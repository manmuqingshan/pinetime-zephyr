%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}




\title{open source watch Documentation}
\date{Dec 04, 2021}
\release{1.2.0}
\author{jj}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}
\noindent\sphinxincludegraphics{{zephyr_logo}.png}




\chapter{Copyright}
\label{\detokenize{copyright:copyright}}\label{\detokenize{copyright::doc}}
\sphinxAtStartPar
The book is subject to copyright.

\sphinxAtStartPar
You cannot use the book, or parts of the book into your own publications, without the permission of the author.

\sphinxAtStartPar
I have put in most of the code a copyright with my mail address.
This does not mean anything. It is just to let you know I modified existing code. The code has been tampered with …


\section{author:}
\label{\detokenize{copyright:author}}
\sphinxAtStartPar
Jan Jansen
\sphinxhref{mailto:najnesnaj@yahoo.com}{najnesnaj@yahoo.com}


\section{LICENSE:}
\label{\detokenize{copyright:license}}
\sphinxAtStartPar
All the software is subject to the Apache 2.0 license (same as the Zephyr RTOS)
A permissive license whose main conditions require preservation of copyright and license notices. Contributors provide an express grant of patent rights. Licensed works, modifications, and larger works may be distributed under different terms and without source code.

\sphinxAtStartPar
You could use nRF Connect SDK (often referred as NCS),it is Nordic Semiconductor SDK based on zephyr. It has additional features that could be useful for pinetime, namely bluetooth modules and bluetooth services. Important to mention that even though, NCS forks zephyr it is kept close to it and it is regularly updated to latest zephyr (typically every 2\sphinxhyphen{}3 weeks).

\sphinxAtStartPar
NCS is using BSD\sphinxhyphen{}5\sphinxhyphen{}Clause\sphinxhyphen{}Nordic license (\sphinxurl{https://github.com/NordicPlayground/fw-nrfconnect-nrf/blob/master/LICENSE})
which is why I did not use their samples.

\sphinxAtStartPar
(see also : bluetooth serial communication)


\chapter{Zephyr  smartwatch framework}
\label{\detokenize{content:zephyr-smartwatch-framework}}\label{\detokenize{content::doc}}
\sphinxAtStartPar
Suppose you want to build a cycle computer quickly.
You need :
\sphinxhyphen{} bluetooth
\sphinxhyphen{} a touchscreen
\sphinxhyphen{} a button
\sphinxhyphen{} time (clock)
\sphinxhyphen{} a method of setting the clock
\sphinxhyphen{} wireless firmware updating
\sphinxhyphen{} timer functions
\sphinxhyphen{} power saving
\sphinxhyphen{} battery management
\sphinxhyphen{} several graphical screens, with buttons graphics

\sphinxAtStartPar
You could start from scratch, or use a framework and only add the stuff you need for your cycling computer :
\sphinxhyphen{} cadence sensor
\sphinxhyphen{} display speed
\sphinxhyphen{} record speed

\sphinxAtStartPar
Suppose you have an idea for a portable device, before running to the shop to buy a dev\sphinxhyphen{}board, develop hardware ….
You could use the framework as a starting point, since it supports a virtual posix\sphinxhyphen{}board.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{this} \PYG{n}{document} \PYG{n}{started} \PYG{n}{off} \PYG{o+ow}{in} \PYG{n}{setting} \PYG{n}{up} \PYG{n}{zephyr} \PYG{n}{RTOS} \PYG{n}{on} \PYG{n}{the} \PYG{n}{PineTime} \PYG{n}{smartwatch}\PYG{o}{.}

\PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{wiki}\PYG{o}{.}\PYG{n}{pine64}\PYG{o}{.}\PYG{n}{org}\PYG{o}{/}\PYG{n}{index}\PYG{o}{.}\PYG{n}{php}\PYG{o}{/}\PYG{n}{PineTime}

\PYG{n}{It} \PYG{n}{evolved} \PYG{n}{to} \PYG{n}{accomodate} \PYG{n}{other} \PYG{n}{nordic} \PYG{n}{nrf52832} \PYG{n}{based} \PYG{n}{watches} \PYG{p}{(}\PYG{n}{Desay} \PYG{n}{D6}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{a} \PYG{n}{Virtual} \PYG{n}{watch} \PYG{p}{(}\PYG{n}{native\PYGZus{}posix\PYGZus{}64}\PYG{p}{)}

\PYG{n}{Zephyr} \PYG{n}{allows} \PYG{k}{for} \PYG{n}{hardware} \PYG{n}{abstraction}\PYG{o}{.} \PYG{n}{The} \PYG{n}{framework} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{limited} \PYG{n}{to} \PYG{n}{Nordic} \PYG{n}{nrf52}\PYG{o}{.}
\PYG{n}{In} \PYG{n}{theory} \PYG{p}{:} \PYG{n}{compiling} \PYG{k}{with} \PYG{n}{a} \PYG{n}{different} \PYG{n}{board} \PYG{n}{definition} \PYG{n}{file} \PYG{n}{should} \PYG{n}{be} \PYG{n}{enough}\PYG{o}{.} \PYG{p}{(}\PYG{n}{minor} \PYG{n}{changes} \PYG{n}{might} \PYG{n}{be} \PYG{n}{necessary} \PYG{o}{\PYGZhy{}} \PYG{n}{see} \PYG{n}{the} \PYG{n}{button} \PYG{n}{sample}\PYG{p}{)}


\PYG{n}{The} \PYG{n}{virtual} \PYG{n}{watch} \PYG{n}{lets} \PYG{n}{you} \PYG{n}{create} \PYG{o+ow}{and} \PYG{n}{debug} \PYG{n}{software} \PYG{n}{without} \PYG{n}{a} \PYG{n}{watch} \PYG{n}{nor} \PYG{n}{a} \PYG{n}{debugprobe}\PYG{o}{.} \PYG{p}{(}\PYG{o}{=}\PYG{n}{cheap}\PYG{p}{)}
\PYG{n}{There} \PYG{n}{exist} \PYG{n}{a} \PYG{n}{lot} \PYG{n}{of} \PYG{n}{cheap} \PYG{p}{(}\PYG{n}{chinese}\PYG{p}{)} \PYG{n}{watches} \PYG{n}{based} \PYG{n}{on} \PYG{n}{Nordic} \PYG{n}{microcontrollers}\PYG{o}{.}
\PYG{n}{The} \PYG{n}{hardware} \PYG{n}{will} \PYG{n}{probably} \PYG{n}{differ}\PYG{p}{,} \PYG{n}{but} \PYG{k}{with} \PYG{n}{minor} \PYG{n}{adjustments} \PYG{n}{it} \PYG{n}{should} \PYG{n}{be} \PYG{n}{possible} \PYG{n}{to} \PYG{n}{adapt} \PYG{n}{the} \PYG{n}{framework}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{the} \PYG{n}{approach} \PYG{o+ow}{in} \PYG{n}{this} \PYG{n}{manual} \PYG{o+ow}{is} \PYG{n}{to} \PYG{n}{get} \PYG{n}{quick} \PYG{n}{results} \PYG{p}{:}
    \PYG{o}{\PYGZhy{}} \PYG{n}{minimal} \PYG{n}{effort} \PYG{n}{install}
    \PYG{o}{\PYGZhy{}} \PYG{k}{try} \PYG{n}{out} \PYG{n}{the} \PYG{n}{samples}
    \PYG{o}{\PYGZhy{}} \PYG{n}{inspire} \PYG{n}{you} \PYG{n}{to} \PYG{n}{modify} \PYG{o+ow}{and} \PYG{n}{enhance}


\PYG{n}{The} \PYG{n}{masterpiece} \PYG{o+ow}{is} \PYG{n}{the} \PYG{n}{firmware} \PYG{n}{toolkit}\PYG{o}{.}
\PYG{n}{Since} \PYG{n}{it} \PYG{o+ow}{is} \PYG{n}{a} \PYG{n}{big} \PYG{n}{chunk} \PYG{n}{of} \PYG{n}{code}\PYG{p}{,} \PYG{n}{you} \PYG{n}{might} \PYG{n}{be} \PYG{n}{lost}\PYG{o}{.}

\PYG{n}{The} \PYG{n}{samples} \PYG{o+ow}{in} \PYG{n}{the} \PYG{o}{/}\PYG{n}{app} \PYG{n}{directory}\PYG{p}{,} \PYG{n}{contain} \PYG{n}{parts} \PYG{n}{of} \PYG{n}{the} \PYG{n}{toolkit}\PYG{o}{.}
\PYG{n}{Like} \PYG{n}{building} \PYG{n}{blocks}\PYG{p}{,} \PYG{n}{which} \PYG{n}{form} \PYG{n}{the} \PYG{n}{final} \PYG{n}{firmware}\PYG{o}{.}
\end{sphinxVerbatim}
\begin{description}
\item[{suggestion :}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
follow the Zephyr installation instructions

\item {} 
\sphinxAtStartPar
try some examples

\item {} 
\sphinxAtStartPar
if you like it copy the /app directory for some more fun

\end{itemize}

\end{description}

\noindent\sphinxincludegraphics{{PineTime-830x400}.png}


\chapter{Howto use the framework ?}
\label{\detokenize{usage:howto-use-the-framework}}\label{\detokenize{usage::doc}}

\section{Boards}
\label{\detokenize{usage:boards}}\begin{description}
\item[{This framework is build around 3 watches :}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
desay D6

\item {} 
\sphinxAtStartPar
pinetime

\item {} 
\sphinxAtStartPar
simulated X86

\end{itemize}

\end{description}

\sphinxAtStartPar
Each of these watches has its own board definition file.

\sphinxAtStartPar
While using the framework for a different setup, you will need a specific board definition file.
This can easily be created, modifying an existing one.


\section{Complexity}
\label{\detokenize{usage:complexity}}
\sphinxAtStartPar
As you add more features, the complexity and(!) code increases.

\sphinxAtStartPar
An incremental approach has been used : from simple to more complex.
\begin{itemize}
\item {} 
\sphinxAtStartPar
oswatch

\item {} 
\sphinxAtStartPar
oswatch\sphinxhyphen{}cts

\item {} 
\sphinxAtStartPar
oswatch\sphinxhyphen{}bt

\item {} 
\sphinxAtStartPar
oswatch\sphinxhyphen{}calendar

\item {} 
\sphinxAtStartPar
oswatch\sphinxhyphen{}lowpower

\item {} 
\sphinxAtStartPar
oswatch\sphinxhyphen{}battery

\item {} 
\sphinxAtStartPar
oswatch\sphinxhyphen{}fota

\end{itemize}

\sphinxAtStartPar
(each extends the functionality of the previous one)


\section{Samples}
\label{\detokenize{usage:samples}}
\sphinxAtStartPar
As the firmware can be a bit overwhelming, a sample directory is provided.
These samples can be installed and tested.
Their purpose is to clarify certain functionality.
Suppose you want to know how to use bluetooth notification, you can compile/install/use the smaller sample.


\section{Bluetooth}
\label{\detokenize{usage:bluetooth}}\begin{quote}

\sphinxAtStartPar
( oswatch\sphinxhyphen{}cts )
( oswatch\sphinxhyphen{}bt )
\end{quote}

\sphinxAtStartPar
I have used Bluez on linux, and python scripts to communicate with the watch.

\sphinxAtStartPar
Maybe there are other ways (android), but you would probably need to write apps or are limited to the functionality of existing apps.

\sphinxAtStartPar
The python scripts can easily be extended and provide a good way to automate the communication process (eg when you need to communicate with multiple watches or in case of the internet of things)


\section{Power saving}
\label{\detokenize{usage:power-saving}}\begin{quote}

\sphinxAtStartPar
( oswatch\sphinxhyphen{}battery )
\end{quote}

\sphinxAtStartPar
Power saving makes sense when the device is battery operated, which is probably not always the case.


\section{Updating over the air}
\label{\detokenize{usage:updating-over-the-air}}\begin{quote}

\sphinxAtStartPar
( oswatch\sphinxhyphen{}fota )
\end{quote}

\sphinxAtStartPar
Firmware updating over the air in zephyr should be failsafe.
As a consequence you need space for 2 images. 1 working and 1 updating.
If the update process fails, you can carry on.

\sphinxAtStartPar
The space can be a challenge if you do not have extra flash memory. (512 / 2 = 256)


\chapter{The idea behind the framework}
\label{\detokenize{idea:the-idea-behind-the-framework}}\label{\detokenize{idea::doc}}
\sphinxAtStartPar
I adapted the pinetime hypnos firmware to run on the Desay D6 smartwatch.

\sphinxAtStartPar
This watch has a small (128x32) oled display and is rather minimalistic.

\sphinxAtStartPar
It does not have a touchscreen, but a single touch button.

\sphinxAtStartPar
One cannot run the software of a feature\sphinxhyphen{}rich smartwatch on a simple one.
But the reverse can be done.


\section{Building blocks}
\label{\detokenize{idea:building-blocks}}
\sphinxAtStartPar
A smartwatch has drivers for motion sensors, bluetooth, HR sensor, a battery, a screen, uses a clock, sets the clock, has a button…

\sphinxAtStartPar
If all put together, you’ll end up with the firmware and a big chunk of code.

\sphinxAtStartPar
This project explores features separately, in the “samples” directory.

\sphinxAtStartPar
Reading out a button, how is it done? How do you make a distinction between click, double click, long press? You can find this in the samples directory. These resembles building blocks or modules.

\sphinxAtStartPar
The oswatch\sphinxhyphen{}xxxx directories assemble some of the building blocks.

\sphinxAtStartPar
The oswatch\sphinxhyphen{}cts shows how the time is set with bluetooth, but also uses the button, the screen, the clock.

\sphinxAtStartPar
Oswatch\sphinxhyphen{}full would include everything.

\sphinxAtStartPar
For your own project you can choose the oswatch\sphinxhyphen{}template which suits you most.


\section{Screen}
\label{\detokenize{idea:screen}}
\sphinxAtStartPar
The OLED screen can only display a few lines.
This is used as a basis for screen layout.

\sphinxAtStartPar
Multiple screens can be displayed, but each screen has little info.


\section{Touchscreen}
\label{\detokenize{idea:touchscreen}}
\sphinxAtStartPar
Although the LVGL graphics library offers touchscreen support and the Pinetime watch has a touchscreen, the emphasis was put on the side button. Most watches have a button.

\sphinxAtStartPar
Selecting a screen and a parameter on the screen is done with the button instead of the touchscreen.


\section{Heart rate sensor}
\label{\detokenize{idea:heart-rate-sensor}}
\sphinxAtStartPar
Most heart rate sensors have a light sensor and an LED.
Instead of trying to get a heart rate out of it.
Emphasis was put on reading out the light sensor and controlling the LED.

\sphinxAtStartPar
This way my cheap oled watch can be used to read out LED signals, and thus be used as a communication device.

\sphinxAtStartPar
The LED cannot be controlled independently on the pinetime. Suppose you want to use the lightsensor without the led, it is not possible.


\section{Bluetooth}
\label{\detokenize{idea:bluetooth}}
\sphinxAtStartPar
Setting time and timers or other parameters is a nuisance on a small device. It is far more easier to set/read parameters on a linux box or android device and transfer them to the smartwatch.

\sphinxAtStartPar
The easiest would be to use bluetooth UART, this is not a part of the open source zephyr (apache 2 license) , but belongs to Nordic. (which supply their own version of zephyr)

\sphinxAtStartPar
The idea I will explore is to use 2 bluetoothservices, one to request and one to supply the value of a parameter.

\sphinxAtStartPar
Bluetooth is used to set the time (CTS) current time service.


\section{Power saving}
\label{\detokenize{idea:power-saving}}
\sphinxAtStartPar
Power saving makes sense when the device is battery operated, which is probably not always the case.
Hence, power saving is an option.


\section{Updating over the air}
\label{\detokenize{idea:updating-over-the-air}}
\sphinxAtStartPar
FOTA : firmware updating over the air, is a useful option.
The way firmware updates work, is to have two firmware images on the device.
In the case of the cheap OLED device, there is no extra memory to store firmware images.
Hence, FOTA is an option.


\section{Motion sensor}
\label{\detokenize{idea:motion-sensor}}
\sphinxAtStartPar
The motion is used as a stepcounter, but could be used for other purposes as well. Knock sensor, position sensor, movement detection …
emphasis is put on reading out the sensor rather than processing the data.


\section{Drivers}
\label{\detokenize{idea:drivers}}
\sphinxAtStartPar
Creating drivers takes a lot of time. Chances are that a specific driver does not exist for zephyr, or that the standard one does not work fully.

\sphinxAtStartPar
To overcome this problem a zephyr driver that resembles the needed driver is adapted and placed out of tree. In some cases I have not even bothered to change the name. The max30101 lightsensor is not present in the smartwatches I worked with, but it exists as a driver that can easily be adapted. In zephyr this means that the board definition files need to refer to this driver as well. Board definition has to be placed out of tree as well.


\chapter{Install zephyr}
\label{\detokenize{installation:install-zephyr}}\label{\detokenize{installation::doc}}

\section{update on 31\sphinxhyphen{}12\sphinxhyphen{}2020}
\label{\detokenize{installation:update-on-31-12-2020}}
\sphinxAtStartPar
Pinetime has become part of the standard zephyr distribution!

\sphinxAtStartPar
These days you can install zephyr and execute a pinetime sample!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{west} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{pinetime\PYGZus{}devkit0} \PYG{n}{samples}\PYG{o}{/}\PYG{n}{boards}\PYG{o}{/}\PYG{n}{pine64\PYGZus{}pinetime}
\end{sphinxVerbatim}


\section{How to install zephyr}
\label{\detokenize{installation:how-to-install-zephyr}}
\sphinxAtStartPar
\sphinxurl{https://docs.zephyrproject.org/latest/getting\_started/index.html}

\sphinxAtStartPar
the documentation describes an installation process under Ubuntu/macOS/Windows


\section{How to install the open source watch frame kit}
\label{\detokenize{installation:how-to-install-the-open-source-watch-frame-kit}}
\sphinxAtStartPar
The kit should work alongside the zephyr installation.
Just get a copy of the “app” directory.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}work\PYGZgt{}  /app
     ├──/zephyr
     ├──.....
\end{sphinxVerbatim}

\sphinxAtStartPar
the app\sphinxhyphen{}directory contains the drivers and source code and(!) modified board definitions.


\section{Linux rules}
\label{\detokenize{installation:linux-rules}}
\sphinxAtStartPar
The development has been done on a virtual linux machine.
For testing bluetooth functionality, I have used linux as well.
In this manual you’ll find a procedure to communicate to the device from a linux box.
Updating the firmware wireless? Possible from a linux box!

\sphinxAtStartPar
Suppose you want to measure how many steps employees do a day?
You could readout everything using a linux box, and handle the data using all the available tools of the box.

\sphinxAtStartPar
\sphinxstylestrong{TIP : sometimes you run into trouble compiling: removing the build directory can help in that case}


\chapter{Out of tree}
\label{\detokenize{out-of-tree:out-of-tree}}\label{\detokenize{out-of-tree::doc}}
\sphinxAtStartPar
A technique used in zephyr/samples/application\sphinxhyphen{}development, is “out of tree” development.

\sphinxAtStartPar
When you tinker with watches, you will soon find out that not all the drivers exist.

\sphinxAtStartPar
You can adapt existing zephyr drivers, but placing them within the zephyr repository could cause issues (upgrading zephyr).

\sphinxAtStartPar
The samples provided contain the board definition and the drivers within their directory outside the zephyr directory.

\sphinxAtStartPar
Have a look at the samples, on how it is done.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{All} \PYG{n}{the} \PYG{n}{development}\PYG{p}{,} \PYG{n}{board} \PYG{n}{definition} \PYG{n}{files}\PYG{p}{,} \PYG{n}{drivers} \PYG{n}{are} \PYG{n}{contained} \PYG{o+ow}{in} \PYG{n}{the} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{app}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{directory}\PYG{o}{.}
\PYG{n}{Copy} \PYG{n}{this} \PYG{n}{directory} \PYG{n}{alongside} \PYG{n}{the} \PYG{n}{zephyr} \PYG{n}{rtos} \PYG{n}{repository}\PYG{p}{,} \PYG{o+ow}{and} \PYG{n}{it} \PYG{n}{should} \PYG{n}{work}\PYG{o}{.}
\PYG{n}{No} \PYG{n}{extra} \PYG{n}{configuration} \PYG{n}{needed}\PYG{o}{.}
\PYG{n}{You} \PYG{n}{can} \PYG{n}{use} \PYG{n}{the} \PYG{n}{latest} \PYG{n}{Zephyr} \PYG{n}{distribution}\PYG{o}{.}
\end{sphinxVerbatim}


\section{Top Tip:}
\label{\detokenize{out-of-tree:top-tip}}
\sphinxAtStartPar
Adapting an existing driver is easier than writing one from scratch.
In the Kconfig you just set another name : instead of SSD1306, you use SSD1306NEW.
You might need to adapt the board definition file \textless{}watch\textgreater{}.dts as well.
Zephyr stitches together parts based on labels. Make sure they match.


\chapter{display}
\label{\detokenize{display:display}}\label{\detokenize{display:display-sample}}\label{\detokenize{display::doc}}

\section{Display   Types}
\label{\detokenize{display:display-types}}
\sphinxAtStartPar
There are three types of display included.
\begin{itemize}
\item {} 
\sphinxAtStartPar
a st7789 color display used in the pinetime

\item {} 
\sphinxAtStartPar
a monochrome SSD1306 OLED display used in the desay D6

\item {} 
\sphinxAtStartPar
a on\sphinxhyphen{}screen display SDL simulated on linux

\end{itemize}


\subsection{Several methods of using the display}
\label{\detokenize{display:several-methods-of-using-the-display}}
\sphinxAtStartPar
Included in the zephyr distribution are :
\sphinxhyphen{} the Little Graphics Library  (LVGL)
\sphinxhyphen{} Character frame buffer (cfb)

\sphinxAtStartPar
For the pinetime the LVGL library might be a good option, since it has a big screen, colors and (!) is touch sensitive.

\sphinxAtStartPar
For the DS\sphinxhyphen{}D6 which has a monochrome OLED small display, the character frame buffer could be the best option.


\subsection{The human eye}
\label{\detokenize{display:the-human-eye}}
\sphinxAtStartPar
You can print something to the serial port, use the Segger RTT, but having a sample which displays something on the screen is the equivalent of blinking a LED.

\sphinxAtStartPar
Instead of the blinky blinking the LED, most samples include the screen.


\chapter{Starting with some basic applications}
\label{\detokenize{basicapplications:starting-with-some-basic-applications}}\label{\detokenize{basicapplications::doc}}
\sphinxAtStartPar
The best way to get a feel of zephyr for the smartwatch, is to start building applications.

\sphinxAtStartPar
The watch framework is under /app.

\sphinxAtStartPar
The framework contains a clock, bluetooth, a procedure to upgrade over the air, cts  …

\sphinxAtStartPar
To reduce the complexity, samples are provided.
Each sample contains a single feature of the framework.


\section{Push the button}
\label{\detokenize{basicapplications:push-the-button}}\begin{itemize}
\item {} 
\sphinxAtStartPar
A button for the posix simulation watch, is a lvgl push button.

\item {} 
\sphinxAtStartPar
A button for the pinetime is a real button, which needs 2 (!) gpio ports

\item {} 
\sphinxAtStartPar
A button for the Desay D6 is a real button, which needs 1 gpio port.

\end{itemize}

\sphinxAtStartPar
To complicate matters, a button on the pinetime can be both an lvgl button and a  real gpio\sphinxhyphen{}enabled button.

\sphinxAtStartPar
Using a framework, which would suit these watches, needs to distinguish between the boards (use a condition with parameter : CONFIG\_BOARD)


\section{posix}
\label{\detokenize{basicapplications:posix}}

\subsection{Building and Running}
\label{\detokenize{basicapplications:building-and-running}}
\sphinxAtStartPar
The “native\_posix\_64” board is your own linux\sphinxhyphen{}box.
This means that you can execute the code on your system.
You do not need a smartwatch.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b native\PYGZus{}posix\PYGZus{}64 samples/button/sdlbutton}
\end{sphinxVerbatim}

\sphinxAtStartPar
running : ./build/zephyr/zephyr.exe


\section{pinetime}
\label{\detokenize{basicapplications:pinetime}}

\subsection{Building and Running}
\label{\detokenize{basicapplications:id1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime\PYGZus{}devkit1 samples/button/pinebutton}
\end{sphinxVerbatim}

\sphinxAtStartPar
running : west flash


\subsubsection{Reading out the button on the watch}
\label{\detokenize{basicapplications:reading-out-the-button-on-the-watch}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{does} \PYG{n}{have} \PYG{n}{a} \PYG{n}{button} \PYG{n}{on} \PYG{n}{the} \PYG{n}{side}\PYG{o}{.}
\PYG{n}{The} \PYG{n}{desay} \PYG{n}{D6} \PYG{n}{has} \PYG{n}{a} \PYG{n}{touchbutton} \PYG{o+ow}{in} \PYG{n}{front}\PYG{o}{.}
\PYG{n}{The} \PYG{n}{virtual} \PYG{n}{POSIX} \PYG{n}{watch} \PYG{n}{has} \PYG{n}{a} \PYG{n}{touchbutton}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Note:}:
\sphinxtitleref{The pinetime watch has a button out port (15) and button in port (13). You have to set the out\sphinxhyphen{}port high. Took me a while to figure this out…}


\chapter{LittlevGL Basic Sample}
\label{\detokenize{lvgl:littlevgl-basic-sample}}\label{\detokenize{lvgl:lvgl-sample}}\label{\detokenize{lvgl::doc}}

\section{Overview}
\label{\detokenize{lvgl:overview}}
\sphinxAtStartPar
This sample application displays “Hello World” in the center of the screen
and a counter at the bottom which increments every second.

\sphinxAtStartPar
LittlevGL is a free and open\sphinxhyphen{}source graphics library providing everything you need to create embedded GUI with easy\sphinxhyphen{}to\sphinxhyphen{}use graphical elements, beautiful visual effects and low memory footprint.


\section{Simulation}
\label{\detokenize{lvgl:simulation}}
\sphinxAtStartPar
In order to avoid uploading to check what the display looks like, there is a simple way to simulate this.
I’ve tested this on Ubuntu 18.04 64bit. You’ll need the SDL2 library.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b native\PYGZus{}posix\PYGZus{}64 samples/display/lvgl}
\end{sphinxVerbatim}

\sphinxAtStartPar
after the building, you can find build/zephyr/zephyr.exe (and execute this to see display\sphinxhyphen{}layout)

\sphinxAtStartPar
the sample is provided as samples/display/lvgl\sphinxhyphen{}posix


\section{Pinetime}
\label{\detokenize{lvgl:pinetime}}
\sphinxAtStartPar
The program has been modified to light up the background leds.

\sphinxAtStartPar
\sphinxstylestrong{TIP: matching label : DISPLAY}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Matching labels are necessary!
pinetime.conf:CONFIG\PYGZus{}LVGL\PYGZus{}DISPLAY\PYGZus{}DEV\PYGZus{}NAME=\PYGZdq{}DISPLAY\PYGZdq{}
pinetime.overlay:               label = \PYGZdq{}DISPLAY\PYGZdq{}; (spi definition)
\end{sphinxVerbatim}


\section{Building and Running}
\label{\detokenize{lvgl:building-and-running}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/lvgl}
\end{sphinxVerbatim}


\subsection{modifying the font size :}
\label{\detokenize{lvgl:modifying-the-font-size}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}t menuconfig}
\end{sphinxVerbatim}
\begin{description}
\item[{goto:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
additional libraries

\item {} 
\sphinxAtStartPar
lvgl gui library

\end{itemize}

\sphinxAtStartPar
(look for fonts, and adapt according to your need)

\end{description}


\subsection{apply changes of the changed config:}
\label{\detokenize{lvgl:apply-changes-of-the-changed-config}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build}
\end{sphinxVerbatim}

\sphinxAtStartPar
(instead of west build \sphinxhyphen{}p (pristine) which wipes out your customisation)


\section{References}
\label{\detokenize{lvgl:references}}
\sphinxAtStartPar
\sphinxurl{https://docs.littlevgl.com/en/html/index.html}

\sphinxAtStartPar
LittlevGL Web Page: \sphinxurl{https://littlevgl.com/}


\chapter{Real Time Clock}
\label{\detokenize{RTC:real-time-clock}}\label{\detokenize{RTC:rtc}}\label{\detokenize{RTC::doc}}
\sphinxAtStartPar
The compile\sphinxhyphen{}time is used to set the initial time. (CMAKE file)

\sphinxAtStartPar
The elapsed time since the startup can be calculated.

\sphinxAtStartPar
Setting the exact time is done via bluetooth current time service. (oswatch\sphinxhyphen{}cts)


\section{Alarm}
\label{\detokenize{RTC:alarm}}
\sphinxAtStartPar
A cool feature, once you get a clock is an alarm. (oswatch\sphinxhyphen{}calendar)

\sphinxAtStartPar
You can set/stop the alarm.

\sphinxAtStartPar
Once set : the value of the “timer1” parameter is added to the current time.
Everytime the clock is updated, there is a check if the alarm\sphinxhyphen{}time has been reached.

\sphinxAtStartPar
The name (oswatch\sphinxhyphen{}calendar) was ambitious, but a more elaborate setup is possible using the same technique. (year month day hour minute needed as a parameter for a real calendar event)


\section{References}
\label{\detokenize{RTC:references}}

\chapter{Current Time Service}
\label{\detokenize{current-time:current-time-service}}\label{\detokenize{current-time::doc}}
\sphinxAtStartPar
\sphinxurl{https://www.bluetooth.com/specifications/gatt/services/}

\sphinxAtStartPar
\sphinxurl{https://www.bluetooth.com/specifications/gatt/characteristics/}
\begin{itemize}
\item {} 
\sphinxAtStartPar
0x1805 current time service

\item {} 
\sphinxAtStartPar
0x2A2B current time characteristic

\end{itemize}


\section{Requirements:}
\label{\detokenize{current-time:requirements}}\begin{description}
\item[{You need :}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{a CTS server (use of bluez on linux explained, and android!)}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
start the CTS service (python script: gatt\sphinxhyphen{}cts\sphinxhyphen{}server.py provided)

\item {} 
\sphinxAtStartPar
connect to the CTS client

\end{itemize}

\end{description}

\item {} 
\sphinxAtStartPar
a CTS client (the oswatch)

\end{itemize}

\end{description}


\section{BLE Peripheral CTS sample for zephyr}
\label{\detokenize{current-time:ble-peripheral-cts-sample-for-zephyr}}
\sphinxAtStartPar
This example demonstrates the basic usage of the current time service.
It is based on the \sphinxurl{https://github.com/Dejvino/pinetime-hermes-firmware}.

\sphinxAtStartPar
It starts advertising it’s UUID, and you can connect to it.
Once connected, it will read the time from your CTS server
(bluez on linux running the gatt\sphinxhyphen{}cts\sphinxhyphen{}server script in my case)

\sphinxAtStartPar
first build the image

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}  }west build \PYGZhy{}p \PYGZhy{}b pinetime\PYGZus{}devkit1 oswatch\PYGZhy{}cts
\end{sphinxVerbatim}


\section{Using bluez on linux to connect}
\label{\detokenize{current-time:using-bluez-on-linux-to-connect}}
\sphinxAtStartPar
The pinetime zephyr sample behaves as a peripheral:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZhy{} make sure your linuxbox has bluez running (type bluetoothctl if you\PYGZsq{}re not sure)}
\PYG{g+go}{\PYGZhy{} first of all start the cts service : python gatt\PYGZhy{}cts\PYGZhy{}server.py}
\PYG{g+go}{\PYGZhy{} connect to the pinetime with bluetoothctl}
\end{sphinxVerbatim}

\sphinxAtStartPar
Using bluetoothctl:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}bluetoothctl
\PYG{g+gp}{[bluetooth]\PYGZsh{}}scan on


\PYG{g+go}{[NEW] Device 60:7C:9E:92:50:C1 Zephyr Peripheral Sample Long}
\PYG{g+go}{once you see your device}
\PYG{g+gp}{[blueooth]\PYGZsh{}}connect \PYG{l+m}{60}:7C:9E:92:50:C1 \PYG{o}{(}the device mac address as displayed\PYG{o}{)}
\end{sphinxVerbatim}


\section{Howto use Bluez on linux to set up a time service}
\label{\detokenize{current-time:howto-use-bluez-on-linux-to-set-up-a-time-service}}
\sphinxAtStartPar
Within the bluez source distribution there is an example GATT (Generic Attribute Profile)server. It advertises some standard service such as heart rate, battery …
Koen zandberg adapted this script, so it advertises the current time :
\sphinxurl{https://github.com/bosmoment/gatt-cts/blob/master/gatt-cts-server.py}

\sphinxAtStartPar
You might have to install extra packages:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{apt\PYGZhy{}get install python\PYGZhy{}dbus}
\PYG{g+go}{apt\PYGZhy{}get install python\PYGZhy{}gi}
\PYG{g+go}{apt\PYGZhy{}get install python\PYGZhy{}gobject}
\end{sphinxVerbatim}


\section{Howto use Android to set up a time service}
\label{\detokenize{current-time:howto-use-android-to-set-up-a-time-service}}
\sphinxAtStartPar
As soon as a device is bonded, Pinetime will look for a CTS server (Current Time Service) on the connected device.
Here is how to do it with an Android smartphone running NRFConnect:

\sphinxAtStartPar
Start NRFConnect and create a CTS server : Tap the hamburger button on the top left and select “Configure GATT server”.

\sphinxAtStartPar
Tap “Add service” on the bottom Select server configuration “Current Time Service”  (0x1805)

\sphinxAtStartPar
Here is for a manual time setup : add the Current Time 0x2A2B characteristic :
in the intial value field add 0x141505130B0D which corresponds to (2021 year 05 month 19 day 11hours 13 minutes)

\sphinxAtStartPar
A device called “PineTime” or “DSD6”, or whichever name you gave it,  should appear.

\sphinxAtStartPar
Tap the button “Connect” next to the PineTime device.

\sphinxAtStartPar
Disconnect and the newly set time should appear.


\chapter{Drivers}
\label{\detokenize{drivers/drivers:drivers}}\label{\detokenize{drivers/drivers:id1}}\label{\detokenize{drivers/drivers::doc}}

\section{configuring I2C}
\label{\detokenize{drivers/i2c:configuring-i2c}}\label{\detokenize{drivers/i2c::doc}}

\subsection{board level definitions}
\label{\detokenize{drivers/i2c:board-level-definitions}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{under} \PYG{n}{boards}\PYG{o}{/}\PYG{n}{arm}\PYG{o}{/}\PYG{n}{pinetime} \PYG{n}{are} \PYG{n}{the} \PYG{n}{board} \PYG{n}{definitions}
\PYG{o}{\PYGZhy{}} \PYG{n}{pinetime}\PYG{o}{.}\PYG{n}{dts}
\PYG{o}{\PYGZhy{}} \PYG{n}{pinetime\PYGZus{}defconfig}


\PYG{n}{The} \PYG{n}{sensors} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{pinetime} \PYG{n}{use} \PYG{n}{the} \PYG{n}{I2C} \PYG{n}{bus}\PYG{o}{.}

\PYG{o}{\PYGZam{}}\PYG{n}{i2c1} \PYG{p}{\PYGZob{}}
        \PYG{n}{compatible} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nordic,nrf\PYGZhy{}twi}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{status} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{okay}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sda}\PYG{o}{\PYGZhy{}}\PYG{n}{pin} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{scl}\PYG{o}{\PYGZhy{}}\PYG{n}{pin} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{7}\PYG{o}{\PYGZgt{}}\PYG{p}{;}

      \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{definition on project level}
\label{\detokenize{drivers/i2c:definition-on-project-level}}
\sphinxAtStartPar
In the directory of a sample, you will find a prj.conf file.
Here you can set values specific for you project/sample.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{In} \PYG{n}{the} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{prj.conf}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{file} \PYG{n}{we} \PYG{n}{define} \PYG{n}{the} \PYG{n}{sensor} \PYG{p}{(}\PYG{n}{eg} \PYG{n}{adxl372}\PYG{p}{)}

\PYG{n}{CONFIG\PYGZus{}STDOUT\PYGZus{}CONSOLE}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}LOG}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}I2C}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}SENSOR}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}ADXL372}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}ADXL372\PYGZus{}I2C}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}SENSOR\PYGZus{}LOG\PYGZus{}LEVEL\PYGZus{}WRN}\PYG{o}{=}\PYG{n}{y}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{note: this gets somehow merged (overlayed) with the board definition pinetime\_defconfig}


\section{SSD1306 modification}
\label{\detokenize{drivers/ssd1306:ssd1306-modification}}\label{\detokenize{drivers/ssd1306::doc}}

\subsection{board level definitions}
\label{\detokenize{drivers/ssd1306:board-level-definitions}}
\sphinxAtStartPar
The desay D6 OLED display gets it power trough a GPIO pin.

\sphinxAtStartPar
In the board definition file one can set it high.

\sphinxAtStartPar
Some minor adjustment in board.c was needed.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{under} \PYG{n}{boards}\PYG{o}{/}\PYG{n}{arm}\PYG{o}{/}\PYG{n}{ds\PYGZus{}d6} \PYG{n}{are} \PYG{n}{the} \PYG{n}{board} \PYG{n}{definitions}
\PYG{o}{\PYGZhy{}} \PYG{n}{ds\PYGZus{}d6}\PYG{o}{.}\PYG{n}{dts}
\PYG{o}{\PYGZhy{}} \PYG{n}{ds\PYGZus{}d6\PYGZus{}defconfig}



\PYG{n}{vdd\PYGZus{}pwr}\PYG{p}{:} \PYG{n}{vdd}\PYG{o}{\PYGZhy{}}\PYG{n}{pwr}\PYG{o}{\PYGZhy{}}\PYG{n}{ctrl} \PYG{p}{\PYGZob{}}
        \PYG{n}{compatible} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{regulator\PYGZhy{}fixed}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{vdd\PYGZhy{}pwr\PYGZhy{}ctrl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{regulator}\PYG{o}{\PYGZhy{}}\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{vdd\PYGZhy{}pwr\PYGZhy{}ctrl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{enable}\PYG{o}{\PYGZhy{}}\PYG{n}{gpios} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZam{}}\PYG{n}{gpio0} \PYG{l+m+mi}{26} \PYG{n}{GPIO\PYGZus{}ACTIVE\PYGZus{}HIGH}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{regulator}\PYG{o}{\PYGZhy{}}\PYG{n}{boot}\PYG{o}{\PYGZhy{}}\PYG{n}{on}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The driver has been placed “out of tree”.
It is a modified ssd1306 driver.
The ssd1306 behaved somewhat differently.
It was renamed to ssd1306new to avoid confusion.
In the board definition file the label was adapted.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ssd1306new}\PYG{o}{@}\PYG{l+m+mi}{0} \PYG{p}{\PYGZob{}}
        \PYG{n}{compatible} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{solomon,ssd1306fb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{spi}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{max}\PYG{o}{\PYGZhy{}}\PYG{n}{frequency} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{80000000}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SSD1306NEW}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{reg} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{segment}\PYG{o}{\PYGZhy{}}\PYG{n}{offset} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{page}\PYG{o}{\PYGZhy{}}\PYG{n}{offset} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{display}\PYG{o}{\PYGZhy{}}\PYG{n}{offset} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{multiplex}\PYG{o}{\PYGZhy{}}\PYG{n}{ratio} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{31}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{height} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{32}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{width} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{128}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{segment}\PYG{o}{\PYGZhy{}}\PYG{n}{remap}\PYG{p}{;}
        \PYG{n}{prechargep} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mh}{0xF1}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{reset}\PYG{o}{\PYGZhy{}}\PYG{n}{gpios} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZam{}}\PYG{n}{gpio0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{data\PYGZus{}cmd}\PYG{o}{\PYGZhy{}}\PYG{n}{gpios} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZam{}}\PYG{n}{gpio0} \PYG{l+m+mi}{28} \PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{definition config}
\label{\detokenize{drivers/ssd1306:definition-config}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{In} \PYG{n}{the} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ds\PYGZus{}d6\PYGZus{}defconfig}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{file} \PYG{n}{we} \PYG{n}{define} \PYG{n}{the} \PYG{n}{driver}


 \PYG{n}{CONFIG\PYGZus{}LVGL\PYGZus{}DISPLAY\PYGZus{}DEV\PYGZus{}NAME}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SSD1306NEW}\PYG{l+s+s2}{\PYGZdq{}}
 \PYG{n}{CONFIG\PYGZus{}SSD1306NEW}\PYG{o}{=}\PYG{n}{y}
\end{sphinxVerbatim}


\section{sensors on the I2C bus}
\label{\detokenize{drivers/sensors:sensors-on-the-i2c-bus}}\label{\detokenize{drivers/sensors::doc}}
\sphinxAtStartPar
0x18: Accelerometer: BMA423\sphinxhyphen{}DS000
\sphinxurl{https://github.com/BoschSensortec/BMA423-Sensor-API}

\sphinxAtStartPar
0x44: Heart Rate Sensor: HRS3300\_Heart

\sphinxAtStartPar
0x15: Touch Controller: Hynitron CST816S Touch Controller


\section{Bosch BMA421}
\label{\detokenize{drivers/bma421:bosch-bma421}}\label{\detokenize{drivers/bma421::doc}}
\sphinxAtStartPar
this driver does not exist, so it has been created.
Still work in progress ….

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/gui/lvaccel}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/bma421:overview}}
\sphinxAtStartPar
BMA421 is not a part number available to the general public, and therefore all the supporting documentation and design resources are neither discussed in public forums, nor disclosed on GitHub.

\sphinxAtStartPar
CHIP\_ID=0X11  (so the Bosch BMA423 drivers need to be adapted)

\sphinxAtStartPar
The Bosch documentation on the bma423 seems to apply to the bma421.


\subsection{Requirements}
\label{\detokenize{drivers/bma421:requirements}}
\sphinxAtStartPar
for this sensor does not exist any driver, so here’s what I did to create one under zephyr


\subsubsection{adapt CMakeLists.txt}
\label{\detokenize{drivers/bma421:adapt-cmakelists-txt}}
\sphinxAtStartPar
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/drivers/sensor
add\_subdirectory\_ifdef(CONFIG\_BMA280            bma280)
add\_subdirectory\_ifdef(CONFIG\_BMA421            bma421)


\subsubsection{adapt Kconfig}
\label{\detokenize{drivers/bma421:adapt-kconfig}}
\sphinxAtStartPar
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/drivers/sensor


\subsubsection{add yaml file}
\label{\detokenize{drivers/bma421:add-yaml-file}}
\sphinxAtStartPar
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/dts/bindings/sensor
cp bosch,bma280\sphinxhyphen{}i2c.yaml  bosch,bma421\sphinxhyphen{}i2c.yaml


\subsubsection{edit KConfig}
\label{\detokenize{drivers/bma421:edit-kconfig}}\begin{description}
\item[{source “drivers/sensor/bma280/Kconfig”}] \leavevmode
\sphinxAtStartPar
source “drivers/sensor/bma421/Kconfig”

\end{description}

\sphinxAtStartPar
source “drivers/sensor/bmc150\_magn/Kconfig”

\sphinxAtStartPar
source “drivers/sensor/bme280/Kconfig”


\subsubsection{create driver}
\label{\detokenize{drivers/bma421:create-driver}}
\sphinxAtStartPar
see under drivers/sensor/bma421

\sphinxAtStartPar
complement the pinetime.dts file with the following (under samples/sensor/bma280)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        bma421@18 \PYGZob{}}
\PYG{g+go}{                   compatible = \PYGZdq{}bosch,bma421\PYGZdq{};}
\PYG{g+go}{                   reg = \PYGZlt{}0x18\PYGZgt{};}
\PYG{g+go}{                   label = \PYGZdq{}BMA421\PYGZdq{};}
\PYG{g+go}{                   int1\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 8 0\PYGZgt{};}
\PYG{g+go}{                  \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}

\sphinxAtStartPar
Create a file: \sphinxtitleref{/dts/bindings/sensor/bosch,bma421\sphinxhyphen{}i2c.yaml}.
Which contains:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{compatible}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bosch,bma421}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{include}\PYG{p}{:} \PYG{n}{i2c}\PYG{o}{\PYGZhy{}}\PYG{n}{device}\PYG{o}{.}\PYG{n}{yaml}
\PYG{n}{properties}\PYG{p}{:}
       \PYG{n}{int1}\PYG{o}{\PYGZhy{}}\PYG{n}{gpios}\PYG{p}{:}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{phandle}\PYG{o}{\PYGZhy{}}\PYG{n}{array}
       \PYG{n}{required}\PYG{p}{:} \PYG{n}{false}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/bma421:building-and-running}}

\subsection{Todo}
\label{\detokenize{drivers/bma421:todo}}\begin{itemize}
\item {} 
\sphinxAtStartPar
the driver is interrupt driven as well \textendash{} need to test software

\item {} 
\sphinxAtStartPar
the sensor has algorithm for steps \textendash{} read out register

\item {} 
\sphinxAtStartPar
temperature some attempt has been made, but … (OK, temp can be read)

\end{itemize}


\subsection{References}
\label{\detokenize{drivers/bma421:references}}
\sphinxAtStartPar
Bosch has documented the BMA423 very well.
I kind of hope it will apply to the bma421.

\sphinxAtStartPar
A mechanism to adapt the 0x5E register is provided.
(burst read/write)

\sphinxAtStartPar
All kind of parameters can be set to trigger an interrupt.
(e.g. number of steps taken : think of the 10000 steps threshold)


\section{HYNITRON CST816S}
\label{\detokenize{drivers/cst816s:hynitron-cst816s}}\label{\detokenize{drivers/cst816s::doc}}
\sphinxAtStartPar
Zephyr has evolved and now there is something that serve as a touchscreen device.
(KSCAN\_TOUCH)

\sphinxAtStartPar
the board definition file has been adapted slightly, using the focaltech ft5336 as a touch\_controller. A minor change in this driver is enough to get data from the hynitron cst816S.

\sphinxAtStartPar
The big advantage : almost standard zephyr install!
Unfortunately I cannot get the KSCAN\_TOUCH working in an out\sphinxhyphen{}of\sphinxhyphen{}tree setup.

\sphinxAtStartPar
I have created the renamed ft9999 driver.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime\PYGZus{}devkit0 samples/display/lvgl}
\end{sphinxVerbatim}

\sphinxAtStartPar
this driver does not exist, so it has been created.
Still work in progress ….


\subsection{Overview}
\label{\detokenize{drivers/cst816s:overview}}
\sphinxAtStartPar
(this is the old way of doing things ….)

\sphinxAtStartPar
the Hynitron cst816s is a touchscreen.
Zephyr doesn’t handle touchscreens yet.
In order to investigate, the touchscreen driver has been created as a sensor.
In fact it senses your finger ;)


\subsection{Requirements}
\label{\detokenize{drivers/cst816s:requirements}}
\sphinxAtStartPar
for this sensor does not exist any driver, so here’s what I did to create one under zephyr

\sphinxAtStartPar
adapt CMakeLists.txt
adapt Kconfig
add yaml file


\subsubsection{create driver}
\label{\detokenize{drivers/cst816s:create-driver}}
\sphinxAtStartPar
The driver reads only one position.
Multitouch is possible, but the screen is small….

\sphinxAtStartPar
see under drivers/sensor/cst816s

\sphinxAtStartPar
have a look at the pinetime.dts (under board/arm/pinetime) file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        cst816s@15 \PYGZob{}}
\PYG{g+go}{                   compatible = \PYGZdq{}hynitron,cst816s\PYGZdq{};}
\PYG{g+go}{                   reg = \PYGZlt{}0x15\PYGZgt{};}
\PYG{g+go}{                   label = \PYGZdq{}CST816S\PYGZdq{};}
\PYG{g+go}{                   \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/cst816s:building-and-running}}\begin{description}
\item[{There are two samples :}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
samples/gui/lvtouch (graphical)

\item {} 
\sphinxAtStartPar
samples/sensor/cst816s (no graphics)

\end{itemize}

\end{description}


\subsection{Todo}
\label{\detokenize{drivers/cst816s:todo}}
\sphinxAtStartPar
The graphical sample doesn’t handle interrupts.


\subsection{References}
\label{\detokenize{drivers/cst816s:references}}
\sphinxAtStartPar
There is little available for this touchscreen.


\section{HX HRS3300}
\label{\detokenize{drivers/hrs3300:hx-hrs3300}}\label{\detokenize{drivers/hrs3300::doc}}
\sphinxAtStartPar
this driver does not exist, so it has been created.
Still work in progress ….

\sphinxAtStartPar
there is a sample in this repository which can be copied to the zephyr samples directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/sensor/hrs3300}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/hrs3300:overview}}
\sphinxAtStartPar
The HX HRS3300 sensor is a heart rate sensor, it produces 2 values: ALS and HRS. Ambient LIGHT SENSOR and HEART RATE SENSOR. Which have to be processed by an algorithm. I have no knowledge of a good open source algorithm yet.

\sphinxAtStartPar
I have used the settings of an arduino port of this library.

\noindent\sphinxincludegraphics{{hrs3300}.jpg}


\subsection{Requirements}
\label{\detokenize{drivers/hrs3300:requirements}}
\sphinxAtStartPar
for this sensor does not exist any driver, so here’s what I did to create one under zephyr


\subsubsection{adapt CMakeLists.txt}
\label{\detokenize{drivers/hrs3300:adapt-cmakelists-txt}}
\sphinxAtStartPar
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/drivers/sensor
add\_subdirectory\_ifdef(CONFIG\_HRS3300           hrs3300)


\subsubsection{adapt Kconfig}
\label{\detokenize{drivers/hrs3300:adapt-kconfig}}
\sphinxAtStartPar
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/drivers/sensor


\subsubsection{add yaml file}
\label{\detokenize{drivers/hrs3300:add-yaml-file}}
\sphinxAtStartPar
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/dts/bindings/sensor
add  hx,hrs3300.yaml


\subsubsection{edit KConfig}
\label{\detokenize{drivers/hrs3300:edit-kconfig}}
\sphinxAtStartPar
source “drivers/sensor/hrs3300/Kconfig”


\subsubsection{create driver}
\label{\detokenize{drivers/hrs3300:create-driver}}
\sphinxAtStartPar
see under drivers/sensor/hrs3300

\sphinxAtStartPar
complement the pinetime.dts file with the following (under samples/sensor/bma280)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        hrs3300@44 \PYGZob{}}
\PYG{g+go}{                   compatible = \PYGZdq{}hx,hrs3300\PYGZdq{};}
\PYG{g+go}{                   reg = \PYGZlt{}0x44\PYGZgt{};}
\PYG{g+go}{                   label = \PYGZdq{}HRS3300\PYGZdq{};}
\PYG{g+go}{                   \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}

\sphinxAtStartPar
Create a file: \sphinxtitleref{/dts/bindings/sensor/hx,hrs3300.yaml}.
Which contains:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{compatible}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hx,hrs3300}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{properties}\PYG{p}{:}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/hrs3300:building-and-running}}

\subsection{Todo}
\label{\detokenize{drivers/hrs3300:todo}}\begin{itemize}
\item {} 
\sphinxAtStartPar
algorithm for heartrate

\item {} 
\sphinxAtStartPar
power saving

\item {} 
\sphinxAtStartPar
switching off/on mechanism

\end{itemize}


\subsection{References}
\label{\detokenize{drivers/hrs3300:references}}
\sphinxAtStartPar
HRS3300 Heart Rate Sensor.pdf
\sphinxurl{https://github.com/atc1441/HRS3300-Arduino-Library}


\section{Serial Nor Flash}
\label{\detokenize{drivers/spinor:serial-nor-flash}}\label{\detokenize{drivers/spinor::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/spi\PYGZus{}flash \PYGZhy{}DCONF=prj.conf}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/spinor:overview}}
\sphinxAtStartPar
This sample application should unlock the serial nor flash memory.
This can be very useful to store e.g. background for the watch.

\sphinxAtStartPar
compilation problematic ….

\sphinxAtStartPar
/root/zephyrproject/zephyr/samples/drivers/spi\_flash/src/main.c:17:22: error: ‘DT\_INST\_0\_JEDEC\_SPI\_NOR\_LABEL’ undeclared (first use in this function); did you mean ‘DT\_INST\_0\_NORDIC\_NRF\_RTC\_LABEL’?

\sphinxAtStartPar
Turns out this is some problem with the board definition file.

\sphinxAtStartPar
I found it to be very useful to consult the generated dts file.
Here you can check if everything is present.

\sphinxAtStartPar
Guess the dts\sphinxhyphen{}file has to be well intended.(structured)

\sphinxAtStartPar
{\color{red}\bfseries{}**}TIP: consult the generated dts board file **


\subsubsection{consulting the generated board definition file}
\label{\detokenize{drivers/spinor:consulting-the-generated-board-definition-file}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{vi /root/zephyrproject/zephyr/build/zephyr/include/generated/generated\PYGZus{}dts\PYGZus{}board.conf}
\end{sphinxVerbatim}


\subsection{Requirements}
\label{\detokenize{drivers/spinor:requirements}}
\sphinxAtStartPar
complement the pinetime.dts file with the following (under spi)
\#define JEDEC\_ID\_MACRONIX\_MX25L64      0xC22017

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}spi0 \PYGZob{}}
\PYG{g+go}{  compatible = \PYGZdq{}nordic,nrf\PYGZhy{}spi\PYGZdq{};}
\PYG{g+go}{  status = \PYGZdq{}okay\PYGZdq{};}
\PYG{g+go}{  sck\PYGZhy{}pin = \PYGZlt{}2\PYGZgt{};}
\PYG{g+go}{  mosi\PYGZhy{}pin = \PYGZlt{}3\PYGZgt{};}
\PYG{g+go}{  miso\PYGZhy{}pin = \PYGZlt{}4\PYGZgt{};}
\PYG{g+go}{  cs\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 27 0\PYGZgt{},\PYGZlt{}\PYGZam{}gpio0 5 0\PYGZgt{};}
\PYG{g+go}{  st7789v@0 \PYGZob{}}
\PYG{g+go}{          compatible = \PYGZdq{}sitronix,st7789v\PYGZdq{};}
\PYG{g+go}{          label = \PYGZdq{}DISPLAY\PYGZdq{};}
\PYG{g+go}{          spi\PYGZhy{}max\PYGZhy{}frequency = \PYGZlt{}8000000\PYGZgt{};}
\PYG{g+go}{          reg = \PYGZlt{}0\PYGZgt{};}
\PYG{g+go}{          cmd\PYGZhy{}data\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 18 0\PYGZgt{};}
\PYG{g+go}{          reset\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 26 0\PYGZgt{};}
\PYG{g+go}{          width = \PYGZlt{}240\PYGZgt{};}
\PYG{g+go}{          height = \PYGZlt{}240\PYGZgt{};}
\PYG{g+go}{          x\PYGZhy{}offset = \PYGZlt{}0\PYGZgt{};}
\PYG{g+go}{          y\PYGZhy{}offset = \PYGZlt{}0\PYGZgt{};}
\PYG{g+go}{          vcom = \PYGZlt{}0x19\PYGZgt{};}
\PYG{g+go}{          gctrl = \PYGZlt{}0x35\PYGZgt{};}
\PYG{g+go}{          vrhs = \PYGZlt{}0x12\PYGZgt{};}
\PYG{g+go}{          vdvs = \PYGZlt{}0x20\PYGZgt{};}
\PYG{g+go}{          mdac = \PYGZlt{}0x00\PYGZgt{};}
\PYG{g+go}{          gamma = \PYGZlt{}0x01\PYGZgt{};}
\PYG{g+go}{          colmod = \PYGZlt{}0x05\PYGZgt{};}
\PYG{g+go}{          lcm = \PYGZlt{}0x2c\PYGZgt{};}
\PYG{g+go}{          porch\PYGZhy{}param = [0c 0c 00 33 33];}
\PYG{g+go}{          cmd2en\PYGZhy{}param = [5a 69 02 01];}
\PYG{g+go}{          pwctrl1\PYGZhy{}param = [a4 a1];}
\PYG{g+go}{          pvgam\PYGZhy{}param = [D0 04 0D 11 13 2B 3F 54 4C 18 0D 0B 1F 23];}
\PYG{g+go}{          nvgam\PYGZhy{}param = [D0 04 0C 11 13 2C 3F 44 51 2F 1F 1F 20 23];}
\PYG{g+go}{          ram\PYGZhy{}param = [00 F0];}
\PYG{g+go}{          rgb\PYGZhy{}param = [CD 08 14];}

\PYG{g+go}{  \PYGZcb{};}

\PYG{g+go}{  mx25r64: mx25r6435f@1 \PYGZob{}}
\PYG{g+go}{          compatible = \PYGZdq{}jedec,spi\PYGZhy{}nor\PYGZdq{};}
\PYG{g+go}{          reg = \PYGZlt{}1\PYGZgt{};}
\PYG{g+go}{          spi\PYGZhy{}max\PYGZhy{}frequency = \PYGZlt{}1000000\PYGZgt{};}
\PYG{g+go}{          label = \PYGZdq{}MX25R64\PYGZdq{};}
\PYG{g+go}{          jedec\PYGZhy{}id = [0b 40 16];}
\PYG{g+go}{          size = \PYGZlt{}67108864\PYGZgt{};}
\PYG{g+go}{          has\PYGZhy{}be32k;}
\PYG{g+go}{  \PYGZcb{};}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/spinor:building-and-running}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/spi\PYGZus{}flash}
\end{sphinxVerbatim}


\subsection{Todo}
\label{\detokenize{drivers/spinor:todo}}\begin{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
detect ID memory  : it is not the macronix one as suggestion on the pinetime website

\end{itemize}

\sphinxAtStartPar
I found the following : jedec\sphinxhyphen{}id = {[}0b 40 16{]}; (OK: can execute sample program)
\begin{itemize}
\item {} 
\sphinxAtStartPar
create working board definition (OK: see above)

\end{itemize}
\end{quote}


\subsection{References}
\label{\detokenize{drivers/spinor:references}}
\sphinxAtStartPar
\sphinxurl{http://files.pine64.org/doc/datasheet/pinetime/MX25L6433F,\%203V,\%2064Mb,\%20v1.6.pdf}


\section{Battery}
\label{\detokenize{drivers/battery:battery}}\label{\detokenize{drivers/battery::doc}}
\sphinxAtStartPar
the samples just gets an analog reading from the battery

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/sensor/battery}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/battery:overview}}
\sphinxAtStartPar
The battery level is measured on port 31, trough an ADC conversion.

\sphinxAtStartPar
voltage = (value * 6)/1024
percentage remaining  ((voltage \sphinxhyphen{} 3.55)*100)*3.9;

\sphinxAtStartPar
A module should be able to report battery status in millivolts and charge level in percentage. Additionally, it should notify when external power is connected and when battery is being charged.
Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
Battery voltage can be in range from 3.0V \sphinxhyphen{} 4.2V (?). Unfortunately, internal reference (0.6V) can only be used for voltages up to 3.6V (due to minimal gain of 1/6). VDD/4 reference can be used with 1/6 gain to measure voltages up to 4.95V. Test is needed to check how accurate is VDD as reference.
Discharge curve (\sphinxurl{https://forum.pine64.org/showthread.php?tid=8147}) will be used to calculate charge level in percent.
Things to consider:
saadc periodical calibration (spec suggests calibration if temperature changes by 10’C)
inaccuracy of results: oversampling? never report higher level than before (if charge not connected), etc.


\subsection{Todo}
\label{\detokenize{drivers/battery:todo}}
\sphinxAtStartPar
check pin when charging


\subsection{References}
\label{\detokenize{drivers/battery:references}}
\sphinxAtStartPar
\sphinxurl{https://forum.pine64.org/showthread.php?tid=8147}


\section{Watchdog}
\label{\detokenize{drivers/watchdog:watchdog}}\label{\detokenize{drivers/watchdog::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/watchdog}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/watchdog:overview}}
\sphinxAtStartPar
Once the pinetime is closed and on your wrist, you still want access.

\sphinxAtStartPar
see : {\hyperref[\detokenize{fota/fota:fota}]{\sphinxcrossref{\DUrole{std,std-ref}{Firmware Over The Air (FOTA)}}}}

\sphinxAtStartPar
Suppose you upload a application which contains a bug, the watch freezes, and … you will have to open it up, connect the SWD …

\sphinxAtStartPar
Here comes the watchdog:
\begin{itemize}
\item {} 
\sphinxAtStartPar
you launch the watchdog

\item {} 
\sphinxAtStartPar
you launch the application

\item {} 
\sphinxAtStartPar
the application feeds the watchdog

\item {} 
\sphinxAtStartPar
if it cannot feed the watchdog, reset to fota, and you can upload another better version …

\end{itemize}


\subsection{Todo}
\label{\detokenize{drivers/watchdog:todo}}
\sphinxAtStartPar
testing


\subsection{References}
\label{\detokenize{drivers/watchdog:references}}

\chapter{bluetooth (BLE)}
\label{\detokenize{bluetooth:bluetooth-ble}}\label{\detokenize{bluetooth::doc}}
\sphinxAtStartPar
Bluetooth is a very nice feature, it lets you exchange data wireless and (!) update firmware wireless.

\sphinxAtStartPar
The PineTime uses a Nordic nrf52832 chip, which has BLE functionality build into it.

\sphinxAtStartPar
To test, you can compile a standard application : Eddy Stone.


\section{A word on bluetooth\sphinxhyphen{}serial communication}
\label{\detokenize{bluetooth:a-word-on-bluetooth-serial-communication}}
\sphinxAtStartPar
Smartwatch manufacturers usually supply you with a smartwatch app.
This app can communicate trough bluetooth, and get/send data to the watch.

\sphinxAtStartPar
Unfortunately this is not a standard Zephyr feature!

\sphinxAtStartPar
You could use nRF Connect SDK (often referred as NCS),it is Nordic Semiconductor SDK based on zephyr. It has additional features that could be useful for pinetime, namely bluetooth modules and bluetooth services. Important to mention that even though, NCS forks zephyr it is kept close to it and it is regularly updated to latest zephyr (typically every 2\sphinxhyphen{}3 weeks).

\sphinxAtStartPar
NCS has no impact on build framework and overall user experience. The only downside I can think of is that NCS is based on older version of zephyr (\textasciitilde{}2 weeks behind).

\sphinxAtStartPar
The main reason why i’m bringing it up is bluetooth shell. Zephyr has very nice shell module with multiple transports (UART, RTT). NCS extends it with bluetooth transport (using Nordic Uart Service) and host tool for using it. There is an application for linux from which you can use shell over bluetooth, get logs, etc.. It is really cool and can be very useful when playing with pinetime where you can get logs or control/tune things with only wireless connection to your PC. Here is a demonstration of bluetooth console used in one of nordic reference kits: \sphinxurl{https://www.youtube.com/watch?v=3KzTfr6S4pg\&t=} . It’s based on nRF5 SDK (not zephyr) but bluetooth shell (and PC tool) was taken from there.

\sphinxAtStartPar
The Nordic UART Service (NUS) shell transport sample demonstrates how to use the receive shell commands from a remote device.

\sphinxAtStartPar
NCS is using BSD\sphinxhyphen{}5\sphinxhyphen{}Clause\sphinxhyphen{}Nordic license (\sphinxurl{https://github.com/NordicPlayground/fw-nrfconnect-nrf/blob/master/LICENSE})

\sphinxAtStartPar
Zephyr RTOS and the samples I use/create use the Apache License 2.0.
A permissive license whose main conditions require preservation of copyright and license notices. Contributors provide an express grant of patent rights. Licensed works, modifications, and larger works may be distributed under different terms and without source code.


\section{Eddy Stone}
\label{\detokenize{bluetooth:eddy-stone}}\begin{quote}

\sphinxAtStartPar
see:   \DUrole{xref,std,std-ref}{bluetooth\sphinxhyphen{}eddystone\sphinxhyphen{}sample}
\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{Note:}  compile the provided example, so a build directory gets created

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }west build \PYGZhy{}p \PYGZhy{}b pinetime\PYGZus{}devkit0 samples/bluetooth/eddystone
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{this builds an image, which can be found under the build directory}}


\section{Using the created bluetooth sample:}
\label{\detokenize{bluetooth:using-the-created-bluetooth-sample}}
\sphinxAtStartPar
I use linux with a bluetoothadapter 4.0.
You need to install bluez.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}bluetoothctl
\PYG{g+gp}{[bluetooth]\PYGZsh{}}scan on
\end{sphinxVerbatim}

\sphinxAtStartPar
And your Eddy Stone should be visible.

\sphinxAtStartPar
It is the peripheral which advertises, and the central that reads the data.

\sphinxAtStartPar
A sample which advertises a heartrate :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{west} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{pinetime\PYGZus{}devkit0} \PYG{n}{samples}\PYG{o}{/}\PYG{n}{bluetooth}\PYG{o}{/}\PYG{n}{peripheral\PYGZus{}hr}
\end{sphinxVerbatim}

\sphinxAtStartPar
you could use your smartphone or bluez on linux to read out the heartrate.

\sphinxAtStartPar
Or if you have another watch, the central will connect to the peripheral and read out the heartrate.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{west} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{pinetime\PYGZus{}devkit0} \PYG{n}{samples}\PYG{o}{/}\PYG{n}{bluetooth}\PYG{o}{/}\PYG{n}{central\PYGZus{}hr}
\end{sphinxVerbatim}


\subsection{the no\sphinxhyphen{}bluetooth, no\sphinxhyphen{}watch approach : nrf52\_bsim}
\label{\detokenize{bluetooth:the-no-bluetooth-no-watch-approach-nrf52-bsim}}
\sphinxAtStartPar
Suppose you have no watch, no development board, nor any bluetooth dongles?
You can still test your bluetooth enabled application.
\sphinxurl{https://docs.zephyrproject.org/latest/boards/posix/nrf52\_bsim/doc/index.html}

\sphinxAtStartPar
We follow the same logic, but this time we specify the nrf52\_bsim board.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
west build \PYGZhy{}p \PYGZhy{}b nrf52\PYGZus{}bsim samples/bluetooth/peripheral\PYGZus{}hr
west build \PYGZhy{}p \PYGZhy{}b nrf52\PYGZus{}bsim samples/bluetooth/central\PYGZus{}hr
cp build/zephyr/zephyr.exe  \PYGZdl{}\PYGZob{}BSIM\PYGZus{}OUT\PYGZus{}PATH\PYGZcb{}/bin/bs\PYGZus{}nrf52\PYGZus{}bsim\PYGZus{}samples\PYGZus{}bluetooth\PYGZus{}central\PYGZus{}hr
\end{sphinxVerbatim}

\sphinxAtStartPar
Once compiled you can execute both the peripheral and central firmware, and(!) you have to start the bluetooth simulation.
By starting each application in its own terminal, you can keep an eye on the output.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYGZob{}BSIM\PYGZus{}OUT\PYGZus{}PATH\PYGZcb{}/bin/bs\PYGZus{}nrf52\PYGZus{}bsim\PYGZus{}samples\PYGZus{}bluetooth\PYGZus{}central\PYGZus{}hr \PYGZhy{}s=trial\PYGZus{}sim \PYGZhy{}d=1

 zephyr/build/zephyr/zephyr.exe \PYGZhy{}s=trial\PYGZus{}sim \PYGZhy{}d=0
 \PYGZdl{}\PYGZob{}BSIM\PYGZus{}OUT\PYGZus{}PATH\PYGZcb{}/bin/bs\PYGZus{}2G4\PYGZus{}phy\PYGZus{}v1 \PYGZhy{}s=trial\PYGZus{}sim \PYGZhy{}D=2 \PYGZhy{}sim\PYGZus{}length=10e6
\end{sphinxVerbatim}


\subsection{the no\sphinxhyphen{}watch approach : simulation on a laptop}
\label{\detokenize{bluetooth:the-no-watch-approach-simulation-on-a-laptop}}
\sphinxAtStartPar
how to activate bluetooth?

\sphinxAtStartPar
VBOX running ubuntu (first deactivate driver in windows)
(CTRL home \textendash{} select usb \textendash{} (intel in my case)) \textendash{} this lets you select the integrated bluetooth module of your laptop

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hciconfig} \PYG{n}{hci0} \PYG{n}{down}

\PYG{n}{west} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{native\PYGZus{}posix\PYGZus{}64} \PYG{n}{samples}\PYG{o}{/}\PYG{n}{bluetooth}\PYG{o}{/}\PYG{n}{peripheral\PYGZus{}hr}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{build}\PYG{o}{/}\PYG{n}{zephyr}\PYG{o}{/}\PYG{n}{zephyr}\PYG{o}{.}\PYG{n}{exe} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{bt}\PYG{o}{\PYGZhy{}}\PYG{n}{dev}\PYG{o}{=}\PYG{n}{hci0}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now you can connect your smartphone to the posix\_64 bluetooth device!

\sphinxAtStartPar
Or, with a second bluetooth interface (eg dongle)
.. code\sphinxhyphen{}block:: console
\begin{quote}

\sphinxAtStartPar
bluetoothctl
{[}bluetooth{]}\# devices
Device C6:78:40:29:EC:31 Zephyr Heartrate Sensor
Device C9:16:85:ED:B6:4E DS\sphinxhyphen{}D6 b64e
Device C8:B7:89:A9:B0:C9 Espruino\sphinxhyphen{}107 b0c9
Device 00:1A:7D:DA:71:0B posix\_64

\sphinxAtStartPar
{[}bluetooth{]}\# info 00:1A:7D:DA:71:0B
Device 00:1A:7D:DA:71:0B (public)
Name: posix\_64
Alias: posix\_64
Paired: no
Trusted: no
Blocked: no
Connected: no
LegacyPairing: no
UUID: Device Information        (0000180a\sphinxhyphen{}0000\sphinxhyphen{}1000\sphinxhyphen{}8000\sphinxhyphen{}00805f9b34fb)
UUID: Current Time Service      (00001805\sphinxhyphen{}0000\sphinxhyphen{}1000\sphinxhyphen{}8000\sphinxhyphen{}00805f9b34fb)
\end{quote}

\sphinxAtStartPar
If you have a smartphone, you can download the nrf utilities app from nordic.


\section{Nordic nRF Connect (android)}
\label{\detokenize{bluetooth:nordic-nrf-connect-android}}
\sphinxAtStartPar
This app allows you to start a gatt server.

\sphinxAtStartPar
As soon as a device is bonded, (oswatch) Pinetime will look for a CTS server (Current Time Service) on the connected device.

\sphinxAtStartPar
Start NRFConnect and create a CTS server : Tap the hamburger button on the top left and select “Configure GATT server”.

\sphinxAtStartPar
Tap “Add service” on the bottom Select server configuration “Current Time Service”  (0x1805)

\sphinxAtStartPar
Here is for a manual time setup : add the Current Time 0x2A2B characteristic :
in the intial value field add 0x141505130B0D which corresponds to (2021 year 05 month 19 day 11hours 13 minutes)

\sphinxAtStartPar
In the samples is how to transfer variables to the watch.

\sphinxAtStartPar
I have (mis)used the battery service (0x180F) to achieve this.
Adding to battery level (0x2A19) a value (eg 0x112233445566778899AACCDD), allows you to transfer 12 bytes to the  watch)


\section{Bluez}
\label{\detokenize{bluetooth:bluez}}
\sphinxAtStartPar
With Bluez on linux you can investigate the bluetoothservices,  using bluetoothctl:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}bluetoothctl
\PYG{g+gp}{[bluetooth]\PYGZsh{}}scan on


\PYG{g+go}{[NEW] Device 60:7C:9E:92:50:C1 Zephyr Peripheral Sample Long}
\PYG{g+go}{once you see your device}
\PYG{g+gp}{[blueooth]\PYGZsh{}}connect \PYG{l+m}{60}:7C:9E:92:50:C1 \PYG{o}{(}the device mac address as displayed\PYG{o}{)}

\PYG{g+go}{then you can already see the services}
\end{sphinxVerbatim}


\subsection{using bluez to write something to the device}
\label{\detokenize{bluetooth:using-bluez-to-write-something-to-the-device}}\begin{description}
\item[{Characteristic}] \leavevmode
\sphinxAtStartPar
/org/bluez/hci0/dev\_74\_71\_4B\_D5\_18\_21/service001f/char0023
00002a38\sphinxhyphen{}0000\sphinxhyphen{}1000\sphinxhyphen{}8000\sphinxhyphen{}00805f9b34fb
Body Sensor Location

\end{description}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{[dsd6]\PYGZsh{} }\PYG{k}{select}\PYGZhy{}attribute /org/bluez/hci0/dev\PYGZus{}74\PYGZus{}71\PYGZus{}4B\PYGZus{}D5\PYGZus{}18\PYGZus{}21/service001f/char0023
\PYG{g+go}{write \PYGZlt{}data=0x1\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
same thing with the app from nordic, you could try to connect and display value of e.g. heart rate


\section{using Python to read out bluetoothservices}
\label{\detokenize{bluetooth:using-python-to-read-out-bluetoothservices}}
\sphinxAtStartPar
In this repo you will find a python script : readbat.py
In order to use it you need bluez on linux and the python \sphinxtitleref{bluepy} module.

\sphinxAtStartPar
It can be used in conjunction with the peripheral bluetooth demo.
It just reads out the battery level, and prints it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{binascii}
\PYG{k+kn}{from} \PYG{n+nn}{bluepy}\PYG{n+nn}{.}\PYG{n+nn}{btle} \PYG{k+kn}{import} \PYG{n}{UUID}\PYG{p}{,} \PYG{n}{Peripheral}

\PYG{n}{temp\PYGZus{}uuid} \PYG{o}{=} \PYG{n}{UUID}\PYG{p}{(}\PYG{l+m+mh}{0x2A19}\PYG{p}{)}

\PYG{n}{p} \PYG{o}{=} \PYG{n}{Peripheral}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{60:7C:9E:92:50:C1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{random}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{try}\PYG{p}{:}
   \PYG{n}{ch} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{getCharacteristics}\PYG{p}{(}\PYG{n}{uuid}\PYG{o}{=}\PYG{n}{temp\PYGZus{}uuid}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
   \PYG{n+nb}{print} \PYG{n}{binascii}\PYG{o}{.}\PYG{n}{b2a\PYGZus{}hex}\PYG{p}{(}\PYG{n}{ch}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{finally}\PYG{p}{:}
    \PYG{n}{p}\PYG{o}{.}\PYG{n}{disconnect}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Bluetooth Notification}
\label{\detokenize{notification:bluetooth-notification}}\label{\detokenize{notification::doc}}
\sphinxAtStartPar
As mentioned earlier, I searched for ways to transfer data to, and(!) from the device.
Bluetooth data exchange might be a standard feature of Android, Apple …

\sphinxAtStartPar
On a linuxbox there are ways to do this as well!

\sphinxAtStartPar
In the zephyr samples,  I found a sample for Indication.
I created a sample for Notification. (samples/bluetooth/Peripheral\sphinxhyphen{}notification)


\section{What?}
\label{\detokenize{notification:what}}
\sphinxAtStartPar
The BLE standard defines two ways to transfer data from the server to the client: notification and indication.

\sphinxAtStartPar
Notification don’t need acknowledgement, so it is faster. Hence, server does not know if the message reached the client….


\section{How?}
\label{\detokenize{notification:how}}
\sphinxAtStartPar
Notification has to be enabled.

\sphinxAtStartPar
Linuxbox (bluez) writes “enable” to the watch notification characteristic.

\sphinxAtStartPar
Once Nofication is enabled the watch sends continuously messages :
the maximum data payload size defined by the specification in each message is 20 bytes.


\section{Bluez}
\label{\detokenize{notification:bluez}}
\sphinxAtStartPar
on linux you could use  “bluetoothctl”

\sphinxAtStartPar
There is an example for heartrates.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}bluetoothctl}

\PYG{n}{connect} \PYG{n}{MAC}\PYG{o}{\PYGZhy{}}\PYG{n}{device}

\PYG{n}{menu} \PYG{n}{gatt}
\PYG{n}{select}\PYG{o}{\PYGZhy{}}\PYG{n}{attribute} \PYG{l+m+mi}{00002}\PYG{n}{a37}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{0000}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1000}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8000}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{00805}\PYG{n}{f9b34fb}
\PYG{n}{notify} \PYG{n}{on}

\PYG{k}{if} \PYG{n+nb}{all} \PYG{n}{goes} \PYG{n}{well}\PYG{p}{,} \PYG{n}{the} \PYG{n}{watch} \PYG{n}{starts} \PYG{n}{sending} \PYG{n}{heartrates}

\PYG{o+ow}{in} \PYG{n}{case} \PYG{n}{it} \PYG{n}{stops}\PYG{p}{:}

\PYG{n}{notify} \PYG{n}{off}
\PYG{n}{notify} \PYG{n}{on}
\end{sphinxVerbatim}


\section{A word on attributes}
\label{\detokenize{notification:a-word-on-attributes}}
\sphinxAtStartPar
The data that the server exposes is structured as attributes.

\sphinxAtStartPar
Attribute type (Universally Unique Identifier or UUID)
This is a :
\begin{itemize}
\item {} 
\sphinxAtStartPar
16\sphinxhyphen{}bit number

\item {} 
\sphinxAtStartPar
or 128\sphinxhyphen{}bit number

\end{itemize}

\sphinxAtStartPar
The 16\sphinxhyphen{}bit number is converted to 128\sphinxhyphen{}bit by means of a
128\sphinxhyphen{}bit base \sphinxurl{UUID:00000000-0000-1000-8000-00805F9B34FB}.

\sphinxAtStartPar
These 16\sphinxhyphen{}bit numbers are standardised. On each device the temperature measurement value is 0x2A1C.

\sphinxAtStartPar
Because I create a custom service to exchange data I use a custom attribute type, also sometimes referred to as vendor\sphinxhyphen{}specific UUID.
BLE\_CHARACTERISTIC\_UUID= “12345678\sphinxhyphen{}1234\sphinxhyphen{}5678\sphinxhyphen{}1234\sphinxhyphen{}56789abcdef1”


\section{Attribute Handle}
\label{\detokenize{notification:attribute-handle}}
\sphinxAtStartPar
This is a 16\sphinxhyphen{}bit value that the server assigns to each of its attributes — think of it as an address. This value is used by the client to reference a specific attribute and is guaranteed by the server to uniquely identify the attribute during the life of the connection between two devices. The range of handles is 0x0001\sphinxhyphen{}0xFFFF, where the value of 0x0000 is reserved.


\section{Python}
\label{\detokenize{notification:python}}
\sphinxAtStartPar
The scripts are provided. (scan+not.py)
But here is a short explanation on how to enable notifications.

\sphinxAtStartPar
On linux one could use the Gatttool from the commandprompt.

\sphinxAtStartPar
Another option is Python!

\sphinxAtStartPar
In this manual the module Bluepy is used : \sphinxurl{https://github.com/IanHarvey/bluepy}.

\sphinxAtStartPar
(custom service)
BLE\_SERVICE\_UUID =”12345678\sphinxhyphen{}1234\sphinxhyphen{}5678\sphinxhyphen{}1234\sphinxhyphen{}56789abcdef0”
BLE\_CHARACTERISTIC\_UUID= “12345678\sphinxhyphen{}1234\sphinxhyphen{}5678\sphinxhyphen{}1234\sphinxhyphen{}56789abcdef1”

\sphinxAtStartPar
ch = ble\_service.getCharacteristics(){[}0{]}
ch.valHandle (this gets you the handle to the notification characteristic

\sphinxAtStartPar
\# Writing x01 is the protocol for all BLE notifications.
\# However …. you need to write it to the handle + 1

\sphinxAtStartPar
dev.writeCharacteristic(ch.valHandle+1, b”x01x00”, withResponse=True)


\chapter{Firmware Over The Air (FOTA)}
\label{\detokenize{fota/fota:firmware-over-the-air-fota}}\label{\detokenize{fota/fota:fota}}\label{\detokenize{fota/fota::doc}}

\section{Wireless Device Firmware Upgrade}
\label{\detokenize{fota/mcuboot:wireless-device-firmware-upgrade}}\label{\detokenize{fota/mcuboot:mcuboot}}\label{\detokenize{fota/mcuboot::doc}}

\subsection{Overview}
\label{\detokenize{fota/mcuboot:overview}}
\sphinxAtStartPar
In order to perform a FOTA (firmware over the air) update on zephyr you need 2 basic components:
\begin{itemize}
\item {} 
\sphinxAtStartPar
MCUboot   (a bootloader)

\item {} 
\sphinxAtStartPar
SMP Server (a bluetooth service)

\end{itemize}


\section{MCUboot with zephyr}
\label{\detokenize{fota/mcuboot:mcuboot-with-zephyr}}\label{\detokenize{fota/mcuboot:id1}}
\sphinxAtStartPar
Clone MCUBOOT for zephyr from github.
Install additional packages required for development with mcuboot:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{o}{\PYGZti{}}\PYG{o}{/}\PYG{n}{mcuboot}  \PYG{c+c1}{\PYGZsh{} or to your directory where mcuboot is cloned}
\PYG{n}{pip3} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{user} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{n}{scripts}\PYG{o}{/}\PYG{n}{requirements}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}

\sphinxAtStartPar
To build MCUboot, create a build directory in boot/zephyr, and build
it as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{boot}\PYG{o}{/}\PYG{n}{zephyr}
\PYG{n}{mkdir} \PYG{n}{build} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{GNinja} \PYG{o}{\PYGZhy{}}\PYG{n}{DBOARD}\PYG{o}{=}\PYG{n}{pinetime} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{ninja}
\end{sphinxVerbatim}

\sphinxAtStartPar
After building the bootloader, the binaries should reside in
\sphinxtitleref{build/zephyr/zephyr.\{bin,hex,elf\}}.

\sphinxAtStartPar
This image can be flashed as a normal application.

\sphinxAtStartPar
Some additional configuration is required to build applications for MCUboot.

\sphinxAtStartPar
This is handled internally by the Zephyr configuration system and is wrapped
in the \sphinxtitleref{CONFIG\_BOOTLOADER\_MCUBOOT} Kconfig variable, which must be enabled in
the application’s \sphinxtitleref{prj.conf} file.

\sphinxAtStartPar
The Zephyr \sphinxtitleref{CONFIG\_BOOTLOADER\_MCUBOOT} configuration option
{[}documentation{]}(\sphinxurl{http://docs.zephyrproject.org/reference/kconfig/CONFIG\_BOOTLOADER\_MCUBOOT.html})
provides additional details regarding the changes it makes to the image
placement and generation in order for an application to be bootable by
MCUboot.

\sphinxAtStartPar
In order to upgrade to an image (or even boot it, if
\sphinxtitleref{MCUBOOT\_VALIDATE\_PRIMARY\_SLOT} is enabled), the images must be signed.

\sphinxAtStartPar
To make development easier, MCUboot is distributed with some example
keys.  It is important to stress that these should never be used for
production, since the private key is publicly available in this
repository.  See below on how to make your own signatures.

\sphinxAtStartPar
Images can be signed with the \sphinxtitleref{scripts/imgtool.py} script.  It is best
to look at \sphinxtitleref{samples/zephyr/Makefile} for examples on how to use this.

\sphinxAtStartPar
Since the bootloader is already in place, you cannot flash your application.bin to 0x00000.

\sphinxAtStartPar
Eg. in openocd : program application.bin 0x0c000. (which corresponds to the flash layout of slot 0)

\sphinxAtStartPar
These images can also be marked for upgrade, and loaded into the secondary slot,
at which point the bootloader should perform an upgrade.


\section{Partitions}
\label{\detokenize{fota/partitions:partitions}}\label{\detokenize{fota/partitions:signing}}\label{\detokenize{fota/partitions::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{have a look at boards/arm/pinetime/pinetime.dts}
\end{sphinxVerbatim}


\subsection{Defining partitions for MCUboot}
\label{\detokenize{fota/partitions:defining-partitions-for-mcuboot}}
\sphinxAtStartPar
The first step required for Zephyr is making sure your board has flash
partitions defined in its device tree. These partitions are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{boot\_partition}: for MCUboot itself

\item {} 
\sphinxAtStartPar
\sphinxtitleref{image\_0\_primary\_partition}: the primary slot of Image 0

\item {} 
\sphinxAtStartPar
\sphinxtitleref{image\_0\_secondary\_partition}: the secondary slot of Image 0

\item {} 
\sphinxAtStartPar
\sphinxtitleref{scratch\_partition}: the scratch slot

\end{itemize}

\sphinxAtStartPar
The flash partitions are defined in the pinetime boards folder, in a
file named \sphinxtitleref{boards/arm/pinetime/pinetime.dts}.


\subsection{Using NOR flash in partitions}
\label{\detokenize{fota/partitions:using-nor-flash-in-partitions}}
\sphinxAtStartPar
The flash space on the Nordic nrf52 is 512K.
Basically with the partitioning you end up with less space for your program.

\sphinxAtStartPar
As the pinetime has an extra spi nor flash chip, we can use this.

\sphinxAtStartPar
The flash\sphinxhyphen{}layout can be modified so as 1 chunk is on system flash and 1 chunk is on SPI NOR flash.
This way the space for your firmware remains almost the same.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{chosen \PYGZob{}}
\PYG{g+go}{        zephyr,flash = \PYGZam{}flash0;}
\PYG{g+go}{        //zephyr,flash = \PYGZam{}flash1;}
\PYG{g+go}{        zephyr,code\PYGZhy{}partition = \PYGZam{}slot0\PYGZus{}partition;}
\PYG{g+go}{\PYGZcb{};}


\PYG{g+go}{Rename the SPI JEDEC NOR Flash definition to : flash1}

\PYG{g+go}{flash1: mx25r6435f@1 \PYGZob{}}
\PYG{g+go}{        compatible = \PYGZdq{}jedec,spi\PYGZhy{}nor\PYGZdq{};}
\PYG{g+go}{        reg = \PYGZlt{}1\PYGZgt{};}
\PYG{g+go}{        spi\PYGZhy{}max\PYGZhy{}frequency = \PYGZlt{}80000000\PYGZgt{};}
\PYG{g+go}{        label = \PYGZdq{}MX25R64\PYGZdq{};}
\PYG{g+go}{        jedec\PYGZhy{}id = [0b 40 16];}
\PYG{g+go}{        size = \PYGZlt{}67108864\PYGZgt{};}
\PYG{g+go}{        has\PYGZhy{}be32k;}
\PYG{g+go}{        erase\PYGZhy{}block\PYGZhy{}size = \PYGZlt{}4096\PYGZgt{};}
\PYG{g+go}{        write\PYGZhy{}block\PYGZhy{}size = \PYGZlt{}4\PYGZgt{};}
\PYG{g+go}{\PYGZcb{};}




\PYG{g+go}{ \PYGZam{}flash0 \PYGZob{}}
\PYG{g+go}{        /*}
\PYG{g+go}{         * For more information, see:}
\PYG{g+go}{         * http://docs.zephyrproject.org/latest/guides/dts/index.html\PYGZsh{}flash\PYGZhy{}partitions}
\PYG{g+go}{         */}
\PYG{g+go}{        partitions \PYGZob{}}
\PYG{g+go}{                compatible = \PYGZdq{}fixed\PYGZhy{}partitions\PYGZdq{};}
\PYG{g+gp}{                \PYGZsh{}}address\PYGZhy{}cells \PYG{o}{=} \PYGZlt{}\PYG{l+m}{1}\PYGZgt{}\PYG{p}{;}
\PYG{g+gp}{                \PYGZsh{}}size\PYGZhy{}cells \PYG{o}{=} \PYGZlt{}\PYG{l+m}{1}\PYGZgt{}\PYG{p}{;}

\PYG{g+go}{                boot\PYGZus{}partition: partition@0 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}mcuboot\PYGZdq{};}
\PYG{g+go}{                        reg = \PYGZlt{}0x00000000 0xc000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}
\PYG{g+go}{                slot0\PYGZus{}partition: partition@c000 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}image\PYGZhy{}0\PYGZdq{};}

\PYG{g+go}{                change the size of partition 0 from 0x32000 to 0x64000}

\PYG{g+go}{                        reg = \PYGZlt{}0x0000C000 0x64000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}

\PYG{g+go}{                move slot1 partition to \PYGZam{}flash1}

\PYG{g+go}{                //slot1\PYGZus{}partition: partition@3e000 \PYGZob{}}
\PYG{g+go}{                //      label = \PYGZdq{}image\PYGZhy{}1\PYGZdq{};}
\PYG{g+go}{                //      reg = \PYGZlt{}0x0003e000 0x32000\PYGZgt{};}
\PYG{g+go}{                //\PYGZcb{};}
\PYG{g+go}{                scratch\PYGZus{}partition: partition@70000 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}image\PYGZhy{}scratch\PYGZdq{};}
\PYG{g+go}{                        reg = \PYGZlt{}0x00070000 0xa000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}
\PYG{g+go}{                storage\PYGZus{}partition: partition@7a000 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}storage\PYGZdq{};}
\PYG{g+go}{                        reg = \PYGZlt{}0x0007a000 0x00006000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}
\PYG{g+go}{        \PYGZcb{};}
\PYG{g+go}{ \PYGZcb{};}

\PYG{g+go}{ \PYGZam{}flash1 \PYGZob{}}
\PYG{g+go}{        partitions \PYGZob{}}
\PYG{g+go}{                compatible = \PYGZdq{}fixed\PYGZhy{}partitions\PYGZdq{};}
\PYG{g+gp}{                \PYGZsh{}}address\PYGZhy{}cells \PYG{o}{=} \PYGZlt{}\PYG{l+m}{1}\PYGZgt{}\PYG{p}{;}
\PYG{g+gp}{                \PYGZsh{}}size\PYGZhy{}cells \PYG{o}{=} \PYGZlt{}\PYG{l+m}{1}\PYGZgt{}\PYG{p}{;}
\PYG{g+go}{                slot1\PYGZus{}partition: partition@3e000 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}image\PYGZhy{}1\PYGZdq{};}
\PYG{g+go}{                        reg = \PYGZlt{}0x00000000 0x64000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}
\PYG{g+go}{        \PYGZcb{};}
\PYG{g+go}{ \PYGZcb{};}
\end{sphinxVerbatim}


\section{Signing an application}
\label{\detokenize{fota/signing:signing-an-application}}\label{\detokenize{fota/signing:signing}}\label{\detokenize{fota/signing::doc}}
\sphinxAtStartPar
In order to improve the security, only signed images can be uploaded.

\sphinxAtStartPar
There is a public and private key.
The Bootloader is compiled with the public key.
Each time you want to upload firmware, you have to sign it with a private key.

\sphinxAtStartPar
\sphinxstylestrong{NOTE: it is important to keep the private key hidden}


\subsection{Generating a new keypair}
\label{\detokenize{fota/signing:generating-a-new-keypair}}
\sphinxAtStartPar
Generating a keypair with imgtool is a matter of running the keygen
subcommand:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }./scripts/imgtool.py keygen \PYGZhy{}k mykey.pem \PYGZhy{}t rsa\PYGZhy{}2048
\end{sphinxVerbatim}


\subsection{Extracting the public key}
\label{\detokenize{fota/signing:extracting-the-public-key}}
\sphinxAtStartPar
The generated keypair above contains both the public and the private
key.  It is necessary to extract the public key and insert it into the
bootloader.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }./scripts/imgtool.py getpub \PYGZhy{}k mykey.pem
\end{sphinxVerbatim}

\sphinxAtStartPar
This will output the public key as a C array that can be dropped
directly into the \sphinxtitleref{keys.c} file.


\subsection{Example}
\label{\detokenize{fota/signing:example}}
\sphinxAtStartPar
sign the compiled zephyr.bin firmware with the root\sphinxhyphen{}rsa\sphinxhyphen{}2048.pem, private key:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{imgtool.py sign \PYGZhy{}\PYGZhy{}key ../../root\PYGZhy{}rsa\PYGZhy{}2048.pem \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}header\PYGZhy{}size 0x200 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}align 8 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}version 1.2 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}slot\PYGZhy{}size 0x60000 \PYGZbs{}}
\PYG{g+go}{    ../mcuboot/samples/zephyr/build/ds\PYGZus{}d6/hello1/zephyr/zephyr.bin \PYGZbs{}}
\PYG{g+go}{    signed\PYGZhy{}hello1.bin}
\end{sphinxVerbatim}


\section{SMP Server Sample}
\label{\detokenize{fota/smp_svr:smp-server-sample}}\label{\detokenize{fota/smp_svr:smp-svr-sample}}\label{\detokenize{fota/smp_svr::doc}}

\subsection{Overview}
\label{\detokenize{fota/smp_svr:overview}}
\sphinxAtStartPar
This sample application implements a Simple Management Protocol (SMP) server.
SMP is a basic transfer encoding for use with the MCUmgr management protocol.

\sphinxAtStartPar
This sample application supports the following mcumgr transports by default:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Shell

\item {} 
\sphinxAtStartPar
Bluetooth

\end{itemize}


\subsection{Requirements}
\label{\detokenize{fota/smp_svr:requirements}}
\sphinxAtStartPar
In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.

\sphinxAtStartPar
Here is a procedure to install mcumgr on a raspberry pi  (or similar)

\sphinxAtStartPar
It is written in the go\sphinxhyphen{}language. You need to adapt the path :   PATH=\$PATH:/root/go/bin.


\subsection{Building and Running}
\label{\detokenize{fota/smp_svr:building-and-running}}
\sphinxAtStartPar
The sample will let you manage the pinetime over bluetooth. (via SMP protocol)

\sphinxAtStartPar
There are slot0 and slot1 which can both contain firmware.

\sphinxAtStartPar
Suppose you switch from slot0 to slot1, you still want to be able to communicate.

\sphinxAtStartPar
So both slots need smp\_svr software!


\subsubsection{Step 1: Build smp\_svr}
\label{\detokenize{fota/smp_svr:step-1-build-smp-svr}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{smp\_svr}} can be built for the nRF52 as follows:

\sphinxAtStartPar
\sphinxstylestrong{NOTE: to perform a firmware update over the air, you have to build a second sample}


\subsubsection{Step 2: Sign the image}
\label{\detokenize{fota/smp_svr:step-2-sign-the-image}}
\sphinxAtStartPar
Using MCUboot’s \sphinxcode{\sphinxupquote{imgtool.py}} script, sign the \sphinxcode{\sphinxupquote{zephyr.(bin|hex)}}
file you built in Step 3. In the below example, the MCUboot repo is located at
\sphinxcode{\sphinxupquote{\textasciitilde{}/src/mcuboot}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/src/mcuboot/scripts/imgtool.py sign \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}key \PYGZti{}/src/mcuboot/root\PYGZhy{}rsa\PYGZhy{}2048.pem \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}header\PYGZhy{}size 0x200 \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}align 8 \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}version 1.0 \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}slot\PYGZhy{}size \PYGZlt{}image\PYGZhy{}slot\PYGZhy{}size\PYGZgt{} \PYGZbs{}}
\PYG{g+go}{     \PYGZlt{}path\PYGZhy{}to\PYGZhy{}zephyr.(bin|hex)\PYGZgt{} signed.(bin|hex)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The above command creates an image file called \sphinxcode{\sphinxupquote{signed.(bin|hex)}} in the
current directory.


\subsubsection{Step 3: Flash the smp\_svr image}
\label{\detokenize{fota/smp_svr:step-3-flash-the-smp-svr-image}}
\sphinxAtStartPar
Upload the bin\sphinxhyphen{}file from Step 2 to image slot\sphinxhyphen{}0.
For the pinetime, slot\sphinxhyphen{}0 is located at address \sphinxcode{\sphinxupquote{0xc000}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{in openocd : program zephyr.bin 0xc000}
\end{sphinxVerbatim}


\subsubsection{Step 4: Run it!}
\label{\detokenize{fota/smp_svr:step-4-run-it}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
If you haven’t installed \sphinxcode{\sphinxupquote{mcumgr}} yet, then do so by following the
instructions in the \DUrole{xref,std,std-ref}{mcumgr\_cli} section of the Management subsystem
documentation.
\end{sphinxadmonition}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{smp\_svr}} app is ready to run.  Just reset your board and test the app
with the \sphinxcode{\sphinxupquote{mcumgr}} command\sphinxhyphen{}line tool’s \sphinxcode{\sphinxupquote{echo}} functionality, which will
send a string to the remote target device and have it echo it back:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} echo hello}
\PYG{g+go}{hello}
\end{sphinxVerbatim}


\subsubsection{Step 5: Device Firmware Upgrade}
\label{\detokenize{fota/smp_svr:step-5-device-firmware-upgrade}}
\sphinxAtStartPar
Now that the SMP server is running on your pinetime, you are able to communicate
with it using \sphinxtitleref{mcumgr}.

\sphinxAtStartPar
You might want to test “OTA DFU”, or Over\sphinxhyphen{}The\sphinxhyphen{}Air Device Firmware Upgrade.

\sphinxAtStartPar
To do this, build a second sample (following the steps below) to verify
it is sent over the air and properly flashed into slot\sphinxhyphen{}1, and then
swapped into slot\sphinxhyphen{}0 by MCUboot.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{*} \PYG{n}{Build} \PYG{n}{a} \PYG{n}{second} \PYG{n}{sample}
\PYG{o}{*} \PYG{n}{Sign} \PYG{n}{the} \PYG{n}{second} \PYG{n}{sample}
\PYG{o}{*} \PYG{n}{Upload} \PYG{n}{the} \PYG{n}{image} \PYG{n}{over} \PYG{n}{BLE}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now we are ready to send or upload the image over BLE to the target remote
device.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} image upload signed.bin}
\end{sphinxVerbatim}

\sphinxAtStartPar
If all goes well the image will now be stored in slot\sphinxhyphen{}1, ready to be swapped
into slot\sphinxhyphen{}0 and executed.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
At the beginning of the upload process, the target might start erasing
the image slot, taking several dozen seconds for some targets.  This might
cause an NMP timeout in the management protocol tool. Use the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}t \textless{}timeout\sphinxhyphen{}in\sphinxhyphen{}seconds}} option to increase the response timeout for the
\sphinxcode{\sphinxupquote{mcumgr}} command line tool if this occurs.
\end{sphinxadmonition}


\paragraph{List the images}
\label{\detokenize{fota/smp_svr:list-the-images}}
\sphinxAtStartPar
We can now obtain a list of images (slot\sphinxhyphen{}0 and slot\sphinxhyphen{}1) present in the remote
target device by issuing the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} image list}
\end{sphinxVerbatim}

\sphinxAtStartPar
This should print the status and hash values of each of the images present.


\paragraph{Test the image}
\label{\detokenize{fota/smp_svr:test-the-image}}
\sphinxAtStartPar
In order to instruct MCUboot to swap the images we need to test the image first,
making sure it boots:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} image test \PYGZlt{}hash of slot\PYGZhy{}1 image\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now MCUBoot will swap the image on the next reset.


\paragraph{Reset remotely}
\label{\detokenize{fota/smp_svr:reset-remotely}}
\sphinxAtStartPar
We can reset the device remotely to observe (use the console output) how
MCUboot swaps the images:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} reset}
\end{sphinxVerbatim}

\sphinxAtStartPar
Upon reset MCUboot will swap slot\sphinxhyphen{}0 and slot\sphinxhyphen{}1.

\sphinxAtStartPar
You can confirm the new image and make the swap permanent by using this command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} image confirm}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Note} that if you try to send the very same image that is already flashed in
slot\sphinxhyphen{}0 then the procedure will not complete successfully since the hash values
for both slots will be identical.
\begin{quote}
\end{quote}


\chapter{Samples}
\label{\detokenize{samples/index:samples}}\label{\detokenize{samples/index:id1}}\label{\detokenize{samples/index::doc}}

\chapter{Menuconfig}
\label{\detokenize{menuconfig:menuconfig}}\label{\detokenize{menuconfig::doc}}

\section{Zephyr is like linux}
\label{\detokenize{menuconfig:zephyr-is-like-linux}}
\sphinxAtStartPar
\sphinxstylestrong{TIP: the pinetime specific drivers are located under Modules}

\sphinxAtStartPar
\sphinxstylestrong{Note:}  to get a feel, compile a program, for example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/bluetooth/peripheral \PYGZhy{}D CONF\PYGZus{}FILE=\PYGZdq{}prj.conf\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{the pinetime contains an external 32Kz crystal}}
now you can have a look in the configurationfile (and modify if needed)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }west build \PYGZhy{}t menuconfig
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{Modules}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Board} \PYG{n}{Selection} \PYG{p}{(}\PYG{n}{nRF52832}\PYG{o}{\PYGZhy{}}\PYG{n}{MDK}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Board} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{SoC}\PYG{o}{/}\PYG{n}{CPU}\PYG{o}{/}\PYG{n}{Configuration} \PYG{n}{Selection} \PYG{p}{(}\PYG{n}{Nordic} \PYG{n}{Semiconductor} \PYG{n}{nRF52} \PYG{n}{series} \PYG{n}{MCU}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Hardware} \PYG{n}{Configuration}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{ARM} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Architecture} \PYG{p}{(}\PYG{n}{ARM} \PYG{n}{architecture}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{General} \PYG{n}{Architecture} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Floating} \PYG{n}{point}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{General} \PYG{n}{Kernel} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Device} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{n}{SELECT} \PYG{n}{THIS} \PYG{n}{ONE}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
    \PYG{n}{C} \PYG{n}{Library}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Additional} \PYG{n}{libraries}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Bluetooth}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Console} \PYG{n}{subsystem}\PYG{o}{/}\PYG{n}{support} \PYG{n}{routines} \PYG{p}{[}\PYG{n}{EXPERIMENTAL}\PYG{p}{]}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{C}\PYG{o}{+}\PYG{o}{+} \PYG{n}{support} \PYG{k}{for} \PYG{n}{the} \PYG{n}{application}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{System} \PYG{n}{Monitoring} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Debugging} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Disk} \PYG{n}{Interface}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{File} \PYG{n}{Systems}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZhy{}}\PYG{o}{*}\PYG{o}{\PYGZhy{}} \PYG{n}{Logging}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Management}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Networking}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[} \PYG{p}{]} \PYG{n}{IEEE} \PYG{l+m+mf}{802.15}\PYG{l+m+mf}{.4} \PYG{n}{drivers} \PYG{n}{options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{(}\PYG{n}{UART\PYGZus{}0}\PYG{p}{)} \PYG{n}{Device} \PYG{n}{Name} \PYG{n}{of} \PYG{n}{UART} \PYG{n}{Device} \PYG{k}{for} \PYG{n}{UART} \PYG{n}{Console}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Console} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Net} \PYG{n}{loopback} \PYG{n}{driver}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Serial} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Interrupt} \PYG{n}{Controllers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Timer} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZhy{}}\PYG{o}{*}\PYG{o}{\PYGZhy{}} \PYG{n}{Entropy} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{GPIO} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Shared} \PYG{n}{interrupt} \PYG{n}{driver}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{SPI} \PYG{n}{hardware} \PYG{n}{bus} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{I2C} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{I2S} \PYG{n}{bus} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{PWM} \PYG{p}{(}\PYG{n}{Pulse} \PYG{n}{Width} \PYG{n}{Modulation}\PYG{p}{)} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Enable} \PYG{n}{board} \PYG{n}{pinmux} \PYG{n}{driver}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{ADC} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Watchdog} \PYG{n}{Support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Hardware} \PYG{n}{clock} \PYG{n}{controller} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{n}{SELECT} \PYG{n}{THIS} \PYG{n}{ONE}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Precision} \PYG{n}{Time} \PYG{n}{Protocol} \PYG{n}{Clock} \PYG{n}{driver} \PYG{n}{support}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{IPM} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{Max} \PYG{n}{compiled}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{log} \PYG{n}{level} \PYG{k}{for} \PYG{n}{ipm} \PYG{p}{(}\PYG{n}{Info}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Flash} \PYG{n}{hardware} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Sensor} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{Max} \PYG{n}{compiled}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{log} \PYG{n}{level} \PYG{k}{for} \PYG{n}{clock} \PYG{n}{control} \PYG{p}{(}\PYG{n}{Info}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{NRF} \PYG{n}{Clock} \PYG{n}{controller} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{n}{SELECT} \PYG{n}{THIS} \PYG{n}{ONE}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}}
\end{sphinxVerbatim}


\chapter{Debugging}
\label{\detokenize{debugging/debugging:debugging}}\label{\detokenize{debugging/debugging:id1}}\label{\detokenize{debugging/debugging::doc}}

\section{debugging}
\label{\detokenize{debugging/debug:debugging}}\label{\detokenize{debugging/debug::doc}}

\subsection{Segger JLink}
\label{\detokenize{debugging/debug:segger-jlink}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{smartwatch} \PYG{n}{does} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port}\PYG{o}{.}
\PYG{n}{A} \PYG{n}{way} \PYG{n}{around} \PYG{n}{this} \PYG{o+ow}{is} \PYG{n}{to} \PYG{n}{use} \PYG{n}{a} \PYG{n}{Segger} \PYG{n}{Jlink} \PYG{n}{debug}\PYG{o}{\PYGZhy{}}\PYG{n}{probe} \PYG{o+ow}{and} \PYG{n}{enable} \PYG{n}{logging} \PYG{o+ow}{and} \PYG{n}{shell} \PYG{n}{over} \PYG{n}{RTT}\PYG{p}{:}

\PYG{o+ow}{in} \PYG{n}{prj}\PYG{o}{.}\PYG{n}{cfg}\PYG{p}{:}

\PYG{n}{CONFIG\PYGZus{}LOG}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}USE\PYGZus{}SEGGER\PYGZus{}RTT}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}SHELL}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}SHELL\PYGZus{}BACKEND\PYGZus{}RTT}\PYG{o}{=}\PYG{n}{y}

\PYG{n}{start} \PYG{n}{the} \PYG{n}{debugger} \PYG{p}{:}
\PYG{n}{west} \PYG{n}{debug}
\PYG{o+ow}{and} \PYG{n}{enter} \PYG{p}{:} \PYG{k}{continue}

\PYG{n}{This} \PYG{n}{starts} \PYG{n}{up} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{background} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Segger Jlink Processes}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
What happens when you type : west debug?
You could type this on the command prompt.
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp+gpVirtualEnv}{(this start the server)}
\PYG{g+go}{JLinkGDBServer \PYGZhy{}select usb \PYGZhy{}port 2331 \PYGZhy{}if swd \PYGZhy{}speed 4000 \PYGZhy{}device nRF52832\PYGZus{}xxAA \PYGZhy{}silent \PYGZhy{}singlerun}
\PYG{g+gp+gpVirtualEnv}{(this starts the debug session)}
\PYG{g+go}{\PYGZti{}/zephyr\PYGZhy{}sdk/arm\PYGZhy{}zephyr\PYGZhy{}eabi/bin/arm\PYGZhy{}zephyr\PYGZhy{}eabi\PYGZhy{}gdb /root/zephyrproject/app/build/zephyr/zephyr.elf \PYGZhy{}ex target :2331 \PYGZhy{}ex halt \PYGZhy{}ex reset \PYGZhy{}ex load}
\PYG{g+go}{telnet 127.0.0.1 19021 (putty on linux) start the rtt console and shows the debug\PYGZhy{}log}
\end{sphinxVerbatim}


\subsection{Black Magic}
\label{\detokenize{debugging/debug:black-magic}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{ds}\PYG{o}{\PYGZhy{}}\PYG{n}{D6} \PYG{n}{smartwatch} \PYG{n}{has} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port}\PYG{o}{.}


\PYG{n}{The} \PYG{n}{blackmagicprobe} \PYG{n}{can} \PYG{n}{lauch} \PYG{n}{a} \PYG{n}{debugger} \PYG{p}{:} \PYG{n}{west} \PYG{n}{debug} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{runnerblackmagicprobe}\PYG{o}{.}
\PYG{n}{The} \PYG{n}{probe} \PYG{n}{has} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port} \PYG{o}{/}\PYG{n}{dev}\PYG{o}{/}\PYG{n}{ttyACM1} \PYG{p}{(}\PYG{n}{linux} \PYG{p}{:} \PYG{n}{minicom} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{l+m+mi}{115200} \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{o}{/}\PYG{n}{dev}\PYG{o}{/}\PYG{n}{ttyACM1}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{STM32 \sphinxhyphen{} Raspberry \sphinxhyphen{} OpenOCD}
\label{\detokenize{debugging/debug:stm32-raspberry-openocd}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{If} \PYG{n}{you} \PYG{n}{do} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{Segger} \PYG{n}{debug} \PYG{n}{probe} \PYG{n}{nor} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port}\PYG{p}{,} \PYG{n}{you} \PYG{n}{can} \PYG{n}{put} \PYG{n}{a} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{memory} \PYG{n}{at} \PYG{n}{a} \PYG{n}{fixed} \PYG{n}{location}\PYG{o}{.}
\PYG{n}{With} \PYG{n}{openocd} \PYG{n}{you} \PYG{n}{can} \PYG{n}{peek} \PYG{n}{at} \PYG{n}{this} \PYG{n}{memory} \PYG{n}{location}\PYG{o}{.}
\PYG{n}{If} \PYG{n}{you} \PYG{n}{own} \PYG{n}{a} \PYG{n}{raspberry} \PYG{n}{pi} \PYG{o+ow}{or} \PYG{n}{an} \PYG{n}{orange} \PYG{n}{pi}\PYG{p}{,} \PYG{n}{you} \PYG{n}{can} \PYG{n}{use} \PYG{n}{the} \PYG{n}{GPIO} \PYG{n}{header}\PYG{o}{.}
\PYG{n}{Another} \PYG{n}{cheap} \PYG{n}{option} \PYG{o+ow}{is} \PYG{n}{an} \PYG{n}{stm32} \PYG{n}{debug} \PYG{n}{probe}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\#define MY\_REGISTER (*(volatile uint8\_t*)0x2000F000)

\sphinxAtStartPar
in the program you can set values:
MY\_REGISTER=1;
MY\_REGISTER=8;

\sphinxAtStartPar
this way you know till where the code executes
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}telnet \PYG{l+m}{127}.0.0.1 \PYG{l+m}{4444}
\end{sphinxVerbatim}

\sphinxAtStartPar
programming

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{once your telnet sessions started:}
\PYG{g+go}{Trying 127.0.0.1...}
\PYG{g+go}{Connected to 127.0.0.1.}
\PYG{g+go}{Escape character is \PYGZsq{}\PYGZca{}]\PYGZsq{}.}
\PYG{g+go}{Open On\PYGZhy{}Chip Debugger}
\PYG{g+go}{\PYGZgt{}mdw 0x2000F000 0x1}

\PYG{g+go}{the last byte shows the value of your program trace value}
\end{sphinxVerbatim}


\section{debugging Posix}
\label{\detokenize{debugging/debug-posix:debugging-posix}}\label{\detokenize{debugging/debug-posix::doc}}
\sphinxAtStartPar
start gdb on the command prompt

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp+gpVirtualEnv}{(gdb)} \PYG{g+go}{file build/zephyr/zephyr.elf}
\PYG{g+go}{Reading symbols from build/zephyr/zephyr.elf...done.}
\PYG{g+gp+gpVirtualEnv}{(gdb)} \PYG{g+go}{b main}
\PYG{g+go}{Breakpoint 1 at 0x5909: file /root/work/zephyr/boards/posix/native\PYGZus{}posix/main.c, line 56.}
\PYG{g+gp+gpVirtualEnv}{(gdb)} \PYG{g+go}{run}
\end{sphinxVerbatim}

\sphinxAtStartPar
Debug oswatch\sphinxhyphen{}bt (which needs and argument \textendash{}bt\sphinxhyphen{}dev=hci0)
Set the breakpoint in the function connected

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp+gpVirtualEnv}{(gdb)} \PYG{g+go}{file build/zephyr/zephyr.elf}
\PYG{g+go}{Reading symbols from build/zephyr/zephyr.elf...done.}
\PYG{g+gp+gpVirtualEnv}{(gdb)} \PYG{g+go}{b connected}
\PYG{g+go}{Breakpoint 1 at 0x498a: file /root/work/app/oswatch\PYGZhy{}bt/src/bt.c, line 140.}
\PYG{g+gp+gpVirtualEnv}{(gdb)} \PYG{g+go}{r \PYGZhy{}\PYGZhy{}bt\PYGZhy{}dev=hci0}
\end{sphinxVerbatim}


\section{The black magic probe}
\label{\detokenize{debugging/blackmagicprobe:the-black-magic-probe}}\label{\detokenize{debugging/blackmagicprobe::doc}}

\subsection{probes in zephyr}
\label{\detokenize{debugging/blackmagicprobe:probes-in-zephyr}}
\sphinxAtStartPar
You can program the nrf52832 with a debuggerprobe.
The standard\sphinxhyphen{}setup is jlink (segger).

\sphinxAtStartPar
/root/zephyrproject/zephyr/boards/arm/id107plus/board.cmake (adapt the runner here)

\sphinxAtStartPar
in our case : instead of jlink specify : blackmagicprobe

\sphinxAtStartPar
The cool thing about this probe that it has a serial port (3.3V) and a debug (upload) port on the same usb\sphinxhyphen{}port.
\begin{description}
\item[{::}] \leavevmode
\sphinxAtStartPar
/dev/ttyACM1 is serial port (pb6 pb7)

\sphinxAtStartPar
minicom \sphinxhyphen{}b 115200 \sphinxhyphen{}D /dev/ttyACM1

\sphinxAtStartPar
/dev/ttyACM0 is used as debugger/uploading

\sphinxAtStartPar
west debug \textendash{}runner blackmagicprobe
west flash \textendash{}runner blackmagicprobe

\end{description}


\subsection{howto setup a blackmagicprobe}
\label{\detokenize{debugging/blackmagicprobe:howto-setup-a-blackmagicprobe}}
\sphinxAtStartPar
You can buy this probe and support the developers. (make this world a better place)

\sphinxAtStartPar
I bought a “cheapo” “blue pill” stm32 board for future projects …
soldered a 1.8K resistor between 3.3K and PA12

\sphinxAtStartPar
downloaded from \sphinxurl{https://jeelabs.org/docs/software/bmp/}
\sphinxhyphen{} blackmagic.bin (79 ko)
\sphinxhyphen{} blackmagic\_dfu.bin (7 ko)

\sphinxAtStartPar
in jlink : loadbin blackmagic\_dfu.bin 0x8000000 (specify jlink no options …)
switch boot0 or boot1 or whatever
connect usb
in linux
dfu\sphinxhyphen{}util \sphinxhyphen{}v \sphinxhyphen{}R \sphinxhyphen{}d 0483:df11 \sphinxhyphen{}s 0x08002000 \sphinxhyphen{}D blackmagic.bin
(uploading in jlink was a problem cause memory restrictions)

\noindent\sphinxincludegraphics{{blackmagicd6}.jpeg}

\sphinxAtStartPar
(removed boot0 and boot1 connectors on the stm afterwards)

\sphinxAtStartPar
plugged it in the USB port and it pops up (had to enable it first in virtual box usb : black sphere technologies …..)


\section{pseudo}
\label{\detokenize{debugging/pseudo:pseudo}}\label{\detokenize{debugging/pseudo::doc}}

\subsection{simulation on NATIVE\_POSIX\_64}
\label{\detokenize{debugging/pseudo:simulation-on-native-posix-64}}
\sphinxAtStartPar
It is possible to use two serial ports on the virtual posix board.
One can display log message, while the other one lets you interact with the shell.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CONFIG\PYGZus{}UART\PYGZus{}CONSOLE}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}UART\PYGZus{}CONSOLE\PYGZus{}ON\PYGZus{}DEV\PYGZus{}NAME}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UART\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{CONFIG\PYGZus{}UART\PYGZus{}NATIVE\PYGZus{}POSIX\PYGZus{}PORT\PYGZus{}1\PYGZus{}ENABLE}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}UART\PYGZus{}NATIVE\PYGZus{}POSIX\PYGZus{}PORT\PYGZus{}1\PYGZus{}NAME}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UART\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{CONFIG\PYGZus{}SHELL}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}UART\PYGZus{}SHELL\PYGZus{}ON\PYGZus{}DEV\PYGZus{}NAME}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UART\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{root@osboxes:\PYGZti{}/work/app\PYGZsh{} }./build/zephyr/zephyr.exe
\PYG{g+go}{UART\PYGZus{}1 connected to pseudotty: /dev/pts/2}
\PYG{g+go}{UART\PYGZus{}0 connected to pseudotty: /dev/pts/3}


\PYG{g+go}{minicom \PYGZhy{}D /dev/pts/3}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp+gpVirtualEnv}{(you should see log messages)}
\end{sphinxVerbatim}


\section{Bsim}
\label{\detokenize{debugging/bsim:bsim}}\label{\detokenize{debugging/bsim::doc}}
\sphinxAtStartPar
this is a method of debugging a bluetooth enabled application, without a bluetooth device


\subsection{debugging on nrf52\_bsim}
\label{\detokenize{debugging/bsim:debugging-on-nrf52-bsim}}
\sphinxAtStartPar
You can compile the oswatch\sphinxhyphen{}bt sample for the bsim board.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{west} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{nrf52\PYGZus{}bsim} \PYG{n}{oswatch}\PYG{o}{\PYGZhy{}}\PYG{n}{bt}
\PYG{n}{gdb}

\PYG{n}{file} \PYG{n}{build}\PYG{o}{/}\PYG{n}{zephyr}\PYG{o}{/}\PYG{n}{zephyr}\PYG{o}{.}\PYG{n}{elf}
\PYG{n}{b} \PYG{n}{connected} \PYG{p}{(}\PYG{n}{breakpoint} \PYG{n}{on} \PYG{n}{function} \PYG{n}{connected}\PYG{p}{)}
\PYG{n}{r} \PYG{o}{\PYGZhy{}}\PYG{n}{s}\PYG{o}{=}\PYG{n}{trial\PYGZus{}sim} \PYG{o}{\PYGZhy{}}\PYG{n}{d}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\section{Segger RTT (Real Time Transfer)}
\label{\detokenize{debugging/jlink:segger-rtt-real-time-transfer}}\label{\detokenize{debugging/jlink::doc}}

\section{Serial data without a serial port}
\label{\detokenize{debugging/jlink:serial-data-without-a-serial-port}}
\sphinxAtStartPar
Pinetime does not have UART pins but UART\sphinxhyphen{}like connection can be achieved using RTT (Real Time Transfer)
feature of Segger JLink debugger. RTT data can be accessed using the SEGGER tool (JLinkRTTViewer) or by using
telnet connection to active debug session. Second method is recommended since it gives better throughput
and allows bidirectional communication using Zephyr Shell (with RTT as backend). PuTTY can be used to
telnet to debug session.

\sphinxAtStartPar
Prerequisites:
\sphinxhyphen{} JLink debugger, for example one of Nordic Semiconductor Development Kits.
\sphinxhyphen{} Setup: \sphinxurl{https://wiki.pine64.org/index.php/PineTime\#Using\_JLink\_programmer\_and\_nrfjprog\_tools}

\sphinxAtStartPar
Following steps needs to be taken to run RTT shell in the application:
1. Install PuTTY and Setup RTT session. On Linux, copy \sphinxtitleref{misc/rtt\_shell/rtt} to \sphinxtitleref{\textasciitilde{}/putty/sessions}. On Windows,
execute \sphinxtitleref{misc/rtt\_shell/putty\sphinxhyphen{}rtt.reg}.
2. Enable logging and shell over RTT:
\sphinxcode{\sphinxupquote{\textasciigrave{}
CONFIG\_LOG=y
CONFIG\_USE\_SEGGER\_RTT=y
CONFIG\_SHELL=y
CONFIG\_SHELL\_BACKEND\_RTT=y
\textasciigrave{}}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Build and flash application.

\end{enumerate}

\sphinxAtStartPar
4. Start debug session
\sphinxcode{\sphinxupquote{\textasciigrave{}
west debug (will start gdb)
continue (in gdb console)
\textasciigrave{}}}
5. Start PuTTY RTT session, prompt should be printed.

\sphinxAtStartPar
Resources:
\sphinxhyphen{} Zephyr shell documentation: \sphinxurl{https://docs.zephyrproject.org/latest/reference/shell/index.html}
\sphinxhyphen{} Zephyr logger documentation: \sphinxurl{https://docs.zephyrproject.org/latest/reference/logging/index.html}


\chapter{Hacking stuff}
\label{\detokenize{hacking/hacking:hacking-stuff}}\label{\detokenize{hacking/hacking:hacking}}\label{\detokenize{hacking/hacking::doc}}

\section{hacking   the pinetime smartwatch}
\label{\detokenize{hacking/flashing:hacking-the-pinetime-smartwatch}}\label{\detokenize{hacking/flashing::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{o+ow}{is} \PYG{n}{preloaded} \PYG{k}{with} \PYG{n}{firmware}\PYG{o}{.}
\PYG{n}{This} \PYG{n}{firmware} \PYG{o+ow}{is} \PYG{n}{secured}\PYG{p}{,} \PYG{n}{you} \PYG{n}{cannot} \PYG{n}{peek} \PYG{n}{into} \PYG{n}{it}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The pinetime has a swd interface.
To be able to write firmware,  you need special hardware.
I use a stm\sphinxhyphen{}link which is very cheap(2\$).
You can also use the GPIO header of a raspberry pi.
(my repo: \sphinxurl{https://github.com/najnesnaj/openocd} is adapted for the orange pi)
\end{sphinxadmonition}

\sphinxAtStartPar
To flash the software I use openocd :
example for stm\sphinxhyphen{}link usb\sphinxhyphen{}stick

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{} }openocd \PYGZhy{}s /usr/local/share/openocd/scripts \PYGZhy{}f interface/stlink.cfg \PYGZhy{}f target/nrf52.cfg
\end{sphinxVerbatim}

\sphinxAtStartPar
example for the orange\sphinxhyphen{}pi GPIO header (or raspberry)
\begin{quote}

\sphinxAtStartPar
\# openocd \sphinxhyphen{}f /usr/local/share/openocd/scripts/interface/sysfsgpio\sphinxhyphen{}raspberrypi.cfg
\sphinxhyphen{}c ‘transport select swd’ \sphinxhyphen{}f /usr/local/share/openocd/scripts/target/nrf52.cfg
\sphinxhyphen{}c ‘bindto 0.0.0.0’
\end{quote}

\sphinxAtStartPar
once you started the openocd background server, you can connect to it using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}telnet \PYG{l+m}{127}.0.0.1 \PYG{l+m}{4444}
\end{sphinxVerbatim}

\sphinxAtStartPar
programming

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{once your telnet sessions started:}
\PYG{g+go}{Trying 127.0.0.1...}
\PYG{g+go}{Connected to 127.0.0.1.}
\PYG{g+go}{Escape character is \PYGZsq{}\PYGZca{}]\PYGZsq{}.}
\PYG{g+go}{Open On\PYGZhy{}Chip Debugger}
\PYG{g+go}{\PYGZgt{} program zephyr.bin}

\PYG{g+go}{target halted due to debug\PYGZhy{}request, current mode: Thread}
\PYG{g+go}{xPSR: 0x01000000 pc: 0x00001534 msp: 0x20004a10}
\PYG{g+go}{** Programming Started **}
\PYG{g+go}{auto erase enabled}
\PYG{g+go}{using fast async flash loader. This is currently supported}
\PYG{g+go}{only with ST\PYGZhy{}Link and CMSIS\PYGZhy{}DAP. If you have issues, add}
\PYG{g+go}{\PYGZdq{}set WORKAREASIZE 0\PYGZdq{} before sourcing nrf51.cfg/nrf52.cfg to disable it}
\PYG{g+go}{target halted due to breakpoint, current mode: Thread}
\PYG{g+go}{xPSR: 0x61000000 pc: 0x2000001e msp: 0x20004a10}
\PYG{g+go}{wrote 24576 bytes from file zephyr.bin in 1.703540s (14.088 KiB/s)}
\PYG{g+go}{** Programming Finished **}

\PYG{g+go}{And finally execute a reset :}
\PYG{g+go}{\PYGZgt{}reset}
\end{sphinxVerbatim}

\sphinxAtStartPar
removing write protection see:   {\hyperref[\detokenize{hacking/writeprotection:flashing}]{\sphinxcrossref{\DUrole{std,std-ref}{howto flash your zephyr image}}}}


\section{scanning the I2C\_1 port}
\label{\detokenize{hacking/i2cscanning:scanning-the-i2c-1-port}}\label{\detokenize{hacking/i2cscanning:i2cscanning}}\label{\detokenize{hacking/i2cscanning::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{does} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port}\PYG{o}{.}
\PYG{n}{I} \PYG{n}{do} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{segger} \PYG{n}{debugging} \PYG{n}{probe}\PYG{o}{.}
\PYG{n}{A} \PYG{n}{way} \PYG{n}{around} \PYG{n}{this}\PYG{p}{,} \PYG{n}{it} \PYG{n}{to} \PYG{n}{put} \PYG{n}{a} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{memory} \PYG{n}{at} \PYG{n}{a} \PYG{n}{fixed} \PYG{n}{location}\PYG{o}{.}
\PYG{n}{With} \PYG{n}{openocd} \PYG{n}{you} \PYG{n}{can} \PYG{n}{peek} \PYG{n}{at} \PYG{n}{this} \PYG{n}{memory} \PYG{n}{location}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{hacking/i2cscanning:building-and-running}}
\sphinxAtStartPar
In this repo under samples you will find an adapted i2c scanner program.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/i2c\PYGZus{}scanner}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\#define MY\_REGISTER (*(volatile uint8\_t*)0x2000F000)

\sphinxAtStartPar
in the program you can set values:
MY\_REGISTER=1;
MY\_REGISTER=8;

\sphinxAtStartPar
this way you know till where the code executes
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}telnet \PYG{l+m}{127}.0.0.1 \PYG{l+m}{4444}
\end{sphinxVerbatim}

\sphinxAtStartPar
Peeking

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{once your telnet sessions started:}
\PYG{g+go}{Trying 127.0.0.1...}
\PYG{g+go}{Connected to 127.0.0.1.}
\PYG{g+go}{Escape character is \PYGZsq{}\PYGZca{}]\PYGZsq{}.}
\PYG{g+go}{Open On\PYGZhy{}Chip Debugger}
\PYG{g+go}{\PYGZgt{}mdw 0x2000F000 0x1}
\PYG{g+go}{0x2000f000: 00c24418}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Note:}:

\sphinxAtStartPar
this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first….)


\section{howto flash your zephyr image}
\label{\detokenize{hacking/writeprotection:howto-flash-your-zephyr-image}}\label{\detokenize{hacking/writeprotection:flashing}}\label{\detokenize{hacking/writeprotection::doc}}
\sphinxAtStartPar
Once you completed your \sphinxcode{\sphinxupquote{west build}} , your image is located under the build directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{   \PYGZdl{} }\PYG{n+nb}{cd} \PYGZti{}/work/pinetime/zephyr/build/zephyr
\PYG{g+go}{   here you can find zephyr.bin which you can flash}




\PYG{g+go}{I use Openocd to flash.}
\PYG{g+go}{Just connect : telnet 127.0.0.1 4444}

\PYG{g+go}{.. code\PYGZhy{}block:: console}

\PYG{g+go}{    program zephyr.bin}
\end{sphinxVerbatim}


\section{howto remove the write protection}
\label{\detokenize{hacking/writeprotection:howto-remove-the-write-protection}}\begin{description}
\item[{::}] \leavevmode
\sphinxAtStartPar
the PineTime watch is read/write protected (at least the one I got)
executing the following : nrf52.dap apreg 1 0x0c shows 0x0

\sphinxAtStartPar
Mind you, st\sphinxhyphen{}link does not allow you to execute that command, for this you will need a J\sphinxhyphen{}link.

\sphinxAtStartPar
There is a workaround using the GPIO of a raspberry pi or an Orangepi. (in this case you won’t need an external programmer at all)
(You can find an example for the orange pi in my repo :\sphinxurl{https://github.com/najnesnaj/openocd}.)
You have to reconfigure Openocd with the \textendash{}enable\sphinxhyphen{}cmsis\sphinxhyphen{}dap option.

\sphinxAtStartPar
Unlock the chip by executing the command:
\textgreater{} nrf52.dap apreg 1 0x04 0x01

\end{description}


\section{howto configure gateway}
\label{\detokenize{hacking/infrastructure:howto-configure-gateway}}\label{\detokenize{hacking/infrastructure:infrastructure}}\label{\detokenize{hacking/infrastructure::doc}}
\sphinxAtStartPar
Once you completed your \sphinxcode{\sphinxupquote{west build}} , your image is located under the build directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd} \PYGZti{}/work/pinetime/zephyr/build/zephyr
\PYG{g+go}{here you can find zephyr.bin which you can flash}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{I} \PYG{n}{use} \PYG{n}{an} \PYG{n}{orange} \PYG{n}{pi} \PYG{n}{single} \PYG{n}{board} \PYG{n}{computer}\PYG{o}{.}
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{watch} \PYG{o+ow}{is} \PYG{n}{attached} \PYG{n}{to} \PYG{n}{this}\PYG{o}{.}
\PYG{n}{My} \PYG{n}{development} \PYG{o+ow}{is} \PYG{n}{done} \PYG{n}{on} \PYG{n}{a} \PYG{n}{laptop}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
How can you copy from one environment (laptop) to another (SBC) without typing password?
\end{sphinxVerbatim}

\sphinxAtStartPar
On the laptop :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{ssh\PYGZhy{}keygen \PYGZhy{}b 8092 \PYGZhy{}t rsa \PYGZhy{}C \PYGZdq{}fota gw access key\PYGZdq{} \PYGZhy{}f \PYGZti{}/.ssh/orange}
\PYG{g+go}{Generating public/private rsa key pair.}
\PYG{g+go}{Enter passphrase (empty for no passphrase):          (LEAVE EMPTY!)}
\PYG{g+go}{Enter same passphrase again:}
\PYG{g+go}{Your identification has been saved in /root/.ssh/orange.}
\PYG{g+go}{Your public key has been saved in /root/.ssh/orange.pub.}
\PYG{g+go}{The key fingerprint is:}
\PYG{g+go}{SHA256:xCM5Fk1LAVjEWqrM6LKM8Y6+Y12ONt6eV8vDa/KdRUM fota gw access key}
\PYG{g+go}{The key\PYGZsq{}s randomart image is:}
\PYG{g+go}{+\PYGZhy{}\PYGZhy{}\PYGZhy{}[RSA 8092]\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{g+go}{|     ==++.       |}
\PYG{g+go}{|B*B.o+. +ooo     |}
\PYG{g+go}{+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}[SHA256]\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}

\PYG{g+gp+gpVirtualEnv}{(the standard port is 22 and not 9988 which is my custom port)}

\PYG{g+go}{copy the certificate to the SBC (which name is orange in my case):}
\PYG{g+go}{ssh\PYGZhy{}copy\PYGZhy{}id \PYGZhy{}p 9988 \PYGZhy{}i \PYGZti{}/.ssh/orange.pub root@orange}


\PYG{g+go}{create config file :  \PYGZti{}/.ssh/config}
\PYG{g+go}{      Host orange}
\PYG{g+go}{      HostName orange}
\PYG{g+go}{      User root}
\PYG{g+go}{      Port 9988}
\PYG{g+go}{      IdentityFile \PYGZti{}/.ssh/orange}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Now} \PYG{n}{you} \PYG{n}{can} \PYG{n}{copy} \PYG{n}{without} \PYG{n}{a} \PYG{n}{password} \PYG{p}{:}
\PYG{n}{scp} \PYG{n}{build}\PYG{o}{/}\PYG{n}{zephyr}\PYG{o}{/}\PYG{n}{zephyr}\PYG{o}{.}\PYG{n}{bin} \PYG{n}{orange}\PYG{p}{:}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{src}
\end{sphinxVerbatim}
\phantomsection\label{\detokenize{hacking/openocd:openocd}}
\sphinxAtStartPar
w


\section{howto use 2 openocd sessions}
\label{\detokenize{hacking/openocd:howto-use-2-openocd-sessions}}\label{\detokenize{hacking/openocd::doc}}
\sphinxAtStartPar
Once you completed your \sphinxcode{\sphinxupquote{west build}} , your image is located under the build directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{   \PYGZdl{} }\PYG{n+nb}{cd} \PYGZti{}/work/pinetime/zephyr/build/zephyr
\PYG{g+go}{   here you can find zephyr.bin which you can flash}




\PYG{g+go}{I use Openocd to flash.}
\PYG{g+go}{Just connect : telnet 127.0.0.1 4444}

\PYG{g+go}{.. code\PYGZhy{}block:: console}

\PYG{g+go}{    program zephyr.bin}
\end{sphinxVerbatim}


\subsection{Suppose you have 2 microcontrollers}
\label{\detokenize{hacking/openocd:suppose-you-have-2-microcontrollers}}\begin{quote}

\sphinxAtStartPar
Just connect : telnet 127.0.0.1 7777 for the second.
\end{quote}


\subsection{Howto setup a second openocd session on a different port?}
\label{\detokenize{hacking/openocd:howto-setup-a-second-openocd-session-on-a-different-port}}
\sphinxAtStartPar
In this case an ST\sphinxhyphen{}LINK/V2 an in\sphinxhyphen{}circuit debugger and programmer is used.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openocd} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{telnet\PYGZus{}port 7777}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tcl\PYGZus{}port 6667}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gdb\PYGZus{}port 3332}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{share}\PYG{o}{/}\PYG{n}{openocd}\PYG{o}{/}\PYG{n}{scripts} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{interface}\PYG{o}{/}\PYG{n}{stlink}\PYG{o}{.}\PYG{n}{cfg}  \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{target}\PYG{o}{/}\PYG{n}{nrf52}\PYG{o}{.}\PYG{n}{cfg}
\end{sphinxVerbatim}


\subsection{Howto use the GPIO header of a Single Board computer}
\label{\detokenize{hacking/openocd:howto-use-the-gpio-header-of-a-single-board-computer}}
\sphinxAtStartPar
This works really well, and does not require a seperate programmer.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openocd} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{share}\PYG{o}{/}\PYG{n}{openocd}\PYG{o}{/}\PYG{n}{scripts}\PYG{o}{/}\PYG{n}{interface}\PYG{o}{/}\PYG{n}{sysfsgpio}\PYG{o}{\PYGZhy{}}\PYG{n}{raspberrypi}\PYG{o}{.}\PYG{n}{cfg} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transport select swd}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{share}\PYG{o}{/}\PYG{n}{openocd}\PYG{o}{/}\PYG{n}{scripts}\PYG{o}{/}\PYG{n}{target}\PYG{o}{/}\PYG{n}{nrf52}\PYG{o}{.}\PYG{n}{cfg}  \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bindto 0.0.0.0}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}


\section{howto generate pdf documents}
\label{\detokenize{hacking/latexpdf:howto-generate-pdf-documents}}\label{\detokenize{hacking/latexpdf::doc}}
\sphinxAtStartPar
sphinx cannot generate pdf directly, and needs latex

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{latexmk}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{fonts}\PYG{o}{\PYGZhy{}}\PYG{n}{recommended}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{xzdec}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{cmap}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{latex}\PYG{o}{\PYGZhy{}}\PYG{n}{recommended}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{latex}\PYG{o}{\PYGZhy{}}\PYG{n}{extra}
\end{sphinxVerbatim}


\section{The Movie}
\label{\detokenize{hacking/movie:the-movie}}\label{\detokenize{hacking/movie::doc}}
\sphinxAtStartPar
\sphinxurl{https://youtu.be/A-kYHdrr-Mg}

\sphinxAtStartPar
or

\sphinxAtStartPar
oswatchclip.mp4


\subsection{editing :}
\label{\detokenize{hacking/movie:editing}}
\sphinxAtStartPar
Kdenlive


\subsection{script :}
\label{\detokenize{hacking/movie:script}}
\sphinxAtStartPar
LibreOffice Impress


\subsection{Camera :}
\label{\detokenize{hacking/movie:camera}}
\sphinxAtStartPar
SimpleScreenRecorder


\subsection{Voice over :}
\label{\detokenize{hacking/movie:voice-over}}
\sphinxAtStartPar
espeak \sphinxhyphen{}v en+f5 \sphinxhyphen{}a 100 \sphinxhyphen{}p 50 \sphinxhyphen{}s 110 \sphinxhyphen{}f slide2.txt \sphinxhyphen{}w slide2.wav


\subsection{Music by Beethoven:}
\label{\detokenize{hacking/movie:music-by-beethoven}}
\sphinxAtStartPar
fluidsynth \sphinxhyphen{}a pulseaudio \sphinxhyphen{}o audio.alsa.device=hw:1 \sphinxhyphen{}m alsa\_seq \sphinxhyphen{}l \sphinxhyphen{}i /usr/share/sounds/sf2/FluidR3\_GM.sf2 moonlight\_sonata.mid

\sphinxAtStartPar
this one works best :
timidity moonlight\_sonata.mid \sphinxhyphen{}Ow \sphinxhyphen{}o out.wav


\chapter{Behind the scene}
\label{\detokenize{behind/behind:behind-the-scene}}\label{\detokenize{behind/behind:id1}}\label{\detokenize{behind/behind::doc}}

\section{Touchscreen}
\label{\detokenize{behind/touchscreen:touchscreen}}\label{\detokenize{behind/touchscreen::doc}}
\sphinxAtStartPar
In my first release I created a touchscreendriver that read the x\sphinxhyphen{}y coordinates from the pinetime screen.

\sphinxAtStartPar
Meanwhile a rudimentary touchscreen driver exist in Zephyr. (KSCAN\_TOUCH)

\sphinxAtStartPar
It integrates with LVGL.

\sphinxAtStartPar
I managed to adapt the driver from Focaltech, so it now supports the Pinetime as well.

\sphinxAtStartPar
However it is not capable of detecting events like “slide up/down”, but point and click is usable.


\subsection{Overview}
\label{\detokenize{behind/touchscreen:overview}}
\sphinxAtStartPar
Touchscreen Hynitron


\subsection{Requirements}
\label{\detokenize{behind/touchscreen:requirements}}

\subsection{Building and Running}
\label{\detokenize{behind/touchscreen:building-and-running}}

\subsection{Todo}
\label{\detokenize{behind/touchscreen:todo}}\begin{quote}

\sphinxAtStartPar
\sphinxhyphen{}support more touchscreen events
\end{quote}


\subsection{References}
\label{\detokenize{behind/touchscreen:references}}

\section{placing a button on the screen}
\label{\detokenize{behind/lvglbutton:placing-a-button-on-the-screen}}\label{\detokenize{behind/lvglbutton::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{This} \PYG{n}{sample} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{really} \PYG{n}{important}\PYG{p}{,} \PYG{n}{but} \PYG{n}{it} \PYG{n}{will} \PYG{n}{teach} \PYG{n}{you} \PYG{n}{that} \PYG{n}{you} \PYG{n}{need} \PYG{n}{to} \PYG{n+nb}{set} \PYG{n}{LVGL\PYGZus{}CONFIG} \PYG{n}{values}\PYG{p}{,} \PYG{o+ow}{in} \PYG{n}{order}    \PYG{n}{to} \PYG{n}{be} \PYG{n}{able} \PYG{n}{to} \PYG{n}{use} \PYG{n}{LVGL} \PYG{n}{functions}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{behind/lvglbutton:building-and-running}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}


\chapter{About}
\label{\detokenize{about:about}}\label{\detokenize{about::doc}}
\sphinxAtStartPar
I got a pinetime development kit very early.
I would like to thank the folks from \sphinxurl{https://www.pine64.org/} for the kit.

\sphinxAtStartPar
The Nordic nrf52832 is an Arm based, 32bit microcontroller with a lot of flash, RAM memory and(!) bluetooth!
It is a good platform to explore the wonderful world of opensource RTOS’s.
I choose the Zephyr platform, because it already contained the display driver, and the bluetooth functionality.
Furthermore it can be updated wireless.

\sphinxAtStartPar
I started of with adapting simple samples, so they would run on the pinetime watch.
Meanwhile I learned how to adapt the board definition file.
Gradually this morphed into a pinetime\sphinxhyphen{}toolkit.
A few experts contributed and improved this kit so it became usable.

\sphinxAtStartPar
I took a long break from this project, zephyr evolved and a project for creating an open source watch, the hypnos\sphinxhyphen{}firmware flourished.

\sphinxAtStartPar
The drivers for the heartrate sensor, touch panel that I adapted, became obsolete.
The pinetime board definition file is now part of the zephyr RTOS distribution.

\sphinxAtStartPar
Recently I discovered that the standard focaltech touchscreen driver could be adapted easily so it would run on the pinetime and integrate nicely with the LVGL\sphinxhyphen{}gui. There were several OLED ssd1306 watches on my desk and I wondered if I could run Zephyr and LVGL (graphical stuff) on them as well. (yes, we can!)
I played around with the “native\_posix\_64” board, which is a virtual board that allows you to run firmware on your computer instead of on the watch (no need for flashing).

\sphinxAtStartPar
This gave me the idea for an opensource\sphinxhyphen{}watch\sphinxhyphen{}framework.
Start of with simple samples, and add some more functionality, until finally you end up with a smartwatch.
The framework is build around three smartwatches, the pinetime, the ds\_d6 and the posix\_sdl.
It should work on other platform as well, with minor modifications.
I only recently got the idea for out\sphinxhyphen{}of\sphinxhyphen{}tree development.
Just put all the modified drivers, board definitions and application in one place outside of the zephyr\sphinxhyphen{}tree.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{n}{word} \PYG{n}{of} \PYG{n}{warning}\PYG{p}{:} \PYG{n}{this} \PYG{o+ow}{is} \PYG{n}{work} \PYG{o+ow}{in} \PYG{n}{progress}\PYG{o}{.}
\PYG{n}{You}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{re likely to have a better skillset then me.}
\PYG{n}{You} \PYG{n}{are} \PYG{n}{invited} \PYG{n}{to} \PYG{n}{add} \PYG{n}{the} \PYG{n}{missing} \PYG{n}{pieces} \PYG{o+ow}{and} \PYG{n}{to} \PYG{n}{improve} \PYG{n}{what}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s already there.}
\end{sphinxVerbatim}


\chapter{Author}
\label{\detokenize{author:author}}\label{\detokenize{author::doc}}
\sphinxAtStartPar
Some 20 years ago I attended a course on how to brew beer.
Real beer, starting with barley, wheat, yeast, brew kettles …

\sphinxAtStartPar
I bought some brewing equipment and started brewing my own beer.
Apart from a stupid idea, (why brew beer in a country that has plenty of breweries), I soon found out that brewing is labor intensive.

\sphinxAtStartPar
Instead of quitting right away (the most sensible thing to do), I tried to reduce the effort.
I switched from a gas heated kettle to an electric one.

\sphinxAtStartPar
The next step was to control the temperature.
I got an arduino and a temp\sphinxhyphen{}sensor.
This got me interested in microcontrollers.

\sphinxAtStartPar
It appealed to my childish nature, that I could get quick results with little coding.
Blinking a led, really lightens up my day!
And a beer of course.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Guess}\PYG{p}{,} \PYG{n}{even} \PYG{k}{for} \PYG{n}{a} \PYG{n}{technically} \PYG{n}{skilled} \PYG{n}{audiance}\PYG{p}{,} \PYG{n}{story}\PYG{o}{\PYGZhy{}}\PYG{n}{telling}\PYG{p}{,}  \PYG{n}{renders} \PYG{n}{a} \PYG{n}{manual} \PYG{n}{less} \PYG{n}{boring} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}



\renewcommand{\indexname}{Index}
\printindex
\end{document}