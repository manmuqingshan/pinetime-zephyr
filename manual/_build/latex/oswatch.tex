%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}




\title{open source watch Documentation}
\date{Mar 19, 2021}
\release{1.1.0}
\author{jj}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}
\noindent\sphinxincludegraphics{{zephyr_logo}.png}




\chapter{Copyright}
\label{\detokenize{copyright:copyright}}\label{\detokenize{copyright::doc}}
The book is subject to copyright.

You cannot use the book, or parts of the book into your own publications, without the permission of the author.

I have put in most of the code a copyright with my mailadress.
This does not mean anything. It is just to let you know I modified existing code. The code has been tampered with …


\section{author:}
\label{\detokenize{copyright:author}}
Jan Jansen
\sphinxhref{mailto:najnesnaj@yahoo.com}{najnesnaj@yahoo.com}


\section{LICENSE:}
\label{\detokenize{copyright:license}}
All the software is subject to the Apache 2.0 license (same as the Zephyr RTOS)
A permissive license whose main conditions require preservation of copyright and license notices. Contributors provide an express grant of patent rights. Licensed works, modifications, and larger works may be distributed under different terms and without source code.

You could use nRF Connect SDK (often referred as NCS),it is Nordic Semiconductor SDK based on zephyr. It has additional features that could be useful for pinetime, namely bluetooth modules and bluetooth services. Important to mention that even though, NCS forks zephyr it is kept close to it and it is regularly updated to latest zephyr (typically every 2\sphinxhyphen{}3 weeks).

NCS is using BSD\sphinxhyphen{}5\sphinxhyphen{}Clause\sphinxhyphen{}Nordic license (\sphinxurl{https://github.com/NordicPlayground/fw-nrfconnect-nrf/blob/master/LICENSE})
which is why I did not use their samples. (which does not mean, you shouldn’t)

(see also : bluetooth serial communication)


\chapter{Zephyr  smartwatch framework}
\label{\detokenize{content:zephyr-smartwatch-framework}}\label{\detokenize{content::doc}}
Suppose you want to build a cycle computer quickly.
You need :
\sphinxhyphen{} bluetooth
\sphinxhyphen{} a touchscreen
\sphinxhyphen{} a button
\sphinxhyphen{} time (clock)
\sphinxhyphen{} a method of setting the clock
\sphinxhyphen{} wireless firmware updating
\sphinxhyphen{} timer functions
\sphinxhyphen{} powersaving
\sphinxhyphen{} battery management
\sphinxhyphen{} several graphical screens, with buttons graphics

You could start from scratch, or use a framework and only add the stuff you need for your cyclecomputer :
\sphinxhyphen{} cadence sensor
\sphinxhyphen{} display speed
\sphinxhyphen{} record speed

Suppose you have an idea for a portable device, before running to the shop to buy a dev\sphinxhyphen{}board, develop hardware ….
You could use the framework as a startingpoint, since it supports a virtual posix\sphinxhyphen{}board.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{this} \PYG{n}{document} \PYG{n}{started} \PYG{n}{off} \PYG{o+ow}{in} \PYG{n}{setting} \PYG{n}{up} \PYG{n}{zephyr} \PYG{n}{RTOS} \PYG{n}{on} \PYG{n}{the} \PYG{n}{PineTime} \PYG{n}{smartwatch}\PYG{o}{.}

\PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{wiki}\PYG{o}{.}\PYG{n}{pine64}\PYG{o}{.}\PYG{n}{org}\PYG{o}{/}\PYG{n}{index}\PYG{o}{.}\PYG{n}{php}\PYG{o}{/}\PYG{n}{PineTime}

\PYG{n}{It} \PYG{n}{evolved} \PYG{n}{to} \PYG{n}{accomodate} \PYG{n}{other} \PYG{n}{nordic} \PYG{n}{nrf52832} \PYG{n}{based} \PYG{n}{watches} \PYG{p}{(}\PYG{n}{Desay} \PYG{n}{D6}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{a} \PYG{n}{Virtual} \PYG{n}{watch} \PYG{p}{(}\PYG{n}{native\PYGZus{}posix\PYGZus{}64}\PYG{p}{)}

\PYG{n}{Zephyr} \PYG{n}{allows} \PYG{k}{for} \PYG{n}{hardware} \PYG{n}{abstraction}\PYG{o}{.} \PYG{n}{The} \PYG{n}{framework} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{limited} \PYG{n}{to} \PYG{n}{Nordic} \PYG{n}{nrf52}\PYG{o}{.}
\PYG{n}{In} \PYG{n}{theory} \PYG{p}{:} \PYG{n}{compiling} \PYG{k}{with} \PYG{n}{a} \PYG{n}{different} \PYG{n}{board} \PYG{n}{definition} \PYG{n}{file} \PYG{n}{should} \PYG{n}{be} \PYG{n}{enough}\PYG{o}{.} \PYG{p}{(}\PYG{n}{minor} \PYG{n}{changes} \PYG{n}{might} \PYG{n}{be} \PYG{n}{necessary} \PYG{o}{\PYGZhy{}} \PYG{n}{see} \PYG{n}{the} \PYG{n}{button} \PYG{n}{sample}\PYG{p}{)}


\PYG{n}{The} \PYG{n}{virtual} \PYG{n}{watch} \PYG{n}{lets} \PYG{n}{you} \PYG{n}{create} \PYG{o+ow}{and} \PYG{n}{debug} \PYG{n}{software} \PYG{n}{without} \PYG{n}{a} \PYG{n}{watch} \PYG{n}{nor} \PYG{n}{a} \PYG{n}{debugprobe}\PYG{o}{.} \PYG{p}{(}\PYG{o}{=}\PYG{n}{cheap}\PYG{p}{)}
\PYG{n}{There} \PYG{n}{exist} \PYG{n}{a} \PYG{n}{lot} \PYG{n}{of} \PYG{n}{cheap} \PYG{p}{(}\PYG{n}{chinese}\PYG{p}{)} \PYG{n}{watches} \PYG{n}{based} \PYG{n}{on} \PYG{n}{Nordic} \PYG{n}{microcontrollers}\PYG{o}{.}
\PYG{n}{The} \PYG{n}{hardware} \PYG{n}{will} \PYG{n}{probably} \PYG{n}{differ}\PYG{p}{,} \PYG{n}{but} \PYG{k}{with} \PYG{n}{minor} \PYG{n}{adjustments} \PYG{n}{it} \PYG{n}{should} \PYG{n}{be} \PYG{n}{possible} \PYG{n}{to} \PYG{n}{adapt} \PYG{n}{the} \PYG{n}{framework}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{the} \PYG{n}{approach} \PYG{o+ow}{in} \PYG{n}{this} \PYG{n}{manual} \PYG{o+ow}{is} \PYG{n}{to} \PYG{n}{get} \PYG{n}{quick} \PYG{n}{results} \PYG{p}{:}
    \PYG{o}{\PYGZhy{}} \PYG{n}{minimal} \PYG{n}{effort} \PYG{n}{install}
    \PYG{o}{\PYGZhy{}} \PYG{k}{try} \PYG{n}{out} \PYG{n}{the} \PYG{n}{samples}
    \PYG{o}{\PYGZhy{}} \PYG{n}{inspire} \PYG{n}{you} \PYG{n}{to} \PYG{n}{modify} \PYG{o+ow}{and} \PYG{n}{enhance}


\PYG{n}{The} \PYG{n}{masterpiece} \PYG{o+ow}{is} \PYG{n}{the} \PYG{n}{firmware} \PYG{n}{toolkit}\PYG{o}{.}
\PYG{n}{Since} \PYG{n}{it} \PYG{o+ow}{is} \PYG{n}{a} \PYG{n}{big} \PYG{n}{chunk} \PYG{n}{of} \PYG{n}{code}\PYG{p}{,} \PYG{n}{you} \PYG{n}{might} \PYG{n}{be} \PYG{n}{lost}\PYG{o}{.}

\PYG{n}{The} \PYG{n}{samples} \PYG{o+ow}{in} \PYG{n}{the} \PYG{o}{/}\PYG{n}{app} \PYG{n}{directory}\PYG{p}{,} \PYG{n}{contain} \PYG{n}{parts} \PYG{n}{of} \PYG{n}{the} \PYG{n}{toolkit}\PYG{o}{.}
\PYG{n}{Like} \PYG{n}{building} \PYG{n}{blocks}\PYG{p}{,} \PYG{n}{which} \PYG{n}{form} \PYG{n}{the} \PYG{n}{final} \PYG{n}{firmware}\PYG{o}{.}
\end{sphinxVerbatim}
\begin{description}
\item[{suggestion :}] \leavevmode\begin{itemize}
\item {} 
follow the Zephyr installation instructions

\item {} 
try some examples

\item {} 
if you like it copy the /app directory for some more fun

\end{itemize}

\end{description}

\noindent\sphinxincludegraphics{{PineTime-830x400}.png}


\chapter{The idea behind the framework}
\label{\detokenize{idea:the-idea-behind-the-framework}}\label{\detokenize{idea::doc}}
I adapted the pinetime hypnos firmware to run on the Desay D6 smartwatch.

This watch has a small (128x32) oled display and is rather minimalistic.

It does not have a touchscreen, but a single touchbutton.

One cannot run the software of a feature\sphinxhyphen{}rich smartwatch on a simple one.
But the reverse can be done.


\section{Building blocks}
\label{\detokenize{idea:building-blocks}}
A smartwatch has drivers for motion sensors, bluetooth, HR sensor, a battery, a screen, uses a clock, sets the clock, has a button…

If all put together, you’ll end up with the firmware and a big chunk of code.

This project explores features separately, in the “samples” directory.

Reading out a button, how is it done? How do you make a distinction between click, double click, long press? You can find this in the samples directory. These ressembles building blocks or modules.

The oswatch\sphinxhyphen{}xxxx directories assemble some of the building blocks.

The oswatch\sphinxhyphen{}cts shows how the time is set with bluetooth, but also uses the button, the screen, the clock.

Oswatch\sphinxhyphen{}full would include everything.

For your own project you can choose the oswatch\sphinxhyphen{}template which suits you most.


\section{Screen}
\label{\detokenize{idea:screen}}
The OLED screen can only display a few lines.
This is used as a basis for screen layout.

Multiple screens can be displayed, but each screen has little info.


\section{Touchscreen}
\label{\detokenize{idea:touchscreen}}
Although the LVGL graphics library offers touchscreen support and the Pinetimewatch has a touchscreen, the emphasis was put on the sidebutton. Most watches have a button.

Selecting a screen and a parameter on the screen is done with the button instead of the touchscreen.


\section{Heart rate sensor}
\label{\detokenize{idea:heart-rate-sensor}}
Most heart rate sensors have a light sensor and an LED.
Instead of trying to get a heart rate out of it.
Emphasis was put on reading out the light sensor and controlling the LED.

This way my cheap oled watch can be used to read out LED signals, and thus be used as a communication device.

The LED cannot be controlled independently on the pinetime. Suppose you want to use the lightsensor without the led, it is not possible.


\section{Bluetooth}
\label{\detokenize{idea:bluetooth}}
Setting time and timers or other parameters is a nuisance on a small device. It is far more easier to set/read parameters on a linux box or android device and transfer them to the smartwatch.

The easiest would be to use bluetooth UART, this is not a part of the open source zephyr (apache 2 license) , but belongs to Nordic. (which supply their own version of zephyr)

The idea I will explore is to use 2 bluetoothservices, one to request and one to supply the value of a parameter.

Bluetooth is used to set the time (CTS) current time service.


\section{Powersaving}
\label{\detokenize{idea:powersaving}}
Powersaving makes sense when the device is battery operated, which is probably not always the case.
Hence, powersaving is an option.


\section{Updating over the air}
\label{\detokenize{idea:updating-over-the-air}}
FOTA : firmwareupdating over the air, is a usefull option.
The way firmware updates work, is to have two firmware images on the device.
In the case of the cheap OLED device, there is no extra memory to store firmware images.
Hence, FOTA is an option.


\section{Motion sensor}
\label{\detokenize{idea:motion-sensor}}
The motion is used as a stepcounter, but could be used for other purposes as well. Knocksensor, position sensor, movement detection …
emphasis is put on reading out the sensor rather than processing the data.


\section{Drivers}
\label{\detokenize{idea:drivers}}
Creating drivers takes a lot of time. Chances are that a specific driver does not exist for zephyr, or that the standard one does not work fully.

To overcome this problem a zephyr driver that resembles the needed driver is adapted and placed out of tree. In some cases I have not even bothered to change the name. The max30101 lightsensor is not present in the smartwatches I worked with, but it exists as a driver that can easily be adapted. In zephyr this means that the board definition files need to refer to this driver as well. Board definition has to be placed out of tree as well.


\chapter{Install zephyr}
\label{\detokenize{installation:install-zephyr}}\label{\detokenize{installation::doc}}

\section{update on 31\sphinxhyphen{}12\sphinxhyphen{}2020}
\label{\detokenize{installation:update-on-31-12-2020}}
Pinetime has become part of the standard zephyr distribution!

These days you can install zephyr and execute a pinetime sample!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{west} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{pinetime\PYGZus{}devkit0} \PYG{n}{samples}\PYG{o}{/}\PYG{n}{boards}\PYG{o}{/}\PYG{n}{pine64\PYGZus{}pinetime}
\end{sphinxVerbatim}


\section{How to install zephyr}
\label{\detokenize{installation:how-to-install-zephyr}}
\sphinxurl{https://docs.zephyrproject.org/latest/getting\_started/index.html}

the documentation describes an installation process under Ubuntu/macOS/Windows


\section{How to install the open source watch framekit}
\label{\detokenize{installation:how-to-install-the-open-source-watch-framekit}}
The kit should work alongside the zephyr installation.
Just get a copy of the “app” directory.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}work\PYGZgt{}  /app
     ├──/zephyr
     ├──.....
\end{sphinxVerbatim}

the app\sphinxhyphen{}directory contains the drivers and source code and(!) modified board definitions.


\section{Linux rules}
\label{\detokenize{installation:linux-rules}}
The development has been done on a virtual linux machine.
For testing bluetooth functionality, I have used linux as well.
In this manual you’ll find a procedure to communicate to the device from a linuxbox.
Updating the firmware wirelessly? Possible from a linuxbox!

Suppose you want to measure how many steps employees do a day?
You could readout everything using a linuxbox, and handle the data using all the available tools of the box.

\sphinxstylestrong{TIP : sometimes you run into trouble compiling: removing the build directory can help in that case}


\chapter{Out of tree}
\label{\detokenize{out-of-tree:out-of-tree}}\label{\detokenize{out-of-tree::doc}}
A technique used in zephyr/samples/application\sphinxhyphen{}development, is “out of tree” development.

When you tinker with watches, you will soon find out that not all the drivers exist.

You can adapt existing zephyr drivers, but placing them within the zephyr repository could cause issues (upgrading zephyr).

The samples provided contain the board definition and the drivers within their directory outside the zephyr directory.

Have a look at the samples, on how it is done.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{All} \PYG{n}{the} \PYG{n}{development}\PYG{p}{,} \PYG{n}{board} \PYG{n}{definition} \PYG{n}{files}\PYG{p}{,} \PYG{n}{drivers} \PYG{n}{are} \PYG{n}{contained} \PYG{o+ow}{in} \PYG{n}{the} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{app}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{directory}\PYG{o}{.}
\PYG{n}{Copy} \PYG{n}{this} \PYG{n}{directory} \PYG{n}{alongside} \PYG{n}{the} \PYG{n}{zephyr} \PYG{n}{rtos} \PYG{n}{repository}\PYG{p}{,} \PYG{o+ow}{and} \PYG{n}{it} \PYG{n}{should} \PYG{n}{work}\PYG{o}{.}
\PYG{n}{No} \PYG{n}{extra} \PYG{n}{configuration} \PYG{n}{needed}\PYG{o}{.}
\PYG{n}{You} \PYG{n}{can} \PYG{n}{use} \PYG{n}{the} \PYG{n}{latest} \PYG{n}{Zephyr} \PYG{n}{distribution}\PYG{o}{.}
\end{sphinxVerbatim}


\section{Top Tip:}
\label{\detokenize{out-of-tree:top-tip}}
Adapting an existing driver is easier than writing one from scratch.
In the Kconfig you just set another name : instead of SSD1306, you use SSD1306NEW.
You might need to adapt the board definition file \textless{}watch\textgreater{}.dts as well.
Zephyr stitches together parts based on labels. Make sure they match.


\chapter{display}
\label{\detokenize{display:display}}\label{\detokenize{display:display-sample}}\label{\detokenize{display::doc}}

\section{Display   Types}
\label{\detokenize{display:display-types}}
There are three types of display included.
\begin{itemize}
\item {} 
a st7789 color display used in the pinetime

\item {} 
a monochrome SSD1306 OLED display used in the desay D6

\item {} 
a on\sphinxhyphen{}screen display SDL simulated on linux

\end{itemize}


\subsection{Several methods of using the display}
\label{\detokenize{display:several-methods-of-using-the-display}}
Included in the zephyr distribution are :
\sphinxhyphen{} the Little Graphics Library  (LVGL)
\sphinxhyphen{} Character framebuffer (cfb)

For the pinetime the LVGL library might be a good option, since it has a big screen, colors and (!) is touch sensitive.

For the DS\sphinxhyphen{}D6 which has a monochrome OLED small display, the character framebuffer could be the best option.


\subsection{The human eye}
\label{\detokenize{display:the-human-eye}}
You can print something to the serial port, use the Segger RTT, but having a sample which displays something on the screen is the equivalent of blinking a LED.

Instead of the blinky blinking the LED, most samples include the screen.


\chapter{Starting with some basic applications}
\label{\detokenize{basicapplications:starting-with-some-basic-applications}}\label{\detokenize{basicapplications::doc}}
The best way to get a feel of zephyr for the smartwatch, is to start building applications.

The watch framework is under /app.

The framework contains a clock, bluetooth, a procedure to upgrade over the air, cts  …

To reduce the complexity, samples are provided.
Each sample contains a single feature of the framework.


\section{Push the button}
\label{\detokenize{basicapplications:push-the-button}}\begin{itemize}
\item {} 
A button for the posix simulation watch, is a lvgl pushbutton.

\item {} 
A button for the pinetime is a realbutton, which needs 2 (!) gpio ports

\item {} 
A button for the Desay D6 is a real button, which needs 1 gpio port.

\end{itemize}

To complicate matters, a button on the pinetime can be both an lvgl button and a  real gpio\sphinxhyphen{}enabled button.

Using a framework, which would suit these watches, needs to distinguish between the boards (use a condition with parameter : CONFIG\_BOARD)


\section{posix}
\label{\detokenize{basicapplications:posix}}

\subsection{Building and Running}
\label{\detokenize{basicapplications:building-and-running}}
The “native\_posix\_64” board is your own linux\sphinxhyphen{}box.
This means that you can execute the code on your system.
You do not need a smartwatch.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b native\PYGZus{}posix\PYGZus{}64 samples/button/sdlbutton}
\end{sphinxVerbatim}

running : ./build/zephyr/zephyr.exe


\section{pinetime}
\label{\detokenize{basicapplications:pinetime}}

\subsection{Building and Running}
\label{\detokenize{basicapplications:id1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime\PYGZus{}devkit1 samples/button/pinebutton}
\end{sphinxVerbatim}

running : west flash


\subsubsection{Reading out the button on the watch}
\label{\detokenize{basicapplications:reading-out-the-button-on-the-watch}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{does} \PYG{n}{have} \PYG{n}{a} \PYG{n}{button} \PYG{n}{on} \PYG{n}{the} \PYG{n}{side}\PYG{o}{.}
\PYG{n}{The} \PYG{n}{desay} \PYG{n}{D6} \PYG{n}{has} \PYG{n}{a} \PYG{n}{touchbutton} \PYG{o+ow}{in} \PYG{n}{front}\PYG{o}{.}
\PYG{n}{The} \PYG{n}{virtual} \PYG{n}{POSIX} \PYG{n}{watch} \PYG{n}{has} \PYG{n}{a} \PYG{n}{touchbutton}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Note:}:
\sphinxtitleref{The pinetime watch has a button out port (15) and button in port (13). You have to set the out\sphinxhyphen{}port high. Took me a while to figure this out…}


\chapter{LittlevGL Basic Sample}
\label{\detokenize{lvgl:littlevgl-basic-sample}}\label{\detokenize{lvgl:lvgl-sample}}\label{\detokenize{lvgl::doc}}

\section{Overview}
\label{\detokenize{lvgl:overview}}
This sample application displays “Hello World” in the center of the screen
and a counter at the bottom which increments every second.

LittlevGL is a free and open\sphinxhyphen{}source graphics library providing everything you need to create embedded GUI with easy\sphinxhyphen{}to\sphinxhyphen{}use graphical elements, beautiful visual effects and low memory footprint.


\section{Simulation}
\label{\detokenize{lvgl:simulation}}
In order to avoid uploading to check what the display looks like, there is a simple way to simulate this.
I’ve tested this on Ubuntu 18.04 64bit. You’ll need the SDL2 library.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b native\PYGZus{}posix\PYGZus{}64 samples/display/lvgl}
\end{sphinxVerbatim}

after the building, you can find build/zephyr/zephyr.exe (and execute this to see display\sphinxhyphen{}layout)

the sample is provided as samples/display/lvgl\sphinxhyphen{}posix


\section{Pinetime}
\label{\detokenize{lvgl:pinetime}}
The program has been modified to light up the background leds.

\sphinxstylestrong{TIP: matching label : DISPLAY}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Matching labels are necessary!
pinetime.conf:CONFIG\PYGZus{}LVGL\PYGZus{}DISPLAY\PYGZus{}DEV\PYGZus{}NAME=\PYGZdq{}DISPLAY\PYGZdq{}
pinetime.overlay:               label = \PYGZdq{}DISPLAY\PYGZdq{}; (spi definition)
\end{sphinxVerbatim}


\section{Building and Running}
\label{\detokenize{lvgl:building-and-running}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/lvgl}
\end{sphinxVerbatim}


\subsection{modifying the font size :}
\label{\detokenize{lvgl:modifying-the-font-size}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}t menuconfig}
\end{sphinxVerbatim}
\begin{description}
\item[{goto:}] \leavevmode\begin{itemize}
\item {} 
additional libraries

\item {} 
lvgl gui library

\end{itemize}

(look for fonts, and adapt according to your need)

\end{description}


\subsection{apply changes of the changed config:}
\label{\detokenize{lvgl:apply-changes-of-the-changed-config}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build}
\end{sphinxVerbatim}

(instead of west build \sphinxhyphen{}p (pristine) which wipes out your customisation)


\section{References}
\label{\detokenize{lvgl:references}}
\sphinxurl{https://docs.littlevgl.com/en/html/index.html}

LittlevGL Web Page: \sphinxurl{https://littlevgl.com/}


\chapter{Real Time Clock}
\label{\detokenize{RTC:real-time-clock}}\label{\detokenize{RTC:rtc}}\label{\detokenize{RTC::doc}}
The compile\sphinxhyphen{}time is used to set the initial time. (CMAKE file)

The elapsed time since the startup can be calculated.

Setting the exact time is done via bluetooth current time service.


\section{Overview}
\label{\detokenize{RTC:overview}}

\section{References}
\label{\detokenize{RTC:references}}

\chapter{Current Time Service}
\label{\detokenize{current-time:current-time-service}}\label{\detokenize{current-time::doc}}
\sphinxurl{https://www.bluetooth.com/specifications/gatt/services/}
\sphinxurl{https://www.bluetooth.com/specifications/gatt/characteristics/}
0x1805 current time service
0x2A2B current time characteristic


\section{Requirements:}
\label{\detokenize{current-time:requirements}}\begin{description}
\item[{You need :}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{a CTS server (use of bluez on linux explained)}] \leavevmode\begin{itemize}
\item {} 
start the CTS service (python script)

\item {} 
connect to the CTS client

\end{itemize}

\end{description}

\item {} 
a CTS client (the pinetime watch)

\end{itemize}

\end{description}


\section{BLE Peripheral CTS sample for zephyr}
\label{\detokenize{current-time:ble-peripheral-cts-sample-for-zephyr}}
This example demonstrates the basic usage of the current time service.
It is based on the \sphinxurl{https://github.com/Dejvino/pinetime-hermes-firmware}.
It starts advertising it’s UUID, and you can connect to it.
Once connected, it will read the time from your CTS server (bluez on linux running the gatt\sphinxhyphen{}cts\sphinxhyphen{}server script in my case)

first build the image

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}}  west build \PYGZhy{}p \PYGZhy{}b pinetime samples/bluetooth/peripheral\PYGZhy{}cts
\end{sphinxVerbatim}


\section{Using bluez on linux to connect}
\label{\detokenize{current-time:using-bluez-on-linux-to-connect}}\begin{description}
\item[{The pinetime zephyr sample behaves as a peripheral:}] \leavevmode\begin{itemize}
\item {} 
first of all start the cts service

\item {} 
connect to the pinetime with bluetoothctl

\end{itemize}

\end{description}

Using bluetoothctl:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}bluetoothctl
\PYG{g+gp}{[bluetooth]\PYGZsh{}}scan on


\PYG{g+go}{[NEW] Device 60:7C:9E:92:50:C1 Zephyr Peripheral Sample Long}
\PYG{g+go}{once you see your device}
\PYG{g+gp}{[blueooth]\PYGZsh{}}connect \PYG{l+m}{60}:7C:9E:92:50:C1 \PYG{o}{(}the device mac address as displayed\PYG{o}{)}
\end{sphinxVerbatim}


\section{Howto use Bluez on linux to set up a time service}
\label{\detokenize{current-time:howto-use-bluez-on-linux-to-set-up-a-time-service}}
Within the bluez source distribution there is an example GATT (Generic Attribute Profile)server. It advertises some standard service such as heart rate, battery …
Koen zandberg adapted this script, so it advertises the current time :
\sphinxurl{https://github.com/bosmoment/gatt-cts/blob/master/gatt-cts-server.py}

You might have to install extra packages:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{apt\PYGZhy{}get install python\PYGZhy{}dbus}
\PYG{g+go}{apt\PYGZhy{}get install python\PYGZhy{}gi}
\PYG{g+go}{apt\PYGZhy{}get install python\PYGZhy{}gobject}
\end{sphinxVerbatim}


\section{Howto use Android to set up a time service}
\label{\detokenize{current-time:howto-use-android-to-set-up-a-time-service}}
As soon as a device is bonded, Pinetime will look for a CTS server (Current Time Service) on the connected device.
Here is how to do it with an Android smartphone running NRFConnect:

Build and program the firmware on the Pinetime Install NRFConnect (\sphinxurl{https://www.nordicsemi.com/Software-and-Tools/Development-Tools/nRF-Connect-for-desktop})

Start NRFConnect and create a CTS server : Tap the hamburger button on the top left and select “Configure GATT server” Tap “Add service” on the bottom Select server configuration “Current Time Service” and tap OK Go back to the main screen and scan for BLE devices. A device called “PineTime” should appear Tap the button “Connect” next to the PineTime device. It should connect to the PineTime and switch to a new tab. On this tab, on the top right, there is a 3 dots button. Tap on it and select Bond. The bonding process begins, and if it is successful, the PineTime should update its time and display it on the screen.


\chapter{Drivers}
\label{\detokenize{drivers/drivers:drivers}}\label{\detokenize{drivers/drivers:id1}}\label{\detokenize{drivers/drivers::doc}}

\section{configuring I2C}
\label{\detokenize{drivers/i2c:configuring-i2c}}\label{\detokenize{drivers/i2c::doc}}

\subsection{board level definitions}
\label{\detokenize{drivers/i2c:board-level-definitions}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{under} \PYG{n}{boards}\PYG{o}{/}\PYG{n}{arm}\PYG{o}{/}\PYG{n}{pinetime} \PYG{n}{are} \PYG{n}{the} \PYG{n}{board} \PYG{n}{definitions}
\PYG{o}{\PYGZhy{}} \PYG{n}{pinetime}\PYG{o}{.}\PYG{n}{dts}
\PYG{o}{\PYGZhy{}} \PYG{n}{pinetime\PYGZus{}defconfig}


\PYG{n}{The} \PYG{n}{sensors} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{pinetime} \PYG{n}{use} \PYG{n}{the} \PYG{n}{I2C} \PYG{n}{bus}\PYG{o}{.}

\PYG{o}{\PYGZam{}}\PYG{n}{i2c1} \PYG{p}{\PYGZob{}}
        \PYG{n}{compatible} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nordic,nrf\PYGZhy{}twi}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{status} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{okay}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sda}\PYG{o}{\PYGZhy{}}\PYG{n}{pin} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{scl}\PYG{o}{\PYGZhy{}}\PYG{n}{pin} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{7}\PYG{o}{\PYGZgt{}}\PYG{p}{;}

      \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{definition on project level}
\label{\detokenize{drivers/i2c:definition-on-project-level}}
In the directory of a sample, you will find a prj.conf file.
Here you can set values specific for you project/sample.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{In} \PYG{n}{the} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{prj.conf}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{file} \PYG{n}{we} \PYG{n}{define} \PYG{n}{the} \PYG{n}{sensor} \PYG{p}{(}\PYG{n}{eg} \PYG{n}{adxl372}\PYG{p}{)}

\PYG{n}{CONFIG\PYGZus{}STDOUT\PYGZus{}CONSOLE}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}LOG}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}I2C}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}SENSOR}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}ADXL372}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}ADXL372\PYGZus{}I2C}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}SENSOR\PYGZus{}LOG\PYGZus{}LEVEL\PYGZus{}WRN}\PYG{o}{=}\PYG{n}{y}
\end{sphinxVerbatim}

\sphinxstylestrong{note: this gets somehow merged (overlayed) with the board definition pinetime\_defconfig}


\section{SSD1306 modification}
\label{\detokenize{drivers/ssd1306:ssd1306-modification}}\label{\detokenize{drivers/ssd1306::doc}}

\subsection{board level definitions}
\label{\detokenize{drivers/ssd1306:board-level-definitions}}
The desay D6 OLED display gets it power trough a GPIO pin.

In the board definition file one can set it high.

Some minor adjustment in board.c was needed.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{under} \PYG{n}{boards}\PYG{o}{/}\PYG{n}{arm}\PYG{o}{/}\PYG{n}{ds\PYGZus{}d6} \PYG{n}{are} \PYG{n}{the} \PYG{n}{board} \PYG{n}{definitions}
\PYG{o}{\PYGZhy{}} \PYG{n}{ds\PYGZus{}d6}\PYG{o}{.}\PYG{n}{dts}
\PYG{o}{\PYGZhy{}} \PYG{n}{ds\PYGZus{}d6\PYGZus{}defconfig}



\PYG{n}{vdd\PYGZus{}pwr}\PYG{p}{:} \PYG{n}{vdd}\PYG{o}{\PYGZhy{}}\PYG{n}{pwr}\PYG{o}{\PYGZhy{}}\PYG{n}{ctrl} \PYG{p}{\PYGZob{}}
        \PYG{n}{compatible} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{regulator\PYGZhy{}fixed}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{vdd\PYGZhy{}pwr\PYGZhy{}ctrl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{regulator}\PYG{o}{\PYGZhy{}}\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{vdd\PYGZhy{}pwr\PYGZhy{}ctrl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{enable}\PYG{o}{\PYGZhy{}}\PYG{n}{gpios} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZam{}}\PYG{n}{gpio0} \PYG{l+m+mi}{26} \PYG{n}{GPIO\PYGZus{}ACTIVE\PYGZus{}HIGH}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{regulator}\PYG{o}{\PYGZhy{}}\PYG{n}{boot}\PYG{o}{\PYGZhy{}}\PYG{n}{on}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The driver has been placed “out of tree”.
It is a modified ssd1306 driver.
The ssd1306 behaved somewhat differently.
It was renamed to ssd1306new to avoid confusion.
In the board definition file the label was adapted.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ssd1306new}\PYG{o}{@}\PYG{l+m+mi}{0} \PYG{p}{\PYGZob{}}
        \PYG{n}{compatible} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{solomon,ssd1306fb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{spi}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{max}\PYG{o}{\PYGZhy{}}\PYG{n}{frequency} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{80000000}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SSD1306NEW}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{reg} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{segment}\PYG{o}{\PYGZhy{}}\PYG{n}{offset} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{page}\PYG{o}{\PYGZhy{}}\PYG{n}{offset} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{display}\PYG{o}{\PYGZhy{}}\PYG{n}{offset} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{multiplex}\PYG{o}{\PYGZhy{}}\PYG{n}{ratio} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{31}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{height} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{32}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{width} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{128}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{segment}\PYG{o}{\PYGZhy{}}\PYG{n}{remap}\PYG{p}{;}
        \PYG{n}{prechargep} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mh}{0xF1}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{reset}\PYG{o}{\PYGZhy{}}\PYG{n}{gpios} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZam{}}\PYG{n}{gpio0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{data\PYGZus{}cmd}\PYG{o}{\PYGZhy{}}\PYG{n}{gpios} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZam{}}\PYG{n}{gpio0} \PYG{l+m+mi}{28} \PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{definition config}
\label{\detokenize{drivers/ssd1306:definition-config}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{In} \PYG{n}{the} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ds\PYGZus{}d6\PYGZus{}defconfig}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{file} \PYG{n}{we} \PYG{n}{define} \PYG{n}{the} \PYG{n}{driver}


 \PYG{n}{CONFIG\PYGZus{}LVGL\PYGZus{}DISPLAY\PYGZus{}DEV\PYGZus{}NAME}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SSD1306NEW}\PYG{l+s+s2}{\PYGZdq{}}
 \PYG{n}{CONFIG\PYGZus{}SSD1306NEW}\PYG{o}{=}\PYG{n}{y}
\end{sphinxVerbatim}


\section{sensors on the I2C bus}
\label{\detokenize{drivers/sensors:sensors-on-the-i2c-bus}}\label{\detokenize{drivers/sensors::doc}}
0x18: Accelerometer: BMA423\sphinxhyphen{}DS000
\sphinxurl{https://github.com/BoschSensortec/BMA423-Sensor-API}

0x44: Heart Rate Sensor: HRS3300\_Heart

0x15: Touch Controller: Hynitron CST816S Touch Controller


\section{Bosch BMA421}
\label{\detokenize{drivers/bma421:bosch-bma421}}\label{\detokenize{drivers/bma421::doc}}
this driver does not exist, so it has been created.
Still work in progress ….

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/gui/lvaccel}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/bma421:overview}}
BMA421 is not a part number available to the general public, and therefore all the supporting documentation and design resources are neither discussed in public forums, nor disclosed on GitHub.

CHIP\_ID=0X11  (so the Bosch BMA423 drivers need to be adapted)

The Bosch documentation on the bma423 seems to apply to the bma421.


\subsection{Requirements}
\label{\detokenize{drivers/bma421:requirements}}
for this sensor does not exist any driver, so here’s what I did to create one under zephyr


\subsubsection{adapt CMakeLists.txt}
\label{\detokenize{drivers/bma421:adapt-cmakelists-txt}}
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/drivers/sensor
add\_subdirectory\_ifdef(CONFIG\_BMA280            bma280)
add\_subdirectory\_ifdef(CONFIG\_BMA421            bma421)


\subsubsection{adapt Kconfig}
\label{\detokenize{drivers/bma421:adapt-kconfig}}
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/drivers/sensor


\subsubsection{add yaml file}
\label{\detokenize{drivers/bma421:add-yaml-file}}
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/dts/bindings/sensor
cp bosch,bma280\sphinxhyphen{}i2c.yaml  bosch,bma421\sphinxhyphen{}i2c.yaml


\subsubsection{edit KConfig}
\label{\detokenize{drivers/bma421:edit-kconfig}}\begin{description}
\item[{source “drivers/sensor/bma280/Kconfig”}] \leavevmode
source “drivers/sensor/bma421/Kconfig”

\end{description}

source “drivers/sensor/bmc150\_magn/Kconfig”

source “drivers/sensor/bme280/Kconfig”


\subsubsection{create driver}
\label{\detokenize{drivers/bma421:create-driver}}
see under drivers/sensor/bma421

complement the pinetime.dts file with the following (under samples/sensor/bma280)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        bma421@18 \PYGZob{}}
\PYG{g+go}{                   compatible = \PYGZdq{}bosch,bma421\PYGZdq{};}
\PYG{g+go}{                   reg = \PYGZlt{}0x18\PYGZgt{};}
\PYG{g+go}{                   label = \PYGZdq{}BMA421\PYGZdq{};}
\PYG{g+go}{                   int1\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 8 0\PYGZgt{};}
\PYG{g+go}{                  \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}

Create a file: \sphinxtitleref{/dts/bindings/sensor/bosch,bma421\sphinxhyphen{}i2c.yaml}.
Which contains:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{compatible}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bosch,bma421}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{include}\PYG{p}{:} \PYG{n}{i2c}\PYG{o}{\PYGZhy{}}\PYG{n}{device}\PYG{o}{.}\PYG{n}{yaml}
\PYG{n}{properties}\PYG{p}{:}
       \PYG{n}{int1}\PYG{o}{\PYGZhy{}}\PYG{n}{gpios}\PYG{p}{:}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{phandle}\PYG{o}{\PYGZhy{}}\PYG{n}{array}
       \PYG{n}{required}\PYG{p}{:} \PYG{n}{false}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/bma421:building-and-running}}

\subsection{Todo}
\label{\detokenize{drivers/bma421:todo}}\begin{itemize}
\item {} 
the driver is interrupt driven as well \textendash{} need to test software

\item {} 
the sensor has algorithm for steps \textendash{} read out register

\item {} 
temperature some attempt has been made, but … (OK, temp can be read)

\end{itemize}


\subsection{References}
\label{\detokenize{drivers/bma421:references}}
Bosch has documented the BMA423 very well.
I kind of hope it will apply to the bma421.

A mechanism to adapt the 0x5E register is provided.
(burst read/write)

All kind of parameters can be set to trigger an interrupt.
(e.g. number of steps taken : think of the 10000 steps threshold)


\section{HYNITRON CST816S}
\label{\detokenize{drivers/cst816s:hynitron-cst816s}}\label{\detokenize{drivers/cst816s::doc}}
Zephyr has evolved and now there is something that serve as a touchscreen device.
(KSCAN\_TOUCH)

the board definition file has been adapted slightly, using the focaltech ft5336 as a touch\_controller. A minor change in this driver is enough to get data from the hynitron cst816S.

The big advantage : almost standard zephyr install!
Unfortunately I cannot get the KSCAN\_TOUCH working in an out\sphinxhyphen{}of\sphinxhyphen{}tree setup.

I have created the renamed ft9999 driver.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime\PYGZus{}devkit0 samples/display/lvgl}
\end{sphinxVerbatim}

this driver does not exist, so it has been created.
Still work in progress ….


\subsection{Overview}
\label{\detokenize{drivers/cst816s:overview}}
(this is the old way of doing things ….)

the Hynitron cst816s is a touchscreen.
Zephyr doesn’t handle touchscreens yet.
In order to investigate, the touchscreen driver has been created as a sensor.
In fact it senses your finger ;)


\subsection{Requirements}
\label{\detokenize{drivers/cst816s:requirements}}
for this sensor does not exist any driver, so here’s what I did to create one under zephyr

adapt CMakeLists.txt
adapt Kconfig
add yaml file


\subsubsection{create driver}
\label{\detokenize{drivers/cst816s:create-driver}}
The driver reads only one position.
Multitouch is possible, but the screen is small….

see under drivers/sensor/cst816s

have a look at the pinetime.dts (under board/arm/pinetime) file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        cst816s@15 \PYGZob{}}
\PYG{g+go}{                   compatible = \PYGZdq{}hynitron,cst816s\PYGZdq{};}
\PYG{g+go}{                   reg = \PYGZlt{}0x15\PYGZgt{};}
\PYG{g+go}{                   label = \PYGZdq{}CST816S\PYGZdq{};}
\PYG{g+go}{                   \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/cst816s:building-and-running}}\begin{description}
\item[{There are two samples :}] \leavevmode\begin{itemize}
\item {} 
samples/gui/lvtouch (graphical)

\item {} 
samples/sensor/cst816s (no graphics)

\end{itemize}

\end{description}


\subsection{Todo}
\label{\detokenize{drivers/cst816s:todo}}
The graphical sample doesn’t handle interrupts.


\subsection{References}
\label{\detokenize{drivers/cst816s:references}}
There is little available for this touchscreen.


\section{HX HRS3300}
\label{\detokenize{drivers/hrs3300:hx-hrs3300}}\label{\detokenize{drivers/hrs3300::doc}}
this driver does not exist, so it has been created.
Still work in progress ….

there is a sample in this repository which can be copied to the zephyr samples directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/sensor/hrs3300}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/hrs3300:overview}}
The HX HRS3300 sensor is a heart rate sensor, it produces 2 values: ALS and HRS. Ambient LIGHT SENSOR and HEART RATE SENSOR. Which have to be processed by an algorithm. I have no knowledge of a good open source algorithm yet.

I have used the settings of an arduino port of this library.

\noindent\sphinxincludegraphics{{hrs3300}.jpg}


\subsection{Requirements}
\label{\detokenize{drivers/hrs3300:requirements}}
for this sensor does not exist any driver, so here’s what I did to create one under zephyr


\subsubsection{adapt CMakeLists.txt}
\label{\detokenize{drivers/hrs3300:adapt-cmakelists-txt}}
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/drivers/sensor
add\_subdirectory\_ifdef(CONFIG\_HRS3300           hrs3300)


\subsubsection{adapt Kconfig}
\label{\detokenize{drivers/hrs3300:adapt-kconfig}}
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/drivers/sensor


\subsubsection{add yaml file}
\label{\detokenize{drivers/hrs3300:add-yaml-file}}
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/dts/bindings/sensor
add  hx,hrs3300.yaml


\subsubsection{edit KConfig}
\label{\detokenize{drivers/hrs3300:edit-kconfig}}
source “drivers/sensor/hrs3300/Kconfig”


\subsubsection{create driver}
\label{\detokenize{drivers/hrs3300:create-driver}}
see under drivers/sensor/hrs3300

complement the pinetime.dts file with the following (under samples/sensor/bma280)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        hrs3300@44 \PYGZob{}}
\PYG{g+go}{                   compatible = \PYGZdq{}hx,hrs3300\PYGZdq{};}
\PYG{g+go}{                   reg = \PYGZlt{}0x44\PYGZgt{};}
\PYG{g+go}{                   label = \PYGZdq{}HRS3300\PYGZdq{};}
\PYG{g+go}{                   \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}

Create a file: \sphinxtitleref{/dts/bindings/sensor/hx,hrs3300.yaml}.
Which contains:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{compatible}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hx,hrs3300}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{properties}\PYG{p}{:}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/hrs3300:building-and-running}}

\subsection{Todo}
\label{\detokenize{drivers/hrs3300:todo}}\begin{itemize}
\item {} 
algorithm for heartrate

\item {} 
power saving

\item {} 
switching off/on mechanism

\end{itemize}


\subsection{References}
\label{\detokenize{drivers/hrs3300:references}}
HRS3300 Heart Rate Sensor.pdf
\sphinxurl{https://github.com/atc1441/HRS3300-Arduino-Library}


\section{Serial Nor Flash}
\label{\detokenize{drivers/spinor:serial-nor-flash}}\label{\detokenize{drivers/spinor::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/spi\PYGZus{}flash \PYGZhy{}DCONF=prj.conf}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/spinor:overview}}
This sample application should unlock the serial nor flash memory.
This can be very usefull to store e.g. background for the watch.

compilation problematic ….

/root/zephyrproject/zephyr/samples/drivers/spi\_flash/src/main.c:17:22: error: ‘DT\_INST\_0\_JEDEC\_SPI\_NOR\_LABEL’ undeclared (first use in this function); did you mean ‘DT\_INST\_0\_NORDIC\_NRF\_RTC\_LABEL’?

Turns out this is some problem with the board definition file.

I found it to be very useful to consult the generated dts file.
Here you can check if everything is present.

Guess the dts\sphinxhyphen{}file has to be well intended.(structured)

{\color{red}\bfseries{}**}TIP: consult the generated dts board file **


\subsubsection{consulting the generated board definition file}
\label{\detokenize{drivers/spinor:consulting-the-generated-board-definition-file}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{vi /root/zephyrproject/zephyr/build/zephyr/include/generated/generated\PYGZus{}dts\PYGZus{}board.conf}
\end{sphinxVerbatim}


\subsection{Requirements}
\label{\detokenize{drivers/spinor:requirements}}
complement the pinetime.dts file with the following (under spi)
\#define JEDEC\_ID\_MACRONIX\_MX25L64      0xC22017

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}spi0 \PYGZob{}}
\PYG{g+go}{  compatible = \PYGZdq{}nordic,nrf\PYGZhy{}spi\PYGZdq{};}
\PYG{g+go}{  status = \PYGZdq{}okay\PYGZdq{};}
\PYG{g+go}{  sck\PYGZhy{}pin = \PYGZlt{}2\PYGZgt{};}
\PYG{g+go}{  mosi\PYGZhy{}pin = \PYGZlt{}3\PYGZgt{};}
\PYG{g+go}{  miso\PYGZhy{}pin = \PYGZlt{}4\PYGZgt{};}
\PYG{g+go}{  cs\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 27 0\PYGZgt{},\PYGZlt{}\PYGZam{}gpio0 5 0\PYGZgt{};}
\PYG{g+go}{  st7789v@0 \PYGZob{}}
\PYG{g+go}{          compatible = \PYGZdq{}sitronix,st7789v\PYGZdq{};}
\PYG{g+go}{          label = \PYGZdq{}DISPLAY\PYGZdq{};}
\PYG{g+go}{          spi\PYGZhy{}max\PYGZhy{}frequency = \PYGZlt{}8000000\PYGZgt{};}
\PYG{g+go}{          reg = \PYGZlt{}0\PYGZgt{};}
\PYG{g+go}{          cmd\PYGZhy{}data\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 18 0\PYGZgt{};}
\PYG{g+go}{          reset\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 26 0\PYGZgt{};}
\PYG{g+go}{          width = \PYGZlt{}240\PYGZgt{};}
\PYG{g+go}{          height = \PYGZlt{}240\PYGZgt{};}
\PYG{g+go}{          x\PYGZhy{}offset = \PYGZlt{}0\PYGZgt{};}
\PYG{g+go}{          y\PYGZhy{}offset = \PYGZlt{}0\PYGZgt{};}
\PYG{g+go}{          vcom = \PYGZlt{}0x19\PYGZgt{};}
\PYG{g+go}{          gctrl = \PYGZlt{}0x35\PYGZgt{};}
\PYG{g+go}{          vrhs = \PYGZlt{}0x12\PYGZgt{};}
\PYG{g+go}{          vdvs = \PYGZlt{}0x20\PYGZgt{};}
\PYG{g+go}{          mdac = \PYGZlt{}0x00\PYGZgt{};}
\PYG{g+go}{          gamma = \PYGZlt{}0x01\PYGZgt{};}
\PYG{g+go}{          colmod = \PYGZlt{}0x05\PYGZgt{};}
\PYG{g+go}{          lcm = \PYGZlt{}0x2c\PYGZgt{};}
\PYG{g+go}{          porch\PYGZhy{}param = [0c 0c 00 33 33];}
\PYG{g+go}{          cmd2en\PYGZhy{}param = [5a 69 02 01];}
\PYG{g+go}{          pwctrl1\PYGZhy{}param = [a4 a1];}
\PYG{g+go}{          pvgam\PYGZhy{}param = [D0 04 0D 11 13 2B 3F 54 4C 18 0D 0B 1F 23];}
\PYG{g+go}{          nvgam\PYGZhy{}param = [D0 04 0C 11 13 2C 3F 44 51 2F 1F 1F 20 23];}
\PYG{g+go}{          ram\PYGZhy{}param = [00 F0];}
\PYG{g+go}{          rgb\PYGZhy{}param = [CD 08 14];}

\PYG{g+go}{  \PYGZcb{};}

\PYG{g+go}{  mx25r64: mx25r6435f@1 \PYGZob{}}
\PYG{g+go}{          compatible = \PYGZdq{}jedec,spi\PYGZhy{}nor\PYGZdq{};}
\PYG{g+go}{          reg = \PYGZlt{}1\PYGZgt{};}
\PYG{g+go}{          spi\PYGZhy{}max\PYGZhy{}frequency = \PYGZlt{}1000000\PYGZgt{};}
\PYG{g+go}{          label = \PYGZdq{}MX25R64\PYGZdq{};}
\PYG{g+go}{          jedec\PYGZhy{}id = [0b 40 16];}
\PYG{g+go}{          size = \PYGZlt{}67108864\PYGZgt{};}
\PYG{g+go}{          has\PYGZhy{}be32k;}
\PYG{g+go}{  \PYGZcb{};}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/spinor:building-and-running}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/spi\PYGZus{}flash}
\end{sphinxVerbatim}


\subsection{Todo}
\label{\detokenize{drivers/spinor:todo}}\begin{quote}
\begin{itemize}
\item {} 
detect ID memory  : it is not the macronix one as suggestion on the pinetime website

\end{itemize}

I found the following : jedec\sphinxhyphen{}id = {[}0b 40 16{]}; (OK: can execute sample program)
\begin{itemize}
\item {} 
create working board definition (OK: see above)

\end{itemize}
\end{quote}


\subsection{References}
\label{\detokenize{drivers/spinor:references}}
\sphinxurl{http://files.pine64.org/doc/datasheet/pinetime/MX25L6433F,\%203V,\%2064Mb,\%20v1.6.pdf}


\section{Battery}
\label{\detokenize{drivers/battery:battery}}\label{\detokenize{drivers/battery::doc}}
the samples just gets an analog reading from the battery

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/sensor/battery}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/battery:overview}}
The battery level is measured on port 31, trough an ADC conversion.

voltage = (value * 6)/1024
percentage remaining  ((voltage \sphinxhyphen{} 3.55)*100)*3.9;

A module should be able to report battery status in millivolts and charge level in percentage. Additionally, it should notify when external power is connected and when battery is being charged.
Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
Battery voltage can be in range from 3.0V \sphinxhyphen{} 4.2V (?). Unfortunately, internal reference (0.6V) can only be used for voltages up to 3.6V (due to minimal gain of 1/6). VDD/4 reference can be used with 1/6 gain to measure voltages up to 4.95V. Test is needed to check how accurate is VDD as reference.
Discharge curve (\sphinxurl{https://forum.pine64.org/showthread.php?tid=8147}) will be used to calculate charge level in percent.
Things to consider:
saadc periodical calibration (spec suggests calibration if temperature changes by 10’C)
inaccuracy of results: oversampling? never report higher level than before (if charge not connected), etc.


\subsection{Todo}
\label{\detokenize{drivers/battery:todo}}
check pin when charging


\subsection{References}
\label{\detokenize{drivers/battery:references}}
\sphinxurl{https://forum.pine64.org/showthread.php?tid=8147}


\section{Watchdog}
\label{\detokenize{drivers/watchdog:watchdog}}\label{\detokenize{drivers/watchdog::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/watchdog}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/watchdog:overview}}
Once the pinetime is closed and on your wrist, you still want access.

see : {\hyperref[\detokenize{fota/fota:fota}]{\sphinxcrossref{\DUrole{std,std-ref}{Firmware Over The Air (FOTA)}}}}

Suppose you upload a application which contains a bug, the watch freezes, and … you will have to open it up, connect the SWD …

Here comes the watchdog:
\begin{itemize}
\item {} 
you launch the watchdog

\item {} 
you launch the application

\item {} 
the application feeds the watchdog

\item {} 
if it cannot feed the watchdog, reset to fota, and you can upload another better version …

\end{itemize}


\subsection{Todo}
\label{\detokenize{drivers/watchdog:todo}}
testing


\subsection{References}
\label{\detokenize{drivers/watchdog:references}}

\chapter{bluetooth (BLE)}
\label{\detokenize{bluetooth:bluetooth-ble}}\label{\detokenize{bluetooth::doc}}
Bluetooth is a very nice feature, it lets you exchange data wirelessly and (!) update firmware wirelessly.

The PineTime uses a Nordic nrf52832 chip, which has BLE functionality build into it.

To test, you can compile a standard application : Eddy Stone.


\section{A word on bluetooth\sphinxhyphen{}serial communication}
\label{\detokenize{bluetooth:a-word-on-bluetooth-serial-communication}}
Smartwatch manufacterers usually supply you with a smartwatch app.
This app can communicatie trough bluetooth, and get/send data to the watch.

Unfortunately this is not a standard Zephyr feature!

You could use nRF Connect SDK (often referred as NCS),it is Nordic Semiconductor SDK based on zephyr. It has additional features that could be useful for pinetime, namely bluetooth modules and bluetooth services. Important to mention that even though, NCS forks zephyr it is kept close to it and it is regularly updated to latest zephyr (typically every 2\sphinxhyphen{}3 weeks).

NCS has no impact on build framework and overall user experience. The only downside I can think of is that NCS is based on older version of zephyr (\textasciitilde{}2 weeks behind).

The main reason why i’m bringing it up is bluetooth shell. Zephyr has very nice shell module with multiple transports (UART, RTT). NCS extends it with bluetooth transport (using Nordic Uart Service) and host tool for using it. There is an application for linux from which you can use shell over bluetooth, get logs, etc.. It is really cool and can be very useful when playing with pinetime where you can get logs or control/tune things with only wireless connection to your PC. Here is a demonstration of bluetooth console used in one of nordic reference kits: \sphinxurl{https://www.youtube.com/watch?v=3KzTfr6S4pg\&t=} . It’s based on nRF5 SDK (not zephyr) but bluetooth shell (and PC tool) was taken from there.

The Nordic UART Service (NUS) shell transport sample demonstrates how to use the receive shell commands from a remote device.

NCS is using BSD\sphinxhyphen{}5\sphinxhyphen{}Clause\sphinxhyphen{}Nordic license (\sphinxurl{https://github.com/NordicPlayground/fw-nrfconnect-nrf/blob/master/LICENSE})

Zephyr RTOS and the samples I use/create use the Apache License 2.0.
A permissive license whose main conditions require preservation of copyright and license notices. Contributors provide an express grant of patent rights. Licensed works, modifications, and larger works may be distributed under different terms and without source code.


\section{Eddy Stone}
\label{\detokenize{bluetooth:eddy-stone}}\begin{quote}

see:   \DUrole{xref,std,std-ref}{bluetooth\sphinxhyphen{}eddystone\sphinxhyphen{}sample}
\end{quote}

\sphinxstylestrong{Note:}  compile the provided example, so a build directory gets created

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} west build \PYGZhy{}p \PYGZhy{}b pinetime\PYGZus{}devkit0 samples/bluetooth/eddystone
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{this builds an image, which can be found under the build directory}}


\section{Using the created bluetooth sample:}
\label{\detokenize{bluetooth:using-the-created-bluetooth-sample}}
I use linux with a bluetoothadapter 4.0.
You need to install bluez.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}bluetoothctl
\PYG{g+gp}{[bluetooth]\PYGZsh{}}scan on
\end{sphinxVerbatim}

And your Eddy Stone should be visible.

It is the peripheral which advertises, and the central that reads the data.

A sample which advertises a heartrate :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{west} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{pinetime\PYGZus{}devkit0} \PYG{n}{samples}\PYG{o}{/}\PYG{n}{bluetooth}\PYG{o}{/}\PYG{n}{peripheral\PYGZus{}hr}
\end{sphinxVerbatim}

you could use your smartphone or bluez on linux to read out the heartrate.

Or if you have another watch, the central will connect to the peripheral and read out the heartrate.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{west} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{pinetime\PYGZus{}devkit0} \PYG{n}{samples}\PYG{o}{/}\PYG{n}{bluetooth}\PYG{o}{/}\PYG{n}{central\PYGZus{}hr}
\end{sphinxVerbatim}


\subsection{the no\sphinxhyphen{}bluetooth, no\sphinxhyphen{}watch approach : nrf52\_bsim}
\label{\detokenize{bluetooth:the-no-bluetooth-no-watch-approach-nrf52-bsim}}
Suppose you have no watch, no devboard, nor any bluetooth dongles?
You can still test your bluetooth enabled application.
\sphinxurl{https://docs.zephyrproject.org/latest/boards/posix/nrf52\_bsim/doc/index.html}

We follow the same logic, but this time we specify the nrf52\_bsim board.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
west build \PYGZhy{}p \PYGZhy{}b nrf52\PYGZus{}bsim samples/bluetooth/peripheral\PYGZus{}hr
west build \PYGZhy{}p \PYGZhy{}b nrf52\PYGZus{}bsim samples/bluetooth/central\PYGZus{}hr
cp build/zephyr/zephyr.exe  \PYGZdl{}\PYGZob{}BSIM\PYGZus{}OUT\PYGZus{}PATH\PYGZcb{}/bin/bs\PYGZus{}nrf52\PYGZus{}bsim\PYGZus{}samples\PYGZus{}bluetooth\PYGZus{}central\PYGZus{}hr
\end{sphinxVerbatim}

Once compiled you can execute both the peripheral and central firmware, and(!) you have to start the bluetooth simulation.
By starting each application in its own terminal, you can keep an eye on the output.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYGZob{}BSIM\PYGZus{}OUT\PYGZus{}PATH\PYGZcb{}/bin/bs\PYGZus{}nrf52\PYGZus{}bsim\PYGZus{}samples\PYGZus{}bluetooth\PYGZus{}central\PYGZus{}hr \PYGZhy{}s=trial\PYGZus{}sim \PYGZhy{}d=1

 zephyr/build/zephyr/zephyr.exe \PYGZhy{}s=trial\PYGZus{}sim \PYGZhy{}d=0
 \PYGZdl{}\PYGZob{}BSIM\PYGZus{}OUT\PYGZus{}PATH\PYGZcb{}/bin/bs\PYGZus{}2G4\PYGZus{}phy\PYGZus{}v1 \PYGZhy{}s=trial\PYGZus{}sim \PYGZhy{}D=2 \PYGZhy{}sim\PYGZus{}length=10e6
\end{sphinxVerbatim}


\subsection{the no\sphinxhyphen{}watch approach : simulation on a laptop}
\label{\detokenize{bluetooth:the-no-watch-approach-simulation-on-a-laptop}}
how to activate bluetooth?

VBOX running ubuntu (first disactivate driver in windows)
(CTRL home \textendash{} select usb \textendash{} (intel in my case)) \textendash{} this lets you select the integrated bluetoothmodule of your laptop

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hciconfig} \PYG{n}{hci0} \PYG{n}{down}

\PYG{n}{west} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{native\PYGZus{}posix\PYGZus{}64} \PYG{n}{samples}\PYG{o}{/}\PYG{n}{bluetooth}\PYG{o}{/}\PYG{n}{peripheral\PYGZus{}hr}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{build}\PYG{o}{/}\PYG{n}{zephyr}\PYG{o}{/}\PYG{n}{zephyr}\PYG{o}{.}\PYG{n}{exe} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{bt}\PYG{o}{\PYGZhy{}}\PYG{n}{dev}\PYG{o}{=}\PYG{n}{hci0}
\end{sphinxVerbatim}

Now you can connect your smartphone to the posix\_64 bluetooth device!

Or, with a second bluetooth interface (eg dongle)
.. code\sphinxhyphen{}block:: console
\begin{quote}

bluetoothctl
{[}bluetooth{]}\# devices
Device C6:78:40:29:EC:31 Zephyr Heartrate Sensor
Device C9:16:85:ED:B6:4E DS\sphinxhyphen{}D6 b64e
Device C8:B7:89:A9:B0:C9 Espruino\sphinxhyphen{}107 b0c9
Device 00:1A:7D:DA:71:0B posix\_64

{[}bluetooth{]}\# info 00:1A:7D:DA:71:0B
Device 00:1A:7D:DA:71:0B (public)
Name: posix\_64
Alias: posix\_64
Paired: no
Trusted: no
Blocked: no
Connected: no
LegacyPairing: no
UUID: Device Information        (0000180a\sphinxhyphen{}0000\sphinxhyphen{}1000\sphinxhyphen{}8000\sphinxhyphen{}00805f9b34fb)
UUID: Current Time Service      (00001805\sphinxhyphen{}0000\sphinxhyphen{}1000\sphinxhyphen{}8000\sphinxhyphen{}00805f9b34fb)
\end{quote}

If you have a smartphone, you can download the nrf utilities app from nordic.


\section{Bluez}
\label{\detokenize{bluetooth:bluez}}
With Bluez on linux you can investigate the bluetoothservices,  using bluetoothctl:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}bluetoothctl
\PYG{g+gp}{[bluetooth]\PYGZsh{}}scan on


\PYG{g+go}{[NEW] Device 60:7C:9E:92:50:C1 Zephyr Peripheral Sample Long}
\PYG{g+go}{once you see your device}
\PYG{g+gp}{[blueooth]\PYGZsh{}}connect \PYG{l+m}{60}:7C:9E:92:50:C1 \PYG{o}{(}the device mac address as displayed\PYG{o}{)}

\PYG{g+go}{then you can already see the services}
\end{sphinxVerbatim}


\subsection{using bluez to write something to the device}
\label{\detokenize{bluetooth:using-bluez-to-write-something-to-the-device}}\begin{description}
\item[{Characteristic}] \leavevmode
/org/bluez/hci0/dev\_74\_71\_4B\_D5\_18\_21/service001f/char0023
00002a38\sphinxhyphen{}0000\sphinxhyphen{}1000\sphinxhyphen{}8000\sphinxhyphen{}00805f9b34fb
Body Sensor Location

\end{description}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{[dsd6]\PYGZsh{}} \PYG{k}{select}\PYGZhy{}attribute /org/bluez/hci0/dev\PYGZus{}74\PYGZus{}71\PYGZus{}4B\PYGZus{}D5\PYGZus{}18\PYGZus{}21/service001f/char0023
\PYG{g+go}{write \PYGZlt{}data=0x1\PYGZgt{}}
\end{sphinxVerbatim}

same thing with the app from nordic, you could try to connect and display value of e.g. heart rate


\section{using Python to read out bluetoothservices}
\label{\detokenize{bluetooth:using-python-to-read-out-bluetoothservices}}
In this repo you will find a python script : readbat.py
In order to use it you need bluez on linux and the python \sphinxtitleref{bluepy} module.

It can be used in conjunction with the peripheral bluetooth demo.
It just reads out the battery level, and prints it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{binascii}
\PYG{k+kn}{from} \PYG{n+nn}{bluepy}\PYG{n+nn}{.}\PYG{n+nn}{btle} \PYG{k+kn}{import} \PYG{n}{UUID}\PYG{p}{,} \PYG{n}{Peripheral}

\PYG{n}{temp\PYGZus{}uuid} \PYG{o}{=} \PYG{n}{UUID}\PYG{p}{(}\PYG{l+m+mh}{0x2A19}\PYG{p}{)}

\PYG{n}{p} \PYG{o}{=} \PYG{n}{Peripheral}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{60:7C:9E:92:50:C1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{random}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{try}\PYG{p}{:}
   \PYG{n}{ch} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{getCharacteristics}\PYG{p}{(}\PYG{n}{uuid}\PYG{o}{=}\PYG{n}{temp\PYGZus{}uuid}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
   \PYG{n+nb}{print} \PYG{n}{binascii}\PYG{o}{.}\PYG{n}{b2a\PYGZus{}hex}\PYG{p}{(}\PYG{n}{ch}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{finally}\PYG{p}{:}
    \PYG{n}{p}\PYG{o}{.}\PYG{n}{disconnect}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Firmware Over The Air (FOTA)}
\label{\detokenize{fota/fota:firmware-over-the-air-fota}}\label{\detokenize{fota/fota:fota}}\label{\detokenize{fota/fota::doc}}

\section{Wireless Device Firmware Upgrade}
\label{\detokenize{fota/mcuboot:wireless-device-firmware-upgrade}}\label{\detokenize{fota/mcuboot:mcuboot}}\label{\detokenize{fota/mcuboot::doc}}

\subsection{Overview}
\label{\detokenize{fota/mcuboot:overview}}
In order to perform a FOTA (firmware over the air) update on zephyr you need 2 basic components:
\begin{itemize}
\item {} 
MCUboot   (a bootloader)

\item {} 
SMP Server (a bluetooth service)

\end{itemize}


\section{MCUboot with zephyr}
\label{\detokenize{fota/mcuboot:mcuboot-with-zephyr}}\label{\detokenize{fota/mcuboot:id1}}
Clone MCUBOOT for zephyr from github.
Install additional packages required for development with mcuboot:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{o}{\PYGZti{}}\PYG{o}{/}\PYG{n}{mcuboot}  \PYG{c+c1}{\PYGZsh{} or to your directory where mcuboot is cloned}
\PYG{n}{pip3} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{user} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{n}{scripts}\PYG{o}{/}\PYG{n}{requirements}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}

To build MCUboot, create a build directory in boot/zephyr, and build
it as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{boot}\PYG{o}{/}\PYG{n}{zephyr}
\PYG{n}{mkdir} \PYG{n}{build} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{GNinja} \PYG{o}{\PYGZhy{}}\PYG{n}{DBOARD}\PYG{o}{=}\PYG{n}{pinetime} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{ninja}
\end{sphinxVerbatim}

After building the bootloader, the binaries should reside in
\sphinxtitleref{build/zephyr/zephyr.\{bin,hex,elf\}}.

This image can be flashed as a normal application.

Some additional configuration is required to build applications for MCUboot.

This is handled internally by the Zephyr configuration system and is wrapped
in the \sphinxtitleref{CONFIG\_BOOTLOADER\_MCUBOOT} Kconfig variable, which must be enabled in
the application’s \sphinxtitleref{prj.conf} file.

The Zephyr \sphinxtitleref{CONFIG\_BOOTLOADER\_MCUBOOT} configuration option
{[}documentation{]}(\sphinxurl{http://docs.zephyrproject.org/reference/kconfig/CONFIG\_BOOTLOADER\_MCUBOOT.html})
provides additional details regarding the changes it makes to the image
placement and generation in order for an application to be bootable by
MCUboot.

In order to upgrade to an image (or even boot it, if
\sphinxtitleref{MCUBOOT\_VALIDATE\_PRIMARY\_SLOT} is enabled), the images must be signed.

To make development easier, MCUboot is distributed with some example
keys.  It is important to stress that these should never be used for
production, since the private key is publicly available in this
repository.  See below on how to make your own signatures.

Images can be signed with the \sphinxtitleref{scripts/imgtool.py} script.  It is best
to look at \sphinxtitleref{samples/zephyr/Makefile} for examples on how to use this.

Since the bootloader is already in place, you cannot flash your application.bin to 0x00000.

Eg. in openocd : program application.bin 0x0c000. (which corresponds to the flash layout of slot 0)

These images can also be marked for upgrade, and loaded into the secondary slot,
at which point the bootloader should perform an upgrade.


\section{Partitions}
\label{\detokenize{fota/partitions:partitions}}\label{\detokenize{fota/partitions:signing}}\label{\detokenize{fota/partitions::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{have a look at boards/arm/pinetime/pinetime.dts}
\end{sphinxVerbatim}


\subsection{Defining partitions for MCUboot}
\label{\detokenize{fota/partitions:defining-partitions-for-mcuboot}}
The first step required for Zephyr is making sure your board has flash
partitions defined in its device tree. These partitions are:
\begin{itemize}
\item {} 
\sphinxtitleref{boot\_partition}: for MCUboot itself

\item {} 
\sphinxtitleref{image\_0\_primary\_partition}: the primary slot of Image 0

\item {} 
\sphinxtitleref{image\_0\_secondary\_partition}: the secondary slot of Image 0

\item {} 
\sphinxtitleref{scratch\_partition}: the scratch slot

\end{itemize}

The flash partitions are defined in the pinetime boards folder, in a
file named \sphinxtitleref{boards/arm/pinetime/pinetime.dts}.


\subsection{Using NOR flash in partitions}
\label{\detokenize{fota/partitions:using-nor-flash-in-partitions}}
The flash space on the Nordic nrf52 is 512K.
Basically with the partitioning you end up with less space for your program.

As the pinetime has an extra spi nor flash chip, we can use this.

The flash\sphinxhyphen{}layout can be modified so as 1 chunk is on system flash and 1 chunk is on SPI NOR flash.
This way the space for your firmware remains almost the same.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{chosen \PYGZob{}}
\PYG{g+go}{        zephyr,flash = \PYGZam{}flash0;}
\PYG{g+go}{        //zephyr,flash = \PYGZam{}flash1;}
\PYG{g+go}{        zephyr,code\PYGZhy{}partition = \PYGZam{}slot0\PYGZus{}partition;}
\PYG{g+go}{\PYGZcb{};}


\PYG{g+go}{Rename the SPI JEDEC NOR Flash definition to : flash1}

\PYG{g+go}{flash1: mx25r6435f@1 \PYGZob{}}
\PYG{g+go}{        compatible = \PYGZdq{}jedec,spi\PYGZhy{}nor\PYGZdq{};}
\PYG{g+go}{        reg = \PYGZlt{}1\PYGZgt{};}
\PYG{g+go}{        spi\PYGZhy{}max\PYGZhy{}frequency = \PYGZlt{}80000000\PYGZgt{};}
\PYG{g+go}{        label = \PYGZdq{}MX25R64\PYGZdq{};}
\PYG{g+go}{        jedec\PYGZhy{}id = [0b 40 16];}
\PYG{g+go}{        size = \PYGZlt{}67108864\PYGZgt{};}
\PYG{g+go}{        has\PYGZhy{}be32k;}
\PYG{g+go}{        erase\PYGZhy{}block\PYGZhy{}size = \PYGZlt{}4096\PYGZgt{};}
\PYG{g+go}{        write\PYGZhy{}block\PYGZhy{}size = \PYGZlt{}4\PYGZgt{};}
\PYG{g+go}{\PYGZcb{};}




\PYG{g+go}{ \PYGZam{}flash0 \PYGZob{}}
\PYG{g+go}{        /*}
\PYG{g+go}{         * For more information, see:}
\PYG{g+go}{         * http://docs.zephyrproject.org/latest/guides/dts/index.html\PYGZsh{}flash\PYGZhy{}partitions}
\PYG{g+go}{         */}
\PYG{g+go}{        partitions \PYGZob{}}
\PYG{g+go}{                compatible = \PYGZdq{}fixed\PYGZhy{}partitions\PYGZdq{};}
\PYG{g+gp}{                \PYGZsh{}}address\PYGZhy{}cells \PYG{o}{=} \PYGZlt{}\PYG{l+m}{1}\PYGZgt{}\PYG{p}{;}
\PYG{g+gp}{                \PYGZsh{}}size\PYGZhy{}cells \PYG{o}{=} \PYGZlt{}\PYG{l+m}{1}\PYGZgt{}\PYG{p}{;}

\PYG{g+go}{                boot\PYGZus{}partition: partition@0 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}mcuboot\PYGZdq{};}
\PYG{g+go}{                        reg = \PYGZlt{}0x00000000 0xc000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}
\PYG{g+go}{                slot0\PYGZus{}partition: partition@c000 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}image\PYGZhy{}0\PYGZdq{};}

\PYG{g+go}{                change the size of partition 0 from 0x32000 to 0x64000}

\PYG{g+go}{                        reg = \PYGZlt{}0x0000C000 0x64000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}

\PYG{g+go}{                move slot1 partition to \PYGZam{}flash1}

\PYG{g+go}{                //slot1\PYGZus{}partition: partition@3e000 \PYGZob{}}
\PYG{g+go}{                //      label = \PYGZdq{}image\PYGZhy{}1\PYGZdq{};}
\PYG{g+go}{                //      reg = \PYGZlt{}0x0003e000 0x32000\PYGZgt{};}
\PYG{g+go}{                //\PYGZcb{};}
\PYG{g+go}{                scratch\PYGZus{}partition: partition@70000 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}image\PYGZhy{}scratch\PYGZdq{};}
\PYG{g+go}{                        reg = \PYGZlt{}0x00070000 0xa000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}
\PYG{g+go}{                storage\PYGZus{}partition: partition@7a000 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}storage\PYGZdq{};}
\PYG{g+go}{                        reg = \PYGZlt{}0x0007a000 0x00006000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}
\PYG{g+go}{        \PYGZcb{};}
\PYG{g+go}{ \PYGZcb{};}

\PYG{g+go}{ \PYGZam{}flash1 \PYGZob{}}
\PYG{g+go}{        partitions \PYGZob{}}
\PYG{g+go}{                compatible = \PYGZdq{}fixed\PYGZhy{}partitions\PYGZdq{};}
\PYG{g+gp}{                \PYGZsh{}}address\PYGZhy{}cells \PYG{o}{=} \PYGZlt{}\PYG{l+m}{1}\PYGZgt{}\PYG{p}{;}
\PYG{g+gp}{                \PYGZsh{}}size\PYGZhy{}cells \PYG{o}{=} \PYGZlt{}\PYG{l+m}{1}\PYGZgt{}\PYG{p}{;}
\PYG{g+go}{                slot1\PYGZus{}partition: partition@3e000 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}image\PYGZhy{}1\PYGZdq{};}
\PYG{g+go}{                        reg = \PYGZlt{}0x00000000 0x64000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}
\PYG{g+go}{        \PYGZcb{};}
\PYG{g+go}{ \PYGZcb{};}
\end{sphinxVerbatim}


\section{Signing an application}
\label{\detokenize{fota/signing:signing-an-application}}\label{\detokenize{fota/signing:signing}}\label{\detokenize{fota/signing::doc}}
In order to improve the security, only signed images can be uploaded.

There is a public and private key.
The Bootloader is compiled with the public key.
Each time you want to upload firmware, you have to sign it with a private key.

\sphinxstylestrong{NOTE: it is important to keep the private key hidden}


\subsection{Generating a new keypair}
\label{\detokenize{fota/signing:generating-a-new-keypair}}
Generating a keypair with imgtool is a matter of running the keygen
subcommand:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} ./scripts/imgtool.py keygen \PYGZhy{}k mykey.pem \PYGZhy{}t rsa\PYGZhy{}2048
\end{sphinxVerbatim}


\subsection{Extracting the public key}
\label{\detokenize{fota/signing:extracting-the-public-key}}
The generated keypair above contains both the public and the private
key.  It is necessary to extract the public key and insert it into the
bootloader.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} ./scripts/imgtool.py getpub \PYGZhy{}k mykey.pem
\end{sphinxVerbatim}

This will output the public key as a C array that can be dropped
directly into the \sphinxtitleref{keys.c} file.


\subsection{Example}
\label{\detokenize{fota/signing:example}}
sign the compiled zephyr.bin firmware with the root\sphinxhyphen{}rsa\sphinxhyphen{}2048.pem, private key:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{imgtool.py sign \PYGZhy{}\PYGZhy{}key ../../root\PYGZhy{}rsa\PYGZhy{}2048.pem \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}header\PYGZhy{}size 0x200 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}align 8 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}version 1.2 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}slot\PYGZhy{}size 0x60000 \PYGZbs{}}
\PYG{g+go}{    ../mcuboot/samples/zephyr/build/ds\PYGZus{}d6/hello1/zephyr/zephyr.bin \PYGZbs{}}
\PYG{g+go}{    signed\PYGZhy{}hello1.bin}
\end{sphinxVerbatim}


\section{SMP Server Sample}
\label{\detokenize{fota/smp_svr:smp-server-sample}}\label{\detokenize{fota/smp_svr:smp-svr-sample}}\label{\detokenize{fota/smp_svr::doc}}

\subsection{Overview}
\label{\detokenize{fota/smp_svr:overview}}
This sample application implements a Simple Management Protocol (SMP) server.
SMP is a basic transfer encoding for use with the MCUmgr management protocol.

This sample application supports the following mcumgr transports by default:
\begin{itemize}
\item {} 
Shell

\item {} 
Bluetooth

\end{itemize}


\subsection{Requirements}
\label{\detokenize{fota/smp_svr:requirements}}
In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.

Here is a procedure to install mcumgr on a raspberry pi  (or similar)

It is written in the go\sphinxhyphen{}language. You need to adapt the path :   PATH=\$PATH:/root/go/bin.


\subsection{Building and Running}
\label{\detokenize{fota/smp_svr:building-and-running}}
The sample will let you manage the pinetime over bluetooth. (via SMP protocol)

There are slot0 and slot1 which can both contain firmware.

Suppose you switch from slot0 to slot1, you still want to be able to communicate.

So both slots need smp\_svr software!


\subsubsection{Step 1: Build smp\_svr}
\label{\detokenize{fota/smp_svr:step-1-build-smp-svr}}
\sphinxcode{\sphinxupquote{smp\_svr}} can be built for the nRF52 as follows:

\sphinxstylestrong{NOTE: to perform a firmware update over the air, you have to build a second sample}


\subsubsection{Step 2: Sign the image}
\label{\detokenize{fota/smp_svr:step-2-sign-the-image}}
Using MCUboot’s \sphinxcode{\sphinxupquote{imgtool.py}} script, sign the \sphinxcode{\sphinxupquote{zephyr.(bin|hex)}}
file you built in Step 3. In the below example, the MCUboot repo is located at
\sphinxcode{\sphinxupquote{\textasciitilde{}/src/mcuboot}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/src/mcuboot/scripts/imgtool.py sign \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}key \PYGZti{}/src/mcuboot/root\PYGZhy{}rsa\PYGZhy{}2048.pem \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}header\PYGZhy{}size 0x200 \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}align 8 \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}version 1.0 \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}slot\PYGZhy{}size \PYGZlt{}image\PYGZhy{}slot\PYGZhy{}size\PYGZgt{} \PYGZbs{}}
\PYG{g+go}{     \PYGZlt{}path\PYGZhy{}to\PYGZhy{}zephyr.(bin|hex)\PYGZgt{} signed.(bin|hex)}
\end{sphinxVerbatim}

The above command creates an image file called \sphinxcode{\sphinxupquote{signed.(bin|hex)}} in the
current directory.


\subsubsection{Step 3: Flash the smp\_svr image}
\label{\detokenize{fota/smp_svr:step-3-flash-the-smp-svr-image}}
Upload the bin\sphinxhyphen{}file from Step 2 to image slot\sphinxhyphen{}0.
For the pinetime, slot\sphinxhyphen{}0 is located at address \sphinxcode{\sphinxupquote{0xc000}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{in openocd : program zephyr.bin 0xc000}
\end{sphinxVerbatim}


\subsubsection{Step 4: Run it!}
\label{\detokenize{fota/smp_svr:step-4-run-it}}
\begin{sphinxadmonition}{note}{Note:}
If you haven’t installed \sphinxcode{\sphinxupquote{mcumgr}} yet, then do so by following the
instructions in the \DUrole{xref,std,std-ref}{mcumgr\_cli} section of the Management subsystem
documentation.
\end{sphinxadmonition}

The \sphinxcode{\sphinxupquote{smp\_svr}} app is ready to run.  Just reset your board and test the app
with the \sphinxcode{\sphinxupquote{mcumgr}} command\sphinxhyphen{}line tool’s \sphinxcode{\sphinxupquote{echo}} functionality, which will
send a string to the remote target device and have it echo it back:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} echo hello}
\PYG{g+go}{hello}
\end{sphinxVerbatim}


\subsubsection{Step 5: Device Firmware Upgrade}
\label{\detokenize{fota/smp_svr:step-5-device-firmware-upgrade}}
Now that the SMP server is running on your pinetime, you are able to communicate
with it using \sphinxtitleref{mcumgr}.

You might want to test “OTA DFU”, or Over\sphinxhyphen{}The\sphinxhyphen{}Air Device Firmware Upgrade.

To do this, build a second sample (following the steps below) to verify
it is sent over the air and properly flashed into slot\sphinxhyphen{}1, and then
swapped into slot\sphinxhyphen{}0 by MCUboot.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{*} \PYG{n}{Build} \PYG{n}{a} \PYG{n}{second} \PYG{n}{sample}
\PYG{o}{*} \PYG{n}{Sign} \PYG{n}{the} \PYG{n}{second} \PYG{n}{sample}
\PYG{o}{*} \PYG{n}{Upload} \PYG{n}{the} \PYG{n}{image} \PYG{n}{over} \PYG{n}{BLE}
\end{sphinxVerbatim}

Now we are ready to send or upload the image over BLE to the target remote
device.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} image upload signed.bin}
\end{sphinxVerbatim}

If all goes well the image will now be stored in slot\sphinxhyphen{}1, ready to be swapped
into slot\sphinxhyphen{}0 and executed.

\begin{sphinxadmonition}{note}{Note:}
At the beginning of the upload process, the target might start erasing
the image slot, taking several dozen seconds for some targets.  This might
cause an NMP timeout in the management protocol tool. Use the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}t \textless{}timeout\sphinxhyphen{}in\sphinxhyphen{}seconds}} option to increase the response timeout for the
\sphinxcode{\sphinxupquote{mcumgr}} command line tool if this occurs.
\end{sphinxadmonition}


\paragraph{List the images}
\label{\detokenize{fota/smp_svr:list-the-images}}
We can now obtain a list of images (slot\sphinxhyphen{}0 and slot\sphinxhyphen{}1) present in the remote
target device by issuing the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} image list}
\end{sphinxVerbatim}

This should print the status and hash values of each of the images present.


\paragraph{Test the image}
\label{\detokenize{fota/smp_svr:test-the-image}}
In order to instruct MCUboot to swap the images we need to test the image first,
making sure it boots:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} image test \PYGZlt{}hash of slot\PYGZhy{}1 image\PYGZgt{}}
\end{sphinxVerbatim}

Now MCUBoot will swap the image on the next reset.


\paragraph{Reset remotely}
\label{\detokenize{fota/smp_svr:reset-remotely}}
We can reset the device remotely to observe (use the console output) how
MCUboot swaps the images:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} reset}
\end{sphinxVerbatim}

Upon reset MCUboot will swap slot\sphinxhyphen{}0 and slot\sphinxhyphen{}1.

You can confirm the new image and make the swap permanent by using this command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} image confirm}
\end{sphinxVerbatim}

\sphinxstylestrong{Note} that if you try to send the very same image that is already flashed in
slot\sphinxhyphen{}0 then the procedure will not complete successfully since the hash values
for both slots will be identical.
\begin{quote}
\end{quote}


\chapter{Samples}
\label{\detokenize{samples/index:samples}}\label{\detokenize{samples/index:id1}}\label{\detokenize{samples/index::doc}}

\section{Battery OSWatch Framework}
\label{\detokenize{samples/oswatch-batteryREADME:battery-oswatch-framework}}\label{\detokenize{samples/oswatch-batteryREADME:oswatch}}\label{\detokenize{samples/oswatch-batteryREADME::doc}}

\subsection{Todo}
\label{\detokenize{samples/oswatch-batteryREADME:todo}}
Not functional yet…
WIP (work in progress)


\subsection{Overview}
\label{\detokenize{samples/oswatch-batteryREADME:overview}}
This is an opensource watch framework.
The same software can run in simulation (SDL) on linux, on pinetime and on the ds\_d6 oled watch.

This frame can be used if you need powermanagement (PM).

The application keeps track of the battery, and is frugile on energy.


\subsection{Requirements}
\label{\detokenize{samples/oswatch-batteryREADME:requirements}}
no requirements since it can run without board (simulation)


\subsection{Building and Running}
\label{\detokenize{samples/oswatch-batteryREADME:building-and-running}}
west build \sphinxhyphen{}p \sphinxhyphen{}b  native\sphinxhyphen{}posix\_64 oswatch


\subsection{References}
\label{\detokenize{samples/oswatch-batteryREADME:references}}

\section{OSWatch bluetooth setting parameters}
\label{\detokenize{samples/oswatch-btREADME:oswatch-bluetooth-setting-parameters}}\label{\detokenize{samples/oswatch-btREADME:oswatch}}\label{\detokenize{samples/oswatch-btREADME::doc}}

\subsection{Overview}
\label{\detokenize{samples/oswatch-btREADME:overview}}
This is an opensource watch framework.
The same software can run in simulation (SDL) on linux, on the pinetime and on the ds\_d6 oled watch.


\subsection{Bluetooth}
\label{\detokenize{samples/oswatch-btREADME:bluetooth}}
This application adds bluetoothfunctionality to update 6 parameters.
One should be able to read out and set these parameters.


\subsection{Requirements}
\label{\detokenize{samples/oswatch-btREADME:requirements}}
no requirements since it can run without board (simulation)


\subsection{Building and Running}
\label{\detokenize{samples/oswatch-btREADME:building-and-running}}
west build \sphinxhyphen{}p \sphinxhyphen{}b  native\sphinxhyphen{}posix\_64 oswatch\sphinxhyphen{}bt


\subsection{References}
\label{\detokenize{samples/oswatch-btREADME:references}}

\section{Current Time Setting  OSWatch Framework}
\label{\detokenize{samples/oswatch-ctsREADME:current-time-setting-oswatch-framework}}\label{\detokenize{samples/oswatch-ctsREADME:oswatch}}\label{\detokenize{samples/oswatch-ctsREADME::doc}}

\subsection{Overview}
\label{\detokenize{samples/oswatch-ctsREADME:overview}}
This is an opensource watch framework.
The same software can run in simulation (SDL) on linux, on pinetime and on the ds\_d6 oled watch.

This sample reads/sets the time, using bluetooth CTS.


\subsection{Requirements}
\label{\detokenize{samples/oswatch-ctsREADME:requirements}}
A bluetooth CTS server.
This can be a smartphone.

Included is a python\sphinxhyphen{}script : gatt\sphinxhyphen{}cts\sphinxhyphen{}server.py, for use with bluez on linux.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python3} \PYG{n}{gatt}\PYG{o}{\PYGZhy{}}\PYG{n}{cts}\PYG{o}{\PYGZhy{}}\PYG{n}{server}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

you need to connect to the watch in order, to have it read the time.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{bluetoothctl}
\PYG{n}{scan} \PYG{n}{on} \PYG{p}{(}\PYG{n}{gets} \PYG{n}{you} \PYG{n+nb}{list} \PYG{n}{of} \PYG{n}{bluetoothdevices}\PYG{p}{)}
\PYG{n}{connect} \PYG{n}{D5}\PYG{p}{:}\PYG{n}{A0}\PYG{p}{:}\PYG{n}{A2}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{n}{D}\PYG{p}{:}\PYG{n}{A0}\PYG{p}{:}\PYG{n}{D5} \PYG{p}{(}\PYG{n}{pick} \PYG{n}{the} \PYG{n}{pinetime} \PYG{o}{\PYGZhy{}} \PYG{n}{macaddress}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{samples/oswatch-ctsREADME:building-and-running}}
west build \sphinxhyphen{}p \sphinxhyphen{}b  native\sphinxhyphen{}posix\_64 oswatch\sphinxhyphen{}cts


\subsection{References}
\label{\detokenize{samples/oswatch-ctsREADME:references}}

\section{FOTA OSWatch Framework}
\label{\detokenize{samples/oswatch-fotaREADME:fota-oswatch-framework}}\label{\detokenize{samples/oswatch-fotaREADME:oswatch}}\label{\detokenize{samples/oswatch-fotaREADME::doc}}

\subsection{Todo}
\label{\detokenize{samples/oswatch-fotaREADME:todo}}
This is not functional yet


\subsection{Overview}
\label{\detokenize{samples/oswatch-fotaREADME:overview}}
This is an opensource watch framework.
The same software can run in simulation (SDL) on linux, on pinetime and on the ds\_d6 oled watch.

This is a demo, when you want to implement firmware updates over the air.

Zephyr has a procedure in place.

Look for MCUBOOT definitions in the source code


\subsection{Requirements}
\label{\detokenize{samples/oswatch-fotaREADME:requirements}}
no requirements since it can run without board (simulation)


\subsection{Building and Running}
\label{\detokenize{samples/oswatch-fotaREADME:building-and-running}}
west build \sphinxhyphen{}p \sphinxhyphen{}b  native\sphinxhyphen{}posix\_64 oswatch\sphinxhyphen{}fota


\subsection{References}
\label{\detokenize{samples/oswatch-fotaREADME:references}}

\section{Basic OSWatch Framework}
\label{\detokenize{samples/oswatchREADME:basic-oswatch-framework}}\label{\detokenize{samples/oswatchREADME:oswatch}}\label{\detokenize{samples/oswatchREADME::doc}}
The application keeps track of time and displays time and date.
The initial time is the time of build.

Switching between screens can be done by multiple presses on button.

On the native\_posix application 2 serial ports are available.
UART\_1 connected to pseudotty: /dev/pts/2
UART\_0 connected to pseudotty: /dev/pts/3

By connecting to UART\_0 with :  minicom \sphinxhyphen{}D /dev/pts/3, you have access to the zephyr\sphinxhyphen{}shell.
(just type “help” to get overview)


\subsection{Overview}
\label{\detokenize{samples/oswatchREADME:overview}}
This is an opensource watch framework.
The same software can run in simulation (SDL) on linux, on the pinetime and on the ds\_d6 oled watch.

This Basic application serves as a chassis, where accessories can be supplemented (bluetooth, fota, powermanagement, …)
These application carry the name oswatch\sphinxhyphen{}bt, oswatch\sphinxhyphen{}pm, oswatch\sphinxhyphen{}fota, oswatch\sphinxhyphen{}full.

Why implement powermanagent if you do not have a battery?
Why implement firmware over the air, if you can update the firmware with a debugprobe.


\subsection{Remark}
\label{\detokenize{samples/oswatchREADME:remark}}
This basic time keeping application, might need adjustment.
In that case you will still need CTS (bluetooth functionality).


\subsection{Requirements}
\label{\detokenize{samples/oswatchREADME:requirements}}
no requirements since it can run without board (simulation)


\subsection{Building and Running}
\label{\detokenize{samples/oswatchREADME:building-and-running}}
west build \sphinxhyphen{}p \sphinxhyphen{}b  native\sphinxhyphen{}posix\_64 oswatch


\subsection{References}
\label{\detokenize{samples/oswatchREADME:references}}

\section{HRS3300 Heart Rate Sensor}
\label{\detokenize{samples/README:hrs3300-heart-rate-sensor}}\label{\detokenize{samples/README:hrs3300}}\label{\detokenize{samples/README::doc}}

\subsection{Overview}
\label{\detokenize{samples/README:overview}}
A sensor application that demonstrates how to poll data from the hrs3300 heart
rate sensor.


\subsection{Building and Running}
\label{\detokenize{samples/README:building-and-running}}
This project configures the hrs3300 sensor on the \DUrole{xref,std,std-ref}{pinetime\_devkit1} board to
enable the green LED and measure the reflected light with a photodiode. The raw
ADC data prints to the console. Further processing (not included in this
sample) is required to extract a heart rate signal from the light measurement.


\subsubsection{Sample Output}
\label{\detokenize{samples/README:sample-output}}
for this you will need a Segger JLink Console

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{rtt:\PYGZti{}\PYGZdl{}} sensor get HRS3300 \PYG{l+m}{18} \PYG{o}{(}ir \PYGZhy{}\PYGZhy{} this switches off the sensor\PYG{o}{)}
\PYG{g+gp}{rtt:\PYGZti{}\PYGZdl{}} sensor get HRS3300 \PYG{l+m}{19} \PYG{o}{(}red \PYGZhy{}\PYGZhy{} this switches on the sensor\PYG{o}{)}
\PYG{g+gp}{rtt:\PYGZti{}\PYGZdl{}} sensor get HRS3300 \PYG{l+m}{20} \PYG{o}{(}green \PYGZhy{}\PYGZhy{} get a value\PYG{o}{)}
\end{sphinxVerbatim}


\section{Character frame buffer}
\label{\detokenize{samples/samplescfbREADME:character-frame-buffer}}\label{\detokenize{samples/samplescfbREADME:character-frame-buffer-sample}}\label{\detokenize{samples/samplescfbREADME::doc}}

\subsection{Overview}
\label{\detokenize{samples/samplescfbREADME:overview}}
This sample displays character strings using the Character Frame Buffer
(CFB) subsystem framework.


\subsection{Building and Running}
\label{\detokenize{samples/samplescfbREADME:building-and-running}}
build the application: west build \sphinxhyphen{}p \sphinxhyphen{}b ds\_d6 samples/cfb

on unix : \#minicom \sphinxhyphen{}b 115200 \sphinxhyphen{}D /dev/ttyACM1

you get a shell and you can type help

to display something on the screen :
cfb init
cfb invert
cfb print 0 0 “hello world”


\subsection{POSIX}
\label{\detokenize{samples/samplescfbREADME:posix}}
west build \sphinxhyphen{}p \sphinxhyphen{}b native\_posix\_64 samles/cfb

connect to serial port :
minicom \sphinxhyphen{}D /dev/pts/1


\subsection{Pinetime}
\label{\detokenize{samples/samplescfbREADME:pinetime}}
Problem : does not display a thing ….


\section{Character Framebuffer Shell Module Sample}
\label{\detokenize{samples/samplescfb_shellREADME:character-framebuffer-shell-module-sample}}\label{\detokenize{samples/samplescfb_shellREADME:cfb-shell-sample}}\label{\detokenize{samples/samplescfb_shellREADME::doc}}

\subsection{Overview}
\label{\detokenize{samples/samplescfb_shellREADME:overview}}
This is a simple shell module that exercises displays using the Character
Framebuffer subsystem.

—not working on posix—\textendash{}


\subsection{Building and Running}
\label{\detokenize{samples/samplescfb_shellREADME:building-and-running}}
Build the sample app by choosing the target board, for example:


\subsubsection{Shell Module Command Help}
\label{\detokenize{samples/samplescfb_shellREADME:shell-module-command-help}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{cfb \PYGZhy{} Character Framebuffer shell commands}
\PYG{g+go}{Options:}
\PYG{g+go}{        \PYGZhy{}h, \PYGZhy{}\PYGZhy{}help  :Show command help.}
\PYG{g+go}{Subcommands:}
\PYG{g+go}{        init        :[none]}
\PYG{g+go}{        get\PYGZus{}device  :[none]}
\PYG{g+go}{        get\PYGZus{}param   :\PYGZlt{}all, height, width, ppt, rows, cols\PYGZgt{}}
\PYG{g+go}{        get\PYGZus{}fonts   :[none]}
\PYG{g+go}{        set\PYGZus{}font    :\PYGZlt{}idx\PYGZgt{}}
\PYG{g+go}{        invert      :[none]}
\PYG{g+go}{        print       :\PYGZlt{}col: pos\PYGZgt{} \PYGZlt{}row: pos\PYGZgt{} \PYGZlt{}text\PYGZgt{}}
\PYG{g+go}{        scroll      :\PYGZlt{}dir: (vertical|horizontal)\PYGZgt{} \PYGZlt{}col: pos\PYGZgt{} \PYGZlt{}row: pos\PYGZgt{}}
\PYG{g+go}{                     \PYGZlt{}text\PYGZgt{}}
\PYG{g+go}{        clear       :[none]}
\end{sphinxVerbatim}

\sphinxstylestrong{init}: should be called first to initialize the display.

Command example (ds\_d6):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{uart:\PYGZti{}\PYGZdl{}} cfb init
\PYG{g+go}{Framebuffer initialized: SSD1306}
\PYG{g+go}{Display Cleared}
\end{sphinxVerbatim}

\sphinxstylestrong{get\_device}: prints the display device name.

Command example (ds\_d6 board):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{uart:\PYGZti{}\PYGZdl{}} cfb get\PYGZus{}device
\PYG{g+go}{Framebuffer Device: SSD16XX}
\end{sphinxVerbatim}

\sphinxstylestrong{get\_param}: get the display parameters where height, width and ppt
(pixel per tile) are in pixels and the number of rows and columns. The row
position is incremented by a multiple of the ppt.

Command example (ds\_d6 board):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{uart:\PYGZti{}\PYGZdl{}} cfb get\PYGZus{}param all
\PYG{g+go}{param: height=120}
\PYG{g+go}{param: width=250}
\PYG{g+go}{param: ppt=8}
\PYG{g+go}{param: rows=15}
\PYG{g+go}{param: cols=250}
\end{sphinxVerbatim}

\sphinxstylestrong{get\_fonts}: print the index, height and width in pixels of the static
defined fonts presented in the system.

Command example (ds\_d6 board):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{uart:\PYGZti{}\PYGZdl{}} cfb get\PYGZus{}fonts
\PYG{g+go}{idx=0 height=32 width=20}
\PYG{g+go}{idx=1 height=24 width=15}
\PYG{g+go}{idx=2 height=16 width=10}
\end{sphinxVerbatim}

\sphinxstylestrong{set\_font}: choose the font to be used by passing the font index. Only one
font can be used at a time.

Command example (ds\_d6 board):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{uart:\PYGZti{}\PYGZdl{}} cfb set\PYGZus{}font \PYG{l+m}{0}
\PYG{g+go}{Font idx=0 height=32 widht=20 set}
\end{sphinxVerbatim}

\sphinxstylestrong{invert}: invert the pixel color of the display.

Command example (ds\_d6 board):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{uart:\PYGZti{}\PYGZdl{}} cfb invert
\PYG{g+go}{Framebuffer Inverted}
\end{sphinxVerbatim}

\sphinxstylestrong{print}: pass the initial column and row positions and the text in
double quotation marks when it contains spaces. If text hits the edge
of the display the remaining characters will be displayed on the next line. The
previous printed text will be overwritten.

Command example (ds\_d6 board):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{uart:\PYGZti{}\PYGZdl{}} cfb print \PYG{l+m}{60} \PYG{l+m}{5} ZEPHYR
\end{sphinxVerbatim}

\sphinxstylestrong{scroll}: pass the scroll direction, vertical or horizontal, the initial
column and row positions, and the text to be displayed in double quotation
marks when it contains spaces. If the text hits the edge of the display, the
remaining characters will be displayed in the next line. The text will scroll
until it hits the display boundary, last column for horizontal and last row
for vertical direction. The text passed with the scroll command will be moved
vertically or horizontally on the display.

Command example (ds\_d6 board):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{uart:\PYGZti{}\PYGZdl{}} cfb scroll vertical \PYG{l+m}{60} \PYG{l+m}{5} ZEPHYR
\end{sphinxVerbatim}

\sphinxstylestrong{clear}: clear the display screen.

Command example (ds\_d6 board):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{uart:\PYGZti{}\PYGZdl{}} cfb clear
\PYG{g+go}{Display Cleared}
\end{sphinxVerbatim}


\section{LittlevGL Basic Sample}
\label{\detokenize{samples/sampleslvglREADME:littlevgl-basic-sample}}\label{\detokenize{samples/sampleslvglREADME:lvgl-sample}}\label{\detokenize{samples/sampleslvglREADME::doc}}

\subsection{Overview}
\label{\detokenize{samples/sampleslvglREADME:overview}}
This sample application displays “Hello World” in the center of the screen.


\subsection{Requirements}
\label{\detokenize{samples/sampleslvglREADME:requirements}}\begin{itemize}
\item {} 
Desay D6 OLED SSD1306

\item {} 
Linux box

\item {} 
Pinetime

\end{itemize}


\subsection{Building and Running}
\label{\detokenize{samples/sampleslvglREADME:building-and-running}}
west build \sphinxhyphen{}p \sphinxhyphen{}b ds\_d6 \sphinxhyphen{}d build\sphinxhyphen{}lvgl samples/lvgl

or

west build \sphinxhyphen{}p \sphinxhyphen{}b native\_posix\_64 samples/lvgl

run : ./build/zephyr/zephyr.exe

west build \sphinxhyphen{}p \sphinxhyphen{}b pinetime\_devkit1 samples/lvgl

run : ./build/zephyr/zephyr.exe


\subsection{References}
\label{\detokenize{samples/sampleslvglREADME:references}}

\section{Lightsensor}
\label{\detokenize{samples/samplesmax44009README:lightsensor}}\label{\detokenize{samples/samplesmax44009README::doc}}
This is a modified sample app to read the pah8001 Heartrate sensor from the Desay D6 smartwatch.
It is used as a light sensor, uses the I2C protocol and is based on the max44009.
In order to function it needs the modified driver.

Notice :  in Kconfig MAX44009NEW was defined to avoid confusion with existing driver max44009
(this way the original does not get selected)


\section{LittlevGL SDL Button  Sample}
\label{\detokenize{samples/samplespinebuttonREADME:littlevgl-sdl-button-sample}}\label{\detokenize{samples/samplespinebuttonREADME:sdl-sample}}\label{\detokenize{samples/samplespinebuttonREADME::doc}}

\subsection{Overview}
\label{\detokenize{samples/samplespinebuttonREADME:overview}}
This sample application displays “a LED” and “a button”
Long Press on the button and the LED changes “color”


\subsection{Requirements}
\label{\detokenize{samples/samplespinebuttonREADME:requirements}}
This sample uses the native\_posix solution, so no need for a real board.
You’ll need to have a SDL library installed.


\subsection{Building and Running}
\label{\detokenize{samples/samplespinebuttonREADME:building-and-running}}
west build \sphinxhyphen{}p \sphinxhyphen{}b native\_posix\_64 samples/sdlbutton


\subsection{References}
\label{\detokenize{samples/samplespinebuttonREADME:references}}

\section{LittlevGL SDL Button  Sample}
\label{\detokenize{samples/samplessdlbuttonREADME:littlevgl-sdl-button-sample}}\label{\detokenize{samples/samplessdlbuttonREADME:sdl-sample}}\label{\detokenize{samples/samplessdlbuttonREADME::doc}}

\subsection{Overview}
\label{\detokenize{samples/samplessdlbuttonREADME:overview}}
This sample application displays “a LED” and “a button”
Long Press on the button and the LED changes “color”


\subsection{Requirements}
\label{\detokenize{samples/samplessdlbuttonREADME:requirements}}
This sample uses the native\_posix solution, so no need for a real board.
You’ll need to have a SDL library installed.


\subsection{Building and Running}
\label{\detokenize{samples/samplessdlbuttonREADME:building-and-running}}
west build \sphinxhyphen{}p \sphinxhyphen{}b native\_posix\_64 samples/sdlbutton


\subsection{References}
\label{\detokenize{samples/samplessdlbuttonREADME:references}}

\section{Testing the timer refresh}
\label{\detokenize{samples/samplestimerREADME:testing-the-timer-refresh}}\label{\detokenize{samples/samplestimerREADME:sdl-sample}}\label{\detokenize{samples/samplestimerREADME::doc}}

\subsection{Overview}
\label{\detokenize{samples/samplestimerREADME:overview}}
This sample application displays “a blinking LED”.
A timer triggers the LED on/off state.


\subsection{Requirements}
\label{\detokenize{samples/samplestimerREADME:requirements}}
This sample uses the native\_posix solution, so no need for a real board.
You’ll need to have a SDL library installed.


\subsection{Building and Running}
\label{\detokenize{samples/samplestimerREADME:building-and-running}}
west build \sphinxhyphen{}p \sphinxhyphen{}b native\_posix\_64 samples/timer


\subsection{References}
\label{\detokenize{samples/samplestimerREADME:references}}

\chapter{Menuconfig}
\label{\detokenize{menuconfig:menuconfig}}\label{\detokenize{menuconfig::doc}}

\section{Zephyr is like linux}
\label{\detokenize{menuconfig:zephyr-is-like-linux}}
\sphinxstylestrong{TIP: the pinetime specific drivers are located under Modules}

\sphinxstylestrong{Note:}  to get a feel, compile a program, for example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/bluetooth/peripheral \PYGZhy{}D CONF\PYGZus{}FILE=\PYGZdq{}prj.conf\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{the pinetime contains an external 32Kz crystal}}
now you can have a look in the configurationfile (and modify if needed)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} west build \PYGZhy{}t menuconfig
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{Modules}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Board} \PYG{n}{Selection} \PYG{p}{(}\PYG{n}{nRF52832}\PYG{o}{\PYGZhy{}}\PYG{n}{MDK}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Board} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{SoC}\PYG{o}{/}\PYG{n}{CPU}\PYG{o}{/}\PYG{n}{Configuration} \PYG{n}{Selection} \PYG{p}{(}\PYG{n}{Nordic} \PYG{n}{Semiconductor} \PYG{n}{nRF52} \PYG{n}{series} \PYG{n}{MCU}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Hardware} \PYG{n}{Configuration}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{ARM} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Architecture} \PYG{p}{(}\PYG{n}{ARM} \PYG{n}{architecture}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{General} \PYG{n}{Architecture} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Floating} \PYG{n}{point}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{General} \PYG{n}{Kernel} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Device} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{n}{SELECT} \PYG{n}{THIS} \PYG{n}{ONE}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
    \PYG{n}{C} \PYG{n}{Library}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Additional} \PYG{n}{libraries}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Bluetooth}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Console} \PYG{n}{subsystem}\PYG{o}{/}\PYG{n}{support} \PYG{n}{routines} \PYG{p}{[}\PYG{n}{EXPERIMENTAL}\PYG{p}{]}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{C}\PYG{o}{+}\PYG{o}{+} \PYG{n}{support} \PYG{k}{for} \PYG{n}{the} \PYG{n}{application}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{System} \PYG{n}{Monitoring} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Debugging} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Disk} \PYG{n}{Interface}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{File} \PYG{n}{Systems}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZhy{}}\PYG{o}{*}\PYG{o}{\PYGZhy{}} \PYG{n}{Logging}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Management}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Networking}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[} \PYG{p}{]} \PYG{n}{IEEE} \PYG{l+m+mf}{802.15}\PYG{o}{.}\PYG{l+m+mi}{4} \PYG{n}{drivers} \PYG{n}{options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{(}\PYG{n}{UART\PYGZus{}0}\PYG{p}{)} \PYG{n}{Device} \PYG{n}{Name} \PYG{n}{of} \PYG{n}{UART} \PYG{n}{Device} \PYG{k}{for} \PYG{n}{UART} \PYG{n}{Console}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Console} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Net} \PYG{n}{loopback} \PYG{n}{driver}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Serial} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Interrupt} \PYG{n}{Controllers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Timer} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZhy{}}\PYG{o}{*}\PYG{o}{\PYGZhy{}} \PYG{n}{Entropy} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{GPIO} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Shared} \PYG{n}{interrupt} \PYG{n}{driver}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{SPI} \PYG{n}{hardware} \PYG{n}{bus} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{I2C} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{I2S} \PYG{n}{bus} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{PWM} \PYG{p}{(}\PYG{n}{Pulse} \PYG{n}{Width} \PYG{n}{Modulation}\PYG{p}{)} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Enable} \PYG{n}{board} \PYG{n}{pinmux} \PYG{n}{driver}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{ADC} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Watchdog} \PYG{n}{Support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Hardware} \PYG{n}{clock} \PYG{n}{controller} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{n}{SELECT} \PYG{n}{THIS} \PYG{n}{ONE}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Precision} \PYG{n}{Time} \PYG{n}{Protocol} \PYG{n}{Clock} \PYG{n}{driver} \PYG{n}{support}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{IPM} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{Max} \PYG{n}{compiled}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{log} \PYG{n}{level} \PYG{k}{for} \PYG{n}{ipm} \PYG{p}{(}\PYG{n}{Info}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Flash} \PYG{n}{hardware} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Sensor} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{Max} \PYG{n}{compiled}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{log} \PYG{n}{level} \PYG{k}{for} \PYG{n}{clock} \PYG{n}{control} \PYG{p}{(}\PYG{n}{Info}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{NRF} \PYG{n}{Clock} \PYG{n}{controller} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{n}{SELECT} \PYG{n}{THIS} \PYG{n}{ONE}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}}
\end{sphinxVerbatim}


\chapter{Debugging}
\label{\detokenize{debugging/debugging:debugging}}\label{\detokenize{debugging/debugging:id1}}\label{\detokenize{debugging/debugging::doc}}

\section{debugging}
\label{\detokenize{debugging/debug:debugging}}\label{\detokenize{debugging/debug::doc}}

\subsection{Segger JLink}
\label{\detokenize{debugging/debug:segger-jlink}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{smartwatch} \PYG{n}{does} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port}\PYG{o}{.}
\PYG{n}{A} \PYG{n}{way} \PYG{n}{around} \PYG{n}{this} \PYG{o+ow}{is} \PYG{n}{to} \PYG{n}{use} \PYG{n}{a} \PYG{n}{Segger} \PYG{n}{Jlink} \PYG{n}{debug}\PYG{o}{\PYGZhy{}}\PYG{n}{probe} \PYG{o+ow}{and} \PYG{n}{enable} \PYG{n}{logging} \PYG{o+ow}{and} \PYG{n}{shell} \PYG{n}{over} \PYG{n}{RTT}\PYG{p}{:}

\PYG{o+ow}{in} \PYG{n}{prj}\PYG{o}{.}\PYG{n}{cfg}\PYG{p}{:}

\PYG{n}{CONFIG\PYGZus{}LOG}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}USE\PYGZus{}SEGGER\PYGZus{}RTT}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}SHELL}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}SHELL\PYGZus{}BACKEND\PYGZus{}RTT}\PYG{o}{=}\PYG{n}{y}

\PYG{n}{start} \PYG{n}{the} \PYG{n}{debugger} \PYG{p}{:}
\PYG{n}{west} \PYG{n}{debug}
\PYG{o+ow}{and} \PYG{n}{enter} \PYG{p}{:} \PYG{k}{continue}

\PYG{n}{This} \PYG{n}{starts} \PYG{n}{up} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{background} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Segger Jlink Processes}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
What happens when you type : west debug?
You could type this on the command prompt.
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp+gpVirtualEnv}{(this start the server)}
\PYG{g+go}{JLinkGDBServer \PYGZhy{}select usb \PYGZhy{}port 2331 \PYGZhy{}if swd \PYGZhy{}speed 4000 \PYGZhy{}device nRF52832\PYGZus{}xxAA \PYGZhy{}silent \PYGZhy{}singlerun}
\PYG{g+gp+gpVirtualEnv}{(this starts the debug session)}
\PYG{g+go}{\PYGZti{}/zephyr\PYGZhy{}sdk/arm\PYGZhy{}zephyr\PYGZhy{}eabi/bin/arm\PYGZhy{}zephyr\PYGZhy{}eabi\PYGZhy{}gdb /root/zephyrproject/app/build/zephyr/zephyr.elf \PYGZhy{}ex target :2331 \PYGZhy{}ex halt \PYGZhy{}ex reset \PYGZhy{}ex load}
\PYG{g+go}{telnet 127.0.0.1 19021 (putty on linux) start the rtt console and shows the debug\PYGZhy{}log}
\end{sphinxVerbatim}


\subsection{Black Magic}
\label{\detokenize{debugging/debug:black-magic}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{ds}\PYG{o}{\PYGZhy{}}\PYG{n}{D6} \PYG{n}{smartwatch} \PYG{n}{has} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port}\PYG{o}{.}


\PYG{n}{The} \PYG{n}{blackmagicprobe} \PYG{n}{can} \PYG{n}{lauch} \PYG{n}{a} \PYG{n}{debugger} \PYG{p}{:} \PYG{n}{west} \PYG{n}{debug} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{runnerblackmagicprobe}\PYG{o}{.}
\PYG{n}{The} \PYG{n}{probe} \PYG{n}{has} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port} \PYG{o}{/}\PYG{n}{dev}\PYG{o}{/}\PYG{n}{ttyACM1} \PYG{p}{(}\PYG{n}{linux} \PYG{p}{:} \PYG{n}{minicom} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{l+m+mi}{115200} \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{o}{/}\PYG{n}{dev}\PYG{o}{/}\PYG{n}{ttyACM1}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{STM32 \sphinxhyphen{} Raspberry \sphinxhyphen{} OpenOCD}
\label{\detokenize{debugging/debug:stm32-raspberry-openocd}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{If} \PYG{n}{you} \PYG{n}{do} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{Segger} \PYG{n}{debug} \PYG{n}{probe} \PYG{n}{nor} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port}\PYG{p}{,} \PYG{n}{you} \PYG{n}{can} \PYG{n}{put} \PYG{n}{a} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{memory} \PYG{n}{at} \PYG{n}{a} \PYG{n}{fixed} \PYG{n}{location}\PYG{o}{.}
\PYG{n}{With} \PYG{n}{openocd} \PYG{n}{you} \PYG{n}{can} \PYG{n}{peek} \PYG{n}{at} \PYG{n}{this} \PYG{n}{memory} \PYG{n}{location}\PYG{o}{.}
\PYG{n}{If} \PYG{n}{you} \PYG{n}{own} \PYG{n}{a} \PYG{n}{raspberry} \PYG{n}{pi} \PYG{o+ow}{or} \PYG{n}{an} \PYG{n}{orange} \PYG{n}{pi}\PYG{p}{,} \PYG{n}{you} \PYG{n}{can} \PYG{n}{use} \PYG{n}{the} \PYG{n}{GPIO} \PYG{n}{header}\PYG{o}{.}
\PYG{n}{Another} \PYG{n}{cheap} \PYG{n}{option} \PYG{o+ow}{is} \PYG{n}{an} \PYG{n}{stm32} \PYG{n}{debug} \PYG{n}{probe}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\#define MY\_REGISTER (*(volatile uint8\_t*)0x2000F000)

in the program you can set values:
MY\_REGISTER=1;
MY\_REGISTER=8;

this way you know till where the code executes
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}telnet \PYG{l+m}{127}.0.0.1 \PYG{l+m}{4444}
\end{sphinxVerbatim}

programming

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{once your telnet sessions started:}
\PYG{g+go}{Trying 127.0.0.1...}
\PYG{g+go}{Connected to 127.0.0.1.}
\PYG{g+go}{Escape character is \PYGZsq{}\PYGZca{}]\PYGZsq{}.}
\PYG{g+go}{Open On\PYGZhy{}Chip Debugger}
\PYG{g+gp}{\PYGZgt{}}mdw 0x2000F000 0x1

\PYG{g+go}{the last byte shows the value of your program trace value}
\end{sphinxVerbatim}


\section{debugging Posix}
\label{\detokenize{debugging/debug-posix:debugging-posix}}\label{\detokenize{debugging/debug-posix::doc}}
start gdb on the command prompt

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp+gpVirtualEnv}{(gdb)} \PYG{g+go}{file build/zephyr/zephyr.elf}
\PYG{g+go}{Reading symbols from build/zephyr/zephyr.elf...done.}
\PYG{g+gp+gpVirtualEnv}{(gdb)} \PYG{g+go}{b main}
\PYG{g+go}{Breakpoint 1 at 0x5909: file /root/work/zephyr/boards/posix/native\PYGZus{}posix/main.c, line 56.}
\PYG{g+gp+gpVirtualEnv}{(gdb)} \PYG{g+go}{run}
\end{sphinxVerbatim}

Debug oswatch\sphinxhyphen{}bt (which needs and argument \textendash{}bt\sphinxhyphen{}dev=hci0)
Set the breakpoint in the function connected

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp+gpVirtualEnv}{(gdb)} \PYG{g+go}{file build/zephyr/zephyr.elf}
\PYG{g+go}{Reading symbols from build/zephyr/zephyr.elf...done.}
\PYG{g+gp+gpVirtualEnv}{(gdb)} \PYG{g+go}{b connected}
\PYG{g+go}{Breakpoint 1 at 0x498a: file /root/work/app/oswatch\PYGZhy{}bt/src/bt.c, line 140.}
\PYG{g+gp+gpVirtualEnv}{(gdb)} \PYG{g+go}{r \PYGZhy{}\PYGZhy{}bt\PYGZhy{}dev=hci0}
\end{sphinxVerbatim}


\section{The black magic probe}
\label{\detokenize{debugging/blackmagicprobe:the-black-magic-probe}}\label{\detokenize{debugging/blackmagicprobe::doc}}

\subsection{probes in zephyr}
\label{\detokenize{debugging/blackmagicprobe:probes-in-zephyr}}
You can program the nrf52832 with a debuggerprobe.
The standard\sphinxhyphen{}setup is jlink (segger).

/root/zephyrproject/zephyr/boards/arm/id107plus/board.cmake (adapt the runner here)

in our case : instead of jlink specify : blackmagicprobe

The cool thing about this probe that it has a serial port (3.3V) and a debug (upload) port on the same usb\sphinxhyphen{}port.
\begin{description}
\item[{::}] \leavevmode
/dev/ttyACM1 is serial port (pb6 pb7)

minicom \sphinxhyphen{}b 115200 \sphinxhyphen{}D /dev/ttyACM1

/dev/ttyACM0 is used as debugger/uploading

west debug \textendash{}runner blackmagicprobe
west flash \textendash{}runner blackmagicprobe

\end{description}


\subsection{howto setup a blackmagicprobe}
\label{\detokenize{debugging/blackmagicprobe:howto-setup-a-blackmagicprobe}}
You can buy this probe and support the developers. (make this world a better place)

I bought a “cheapo” “blue pill” stm32 board for future projects …
soldered a 1.8K resistor between 3.3K and PA12

downloaded from \sphinxurl{https://jeelabs.org/docs/software/bmp/}
\sphinxhyphen{} blackmagic.bin (79 ko)
\sphinxhyphen{} blackmagic\_dfu.bin (7 ko)

in jlink : loadbin blackmagic\_dfu.bin 0x8000000 (specify jlink no options …)
switch boot0 or boot1 or whatever
connect usb
in linux
dfu\sphinxhyphen{}util \sphinxhyphen{}v \sphinxhyphen{}R \sphinxhyphen{}d 0483:df11 \sphinxhyphen{}s 0x08002000 \sphinxhyphen{}D blackmagic.bin
(uploading in jlink was a problem cause memory restrictions)

\noindent\sphinxincludegraphics{{blackmagicd6}.jpeg}

(removed boot0 and boot1 connectors on the stm afterwards)

plugged it in the USB port and it pops up (had to enable it first in virtual box usb : black sphere technologies …..)


\section{pseudo}
\label{\detokenize{debugging/pseudo:pseudo}}\label{\detokenize{debugging/pseudo::doc}}

\subsection{simulation on NATIVE\_POSIX\_64}
\label{\detokenize{debugging/pseudo:simulation-on-native-posix-64}}
It is possible to use two serial ports on the virtual posix board.
One can display log message, while the other one lets you interact with the shell.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CONFIG\PYGZus{}UART\PYGZus{}CONSOLE}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}UART\PYGZus{}CONSOLE\PYGZus{}ON\PYGZus{}DEV\PYGZus{}NAME}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UART\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{CONFIG\PYGZus{}UART\PYGZus{}NATIVE\PYGZus{}POSIX\PYGZus{}PORT\PYGZus{}1\PYGZus{}ENABLE}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}UART\PYGZus{}NATIVE\PYGZus{}POSIX\PYGZus{}PORT\PYGZus{}1\PYGZus{}NAME}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UART\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{CONFIG\PYGZus{}SHELL}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}UART\PYGZus{}SHELL\PYGZus{}ON\PYGZus{}DEV\PYGZus{}NAME}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UART\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{root@osboxes:\PYGZti{}/work/app\PYGZsh{}} ./build/zephyr/zephyr.exe
\PYG{g+go}{UART\PYGZus{}1 connected to pseudotty: /dev/pts/2}
\PYG{g+go}{UART\PYGZus{}0 connected to pseudotty: /dev/pts/3}


\PYG{g+go}{minicom \PYGZhy{}D /dev/pts/3}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp+gpVirtualEnv}{(you should see log messages)}
\end{sphinxVerbatim}


\section{Bsim}
\label{\detokenize{debugging/bsim:bsim}}\label{\detokenize{debugging/bsim::doc}}
this is a method of debugging a bluetooth enabled application, without a bluetooth device


\subsection{debugging on nrf52\_bsim}
\label{\detokenize{debugging/bsim:debugging-on-nrf52-bsim}}
You can compile the oswatch\sphinxhyphen{}bt sample for the bsim board.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{west} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{nrf52\PYGZus{}bsim} \PYG{n}{oswatch}\PYG{o}{\PYGZhy{}}\PYG{n}{bt}
\PYG{n}{gdb}

\PYG{n}{file} \PYG{n}{build}\PYG{o}{/}\PYG{n}{zephyr}\PYG{o}{/}\PYG{n}{zephyr}\PYG{o}{.}\PYG{n}{elf}
\PYG{n}{b} \PYG{n}{connected} \PYG{p}{(}\PYG{n}{breakpoint} \PYG{n}{on} \PYG{n}{function} \PYG{n}{connected}\PYG{p}{)}
\PYG{n}{r} \PYG{o}{\PYGZhy{}}\PYG{n}{s}\PYG{o}{=}\PYG{n}{trial\PYGZus{}sim} \PYG{o}{\PYGZhy{}}\PYG{n}{d}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\section{Segger RTT (Real Time Transfer)}
\label{\detokenize{debugging/jlink:segger-rtt-real-time-transfer}}\label{\detokenize{debugging/jlink::doc}}

\section{Serial data without a serial port}
\label{\detokenize{debugging/jlink:serial-data-without-a-serial-port}}
Pinetime does not have UART pins but UART\sphinxhyphen{}like connection can be achieved using RTT (Real Time Transfer)
feature of Segger JLink debugger. RTT data can be accessed using the SEGGER tool (JLinkRTTViewer) or by using
telnet connection to active debug session. Second methond is recommended since it gives better throughput
and allows bitdirection communication using Zephyr Shell (with RTT as backend). PuTTY can be used to
telnet to debug session.

Prerequisites:
\sphinxhyphen{} JLink debugger, for example one of Nordic Semiconductor Development Kits.
\sphinxhyphen{} Setup: \sphinxurl{https://wiki.pine64.org/index.php/PineTime\#Using\_JLink\_programmer\_and\_nrfjprog\_tools}

Following steps needs to be taken to run RTT shell in the application:
1. Install PuTTY and Setup RTT session. On Linux, copy \sphinxtitleref{misc/rtt\_shell/rtt} to \sphinxtitleref{\textasciitilde{}/putty/sessions}. On Windows,
execute \sphinxtitleref{misc/rtt\_shell/putty\sphinxhyphen{}rtt.reg}.
2. Enable logging and shell over RTT:
\sphinxcode{\sphinxupquote{\textasciigrave{}
CONFIG\_LOG=y
CONFIG\_USE\_SEGGER\_RTT=y
CONFIG\_SHELL=y
CONFIG\_SHELL\_BACKEND\_RTT=y
\textasciigrave{}}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Build and flash application.

\end{enumerate}

4. Start debug session
\sphinxcode{\sphinxupquote{\textasciigrave{}
west debug (will start gdb)
continue (in gdb console)
\textasciigrave{}}}
5. Start PuTTY RTT session, prompt should be printed.

Resources:
\sphinxhyphen{} Zephyr shell documentation: \sphinxurl{https://docs.zephyrproject.org/latest/reference/shell/index.html}
\sphinxhyphen{} Zephyr logger documentation: \sphinxurl{https://docs.zephyrproject.org/latest/reference/logging/index.html}


\chapter{Hacking stuff}
\label{\detokenize{hacking/hacking:hacking-stuff}}\label{\detokenize{hacking/hacking:hacking}}\label{\detokenize{hacking/hacking::doc}}

\section{hacking   the pinetime smartwatch}
\label{\detokenize{hacking/flashing:hacking-the-pinetime-smartwatch}}\label{\detokenize{hacking/flashing::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{o+ow}{is} \PYG{n}{preloaded} \PYG{k}{with} \PYG{n}{firmware}\PYG{o}{.}
\PYG{n}{This} \PYG{n}{firmware} \PYG{o+ow}{is} \PYG{n}{secured}\PYG{p}{,} \PYG{n}{you} \PYG{n}{cannot} \PYG{n}{peek} \PYG{n}{into} \PYG{n}{it}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The pinetime has a swd interface.
To be able to write firmware,  you need special hardware.
I use a stm\sphinxhyphen{}link which is very cheap(2\$).
You can also use the GPIO header of a raspberry pi.
(my repo: \sphinxurl{https://github.com/najnesnaj/openocd} is adapted for the orange pi)
\end{sphinxadmonition}

To flash the software I use openocd :
example for stm\sphinxhyphen{}link usb\sphinxhyphen{}stick

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}} openocd \PYGZhy{}s /usr/local/share/openocd/scripts \PYGZhy{}f interface/stlink.cfg \PYGZhy{}f target/nrf52.cfg
\end{sphinxVerbatim}

example for the orange\sphinxhyphen{}pi GPIO header (or raspberry)
\begin{quote}

\# openocd \sphinxhyphen{}f /usr/local/share/openocd/scripts/interface/sysfsgpio\sphinxhyphen{}raspberrypi.cfg
\sphinxhyphen{}c ‘transport select swd’ \sphinxhyphen{}f /usr/local/share/openocd/scripts/target/nrf52.cfg
\sphinxhyphen{}c ‘bindto 0.0.0.0’
\end{quote}

once you started the openocd background server, you can connect to it using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}telnet \PYG{l+m}{127}.0.0.1 \PYG{l+m}{4444}
\end{sphinxVerbatim}

programming

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{once your telnet sessions started:}
\PYG{g+go}{Trying 127.0.0.1...}
\PYG{g+go}{Connected to 127.0.0.1.}
\PYG{g+go}{Escape character is \PYGZsq{}\PYGZca{}]\PYGZsq{}.}
\PYG{g+go}{Open On\PYGZhy{}Chip Debugger}
\PYG{g+gp}{\PYGZgt{}} program zephyr.bin

\PYG{g+go}{target halted due to debug\PYGZhy{}request, current mode: Thread}
\PYG{g+go}{xPSR: 0x01000000 pc: 0x00001534 msp: 0x20004a10}
\PYG{g+go}{** Programming Started **}
\PYG{g+go}{auto erase enabled}
\PYG{g+go}{using fast async flash loader. This is currently supported}
\PYG{g+go}{only with ST\PYGZhy{}Link and CMSIS\PYGZhy{}DAP. If you have issues, add}
\PYG{g+go}{\PYGZdq{}set WORKAREASIZE 0\PYGZdq{} before sourcing nrf51.cfg/nrf52.cfg to disable it}
\PYG{g+go}{target halted due to breakpoint, current mode: Thread}
\PYG{g+go}{xPSR: 0x61000000 pc: 0x2000001e msp: 0x20004a10}
\PYG{g+go}{wrote 24576 bytes from file zephyr.bin in 1.703540s (14.088 KiB/s)}
\PYG{g+go}{** Programming Finished **}

\PYG{g+go}{And finally execute a reset :}
\PYG{g+gp}{\PYGZgt{}}reset
\end{sphinxVerbatim}

removing write protection see:   {\hyperref[\detokenize{hacking/writeprotection:flashing}]{\sphinxcrossref{\DUrole{std,std-ref}{howto flash your zephyr image}}}}


\section{scanning the I2C\_1 port}
\label{\detokenize{hacking/i2cscanning:scanning-the-i2c-1-port}}\label{\detokenize{hacking/i2cscanning:i2cscanning}}\label{\detokenize{hacking/i2cscanning::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{does} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port}\PYG{o}{.}
\PYG{n}{I} \PYG{n}{do} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{segger} \PYG{n}{debugging} \PYG{n}{probe}\PYG{o}{.}
\PYG{n}{A} \PYG{n}{way} \PYG{n}{around} \PYG{n}{this}\PYG{p}{,} \PYG{n}{it} \PYG{n}{to} \PYG{n}{put} \PYG{n}{a} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{memory} \PYG{n}{at} \PYG{n}{a} \PYG{n}{fixed} \PYG{n}{location}\PYG{o}{.}
\PYG{n}{With} \PYG{n}{openocd} \PYG{n}{you} \PYG{n}{can} \PYG{n}{peek} \PYG{n}{at} \PYG{n}{this} \PYG{n}{memory} \PYG{n}{location}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{hacking/i2cscanning:building-and-running}}
In this repo under samples you will find an adapted i2c scanner program.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/i2c\PYGZus{}scanner}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\#define MY\_REGISTER (*(volatile uint8\_t*)0x2000F000)

in the program you can set values:
MY\_REGISTER=1;
MY\_REGISTER=8;

this way you know till where the code executes
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}telnet \PYG{l+m}{127}.0.0.1 \PYG{l+m}{4444}
\end{sphinxVerbatim}

Peeking

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{once your telnet sessions started:}
\PYG{g+go}{Trying 127.0.0.1...}
\PYG{g+go}{Connected to 127.0.0.1.}
\PYG{g+go}{Escape character is \PYGZsq{}\PYGZca{}]\PYGZsq{}.}
\PYG{g+go}{Open On\PYGZhy{}Chip Debugger}
\PYG{g+gp}{\PYGZgt{}}mdw 0x2000F000 0x1
\PYG{g+go}{0x2000f000: 00c24418}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Note:}:

this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first….)


\section{howto flash your zephyr image}
\label{\detokenize{hacking/writeprotection:howto-flash-your-zephyr-image}}\label{\detokenize{hacking/writeprotection:flashing}}\label{\detokenize{hacking/writeprotection::doc}}
Once you completed your \sphinxcode{\sphinxupquote{west build}} , your image is located under the build directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{   \PYGZdl{}} \PYG{n+nb}{cd} \PYGZti{}/work/pinetime/zephyr/build/zephyr
\PYG{g+go}{   here you can find zephyr.bin which you can flash}




\PYG{g+go}{I use Openocd to flash.}
\PYG{g+go}{Just connect : telnet 127.0.0.1 4444}

\PYG{g+go}{.. code\PYGZhy{}block:: console}

\PYG{g+go}{    program zephyr.bin}
\end{sphinxVerbatim}


\section{howto remove the write protection}
\label{\detokenize{hacking/writeprotection:howto-remove-the-write-protection}}\begin{description}
\item[{::}] \leavevmode
the PineTime watch is read/write protected (at least the one I got)
executing the following : nrf52.dap apreg 1 0x0c shows 0x0

Mind you, st\sphinxhyphen{}link does not allow you to execute that command, for this you will need a J\sphinxhyphen{}link.

There is a workaround using the GPIO of a raspberry pi or an Orangepi. (in this case you won’t need an external programmer at all)
(You can find an example for the orange pi in my repo :\sphinxurl{https://github.com/najnesnaj/openocd}.)
You have to reconfigure Openocd with the \textendash{}enable\sphinxhyphen{}cmsis\sphinxhyphen{}dap option.

Unlock the chip by executing the command:
\textgreater{} nrf52.dap apreg 1 0x04 0x01

\end{description}


\section{howto configure gateway}
\label{\detokenize{hacking/infrastructure:howto-configure-gateway}}\label{\detokenize{hacking/infrastructure:infrastructure}}\label{\detokenize{hacking/infrastructure::doc}}
Once you completed your \sphinxcode{\sphinxupquote{west build}} , your image is located under the build directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} \PYGZti{}/work/pinetime/zephyr/build/zephyr
\PYG{g+go}{here you can find zephyr.bin which you can flash}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{I} \PYG{n}{use} \PYG{n}{an} \PYG{n}{orange} \PYG{n}{pi} \PYG{n}{single} \PYG{n}{board} \PYG{n}{computer}\PYG{o}{.}
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{watch} \PYG{o+ow}{is} \PYG{n}{attached} \PYG{n}{to} \PYG{n}{this}\PYG{o}{.}
\PYG{n}{My} \PYG{n}{development} \PYG{o+ow}{is} \PYG{n}{done} \PYG{n}{on} \PYG{n}{a} \PYG{n}{laptop}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
How can you copy from one environment (laptop) to another (SBC) without typing password?
\end{sphinxVerbatim}

On the laptop :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{ssh\PYGZhy{}keygen \PYGZhy{}b 8092 \PYGZhy{}t rsa \PYGZhy{}C \PYGZdq{}fota gw access key\PYGZdq{} \PYGZhy{}f \PYGZti{}/.ssh/orange}
\PYG{g+go}{Generating public/private rsa key pair.}
\PYG{g+go}{Enter passphrase (empty for no passphrase):          (LEAVE EMPTY!)}
\PYG{g+go}{Enter same passphrase again:}
\PYG{g+go}{Your identification has been saved in /root/.ssh/orange.}
\PYG{g+go}{Your public key has been saved in /root/.ssh/orange.pub.}
\PYG{g+go}{The key fingerprint is:}
\PYG{g+go}{SHA256:xCM5Fk1LAVjEWqrM6LKM8Y6+Y12ONt6eV8vDa/KdRUM fota gw access key}
\PYG{g+go}{The key\PYGZsq{}s randomart image is:}
\PYG{g+go}{+\PYGZhy{}\PYGZhy{}\PYGZhy{}[RSA 8092]\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{g+go}{|     ==++.       |}
\PYG{g+go}{|B*B.o+. +ooo     |}
\PYG{g+go}{+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}[SHA256]\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}

\PYG{g+gp+gpVirtualEnv}{(the standard port is 22 and not 9988 which is my custom port)}

\PYG{g+go}{copy the certificate to the SBC (which name is orange in my case):}
\PYG{g+go}{ssh\PYGZhy{}copy\PYGZhy{}id \PYGZhy{}p 9988 \PYGZhy{}i \PYGZti{}/.ssh/orange.pub root@orange}


\PYG{g+go}{create config file :  \PYGZti{}/.ssh/config}
\PYG{g+go}{      Host orange}
\PYG{g+go}{      HostName orange}
\PYG{g+go}{      User root}
\PYG{g+go}{      Port 9988}
\PYG{g+go}{      IdentityFile \PYGZti{}/.ssh/orange}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Now} \PYG{n}{you} \PYG{n}{can} \PYG{n}{copy} \PYG{n}{without} \PYG{n}{a} \PYG{n}{password} \PYG{p}{:}
\PYG{n}{scp} \PYG{n}{build}\PYG{o}{/}\PYG{n}{zephyr}\PYG{o}{/}\PYG{n}{zephyr}\PYG{o}{.}\PYG{n}{bin} \PYG{n}{orange}\PYG{p}{:}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{src}
\end{sphinxVerbatim}
\phantomsection\label{\detokenize{hacking/openocd:openocd}}
w


\section{howto use 2 openocd sessions}
\label{\detokenize{hacking/openocd:howto-use-2-openocd-sessions}}\label{\detokenize{hacking/openocd::doc}}
Once you completed your \sphinxcode{\sphinxupquote{west build}} , your image is located under the build directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{   \PYGZdl{}} \PYG{n+nb}{cd} \PYGZti{}/work/pinetime/zephyr/build/zephyr
\PYG{g+go}{   here you can find zephyr.bin which you can flash}




\PYG{g+go}{I use Openocd to flash.}
\PYG{g+go}{Just connect : telnet 127.0.0.1 4444}

\PYG{g+go}{.. code\PYGZhy{}block:: console}

\PYG{g+go}{    program zephyr.bin}
\end{sphinxVerbatim}


\subsection{Suppose you have 2 microcontrollers}
\label{\detokenize{hacking/openocd:suppose-you-have-2-microcontrollers}}\begin{quote}

Just connect : telnet 127.0.0.1 7777 for the second.
\end{quote}


\subsection{Howto setup a second openocd session on a different port?}
\label{\detokenize{hacking/openocd:howto-setup-a-second-openocd-session-on-a-different-port}}
In this case an ST\sphinxhyphen{}LINK/V2 an in\sphinxhyphen{}circuit debugger and programmer is used.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openocd} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{telnet\PYGZus{}port 7777}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tcl\PYGZus{}port 6667}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gdb\PYGZus{}port 3332}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{share}\PYG{o}{/}\PYG{n}{openocd}\PYG{o}{/}\PYG{n}{scripts} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{interface}\PYG{o}{/}\PYG{n}{stlink}\PYG{o}{.}\PYG{n}{cfg}  \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{target}\PYG{o}{/}\PYG{n}{nrf52}\PYG{o}{.}\PYG{n}{cfg}
\end{sphinxVerbatim}


\subsection{Howto use the GPIO header of a Single Board computer}
\label{\detokenize{hacking/openocd:howto-use-the-gpio-header-of-a-single-board-computer}}
This works really well, and does not require a seperate programmer.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openocd} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{share}\PYG{o}{/}\PYG{n}{openocd}\PYG{o}{/}\PYG{n}{scripts}\PYG{o}{/}\PYG{n}{interface}\PYG{o}{/}\PYG{n}{sysfsgpio}\PYG{o}{\PYGZhy{}}\PYG{n}{raspberrypi}\PYG{o}{.}\PYG{n}{cfg} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transport select swd}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{share}\PYG{o}{/}\PYG{n}{openocd}\PYG{o}{/}\PYG{n}{scripts}\PYG{o}{/}\PYG{n}{target}\PYG{o}{/}\PYG{n}{nrf52}\PYG{o}{.}\PYG{n}{cfg}  \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bindto 0.0.0.0}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}


\section{howto generate pdf documents}
\label{\detokenize{hacking/latexpdf:howto-generate-pdf-documents}}\label{\detokenize{hacking/latexpdf::doc}}
sphinx cannot generate pdf directly, and needs latex

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{latexmk}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{fonts}\PYG{o}{\PYGZhy{}}\PYG{n}{recommended}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{xzdec}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{cmap}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{latex}\PYG{o}{\PYGZhy{}}\PYG{n}{recommended}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{latex}\PYG{o}{\PYGZhy{}}\PYG{n}{extra}
\end{sphinxVerbatim}


\section{The Movie}
\label{\detokenize{hacking/movie:the-movie}}\label{\detokenize{hacking/movie::doc}}
\sphinxurl{https://youtu.be/A-kYHdrr-Mg}

or

oswatchclip.mp4


\subsection{editing :}
\label{\detokenize{hacking/movie:editing}}
Kdenlive


\subsection{script :}
\label{\detokenize{hacking/movie:script}}
LibreOffice Impress


\subsection{Camera :}
\label{\detokenize{hacking/movie:camera}}
SimpleScreenRecorder


\subsection{Voice over :}
\label{\detokenize{hacking/movie:voice-over}}
espeak \sphinxhyphen{}v en+f5 \sphinxhyphen{}a 100 \sphinxhyphen{}p 50 \sphinxhyphen{}s 110 \sphinxhyphen{}f slide2.txt \sphinxhyphen{}w slide2.wav


\subsection{Music by Beethoven:}
\label{\detokenize{hacking/movie:music-by-beethoven}}
fluidsynth \sphinxhyphen{}a pulseaudio \sphinxhyphen{}o audio.alsa.device=hw:1 \sphinxhyphen{}m alsa\_seq \sphinxhyphen{}l \sphinxhyphen{}i /usr/share/sounds/sf2/FluidR3\_GM.sf2 moonlight\_sonata.mid

this one works best :
timidity moonlight\_sonata.mid \sphinxhyphen{}Ow \sphinxhyphen{}o out.wav


\chapter{Behind the scene}
\label{\detokenize{behind/behind:behind-the-scene}}\label{\detokenize{behind/behind:id1}}\label{\detokenize{behind/behind::doc}}

\section{Touchscreen}
\label{\detokenize{behind/touchscreen:touchscreen}}\label{\detokenize{behind/touchscreen::doc}}
In my first release I created a touchscreendriver that read the x\sphinxhyphen{}y coordinates from the pinetime screen.

Meanwhile a rudimentary touchscreen driver exist in Zephyr. (KSCAN\_TOUCH)

It integrates with LVGL.

I managed to adapt the driver from Focaltech, so it now supports the Pinetime as well.

However it is not capable of detecting events like “slide up/down”, but point and click is usable.


\subsection{Overview}
\label{\detokenize{behind/touchscreen:overview}}
Touchscreen Hynitron


\subsection{Requirements}
\label{\detokenize{behind/touchscreen:requirements}}

\subsection{Building and Running}
\label{\detokenize{behind/touchscreen:building-and-running}}

\subsection{Todo}
\label{\detokenize{behind/touchscreen:todo}}\begin{quote}

\sphinxhyphen{}support more touchscreen events
\end{quote}


\subsection{References}
\label{\detokenize{behind/touchscreen:references}}

\section{placing a button on the screen}
\label{\detokenize{behind/lvglbutton:placing-a-button-on-the-screen}}\label{\detokenize{behind/lvglbutton::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{This} \PYG{n}{sample} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{really} \PYG{n}{important}\PYG{p}{,} \PYG{n}{but} \PYG{n}{it} \PYG{n}{will} \PYG{n}{teach} \PYG{n}{you} \PYG{n}{that} \PYG{n}{you} \PYG{n}{need} \PYG{n}{to} \PYG{n+nb}{set} \PYG{n}{LVGL\PYGZus{}CONFIG} \PYG{n}{values}\PYG{p}{,} \PYG{o+ow}{in} \PYG{n}{order}    \PYG{n}{to} \PYG{n}{be} \PYG{n}{able} \PYG{n}{to} \PYG{n}{use} \PYG{n}{LVGL} \PYG{n}{functions}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{behind/lvglbutton:building-and-running}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}


\chapter{About}
\label{\detokenize{about:about}}\label{\detokenize{about::doc}}
I got a pinetime development kit very early.
I would like to thank the folks from \sphinxurl{https://www.pine64.org/} for the kit.

The Nordic nrf52832 is an Arm based, 32bit microcontroller with a lot of flash, RAM memory and(!) bluetooth!
It is a good platform to explore the wonderfull world of opensource RTOS’s.
I choose the Zephyr platform, because it already contained the display driver, and the bluetooth functionality.
Furthermore it can be updated wirelessly.

I started of with adapting simple samples, so they would run on the pinetime watch.
Meanwhile I learned how to adapt the board definition file.
Gradually this morphed into a pinetime\sphinxhyphen{}toolkit.
A few experts contributed and improved this kit so it became usable.

I took a long break from this project, zephyr evolved and a project for creating an open source watch, the hypnos\sphinxhyphen{}firmware flourished.

The drivers for the heartrate sensor, touchpanel that I adapted, became obsolete.
The pinetime board definition file is now part of the zephyr RTOS distribution.

Recently I discovered that the standard focaltech touchscreen driver could be adapted easily so it would run on the pinetime and integrate nicely with the LVGL\sphinxhyphen{}gui. There were several OLED ssd1306 watches on my desk and I wondered if I could run Zephyr and LVGL (graphical stuff) on them as well. (yes, we can!)
I played around with the “native\_posix\_64” board, which is a virtual board that allows you to run firmware on your computer instead of on the watch (no need for flashing).

This gave me the idea for an opensource\sphinxhyphen{}watch\sphinxhyphen{}framework.
Start of with simple samples, and add some more functionality, until finally you end up with a smartwatch.
The framework is build around three smartwatches, the pinetime, the ds\_d6 and the posix\_sdl.
It should work on other platform as well, with minor modifications.
I only recently got the idea for out\sphinxhyphen{}of\sphinxhyphen{}tree development.
Just put all the modified drivers, board definitions and application in one place outside of the zephyr\sphinxhyphen{}tree.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{n}{word} \PYG{n}{of} \PYG{n}{warning}\PYG{p}{:} \PYG{n}{this} \PYG{o+ow}{is} \PYG{n}{work} \PYG{o+ow}{in} \PYG{n}{progress}\PYG{o}{.}
\PYG{n}{You}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{re likely to have a better skillset then me.}
\PYG{n}{You} \PYG{n}{are} \PYG{n}{invited} \PYG{n}{to} \PYG{n}{add} \PYG{n}{the} \PYG{n}{missing} \PYG{n}{pieces} \PYG{o+ow}{and} \PYG{n}{to} \PYG{n}{improve} \PYG{n}{what}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s already there.}
\end{sphinxVerbatim}


\chapter{Author}
\label{\detokenize{author:author}}\label{\detokenize{author::doc}}
Some 20 years ago I attended a course on how to brew beer.
Real beer, starting with barley, wheat, yeast, brewkettles …

I bought some brewing equipment and started brewing my own beer.
Apart from a stupid idea, (why brew beer in a country that has plenty of breweries), I soon found out that brewing is labour intensitive.

Instead of quitting right away (the most sensisible thing to do), I tried to reduce the effort.
I switched from a gasheated kettle to an electric one.

The next step was to control the temperature.
I got an arduino and a temp\sphinxhyphen{}sensor.
This got me interested in microcontrollers.

It appealed to my childish nature, that I could get quick results with little coding.
Blinking a led, really lightens up my day!
And a beer of course.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Guess}\PYG{p}{,} \PYG{n}{even} \PYG{k}{for} \PYG{n}{a} \PYG{n}{technically} \PYG{n}{skilled} \PYG{n}{audiance}\PYG{p}{,} \PYG{n}{story}\PYG{o}{\PYGZhy{}}\PYG{n}{telling}\PYG{p}{,}  \PYG{n}{renders} \PYG{n}{a} \PYG{n}{manual} \PYG{n}{less} \PYG{n}{boring} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}



\renewcommand{\indexname}{Index}
\printindex
\end{document}