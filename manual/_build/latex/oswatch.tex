%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}




\title{open source watch Documentation}
\date{Feb 19, 2021}
\release{1.1.0}
\author{jj}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}
\noindent\sphinxincludegraphics{{zephyr_logo}.png}




\chapter{Copyright}
\label{\detokenize{copyright:copyright}}\label{\detokenize{copyright::doc}}
The book is subject to copyright.

You cannot use the book, or parts of the book into your own publications, without the permission of the author.

I have put in most of the code a copyright with my mailadress.
This does not mean anything. It is just to let you know I modified existing code. The code has been tampered with …


\section{author:}
\label{\detokenize{copyright:author}}
Jan Jansen
\sphinxhref{mailto:najnesnaj@yahoo.com}{najnesnaj@yahoo.com}


\section{LICENSE:}
\label{\detokenize{copyright:license}}
All the software is subject to the Apache 2.0 license (same as the Zephyr RTOS)


\chapter{Zephyr  smartwatch framework}
\label{\detokenize{content:zephyr-smartwatch-framework}}\label{\detokenize{content::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{this} \PYG{n}{document} \PYG{n}{started} \PYG{n}{off} \PYG{o+ow}{in} \PYG{n}{setting} \PYG{n}{up} \PYG{n}{zephyr} \PYG{n}{RTOS} \PYG{n}{on} \PYG{n}{the} \PYG{n}{PineTime} \PYG{n}{smartwatch}\PYG{o}{.}

\PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{wiki}\PYG{o}{.}\PYG{n}{pine64}\PYG{o}{.}\PYG{n}{org}\PYG{o}{/}\PYG{n}{index}\PYG{o}{.}\PYG{n}{php}\PYG{o}{/}\PYG{n}{PineTime}

\PYG{n}{It} \PYG{n}{evolved} \PYG{n}{to} \PYG{n}{accomodate} \PYG{n}{other} \PYG{n}{nordic} \PYG{n}{nrf52832} \PYG{n}{based} \PYG{n}{watches} \PYG{p}{(}\PYG{n}{Desay} \PYG{n}{D6}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{a} \PYG{n}{Virtual} \PYG{n}{watch} \PYG{p}{(}\PYG{n}{native\PYGZus{}posix\PYGZus{}64}\PYG{p}{)}

\PYG{n}{The} \PYG{n}{virtual} \PYG{n}{watch} \PYG{n}{lets} \PYG{n}{you} \PYG{n}{create} \PYG{o+ow}{and} \PYG{n}{debug} \PYG{n}{software} \PYG{n}{without} \PYG{n}{a} \PYG{n}{watch} \PYG{n}{nor} \PYG{n}{a} \PYG{n}{debugprobe}\PYG{o}{.} \PYG{p}{(}\PYG{o}{=}\PYG{n}{cheap}\PYG{p}{)}
\PYG{n}{There} \PYG{n}{exist} \PYG{n}{a} \PYG{n}{lot} \PYG{n}{of} \PYG{n}{cheap} \PYG{p}{(}\PYG{n}{chinese}\PYG{p}{)} \PYG{n}{watches} \PYG{n}{based} \PYG{n}{on} \PYG{n}{Nordic} \PYG{n}{microcontrollers}\PYG{o}{.}
\PYG{n}{The} \PYG{n}{hardware} \PYG{n}{will} \PYG{n}{probably} \PYG{n}{differ}\PYG{p}{,} \PYG{n}{but} \PYG{k}{with} \PYG{n}{minor} \PYG{n}{adjustments} \PYG{n}{it} \PYG{n}{should} \PYG{n}{be} \PYG{n}{possible} \PYG{n}{to} \PYG{n}{adapt} \PYG{n}{the} \PYG{n}{framework}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{the} \PYG{n}{approach} \PYG{o+ow}{in} \PYG{n}{this} \PYG{n}{manual} \PYG{o+ow}{is} \PYG{n}{to} \PYG{n}{get} \PYG{n}{quick} \PYG{n}{results} \PYG{p}{:}
    \PYG{o}{\PYGZhy{}} \PYG{n}{minimal} \PYG{n}{effort} \PYG{n}{install}
    \PYG{o}{\PYGZhy{}} \PYG{k}{try} \PYG{n}{out} \PYG{n}{the} \PYG{n}{samples}
    \PYG{o}{\PYGZhy{}} \PYG{n}{inspire} \PYG{n}{you} \PYG{n}{to} \PYG{n}{modify} \PYG{o+ow}{and} \PYG{n}{enhance}


\PYG{n}{The} \PYG{n}{masterpiece} \PYG{o+ow}{is} \PYG{n}{the} \PYG{n}{firmware} \PYG{n}{toolkit}\PYG{o}{.}
\PYG{n}{Since} \PYG{n}{it} \PYG{o+ow}{is} \PYG{n}{a} \PYG{n}{big} \PYG{n}{chunk} \PYG{n}{of} \PYG{n}{code}\PYG{p}{,} \PYG{n}{you} \PYG{n}{might} \PYG{n}{be} \PYG{n}{lost}\PYG{o}{.}

\PYG{n}{The} \PYG{n}{samples} \PYG{o+ow}{in} \PYG{n}{the} \PYG{o}{/}\PYG{n}{app} \PYG{n}{directory}\PYG{p}{,} \PYG{n}{contain} \PYG{n}{parts} \PYG{n}{of} \PYG{n}{the} \PYG{n}{toolkit}\PYG{o}{.}
\PYG{n}{Like} \PYG{n}{building} \PYG{n}{blocks}\PYG{p}{,} \PYG{n}{which} \PYG{n}{form} \PYG{n}{the} \PYG{n}{final} \PYG{n}{firmware}\PYG{o}{.}
\end{sphinxVerbatim}
\begin{description}
\item[{suggestion :}] \leavevmode\begin{itemize}
\item {} 
follow the Zephyr installation instructions

\item {} 
try some examples

\item {} 
if you like it copy the /app directory for some more fun

\end{itemize}

\end{description}

\noindent\sphinxincludegraphics{{PineTime-830x400}.png}


\chapter{Install zephyr}
\label{\detokenize{installation:install-zephyr}}\label{\detokenize{installation::doc}}

\section{update on 31\sphinxhyphen{}12\sphinxhyphen{}2020}
\label{\detokenize{installation:update-on-31-12-2020}}
Pinetime has become part of the standard zephyr distribution!

These days you can install zephyr and execute a pinetime sample!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{west} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{pinetime\PYGZus{}devkit0} \PYG{n}{samples}\PYG{o}{/}\PYG{n}{boards}\PYG{o}{/}\PYG{n}{pine64\PYGZus{}pinetime}
\end{sphinxVerbatim}


\section{How to install zephyr}
\label{\detokenize{installation:how-to-install-zephyr}}
\sphinxurl{https://docs.zephyrproject.org/latest/getting\_started/index.html}

the documentation describes an installation process under Ubuntu/macOS/Windows


\section{How to install the open source watch framekit}
\label{\detokenize{installation:how-to-install-the-open-source-watch-framekit}}
The kit should work alongside the zephyr installation.
Just get a copy of the “app” directory.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}work\PYGZgt{}  /app
     ├──/zephyr
     ├──.....
\end{sphinxVerbatim}

the app\sphinxhyphen{}directory contains the drivers and source code and(!) modified board definitions.

\sphinxstylestrong{TIP : sometimes you run into trouble compiling: removing the build directory can help in that case}


\chapter{Out of tree}
\label{\detokenize{out-of-tree:out-of-tree}}\label{\detokenize{out-of-tree::doc}}
A technique used in zephyr/samples/application\sphinxhyphen{}development, is “out of tree” development.

When you tincker with watches, you will soon find out that not all the drivers exist.

You can adapt existing zephyr drivers, but placing them within the zephyr repository could cause issues (upgrading zephyr).

The samples provided contain the board definition and the drivers within their directory outside the zephyr directory.

Have a look at the samples, on how it is done.


\chapter{Starting with some basic applications}
\label{\detokenize{basicapplications:starting-with-some-basic-applications}}\label{\detokenize{basicapplications::doc}}
The best way to get a feel of zephyr for the smartwatch, is to start building applications.

The watch framework is under /app.

The framework contains a clock, bluetooth, a procedure to upgrade over the air, cts  …

To reduce the complexity, samples are provided.
Each sample contains a single feature of the framework.


\section{Building and Running}
\label{\detokenize{basicapplications:building-and-running}}
The “native\_posix\_64” board is your own linux\sphinxhyphen{}box.
This means that you can execute the code on your system.
You do not need a smartwatch.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b native\PYGZus{}posix\PYGZus{}64 samples/sdlbutton}
\end{sphinxVerbatim}

running : ./build/zephyr/zephyr.exe

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime\PYGZus{}devkit1 samples/sdlbutton}
\end{sphinxVerbatim}

running : west flash


\subsection{Reading out the button on the watch}
\label{\detokenize{basicapplications:reading-out-the-button-on-the-watch}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{does} \PYG{n}{have} \PYG{n}{a} \PYG{n}{button} \PYG{n}{on} \PYG{n}{the} \PYG{n}{side}\PYG{o}{.}
\PYG{n}{The} \PYG{n}{desay} \PYG{n}{D6} \PYG{n}{has} \PYG{n}{a} \PYG{n}{touchbutton} \PYG{o+ow}{in} \PYG{n}{front}\PYG{o}{.}
\PYG{n}{The} \PYG{n}{virtual} \PYG{n}{POSIX} \PYG{n}{watch} \PYG{n}{has} \PYG{n}{a} \PYG{n}{touchbutton}
\end{sphinxVerbatim}


\section{Building and Running}
\label{\detokenize{basicapplications:id1}}
\sphinxstyleemphasis{Note:}:
\sphinxtitleref{The pinetime watch has a button out port (15) and button in port (13). You have to set the out\sphinxhyphen{}port high. Took me a while to figure this out…}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/button}
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b ds\PYGZus{}d6 samples/button}
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b native\PYGZus{}posix\PYGZus{}64 samples/button}
\end{sphinxVerbatim}


\chapter{bluetooth (BLE) example}
\label{\detokenize{bluetooth:bluetooth-ble-example}}\label{\detokenize{bluetooth::doc}}

\section{simulated on laptop}
\label{\detokenize{bluetooth:simulated-on-laptop}}
how to activate bluetooth?

VBOX running ubuntu (first disactivate driver in windows)
(CTRL home \textendash{} select usb \textendash{} (intel in my case)) \textendash{} this lets you select the integrated bluetoothmodule of your laptop
\begin{quote}

hciconfig hci0 down
\begin{description}
\item[{west build \sphinxhyphen{}p \sphinxhyphen{}b native\_posix\_64 samples/bluetooth/peripheral\_hr}] \leavevmode
./build/zephyr/zephyr.exe \textendash{}bt\sphinxhyphen{}dev=hci0

\end{description}
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{bluetoothctl}
\PYG{g+gp}{[bluetooth]\PYGZsh{}} devices
\PYG{g+go}{Device C6:78:40:29:EC:31 Zephyr Heartrate Sensor}
\PYG{g+go}{Device C9:16:85:ED:B6:4E DS\PYGZhy{}D6 b64e}
\PYG{g+go}{Device C8:B7:89:A9:B0:C9 Espruino\PYGZhy{}107 b0c9}
\PYG{g+go}{Device 00:1A:7D:DA:71:0B posix\PYGZus{}64}


\PYG{g+gp}{[bluetooth]\PYGZsh{}} info \PYG{l+m}{00}:1A:7D:DA:71:0B
\PYG{g+go}{Device 00:1A:7D:DA:71:0B (public)}
\PYG{g+go}{Name: posix\PYGZus{}64}
\PYG{g+go}{Alias: posix\PYGZus{}64}
\PYG{g+go}{Paired: no}
\PYG{g+go}{Trusted: no}
\PYG{g+go}{Blocked: no}
\PYG{g+go}{Connected: no}
\PYG{g+go}{LegacyPairing: no}
\PYG{g+go}{UUID: Device Information        (0000180a\PYGZhy{}0000\PYGZhy{}1000\PYGZhy{}8000\PYGZhy{}00805f9b34fb)}
\PYG{g+go}{UUID: Current Time Service      (00001805\PYGZhy{}0000\PYGZhy{}1000\PYGZhy{}8000\PYGZhy{}00805f9b34fb)}
\end{sphinxVerbatim}

The PineTime uses a Nordic nrf52832 chip, which has BLE functionality build into it.

To test, you can compile a standard application : Eddy Stone.

The watch will behave as a bluetooth beacon, and you should be able to detect it with your smartphone or with bluez under linux.


\subsection{Using a standard zephyr application under pinetime:}
\label{\detokenize{bluetooth:using-a-standard-zephyr-application-under-pinetime}}
Each sample has its own directory.
In this directory you will notice a file : “CMakeLists.txt”.

In order to use a standard, you can just copy it under the pinetime directory.

In order to be able to compile it, you just have to add one line in the CMakeList.txt :

\sphinxtitleref{include(\$ENV\{ZEPHYR\_BASE\}/../pinetime/cmake/boilerplate.cmake)}

Have a look in the samples/bluetooth/eddystone directory.


\subsection{Eddy Stone}
\label{\detokenize{bluetooth:eddy-stone}}\begin{quote}

see:   \DUrole{xref,std,std-ref}{bluetooth\sphinxhyphen{}eddystone\sphinxhyphen{}sample}
\end{quote}

\sphinxstylestrong{Note:}  compile the provided example, so a build directory gets created

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} west build \PYGZhy{}p \PYGZhy{}b pinetime samples/bluetooth/eddystone
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{this builds an image, which can be found under the build directory}}


\subsection{Using the created bluetooth sample:}
\label{\detokenize{bluetooth:using-the-created-bluetooth-sample}}
I use linux with a bluetoothadapter 4.0.
You need to install bluez.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}bluetoothctl
\PYG{g+gp}{[bluetooth]\PYGZsh{}}scan on
\end{sphinxVerbatim}

And your Eddy Stone should be visible.

If you have a smartphone, you can download the nrf utilities app from nordic.


\subsection{Ble Peripheral}
\label{\detokenize{bluetooth:ble-peripheral}}
this example is a demo of the services under bluetooth

first build the image

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}}  west build \PYGZhy{}p \PYGZhy{}b pinetime samples/bluetooth/peripheral
\end{sphinxVerbatim}

With linux you can have a look using bluetoothctl:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}bluetoothctl
\PYG{g+gp}{[bluetooth]\PYGZsh{}}scan on


\PYG{g+go}{[NEW] Device 60:7C:9E:92:50:C1 Zephyr Peripheral Sample Long}
\PYG{g+go}{once you see your device}
\PYG{g+gp}{[blueooth]\PYGZsh{}}connect \PYG{l+m}{60}:7C:9E:92:50:C1 \PYG{o}{(}the device mac address as displayed\PYG{o}{)}

\PYG{g+go}{then you can already see the services}
\end{sphinxVerbatim}

same thing with the app from nordic, you could try to connect and display value of e.g. heart rate


\subsection{using Python to read out bluetoothservices}
\label{\detokenize{bluetooth:using-python-to-read-out-bluetoothservices}}
In this repo you will find a python script : readbat.py
In order to use it you need bluez on linux and the python \sphinxtitleref{bluepy} module.

It can be used in conjunction with the peripheral bluetooth demo.
It just reads out the battery level, and prints it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{binascii}
\PYG{k+kn}{from} \PYG{n+nn}{bluepy}\PYG{n+nn}{.}\PYG{n+nn}{btle} \PYG{k+kn}{import} \PYG{n}{UUID}\PYG{p}{,} \PYG{n}{Peripheral}

\PYG{n}{temp\PYGZus{}uuid} \PYG{o}{=} \PYG{n}{UUID}\PYG{p}{(}\PYG{l+m+mh}{0x2A19}\PYG{p}{)}

\PYG{n}{p} \PYG{o}{=} \PYG{n}{Peripheral}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{60:7C:9E:92:50:C1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{random}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{try}\PYG{p}{:}
   \PYG{n}{ch} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{getCharacteristics}\PYG{p}{(}\PYG{n}{uuid}\PYG{o}{=}\PYG{n}{temp\PYGZus{}uuid}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
   \PYG{n+nb}{print} \PYG{n}{binascii}\PYG{o}{.}\PYG{n}{b2a\PYGZus{}hex}\PYG{p}{(}\PYG{n}{ch}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{finally}\PYG{p}{:}
    \PYG{n}{p}\PYG{o}{.}\PYG{n}{disconnect}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{display}
\label{\detokenize{display:display}}\label{\detokenize{display:display-sample}}\label{\detokenize{display::doc}}

\section{Display    example}
\label{\detokenize{display:display-example}}
There are three types of display included.
\begin{itemize}
\item {} 
a st7789 color display used in the pinetime

\item {} 
a monochrome SSD1306 OLED display used in the desay D6

\item {} 
a on\sphinxhyphen{}screen display SDL simulated on linux

\end{itemize}


\chapter{LittlevGL Basic Sample}
\label{\detokenize{lvgl:littlevgl-basic-sample}}\label{\detokenize{lvgl:lvgl-sample}}\label{\detokenize{lvgl::doc}}

\section{Overview}
\label{\detokenize{lvgl:overview}}
This sample application displays “Hello World” in the center of the screen
and a counter at the bottom which increments every second.

LittlevGL is a free and open\sphinxhyphen{}source graphics library providing everything you need to create embedded GUI with easy\sphinxhyphen{}to\sphinxhyphen{}use graphical elements, beautiful visual effects and low memory footprint.


\section{Simulation}
\label{\detokenize{lvgl:simulation}}
In order to avoid uploading to check what the display looks like, there is a simple way to simulate this.
I’ve tested this on Ubuntu 18.04 64bit. You’ll need the SDL2 library.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b native\PYGZus{}posix\PYGZus{}64 samples/display/lvgl \PYGZhy{}DCONF=board/native\PYGZhy{}posix\PYGZus{}64}
\end{sphinxVerbatim}

after the building, you can find build/zephyr/zephyr.exe (and execute this to see display\sphinxhyphen{}layout)

the sample is provided as samples/display/lvgl\sphinxhyphen{}posix


\section{Requirements}
\label{\detokenize{lvgl:requirements}}
The program has been modified to light up the background leds.

\sphinxstylestrong{TIP: matching label : DISPLAY}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Matching labels are necessary!
pinetime.conf:CONFIG\PYGZus{}LVGL\PYGZus{}DISPLAY\PYGZus{}DEV\PYGZus{}NAME=\PYGZdq{}DISPLAY\PYGZdq{}
pinetime.overlay:               label = \PYGZdq{}DISPLAY\PYGZdq{}; (spi definition)
\end{sphinxVerbatim}


\section{Building and Running}
\label{\detokenize{lvgl:building-and-running}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/lvgl}
\end{sphinxVerbatim}


\subsection{modifying the font size :}
\label{\detokenize{lvgl:modifying-the-font-size}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}t menuconfig}
\end{sphinxVerbatim}
\begin{description}
\item[{goto:}] \leavevmode\begin{itemize}
\item {} 
additional libraries

\item {} 
lvgl gui library

\end{itemize}

(look for fonts, and adapt according to your need)

\end{description}


\subsection{apply changes of the changed config:}
\label{\detokenize{lvgl:apply-changes-of-the-changed-config}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build}
\end{sphinxVerbatim}

(instead of west build \sphinxhyphen{}p (pristine) which wipes out your customisation)


\section{References}
\label{\detokenize{lvgl:references}}
\sphinxurl{https://docs.littlevgl.com/en/html/index.html}

LittlevGL Web Page: \sphinxurl{https://littlevgl.com/}


\chapter{LittlevGL Clock Sample}
\label{\detokenize{clock:littlevgl-clock-sample}}\label{\detokenize{clock:lvgl-clock}}\label{\detokenize{clock::doc}}
see : \DUrole{xref,std,std-ref}{clock\sphinxhyphen{}sample}


\section{Overview}
\label{\detokenize{clock:overview}}
This sample application displays a “clockbackground” in the center of the screen.

LittlevGL is a free and open\sphinxhyphen{}source graphics library providing everything you need to create embedded GUI with easy\sphinxhyphen{}to\sphinxhyphen{}use graphical elements, beautiful visual effects and low memory footprint.

\noindent\sphinxincludegraphics{{clockback}.png}


\section{Requirements}
\label{\detokenize{clock:requirements}}
Make sure the prj.conf contains the following :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CONFIG\PYGZus{}LVGL}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}LVGL\PYGZus{}OBJ\PYGZus{}IMAGE}\PYG{o}{=}\PYG{n}{y}
\end{sphinxVerbatim}

LitlevGL uses a “c” file to store the image.
You need to convert a jpg, or png image to this c file.
There is an online tool : \sphinxurl{https://littlevgl.com/image-to-c-array}


\section{Building and Running}
\label{\detokenize{clock:building-and-running}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/gui/clock}
\end{sphinxVerbatim}


\section{Todo}
\label{\detokenize{clock:todo}}\begin{itemize}
\item {} 
create an internal clock (and adjustment mechanism, eg. bluetooth cts)

\item {} 
lvgl supports lv\_canvas\_rotate(canvas, \&imd\_dsc, angle, x, y, pivot\_x, pivot\_y) should be cool for a clock, chrono…

\end{itemize}


\section{References}
\label{\detokenize{clock:references}}
\sphinxurl{https://docs.littlevgl.com/en/html/index.html}

LittlevGL Web Page: \sphinxurl{https://littlevgl.com/}


\chapter{Real Time Clock}
\label{\detokenize{RTC:real-time-clock}}\label{\detokenize{RTC:rtc}}\label{\detokenize{RTC::doc}}
originally I used the RTC2 timer to update the clock.

Now the time of programming is used to set the initial time.

An external library is used for time functions.

Current time service on Bluetooth is used to adjust the time.


\section{Overview}
\label{\detokenize{RTC:overview}}

\section{References}
\label{\detokenize{RTC:references}}

\chapter{Current Time Service}
\label{\detokenize{current-time:current-time-service}}\label{\detokenize{current-time::doc}}
\sphinxurl{https://www.bluetooth.com/specifications/gatt/services/}
\sphinxurl{https://www.bluetooth.com/specifications/gatt/characteristics/}
0x1805 current time service
0x2A2B current time characteristic


\section{Requirements:}
\label{\detokenize{current-time:requirements}}\begin{description}
\item[{You need :}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{a CTS server (use of bluez on linux explained)}] \leavevmode\begin{itemize}
\item {} 
start the CTS service (python script)

\item {} 
connect to the CTS client

\end{itemize}

\end{description}

\item {} 
a CTS client (the pinetime watch)

\end{itemize}

\end{description}


\section{BLE Peripheral CTS sample for zephyr}
\label{\detokenize{current-time:ble-peripheral-cts-sample-for-zephyr}}
This example demonstrates the basic usage of the current time service.
It is based on the \sphinxurl{https://github.com/Dejvino/pinetime-hermes-firmware}.
It starts advertising it’s UUID, and you can connect to it.
Once connected, it will read the time from your CTS server (bluez on linux running the gatt\sphinxhyphen{}cts\sphinxhyphen{}server script in my case)

first build the image

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}}  west build \PYGZhy{}p \PYGZhy{}b pinetime samples/bluetooth/peripheral\PYGZhy{}cts
\end{sphinxVerbatim}


\section{Using bluez on linux to connect}
\label{\detokenize{current-time:using-bluez-on-linux-to-connect}}\begin{description}
\item[{The pinetime zephyr sample behaves as a peripheral:}] \leavevmode\begin{itemize}
\item {} 
first of all start the cts service

\end{itemize}
\begin{quote}

\sphinxhyphen{}connect to the pinetime with bluetoothctl
\end{quote}

\end{description}

Using bluetoothctl:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}bluetoothctl
\PYG{g+gp}{[bluetooth]\PYGZsh{}}scan on


\PYG{g+go}{[NEW] Device 60:7C:9E:92:50:C1 Zephyr Peripheral Sample Long}
\PYG{g+go}{once you see your device}
\PYG{g+gp}{[blueooth]\PYGZsh{}}connect \PYG{l+m}{60}:7C:9E:92:50:C1 \PYG{o}{(}the device mac address as displayed\PYG{o}{)}
\end{sphinxVerbatim}


\section{Howto use Bluez on linux to set up a time service}
\label{\detokenize{current-time:howto-use-bluez-on-linux-to-set-up-a-time-service}}
Within the bluez source distribution there is an example GATT (Generic Attribute Profile)server. It advertises some standard service such as heart rate, battery …
Koen zandberg adapted this script, so it advertises the current time :
\sphinxurl{https://github.com/bosmoment/gatt-cts/blob/master/gatt-cts-server.py}

You might have to install extra packages:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{apt\PYGZhy{}get install python\PYGZhy{}dbus}
\PYG{g+go}{apt\PYGZhy{}get install python\PYGZhy{}gi}
\PYG{g+go}{apt\PYGZhy{}get install python\PYGZhy{}gobject}
\end{sphinxVerbatim}


\section{Howto use Android to set up a time service}
\label{\detokenize{current-time:howto-use-android-to-set-up-a-time-service}}
As soon as a device is bonded, Pinetime will look for a CTS server (Current Time Service) on the connected device.
Here is how to do it with an Android smartphone running NRFConnect:

Build and program the firmware on the Pinetime Install NRFConnect (\sphinxurl{https://www.nordicsemi.com/Software-and-Tools/Development-Tools/nRF-Connect-for-desktop})

Start NRFConnect and create a CTS server : Tap the hamburger button on the top left and select “Configure GATT server” Tap “Add service” on the bottom Select server configuration “Current Time Service” and tap OK Go back to the main screen and scan for BLE devices. A device called “PineTime” should appear Tap the button “Connect” next to the PineTime device. It should connect to the PineTime and switch to a new tab. On this tab, on the top right, there is a 3 dots button. Tap on it and select Bond. The bonding process begins, and if it is successful, the PineTime should update its time and display it on the screen.


\chapter{Drivers}
\label{\detokenize{drivers/drivers:drivers}}\label{\detokenize{drivers/drivers:id1}}\label{\detokenize{drivers/drivers::doc}}

\section{configuring I2C}
\label{\detokenize{drivers/i2c:configuring-i2c}}\label{\detokenize{drivers/i2c::doc}}

\subsection{board level definitions}
\label{\detokenize{drivers/i2c:board-level-definitions}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{under} \PYG{n}{boards}\PYG{o}{/}\PYG{n}{arm}\PYG{o}{/}\PYG{n}{pinetime} \PYG{n}{are} \PYG{n}{the} \PYG{n}{board} \PYG{n}{definitions}
\PYG{o}{\PYGZhy{}} \PYG{n}{pinetime}\PYG{o}{.}\PYG{n}{dts}
\PYG{o}{\PYGZhy{}} \PYG{n}{pinetime\PYGZus{}defconfig}


\PYG{n}{The} \PYG{n}{sensors} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{pinetime} \PYG{n}{use} \PYG{n}{the} \PYG{n}{I2C} \PYG{n}{bus}\PYG{o}{.}

\PYG{o}{\PYGZam{}}\PYG{n}{i2c1} \PYG{p}{\PYGZob{}}
        \PYG{n}{compatible} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nordic,nrf\PYGZhy{}twi}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{status} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{okay}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sda}\PYG{o}{\PYGZhy{}}\PYG{n}{pin} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{scl}\PYG{o}{\PYGZhy{}}\PYG{n}{pin} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{7}\PYG{o}{\PYGZgt{}}\PYG{p}{;}

      \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{definition on project level}
\label{\detokenize{drivers/i2c:definition-on-project-level}}
In the directory of a sample, you will find a prj.conf file.
Here you can set values specific for you project/sample.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{In} \PYG{n}{the} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{prj.conf}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{file} \PYG{n}{we} \PYG{n}{define} \PYG{n}{the} \PYG{n}{sensor} \PYG{p}{(}\PYG{n}{eg} \PYG{n}{adxl372}\PYG{p}{)}

\PYG{n}{CONFIG\PYGZus{}STDOUT\PYGZus{}CONSOLE}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}LOG}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}I2C}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}SENSOR}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}ADXL372}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}ADXL372\PYGZus{}I2C}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}SENSOR\PYGZus{}LOG\PYGZus{}LEVEL\PYGZus{}WRN}\PYG{o}{=}\PYG{n}{y}
\end{sphinxVerbatim}

\sphinxstylestrong{note: this gets somehow merged (overlayed) with the board definition pinetime\_defconfig}


\section{sensors on the I2C bus}
\label{\detokenize{drivers/sensors:sensors-on-the-i2c-bus}}\label{\detokenize{drivers/sensors::doc}}
0x18: Accelerometer: BMA423\sphinxhyphen{}DS000
\sphinxurl{https://github.com/BoschSensortec/BMA423-Sensor-API}

0x44: Heart Rate Sensor: HRS3300\_Heart

0x15: Touch Controller: Hynitron CST816S Touch Controller


\section{Bosch BMA421}
\label{\detokenize{drivers/bma421:bosch-bma421}}\label{\detokenize{drivers/bma421::doc}}
this driver does not exist, so it has been created.
Still work in progress ….

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/gui/lvaccel}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/bma421:overview}}
BMA421 is not a part number available to the general public, and therefore all the supporting documentation and design resources are neither discussed in public forums, nor disclosed on GitHub.

CHIP\_ID=0X11  (so the Bosch BMA423 drivers need to be adapted)

The Bosch documentation on the bma423 seems to apply to the bma421.


\subsection{Requirements}
\label{\detokenize{drivers/bma421:requirements}}
for this sensor does not exist any driver, so here’s what I did to create one under zephyr


\subsubsection{adapt CMakeLists.txt}
\label{\detokenize{drivers/bma421:adapt-cmakelists-txt}}
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/drivers/sensor
add\_subdirectory\_ifdef(CONFIG\_BMA280            bma280)
add\_subdirectory\_ifdef(CONFIG\_BMA421            bma421)


\subsubsection{adapt Kconfig}
\label{\detokenize{drivers/bma421:adapt-kconfig}}
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/drivers/sensor


\subsubsection{add yaml file}
\label{\detokenize{drivers/bma421:add-yaml-file}}
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/dts/bindings/sensor
cp bosch,bma280\sphinxhyphen{}i2c.yaml  bosch,bma421\sphinxhyphen{}i2c.yaml


\subsubsection{edit KConfig}
\label{\detokenize{drivers/bma421:edit-kconfig}}\begin{description}
\item[{source “drivers/sensor/bma280/Kconfig”}] \leavevmode
source “drivers/sensor/bma421/Kconfig”

\end{description}

source “drivers/sensor/bmc150\_magn/Kconfig”

source “drivers/sensor/bme280/Kconfig”


\subsubsection{create driver}
\label{\detokenize{drivers/bma421:create-driver}}
see under drivers/sensor/bma421

complement the pinetime.dts file with the following (under samples/sensor/bma280)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        bma421@18 \PYGZob{}}
\PYG{g+go}{                   compatible = \PYGZdq{}bosch,bma421\PYGZdq{};}
\PYG{g+go}{                   reg = \PYGZlt{}0x18\PYGZgt{};}
\PYG{g+go}{                   label = \PYGZdq{}BMA421\PYGZdq{};}
\PYG{g+go}{                   int1\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 8 0\PYGZgt{};}
\PYG{g+go}{                  \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}

Create a file: \sphinxtitleref{/dts/bindings/sensor/bosch,bma421\sphinxhyphen{}i2c.yaml}.
Which contains:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{compatible}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bosch,bma421}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{include}\PYG{p}{:} \PYG{n}{i2c}\PYG{o}{\PYGZhy{}}\PYG{n}{device}\PYG{o}{.}\PYG{n}{yaml}
\PYG{n}{properties}\PYG{p}{:}
       \PYG{n}{int1}\PYG{o}{\PYGZhy{}}\PYG{n}{gpios}\PYG{p}{:}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{phandle}\PYG{o}{\PYGZhy{}}\PYG{n}{array}
       \PYG{n}{required}\PYG{p}{:} \PYG{n}{false}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/bma421:building-and-running}}

\subsection{Todo}
\label{\detokenize{drivers/bma421:todo}}\begin{itemize}
\item {} 
the driver is interrupt driven as well \textendash{} need to test software

\item {} 
the sensor has algorithm for steps \textendash{} read out register

\item {} 
temperature some attempt has been made, but … (OK, temp can be read)

\end{itemize}


\subsection{References}
\label{\detokenize{drivers/bma421:references}}
Bosch has documented the BMA423 very well.
I kind of hope it will apply to the bma421.

A mechanism to adapt the 0x5E register is provided.
(burst read/write)

All kind of parameters can be set to trigger an interrupt.
(e.g. number of steps taken : think of the 10000 steps threshold)


\section{HYNITRON CST816S}
\label{\detokenize{drivers/cst816s:hynitron-cst816s}}\label{\detokenize{drivers/cst816s::doc}}
update on 5\sphinxhyphen{}1\sphinxhyphen{}2021:
Zephyr has evolved and now there is something that serve as a touchscreen device.

the board definition file has been adapted slightly, using the focaltech ft5336 as a touch\_controller. A minor change in this driver is enough to get data from the hynitron cst816S.

The big advantage : almost standard zephyr install!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime\PYGZus{}devkit0 samples/display/lvgl}
\end{sphinxVerbatim}

this driver does not exist, so it has been created.
Still work in progress ….

there is a sample in this repository which can be copied to the zephyr samples directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/sensor/cst816s}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/cst816s:overview}}
the Hynitron cst816s is a touchscreen.
Zephyr doesn’t handle touchscreens yet.
In order to investigate, the touchscreen driver has been created as a sensor.
In fact it senses your finger ;)


\subsection{Requirements}
\label{\detokenize{drivers/cst816s:requirements}}
for this sensor does not exist any driver, so here’s what I did to create one under zephyr

adapt CMakeLists.txt
adapt Kconfig
add yaml file


\subsubsection{create driver}
\label{\detokenize{drivers/cst816s:create-driver}}
The driver reads only one position.
Multitouch is possible, but the screen is small….

see under drivers/sensor/cst816s

have a look at the pinetime.dts (under board/arm/pinetime) file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        cst816s@15 \PYGZob{}}
\PYG{g+go}{                   compatible = \PYGZdq{}hynitron,cst816s\PYGZdq{};}
\PYG{g+go}{                   reg = \PYGZlt{}0x15\PYGZgt{};}
\PYG{g+go}{                   label = \PYGZdq{}CST816S\PYGZdq{};}
\PYG{g+go}{                   \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/cst816s:building-and-running}}\begin{description}
\item[{There are two samples :}] \leavevmode\begin{itemize}
\item {} 
samples/gui/lvtouch (graphical)

\item {} 
samples/sensor/cst816s (no graphics)

\end{itemize}

\end{description}


\subsection{Todo}
\label{\detokenize{drivers/cst816s:todo}}
The graphical sample doesn’t handle interrupts.


\subsection{References}
\label{\detokenize{drivers/cst816s:references}}
There is little available for this touchscreen.


\section{HX HRS3300}
\label{\detokenize{drivers/hrs3300:hx-hrs3300}}\label{\detokenize{drivers/hrs3300::doc}}
this driver does not exist, so it has been created.
Still work in progress ….

there is a sample in this repository which can be copied to the zephyr samples directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/sensor/hrs3300}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/hrs3300:overview}}
The HX HRS3300 sensor is a heart rate sensor, it produces 2 values: ALS and HRS. Ambient LIGHT SENSOR and HEART RATE SENSOR. Which have to be processed by an algorithm. I have no knowledge of a good open source algorithm yet.

I have used the settings of an arduino port of this library.

\noindent\sphinxincludegraphics{{hrs3300}.jpg}


\subsection{Requirements}
\label{\detokenize{drivers/hrs3300:requirements}}
for this sensor does not exist any driver, so here’s what I did to create one under zephyr


\subsubsection{adapt CMakeLists.txt}
\label{\detokenize{drivers/hrs3300:adapt-cmakelists-txt}}
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/drivers/sensor
add\_subdirectory\_ifdef(CONFIG\_HRS3300           hrs3300)


\subsubsection{adapt Kconfig}
\label{\detokenize{drivers/hrs3300:adapt-kconfig}}
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/drivers/sensor


\subsubsection{add yaml file}
\label{\detokenize{drivers/hrs3300:add-yaml-file}}
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/dts/bindings/sensor
add  hx,hrs3300.yaml


\subsubsection{edit KConfig}
\label{\detokenize{drivers/hrs3300:edit-kconfig}}
source “drivers/sensor/hrs3300/Kconfig”


\subsubsection{create driver}
\label{\detokenize{drivers/hrs3300:create-driver}}
see under drivers/sensor/hrs3300

complement the pinetime.dts file with the following (under samples/sensor/bma280)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        hrs3300@44 \PYGZob{}}
\PYG{g+go}{                   compatible = \PYGZdq{}hx,hrs3300\PYGZdq{};}
\PYG{g+go}{                   reg = \PYGZlt{}0x44\PYGZgt{};}
\PYG{g+go}{                   label = \PYGZdq{}HRS3300\PYGZdq{};}
\PYG{g+go}{                   \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}

Create a file: \sphinxtitleref{/dts/bindings/sensor/hx,hrs3300.yaml}.
Which contains:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{compatible}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hx,hrs3300}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{properties}\PYG{p}{:}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/hrs3300:building-and-running}}

\subsection{Todo}
\label{\detokenize{drivers/hrs3300:todo}}\begin{itemize}
\item {} 
algorithm for heartrate

\item {} 
power saving

\item {} 
switching off/on mechanism

\end{itemize}


\subsection{References}
\label{\detokenize{drivers/hrs3300:references}}
HRS3300 Heart Rate Sensor.pdf
\sphinxurl{https://github.com/atc1441/HRS3300-Arduino-Library}


\section{Serial Nor Flash}
\label{\detokenize{drivers/spinor:serial-nor-flash}}\label{\detokenize{drivers/spinor::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/spi\PYGZus{}flash \PYGZhy{}DCONF=prj.conf}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/spinor:overview}}
This sample application should unlock the serial nor flash memory.
This can be very usefull to store e.g. background for the watch.

compilation problematic ….

/root/zephyrproject/zephyr/samples/drivers/spi\_flash/src/main.c:17:22: error: ‘DT\_INST\_0\_JEDEC\_SPI\_NOR\_LABEL’ undeclared (first use in this function); did you mean ‘DT\_INST\_0\_NORDIC\_NRF\_RTC\_LABEL’?

Turns out this is some problem with the board definition file.

I found it to be very useful to consult the generated dts file.
Here you can check if everything is present.

Guess the dts\sphinxhyphen{}file has to be well intended.(structured)

{\color{red}\bfseries{}**}TIP: consult the generated dts board file **


\subsubsection{consulting the generated board definition file}
\label{\detokenize{drivers/spinor:consulting-the-generated-board-definition-file}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{vi /root/zephyrproject/zephyr/build/zephyr/include/generated/generated\PYGZus{}dts\PYGZus{}board.conf}
\end{sphinxVerbatim}


\subsection{Requirements}
\label{\detokenize{drivers/spinor:requirements}}
complement the pinetime.dts file with the following (under spi)
\#define JEDEC\_ID\_MACRONIX\_MX25L64      0xC22017

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}spi0 \PYGZob{}}
\PYG{g+go}{  compatible = \PYGZdq{}nordic,nrf\PYGZhy{}spi\PYGZdq{};}
\PYG{g+go}{  status = \PYGZdq{}okay\PYGZdq{};}
\PYG{g+go}{  sck\PYGZhy{}pin = \PYGZlt{}2\PYGZgt{};}
\PYG{g+go}{  mosi\PYGZhy{}pin = \PYGZlt{}3\PYGZgt{};}
\PYG{g+go}{  miso\PYGZhy{}pin = \PYGZlt{}4\PYGZgt{};}
\PYG{g+go}{  cs\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 27 0\PYGZgt{},\PYGZlt{}\PYGZam{}gpio0 5 0\PYGZgt{};}
\PYG{g+go}{  st7789v@0 \PYGZob{}}
\PYG{g+go}{          compatible = \PYGZdq{}sitronix,st7789v\PYGZdq{};}
\PYG{g+go}{          label = \PYGZdq{}DISPLAY\PYGZdq{};}
\PYG{g+go}{          spi\PYGZhy{}max\PYGZhy{}frequency = \PYGZlt{}8000000\PYGZgt{};}
\PYG{g+go}{          reg = \PYGZlt{}0\PYGZgt{};}
\PYG{g+go}{          cmd\PYGZhy{}data\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 18 0\PYGZgt{};}
\PYG{g+go}{          reset\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 26 0\PYGZgt{};}
\PYG{g+go}{          width = \PYGZlt{}240\PYGZgt{};}
\PYG{g+go}{          height = \PYGZlt{}240\PYGZgt{};}
\PYG{g+go}{          x\PYGZhy{}offset = \PYGZlt{}0\PYGZgt{};}
\PYG{g+go}{          y\PYGZhy{}offset = \PYGZlt{}0\PYGZgt{};}
\PYG{g+go}{          vcom = \PYGZlt{}0x19\PYGZgt{};}
\PYG{g+go}{          gctrl = \PYGZlt{}0x35\PYGZgt{};}
\PYG{g+go}{          vrhs = \PYGZlt{}0x12\PYGZgt{};}
\PYG{g+go}{          vdvs = \PYGZlt{}0x20\PYGZgt{};}
\PYG{g+go}{          mdac = \PYGZlt{}0x00\PYGZgt{};}
\PYG{g+go}{          gamma = \PYGZlt{}0x01\PYGZgt{};}
\PYG{g+go}{          colmod = \PYGZlt{}0x05\PYGZgt{};}
\PYG{g+go}{          lcm = \PYGZlt{}0x2c\PYGZgt{};}
\PYG{g+go}{          porch\PYGZhy{}param = [0c 0c 00 33 33];}
\PYG{g+go}{          cmd2en\PYGZhy{}param = [5a 69 02 01];}
\PYG{g+go}{          pwctrl1\PYGZhy{}param = [a4 a1];}
\PYG{g+go}{          pvgam\PYGZhy{}param = [D0 04 0D 11 13 2B 3F 54 4C 18 0D 0B 1F 23];}
\PYG{g+go}{          nvgam\PYGZhy{}param = [D0 04 0C 11 13 2C 3F 44 51 2F 1F 1F 20 23];}
\PYG{g+go}{          ram\PYGZhy{}param = [00 F0];}
\PYG{g+go}{          rgb\PYGZhy{}param = [CD 08 14];}

\PYG{g+go}{  \PYGZcb{};}

\PYG{g+go}{  mx25r64: mx25r6435f@1 \PYGZob{}}
\PYG{g+go}{          compatible = \PYGZdq{}jedec,spi\PYGZhy{}nor\PYGZdq{};}
\PYG{g+go}{          reg = \PYGZlt{}1\PYGZgt{};}
\PYG{g+go}{          spi\PYGZhy{}max\PYGZhy{}frequency = \PYGZlt{}1000000\PYGZgt{};}
\PYG{g+go}{          label = \PYGZdq{}MX25R64\PYGZdq{};}
\PYG{g+go}{          jedec\PYGZhy{}id = [0b 40 16];}
\PYG{g+go}{          size = \PYGZlt{}67108864\PYGZgt{};}
\PYG{g+go}{          has\PYGZhy{}be32k;}
\PYG{g+go}{  \PYGZcb{};}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/spinor:building-and-running}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/spi\PYGZus{}flash}
\end{sphinxVerbatim}


\subsection{Todo}
\label{\detokenize{drivers/spinor:todo}}\begin{quote}
\begin{itemize}
\item {} 
detect ID memory  : it is not the macronix one as suggestion on the pinetime website

\end{itemize}

I found the following : jedec\sphinxhyphen{}id = {[}0b 40 16{]}; (OK: can execute sample program)
\begin{itemize}
\item {} 
create working board definition (OK: see above)

\end{itemize}
\end{quote}


\subsection{References}
\label{\detokenize{drivers/spinor:references}}
\sphinxurl{http://files.pine64.org/doc/datasheet/pinetime/MX25L6433F,\%203V,\%2064Mb,\%20v1.6.pdf}


\section{Battery}
\label{\detokenize{drivers/battery:battery}}\label{\detokenize{drivers/battery::doc}}
the samples just gets an analog reading from the battery

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/sensor/battery}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/battery:overview}}
The battery level is measured on port 31, trough an ADC conversion.

voltage = (value * 6)/1024
percentage remaining  ((voltage \sphinxhyphen{} 3.55)*100)*3.9;

A module should be able to report battery status in millivolts and charge level in percentage. Additionally, it should notify when external power is connected and when battery is being charged.
Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
Battery voltage can be in range from 3.0V \sphinxhyphen{} 4.2V (?). Unfortunately, internal reference (0.6V) can only be used for voltages up to 3.6V (due to minimal gain of 1/6). VDD/4 reference can be used with 1/6 gain to measure voltages up to 4.95V. Test is needed to check how accurate is VDD as reference.
Discharge curve (\sphinxurl{https://forum.pine64.org/showthread.php?tid=8147}) will be used to calculate charge level in percent.
Things to consider:
saadc periodical calibration (spec suggests calibration if temperature changes by 10’C)
inaccuracy of results: oversampling? never report higher level than before (if charge not connected), etc.


\subsection{Todo}
\label{\detokenize{drivers/battery:todo}}
check pin when charging


\subsection{References}
\label{\detokenize{drivers/battery:references}}
\sphinxurl{https://forum.pine64.org/showthread.php?tid=8147}


\section{Watchdog}
\label{\detokenize{drivers/watchdog:watchdog}}\label{\detokenize{drivers/watchdog::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/watchdog}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/watchdog:overview}}
Once the pinetime is closed and on your wrist, you still want access.

see : {\hyperref[\detokenize{fota/fota:fota}]{\sphinxcrossref{\DUrole{std,std-ref}{Firmware Over The Air (FOTA)}}}}

Suppose you upload a application which contains a bug, the watch freezes, and … you will have to open it up, connect the SWD …

Here comes the watchdog:
\begin{itemize}
\item {} 
you launch the watchdog

\item {} 
you launch the application

\item {} 
the application feeds the watchdog

\item {} 
if it cannot feed the watchdog, reset to fota, and you can upload another better version …

\end{itemize}


\subsection{Todo}
\label{\detokenize{drivers/watchdog:todo}}
testing


\subsection{References}
\label{\detokenize{drivers/watchdog:references}}

\chapter{Firmware Over The Air (FOTA)}
\label{\detokenize{fota/fota:firmware-over-the-air-fota}}\label{\detokenize{fota/fota:fota}}\label{\detokenize{fota/fota::doc}}

\section{Wireless Device Firmware Upgrade}
\label{\detokenize{fota/mcuboot:wireless-device-firmware-upgrade}}\label{\detokenize{fota/mcuboot:mcuboot}}\label{\detokenize{fota/mcuboot::doc}}

\subsection{Overview}
\label{\detokenize{fota/mcuboot:overview}}
In order to perform a FOTA (firmware over the air) update on zephyr you need 2 basic components:
\begin{itemize}
\item {} 
MCUboot   (a bootloader)

\item {} 
SMP Server (a bluetooth service)

\end{itemize}


\section{MCUboot with zephyr}
\label{\detokenize{fota/mcuboot:mcuboot-with-zephyr}}\label{\detokenize{fota/mcuboot:id1}}
Clone MCUBOOT for zephyr from github.
Install additional packages required for development with mcuboot:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{o}{\PYGZti{}}\PYG{o}{/}\PYG{n}{mcuboot}  \PYG{c+c1}{\PYGZsh{} or to your directory where mcuboot is cloned}
\PYG{n}{pip3} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{user} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{n}{scripts}\PYG{o}{/}\PYG{n}{requirements}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}

To build MCUboot, create a build directory in boot/zephyr, and build
it as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{boot}\PYG{o}{/}\PYG{n}{zephyr}
\PYG{n}{mkdir} \PYG{n}{build} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{GNinja} \PYG{o}{\PYGZhy{}}\PYG{n}{DBOARD}\PYG{o}{=}\PYG{n}{pinetime} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{ninja}
\end{sphinxVerbatim}

After building the bootloader, the binaries should reside in
\sphinxtitleref{build/zephyr/zephyr.\{bin,hex,elf\}}.

This image can be flashed as a normal application.

Some additional configuration is required to build applications for MCUboot.

This is handled internally by the Zephyr configuration system and is wrapped
in the \sphinxtitleref{CONFIG\_BOOTLOADER\_MCUBOOT} Kconfig variable, which must be enabled in
the application’s \sphinxtitleref{prj.conf} file.

The Zephyr \sphinxtitleref{CONFIG\_BOOTLOADER\_MCUBOOT} configuration option
{[}documentation{]}(\sphinxurl{http://docs.zephyrproject.org/reference/kconfig/CONFIG\_BOOTLOADER\_MCUBOOT.html})
provides additional details regarding the changes it makes to the image
placement and generation in order for an application to be bootable by
MCUboot.

In order to upgrade to an image (or even boot it, if
\sphinxtitleref{MCUBOOT\_VALIDATE\_PRIMARY\_SLOT} is enabled), the images must be signed.

To make development easier, MCUboot is distributed with some example
keys.  It is important to stress that these should never be used for
production, since the private key is publicly available in this
repository.  See below on how to make your own signatures.

Images can be signed with the \sphinxtitleref{scripts/imgtool.py} script.  It is best
to look at \sphinxtitleref{samples/zephyr/Makefile} for examples on how to use this.

Since the bootloader is already in place, you cannot flash your application.bin to 0x00000.

Eg. in openocd : program application.bin 0x0c000. (which corresponds to the flash layout of slot 0)

These images can also be marked for upgrade, and loaded into the secondary slot,
at which point the bootloader should perform an upgrade.


\section{Partitions}
\label{\detokenize{fota/partitions:partitions}}\label{\detokenize{fota/partitions:signing}}\label{\detokenize{fota/partitions::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{have a look at boards/arm/pinetime/pinetime.dts}
\end{sphinxVerbatim}


\subsection{Defining partitions for MCUboot}
\label{\detokenize{fota/partitions:defining-partitions-for-mcuboot}}
The first step required for Zephyr is making sure your board has flash
partitions defined in its device tree. These partitions are:
\begin{itemize}
\item {} 
\sphinxtitleref{boot\_partition}: for MCUboot itself

\item {} 
\sphinxtitleref{image\_0\_primary\_partition}: the primary slot of Image 0

\item {} 
\sphinxtitleref{image\_0\_secondary\_partition}: the secondary slot of Image 0

\item {} 
\sphinxtitleref{scratch\_partition}: the scratch slot

\end{itemize}

The flash partitions are defined in the pinetime boards folder, in a
file named \sphinxtitleref{boards/arm/pinetime/pinetime.dts}.


\subsection{Using NOR flash in partitions}
\label{\detokenize{fota/partitions:using-nor-flash-in-partitions}}
The flash space on the Nordic nrf52 is 512K.
Basically with the partitioning you end up with less space for your program.

As the pinetime has an extra spi nor flash chip, we can use this.

The flash\sphinxhyphen{}layout can be modified so as 1 chunk is on system flash and 1 chunk is on SPI NOR flash.
This way the space for your firmware remains almost the same.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{chosen \PYGZob{}}
\PYG{g+go}{        zephyr,flash = \PYGZam{}flash0;}
\PYG{g+go}{        //zephyr,flash = \PYGZam{}flash1;}
\PYG{g+go}{        zephyr,code\PYGZhy{}partition = \PYGZam{}slot0\PYGZus{}partition;}
\PYG{g+go}{\PYGZcb{};}


\PYG{g+go}{Rename the SPI JEDEC NOR Flash definition to : flash1}

\PYG{g+go}{flash1: mx25r6435f@1 \PYGZob{}}
\PYG{g+go}{        compatible = \PYGZdq{}jedec,spi\PYGZhy{}nor\PYGZdq{};}
\PYG{g+go}{        reg = \PYGZlt{}1\PYGZgt{};}
\PYG{g+go}{        spi\PYGZhy{}max\PYGZhy{}frequency = \PYGZlt{}80000000\PYGZgt{};}
\PYG{g+go}{        label = \PYGZdq{}MX25R64\PYGZdq{};}
\PYG{g+go}{        jedec\PYGZhy{}id = [0b 40 16];}
\PYG{g+go}{        size = \PYGZlt{}67108864\PYGZgt{};}
\PYG{g+go}{        has\PYGZhy{}be32k;}
\PYG{g+go}{        erase\PYGZhy{}block\PYGZhy{}size = \PYGZlt{}4096\PYGZgt{};}
\PYG{g+go}{        write\PYGZhy{}block\PYGZhy{}size = \PYGZlt{}4\PYGZgt{};}
\PYG{g+go}{\PYGZcb{};}




\PYG{g+go}{ \PYGZam{}flash0 \PYGZob{}}
\PYG{g+go}{        /*}
\PYG{g+go}{         * For more information, see:}
\PYG{g+go}{         * http://docs.zephyrproject.org/latest/guides/dts/index.html\PYGZsh{}flash\PYGZhy{}partitions}
\PYG{g+go}{         */}
\PYG{g+go}{        partitions \PYGZob{}}
\PYG{g+go}{                compatible = \PYGZdq{}fixed\PYGZhy{}partitions\PYGZdq{};}
\PYG{g+gp}{                \PYGZsh{}}address\PYGZhy{}cells \PYG{o}{=} \PYGZlt{}\PYG{l+m}{1}\PYGZgt{}\PYG{p}{;}
\PYG{g+gp}{                \PYGZsh{}}size\PYGZhy{}cells \PYG{o}{=} \PYGZlt{}\PYG{l+m}{1}\PYGZgt{}\PYG{p}{;}

\PYG{g+go}{                boot\PYGZus{}partition: partition@0 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}mcuboot\PYGZdq{};}
\PYG{g+go}{                        reg = \PYGZlt{}0x00000000 0xc000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}
\PYG{g+go}{                slot0\PYGZus{}partition: partition@c000 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}image\PYGZhy{}0\PYGZdq{};}

\PYG{g+go}{                change the size of partition 0 from 0x32000 to 0x64000}

\PYG{g+go}{                        reg = \PYGZlt{}0x0000C000 0x64000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}

\PYG{g+go}{                move slot1 partition to \PYGZam{}flash1}

\PYG{g+go}{                //slot1\PYGZus{}partition: partition@3e000 \PYGZob{}}
\PYG{g+go}{                //      label = \PYGZdq{}image\PYGZhy{}1\PYGZdq{};}
\PYG{g+go}{                //      reg = \PYGZlt{}0x0003e000 0x32000\PYGZgt{};}
\PYG{g+go}{                //\PYGZcb{};}
\PYG{g+go}{                scratch\PYGZus{}partition: partition@70000 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}image\PYGZhy{}scratch\PYGZdq{};}
\PYG{g+go}{                        reg = \PYGZlt{}0x00070000 0xa000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}
\PYG{g+go}{                storage\PYGZus{}partition: partition@7a000 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}storage\PYGZdq{};}
\PYG{g+go}{                        reg = \PYGZlt{}0x0007a000 0x00006000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}
\PYG{g+go}{        \PYGZcb{};}
\PYG{g+go}{ \PYGZcb{};}

\PYG{g+go}{ \PYGZam{}flash1 \PYGZob{}}
\PYG{g+go}{        partitions \PYGZob{}}
\PYG{g+go}{                compatible = \PYGZdq{}fixed\PYGZhy{}partitions\PYGZdq{};}
\PYG{g+gp}{                \PYGZsh{}}address\PYGZhy{}cells \PYG{o}{=} \PYGZlt{}\PYG{l+m}{1}\PYGZgt{}\PYG{p}{;}
\PYG{g+gp}{                \PYGZsh{}}size\PYGZhy{}cells \PYG{o}{=} \PYGZlt{}\PYG{l+m}{1}\PYGZgt{}\PYG{p}{;}
\PYG{g+go}{                slot1\PYGZus{}partition: partition@3e000 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}image\PYGZhy{}1\PYGZdq{};}
\PYG{g+go}{                        reg = \PYGZlt{}0x00000000 0x64000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}
\PYG{g+go}{        \PYGZcb{};}
\PYG{g+go}{ \PYGZcb{};}
\end{sphinxVerbatim}


\section{Signing an application}
\label{\detokenize{fota/signing:signing-an-application}}\label{\detokenize{fota/signing:signing}}\label{\detokenize{fota/signing::doc}}
In order to improve the security, only signed images can be uploaded.

There is a public and private key.
The Bootloader is compiled with the public key.
Each time you want to upload firmware, you have to sign it with a private key.

\sphinxstylestrong{NOTE: it is important to keep the private key hidden}


\subsection{Generating a new keypair}
\label{\detokenize{fota/signing:generating-a-new-keypair}}
Generating a keypair with imgtool is a matter of running the keygen
subcommand:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} ./scripts/imgtool.py keygen \PYGZhy{}k mykey.pem \PYGZhy{}t rsa\PYGZhy{}2048
\end{sphinxVerbatim}


\subsection{Extracting the public key}
\label{\detokenize{fota/signing:extracting-the-public-key}}
The generated keypair above contains both the public and the private
key.  It is necessary to extract the public key and insert it into the
bootloader.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} ./scripts/imgtool.py getpub \PYGZhy{}k mykey.pem
\end{sphinxVerbatim}

This will output the public key as a C array that can be dropped
directly into the \sphinxtitleref{keys.c} file.


\subsection{Example}
\label{\detokenize{fota/signing:example}}
sign the compiled zephyr.bin firmware with the root\sphinxhyphen{}rsa\sphinxhyphen{}2048.pem, private key:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{imgtool.py sign \PYGZhy{}\PYGZhy{}key ../../root\PYGZhy{}rsa\PYGZhy{}2048.pem \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}header\PYGZhy{}size 0x200 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}align 8 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}version 1.2 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}slot\PYGZhy{}size 0x60000 \PYGZbs{}}
\PYG{g+go}{    ../mcuboot/samples/zephyr/build/ds\PYGZus{}d6/hello1/zephyr/zephyr.bin \PYGZbs{}}
\PYG{g+go}{    signed\PYGZhy{}hello1.bin}
\end{sphinxVerbatim}


\section{SMP Server Sample}
\label{\detokenize{fota/smp_svr:smp-server-sample}}\label{\detokenize{fota/smp_svr:smp-svr-sample}}\label{\detokenize{fota/smp_svr::doc}}

\subsection{Overview}
\label{\detokenize{fota/smp_svr:overview}}
This sample application implements a Simple Management Protocol (SMP) server.
SMP is a basic transfer encoding for use with the MCUmgr management protocol.

This sample application supports the following mcumgr transports by default:
\begin{itemize}
\item {} 
Shell

\item {} 
Bluetooth

\end{itemize}


\subsection{Requirements}
\label{\detokenize{fota/smp_svr:requirements}}
In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.

Here is a procedure to install mcumgr on a raspberry pi  (or similar)

It is written in the go\sphinxhyphen{}language. You need to adapt the path :   PATH=\$PATH:/root/go/bin.


\subsection{Building and Running}
\label{\detokenize{fota/smp_svr:building-and-running}}
The sample will let you manage the pinetime over bluetooth. (via SMP protocol)

There are slot0 and slot1 which can both contain firmware.

Suppose you switch from slot0 to slot1, you still want to be able to communicate.

So both slots need smp\_svr software!


\subsubsection{Step 1: Build smp\_svr}
\label{\detokenize{fota/smp_svr:step-1-build-smp-svr}}
\sphinxcode{\sphinxupquote{smp\_svr}} can be built for the nRF52 as follows:

\sphinxstylestrong{NOTE: to perform a firmware update over the air, you have to build a second sample}


\subsubsection{Step 2: Sign the image}
\label{\detokenize{fota/smp_svr:step-2-sign-the-image}}
Using MCUboot’s \sphinxcode{\sphinxupquote{imgtool.py}} script, sign the \sphinxcode{\sphinxupquote{zephyr.(bin|hex)}}
file you built in Step 3. In the below example, the MCUboot repo is located at
\sphinxcode{\sphinxupquote{\textasciitilde{}/src/mcuboot}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/src/mcuboot/scripts/imgtool.py sign \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}key \PYGZti{}/src/mcuboot/root\PYGZhy{}rsa\PYGZhy{}2048.pem \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}header\PYGZhy{}size 0x200 \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}align 8 \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}version 1.0 \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}slot\PYGZhy{}size \PYGZlt{}image\PYGZhy{}slot\PYGZhy{}size\PYGZgt{} \PYGZbs{}}
\PYG{g+go}{     \PYGZlt{}path\PYGZhy{}to\PYGZhy{}zephyr.(bin|hex)\PYGZgt{} signed.(bin|hex)}
\end{sphinxVerbatim}

The above command creates an image file called \sphinxcode{\sphinxupquote{signed.(bin|hex)}} in the
current directory.


\subsubsection{Step 3: Flash the smp\_svr image}
\label{\detokenize{fota/smp_svr:step-3-flash-the-smp-svr-image}}
Upload the bin\sphinxhyphen{}file from Step 2 to image slot\sphinxhyphen{}0.
For the pinetime, slot\sphinxhyphen{}0 is located at address \sphinxcode{\sphinxupquote{0xc000}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{in openocd : program zephyr.bin 0xc000}
\end{sphinxVerbatim}


\subsubsection{Step 4: Run it!}
\label{\detokenize{fota/smp_svr:step-4-run-it}}
\begin{sphinxadmonition}{note}{Note:}
If you haven’t installed \sphinxcode{\sphinxupquote{mcumgr}} yet, then do so by following the
instructions in the \DUrole{xref,std,std-ref}{mcumgr\_cli} section of the Management subsystem
documentation.
\end{sphinxadmonition}

The \sphinxcode{\sphinxupquote{smp\_svr}} app is ready to run.  Just reset your board and test the app
with the \sphinxcode{\sphinxupquote{mcumgr}} command\sphinxhyphen{}line tool’s \sphinxcode{\sphinxupquote{echo}} functionality, which will
send a string to the remote target device and have it echo it back:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} echo hello}
\PYG{g+go}{hello}
\end{sphinxVerbatim}


\subsubsection{Step 5: Device Firmware Upgrade}
\label{\detokenize{fota/smp_svr:step-5-device-firmware-upgrade}}
Now that the SMP server is running on your pinetime, you are able to communicate
with it using \sphinxtitleref{mcumgr}.

You might want to test “OTA DFU”, or Over\sphinxhyphen{}The\sphinxhyphen{}Air Device Firmware Upgrade.

To do this, build a second sample (following the steps below) to verify
it is sent over the air and properly flashed into slot\sphinxhyphen{}1, and then
swapped into slot\sphinxhyphen{}0 by MCUboot.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{*} \PYG{n}{Build} \PYG{n}{a} \PYG{n}{second} \PYG{n}{sample}
\PYG{o}{*} \PYG{n}{Sign} \PYG{n}{the} \PYG{n}{second} \PYG{n}{sample}
\PYG{o}{*} \PYG{n}{Upload} \PYG{n}{the} \PYG{n}{image} \PYG{n}{over} \PYG{n}{BLE}
\end{sphinxVerbatim}

Now we are ready to send or upload the image over BLE to the target remote
device.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} image upload signed.bin}
\end{sphinxVerbatim}

If all goes well the image will now be stored in slot\sphinxhyphen{}1, ready to be swapped
into slot\sphinxhyphen{}0 and executed.

\begin{sphinxadmonition}{note}{Note:}
At the beginning of the upload process, the target might start erasing
the image slot, taking several dozen seconds for some targets.  This might
cause an NMP timeout in the management protocol tool. Use the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}t \textless{}timeout\sphinxhyphen{}in\sphinxhyphen{}seconds}} option to increase the response timeout for the
\sphinxcode{\sphinxupquote{mcumgr}} command line tool if this occurs.
\end{sphinxadmonition}


\paragraph{List the images}
\label{\detokenize{fota/smp_svr:list-the-images}}
We can now obtain a list of images (slot\sphinxhyphen{}0 and slot\sphinxhyphen{}1) present in the remote
target device by issuing the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} image list}
\end{sphinxVerbatim}

This should print the status and hash values of each of the images present.


\paragraph{Test the image}
\label{\detokenize{fota/smp_svr:test-the-image}}
In order to instruct MCUboot to swap the images we need to test the image first,
making sure it boots:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} image test \PYGZlt{}hash of slot\PYGZhy{}1 image\PYGZgt{}}
\end{sphinxVerbatim}

Now MCUBoot will swap the image on the next reset.


\paragraph{Reset remotely}
\label{\detokenize{fota/smp_svr:reset-remotely}}
We can reset the device remotely to observe (use the console output) how
MCUboot swaps the images:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} reset}
\end{sphinxVerbatim}

Upon reset MCUboot will swap slot\sphinxhyphen{}0 and slot\sphinxhyphen{}1.

You can confirm the new image and make the swap permanent by using this command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} image confirm}
\end{sphinxVerbatim}

\sphinxstylestrong{Note} that if you try to send the very same image that is already flashed in
slot\sphinxhyphen{}0 then the procedure will not complete successfully since the hash values
for both slots will be identical.
\begin{quote}
\end{quote}


\chapter{Samples}
\label{\detokenize{samples/index:samples}}\label{\detokenize{samples/index:id1}}\label{\detokenize{samples/index::doc}}

\section{OSWatch Framework}
\label{\detokenize{samples/oswatch-btREADME:oswatch-framework}}\label{\detokenize{samples/oswatch-btREADME:oswatch}}\label{\detokenize{samples/oswatch-btREADME::doc}}

\subsection{Overview}
\label{\detokenize{samples/oswatch-btREADME:overview}}
This is an opensource watch framework.
The same software can run in simulation (SDL) on linux, on pinetime and on the ds\_d6 oled watch.


\subsection{Requirements}
\label{\detokenize{samples/oswatch-btREADME:requirements}}
no requirements since it run without board (simulation)


\subsection{Building and Running}
\label{\detokenize{samples/oswatch-btREADME:building-and-running}}
west build \sphinxhyphen{}p \sphinxhyphen{}b  native\sphinxhyphen{}posix\_64 oswatch


\subsection{References}
\label{\detokenize{samples/oswatch-btREADME:references}}

\section{OSWatch Framework}
\label{\detokenize{samples/oswatchREADME:oswatch-framework}}\label{\detokenize{samples/oswatchREADME:oswatch}}\label{\detokenize{samples/oswatchREADME::doc}}

\subsection{Overview}
\label{\detokenize{samples/oswatchREADME:overview}}
This is an opensource watch framework.
The same software can run in simulation (SDL) on linux, on pinetime and on the ds\_d6 oled watch.


\subsection{Requirements}
\label{\detokenize{samples/oswatchREADME:requirements}}
no requirements since it run without board (simulation)


\subsection{Building and Running}
\label{\detokenize{samples/oswatchREADME:building-and-running}}
west build \sphinxhyphen{}p \sphinxhyphen{}b  native\sphinxhyphen{}posix\_64 oswatch


\subsection{References}
\label{\detokenize{samples/oswatchREADME:references}}

\section{HRS3300 Heart Rate Sensor}
\label{\detokenize{samples/README:hrs3300-heart-rate-sensor}}\label{\detokenize{samples/README:hrs3300}}\label{\detokenize{samples/README::doc}}

\subsection{Overview}
\label{\detokenize{samples/README:overview}}
A sensor application that demonstrates how to poll data from the hrs3300 heart
rate sensor.


\subsection{Building and Running}
\label{\detokenize{samples/README:building-and-running}}
This project configures the hrs3300 sensor on the \DUrole{xref,std,std-ref}{pinetime\_devkit1} board to
enable the green LED and measure the reflected light with a photodiode. The raw
ADC data prints to the console. Further processing (not included in this
sample) is required to extract a heart rate signal from the light measurement.


\subsubsection{Sample Output}
\label{\detokenize{samples/README:sample-output}}
for this you will need a Segger JLink Console

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{rtt:\PYGZti{}\PYGZdl{}} sensor get HRS3300 \PYG{l+m}{18} \PYG{o}{(}ir \PYGZhy{}\PYGZhy{} this switches off the sensor\PYG{o}{)}
\PYG{g+gp}{rtt:\PYGZti{}\PYGZdl{}} sensor get HRS3300 \PYG{l+m}{19} \PYG{o}{(}red \PYGZhy{}\PYGZhy{} this switches on the sensor\PYG{o}{)}
\PYG{g+gp}{rtt:\PYGZti{}\PYGZdl{}} sensor get HRS3300 \PYG{l+m}{20} \PYG{o}{(}green \PYGZhy{}\PYGZhy{} get a value\PYG{o}{)}
\end{sphinxVerbatim}


\section{Character frame buffer}
\label{\detokenize{samples/samplescfbREADME:character-frame-buffer}}\label{\detokenize{samples/samplescfbREADME:character-frame-buffer-sample}}\label{\detokenize{samples/samplescfbREADME::doc}}

\subsection{Overview}
\label{\detokenize{samples/samplescfbREADME:overview}}
This sample displays character strings using the Character Frame Buffer
(CFB) subsystem framework.


\subsection{Building and Running}
\label{\detokenize{samples/samplescfbREADME:building-and-running}}
build the application: west build \sphinxhyphen{}p \sphinxhyphen{}b ds\_d6 samples/cfb

on unix : \#minicom \sphinxhyphen{}b 115200 \sphinxhyphen{}D /dev/ttyACM1

you get a shell and you can type help

to display something on the screen :
cfb init
cfb invert
cfb print 0 0 “hello world”


\subsection{POSIX}
\label{\detokenize{samples/samplescfbREADME:posix}}
west build \sphinxhyphen{}p \sphinxhyphen{}b native\_posix\_64 samles/cfb

connect to serial port :
minicom \sphinxhyphen{}D /dev/pts/1


\subsection{Pinetime}
\label{\detokenize{samples/samplescfbREADME:pinetime}}
Problem : does not display a thing ….


\section{Character Framebuffer Shell Module Sample}
\label{\detokenize{samples/samplescfb_shellREADME:character-framebuffer-shell-module-sample}}\label{\detokenize{samples/samplescfb_shellREADME:cfb-shell-sample}}\label{\detokenize{samples/samplescfb_shellREADME::doc}}

\subsection{Overview}
\label{\detokenize{samples/samplescfb_shellREADME:overview}}
This is a simple shell module that exercises displays using the Character
Framebuffer subsystem.


\subsection{Building and Running}
\label{\detokenize{samples/samplescfb_shellREADME:building-and-running}}
Build the sample app by choosing the target board, for example:


\subsubsection{Shell Module Command Help}
\label{\detokenize{samples/samplescfb_shellREADME:shell-module-command-help}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{cfb \PYGZhy{} Character Framebuffer shell commands}
\PYG{g+go}{Options:}
\PYG{g+go}{        \PYGZhy{}h, \PYGZhy{}\PYGZhy{}help  :Show command help.}
\PYG{g+go}{Subcommands:}
\PYG{g+go}{        init        :[none]}
\PYG{g+go}{        get\PYGZus{}device  :[none]}
\PYG{g+go}{        get\PYGZus{}param   :\PYGZlt{}all, height, width, ppt, rows, cols\PYGZgt{}}
\PYG{g+go}{        get\PYGZus{}fonts   :[none]}
\PYG{g+go}{        set\PYGZus{}font    :\PYGZlt{}idx\PYGZgt{}}
\PYG{g+go}{        invert      :[none]}
\PYG{g+go}{        print       :\PYGZlt{}col: pos\PYGZgt{} \PYGZlt{}row: pos\PYGZgt{} \PYGZlt{}text\PYGZgt{}}
\PYG{g+go}{        scroll      :\PYGZlt{}dir: (vertical|horizontal)\PYGZgt{} \PYGZlt{}col: pos\PYGZgt{} \PYGZlt{}row: pos\PYGZgt{}}
\PYG{g+go}{                     \PYGZlt{}text\PYGZgt{}}
\PYG{g+go}{        clear       :[none]}
\end{sphinxVerbatim}

\sphinxstylestrong{init}: should be called first to initialize the display.

Command example (reel\_board):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{uart:\PYGZti{}\PYGZdl{}} cfb init
\PYG{g+go}{Framebuffer initialized: SSD16XX}
\PYG{g+go}{Display Cleared}
\end{sphinxVerbatim}

\sphinxstylestrong{get\_device}: prints the display device name.

Command example (reel\_board):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{uart:\PYGZti{}\PYGZdl{}} cfb get\PYGZus{}device
\PYG{g+go}{Framebuffer Device: SSD16XX}
\end{sphinxVerbatim}

\sphinxstylestrong{get\_param}: get the display parameters where height, width and ppt
(pixel per tile) are in pixels and the number of rows and columns. The row
position is incremented by a multiple of the ppt.

Command example (reel\_board):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{uart:\PYGZti{}\PYGZdl{}} cfb get\PYGZus{}param all
\PYG{g+go}{param: height=120}
\PYG{g+go}{param: width=250}
\PYG{g+go}{param: ppt=8}
\PYG{g+go}{param: rows=15}
\PYG{g+go}{param: cols=250}
\end{sphinxVerbatim}

\sphinxstylestrong{get\_fonts}: print the index, height and width in pixels of the static
defined fonts presented in the system.

Command example (reel\_board):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{uart:\PYGZti{}\PYGZdl{}} cfb get\PYGZus{}fonts
\PYG{g+go}{idx=0 height=32 width=20}
\PYG{g+go}{idx=1 height=24 width=15}
\PYG{g+go}{idx=2 height=16 width=10}
\end{sphinxVerbatim}

\sphinxstylestrong{set\_font}: choose the font to be used by passing the font index. Only one
font can be used at a time.

Command example (reel\_board):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{uart:\PYGZti{}\PYGZdl{}} cfb set\PYGZus{}font \PYG{l+m}{0}
\PYG{g+go}{Font idx=0 height=32 widht=20 set}
\end{sphinxVerbatim}

\sphinxstylestrong{invert}: invert the pixel color of the display.

Command example (reel\_board):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{uart:\PYGZti{}\PYGZdl{}} cfb invert
\PYG{g+go}{Framebuffer Inverted}
\end{sphinxVerbatim}

\sphinxstylestrong{print}: pass the initial column and row positions and the text in
double quotation marks when it contains spaces. If text hits the edge
of the display the remaining characters will be displayed on the next line. The
previous printed text will be overwritten.

Command example (reel\_board):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{uart:\PYGZti{}\PYGZdl{}} cfb print \PYG{l+m}{60} \PYG{l+m}{5} ZEPHYR
\end{sphinxVerbatim}

\sphinxstylestrong{scroll}: pass the scroll direction, vertical or horizontal, the initial
column and row positions, and the text to be displayed in double quotation
marks when it contains spaces. If the text hits the edge of the display, the
remaining characters will be displayed in the next line. The text will scroll
until it hits the display boundary, last column for horizontal and last row
for vertical direction. The text passed with the scroll command will be moved
vertically or horizontally on the display.

Command example (reel\_board):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{uart:\PYGZti{}\PYGZdl{}} cfb scroll vertical \PYG{l+m}{60} \PYG{l+m}{5} ZEPHYR
\end{sphinxVerbatim}

\sphinxstylestrong{clear}: clear the display screen.

Command example (reel\_board):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{uart:\PYGZti{}\PYGZdl{}} cfb clear
\PYG{g+go}{Display Cleared}
\end{sphinxVerbatim}


\section{LittlevGL Basic Sample}
\label{\detokenize{samples/sampleslvglREADME:littlevgl-basic-sample}}\label{\detokenize{samples/sampleslvglREADME:lvgl-sample}}\label{\detokenize{samples/sampleslvglREADME::doc}}

\subsection{Overview}
\label{\detokenize{samples/sampleslvglREADME:overview}}
This sample application displays “Hello World” in the center of the screen.


\subsection{Requirements}
\label{\detokenize{samples/sampleslvglREADME:requirements}}
Desay D6 OLED SSD1306


\subsection{Building and Running}
\label{\detokenize{samples/sampleslvglREADME:building-and-running}}
west build \sphinxhyphen{}p \sphinxhyphen{}b ds\_d6 \sphinxhyphen{}d build\sphinxhyphen{}lvgl samples/lvgl

or

west build \sphinxhyphen{}p \sphinxhyphen{}b native\_posix\_64 samples/lvgl

run : ./build/zephyr/zephyr.exe


\subsection{References}
\label{\detokenize{samples/sampleslvglREADME:references}}

\section{Lightsensor}
\label{\detokenize{samples/samplesmax44009README:lightsensor}}\label{\detokenize{samples/samplesmax44009README::doc}}
This is a modified sample app to read the pah8001 Heartrate sensor from the Desay D6 smartwatch.
It is used as a light sensor, uses the I2C protocol and is based on the max44009.
In order to function it needs the modified driver.

Notice :  in Kconfig MAX44009NEW was defined to avoid confusion with existing driver max44009
(this way the original does not get selected)


\section{LittlevGL SDL Button  Sample}
\label{\detokenize{samples/samplespinebuttonREADME:littlevgl-sdl-button-sample}}\label{\detokenize{samples/samplespinebuttonREADME:sdl-sample}}\label{\detokenize{samples/samplespinebuttonREADME::doc}}

\subsection{Overview}
\label{\detokenize{samples/samplespinebuttonREADME:overview}}
This sample application displays “a LED” and “a button”
Long Press on the button and the LED changes “color”


\subsection{Requirements}
\label{\detokenize{samples/samplespinebuttonREADME:requirements}}
This sample uses the native\_posix solution, so no need for a real board.
You’ll need to have a SDL library installed.


\subsection{Building and Running}
\label{\detokenize{samples/samplespinebuttonREADME:building-and-running}}
west build \sphinxhyphen{}p \sphinxhyphen{}b native\_posix\_64 samples/sdlbutton


\subsection{References}
\label{\detokenize{samples/samplespinebuttonREADME:references}}

\section{LittlevGL SDL Button  Sample}
\label{\detokenize{samples/samplessdlbuttonREADME:littlevgl-sdl-button-sample}}\label{\detokenize{samples/samplessdlbuttonREADME:sdl-sample}}\label{\detokenize{samples/samplessdlbuttonREADME::doc}}

\subsection{Overview}
\label{\detokenize{samples/samplessdlbuttonREADME:overview}}
This sample application displays “a LED” and “a button”
Long Press on the button and the LED changes “color”


\subsection{Requirements}
\label{\detokenize{samples/samplessdlbuttonREADME:requirements}}
This sample uses the native\_posix solution, so no need for a real board.
You’ll need to have a SDL library installed.


\subsection{Building and Running}
\label{\detokenize{samples/samplessdlbuttonREADME:building-and-running}}
west build \sphinxhyphen{}p \sphinxhyphen{}b native\_posix\_64 samples/sdlbutton


\subsection{References}
\label{\detokenize{samples/samplessdlbuttonREADME:references}}

\chapter{Menuconfig}
\label{\detokenize{menuconfig:menuconfig}}\label{\detokenize{menuconfig::doc}}

\section{Zephyr is like linux}
\label{\detokenize{menuconfig:zephyr-is-like-linux}}
\sphinxstylestrong{TIP: the pinetime specific drivers are located under Modules}

\sphinxstylestrong{Note:}  to get a feel, compile a program, for example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/bluetooth/peripheral \PYGZhy{}D CONF\PYGZus{}FILE=\PYGZdq{}prj.conf\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{the pinetime contains an external 32Kz crystal}}
now you can have a look in the configurationfile (and modify if needed)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} west build \PYGZhy{}t menuconfig
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{Modules}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Board} \PYG{n}{Selection} \PYG{p}{(}\PYG{n}{nRF52832}\PYG{o}{\PYGZhy{}}\PYG{n}{MDK}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Board} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{SoC}\PYG{o}{/}\PYG{n}{CPU}\PYG{o}{/}\PYG{n}{Configuration} \PYG{n}{Selection} \PYG{p}{(}\PYG{n}{Nordic} \PYG{n}{Semiconductor} \PYG{n}{nRF52} \PYG{n}{series} \PYG{n}{MCU}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Hardware} \PYG{n}{Configuration}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{ARM} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Architecture} \PYG{p}{(}\PYG{n}{ARM} \PYG{n}{architecture}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{General} \PYG{n}{Architecture} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Floating} \PYG{n}{point}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{General} \PYG{n}{Kernel} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Device} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{n}{SELECT} \PYG{n}{THIS} \PYG{n}{ONE}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
    \PYG{n}{C} \PYG{n}{Library}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Additional} \PYG{n}{libraries}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Bluetooth}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Console} \PYG{n}{subsystem}\PYG{o}{/}\PYG{n}{support} \PYG{n}{routines} \PYG{p}{[}\PYG{n}{EXPERIMENTAL}\PYG{p}{]}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{C}\PYG{o}{+}\PYG{o}{+} \PYG{n}{support} \PYG{k}{for} \PYG{n}{the} \PYG{n}{application}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{System} \PYG{n}{Monitoring} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Debugging} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Disk} \PYG{n}{Interface}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{File} \PYG{n}{Systems}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZhy{}}\PYG{o}{*}\PYG{o}{\PYGZhy{}} \PYG{n}{Logging}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Management}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Networking}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[} \PYG{p}{]} \PYG{n}{IEEE} \PYG{l+m+mf}{802.15}\PYG{o}{.}\PYG{l+m+mi}{4} \PYG{n}{drivers} \PYG{n}{options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{(}\PYG{n}{UART\PYGZus{}0}\PYG{p}{)} \PYG{n}{Device} \PYG{n}{Name} \PYG{n}{of} \PYG{n}{UART} \PYG{n}{Device} \PYG{k}{for} \PYG{n}{UART} \PYG{n}{Console}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Console} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Net} \PYG{n}{loopback} \PYG{n}{driver}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Serial} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Interrupt} \PYG{n}{Controllers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Timer} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZhy{}}\PYG{o}{*}\PYG{o}{\PYGZhy{}} \PYG{n}{Entropy} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{GPIO} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Shared} \PYG{n}{interrupt} \PYG{n}{driver}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{SPI} \PYG{n}{hardware} \PYG{n}{bus} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{I2C} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{I2S} \PYG{n}{bus} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{PWM} \PYG{p}{(}\PYG{n}{Pulse} \PYG{n}{Width} \PYG{n}{Modulation}\PYG{p}{)} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Enable} \PYG{n}{board} \PYG{n}{pinmux} \PYG{n}{driver}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{ADC} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Watchdog} \PYG{n}{Support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Hardware} \PYG{n}{clock} \PYG{n}{controller} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{n}{SELECT} \PYG{n}{THIS} \PYG{n}{ONE}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Precision} \PYG{n}{Time} \PYG{n}{Protocol} \PYG{n}{Clock} \PYG{n}{driver} \PYG{n}{support}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{IPM} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{Max} \PYG{n}{compiled}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{log} \PYG{n}{level} \PYG{k}{for} \PYG{n}{ipm} \PYG{p}{(}\PYG{n}{Info}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Flash} \PYG{n}{hardware} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Sensor} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{Max} \PYG{n}{compiled}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{log} \PYG{n}{level} \PYG{k}{for} \PYG{n}{clock} \PYG{n}{control} \PYG{p}{(}\PYG{n}{Info}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{NRF} \PYG{n}{Clock} \PYG{n}{controller} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{n}{SELECT} \PYG{n}{THIS} \PYG{n}{ONE}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}}
\end{sphinxVerbatim}


\chapter{Debugging}
\label{\detokenize{debugging/debugging:debugging}}\label{\detokenize{debugging/debugging:id1}}\label{\detokenize{debugging/debugging::doc}}

\section{debugging}
\label{\detokenize{debugging/debug:debugging}}\label{\detokenize{debugging/debug::doc}}

\subsection{Segger JLink}
\label{\detokenize{debugging/debug:segger-jlink}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{smartwatch} \PYG{n}{does} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port}\PYG{o}{.}
\PYG{n}{A} \PYG{n}{way} \PYG{n}{around} \PYG{n}{this} \PYG{o+ow}{is} \PYG{n}{to} \PYG{n}{use} \PYG{n}{a} \PYG{n}{Segger} \PYG{n}{Jlink} \PYG{n}{debug}\PYG{o}{\PYGZhy{}}\PYG{n}{probe} \PYG{o+ow}{and} \PYG{n}{enable} \PYG{n}{logging} \PYG{o+ow}{and} \PYG{n}{shell} \PYG{n}{over} \PYG{n}{RTT}\PYG{p}{:}

\PYG{o+ow}{in} \PYG{n}{prj}\PYG{o}{.}\PYG{n}{cfg}\PYG{p}{:}

\PYG{n}{CONFIG\PYGZus{}LOG}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}USE\PYGZus{}SEGGER\PYGZus{}RTT}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}SHELL}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}SHELL\PYGZus{}BACKEND\PYGZus{}RTT}\PYG{o}{=}\PYG{n}{y}

\PYG{n}{start} \PYG{n}{the} \PYG{n}{debugger} \PYG{p}{:}
\PYG{n}{west} \PYG{n}{debug}
\PYG{o+ow}{and} \PYG{n}{enter} \PYG{p}{:} \PYG{k}{continue}

\PYG{n}{This} \PYG{n}{starts} \PYG{n}{up} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{background} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Segger Jlink Processes}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
What happens when you type : west debug?
You could type this on the command prompt.
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp+gpVirtualEnv}{(this start the server)}
\PYG{g+go}{JLinkGDBServer \PYGZhy{}select usb \PYGZhy{}port 2331 \PYGZhy{}if swd \PYGZhy{}speed 4000 \PYGZhy{}device nRF52832\PYGZus{}xxAA \PYGZhy{}silent \PYGZhy{}singlerun}
\PYG{g+gp+gpVirtualEnv}{(this starts the debug session)}
\PYG{g+go}{\PYGZti{}/zephyr\PYGZhy{}sdk/arm\PYGZhy{}zephyr\PYGZhy{}eabi/bin/arm\PYGZhy{}zephyr\PYGZhy{}eabi\PYGZhy{}gdb /root/zephyrproject/app/build/zephyr/zephyr.elf \PYGZhy{}ex target :2331 \PYGZhy{}ex halt \PYGZhy{}ex reset \PYGZhy{}ex load}
\PYG{g+go}{telnet 127.0.0.1 19021 (putty on linux) start the rtt console and shows the debug\PYGZhy{}log}
\end{sphinxVerbatim}


\subsection{Black Magic}
\label{\detokenize{debugging/debug:black-magic}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{ds}\PYG{o}{\PYGZhy{}}\PYG{n}{D6} \PYG{n}{smartwatch} \PYG{n}{has} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port}\PYG{o}{.}


\PYG{n}{The} \PYG{n}{blackmagicprobe} \PYG{n}{can} \PYG{n}{lauch} \PYG{n}{a} \PYG{n}{debugger} \PYG{p}{:} \PYG{n}{west} \PYG{n}{debug} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{runnerblackmagicprobe}\PYG{o}{.}
\PYG{n}{The} \PYG{n}{probe} \PYG{n}{has} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port} \PYG{o}{/}\PYG{n}{dev}\PYG{o}{/}\PYG{n}{ttyACM1} \PYG{p}{(}\PYG{n}{linux} \PYG{p}{:} \PYG{n}{minicom} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{l+m+mi}{115200} \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{o}{/}\PYG{n}{dev}\PYG{o}{/}\PYG{n}{ttyACM1}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{STM32 \sphinxhyphen{} Raspberry \sphinxhyphen{} OpenOCD}
\label{\detokenize{debugging/debug:stm32-raspberry-openocd}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{If} \PYG{n}{you} \PYG{n}{do} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{Segger} \PYG{n}{debug} \PYG{n}{probe} \PYG{n}{nor} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port}\PYG{p}{,} \PYG{n}{you} \PYG{n}{can} \PYG{n}{put} \PYG{n}{a} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{memory} \PYG{n}{at} \PYG{n}{a} \PYG{n}{fixed} \PYG{n}{location}\PYG{o}{.}
\PYG{n}{With} \PYG{n}{openocd} \PYG{n}{you} \PYG{n}{can} \PYG{n}{peek} \PYG{n}{at} \PYG{n}{this} \PYG{n}{memory} \PYG{n}{location}\PYG{o}{.}
\PYG{n}{If} \PYG{n}{you} \PYG{n}{own} \PYG{n}{a} \PYG{n}{raspberry} \PYG{n}{pi} \PYG{o+ow}{or} \PYG{n}{an} \PYG{n}{orange} \PYG{n}{pi}\PYG{p}{,} \PYG{n}{you} \PYG{n}{can} \PYG{n}{use} \PYG{n}{the} \PYG{n}{GPIO} \PYG{n}{header}\PYG{o}{.}
\PYG{n}{Another} \PYG{n}{cheap} \PYG{n}{option} \PYG{o+ow}{is} \PYG{n}{an} \PYG{n}{stm32} \PYG{n}{debug} \PYG{n}{probe}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\#define MY\_REGISTER (*(volatile uint8\_t*)0x2000F000)

in the program you can set values:
MY\_REGISTER=1;
MY\_REGISTER=8;

this way you know till where the code executes
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}telnet \PYG{l+m}{127}.0.0.1 \PYG{l+m}{4444}
\end{sphinxVerbatim}

programming

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{once your telnet sessions started:}
\PYG{g+go}{Trying 127.0.0.1...}
\PYG{g+go}{Connected to 127.0.0.1.}
\PYG{g+go}{Escape character is \PYGZsq{}\PYGZca{}]\PYGZsq{}.}
\PYG{g+go}{Open On\PYGZhy{}Chip Debugger}
\PYG{g+gp}{\PYGZgt{}}mdw 0x2000F000 0x1

\PYG{g+go}{the last byte shows the value of your program trace value}
\end{sphinxVerbatim}


\section{The black magic probe}
\label{\detokenize{debugging/blackmagicprobe:the-black-magic-probe}}\label{\detokenize{debugging/blackmagicprobe::doc}}

\subsection{probes in zephyr}
\label{\detokenize{debugging/blackmagicprobe:probes-in-zephyr}}
You can program the nrf52832 with a debuggerprobe.
The standard\sphinxhyphen{}setup is jlink (segger).

/root/zephyrproject/zephyr/boards/arm/id107plus/board.cmake (adapt the runner here)

in our case : instead of jlink specify : blackmagicprobe

The cool thing about this probe that it has a serial port (3.3V) and a debug (upload) port on the same usb\sphinxhyphen{}port.
\begin{itemize}
\item {} 
/dev/ttyACM1 is serial port (pb6 pb7)

\end{itemize}

minicom \sphinxhyphen{}b 115200 \sphinxhyphen{}D /dev/ttyACM1
\begin{itemize}
\item {} 
/dev/ttyACM0 is used as debugger/uploading

\end{itemize}

west debug \textendash{}runner blackmagicprobe
west flash \textendash{}runner blackmagicprobe


\subsection{howto setup a blackmagicprobe}
\label{\detokenize{debugging/blackmagicprobe:howto-setup-a-blackmagicprobe}}
You can buy this probe and support the developers. (make this world a better place)

I bought a “cheapo” “blue pill” stm32 board for future projects …
soldered a 1.8K resistor between 3.3K and PA12

downloaded from \sphinxurl{https://jeelabs.org/docs/software/bmp/}
\sphinxhyphen{} blackmagic.bin (79 ko)
\sphinxhyphen{} blackmagic\_dfu.bin (7 ko)

in jlink : loadbin blackmagic\_dfu.bin 0x8000000 (specify jlink no options …)
switch boot0 or boot1 or whatever
connect usb
in linux
dfu\sphinxhyphen{}util \sphinxhyphen{}v \sphinxhyphen{}R \sphinxhyphen{}d 0483:df11 \sphinxhyphen{}s 0x08002000 \sphinxhyphen{}D blackmagic.bin
(uploading in jlink was a problem cause memory restrictions)

\noindent\sphinxincludegraphics{{blackmagicd6}.jpeg}

(removed boot0 and boot1 connectors on the stm afterwards)

plugged it in the USB port and it pops up (had to enable it first in virtual box usb : black sphere technologies …..)


\section{pseudo}
\label{\detokenize{debugging/pseudo:pseudo}}\label{\detokenize{debugging/pseudo::doc}}

\subsection{simulation on NATIVE\_POSIX\_64}
\label{\detokenize{debugging/pseudo:simulation-on-native-posix-64}}
It is possible to use two serial ports on the virtual posix board.
One can display log message, while the other one lets you interact with the shell.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CONFIG\PYGZus{}UART\PYGZus{}CONSOLE}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}UART\PYGZus{}CONSOLE\PYGZus{}ON\PYGZus{}DEV\PYGZus{}NAME}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UART\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{CONFIG\PYGZus{}UART\PYGZus{}NATIVE\PYGZus{}POSIX\PYGZus{}PORT\PYGZus{}1\PYGZus{}ENABLE}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}UART\PYGZus{}NATIVE\PYGZus{}POSIX\PYGZus{}PORT\PYGZus{}1\PYGZus{}NAME}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UART\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{CONFIG\PYGZus{}SHELL}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}UART\PYGZus{}SHELL\PYGZus{}ON\PYGZus{}DEV\PYGZus{}NAME}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UART\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{root@osboxes:\PYGZti{}/work/app\PYGZsh{}} ./build/zephyr/zephyr.exe
\PYG{g+go}{UART\PYGZus{}1 connected to pseudotty: /dev/pts/2}
\PYG{g+go}{UART\PYGZus{}0 connected to pseudotty: /dev/pts/3}


\PYG{g+go}{minicom \PYGZhy{}D /dev/pts/3}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp+gpVirtualEnv}{(you should see log messages)}
\end{sphinxVerbatim}


\section{Segger RTT (Real Time Transfer)}
\label{\detokenize{debugging/jlink:segger-rtt-real-time-transfer}}\label{\detokenize{debugging/jlink::doc}}

\section{Serial data without a serial port}
\label{\detokenize{debugging/jlink:serial-data-without-a-serial-port}}
Pinetime does not have UART pins but UART\sphinxhyphen{}like connection can be achieved using RTT (Real Time Transfer)
feature of Segger JLink debugger. RTT data can be accessed using SEGGER tool (RTTViewer) or by using
telnet connection to active debug session. Second methond is recommended since it gives better throughput
and allows bitdirection communication using Zephyr Shell (with RTT as backend). PuTTY can be used to
telnet to debug session.

Prerequisites:
\sphinxhyphen{} JLink debugger, for example one of Nordic Semiconductor Development Kits.
\sphinxhyphen{} Setup: \sphinxurl{https://wiki.pine64.org/index.php/PineTime\#Using\_JLink\_programmer\_and\_nrfjprog\_tools}

Following steps needs to be taken to run RTT shell in the application:
1. Install PuTTY and Setup RTT session. On Linux, copy \sphinxtitleref{misc/rtt\_shell/rtt} to \sphinxtitleref{\textasciitilde{}/putty/sessions}. On Windows,
execute \sphinxtitleref{misc/rtt\_shell/putty\sphinxhyphen{}rtt.reg}.
2. Enable logging and shell over RTT:
\sphinxcode{\sphinxupquote{\textasciigrave{}
CONFIG\_LOG=y
CONFIG\_USE\_SEGGER\_RTT=y
CONFIG\_SHELL=y
CONFIG\_SHELL\_BACKEND\_RTT=y
\textasciigrave{}}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Build and flash application.

\end{enumerate}

4. Start debug session
\sphinxcode{\sphinxupquote{\textasciigrave{}
west debug (will start gdb)
continue (in gdb console)
\textasciigrave{}}}
5. Start PuTTY RTT session, prompt should be printed.

Resources:
\sphinxhyphen{} Zephyr shell documentation: \sphinxurl{https://docs.zephyrproject.org/latest/reference/shell/index.html}
\sphinxhyphen{} Zephyr logger documentation: \sphinxurl{https://docs.zephyrproject.org/latest/reference/logging/index.html}


\chapter{Hacking stuff}
\label{\detokenize{hacking/hacking:hacking-stuff}}\label{\detokenize{hacking/hacking:hacking}}\label{\detokenize{hacking/hacking::doc}}

\section{hacking   the pinetime smartwatch}
\label{\detokenize{hacking/flashing:hacking-the-pinetime-smartwatch}}\label{\detokenize{hacking/flashing::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{o+ow}{is} \PYG{n}{preloaded} \PYG{k}{with} \PYG{n}{firmware}\PYG{o}{.}
\PYG{n}{This} \PYG{n}{firmware} \PYG{o+ow}{is} \PYG{n}{secured}\PYG{p}{,} \PYG{n}{you} \PYG{n}{cannot} \PYG{n}{peek} \PYG{n}{into} \PYG{n}{it}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The pinetime has a swd interface.
To be able to write firmware,  you need special hardware.
I use a stm\sphinxhyphen{}link which is very cheap(2\$).
You can also use the GPIO header of a raspberry pi.
(my repo: \sphinxurl{https://github.com/najnesnaj/openocd} is adapted for the orange pi)
\end{sphinxadmonition}

To flash the software I use openocd :
example for stm\sphinxhyphen{}link usb\sphinxhyphen{}stick

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}} openocd \PYGZhy{}s /usr/local/share/openocd/scripts \PYGZhy{}f interface/stlink.cfg \PYGZhy{}f target/nrf52.cfg
\end{sphinxVerbatim}

example for the orange\sphinxhyphen{}pi GPIO header (or raspberry)
\begin{quote}

\# openocd \sphinxhyphen{}f /usr/local/share/openocd/scripts/interface/sysfsgpio\sphinxhyphen{}raspberrypi.cfg
\sphinxhyphen{}c ‘transport select swd’ \sphinxhyphen{}f /usr/local/share/openocd/scripts/target/nrf52.cfg
\sphinxhyphen{}c ‘bindto 0.0.0.0’
\end{quote}

once you started the openocd background server, you can connect to it using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}telnet \PYG{l+m}{127}.0.0.1 \PYG{l+m}{4444}
\end{sphinxVerbatim}

programming

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{once your telnet sessions started:}
\PYG{g+go}{Trying 127.0.0.1...}
\PYG{g+go}{Connected to 127.0.0.1.}
\PYG{g+go}{Escape character is \PYGZsq{}\PYGZca{}]\PYGZsq{}.}
\PYG{g+go}{Open On\PYGZhy{}Chip Debugger}
\PYG{g+gp}{\PYGZgt{}} program zephyr.bin

\PYG{g+go}{target halted due to debug\PYGZhy{}request, current mode: Thread}
\PYG{g+go}{xPSR: 0x01000000 pc: 0x00001534 msp: 0x20004a10}
\PYG{g+go}{** Programming Started **}
\PYG{g+go}{auto erase enabled}
\PYG{g+go}{using fast async flash loader. This is currently supported}
\PYG{g+go}{only with ST\PYGZhy{}Link and CMSIS\PYGZhy{}DAP. If you have issues, add}
\PYG{g+go}{\PYGZdq{}set WORKAREASIZE 0\PYGZdq{} before sourcing nrf51.cfg/nrf52.cfg to disable it}
\PYG{g+go}{target halted due to breakpoint, current mode: Thread}
\PYG{g+go}{xPSR: 0x61000000 pc: 0x2000001e msp: 0x20004a10}
\PYG{g+go}{wrote 24576 bytes from file zephyr.bin in 1.703540s (14.088 KiB/s)}
\PYG{g+go}{** Programming Finished **}

\PYG{g+go}{And finally execute a reset :}
\PYG{g+gp}{\PYGZgt{}}reset
\end{sphinxVerbatim}

removing write protection see:   {\hyperref[\detokenize{hacking/writeprotection:flashing}]{\sphinxcrossref{\DUrole{std,std-ref}{howto flash your zephyr image}}}}


\section{scanning the I2C\_1 port}
\label{\detokenize{hacking/i2cscanning:scanning-the-i2c-1-port}}\label{\detokenize{hacking/i2cscanning:i2cscanning}}\label{\detokenize{hacking/i2cscanning::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{does} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port}\PYG{o}{.}
\PYG{n}{I} \PYG{n}{do} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{segger} \PYG{n}{debugging} \PYG{n}{probe}\PYG{o}{.}
\PYG{n}{A} \PYG{n}{way} \PYG{n}{around} \PYG{n}{this}\PYG{p}{,} \PYG{n}{it} \PYG{n}{to} \PYG{n}{put} \PYG{n}{a} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{memory} \PYG{n}{at} \PYG{n}{a} \PYG{n}{fixed} \PYG{n}{location}\PYG{o}{.}
\PYG{n}{With} \PYG{n}{openocd} \PYG{n}{you} \PYG{n}{can} \PYG{n}{peek} \PYG{n}{at} \PYG{n}{this} \PYG{n}{memory} \PYG{n}{location}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{hacking/i2cscanning:building-and-running}}
In this repo under samples you will find an adapted i2c scanner program.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/i2c\PYGZus{}scanner}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\#define MY\_REGISTER (*(volatile uint8\_t*)0x2000F000)

in the program you can set values:
MY\_REGISTER=1;
MY\_REGISTER=8;

this way you know till where the code executes
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}telnet \PYG{l+m}{127}.0.0.1 \PYG{l+m}{4444}
\end{sphinxVerbatim}

Peeking

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{once your telnet sessions started:}
\PYG{g+go}{Trying 127.0.0.1...}
\PYG{g+go}{Connected to 127.0.0.1.}
\PYG{g+go}{Escape character is \PYGZsq{}\PYGZca{}]\PYGZsq{}.}
\PYG{g+go}{Open On\PYGZhy{}Chip Debugger}
\PYG{g+gp}{\PYGZgt{}}mdw 0x2000F000 0x1
\PYG{g+go}{0x2000f000: 00c24418}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Note:}:

this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first….)


\section{howto flash your zephyr image}
\label{\detokenize{hacking/writeprotection:howto-flash-your-zephyr-image}}\label{\detokenize{hacking/writeprotection:flashing}}\label{\detokenize{hacking/writeprotection::doc}}
Once you completed your \sphinxcode{\sphinxupquote{west build}} , your image is located under the build directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{   \PYGZdl{}} \PYG{n+nb}{cd} \PYGZti{}/work/pinetime/zephyr/build/zephyr
\PYG{g+go}{   here you can find zephyr.bin which you can flash}




\PYG{g+go}{I use Openocd to flash.}
\PYG{g+go}{Just connect : telnet 127.0.0.1 4444}

\PYG{g+go}{.. code\PYGZhy{}block:: console}

\PYG{g+go}{    program zephyr.bin}
\end{sphinxVerbatim}


\section{howto remove the write protection}
\label{\detokenize{hacking/writeprotection:howto-remove-the-write-protection}}\begin{description}
\item[{::}] \leavevmode
the PineTime watch is read/write protected (at least the one I got)
executing the following : nrf52.dap apreg 1 0x0c shows 0x0

Mind you, st\sphinxhyphen{}link does not allow you to execute that command, for this you will need a J\sphinxhyphen{}link.

There is a workaround using the GPIO of a raspberry pi or an Orangepi. (in this case you won’t need an external programmer at all)
(You can find an example for the orange pi in my repo :\sphinxurl{https://github.com/najnesnaj/openocd}.)
You have to reconfigure Openocd with the \textendash{}enable\sphinxhyphen{}cmsis\sphinxhyphen{}dap option.

Unlock the chip by executing the command:
\textgreater{} nrf52.dap apreg 1 0x04 0x01

\end{description}


\section{howto configure gateway}
\label{\detokenize{hacking/infrastructure:howto-configure-gateway}}\label{\detokenize{hacking/infrastructure:infrastructure}}\label{\detokenize{hacking/infrastructure::doc}}
Once you completed your \sphinxcode{\sphinxupquote{west build}} , your image is located under the build directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} \PYGZti{}/work/pinetime/zephyr/build/zephyr
\PYG{g+go}{here you can find zephyr.bin which you can flash}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{I} \PYG{n}{use} \PYG{n}{an} \PYG{n}{orange} \PYG{n}{pi} \PYG{n}{single} \PYG{n}{board} \PYG{n}{computer}\PYG{o}{.}
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{watch} \PYG{o+ow}{is} \PYG{n}{attached} \PYG{n}{to} \PYG{n}{this}\PYG{o}{.}
\PYG{n}{My} \PYG{n}{development} \PYG{o+ow}{is} \PYG{n}{done} \PYG{n}{on} \PYG{n}{a} \PYG{n}{laptop}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
How can you copy from one environment (laptop) to another (SBC) without typing password?
\end{sphinxVerbatim}

On the laptop :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{ssh\PYGZhy{}keygen \PYGZhy{}b 8092 \PYGZhy{}t rsa \PYGZhy{}C \PYGZdq{}fota gw access key\PYGZdq{} \PYGZhy{}f \PYGZti{}/.ssh/orange}
\PYG{g+go}{Generating public/private rsa key pair.}
\PYG{g+go}{Enter passphrase (empty for no passphrase):          (LEAVE EMPTY!)}
\PYG{g+go}{Enter same passphrase again:}
\PYG{g+go}{Your identification has been saved in /root/.ssh/orange.}
\PYG{g+go}{Your public key has been saved in /root/.ssh/orange.pub.}
\PYG{g+go}{The key fingerprint is:}
\PYG{g+go}{SHA256:xCM5Fk1LAVjEWqrM6LKM8Y6+Y12ONt6eV8vDa/KdRUM fota gw access key}
\PYG{g+go}{The key\PYGZsq{}s randomart image is:}
\PYG{g+go}{+\PYGZhy{}\PYGZhy{}\PYGZhy{}[RSA 8092]\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{g+go}{|     ==++.       |}
\PYG{g+go}{|B*B.o+. +ooo     |}
\PYG{g+go}{+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}[SHA256]\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}

\PYG{g+gp+gpVirtualEnv}{(the standard port is 22 and not 9988 which is my custom port)}

\PYG{g+go}{copy the certificate to the SBC (which name is orange in my case):}
\PYG{g+go}{ssh\PYGZhy{}copy\PYGZhy{}id \PYGZhy{}p 9988 \PYGZhy{}i \PYGZti{}/.ssh/orange.pub root@orange}


\PYG{g+go}{create config file :  \PYGZti{}/.ssh/config}
\PYG{g+go}{      Host orange}
\PYG{g+go}{      HostName orange}
\PYG{g+go}{      User root}
\PYG{g+go}{      Port 9988}
\PYG{g+go}{      IdentityFile \PYGZti{}/.ssh/orange}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Now} \PYG{n}{you} \PYG{n}{can} \PYG{n}{copy} \PYG{n}{without} \PYG{n}{a} \PYG{n}{password} \PYG{p}{:}
\PYG{n}{scp} \PYG{n}{build}\PYG{o}{/}\PYG{n}{zephyr}\PYG{o}{/}\PYG{n}{zephyr}\PYG{o}{.}\PYG{n}{bin} \PYG{n}{orange}\PYG{p}{:}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{src}
\end{sphinxVerbatim}
\phantomsection\label{\detokenize{hacking/openocd:openocd}}
w


\section{howto use 2 openocd sessions}
\label{\detokenize{hacking/openocd:howto-use-2-openocd-sessions}}\label{\detokenize{hacking/openocd::doc}}
Once you completed your \sphinxcode{\sphinxupquote{west build}} , your image is located under the build directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{   \PYGZdl{}} \PYG{n+nb}{cd} \PYGZti{}/work/pinetime/zephyr/build/zephyr
\PYG{g+go}{   here you can find zephyr.bin which you can flash}




\PYG{g+go}{I use Openocd to flash.}
\PYG{g+go}{Just connect : telnet 127.0.0.1 4444}

\PYG{g+go}{.. code\PYGZhy{}block:: console}

\PYG{g+go}{    program zephyr.bin}
\end{sphinxVerbatim}


\subsection{Suppose you have 2 microcontrollers}
\label{\detokenize{hacking/openocd:suppose-you-have-2-microcontrollers}}\begin{quote}

Just connect : telnet 127.0.0.1 7777 for the second.
\end{quote}


\subsection{Howto setup a second openocd session on a different port?}
\label{\detokenize{hacking/openocd:howto-setup-a-second-openocd-session-on-a-different-port}}
In this case an ST\sphinxhyphen{}LINK/V2 an in\sphinxhyphen{}circuit debugger and programmer is used.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openocd} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{telnet\PYGZus{}port 7777}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tcl\PYGZus{}port 6667}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gdb\PYGZus{}port 3332}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{share}\PYG{o}{/}\PYG{n}{openocd}\PYG{o}{/}\PYG{n}{scripts} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{interface}\PYG{o}{/}\PYG{n}{stlink}\PYG{o}{.}\PYG{n}{cfg}  \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{target}\PYG{o}{/}\PYG{n}{nrf52}\PYG{o}{.}\PYG{n}{cfg}
\end{sphinxVerbatim}


\subsection{Howto use the GPIO header of a Single Board computer}
\label{\detokenize{hacking/openocd:howto-use-the-gpio-header-of-a-single-board-computer}}
This works really well, and does not require a seperate programmer.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openocd} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{share}\PYG{o}{/}\PYG{n}{openocd}\PYG{o}{/}\PYG{n}{scripts}\PYG{o}{/}\PYG{n}{interface}\PYG{o}{/}\PYG{n}{sysfsgpio}\PYG{o}{\PYGZhy{}}\PYG{n}{raspberrypi}\PYG{o}{.}\PYG{n}{cfg} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transport select swd}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{share}\PYG{o}{/}\PYG{n}{openocd}\PYG{o}{/}\PYG{n}{scripts}\PYG{o}{/}\PYG{n}{target}\PYG{o}{/}\PYG{n}{nrf52}\PYG{o}{.}\PYG{n}{cfg}  \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bindto 0.0.0.0}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}


\section{howto generate pdf documents}
\label{\detokenize{hacking/latexpdf:howto-generate-pdf-documents}}\label{\detokenize{hacking/latexpdf::doc}}
sphinx cannot generate pdf directly, and needs latex

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{latexmk}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{fonts}\PYG{o}{\PYGZhy{}}\PYG{n}{recommended}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{xzdec}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{cmap}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{latex}\PYG{o}{\PYGZhy{}}\PYG{n}{recommended}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{latex}\PYG{o}{\PYGZhy{}}\PYG{n}{extra}
\end{sphinxVerbatim}


\chapter{Behind the scene}
\label{\detokenize{behind/behind:behind-the-scene}}\label{\detokenize{behind/behind:id1}}\label{\detokenize{behind/behind::doc}}

\section{Touchscreen}
\label{\detokenize{behind/touchscreen:touchscreen}}\label{\detokenize{behind/touchscreen::doc}}
In my first release I created a touchscreendriver that read the x\sphinxhyphen{}y coordinates from the pinetime screen.

Meanwhile a rudimentary touchscreen driver exist in Zephyr. (KSCAN\_TOUCH)

It integrates with LVGL.

I managed to adapt the driver from Focaltech, so it now supports the Pinetime as well.

However it is not capable of detecting events like “slide up/down”, but point and click is usable.


\subsection{Overview}
\label{\detokenize{behind/touchscreen:overview}}
Touchscreen Hynitron


\subsection{Requirements}
\label{\detokenize{behind/touchscreen:requirements}}

\subsection{Building and Running}
\label{\detokenize{behind/touchscreen:building-and-running}}

\subsection{Todo}
\label{\detokenize{behind/touchscreen:todo}}\begin{quote}

\sphinxhyphen{}support more touchscreen events
\end{quote}


\subsection{References}
\label{\detokenize{behind/touchscreen:references}}

\section{placing a button on the screen}
\label{\detokenize{behind/lvglbutton:placing-a-button-on-the-screen}}\label{\detokenize{behind/lvglbutton::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{This} \PYG{n}{sample} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{really} \PYG{n}{important}\PYG{p}{,} \PYG{n}{but} \PYG{n}{it} \PYG{n}{will} \PYG{n}{teach} \PYG{n}{you} \PYG{n}{that} \PYG{n}{you} \PYG{n}{need} \PYG{n}{to} \PYG{n+nb}{set} \PYG{n}{LVGL\PYGZus{}CONFIG} \PYG{n}{values}\PYG{p}{,} \PYG{o+ow}{in} \PYG{n}{order}    \PYG{n}{to} \PYG{n}{be} \PYG{n}{able} \PYG{n}{to} \PYG{n}{use} \PYG{n}{LVGL} \PYG{n}{functions}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{behind/lvglbutton:building-and-running}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}


\chapter{About}
\label{\detokenize{about:about}}\label{\detokenize{about::doc}}
I got a pinetime development kit very early.
I would like to thank the folks from \sphinxurl{https://www.pine64.org/} for the kit.

The Nordic nrf52832 is an Arm based, 32bit microcontroller with a lot of flash, RAM memory and(!) bluetooth!
It is a good platform to explore the wonderfull world of opensource RTOS’s.
I choose the Zephyr platform, because it already contained the display driver, and the bluetooth functionality.
Furthermore it can be updated wirelessly.

I started of with adapting simple samples, so they would run on the pinetime watch.
Meanwhile I learned how to adapt the board definition file.
Gradually this morphed into a pinetime\sphinxhyphen{}toolkit.
A few experts contributed and improved this kit so it became usable.

I took a long break from this project, zephyr evolved and a project for creating an open source watch, the hypnos\sphinxhyphen{}firmware flourished.

The drivers for the heartrate sensor, touchpanel that I adapted, became obsolete.
The pinetime board definition file is now part of the zephyr RTOS distribution.

Recently I discovered that the standard focaltech touchscreen driver could be adapted easily so it would run on the pinetime and integrate nicely with the LVGL\sphinxhyphen{}gui. There were several OLED ssd1306 watches on my desk and I wondered if I could run Zephyr and LVGL (graphical stuff) on them as well. (yes, we can!)
I played around with the “native\_posix\_64” board, which is a virtual board that allows you to run firmware on your computer instead of on the watch (no need for flashing).

This gave me the idea for an opensource\sphinxhyphen{}watch\sphinxhyphen{}framework.
Start of with simple samples, and add some more functionality, until finally you end up with a smartwatch.
The framework is build around three smartwatches, the pinetime, the ds\_d6 and the posix\_sdl.
It should work on other platform as well, with minor modifications.
I only recently got the idea for out\sphinxhyphen{}of\sphinxhyphen{}tree development.
Just put all the modified drivers, board definitions and application in one place outside of the zephyr\sphinxhyphen{}tree.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{n}{word} \PYG{n}{of} \PYG{n}{warning}\PYG{p}{:} \PYG{n}{this} \PYG{o+ow}{is} \PYG{n}{work} \PYG{o+ow}{in} \PYG{n}{progress}\PYG{o}{.}
\PYG{n}{You}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{re likely to have a better skillset then me.}
\PYG{n}{You} \PYG{n}{are} \PYG{n}{invited} \PYG{n}{to} \PYG{n}{add} \PYG{n}{the} \PYG{n}{missing} \PYG{n}{pieces} \PYG{o+ow}{and} \PYG{n}{to} \PYG{n}{improve} \PYG{n}{what}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s already there.}
\end{sphinxVerbatim}


\chapter{Author}
\label{\detokenize{author:author}}\label{\detokenize{author::doc}}
Some 20 years ago I attended a course on how to brew beer.
Real beer, starting with barley, wheat, yeast, brewkettles …

I bought some brewing equipment and started brewing my own beer.
Apart from a stupid idea, (why brew beer in a country that has plenty of breweries), I soon found out that brewing is labour intensitive.

Instead of quitting right away (the most sensisible thing to do), I tried to reduce the effort.
I switched from a gasheated kettle to an electric one.

The next step was to control the temperature.
I got an arduino and a temp\sphinxhyphen{}sensor.
This got me interested in microcontrollers.

It appealed to my childish nature, that I could get quick results with little coding.
Blinking a led, really lightens up my day!
And a beer of course.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Guess}\PYG{p}{,} \PYG{n}{even} \PYG{k}{for} \PYG{n}{a} \PYG{n}{technically} \PYG{n}{skilled} \PYG{n}{audiance}\PYG{p}{,} \PYG{n}{story}\PYG{o}{\PYGZhy{}}\PYG{n}{telling}\PYG{p}{,}  \PYG{n}{renders} \PYG{n}{a} \PYG{n}{manual} \PYG{n}{less} \PYG{n}{boring} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}



\renewcommand{\indexname}{Index}
\printindex
\end{document}