
zephyr.elf:     file format elf64-x86-64


Disassembly of section .init:

0000000000004300 <_init>:
    4300:	48 83 ec 08          	sub    $0x8,%rsp
    4304:	48 8b 05 dd 1c 23 00 	mov    0x231cdd(%rip),%rax        # 235fe8 <__gmon_start__>
    430b:	48 85 c0             	test   %rax,%rax
    430e:	74 02                	je     4312 <_init+0x12>
    4310:	ff d0                	callq  *%rax
    4312:	48 83 c4 08          	add    $0x8,%rsp
    4316:	c3                   	retq   

Disassembly of section .plt:

0000000000004320 <.plt>:
    4320:	ff 35 c2 19 23 00    	pushq  0x2319c2(%rip)        # 235ce8 <_GLOBAL_OFFSET_TABLE_+0x8>
    4326:	ff 25 c4 19 23 00    	jmpq   *0x2319c4(%rip)        # 235cf0 <_GLOBAL_OFFSET_TABLE_+0x10>
    432c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000004330 <SDL_DestroyWindow@plt>:
    4330:	ff 25 c2 19 23 00    	jmpq   *0x2319c2(%rip)        # 235cf8 <SDL_DestroyWindow>
    4336:	68 00 00 00 00       	pushq  $0x0
    433b:	e9 e0 ff ff ff       	jmpq   4320 <.plt>

0000000000004340 <setvbuf@plt>:
    4340:	ff 25 ba 19 23 00    	jmpq   *0x2319ba(%rip)        # 235d00 <setvbuf@GLIBC_2.2.5>
    4346:	68 01 00 00 00       	pushq  $0x1
    434b:	e9 d0 ff ff ff       	jmpq   4320 <.plt>

0000000000004350 <SDL_CreateRenderer@plt>:
    4350:	ff 25 b2 19 23 00    	jmpq   *0x2319b2(%rip)        # 235d08 <SDL_CreateRenderer>
    4356:	68 02 00 00 00       	pushq  $0x2
    435b:	e9 c0 ff ff ff       	jmpq   4320 <.plt>

0000000000004360 <__errno_location@plt>:
    4360:	ff 25 aa 19 23 00    	jmpq   *0x2319aa(%rip)        # 235d10 <__errno_location@GLIBC_2.2.5>
    4366:	68 03 00 00 00       	pushq  $0x3
    436b:	e9 b0 ff ff ff       	jmpq   4320 <.plt>

0000000000004370 <SDL_CreateWindow@plt>:
    4370:	ff 25 a2 19 23 00    	jmpq   *0x2319a2(%rip)        # 235d18 <SDL_CreateWindow>
    4376:	68 04 00 00 00       	pushq  $0x4
    437b:	e9 a0 ff ff ff       	jmpq   4320 <.plt>

0000000000004380 <pthread_cancel@plt>:
    4380:	ff 25 9a 19 23 00    	jmpq   *0x23199a(%rip)        # 235d20 <pthread_cancel@GLIBC_2.2.5>
    4386:	68 05 00 00 00       	pushq  $0x5
    438b:	e9 90 ff ff ff       	jmpq   4320 <.plt>

0000000000004390 <SDL_Quit@plt>:
    4390:	ff 25 92 19 23 00    	jmpq   *0x231992(%rip)        # 235d28 <SDL_Quit>
    4396:	68 06 00 00 00       	pushq  $0x6
    439b:	e9 80 ff ff ff       	jmpq   4320 <.plt>

00000000000043a0 <SDL_RenderPresent@plt>:
    43a0:	ff 25 8a 19 23 00    	jmpq   *0x23198a(%rip)        # 235d30 <SDL_RenderPresent>
    43a6:	68 07 00 00 00       	pushq  $0x7
    43ab:	e9 70 ff ff ff       	jmpq   4320 <.plt>

00000000000043b0 <strtoll@plt>:
    43b0:	ff 25 82 19 23 00    	jmpq   *0x231982(%rip)        # 235d38 <strtoll@GLIBC_2.2.5>
    43b6:	68 08 00 00 00       	pushq  $0x8
    43bb:	e9 60 ff ff ff       	jmpq   4320 <.plt>

00000000000043c0 <bind@plt>:
    43c0:	ff 25 7a 19 23 00    	jmpq   *0x23197a(%rip)        # 235d40 <bind@GLIBC_2.2.5>
    43c6:	68 09 00 00 00       	pushq  $0x9
    43cb:	e9 50 ff ff ff       	jmpq   4320 <.plt>

00000000000043d0 <socket@plt>:
    43d0:	ff 25 72 19 23 00    	jmpq   *0x231972(%rip)        # 235d48 <socket@GLIBC_2.2.5>
    43d6:	68 0a 00 00 00       	pushq  $0xa
    43db:	e9 40 ff ff ff       	jmpq   4320 <.plt>

00000000000043e0 <__vfprintf_chk@plt>:
    43e0:	ff 25 6a 19 23 00    	jmpq   *0x23196a(%rip)        # 235d50 <__vfprintf_chk@GLIBC_2.3.4>
    43e6:	68 0b 00 00 00       	pushq  $0xb
    43eb:	e9 30 ff ff ff       	jmpq   4320 <.plt>

00000000000043f0 <nanosleep@plt>:
    43f0:	ff 25 62 19 23 00    	jmpq   *0x231962(%rip)        # 235d58 <nanosleep@GLIBC_2.2.5>
    43f6:	68 0c 00 00 00       	pushq  $0xc
    43fb:	e9 20 ff ff ff       	jmpq   4320 <.plt>

0000000000004400 <strtoul@plt>:
    4400:	ff 25 5a 19 23 00    	jmpq   *0x23195a(%rip)        # 235d60 <strtoul@GLIBC_2.2.5>
    4406:	68 0d 00 00 00       	pushq  $0xd
    440b:	e9 10 ff ff ff       	jmpq   4320 <.plt>

0000000000004410 <pthread_cond_broadcast@plt>:
    4410:	ff 25 52 19 23 00    	jmpq   *0x231952(%rip)        # 235d68 <pthread_cond_broadcast@GLIBC_2.3.2>
    4416:	68 0e 00 00 00       	pushq  $0xe
    441b:	e9 00 ff ff ff       	jmpq   4320 <.plt>

0000000000004420 <write@plt>:
    4420:	ff 25 4a 19 23 00    	jmpq   *0x23194a(%rip)        # 235d70 <write@GLIBC_2.2.5>
    4426:	68 0f 00 00 00       	pushq  $0xf
    442b:	e9 f0 fe ff ff       	jmpq   4320 <.plt>

0000000000004430 <SDL_DestroyRenderer@plt>:
    4430:	ff 25 42 19 23 00    	jmpq   *0x231942(%rip)        # 235d78 <SDL_DestroyRenderer>
    4436:	68 10 00 00 00       	pushq  $0x10
    443b:	e9 e0 fe ff ff       	jmpq   4320 <.plt>

0000000000004440 <memcmp@plt>:
    4440:	ff 25 3a 19 23 00    	jmpq   *0x23193a(%rip)        # 235d80 <memcmp@GLIBC_2.2.5>
    4446:	68 11 00 00 00       	pushq  $0x11
    444b:	e9 d0 fe ff ff       	jmpq   4320 <.plt>

0000000000004450 <strncmp@plt>:
    4450:	ff 25 32 19 23 00    	jmpq   *0x231932(%rip)        # 235d88 <strncmp@GLIBC_2.2.5>
    4456:	68 12 00 00 00       	pushq  $0x12
    445b:	e9 c0 fe ff ff       	jmpq   4320 <.plt>

0000000000004460 <strncpy@plt>:
    4460:	ff 25 2a 19 23 00    	jmpq   *0x23192a(%rip)        # 235d90 <strncpy@GLIBC_2.2.5>
    4466:	68 13 00 00 00       	pushq  $0x13
    446b:	e9 b0 fe ff ff       	jmpq   4320 <.plt>

0000000000004470 <pthread_create@plt>:
    4470:	ff 25 22 19 23 00    	jmpq   *0x231922(%rip)        # 235d98 <pthread_create@GLIBC_2.2.5>
    4476:	68 14 00 00 00       	pushq  $0x14
    447b:	e9 a0 fe ff ff       	jmpq   4320 <.plt>

0000000000004480 <__strncpy_chk@plt>:
    4480:	ff 25 1a 19 23 00    	jmpq   *0x23191a(%rip)        # 235da0 <__strncpy_chk@GLIBC_2.3.4>
    4486:	68 15 00 00 00       	pushq  $0x15
    448b:	e9 90 fe ff ff       	jmpq   4320 <.plt>

0000000000004490 <SDL_PollEvent@plt>:
    4490:	ff 25 12 19 23 00    	jmpq   *0x231912(%rip)        # 235da8 <SDL_PollEvent>
    4496:	68 16 00 00 00       	pushq  $0x16
    449b:	e9 80 fe ff ff       	jmpq   4320 <.plt>

00000000000044a0 <__snprintf_chk@plt>:
    44a0:	ff 25 0a 19 23 00    	jmpq   *0x23190a(%rip)        # 235db0 <__snprintf_chk@GLIBC_2.3.4>
    44a6:	68 17 00 00 00       	pushq  $0x17
    44ab:	e9 70 fe ff ff       	jmpq   4320 <.plt>

00000000000044b0 <calloc@plt>:
    44b0:	ff 25 02 19 23 00    	jmpq   *0x231902(%rip)        # 235db8 <calloc@GLIBC_2.2.5>
    44b6:	68 18 00 00 00       	pushq  $0x18
    44bb:	e9 60 fe ff ff       	jmpq   4320 <.plt>

00000000000044c0 <mktime@plt>:
    44c0:	ff 25 fa 18 23 00    	jmpq   *0x2318fa(%rip)        # 235dc0 <mktime@GLIBC_2.2.5>
    44c6:	68 19 00 00 00       	pushq  $0x19
    44cb:	e9 50 fe ff ff       	jmpq   4320 <.plt>

00000000000044d0 <SDL_DestroyTexture@plt>:
    44d0:	ff 25 f2 18 23 00    	jmpq   *0x2318f2(%rip)        # 235dc8 <SDL_DestroyTexture>
    44d6:	68 1a 00 00 00       	pushq  $0x1a
    44db:	e9 40 fe ff ff       	jmpq   4320 <.plt>

00000000000044e0 <SDL_GetError@plt>:
    44e0:	ff 25 ea 18 23 00    	jmpq   *0x2318ea(%rip)        # 235dd0 <SDL_GetError>
    44e6:	68 1b 00 00 00       	pushq  $0x1b
    44eb:	e9 30 fe ff ff       	jmpq   4320 <.plt>

00000000000044f0 <SDL_UpdateTexture@plt>:
    44f0:	ff 25 e2 18 23 00    	jmpq   *0x2318e2(%rip)        # 235dd8 <SDL_UpdateTexture>
    44f6:	68 1c 00 00 00       	pushq  $0x1c
    44fb:	e9 20 fe ff ff       	jmpq   4320 <.plt>

0000000000004500 <sleep@plt>:
    4500:	ff 25 da 18 23 00    	jmpq   *0x2318da(%rip)        # 235de0 <sleep@GLIBC_2.2.5>
    4506:	68 1d 00 00 00       	pushq  $0x1d
    450b:	e9 10 fe ff ff       	jmpq   4320 <.plt>

0000000000004510 <pthread_mutex_unlock@plt>:
    4510:	ff 25 d2 18 23 00    	jmpq   *0x2318d2(%rip)        # 235de8 <pthread_mutex_unlock@GLIBC_2.2.5>
    4516:	68 1e 00 00 00       	pushq  $0x1e
    451b:	e9 00 fe ff ff       	jmpq   4320 <.plt>

0000000000004520 <strtod@plt>:
    4520:	ff 25 ca 18 23 00    	jmpq   *0x2318ca(%rip)        # 235df0 <strtod@GLIBC_2.2.5>
    4526:	68 1f 00 00 00       	pushq  $0x1f
    452b:	e9 f0 fd ff ff       	jmpq   4320 <.plt>

0000000000004530 <SDL_GetWindowFromID@plt>:
    4530:	ff 25 c2 18 23 00    	jmpq   *0x2318c2(%rip)        # 235df8 <SDL_GetWindowFromID>
    4536:	68 20 00 00 00       	pushq  $0x20
    453b:	e9 e0 fd ff ff       	jmpq   4320 <.plt>

0000000000004540 <strftime@plt>:
    4540:	ff 25 ba 18 23 00    	jmpq   *0x2318ba(%rip)        # 235e00 <strftime@GLIBC_2.2.5>
    4546:	68 21 00 00 00       	pushq  $0x21
    454b:	e9 d0 fd ff ff       	jmpq   4320 <.plt>

0000000000004550 <__vsnprintf_chk@plt>:
    4550:	ff 25 b2 18 23 00    	jmpq   *0x2318b2(%rip)        # 235e08 <__vsnprintf_chk@GLIBC_2.3.4>
    4556:	68 22 00 00 00       	pushq  $0x22
    455b:	e9 c0 fd ff ff       	jmpq   4320 <.plt>

0000000000004560 <__pthread_register_cancel@plt>:
    4560:	ff 25 aa 18 23 00    	jmpq   *0x2318aa(%rip)        # 235e10 <__pthread_register_cancel@GLIBC_2.3.3>
    4566:	68 23 00 00 00       	pushq  $0x23
    456b:	e9 b0 fd ff ff       	jmpq   4320 <.plt>

0000000000004570 <SDL_GetRenderer@plt>:
    4570:	ff 25 a2 18 23 00    	jmpq   *0x2318a2(%rip)        # 235e18 <SDL_GetRenderer>
    4576:	68 24 00 00 00       	pushq  $0x24
    457b:	e9 a0 fd ff ff       	jmpq   4320 <.plt>

0000000000004580 <SDL_RenderReadPixels@plt>:
    4580:	ff 25 9a 18 23 00    	jmpq   *0x23189a(%rip)        # 235e20 <SDL_RenderReadPixels>
    4586:	68 25 00 00 00       	pushq  $0x25
    458b:	e9 90 fd ff ff       	jmpq   4320 <.plt>

0000000000004590 <pthread_self@plt>:
    4590:	ff 25 92 18 23 00    	jmpq   *0x231892(%rip)        # 235e28 <pthread_self@GLIBC_2.2.5>
    4596:	68 26 00 00 00       	pushq  $0x26
    459b:	e9 80 fd ff ff       	jmpq   4320 <.plt>

00000000000045a0 <SDL_Init@plt>:
    45a0:	ff 25 8a 18 23 00    	jmpq   *0x23188a(%rip)        # 235e30 <SDL_Init>
    45a6:	68 27 00 00 00       	pushq  $0x27
    45ab:	e9 70 fd ff ff       	jmpq   4320 <.plt>

00000000000045b0 <__pthread_unwind_next@plt>:
    45b0:	ff 25 82 18 23 00    	jmpq   *0x231882(%rip)        # 235e38 <__pthread_unwind_next@GLIBC_2.3.3>
    45b6:	68 28 00 00 00       	pushq  $0x28
    45bb:	e9 60 fd ff ff       	jmpq   4320 <.plt>

00000000000045c0 <clock_gettime@plt>:
    45c0:	ff 25 7a 18 23 00    	jmpq   *0x23187a(%rip)        # 235e40 <clock_gettime@GLIBC_2.17>
    45c6:	68 29 00 00 00       	pushq  $0x29
    45cb:	e9 50 fd ff ff       	jmpq   4320 <.plt>

00000000000045d0 <strcpy@plt>:
    45d0:	ff 25 72 18 23 00    	jmpq   *0x231872(%rip)        # 235e48 <strcpy@GLIBC_2.2.5>
    45d6:	68 2a 00 00 00       	pushq  $0x2a
    45db:	e9 40 fd ff ff       	jmpq   4320 <.plt>

00000000000045e0 <SDL_RenderClear@plt>:
    45e0:	ff 25 6a 18 23 00    	jmpq   *0x23186a(%rip)        # 235e50 <SDL_RenderClear>
    45e6:	68 2b 00 00 00       	pushq  $0x2b
    45eb:	e9 30 fd ff ff       	jmpq   4320 <.plt>

00000000000045f0 <__isoc99_sscanf@plt>:
    45f0:	ff 25 62 18 23 00    	jmpq   *0x231862(%rip)        # 235e58 <__isoc99_sscanf@GLIBC_2.7>
    45f6:	68 2c 00 00 00       	pushq  $0x2c
    45fb:	e9 20 fd ff ff       	jmpq   4320 <.plt>

0000000000004600 <pthread_detach@plt>:
    4600:	ff 25 5a 18 23 00    	jmpq   *0x23185a(%rip)        # 235e60 <pthread_detach@GLIBC_2.2.5>
    4606:	68 2d 00 00 00       	pushq  $0x2d
    460b:	e9 10 fd ff ff       	jmpq   4320 <.plt>

0000000000004610 <__ctype_b_loc@plt>:
    4610:	ff 25 52 18 23 00    	jmpq   *0x231852(%rip)        # 235e68 <__ctype_b_loc@GLIBC_2.3>
    4616:	68 2e 00 00 00       	pushq  $0x2e
    461b:	e9 00 fd ff ff       	jmpq   4320 <.plt>

0000000000004620 <strcasecmp@plt>:
    4620:	ff 25 4a 18 23 00    	jmpq   *0x23184a(%rip)        # 235e70 <strcasecmp@GLIBC_2.2.5>
    4626:	68 2f 00 00 00       	pushq  $0x2f
    462b:	e9 f0 fc ff ff       	jmpq   4320 <.plt>

0000000000004630 <SDL_AddEventWatch@plt>:
    4630:	ff 25 42 18 23 00    	jmpq   *0x231842(%rip)        # 235e78 <SDL_AddEventWatch>
    4636:	68 30 00 00 00       	pushq  $0x30
    463b:	e9 e0 fc ff ff       	jmpq   4320 <.plt>

0000000000004640 <__stack_chk_fail@plt>:
    4640:	ff 25 3a 18 23 00    	jmpq   *0x23183a(%rip)        # 235e80 <__stack_chk_fail@GLIBC_2.4>
    4646:	68 31 00 00 00       	pushq  $0x31
    464b:	e9 d0 fc ff ff       	jmpq   4320 <.plt>

0000000000004650 <SDL_RenderCopy@plt>:
    4650:	ff 25 32 18 23 00    	jmpq   *0x231832(%rip)        # 235e88 <SDL_RenderCopy>
    4656:	68 32 00 00 00       	pushq  $0x32
    465b:	e9 c0 fc ff ff       	jmpq   4320 <.plt>

0000000000004660 <free@plt>:
    4660:	ff 25 2a 18 23 00    	jmpq   *0x23182a(%rip)        # 235e90 <free@GLIBC_2.2.5>
    4666:	68 33 00 00 00       	pushq  $0x33
    466b:	e9 b0 fc ff ff       	jmpq   4320 <.plt>

0000000000004670 <exit@plt>:
    4670:	ff 25 22 18 23 00    	jmpq   *0x231822(%rip)        # 235e98 <exit@GLIBC_2.2.5>
    4676:	68 34 00 00 00       	pushq  $0x34
    467b:	e9 a0 fc ff ff       	jmpq   4320 <.plt>

0000000000004680 <sigemptyset@plt>:
    4680:	ff 25 1a 18 23 00    	jmpq   *0x23181a(%rip)        # 235ea0 <sigemptyset@GLIBC_2.2.5>
    4686:	68 35 00 00 00       	pushq  $0x35
    468b:	e9 90 fc ff ff       	jmpq   4320 <.plt>

0000000000004690 <sigaction@plt>:
    4690:	ff 25 12 18 23 00    	jmpq   *0x231812(%rip)        # 235ea8 <sigaction@GLIBC_2.2.5>
    4696:	68 36 00 00 00       	pushq  $0x36
    469b:	e9 80 fc ff ff       	jmpq   4320 <.plt>

00000000000046a0 <strtoull@plt>:
    46a0:	ff 25 0a 18 23 00    	jmpq   *0x23180a(%rip)        # 235eb0 <strtoull@GLIBC_2.2.5>
    46a6:	68 37 00 00 00       	pushq  $0x37
    46ab:	e9 70 fc ff ff       	jmpq   4320 <.plt>

00000000000046b0 <strcmp@plt>:
    46b0:	ff 25 02 18 23 00    	jmpq   *0x231802(%rip)        # 235eb8 <strcmp@GLIBC_2.2.5>
    46b6:	68 38 00 00 00       	pushq  $0x38
    46bb:	e9 60 fc ff ff       	jmpq   4320 <.plt>

00000000000046c0 <strtol@plt>:
    46c0:	ff 25 fa 17 23 00    	jmpq   *0x2317fa(%rip)        # 235ec0 <strtol@GLIBC_2.2.5>
    46c6:	68 39 00 00 00       	pushq  $0x39
    46cb:	e9 50 fc ff ff       	jmpq   4320 <.plt>

00000000000046d0 <SDL_SetRenderDrawColor@plt>:
    46d0:	ff 25 f2 17 23 00    	jmpq   *0x2317f2(%rip)        # 235ec8 <SDL_SetRenderDrawColor>
    46d6:	68 3a 00 00 00       	pushq  $0x3a
    46db:	e9 40 fc ff ff       	jmpq   4320 <.plt>

00000000000046e0 <__sigsetjmp@plt>:
    46e0:	ff 25 ea 17 23 00    	jmpq   *0x2317ea(%rip)        # 235ed0 <__sigsetjmp@GLIBC_2.2.5>
    46e6:	68 3b 00 00 00       	pushq  $0x3b
    46eb:	e9 30 fc ff ff       	jmpq   4320 <.plt>

00000000000046f0 <read@plt>:
    46f0:	ff 25 e2 17 23 00    	jmpq   *0x2317e2(%rip)        # 235ed8 <read@GLIBC_2.2.5>
    46f6:	68 3c 00 00 00       	pushq  $0x3c
    46fb:	e9 20 fc ff ff       	jmpq   4320 <.plt>

0000000000004700 <pthread_mutex_lock@plt>:
    4700:	ff 25 da 17 23 00    	jmpq   *0x2317da(%rip)        # 235ee0 <pthread_mutex_lock@GLIBC_2.2.5>
    4706:	68 3d 00 00 00       	pushq  $0x3d
    470b:	e9 10 fc ff ff       	jmpq   4320 <.plt>

0000000000004710 <poll@plt>:
    4710:	ff 25 d2 17 23 00    	jmpq   *0x2317d2(%rip)        # 235ee8 <poll@GLIBC_2.2.5>
    4716:	68 3e 00 00 00       	pushq  $0x3e
    471b:	e9 00 fc ff ff       	jmpq   4320 <.plt>

0000000000004720 <pthread_cond_wait@plt>:
    4720:	ff 25 ca 17 23 00    	jmpq   *0x2317ca(%rip)        # 235ef0 <pthread_cond_wait@GLIBC_2.3.2>
    4726:	68 3f 00 00 00       	pushq  $0x3f
    472b:	e9 f0 fb ff ff       	jmpq   4320 <.plt>

0000000000004730 <strnlen@plt>:
    4730:	ff 25 c2 17 23 00    	jmpq   *0x2317c2(%rip)        # 235ef8 <strnlen@GLIBC_2.2.5>
    4736:	68 40 00 00 00       	pushq  $0x40
    473b:	e9 e0 fb ff ff       	jmpq   4320 <.plt>

0000000000004740 <snprintf@plt>:
    4740:	ff 25 ba 17 23 00    	jmpq   *0x2317ba(%rip)        # 235f00 <snprintf@GLIBC_2.2.5>
    4746:	68 41 00 00 00       	pushq  $0x41
    474b:	e9 d0 fb ff ff       	jmpq   4320 <.plt>

0000000000004750 <realloc@plt>:
    4750:	ff 25 b2 17 23 00    	jmpq   *0x2317b2(%rip)        # 235f08 <realloc@GLIBC_2.2.5>
    4756:	68 42 00 00 00       	pushq  $0x42
    475b:	e9 c0 fb ff ff       	jmpq   4320 <.plt>

0000000000004760 <__fprintf_chk@plt>:
    4760:	ff 25 aa 17 23 00    	jmpq   *0x2317aa(%rip)        # 235f10 <__fprintf_chk@GLIBC_2.3.4>
    4766:	68 43 00 00 00       	pushq  $0x43
    476b:	e9 b0 fb ff ff       	jmpq   4320 <.plt>

0000000000004770 <__memcpy_chk@plt>:
    4770:	ff 25 a2 17 23 00    	jmpq   *0x2317a2(%rip)        # 235f18 <__memcpy_chk@GLIBC_2.3.4>
    4776:	68 44 00 00 00       	pushq  $0x44
    477b:	e9 a0 fb ff ff       	jmpq   4320 <.plt>

0000000000004780 <isatty@plt>:
    4780:	ff 25 9a 17 23 00    	jmpq   *0x23179a(%rip)        # 235f20 <isatty@GLIBC_2.2.5>
    4786:	68 45 00 00 00       	pushq  $0x45
    478b:	e9 90 fb ff ff       	jmpq   4320 <.plt>

0000000000004790 <pthread_exit@plt>:
    4790:	ff 25 92 17 23 00    	jmpq   *0x231792(%rip)        # 235f28 <pthread_exit@GLIBC_2.2.5>
    4796:	68 46 00 00 00       	pushq  $0x46
    479b:	e9 80 fb ff ff       	jmpq   4320 <.plt>

00000000000047a0 <SDL_CreateTexture@plt>:
    47a0:	ff 25 8a 17 23 00    	jmpq   *0x23178a(%rip)        # 235f30 <SDL_CreateTexture>
    47a6:	68 47 00 00 00       	pushq  $0x47
    47ab:	e9 70 fb ff ff       	jmpq   4320 <.plt>

00000000000047b0 <close@plt>:
    47b0:	ff 25 82 17 23 00    	jmpq   *0x231782(%rip)        # 235f38 <close@GLIBC_2.2.5>
    47b6:	68 48 00 00 00       	pushq  $0x48
    47bb:	e9 60 fb ff ff       	jmpq   4320 <.plt>

Disassembly of section .plt.got:

00000000000047c0 <__cxa_finalize@plt>:
    47c0:	ff 25 92 17 23 00    	jmpq   *0x231792(%rip)        # 235f58 <__cxa_finalize@GLIBC_2.2.5>
    47c6:	66 90                	xchg   %ax,%ax

Disassembly of section .text:

00000000000047d0 <_start>:
    47d0:	31 ed                	xor    %ebp,%ebp
    47d2:	49 89 d1             	mov    %rdx,%r9
    47d5:	5e                   	pop    %rsi
    47d6:	48 89 e2             	mov    %rsp,%rdx
    47d9:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
    47dd:	50                   	push   %rax
    47de:	54                   	push   %rsp
    47df:	4c 8d 05 6a 01 00 00 	lea    0x16a(%rip),%r8        # 4950 <__libc_csu_fini>
    47e6:	48 8d 0d f3 00 00 00 	lea    0xf3(%rip),%rcx        # 48e0 <__libc_csu_init>
    47ed:	48 8d 3d 15 7a 00 00 	lea    0x7a15(%rip),%rdi        # c209 <main>
    47f4:	ff 15 e6 17 23 00    	callq  *0x2317e6(%rip)        # 235fe0 <__libc_start_main@GLIBC_2.2.5>
    47fa:	f4                   	hlt    
    47fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000004800 <deregister_tm_clones>:
    4800:	48 8d 3d 19 23 23 00 	lea    0x232319(%rip),%rdi        # 236b20 <logging_stack>
    4807:	55                   	push   %rbp
    4808:	48 8d 05 11 23 23 00 	lea    0x232311(%rip),%rax        # 236b20 <logging_stack>
    480f:	48 39 f8             	cmp    %rdi,%rax
    4812:	48 89 e5             	mov    %rsp,%rbp
    4815:	74 19                	je     4830 <deregister_tm_clones+0x30>
    4817:	48 8b 05 a2 17 23 00 	mov    0x2317a2(%rip),%rax        # 235fc0 <_ITM_deregisterTMCloneTable>
    481e:	48 85 c0             	test   %rax,%rax
    4821:	74 0d                	je     4830 <deregister_tm_clones+0x30>
    4823:	5d                   	pop    %rbp
    4824:	ff e0                	jmpq   *%rax
    4826:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    482d:	00 00 00 
    4830:	5d                   	pop    %rbp
    4831:	c3                   	retq   
    4832:	0f 1f 40 00          	nopl   0x0(%rax)
    4836:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    483d:	00 00 00 

0000000000004840 <register_tm_clones>:
    4840:	48 8d 3d d9 22 23 00 	lea    0x2322d9(%rip),%rdi        # 236b20 <logging_stack>
    4847:	48 8d 35 d2 22 23 00 	lea    0x2322d2(%rip),%rsi        # 236b20 <logging_stack>
    484e:	55                   	push   %rbp
    484f:	48 29 fe             	sub    %rdi,%rsi
    4852:	48 89 e5             	mov    %rsp,%rbp
    4855:	48 c1 fe 03          	sar    $0x3,%rsi
    4859:	48 89 f0             	mov    %rsi,%rax
    485c:	48 c1 e8 3f          	shr    $0x3f,%rax
    4860:	48 01 c6             	add    %rax,%rsi
    4863:	48 d1 fe             	sar    %rsi
    4866:	74 18                	je     4880 <register_tm_clones+0x40>
    4868:	48 8b 05 81 17 23 00 	mov    0x231781(%rip),%rax        # 235ff0 <_ITM_registerTMCloneTable>
    486f:	48 85 c0             	test   %rax,%rax
    4872:	74 0c                	je     4880 <register_tm_clones+0x40>
    4874:	5d                   	pop    %rbp
    4875:	ff e0                	jmpq   *%rax
    4877:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    487e:	00 00 
    4880:	5d                   	pop    %rbp
    4881:	c3                   	retq   
    4882:	0f 1f 40 00          	nopl   0x0(%rax)
    4886:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    488d:	00 00 00 

0000000000004890 <__do_global_dtors_aux>:
    4890:	80 3d 49 a8 25 00 00 	cmpb   $0x0,0x25a849(%rip)        # 25f0e0 <completed.7698>
    4897:	75 2f                	jne    48c8 <__do_global_dtors_aux+0x38>
    4899:	48 83 3d b7 16 23 00 	cmpq   $0x0,0x2316b7(%rip)        # 235f58 <__cxa_finalize@GLIBC_2.2.5>
    48a0:	00 
    48a1:	55                   	push   %rbp
    48a2:	48 89 e5             	mov    %rsp,%rbp
    48a5:	74 0c                	je     48b3 <__do_global_dtors_aux+0x23>
    48a7:	48 8b 3d 92 21 23 00 	mov    0x232192(%rip),%rdi        # 236a40 <__dso_handle>
    48ae:	e8 0d ff ff ff       	callq  47c0 <__cxa_finalize@plt>
    48b3:	e8 48 ff ff ff       	callq  4800 <deregister_tm_clones>
    48b8:	c6 05 21 a8 25 00 01 	movb   $0x1,0x25a821(%rip)        # 25f0e0 <completed.7698>
    48bf:	5d                   	pop    %rbp
    48c0:	c3                   	retq   
    48c1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    48c8:	f3 c3                	repz retq 
    48ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000000048d0 <frame_dummy>:
    48d0:	55                   	push   %rbp
    48d1:	48 89 e5             	mov    %rsp,%rbp
    48d4:	5d                   	pop    %rbp
    48d5:	e9 66 ff ff ff       	jmpq   4840 <register_tm_clones>
    48da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000000048e0 <__libc_csu_init>:
    48e0:	41 57                	push   %r15
    48e2:	41 56                	push   %r14
    48e4:	49 89 d7             	mov    %rdx,%r15
    48e7:	41 55                	push   %r13
    48e9:	41 54                	push   %r12
    48eb:	4c 8d 25 5e 08 23 00 	lea    0x23085e(%rip),%r12        # 235150 <__frame_dummy_init_array_entry>
    48f2:	55                   	push   %rbp
    48f3:	48 8d 2d 5e 08 23 00 	lea    0x23085e(%rip),%rbp        # 235158 <__init_array_end>
    48fa:	53                   	push   %rbx
    48fb:	41 89 fd             	mov    %edi,%r13d
    48fe:	49 89 f6             	mov    %rsi,%r14
    4901:	4c 29 e5             	sub    %r12,%rbp
    4904:	48 83 ec 08          	sub    $0x8,%rsp
    4908:	48 c1 fd 03          	sar    $0x3,%rbp
    490c:	e8 ef f9 ff ff       	callq  4300 <_init>
    4911:	48 85 ed             	test   %rbp,%rbp
    4914:	74 20                	je     4936 <__libc_csu_init+0x56>
    4916:	31 db                	xor    %ebx,%ebx
    4918:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    491f:	00 
    4920:	4c 89 fa             	mov    %r15,%rdx
    4923:	4c 89 f6             	mov    %r14,%rsi
    4926:	44 89 ef             	mov    %r13d,%edi
    4929:	41 ff 14 dc          	callq  *(%r12,%rbx,8)
    492d:	48 83 c3 01          	add    $0x1,%rbx
    4931:	48 39 dd             	cmp    %rbx,%rbp
    4934:	75 ea                	jne    4920 <__libc_csu_init+0x40>
    4936:	48 83 c4 08          	add    $0x8,%rsp
    493a:	5b                   	pop    %rbx
    493b:	5d                   	pop    %rbp
    493c:	41 5c                	pop    %r12
    493e:	41 5d                	pop    %r13
    4940:	41 5e                	pop    %r14
    4942:	41 5f                	pop    %r15
    4944:	c3                   	retq   
    4945:	90                   	nop
    4946:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    494d:	00 00 00 

0000000000004950 <__libc_csu_fini>:
    4950:	f3 c3                	repz retq 

0000000000004952 <le_param_req>:
}

static bool le_param_req(struct bt_conn *conn, struct bt_le_conn_param *param)
{
	return true;
}
    4952:	b0 01                	mov    $0x1,%al
    4954:	c3                   	retq   

0000000000004955 <le_param_updated>:

static void le_param_updated(struct bt_conn *conn, uint16_t interval, uint16_t latency, uint16_t timeout)
{

}
    4955:	c3                   	retq   

0000000000004956 <disconnected>:
{
    4956:	48 83 ec 08          	sub    $0x8,%rsp
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    495a:	48 8d 15 ff 59 23 00 	lea    0x2359ff(%rip),%rdx        # 23a360 <_settings_handler_static_list_end>
    4961:	48 2b 15 e8 15 23 00 	sub    0x2315e8(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
	LOG_INF("disconnected (reason: %u)", reason);
    4968:	48 8d 3d dd c4 02 00 	lea    0x2c4dd(%rip),%rdi        # 30e4c <__func__.5785+0x1e4>
    496f:	40 0f b6 f6          	movzbl %sil,%esi
    4973:	48 c1 ea 04          	shr    $0x4,%rdx
    4977:	c1 e2 06             	shl    $0x6,%edx
    497a:	83 ca 03             	or     $0x3,%edx
    497d:	e8 73 29 00 00       	callq  72f5 <log_1>
}
    4982:	58                   	pop    %rax
	cts_sync_enable(false);
    4983:	31 ff                	xor    %edi,%edi
    4985:	e9 37 06 00 00       	jmpq   4fc1 <cts_sync_enable>

000000000000498a <connected>:
{
    498a:	53                   	push   %rbx
	printk("test\n");
    498b:	48 8d 3d d4 c4 02 00 	lea    0x2c4d4(%rip),%rdi        # 30e66 <__func__.5785+0x1fe>
{
    4992:	89 f3                	mov    %esi,%ebx
	printk("test\n");
    4994:	31 c0                	xor    %eax,%eax
    4996:	e8 f5 0f 00 00       	callq  5990 <printk>
	if (err) {
    499b:	84 db                	test   %bl,%bl
    499d:	75 34                	jne    49d3 <connected+0x49>
    499f:	48 8d 35 ba 59 23 00 	lea    0x2359ba(%rip),%rsi        # 23a360 <_settings_handler_static_list_end>
    49a6:	48 2b 35 a3 15 23 00 	sub    0x2315a3(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
	LOG_INF("connected");
    49ad:	48 8d 3d a0 e3 02 00 	lea    0x2e3a0(%rip),%rdi        # 32d54 <__func__.5785+0x20ec>
    49b4:	48 c1 ee 04          	shr    $0x4,%rsi
    49b8:	c1 e6 06             	shl    $0x6,%esi
    49bb:	83 ce 03             	or     $0x3,%esi
    49be:	e8 01 29 00 00       	callq  72c4 <log_0>
	cts_sync_enable(true);
    49c3:	bf 01 00 00 00       	mov    $0x1,%edi
    49c8:	e8 f4 05 00 00       	callq  4fc1 <cts_sync_enable>
}
    49cd:	5b                   	pop    %rbx
	clock_show_time();
    49ce:	e9 bf 02 00 00       	jmpq   4c92 <clock_show_time>
}
    49d3:	5b                   	pop    %rbx
    49d4:	c3                   	retq   

00000000000049d5 <advertise>:
{
    49d5:	48 83 ec 08          	sub    $0x8,%rsp
	bt_le_adv_stop();
    49d9:	e8 3a bd 00 00       	callq  10718 <bt_le_adv_stop>
	rc = bt_le_adv_start(&param, ad, ARRAY_SIZE(ad), NULL, 0);
    49de:	48 8d 35 7b 07 23 00 	lea    0x23077b(%rip),%rsi        # 235160 <ad>
    49e5:	48 8d 3d 64 1f 23 00 	lea    0x231f64(%rip),%rdi        # 236950 <param>
    49ec:	45 31 c0             	xor    %r8d,%r8d
    49ef:	31 c9                	xor    %ecx,%ecx
    49f1:	ba 03 00 00 00       	mov    $0x3,%edx
    49f6:	e8 fe bc 00 00       	callq  106f9 <bt_le_adv_start>
    49fb:	48 8d 15 5e 59 23 00 	lea    0x23595e(%rip),%rdx        # 23a360 <_settings_handler_static_list_end>
    4a02:	48 2b 15 47 15 23 00 	sub    0x231547(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
    4a09:	48 c1 ea 04          	shr    $0x4,%rdx
    4a0d:	66 81 e2 ff 03       	and    $0x3ff,%dx
		LOG_ERR("Advertising failed to start (rc %d)", rc);
    4a12:	c1 e2 06             	shl    $0x6,%edx
	if (rc) {
    4a15:	85 c0                	test   %eax,%eax
    4a17:	74 13                	je     4a2c <advertise+0x57>
}
    4a19:	59                   	pop    %rcx
		LOG_ERR("Advertising failed to start (rc %d)", rc);
    4a1a:	48 8d 3d 4b c4 02 00 	lea    0x2c44b(%rip),%rdi        # 30e6c <__func__.5785+0x204>
    4a21:	83 ca 01             	or     $0x1,%edx
    4a24:	48 63 f0             	movslq %eax,%rsi
    4a27:	e9 c9 28 00 00       	jmpq   72f5 <log_1>
}
    4a2c:	58                   	pop    %rax
	LOG_INF("Advertising successfully started");
    4a2d:	89 d6                	mov    %edx,%esi
    4a2f:	48 8d 3d 5a c4 02 00 	lea    0x2c45a(%rip),%rdi        # 30e90 <__func__.5785+0x228>
    4a36:	83 ce 03             	or     $0x3,%esi
    4a39:	e9 86 28 00 00       	jmpq   72c4 <log_0>

0000000000004a3e <bt_init>:

void bt_init(void)
{
    4a3e:	53                   	push   %rbx
	int err = bt_enable(NULL);
    4a3f:	31 ff                	xor    %edi,%edi
    4a41:	e8 a4 b2 00 00       	callq  fcea <bt_enable>
    4a46:	48 8d 1d 13 59 23 00 	lea    0x235913(%rip),%rbx        # 23a360 <_settings_handler_static_list_end>
    4a4d:	48 2b 1d fc 14 23 00 	sub    0x2314fc(%rip),%rbx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
    4a54:	48 c1 eb 04          	shr    $0x4,%rbx
    4a58:	66 81 e3 ff 03       	and    $0x3ff,%bx
	if (err) {
    4a5d:	85 c0                	test   %eax,%eax
    4a5f:	74 18                	je     4a79 <bt_init+0x3b>
		LOG_ERR("Bluetooth init failed (err %d)", err);
    4a61:	89 da                	mov    %ebx,%edx
    4a63:	48 8d 3d 47 c4 02 00 	lea    0x2c447(%rip),%rdi        # 30eb1 <__func__.5785+0x249>
    4a6a:	48 63 f0             	movslq %eax,%rsi
#endif
	cts_sync_init();

	LOG_INF("Bluetooth initialized"); //jj
	LOG_DBG("Bluetooth initialized");
}
    4a6d:	5b                   	pop    %rbx
		LOG_ERR("Bluetooth init failed (err %d)", err);
    4a6e:	c1 e2 06             	shl    $0x6,%edx
    4a71:	83 ca 01             	or     $0x1,%edx
    4a74:	e9 7c 28 00 00       	jmpq   72f5 <log_1>
	settings_load();
    4a79:	e8 f1 39 00 00       	callq  846f <settings_load>
	settings_runtime_set("bt/dis/sw",
    4a7e:	48 8d 35 4b c4 02 00 	lea    0x2c44b(%rip),%rsi        # 30ed0 <__func__.5785+0x268>
    4a85:	48 8d 3d 4d c4 02 00 	lea    0x2c44d(%rip),%rdi        # 30ed9 <__func__.5785+0x271>
    4a8c:	ba 09 00 00 00       	mov    $0x9,%edx
    4a91:	e8 1e 3d 00 00       	callq  87b4 <settings_runtime_set>
	settings_runtime_set("bt/dis/fw",
    4a96:	48 8d 35 e4 d5 02 00 	lea    0x2d5e4(%rip),%rsi        # 32081 <__func__.5785+0x1419>
    4a9d:	48 8d 3d 3f c4 02 00 	lea    0x2c43f(%rip),%rdi        # 30ee3 <__func__.5785+0x27b>
    4aa4:	ba 01 00 00 00       	mov    $0x1,%edx
    4aa9:	e8 06 3d 00 00       	callq  87b4 <settings_runtime_set>
 *
 * @return N/A
 */
static inline void k_work_init(struct k_work *work, k_work_handler_t handler)
{
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    4aae:	48 8d 05 20 ff ff ff 	lea    -0xe0(%rip),%rax        # 49d5 <advertise>
	bt_conn_cb_register(&m_conn_callbacks);
    4ab5:	48 8d 3d 44 15 23 00 	lea    0x231544(%rip),%rdi        # 236000 <m_conn_callbacks>
    4abc:	48 c7 05 99 31 25 00 	movq   $0x0,0x253199(%rip)        # 257c60 <advertise_work>
    4ac3:	00 00 00 00 
    4ac7:	c7 05 9f 31 25 00 00 	movl   $0x0,0x25319f(%rip)        # 257c70 <advertise_work+0x10>
    4ace:	00 00 00 
    4ad1:	48 89 05 90 31 25 00 	mov    %rax,0x253190(%rip)        # 257c68 <advertise_work+0x8>
    4ad8:	e8 8a c7 00 00       	callq  11267 <bt_conn_cb_register>
		LOG_INF("bt init callback started\n");
    4add:	89 de                	mov    %ebx,%esi
    4adf:	48 8d 3d 07 c4 02 00 	lea    0x2c407(%rip),%rdi        # 30eed <__func__.5785+0x285>
    4ae6:	c1 e6 06             	shl    $0x6,%esi
    4ae9:	83 ce 03             	or     $0x3,%esi
    4aec:	e8 d3 27 00 00       	callq  72c4 <log_0>
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    4af1:	8b 05 79 31 25 00    	mov    0x253179(%rip),%eax        # 257c70 <advertise_work+0x10>
    4af7:	89 c1                	mov    %eax,%ecx
    4af9:	89 c2                	mov    %eax,%edx
    4afb:	83 c9 01             	or     $0x1,%ecx
    4afe:	f0 0f b1 0d 6a 31 25 	lock cmpxchg %ecx,0x25316a(%rip)        # 257c70 <advertise_work+0x10>
    4b05:	00 
    4b06:	75 ef                	jne    4af7 <bt_init+0xb9>
 * @return N/A
 */
static inline void k_work_submit_to_queue(struct k_work_q *work_q,
					  struct k_work *work)
{
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    4b08:	80 e2 01             	and    $0x1,%dl
    4b0b:	75 13                	jne    4b20 <bt_init+0xe2>
		k_queue_append(&work_q->queue, work);
    4b0d:	48 8d 3d 8c 30 25 00 	lea    0x25308c(%rip),%rdi        # 257ba0 <k_sys_work_q>
    4b14:	48 8d 35 45 31 25 00 	lea    0x253145(%rip),%rsi        # 257c60 <advertise_work>
    4b1b:	e8 0b 68 02 00       	callq  2b32b <k_queue_append>
	LOG_INF("Bluetooth initialized"); //jj
    4b20:	c1 e3 06             	shl    $0x6,%ebx
	cts_sync_init();
    4b23:	e8 5b 04 00 00       	callq  4f83 <cts_sync_init>
	LOG_INF("Bluetooth initialized"); //jj
    4b28:	89 de                	mov    %ebx,%esi
    4b2a:	48 8d 3d d6 c3 02 00 	lea    0x2c3d6(%rip),%rdi        # 30f07 <__func__.5785+0x29f>
}
    4b31:	5b                   	pop    %rbx
	LOG_INF("Bluetooth initialized"); //jj
    4b32:	83 ce 03             	or     $0x3,%esi
    4b35:	e9 8a 27 00 00       	jmpq   72c4 <log_0>

0000000000004b3a <clock_str_to_local_time>:
};

/* ********** ********** FUNCTIONS *********** ********** */
void clock_str_to_local_time(const char *str)
{
	if (sscanf(str, "%d-%d-%dT%d:%d:%d", &ti.tm_year, &ti.tm_mon,
    4b3a:	48 8d 05 3f 5e 23 00 	lea    0x235e3f(%rip),%rax        # 23a980 <ti>
{
    4b41:	48 83 ec 08          	sub    $0x8,%rsp
	if (sscanf(str, "%d-%d-%dT%d:%d:%d", &ti.tm_year, &ti.tm_mon,
    4b45:	48 8d 35 d1 c3 02 00 	lea    0x2c3d1(%rip),%rsi        # 30f1d <__func__.5785+0x2b5>
    4b4c:	50                   	push   %rax
    4b4d:	48 83 c0 04          	add    $0x4,%rax
    4b51:	50                   	push   %rax
    4b52:	48 8d 48 0c          	lea    0xc(%rax),%rcx
    4b56:	48 8d 50 10          	lea    0x10(%rax),%rdx
    4b5a:	4c 8d 48 04          	lea    0x4(%rax),%r9
    4b5e:	4c 8d 40 08          	lea    0x8(%rax),%r8
    4b62:	31 c0                	xor    %eax,%eax
    4b64:	e8 87 fa ff ff       	callq  45f0 <__isoc99_sscanf@plt>
    4b69:	83 f8 06             	cmp    $0x6,%eax
    4b6c:	5a                   	pop    %rdx
    4b6d:	59                   	pop    %rcx
    4b6e:	74 24                	je     4b94 <clock_str_to_local_time+0x5a>
    4b70:	48 8d 35 e9 57 23 00 	lea    0x2357e9(%rip),%rsi        # 23a360 <_settings_handler_static_list_end>
    4b77:	48 2b 35 d2 13 23 00 	sub    0x2313d2(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		   &ti.tm_mday, &ti.tm_hour, &ti.tm_min, &ti.tm_sec) != 6) {
		LOG_ERR("Failed to parse time of build.");
    4b7e:	48 8d 3d aa c3 02 00 	lea    0x2c3aa(%rip),%rdi        # 30f2f <__func__.5785+0x2c7>
    4b85:	48 c1 ee 04          	shr    $0x4,%rsi
    4b89:	c1 e6 06             	shl    $0x6,%esi
    4b8c:	83 ce 01             	or     $0x1,%esi
    4b8f:	e8 30 27 00 00       	callq  72c4 <log_0>
	}
	ti.tm_year-=1900;
    4b94:	81 2d f6 5d 23 00 6c 	subl   $0x76c,0x235df6(%rip)        # 23a994 <ti+0x14>
    4b9b:	07 00 00 
	ti.tm_mon-=1;
    4b9e:	ff 0d ec 5d 23 00    	decl   0x235dec(%rip)        # 23a990 <ti+0x10>
	mktime(&ti);
    4ba4:	48 8d 3d d5 5d 23 00 	lea    0x235dd5(%rip),%rdi        # 23a980 <ti>
}
    4bab:	58                   	pop    %rax
	mktime(&ti);
    4bac:	e9 0f f9 ff ff       	jmpq   44c0 <mktime@plt>

0000000000004bb1 <clock_init>:

void clock_init()
{
	/* Set time to time of build */
	clock_str_to_local_time(TIME_OF_BUILD);
    4bb1:	48 8d 3d 96 c3 02 00 	lea    0x2c396(%rip),%rdi        # 30f4e <__func__.5785+0x2e6>
    4bb8:	e9 7d ff ff ff       	jmpq   4b3a <clock_str_to_local_time>

0000000000004bbd <clock_update_elapsed_ms>:
	LOG_DBG("Time set to time of build");
	LOG_DBG("Clock init: Done");
}

void clock_update_elapsed_ms()
{
    4bbd:	48 83 ec 08          	sub    $0x8,%rsp
	if (z_syscall_trap()) {
		return (int64_t) arch_syscall_invoke0(K_SYSCALL_K_UPTIME_TICKS);
	}
#endif
	compiler_barrier();
	return z_impl_k_uptime_ticks();
    4bc1:	31 c0                	xor    %eax,%eax
    4bc3:	e8 eb 7b 02 00       	callq  2c7b3 <z_impl_k_uptime_ticks>
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
		} else {
			return t * (to_hz / from_hz);
    4bc8:	48 6b c0 0a          	imul   $0xa,%rax,%rax
    4bcc:	48 8d 35 8d 57 23 00 	lea    0x23578d(%rip),%rsi        # 23a360 <_settings_handler_static_list_end>
    4bd3:	48 2b 35 76 13 23 00 	sub    0x231376(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
	uptime_ms = k_uptime_get();
	elapsed_ms = uptime_ms - last_uptime_ms;
	last_uptime_ms = uptime_ms;
	LOG_INF("Clock updated: "); //jj
    4bda:	48 8d 3d 81 c3 02 00 	lea    0x2c381(%rip),%rdi        # 30f62 <__func__.5785+0x2fa>
	elapsed_ms = uptime_ms - last_uptime_ms;
    4be1:	48 89 c2             	mov    %rax,%rdx
    4be4:	48 2b 15 6d 32 25 00 	sub    0x25326d(%rip),%rdx        # 257e58 <last_uptime_ms>
	last_uptime_ms = uptime_ms;
    4beb:	48 89 05 66 32 25 00 	mov    %rax,0x253266(%rip)        # 257e58 <last_uptime_ms>
    4bf2:	48 c1 ee 04          	shr    $0x4,%rsi
	LOG_INF("Clock updated: "); //jj
    4bf6:	c1 e6 06             	shl    $0x6,%esi
    4bf9:	83 ce 03             	or     $0x3,%esi
	elapsed_ms = uptime_ms - last_uptime_ms;
    4bfc:	48 89 15 4d 32 25 00 	mov    %rdx,0x25324d(%rip)        # 257e50 <elapsed_ms>
}
    4c03:	58                   	pop    %rax
	LOG_INF("Clock updated: "); //jj
    4c04:	e9 bb 26 00 00       	jmpq   72c4 <log_0>

0000000000004c09 <clock_sync_time>:

/* Called by cts sync */
void clock_sync_time(cts_datetime_t *cts)
{
    4c09:	48 83 ec 08          	sub    $0x8,%rsp
	ti.tm_year = cts->year -1900;
    4c0d:	0f b7 07             	movzwl (%rdi),%eax
    4c10:	2d 6c 07 00 00       	sub    $0x76c,%eax
    4c15:	89 05 79 5d 23 00    	mov    %eax,0x235d79(%rip)        # 23a994 <ti+0x14>
	ti.tm_mon = cts->month -1;
    4c1b:	0f b6 47 02          	movzbl 0x2(%rdi),%eax
    4c1f:	ff c8                	dec    %eax
    4c21:	89 05 69 5d 23 00    	mov    %eax,0x235d69(%rip)        # 23a990 <ti+0x10>
	ti.tm_mday = cts->day;
    4c27:	0f b6 47 03          	movzbl 0x3(%rdi),%eax
    4c2b:	89 05 5b 5d 23 00    	mov    %eax,0x235d5b(%rip)        # 23a98c <ti+0xc>
	ti.tm_hour = cts->hours;
    4c31:	0f b6 47 04          	movzbl 0x4(%rdi),%eax
    4c35:	89 05 4d 5d 23 00    	mov    %eax,0x235d4d(%rip)        # 23a988 <ti+0x8>
	ti.tm_min = cts->minutes;
    4c3b:	0f b6 47 05          	movzbl 0x5(%rdi),%eax
    4c3f:	89 05 3f 5d 23 00    	mov    %eax,0x235d3f(%rip)        # 23a984 <ti+0x4>
	ti.tm_sec = cts->seconds;
    4c45:	0f b6 47 06          	movzbl 0x6(%rdi),%eax
	mktime(&ti);
    4c49:	48 8d 3d 30 5d 23 00 	lea    0x235d30(%rip),%rdi        # 23a980 <ti>
	ti.tm_sec = cts->seconds;
    4c50:	89 05 2a 5d 23 00    	mov    %eax,0x235d2a(%rip)        # 23a980 <ti>
	mktime(&ti);
    4c56:	e8 65 f8 ff ff       	callq  44c0 <mktime@plt>
	clock_update_elapsed_ms();
}
    4c5b:	5a                   	pop    %rdx
	clock_update_elapsed_ms();
    4c5c:	31 c0                	xor    %eax,%eax
    4c5e:	e9 5a ff ff ff       	jmpq   4bbd <clock_update_elapsed_ms>

0000000000004c63 <clock_increment_local_time>:

/* Called by event handler */
void clock_increment_local_time()
{
    4c63:	48 83 ec 08          	sub    $0x8,%rsp
	clock_update_elapsed_ms();
    4c67:	31 c0                	xor    %eax,%eax
    4c69:	e8 4f ff ff ff       	callq  4bbd <clock_update_elapsed_ms>
	ti.tm_sec += elapsed_ms / 1000;
    4c6e:	48 8b 05 db 31 25 00 	mov    0x2531db(%rip),%rax        # 257e50 <elapsed_ms>
    4c75:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
    4c7a:	31 d2                	xor    %edx,%edx
	mktime(&ti);
    4c7c:	48 8d 3d fd 5c 23 00 	lea    0x235cfd(%rip),%rdi        # 23a980 <ti>
	ti.tm_sec += elapsed_ms / 1000;
    4c83:	48 f7 f1             	div    %rcx
    4c86:	01 05 f4 5c 23 00    	add    %eax,0x235cf4(%rip)        # 23a980 <ti>
}
    4c8c:	58                   	pop    %rax
	mktime(&ti);
    4c8d:	e9 2e f8 ff ff       	jmpq   44c0 <mktime@plt>

0000000000004c92 <clock_show_time>:

void clock_show_time()
{
	strftime(time_label_str, 32, "%H:%M", &ti);
    4c92:	48 8d 0d e7 5c 23 00 	lea    0x235ce7(%rip),%rcx        # 23a980 <ti>
    4c99:	48 8d 15 d2 c2 02 00 	lea    0x2c2d2(%rip),%rdx        # 30f72 <__func__.5785+0x30a>
    4ca0:	48 8d 3d 39 5d 23 00 	lea    0x235d39(%rip),%rdi        # 23a9e0 <time_label_str>
{
    4ca7:	48 83 ec 08          	sub    $0x8,%rsp
	strftime(time_label_str, 32, "%H:%M", &ti);
    4cab:	be 20 00 00 00       	mov    $0x20,%esi
    4cb0:	e8 8b f8 ff ff       	callq  4540 <strftime@plt>
	strftime(date_label_str, 32, "%a %d %b", &ti);
    4cb5:	48 8d 0d c4 5c 23 00 	lea    0x235cc4(%rip),%rcx        # 23a980 <ti>
    4cbc:	48 8d 15 b5 c2 02 00 	lea    0x2c2b5(%rip),%rdx        # 30f78 <__func__.5785+0x310>
    4cc3:	48 8d 3d f6 5c 23 00 	lea    0x235cf6(%rip),%rdi        # 23a9c0 <date_label_str>
    4cca:	be 20 00 00 00       	mov    $0x20,%esi
    4ccf:	e8 6c f8 ff ff       	callq  4540 <strftime@plt>
	//gfx_time_set_label(time_label_str); jj
	display_time_set_label(time_label_str);
    4cd4:	48 8d 3d 05 5d 23 00 	lea    0x235d05(%rip),%rdi        # 23a9e0 <time_label_str>
    4cdb:	e8 69 04 00 00       	callq  5149 <display_time_set_label>
	//gfx_date_set_label(date_label_str);
	display_date_set_label(date_label_str);
}
    4ce0:	58                   	pop    %rax
	display_date_set_label(date_label_str);
    4ce1:	48 8d 3d d8 5c 23 00 	lea    0x235cd8(%rip),%rdi        # 23a9c0 <date_label_str>
    4ce8:	e9 6b 04 00 00       	jmpq   5158 <display_date_set_label>

0000000000004ced <cts_sync_timer_timeout_handler>:
	t->tm_sec = clock_datetime.seconds;
}

static void cts_sync_timer_timeout_handler(struct k_timer *tmr)
{
	bt_conn_foreach(BT_CONN_TYPE_LE, cts_sync_processor, NULL);
    4ced:	48 8d 35 0c 00 00 00 	lea    0xc(%rip),%rsi        # 4d00 <cts_sync_processor>
    4cf4:	31 d2                	xor    %edx,%edx
    4cf6:	bf 01 00 00 00       	mov    $0x1,%edi
    4cfb:	e9 1f ce 00 00       	jmpq   11b1f <bt_conn_foreach>

0000000000004d00 <cts_sync_processor>:

	return BT_GATT_ITER_STOP;
}

static void cts_sync_processor(struct bt_conn *conn, void *data)
{
    4d00:	48 83 ec 18          	sub    $0x18,%rsp
	cts_discovery_params.start_handle = 0x0001;
	cts_discovery_params.end_handle = 0xFFFF;
	cts_discovery_params.type = BT_GATT_DISCOVER_CHARACTERISTIC;
	cts_discovery_params.uuid = (struct bt_uuid *) &uuid;

	if (bt_gatt_discover(conn, &cts_discovery_params) != 0) {
    4d04:	48 8d 35 15 5d 23 00 	lea    0x235d15(%rip),%rsi        # 23aa20 <cts_discovery_params>
	cts_discovery_params.start_handle = 0x0001;
    4d0b:	66 c7 05 1c 5d 23 00 	movw   $0x1,0x235d1c(%rip)        # 23aa30 <cts_discovery_params+0x10>
    4d12:	01 00 
{
    4d14:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4d1b:	00 00 
    4d1d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    4d22:	31 c0                	xor    %eax,%eax
	memcpy(&uuid, BT_UUID_CTS_CURRENT_TIME, sizeof(uuid));
    4d24:	c6 44 24 04 00       	movb   $0x0,0x4(%rsp)
    4d29:	66 c7 44 24 06 2b 2a 	movw   $0x2a2b,0x6(%rsp)
    4d30:	8b 44 24 04          	mov    0x4(%rsp),%eax
	cts_discovery_params.end_handle = 0xFFFF;
    4d34:	66 c7 05 f9 5c 23 00 	movw   $0xffff,0x235cf9(%rip)        # 23aa36 <cts_discovery_params+0x16>
    4d3b:	ff ff 
	cts_discovery_params.type = BT_GATT_DISCOVER_CHARACTERISTIC;
    4d3d:	c6 05 f4 5c 23 00 03 	movb   $0x3,0x235cf4(%rip)        # 23aa38 <cts_discovery_params+0x18>
    4d44:	89 05 7e a3 25 00    	mov    %eax,0x25a37e(%rip)        # 25f0c8 <uuid>
	cts_discovery_params.func = cts_sync_service_discovered;
    4d4a:	48 8d 05 70 00 00 00 	lea    0x70(%rip),%rax        # 4dc1 <cts_sync_service_discovered>
    4d51:	48 89 05 d0 5c 23 00 	mov    %rax,0x235cd0(%rip)        # 23aa28 <cts_discovery_params+0x8>
	cts_discovery_params.uuid = (struct bt_uuid *) &uuid;
    4d58:	48 8d 05 69 a3 25 00 	lea    0x25a369(%rip),%rax        # 25f0c8 <uuid>
    4d5f:	48 89 05 ba 5c 23 00 	mov    %rax,0x235cba(%rip)        # 23aa20 <cts_discovery_params>
	if (bt_gatt_discover(conn, &cts_discovery_params) != 0) {
    4d66:	e8 fa 26 01 00       	callq  17465 <bt_gatt_discover>
    4d6b:	85 c0                	test   %eax,%eax
    4d6d:	74 38                	je     4da7 <cts_sync_processor+0xa7>
    4d6f:	48 8d 35 ea 55 23 00 	lea    0x2355ea(%rip),%rsi        # 23a360 <_settings_handler_static_list_end>
    4d76:	48 2b 35 d3 11 23 00 	sub    0x2311d3(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
    4d7d:	48 c1 ee 04          	shr    $0x4,%rsi
		LOG_ERR("CTS Sync > GATT discovery FAILED.");
    4d81:	c1 e6 06             	shl    $0x6,%esi
    4d84:	83 ce 01             	or     $0x1,%esi
    4d87:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    4d8c:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    4d93:	00 00 
    4d95:	75 20                	jne    4db7 <cts_sync_processor+0xb7>
    4d97:	48 8d 3d e3 c1 02 00 	lea    0x2c1e3(%rip),%rdi        # 30f81 <__func__.5785+0x319>
	}
}
    4d9e:	48 83 c4 18          	add    $0x18,%rsp
		LOG_ERR("CTS Sync > GATT discovery FAILED.");
    4da2:	e9 1d 25 00 00       	jmpq   72c4 <log_0>
}
    4da7:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    4dac:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    4db3:	00 00 
    4db5:	74 05                	je     4dbc <cts_sync_processor+0xbc>
    4db7:	e8 84 f8 ff ff       	callq  4640 <__stack_chk_fail@plt>
    4dbc:	48 83 c4 18          	add    $0x18,%rsp
    4dc0:	c3                   	retq   

0000000000004dc1 <cts_sync_service_discovered>:
{
    4dc1:	48 83 ec 08          	sub    $0x8,%rsp
	if (!attr) {
    4dc5:	48 85 f6             	test   %rsi,%rsi
    4dc8:	75 26                	jne    4df0 <cts_sync_service_discovered+0x2f>
    4dca:	48 8d 35 8f 55 23 00 	lea    0x23558f(%rip),%rsi        # 23a360 <_settings_handler_static_list_end>
    4dd1:	48 2b 35 78 11 23 00 	sub    0x231178(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		LOG_INF("CTS Service Discovery completed");
    4dd8:	48 8d 3d c4 c1 02 00 	lea    0x2c1c4(%rip),%rdi        # 30fa3 <__func__.5785+0x33b>
    4ddf:	48 c1 ee 04          	shr    $0x4,%rsi
    4de3:	c1 e6 06             	shl    $0x6,%esi
    4de6:	83 ce 03             	or     $0x3,%esi
    4de9:	e8 d6 24 00 00       	callq  72c4 <log_0>
    4dee:	eb 4f                	jmp    4e3f <cts_sync_service_discovered+0x7e>
	read_params.func = cts_sync_read;
    4df0:	48 8d 05 4c 00 00 00 	lea    0x4c(%rip),%rax        # 4e43 <cts_sync_read>
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    4df7:	0f 57 c0             	xorps  %xmm0,%xmm0
	m_read_buf.offset = 0;
    4dfa:	c7 05 7c 2e 25 00 00 	movl   $0x0,0x252e7c(%rip)        # 257c80 <m_read_buf>
    4e01:	00 00 00 
	read_params.func = cts_sync_read;
    4e04:	48 89 05 f5 5b 23 00 	mov    %rax,0x235bf5(%rip)        # 23aa00 <read_params>
	read_params.by_uuid.uuid = (struct bt_uuid *) &uuid;
    4e0b:	48 8d 05 b6 a2 25 00 	lea    0x25a2b6(%rip),%rax        # 25f0c8 <uuid>
    4e12:	0f 11 05 ef 5b 23 00 	movups %xmm0,0x235bef(%rip)        # 23aa08 <read_params+0x8>
    4e19:	48 89 05 f8 5b 23 00 	mov    %rax,0x235bf8(%rip)        # 23aa18 <read_params+0x18>
	read_params.by_uuid.start_handle = attr->handle;
    4e20:	8b 46 20             	mov    0x20(%rsi),%eax
	if (bt_gatt_read(conn, &read_params) < 0) {
    4e23:	48 8d 35 d6 5b 23 00 	lea    0x235bd6(%rip),%rsi        # 23aa00 <read_params>
	read_params.by_uuid.start_handle = attr->handle;
    4e2a:	66 89 05 df 5b 23 00 	mov    %ax,0x235bdf(%rip)        # 23aa10 <read_params+0x10>
	read_params.by_uuid.end_handle = 0xffff;
    4e31:	66 c7 05 d8 5b 23 00 	movw   $0xffff,0x235bd8(%rip)        # 23aa12 <read_params+0x12>
    4e38:	ff ff 
	if (bt_gatt_read(conn, &read_params) < 0) {
    4e3a:	e8 69 32 01 00       	callq  180a8 <bt_gatt_read>
}
    4e3f:	31 c0                	xor    %eax,%eax
    4e41:	5a                   	pop    %rdx
    4e42:	c3                   	retq   

0000000000004e43 <cts_sync_read>:
{
    4e43:	53                   	push   %rbx
    4e44:	48 89 ce             	mov    %rcx,%rsi
    4e47:	48 83 ec 30          	sub    $0x30,%rsp
    4e4b:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4e52:	00 00 
    4e54:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    4e59:	31 c0                	xor    %eax,%eax
	if (!data || length <= 0) {
    4e5b:	48 85 c9             	test   %rcx,%rcx
    4e5e:	74 0a                	je     4e6a <cts_sync_read+0x27>
    4e60:	66 45 85 c0          	test   %r8w,%r8w
    4e64:	0f 85 d3 00 00 00    	jne    4f3d <cts_sync_read+0xfa>
	if (cts_datetime->year + cts_datetime->day + cts_datetime->hours
    4e6a:	0f b6 0d 16 2e 25 00 	movzbl 0x252e16(%rip),%ecx        # 257c87 <m_read_buf+0x7>
    4e71:	0f b7 05 0c 2e 25 00 	movzwl 0x252e0c(%rip),%eax        # 257c84 <m_read_buf+0x4>
    4e78:	0f b6 3d 09 2e 25 00 	movzbl 0x252e09(%rip),%edi        # 257c88 <m_read_buf+0x8>
	    + cts_datetime->minutes + cts_datetime->seconds == 0) {
    4e7f:	0f b6 35 03 2e 25 00 	movzbl 0x252e03(%rip),%esi        # 257c89 <m_read_buf+0x9>
    4e86:	48 8d 1d d3 54 23 00 	lea    0x2354d3(%rip),%rbx        # 23a360 <_settings_handler_static_list_end>
    4e8d:	48 2b 1d bc 10 23 00 	sub    0x2310bc(%rip),%rbx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
    4e94:	0f b6 15 ef 2d 25 00 	movzbl 0x252def(%rip),%edx        # 257c8a <m_read_buf+0xa>
	if (cts_datetime->year + cts_datetime->day + cts_datetime->hours
    4e9b:	49 89 c1             	mov    %rax,%r9
    4e9e:	49 89 c8             	mov    %rcx,%r8
    4ea1:	01 c8                	add    %ecx,%eax
    4ea3:	40 0f b6 cf          	movzbl %dil,%ecx
    4ea7:	01 c8                	add    %ecx,%eax
    4ea9:	48 c1 eb 04          	shr    $0x4,%rbx
	    + cts_datetime->minutes + cts_datetime->seconds == 0) {
    4ead:	40 0f b6 ce          	movzbl %sil,%ecx
    4eb1:	66 81 e3 ff 03       	and    $0x3ff,%bx
    4eb6:	01 c8                	add    %ecx,%eax
    4eb8:	0f b6 ca             	movzbl %dl,%ecx
		LOG_WRN("Ignoring suspicious time data from companion application.");
    4ebb:	c1 e3 06             	shl    $0x6,%ebx
	if (cts_datetime->year + cts_datetime->day + cts_datetime->hours
    4ebe:	01 c8                	add    %ecx,%eax
    4ec0:	75 0e                	jne    4ed0 <cts_sync_read+0x8d>
		LOG_WRN("Ignoring suspicious time data from companion application.");
    4ec2:	83 cb 02             	or     $0x2,%ebx
    4ec5:	48 8d 3d f7 c0 02 00 	lea    0x2c0f7(%rip),%rdi        # 30fc3 <__func__.5785+0x35b>
    4ecc:	89 de                	mov    %ebx,%esi
    4ece:	eb 64                	jmp    4f34 <cts_sync_read+0xf1>
	LOG_INF("CTS sync to clock started.\n Y%04d D%03d T%2d:%2d:%2d",
    4ed0:	89 d9                	mov    %ebx,%ecx
    4ed2:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
    4ed7:	48 8d 3d 1f c1 02 00 	lea    0x2c11f(%rip),%rdi        # 30ffd <__func__.5785+0x395>
    4ede:	83 c9 03             	or     $0x3,%ecx
    4ee1:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
    4ee6:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
    4eeb:	48 89 e6             	mov    %rsp,%rsi
    4eee:	ba 05 00 00 00       	mov    $0x5,%edx
    4ef3:	4c 89 0c 24          	mov    %r9,(%rsp)
    4ef7:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
	LOG_INF("CTS sync to clock complete.");
    4efc:	83 cb 03             	or     $0x3,%ebx
	LOG_INF("CTS sync to clock started.\n Y%04d D%03d T%2d:%2d:%2d",
    4eff:	e8 e8 24 00 00       	callq  73ec <log_n>
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    4f04:	48 8d 05 55 2f 25 00 	lea    0x252f55(%rip),%rax        # 257e60 <clock_datetime>
    4f0b:	48 8b 15 72 2d 25 00 	mov    0x252d72(%rip),%rdx        # 257c84 <m_read_buf+0x4>
	clock_sync_time(cts_datetime);
    4f12:	48 8d 3d 6b 2d 25 00 	lea    0x252d6b(%rip),%rdi        # 257c84 <m_read_buf+0x4>
    4f19:	48 89 10             	mov    %rdx,(%rax)
    4f1c:	8b 15 6a 2d 25 00    	mov    0x252d6a(%rip),%edx        # 257c8c <m_read_buf+0xc>
    4f22:	66 89 50 08          	mov    %dx,0x8(%rax)
    4f26:	e8 de fc ff ff       	callq  4c09 <clock_sync_time>
	LOG_INF("CTS sync to clock complete.");
    4f2b:	48 8d 3d 00 c1 02 00 	lea    0x2c100(%rip),%rdi        # 31032 <__func__.5785+0x3ca>
    4f32:	89 de                	mov    %ebx,%esi
    4f34:	e8 8b 23 00 00       	callq  72c4 <log_0>
		return BT_GATT_ITER_STOP;
    4f39:	31 c0                	xor    %eax,%eax
    4f3b:	eb 2b                	jmp    4f68 <cts_sync_read+0x125>
	memcpy(&m_read_buf.datetime + m_read_buf.offset, data, length);
    4f3d:	48 63 05 3c 2d 25 00 	movslq 0x252d3c(%rip),%rax        # 257c80 <m_read_buf>
    4f44:	48 8d 15 39 2d 25 00 	lea    0x252d39(%rip),%rdx        # 257c84 <m_read_buf+0x4>
    4f4b:	41 0f b7 c8          	movzwl %r8w,%ecx
	m_read_buf.offset += length;
    4f4f:	45 0f b7 c0          	movzwl %r8w,%r8d
	memcpy(&m_read_buf.datetime + m_read_buf.offset, data, length);
    4f53:	48 6b c0 0a          	imul   $0xa,%rax,%rax
    4f57:	48 01 d0             	add    %rdx,%rax
    4f5a:	48 89 c7             	mov    %rax,%rdi
	m_read_buf.offset += length;
    4f5d:	b0 01                	mov    $0x1,%al
    4f5f:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
    4f61:	44 01 05 18 2d 25 00 	add    %r8d,0x252d18(%rip)        # 257c80 <m_read_buf>
}
    4f68:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
    4f6d:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
    4f74:	00 00 
    4f76:	74 05                	je     4f7d <cts_sync_read+0x13a>
    4f78:	e8 c3 f6 ff ff       	callq  4640 <__stack_chk_fail@plt>
    4f7d:	48 83 c4 30          	add    $0x30,%rsp
    4f81:	5b                   	pop    %rbx
    4f82:	c3                   	retq   

0000000000004f83 <cts_sync_init>:
{
    4f83:	48 83 ec 08          	sub    $0x8,%rsp
    4f87:	48 8d 35 d2 53 23 00 	lea    0x2353d2(%rip),%rsi        # 23a360 <_settings_handler_static_list_end>
    4f8e:	48 2b 35 bb 0f 23 00 	sub    0x230fbb(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
	LOG_INF("CTS sync init\n");
    4f95:	48 8d 3d b2 c0 02 00 	lea    0x2c0b2(%rip),%rdi        # 3104e <__func__.5785+0x3e6>
    4f9c:	48 c1 ee 04          	shr    $0x4,%rsi
    4fa0:	c1 e6 06             	shl    $0x6,%esi
    4fa3:	83 ce 03             	or     $0x3,%esi
    4fa6:	e8 19 23 00 00       	callq  72c4 <log_0>
}
    4fab:	58                   	pop    %rax
	k_timer_init(&m_cts_sync_timer, cts_sync_timer_timeout_handler, NULL);
    4fac:	48 8d 35 3a fd ff ff 	lea    -0x2c6(%rip),%rsi        # 4ced <cts_sync_timer_timeout_handler>
    4fb3:	48 8d 3d 86 5a 23 00 	lea    0x235a86(%rip),%rdi        # 23aa40 <m_cts_sync_timer>
    4fba:	31 d2                	xor    %edx,%edx
    4fbc:	e9 93 78 02 00       	jmpq   2c854 <k_timer_init>

0000000000004fc1 <cts_sync_enable>:
	if (enable) {
    4fc1:	40 84 ff             	test   %dil,%dil
    4fc4:	74 13                	je     4fd9 <cts_sync_enable+0x18>
	z_impl_k_timer_start(timer, duration, period);
    4fc6:	48 8d 3d 73 5a 23 00 	lea    0x235a73(%rip),%rdi        # 23aa40 <m_cts_sync_timer>
    4fcd:	ba 70 17 00 00       	mov    $0x1770,%edx
    4fd2:	31 f6                	xor    %esi,%esi
    4fd4:	e9 ae 78 02 00       	jmpq   2c887 <z_impl_k_timer_start>
	z_impl_k_timer_stop(timer);
    4fd9:	48 8d 3d 60 5a 23 00 	lea    0x235a60(%rip),%rdi        # 23aa40 <m_cts_sync_timer>
    4fe0:	e9 17 79 02 00       	jmpq   2c8fc <z_impl_k_timer_stop>

0000000000004fe5 <display_task_handler>:

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*---------------------------------------------------------------------------*/
void display_task_handler(struct k_work * work)
{
    4fe5:	48 83 ec 08          	sub    $0x8,%rsp
	lv_tick_inc(TICK_PERIOD);
    4fe9:	bf 0a 00 00 00       	mov    $0xa,%edi
    4fee:	e8 8d 04 02 00       	callq  25480 <lv_tick_inc>
	lv_task_handler();
}
    4ff3:	58                   	pop    %rax
	lv_task_handler();
    4ff4:	e9 df 14 02 00       	jmpq   264d8 <lv_task_handler>

0000000000004ff9 <button_event_cb>:
	static int param_id  = 0;  // init to first parameter index
//	if (lv_btn_get_state(obj) == LV_BTN_STATE_PRESSED) {
//		LOG_INF("button state pressed button event\n");
//	}

	switch(event) {
    4ff9:	83 ee 03             	sub    $0x3,%esi
    4ffc:	40 80 fe 04          	cmp    $0x4,%sil
    5000:	0f 87 06 01 00 00    	ja     510c <button_event_cb+0x113>
{
    5006:	55                   	push   %rbp
	switch(event) {
    5007:	48 8d 15 6a bc 02 00 	lea    0x2bc6a(%rip),%rdx        # 30c78 <__func__.5785+0x10>
{
    500e:	53                   	push   %rbx
	switch(event) {
    500f:	40 0f b6 f6          	movzbl %sil,%esi
{
    5013:	48 83 ec 08          	sub    $0x8,%rsp
	switch(event) {
    5017:	48 63 04 b2          	movslq (%rdx,%rsi,4),%rax
    501b:	48 8d 1d ee 53 23 00 	lea    0x2353ee(%rip),%rbx        # 23a410 <log_const_display>
    5022:	48 8d 2d 37 53 23 00 	lea    0x235337(%rip),%rbp        # 23a360 <_settings_handler_static_list_end>
    5029:	48 01 d0             	add    %rdx,%rax
    502c:	ff e0                	jmpq   *%rax
    502e:	48 29 eb             	sub    %rbp,%rbx
				//	display_btn_event(BTN1_LONG);
				}
			}*/ 
			break; 
		case LV_EVENT_SHORT_CLICKED:
			LOG_INF("Short clicked\n");
    5031:	48 8d 3d 25 c0 02 00 	lea    0x2c025(%rip),%rdi        # 3105d <__func__.5785+0x3f5>
    5038:	48 89 de             	mov    %rbx,%rsi
    503b:	48 c1 ee 04          	shr    $0x4,%rsi
    503f:	c1 e6 06             	shl    $0x6,%esi
    5042:	83 ce 03             	or     $0x3,%esi
    5045:	e9 ba 00 00 00       	jmpq   5104 <button_event_cb+0x10b>
    504a:	48 29 eb             	sub    %rbp,%rbx
			break;

		case LV_EVENT_CLICKED:
			clock_increment_local_time();
    504d:	e8 11 fc ff ff       	callq  4c63 <clock_increment_local_time>
    5052:	48 89 de             	mov    %rbx,%rsi

			LOG_INF("Clicked\n");
    5055:	48 8d 3d 10 c0 02 00 	lea    0x2c010(%rip),%rdi        # 3106c <__func__.5785+0x404>
    505c:	48 c1 ee 04          	shr    $0x4,%rsi
    5060:	c1 e6 06             	shl    $0x6,%esi
    5063:	83 ce 03             	or     $0x3,%esi
    5066:	e9 99 00 00 00       	jmpq   5104 <button_event_cb+0x10b>
    506b:	48 29 eb             	sub    %rbp,%rbx
			break;

		case LV_EVENT_LONG_PRESSED:
			clock_increment_local_time();
    506e:	e8 f0 fb ff ff       	callq  4c63 <clock_increment_local_time>
			clock_show_time();
    5073:	e8 1a fc ff ff       	callq  4c92 <clock_show_time>
    5078:	48 89 de             	mov    %rbx,%rsi
			LOG_INF("Long press\n");
    507b:	48 8d 3d f3 bf 02 00 	lea    0x2bff3(%rip),%rdi        # 31075 <__func__.5785+0x40d>
    5082:	48 c1 ee 04          	shr    $0x4,%rsi
    5086:	c1 e6 06             	shl    $0x6,%esi
    5089:	83 ce 03             	or     $0x3,%esi
    508c:	eb 76                	jmp    5104 <button_event_cb+0x10b>

		case LV_EVENT_LONG_PRESSED_REPEAT:

			//this can be configured in menuconfig 
			//standard value < long_pressed
						screen_id++;
    508e:	8b 05 bc 6f 25 00    	mov    0x256fbc(%rip),%eax        # 25c050 <screen_id.10325>
    5094:	ba 00 00 00 00       	mov    $0x0,%edx
    5099:	ff c0                	inc    %eax
    509b:	83 f8 03             	cmp    $0x3,%eax
    509e:	0f 4f c2             	cmovg  %edx,%eax
    return lv_disp_get_layer_sys(lv_disp_get_default());
}

static inline void lv_scr_load(lv_obj_t * scr)
{
    lv_disp_load_scr(scr);
    50a1:	48 8d 15 98 0f 23 00 	lea    0x230f98(%rip),%rdx        # 236040 <screens>
    50a8:	48 29 eb             	sub    %rbp,%rbx
    50ab:	89 05 9f 6f 25 00    	mov    %eax,0x256f9f(%rip)        # 25c050 <screen_id.10325>
						if (screen_id >= SCREEN_COUNT)
						screen_id = 0;
						lv_scr_load(screens[screen_id].screen);
    50b1:	48 98                	cltq   
    50b3:	48 c1 eb 04          	shr    $0x4,%rbx
    50b7:	48 6b c0 18          	imul   $0x18,%rax,%rax
						param_id = 0;
						LOG_INF("BTN1: screen_id(%d)", screen_id);
    50bb:	c1 e3 06             	shl    $0x6,%ebx
    50be:	48 8b 3c 02          	mov    (%rdx,%rax,1),%rdi
    50c2:	e8 26 42 01 00       	callq  192ed <lv_disp_load_scr>
    50c7:	48 63 35 82 6f 25 00 	movslq 0x256f82(%rip),%rsi        # 25c050 <screen_id.10325>
    50ce:	89 da                	mov    %ebx,%edx
    50d0:	48 8d 3d aa bf 02 00 	lea    0x2bfaa(%rip),%rdi        # 31081 <__func__.5785+0x419>
    50d7:	83 ca 03             	or     $0x3,%edx
			//   handle_button_event();



			LOG_INF("Long press repeat\n");
    50da:	83 cb 03             	or     $0x3,%ebx
						LOG_INF("BTN1: screen_id(%d)", screen_id);
    50dd:	e8 13 22 00 00       	callq  72f5 <log_1>
			LOG_INF("Long press repeat\n");
    50e2:	89 de                	mov    %ebx,%esi
    50e4:	48 8d 3d aa bf 02 00 	lea    0x2bfaa(%rip),%rdi        # 31095 <__func__.5785+0x42d>
    50eb:	eb 17                	jmp    5104 <button_event_cb+0x10b>
    50ed:	48 29 eb             	sub    %rbp,%rbx
			break;

		case LV_EVENT_RELEASED:
			LOG_INF("Released\n");
    50f0:	48 8d 3d b1 bf 02 00 	lea    0x2bfb1(%rip),%rdi        # 310a8 <__func__.5785+0x440>
    50f7:	48 89 de             	mov    %rbx,%rsi
    50fa:	48 c1 ee 04          	shr    $0x4,%rsi
    50fe:	c1 e6 06             	shl    $0x6,%esi
    5101:	83 ce 03             	or     $0x3,%esi
			break;
	}

}
    5104:	58                   	pop    %rax
    5105:	5b                   	pop    %rbx
    5106:	5d                   	pop    %rbp
			LOG_INF("Released\n");
    5107:	e9 b8 21 00 00       	jmpq   72c4 <log_0>
    510c:	c3                   	retq   

000000000000510d <lv_scr_act>:
{
    510d:	48 83 ec 08          	sub    $0x8,%rsp
    return lv_disp_get_scr_act(lv_disp_get_default());
    5111:	e8 28 ff 01 00       	callq  2503e <lv_disp_get_default>
    5116:	48 89 c7             	mov    %rax,%rdi
}
    5119:	58                   	pop    %rax
    return lv_disp_get_scr_act(lv_disp_get_default());
    511a:	e9 36 41 01 00       	jmpq   19255 <lv_disp_get_scr_act>

000000000000511f <display_timer_handler>:
    511f:	48 8d 35 4a 18 23 00 	lea    0x23184a(%rip),%rsi        # 236970 <display_work>
    5126:	8b 46 10             	mov    0x10(%rsi),%eax
    5129:	89 c1                	mov    %eax,%ecx
    512b:	89 c2                	mov    %eax,%edx
    512d:	83 c9 01             	or     $0x1,%ecx
    5130:	f0 0f b1 4e 10       	lock cmpxchg %ecx,0x10(%rsi)
    5135:	75 f2                	jne    5129 <display_timer_handler+0xa>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    5137:	80 e2 01             	and    $0x1,%dl
    513a:	75 0c                	jne    5148 <display_timer_handler+0x29>
		k_queue_append(&work_q->queue, work);
    513c:	48 8d 3d 5d 2a 25 00 	lea    0x252a5d(%rip),%rdi        # 257ba0 <k_sys_work_q>
    5143:	e9 e3 61 02 00       	jmpq   2b32b <k_queue_append>
}
    5148:	c3                   	retq   

0000000000005149 <display_time_set_label>:
{
    5149:	48 89 fe             	mov    %rdi,%rsi
	lv_label_set_text(time_label, str);
    514c:	48 8b 3d 5d 2d 25 00 	mov    0x252d5d(%rip),%rdi        # 257eb0 <time_label>
    5153:	e9 6f 4e 02 00       	jmpq   29fc7 <lv_label_set_text>

0000000000005158 <display_date_set_label>:
{
    5158:	48 89 fe             	mov    %rdi,%rsi
	lv_label_set_text(date_label, str);
    515b:	48 8b 3d 46 2d 25 00 	mov    0x252d46(%rip),%rdi        # 257ea8 <date_label>
    5162:	e9 60 4e 02 00       	jmpq   29fc7 <lv_label_set_text>

0000000000005167 <display_battery>:




void display_battery(enum battery_symbol s)
{
    5167:	89 f8                	mov    %edi,%eax
                        break;
                case BAT_1:
                        lv_label_set_text(battery_label, LV_SYMBOL_BATTERY_1);
                        break;
                default:
                        lv_label_set_text(battery_label, LV_SYMBOL_BATTERY_EMPTY);
    5169:	48 8d 35 56 bf 02 00 	lea    0x2bf56(%rip),%rsi        # 310c6 <__func__.5785+0x45e>
    5170:	48 8b 3d 21 2d 25 00 	mov    0x252d21(%rip),%rdi        # 257e98 <battery_label>
        switch (s) {
    5177:	83 f8 04             	cmp    $0x4,%eax
    517a:	77 3b                	ja     51b7 <display_battery+0x50>
    517c:	48 8d 15 09 bb 02 00 	lea    0x2bb09(%rip),%rdx        # 30c8c <__func__.5785+0x24>
    5183:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
    5187:	48 01 d0             	add    %rdx,%rax
    518a:	ff e0                	jmpq   *%rax
                        lv_label_set_text(battery_label, LV_SYMBOL_CHARGE);
    518c:	48 8d 35 1f bf 02 00 	lea    0x2bf1f(%rip),%rsi        # 310b2 <__func__.5785+0x44a>
    5193:	eb 22                	jmp    51b7 <display_battery+0x50>
                        lv_label_set_text(battery_label, LV_SYMBOL_BATTERY_FULL);
    5195:	48 8d 35 1a bf 02 00 	lea    0x2bf1a(%rip),%rsi        # 310b6 <__func__.5785+0x44e>
    519c:	eb 19                	jmp    51b7 <display_battery+0x50>
                        lv_label_set_text(battery_label, LV_SYMBOL_BATTERY_3);
    519e:	48 8d 35 15 bf 02 00 	lea    0x2bf15(%rip),%rsi        # 310ba <__func__.5785+0x452>
    51a5:	eb 10                	jmp    51b7 <display_battery+0x50>
                        lv_label_set_text(battery_label, LV_SYMBOL_BATTERY_2);
    51a7:	48 8d 35 10 bf 02 00 	lea    0x2bf10(%rip),%rsi        # 310be <__func__.5785+0x456>
    51ae:	eb 07                	jmp    51b7 <display_battery+0x50>
                        lv_label_set_text(battery_label, LV_SYMBOL_BATTERY_1);
    51b0:	48 8d 35 0b bf 02 00 	lea    0x2bf0b(%rip),%rsi        # 310c2 <__func__.5785+0x45a>
                        lv_label_set_text(battery_label, LV_SYMBOL_BATTERY_EMPTY);
    51b7:	e9 0b 4e 02 00       	jmpq   29fc7 <lv_label_set_text>

00000000000051bc <display_button>:




void display_button()
{
    51bc:	48 83 ec 08          	sub    $0x8,%rsp
	/* the ds_d6 has a real button and no touchscreen, so no need for lvgl-button */
#if defined(CONFIG_LVGL_POINTER_KSCAN)
//#if defined(CONFIG_BOARD_NATIVE_POSIX_64BIT)
	button_obj = lv_btn_create(lv_scr_act(), NULL);
    51c0:	e8 48 ff ff ff       	callq  510d <lv_scr_act>
    51c5:	31 f6                	xor    %esi,%esi
    51c7:	48 89 c7             	mov    %rax,%rdi
    51ca:	e8 90 31 02 00       	callq  2835f <lv_btn_create>
	lv_obj_set_width(button_obj, 5);
    51cf:	be 05 00 00 00       	mov    $0x5,%esi
    51d4:	48 89 c7             	mov    %rax,%rdi
	button_obj = lv_btn_create(lv_scr_act(), NULL);
    51d7:	48 89 05 da 2c 25 00 	mov    %rax,0x252cda(%rip)        # 257eb8 <button_obj>
	lv_obj_set_width(button_obj, 5);
    51de:	e8 a1 63 01 00       	callq  1b584 <lv_obj_set_width>
	lv_obj_set_height(button_obj, 5);
    51e3:	48 8b 3d ce 2c 25 00 	mov    0x252cce(%rip),%rdi        # 257eb8 <button_obj>
    51ea:	be 05 00 00 00       	mov    $0x5,%esi
    51ef:	e8 b1 63 01 00       	callq  1b5a5 <lv_obj_set_height>
	//lv_obj_align(button_obj, NULL, LV_ALIGN_CENTER, 128, 0);
	lv_obj_align(button_obj, NULL, LV_ALIGN_CENTER, 0, 0);
    51f4:	48 8b 3d bd 2c 25 00 	mov    0x252cbd(%rip),%rdi        # 257eb8 <button_obj>
    51fb:	45 31 c0             	xor    %r8d,%r8d
    51fe:	31 c9                	xor    %ecx,%ecx
    5200:	31 d2                	xor    %edx,%edx
    5202:	31 f6                	xor    %esi,%esi
    5204:	e8 b1 5d 01 00       	callq  1afba <lv_obj_align>
 * @param cont pointer to a container object
 * @param fit fit policy from `lv_fit_t`
 */
static inline void lv_cont_set_fit(lv_obj_t * cont, lv_fit_t fit)
{
    lv_cont_set_fit4(cont, fit, fit, fit, fit);
    5209:	48 8b 3d a8 2c 25 00 	mov    0x252ca8(%rip),%rdi        # 257eb8 <button_obj>
    5210:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    5216:	b9 01 00 00 00       	mov    $0x1,%ecx
    521b:	ba 01 00 00 00       	mov    $0x1,%edx
    5220:	be 01 00 00 00       	mov    $0x1,%esi
    5225:	e8 fd 39 02 00       	callq  28c27 <lv_cont_set_fit4>
	lv_btn_set_fit(button_obj, LV_FIT_TIGHT);
	screen0_label0_obj = lv_label_create(button_obj, NULL);
    522a:	48 8b 3d 87 2c 25 00 	mov    0x252c87(%rip),%rdi        # 257eb8 <button_obj>
    5231:	31 f6                	xor    %esi,%esi
    5233:	e8 24 4f 02 00       	callq  2a15c <lv_label_create>
	lv_label_set_text(screen0_label0_obj, "O"); //substitute for real switch on physical watch
    5238:	48 8d 35 8b be 02 00 	lea    0x2be8b(%rip),%rsi        # 310ca <__func__.5785+0x462>
    523f:	48 89 c7             	mov    %rax,%rdi
    5242:	e8 80 4d 02 00       	callq  29fc7 <lv_label_set_text>
	lv_obj_set_event_cb(button_obj, button_event_cb);
    5247:	48 8b 3d 6a 2c 25 00 	mov    0x252c6a(%rip),%rdi        # 257eb8 <button_obj>
    524e:	48 8d 35 a4 fd ff ff 	lea    -0x25c(%rip),%rsi        # 4ff9 <button_event_cb>
#endif

}
    5255:	58                   	pop    %rax
	lv_obj_set_event_cb(button_obj, button_event_cb);
    5256:	e9 5b 54 01 00       	jmpq   1a6b6 <lv_obj_set_event_cb>

000000000000525b <display_screens_init>:

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*---------------------------------------------------------------------------*/
void display_screens_init(void)
{
    525b:	53                   	push   %rbx
	screens[0].screen = lv_obj_create(NULL, NULL);
    525c:	31 f6                	xor    %esi,%esi
    525e:	31 ff                	xor    %edi,%edi
    5260:	e8 33 5e 01 00       	callq  1b098 <lv_obj_create>
	screens[1].screen = lv_obj_create(NULL, NULL);
    5265:	31 f6                	xor    %esi,%esi
    5267:	31 ff                	xor    %edi,%edi
	screens[0].screen = lv_obj_create(NULL, NULL);
    5269:	48 89 05 d0 0d 23 00 	mov    %rax,0x230dd0(%rip)        # 236040 <screens>
	screens[1].screen = lv_obj_create(NULL, NULL);
    5270:	e8 23 5e 01 00       	callq  1b098 <lv_obj_create>
	screens[2].screen = lv_obj_create(NULL, NULL);
    5275:	31 f6                	xor    %esi,%esi
    5277:	31 ff                	xor    %edi,%edi
	screens[1].screen = lv_obj_create(NULL, NULL);
    5279:	48 89 05 d8 0d 23 00 	mov    %rax,0x230dd8(%rip)        # 236058 <screens+0x18>
	screens[2].screen = lv_obj_create(NULL, NULL);
    5280:	e8 13 5e 01 00       	callq  1b098 <lv_obj_create>
	screens[3].screen = lv_obj_create(NULL, NULL);
    5285:	31 f6                	xor    %esi,%esi
    5287:	31 ff                	xor    %edi,%edi
	screens[2].screen = lv_obj_create(NULL, NULL);
    5289:	48 89 05 e0 0d 23 00 	mov    %rax,0x230de0(%rip)        # 236070 <screens+0x30>
	screens[3].screen = lv_obj_create(NULL, NULL);
    5290:	e8 03 5e 01 00       	callq  1b098 <lv_obj_create>
    lv_disp_load_scr(scr);
    5295:	48 8b 3d a4 0d 23 00 	mov    0x230da4(%rip),%rdi        # 236040 <screens>
    529c:	48 89 05 e5 0d 23 00 	mov    %rax,0x230de5(%rip)        # 236088 <screens+0x48>
    52a3:	e8 45 40 01 00       	callq  192ed <lv_disp_load_scr>

	/*
	 *  build basic screen0
	 */
	lv_scr_load(screens[0].screen);
	lv_obj_t * screen0_label = lv_label_create(lv_scr_act(), NULL);
    52a8:	e8 60 fe ff ff       	callq  510d <lv_scr_act>
    52ad:	31 f6                	xor    %esi,%esi
    52af:	48 89 c7             	mov    %rax,%rdi
    52b2:	e8 a5 4e 02 00       	callq  2a15c <lv_label_create>
	lv_label_set_text(screen0_label, "Pg1");
    52b7:	48 8d 35 0e be 02 00 	lea    0x2be0e(%rip),%rsi        # 310cc <__func__.5785+0x464>
    52be:	48 89 c7             	mov    %rax,%rdi
	lv_obj_t * screen0_label = lv_label_create(lv_scr_act(), NULL);
    52c1:	48 89 c3             	mov    %rax,%rbx
	lv_label_set_text(screen0_label, "Pg1");
    52c4:	e8 fe 4c 02 00       	callq  29fc7 <lv_label_set_text>
	lv_obj_align(screen0_label, screens[0].screen, LV_ALIGN_IN_TOP_RIGHT, 0, 0);
    52c9:	48 8b 35 70 0d 23 00 	mov    0x230d70(%rip),%rsi        # 236040 <screens>
    52d0:	45 31 c0             	xor    %r8d,%r8d
    52d3:	31 c9                	xor    %ecx,%ecx
    52d5:	ba 03 00 00 00       	mov    $0x3,%edx
    52da:	48 89 df             	mov    %rbx,%rdi
    52dd:	e8 d8 5c 01 00       	callq  1afba <lv_obj_align>
	/* the ds_d6 has a real button and no touchscreen, so no need for lvgl-button */
	display_button();
    52e2:	31 c0                	xor    %eax,%eax
    52e4:	e8 d3 fe ff ff       	callq  51bc <display_button>

	/* Time label */
	time_label = lv_label_create(lv_scr_act(), NULL);
    52e9:	e8 1f fe ff ff       	callq  510d <lv_scr_act>
    52ee:	31 f6                	xor    %esi,%esi
    52f0:	48 89 c7             	mov    %rax,%rdi
    52f3:	e8 64 4e 02 00       	callq  2a15c <lv_label_create>
	lv_obj_align(time_label, NULL, LV_ALIGN_IN_TOP_MID, 0, 0); //jj
    52f8:	45 31 c0             	xor    %r8d,%r8d
    52fb:	31 c9                	xor    %ecx,%ecx
    52fd:	ba 02 00 00 00       	mov    $0x2,%edx
    5302:	48 89 c7             	mov    %rax,%rdi
    5305:	31 f6                	xor    %esi,%esi
	time_label = lv_label_create(lv_scr_act(), NULL);
    5307:	48 89 05 a2 2b 25 00 	mov    %rax,0x252ba2(%rip)        # 257eb0 <time_label>
	lv_obj_align(time_label, NULL, LV_ALIGN_IN_TOP_MID, 0, 0); //jj
    530e:	e8 a7 5c 01 00       	callq  1afba <lv_obj_align>
	lv_label_set_text(time_label, "00:00");
    5313:	48 8b 3d 96 2b 25 00 	mov    0x252b96(%rip),%rdi        # 257eb0 <time_label>
    531a:	48 8d 35 af bd 02 00 	lea    0x2bdaf(%rip),%rsi        # 310d0 <__func__.5785+0x468>
    5321:	e8 a1 4c 02 00       	callq  29fc7 <lv_label_set_text>
	/* Date label */
	date_label = lv_label_create(lv_scr_act(), NULL);
    5326:	e8 e2 fd ff ff       	callq  510d <lv_scr_act>
    532b:	31 f6                	xor    %esi,%esi
    532d:	48 89 c7             	mov    %rax,%rdi
    5330:	e8 27 4e 02 00       	callq  2a15c <lv_label_create>
	lv_obj_align(date_label, NULL, LV_ALIGN_IN_BOTTOM_MID, 0, 0);
    5335:	45 31 c0             	xor    %r8d,%r8d
    5338:	31 c9                	xor    %ecx,%ecx
    533a:	ba 05 00 00 00       	mov    $0x5,%edx
    533f:	48 89 c7             	mov    %rax,%rdi
    5342:	31 f6                	xor    %esi,%esi
	date_label = lv_label_create(lv_scr_act(), NULL);
    5344:	48 89 05 5d 2b 25 00 	mov    %rax,0x252b5d(%rip)        # 257ea8 <date_label>
	lv_obj_align(date_label, NULL, LV_ALIGN_IN_BOTTOM_MID, 0, 0);
    534b:	e8 6a 5c 01 00       	callq  1afba <lv_obj_align>
	lv_label_set_text(date_label, "Mon 10 Jan");
    5350:	48 8b 3d 51 2b 25 00 	mov    0x252b51(%rip),%rdi        # 257ea8 <date_label>
    5357:	48 8d 35 78 bd 02 00 	lea    0x2bd78(%rip),%rsi        # 310d6 <__func__.5785+0x46e>
    535e:	e8 64 4c 02 00       	callq  29fc7 <lv_label_set_text>

	/* title label */
	title_label = lv_label_create(lv_scr_act(), NULL);
    5363:	e8 a5 fd ff ff       	callq  510d <lv_scr_act>
    5368:	31 f6                	xor    %esi,%esi
    536a:	48 89 c7             	mov    %rax,%rdi
    536d:	e8 ea 4d 02 00       	callq  2a15c <lv_label_create>
	lv_obj_align(title_label, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0);
    5372:	45 31 c0             	xor    %r8d,%r8d
    5375:	31 c9                	xor    %ecx,%ecx
    5377:	ba 01 00 00 00       	mov    $0x1,%edx
    537c:	48 89 c7             	mov    %rax,%rdi
    537f:	31 f6                	xor    %esi,%esi
	title_label = lv_label_create(lv_scr_act(), NULL);
    5381:	48 89 05 18 2b 25 00 	mov    %rax,0x252b18(%rip)        # 257ea0 <title_label>
	lv_obj_align(title_label, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0);
    5388:	e8 2d 5c 01 00       	callq  1afba <lv_obj_align>
	//lv_label_set_text(title_label, LV_SYMBOL_BLUETOOTH"symb");
	//lv_label_set_text(title_label, LV_SYMBOL_BLUETOOTH);
	lv_label_set_text(title_label, LV_SYMBOL_WIFI);
    538d:	48 8b 3d 0c 2b 25 00 	mov    0x252b0c(%rip),%rdi        # 257ea0 <title_label>
    5394:	48 8d 35 46 bd 02 00 	lea    0x2bd46(%rip),%rsi        # 310e1 <__func__.5785+0x479>
    539b:	e8 27 4c 02 00       	callq  29fc7 <lv_label_set_text>

	/* Battery label */
	//display_battery(3);
	battery_label = lv_label_create(lv_scr_act(), NULL);
    53a0:	e8 68 fd ff ff       	callq  510d <lv_scr_act>
    53a5:	31 f6                	xor    %esi,%esi
    53a7:	48 89 c7             	mov    %rax,%rdi
    53aa:	e8 ad 4d 02 00       	callq  2a15c <lv_label_create>
	display_battery(BAT_3); //todo just demo value -- need real level
    53af:	bf 02 00 00 00       	mov    $0x2,%edi
	battery_label = lv_label_create(lv_scr_act(), NULL);
    53b4:	48 89 05 dd 2a 25 00 	mov    %rax,0x252add(%rip)        # 257e98 <battery_label>
	display_battery(BAT_3); //todo just demo value -- need real level
    53bb:	e8 a7 fd ff ff       	callq  5167 <display_battery>
	//lv_label_set_text(battery_label, LV_SYMBOL_BATTERY_2);
        lv_obj_align(battery_label, NULL, LV_ALIGN_IN_BOTTOM_LEFT, 0, 0);
    53c0:	48 8b 3d d1 2a 25 00 	mov    0x252ad1(%rip),%rdi        # 257e98 <battery_label>
    53c7:	45 31 c0             	xor    %r8d,%r8d
    53ca:	31 c9                	xor    %ecx,%ecx
    53cc:	ba 04 00 00 00       	mov    $0x4,%edx
    53d1:	31 f6                	xor    %esi,%esi
    53d3:	e8 e2 5b 01 00       	callq  1afba <lv_obj_align>
    53d8:	48 8b 3d 79 0c 23 00 	mov    0x230c79(%rip),%rdi        # 236058 <screens+0x18>
    53df:	e8 09 3f 01 00       	callq  192ed <lv_disp_load_scr>

	/*
	 *  build basic screen1
	 */
	lv_scr_load(screens[1].screen);
	lv_obj_t * screen1_page = lv_label_create(lv_scr_act(), NULL);
    53e4:	e8 24 fd ff ff       	callq  510d <lv_scr_act>
    53e9:	31 f6                	xor    %esi,%esi
    53eb:	48 89 c7             	mov    %rax,%rdi
    53ee:	e8 69 4d 02 00       	callq  2a15c <lv_label_create>
	lv_label_set_text(screen1_page, "Pg2");
    53f3:	48 8d 35 eb bc 02 00 	lea    0x2bceb(%rip),%rsi        # 310e5 <__func__.5785+0x47d>
    53fa:	48 89 c7             	mov    %rax,%rdi
	lv_obj_t * screen1_page = lv_label_create(lv_scr_act(), NULL);
    53fd:	48 89 c3             	mov    %rax,%rbx
	lv_label_set_text(screen1_page, "Pg2");
    5400:	e8 c2 4b 02 00       	callq  29fc7 <lv_label_set_text>
	lv_obj_align(screen1_page, screens[1].screen, LV_ALIGN_IN_TOP_RIGHT, 0, 0);
    5405:	48 8b 35 4c 0c 23 00 	mov    0x230c4c(%rip),%rsi        # 236058 <screens+0x18>
    540c:	45 31 c0             	xor    %r8d,%r8d
    540f:	31 c9                	xor    %ecx,%ecx
    5411:	ba 03 00 00 00       	mov    $0x3,%edx
    5416:	48 89 df             	mov    %rbx,%rdi
    5419:	e8 9c 5b 01 00       	callq  1afba <lv_obj_align>

	// to avoid creating the same button all over again jj
	display_button();
    541e:	31 c0                	xor    %eax,%eax
    5420:	e8 97 fd ff ff       	callq  51bc <display_button>

	screen1_label0_obj = lv_label_create(lv_scr_act(), NULL);
    5425:	e8 e3 fc ff ff       	callq  510d <lv_scr_act>
    542a:	31 f6                	xor    %esi,%esi
    542c:	48 89 c7             	mov    %rax,%rdi
    542f:	e8 28 4d 02 00       	callq  2a15c <lv_label_create>
	lv_label_set_text(screen1_label0_obj, "0");
    5434:	48 8d 35 fd e6 02 00 	lea    0x2e6fd(%rip),%rsi        # 33b38 <_lv_bpp1_opa_table+0x2e3>
    543b:	48 89 c7             	mov    %rax,%rdi
	screen1_label0_obj = lv_label_create(lv_scr_act(), NULL);
    543e:	48 89 05 4b 2a 25 00 	mov    %rax,0x252a4b(%rip)        # 257e90 <screen1_label0_obj>
	lv_label_set_text(screen1_label0_obj, "0");
    5445:	e8 7d 4b 02 00       	callq  29fc7 <lv_label_set_text>
	lv_obj_align(screen1_label0_obj, screens[1].screen, LV_ALIGN_IN_BOTTOM_LEFT, 5, -5);
    544a:	48 8b 35 07 0c 23 00 	mov    0x230c07(%rip),%rsi        # 236058 <screens+0x18>
    5451:	48 8b 3d 38 2a 25 00 	mov    0x252a38(%rip),%rdi        # 257e90 <screen1_label0_obj>
    5458:	41 b8 fb ff ff ff    	mov    $0xfffffffb,%r8d
    545e:	b9 05 00 00 00       	mov    $0x5,%ecx
    5463:	ba 04 00 00 00       	mov    $0x4,%edx
    5468:	e8 4d 5b 01 00       	callq  1afba <lv_obj_align>

	screen1_label1_obj = lv_label_create(lv_scr_act(), NULL);
    546d:	e8 9b fc ff ff       	callq  510d <lv_scr_act>
    5472:	31 f6                	xor    %esi,%esi
    5474:	48 89 c7             	mov    %rax,%rdi
    5477:	e8 e0 4c 02 00       	callq  2a15c <lv_label_create>
	lv_label_set_text(screen1_label1_obj, "0");
    547c:	48 8d 35 b5 e6 02 00 	lea    0x2e6b5(%rip),%rsi        # 33b38 <_lv_bpp1_opa_table+0x2e3>
    5483:	48 89 c7             	mov    %rax,%rdi
	screen1_label1_obj = lv_label_create(lv_scr_act(), NULL);
    5486:	48 89 05 fb 29 25 00 	mov    %rax,0x2529fb(%rip)        # 257e88 <screen1_label1_obj>
	lv_label_set_text(screen1_label1_obj, "0");
    548d:	e8 35 4b 02 00       	callq  29fc7 <lv_label_set_text>
	lv_obj_align(screen1_label1_obj, screens[1].screen, LV_ALIGN_IN_BOTTOM_RIGHT, -15, -5);
    5492:	48 8b 35 bf 0b 23 00 	mov    0x230bbf(%rip),%rsi        # 236058 <screens+0x18>
    5499:	48 8b 3d e8 29 25 00 	mov    0x2529e8(%rip),%rdi        # 257e88 <screen1_label1_obj>
    54a0:	41 b8 fb ff ff ff    	mov    $0xfffffffb,%r8d
    54a6:	b9 f1 ff ff ff       	mov    $0xfffffff1,%ecx
    54ab:	ba 06 00 00 00       	mov    $0x6,%edx
    54b0:	e8 05 5b 01 00       	callq  1afba <lv_obj_align>
    54b5:	48 8b 3d b4 0b 23 00 	mov    0x230bb4(%rip),%rdi        # 236070 <screens+0x30>
    54bc:	e8 2c 3e 01 00       	callq  192ed <lv_disp_load_scr>

	/*
	 *  build basic screen2
	 */
	lv_scr_load(screens[2].screen);
	lv_obj_t * screen2_page = lv_label_create(lv_scr_act(), NULL);
    54c1:	e8 47 fc ff ff       	callq  510d <lv_scr_act>
    54c6:	31 f6                	xor    %esi,%esi
    54c8:	48 89 c7             	mov    %rax,%rdi
    54cb:	e8 8c 4c 02 00       	callq  2a15c <lv_label_create>
	lv_label_set_text(screen2_page, "Pg3");
    54d0:	48 8d 35 12 bc 02 00 	lea    0x2bc12(%rip),%rsi        # 310e9 <__func__.5785+0x481>
    54d7:	48 89 c7             	mov    %rax,%rdi
	lv_obj_t * screen2_page = lv_label_create(lv_scr_act(), NULL);
    54da:	48 89 c3             	mov    %rax,%rbx
	lv_label_set_text(screen2_page, "Pg3");
    54dd:	e8 e5 4a 02 00       	callq  29fc7 <lv_label_set_text>
	lv_obj_align(screen2_page, screens[2].screen, LV_ALIGN_IN_TOP_RIGHT, 0, 0);
    54e2:	48 8b 35 87 0b 23 00 	mov    0x230b87(%rip),%rsi        # 236070 <screens+0x30>
    54e9:	45 31 c0             	xor    %r8d,%r8d
    54ec:	31 c9                	xor    %ecx,%ecx
    54ee:	ba 03 00 00 00       	mov    $0x3,%edx
    54f3:	48 89 df             	mov    %rbx,%rdi
    54f6:	e8 bf 5a 01 00       	callq  1afba <lv_obj_align>
	// why define the same button all over again? jj
	display_button();
    54fb:	31 c0                	xor    %eax,%eax
    54fd:	e8 ba fc ff ff       	callq  51bc <display_button>

	//
	lv_obj_t * screen2_label0_tag = lv_label_create(lv_scr_act(), NULL);
    5502:	e8 06 fc ff ff       	callq  510d <lv_scr_act>
    5507:	31 f6                	xor    %esi,%esi
    5509:	48 89 c7             	mov    %rax,%rdi
    550c:	e8 4b 4c 02 00       	callq  2a15c <lv_label_create>
	lv_label_set_text(screen2_label0_tag, "value-0");
    5511:	48 8d 35 d5 bb 02 00 	lea    0x2bbd5(%rip),%rsi        # 310ed <__func__.5785+0x485>
    5518:	48 89 c7             	mov    %rax,%rdi
	lv_obj_t * screen2_label0_tag = lv_label_create(lv_scr_act(), NULL);
    551b:	48 89 c3             	mov    %rax,%rbx
	lv_label_set_text(screen2_label0_tag, "value-0");
    551e:	e8 a4 4a 02 00       	callq  29fc7 <lv_label_set_text>
	lv_obj_align(screen2_label0_tag, screens[2].screen, LV_ALIGN_IN_TOP_RIGHT, -70, 2);
    5523:	48 8b 35 46 0b 23 00 	mov    0x230b46(%rip),%rsi        # 236070 <screens+0x30>
    552a:	41 b8 02 00 00 00    	mov    $0x2,%r8d
    5530:	b9 ba ff ff ff       	mov    $0xffffffba,%ecx
    5535:	ba 03 00 00 00       	mov    $0x3,%edx
    553a:	48 89 df             	mov    %rbx,%rdi
    553d:	e8 78 5a 01 00       	callq  1afba <lv_obj_align>

	screen2_label0_obj = lv_label_create(lv_scr_act(), NULL);
    5542:	e8 c6 fb ff ff       	callq  510d <lv_scr_act>
    5547:	31 f6                	xor    %esi,%esi
    5549:	48 89 c7             	mov    %rax,%rdi
    554c:	e8 0b 4c 02 00       	callq  2a15c <lv_label_create>
	lv_label_set_text(screen2_label0_obj, "0");
    5551:	48 8d 35 e0 e5 02 00 	lea    0x2e5e0(%rip),%rsi        # 33b38 <_lv_bpp1_opa_table+0x2e3>
    5558:	48 89 c7             	mov    %rax,%rdi
	screen2_label0_obj = lv_label_create(lv_scr_act(), NULL);
    555b:	48 89 05 1e 29 25 00 	mov    %rax,0x25291e(%rip)        # 257e80 <screen2_label0_obj>
	lv_label_set_text(screen2_label0_obj, "0");
    5562:	e8 60 4a 02 00       	callq  29fc7 <lv_label_set_text>
	lv_obj_align(screen2_label0_obj, screens[2].screen, LV_ALIGN_IN_TOP_RIGHT, -45, 2);
    5567:	48 8b 35 02 0b 23 00 	mov    0x230b02(%rip),%rsi        # 236070 <screens+0x30>
    556e:	48 8b 3d 0b 29 25 00 	mov    0x25290b(%rip),%rdi        # 257e80 <screen2_label0_obj>
    5575:	41 b8 02 00 00 00    	mov    $0x2,%r8d
    557b:	b9 d3 ff ff ff       	mov    $0xffffffd3,%ecx
    5580:	ba 03 00 00 00       	mov    $0x3,%edx
    5585:	e8 30 5a 01 00       	callq  1afba <lv_obj_align>

	//
	lv_obj_t * screen2_label1_tag = lv_label_create(lv_scr_act(), NULL);
    558a:	e8 7e fb ff ff       	callq  510d <lv_scr_act>
    558f:	31 f6                	xor    %esi,%esi
    5591:	48 89 c7             	mov    %rax,%rdi
    5594:	e8 c3 4b 02 00       	callq  2a15c <lv_label_create>
	lv_label_set_text(screen2_label1_tag, "value-1");
    5599:	48 8d 35 55 bb 02 00 	lea    0x2bb55(%rip),%rsi        # 310f5 <__func__.5785+0x48d>
    55a0:	48 89 c7             	mov    %rax,%rdi
	lv_obj_t * screen2_label1_tag = lv_label_create(lv_scr_act(), NULL);
    55a3:	48 89 c3             	mov    %rax,%rbx
	lv_label_set_text(screen2_label1_tag, "value-1");
    55a6:	e8 1c 4a 02 00       	callq  29fc7 <lv_label_set_text>
	lv_obj_align(screen2_label1_tag, screens[2].screen, LV_ALIGN_IN_RIGHT_MID, -70, 0);
    55ab:	48 8b 35 be 0a 23 00 	mov    0x230abe(%rip),%rsi        # 236070 <screens+0x30>
    55b2:	45 31 c0             	xor    %r8d,%r8d
    55b5:	b9 ba ff ff ff       	mov    $0xffffffba,%ecx
    55ba:	ba 08 00 00 00       	mov    $0x8,%edx
    55bf:	48 89 df             	mov    %rbx,%rdi
    55c2:	e8 f3 59 01 00       	callq  1afba <lv_obj_align>

	screen2_label1_obj = lv_label_create(lv_scr_act(), NULL);
    55c7:	e8 41 fb ff ff       	callq  510d <lv_scr_act>
    55cc:	31 f6                	xor    %esi,%esi
    55ce:	48 89 c7             	mov    %rax,%rdi
    55d1:	e8 86 4b 02 00       	callq  2a15c <lv_label_create>
	lv_label_set_text(screen2_label1_obj, "0");
    55d6:	48 8d 35 5b e5 02 00 	lea    0x2e55b(%rip),%rsi        # 33b38 <_lv_bpp1_opa_table+0x2e3>
    55dd:	48 89 c7             	mov    %rax,%rdi
	screen2_label1_obj = lv_label_create(lv_scr_act(), NULL);
    55e0:	48 89 05 91 28 25 00 	mov    %rax,0x252891(%rip)        # 257e78 <screen2_label1_obj>
	lv_label_set_text(screen2_label1_obj, "0");
    55e7:	e8 db 49 02 00       	callq  29fc7 <lv_label_set_text>
	lv_obj_align(screen2_label1_obj, screens[2].screen, LV_ALIGN_IN_RIGHT_MID, -45, 0);
    55ec:	48 8b 35 7d 0a 23 00 	mov    0x230a7d(%rip),%rsi        # 236070 <screens+0x30>
    55f3:	48 8b 3d 7e 28 25 00 	mov    0x25287e(%rip),%rdi        # 257e78 <screen2_label1_obj>
    55fa:	45 31 c0             	xor    %r8d,%r8d
    55fd:	b9 d3 ff ff ff       	mov    $0xffffffd3,%ecx
    5602:	ba 08 00 00 00       	mov    $0x8,%edx
    5607:	e8 ae 59 01 00       	callq  1afba <lv_obj_align>

	//
	lv_obj_t * screen2_value2_tag = lv_label_create(lv_scr_act(), NULL);
    560c:	e8 fc fa ff ff       	callq  510d <lv_scr_act>
    5611:	31 f6                	xor    %esi,%esi
    5613:	48 89 c7             	mov    %rax,%rdi
    5616:	e8 41 4b 02 00       	callq  2a15c <lv_label_create>
	lv_label_set_text(screen2_value2_tag, "value-2");
    561b:	48 8d 35 db ba 02 00 	lea    0x2badb(%rip),%rsi        # 310fd <__func__.5785+0x495>
    5622:	48 89 c7             	mov    %rax,%rdi
	lv_obj_t * screen2_value2_tag = lv_label_create(lv_scr_act(), NULL);
    5625:	48 89 c3             	mov    %rax,%rbx
	lv_label_set_text(screen2_value2_tag, "value-2");
    5628:	e8 9a 49 02 00       	callq  29fc7 <lv_label_set_text>
	lv_obj_align(screen2_value2_tag, screens[2].screen, LV_ALIGN_IN_BOTTOM_RIGHT, -70, -2);
    562d:	48 8b 35 3c 0a 23 00 	mov    0x230a3c(%rip),%rsi        # 236070 <screens+0x30>
    5634:	41 b8 fe ff ff ff    	mov    $0xfffffffe,%r8d
    563a:	b9 ba ff ff ff       	mov    $0xffffffba,%ecx
    563f:	ba 06 00 00 00       	mov    $0x6,%edx
    5644:	48 89 df             	mov    %rbx,%rdi
    5647:	e8 6e 59 01 00       	callq  1afba <lv_obj_align>

	screen2_label2_obj = lv_label_create(lv_scr_act(), NULL);
    564c:	e8 bc fa ff ff       	callq  510d <lv_scr_act>
    5651:	31 f6                	xor    %esi,%esi
    5653:	48 89 c7             	mov    %rax,%rdi
    5656:	e8 01 4b 02 00       	callq  2a15c <lv_label_create>
	lv_label_set_text(screen2_label2_obj, "0");
    565b:	48 8d 35 d6 e4 02 00 	lea    0x2e4d6(%rip),%rsi        # 33b38 <_lv_bpp1_opa_table+0x2e3>
    5662:	48 89 c7             	mov    %rax,%rdi
	screen2_label2_obj = lv_label_create(lv_scr_act(), NULL);
    5665:	48 89 05 04 28 25 00 	mov    %rax,0x252804(%rip)        # 257e70 <screen2_label2_obj>
	lv_label_set_text(screen2_label2_obj, "0");
    566c:	e8 56 49 02 00       	callq  29fc7 <lv_label_set_text>
	lv_obj_align(screen2_label2_obj, screens[2].screen, LV_ALIGN_IN_BOTTOM_RIGHT, -45, -2);
    5671:	48 8b 35 f8 09 23 00 	mov    0x2309f8(%rip),%rsi        # 236070 <screens+0x30>
    5678:	48 8b 3d f1 27 25 00 	mov    0x2527f1(%rip),%rdi        # 257e70 <screen2_label2_obj>
    567f:	41 b8 fe ff ff ff    	mov    $0xfffffffe,%r8d
    5685:	b9 d3 ff ff ff       	mov    $0xffffffd3,%ecx
    568a:	ba 06 00 00 00       	mov    $0x6,%edx
    568f:	e8 26 59 01 00       	callq  1afba <lv_obj_align>
    5694:	48 8b 3d ed 09 23 00 	mov    0x2309ed(%rip),%rdi        # 236088 <screens+0x48>
    569b:	e8 4d 3c 01 00       	callq  192ed <lv_disp_load_scr>

	/*
	 *  build basic screen3
	 */
	lv_scr_load(screens[3].screen);
	lv_obj_t * screen3_page = lv_label_create(lv_scr_act(), NULL);
    56a0:	e8 68 fa ff ff       	callq  510d <lv_scr_act>
    56a5:	31 f6                	xor    %esi,%esi
    56a7:	48 89 c7             	mov    %rax,%rdi
    56aa:	e8 ad 4a 02 00       	callq  2a15c <lv_label_create>
	lv_label_set_text(screen3_page, "Sc4");
    56af:	48 8d 35 4f ba 02 00 	lea    0x2ba4f(%rip),%rsi        # 31105 <__func__.5785+0x49d>
    56b6:	48 89 c7             	mov    %rax,%rdi
	lv_obj_t * screen3_page = lv_label_create(lv_scr_act(), NULL);
    56b9:	48 89 c3             	mov    %rax,%rbx
	lv_label_set_text(screen3_page, "Sc4");
    56bc:	e8 06 49 02 00       	callq  29fc7 <lv_label_set_text>
	lv_obj_align(screen3_page, screens[3].screen, LV_ALIGN_IN_TOP_RIGHT, 0, 0);
    56c1:	48 8b 35 c0 09 23 00 	mov    0x2309c0(%rip),%rsi        # 236088 <screens+0x48>
    56c8:	48 89 df             	mov    %rbx,%rdi
    56cb:	45 31 c0             	xor    %r8d,%r8d
    56ce:	31 c9                	xor    %ecx,%ecx
    56d0:	ba 03 00 00 00       	mov    $0x3,%edx
    56d5:	e8 e0 58 01 00       	callq  1afba <lv_obj_align>
	display_button();

	//	lv_obj_t * icon_3 = lv_img_create(lv_scr_act(), NULL);
	//	lv_img_set_src(icon_3, &icon3);
	//	lv_obj_align(icon_3, NULL, LV_ALIGN_CENTER, 0, 0);
}
    56da:	5b                   	pop    %rbx
	display_button();
    56db:	31 c0                	xor    %eax,%eax
    56dd:	e9 da fa ff ff       	jmpq   51bc <display_button>

00000000000056e2 <display_init>:
#endif



int display_init(void)
{
    56e2:	48 83 ec 08          	sub    $0x8,%rsp
	if (z_syscall_trap()) {
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    56e6:	48 8d 3d 1c ba 02 00 	lea    0x2ba1c(%rip),%rdi        # 31109 <__func__.5785+0x4a1>
    56ed:	e8 5a 51 02 00       	callq  2a84c <z_impl_device_get_binding>
#if defined(CONFIG_BOARD_PINETIME_DEVKIT1)
	backlight_init();
#endif
	display_dev = device_get_binding(CONFIG_LVGL_DISPLAY_DEV_NAME);

	if (display_dev == NULL) {
    56f2:	48 85 c0             	test   %rax,%rax
	display_dev = device_get_binding(CONFIG_LVGL_DISPLAY_DEV_NAME);
    56f5:	48 89 05 c4 27 25 00 	mov    %rax,0x2527c4(%rip)        # 257ec0 <display_dev>
	if (display_dev == NULL) {
    56fc:	75 30                	jne    572e <display_init+0x4c>
    56fe:	48 8d 15 0b 4d 23 00 	lea    0x234d0b(%rip),%rdx        # 23a410 <log_const_display>
    5705:	48 2b 15 44 08 23 00 	sub    0x230844(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		LOG_ERR("device not found. %s", CONFIG_LVGL_DISPLAY_DEV_NAME);
    570c:	48 8d 35 f6 b9 02 00 	lea    0x2b9f6(%rip),%rsi        # 31109 <__func__.5785+0x4a1>
    5713:	48 8d 3d f7 b9 02 00 	lea    0x2b9f7(%rip),%rdi        # 31111 <__func__.5785+0x4a9>
    571a:	48 c1 ea 04          	shr    $0x4,%rdx
    571e:	c1 e2 06             	shl    $0x6,%edx
    5721:	83 ca 01             	or     $0x1,%edx
    5724:	e8 cc 1b 00 00       	callq  72f5 <log_1>
		return -1;
    5729:	83 c8 ff             	or     $0xffffffff,%eax
    572c:	eb 3c                	jmp    576a <display_init+0x88>
	}

	//lv_init();

	display_screens_init();
    572e:	e8 28 fb ff ff       	callq  525b <display_screens_init>
    5733:	48 8b 3d 06 09 23 00 	mov    0x230906(%rip),%rdi        # 236040 <screens>
    573a:	e8 ae 3b 01 00       	callq  192ed <lv_disp_load_scr>
	lv_scr_load(screens[0].screen);

	/*
	 *  Turn on display
	 */
	lv_task_handler();//jj
    573f:	e8 94 0d 02 00       	callq  264d8 <lv_task_handler>
	display_blanking_off(display_dev);
    5744:	48 8b 3d 75 27 25 00 	mov    0x252775(%rip),%rdi        # 257ec0 <display_dev>
static inline int display_blanking_off(const struct device *dev)
{
	struct display_driver_api *api =
		(struct display_driver_api *)dev->api;

	return api->blanking_off(dev);
    574b:	48 8b 47 10          	mov    0x10(%rdi),%rax
    574f:	ff 50 08             	callq  *0x8(%rax)
	z_impl_k_timer_start(timer, duration, period);
    5752:	48 8d 3d bf 4d 23 00 	lea    0x234dbf(%rip),%rdi        # 23a518 <display_timer>
    5759:	ba 01 00 00 00       	mov    $0x1,%edx
    575e:	be 01 00 00 00       	mov    $0x1,%esi
    5763:	e8 1f 71 02 00       	callq  2c887 <z_impl_k_timer_start>
	/*
	 *  Start task handler timer loop
	 */
	k_timer_start(&display_timer, K_MSEC(TICK_PERIOD), K_MSEC(TICK_PERIOD));

	return 0;
    5768:	31 c0                	xor    %eax,%eax
};
    576a:	5a                   	pop    %rdx
    576b:	c3                   	retq   

000000000000576c <zephyr_app_main>:
#include "event_handler.h"
#include "bt.h"


void main(void)
{
    576c:	48 83 ec 08          	sub    $0x8,%rsp
#if !(defined(CONFIG_BOARD_NATIVE_POSIX_64BIT)) //both the pinetime & ds_d6 have a real button 
	{
		init_button();
	}
#endif
	display_init();
    5770:	e8 6d ff ff ff       	callq  56e2 <display_init>
	clock_init();
    5775:	e8 37 f4 ff ff       	callq  4bb1 <clock_init>
        bt_init();
    577a:	e8 bf f2 ff ff       	callq  4a3e <bt_init>
	return z_impl_k_sleep(timeout);
    577f:	bf 0a 00 00 00       	mov    $0xa,%edi
    5784:	e8 3d 67 02 00       	callq  2bec6 <z_impl_k_sleep>
    5789:	eb f4                	jmp    577f <zephyr_app_main+0x13>

000000000000578b <u8_to_dec>:
#include <sys/util.h>

uint8_t u8_to_dec(char *buf, uint8_t buflen, uint8_t value)
{
	uint8_t divisor = 100;
	uint8_t num_digits = 0;
    578b:	45 31 c0             	xor    %r8d,%r8d
	uint8_t digit;

	while (buflen > 0 && divisor > 0) {
    578e:	40 84 f6             	test   %sil,%sil
	uint8_t divisor = 100;
    5791:	b1 64                	mov    $0x64,%cl
			buflen--;
			num_digits++;
		}

		value -= digit * divisor;
		divisor /= 10;
    5793:	41 b1 0a             	mov    $0xa,%r9b
	while (buflen > 0 && divisor > 0) {
    5796:	74 04                	je     579c <u8_to_dec+0x11>
    5798:	84 c9                	test   %cl,%cl
    579a:	75 0c                	jne    57a8 <u8_to_dec+0x1d>
	}

	if (buflen) {
    579c:	40 84 f6             	test   %sil,%sil
    579f:	74 03                	je     57a4 <u8_to_dec+0x19>
		*buf = '\0';
    57a1:	c6 07 00             	movb   $0x0,(%rdi)
	}

	return num_digits;
}
    57a4:	44 88 c0             	mov    %r8b,%al
    57a7:	c3                   	retq   
{
    57a8:	53                   	push   %rbx
    57a9:	0f b6 c2             	movzbl %dl,%eax
    57ac:	f6 f1                	div    %cl
		if (digit != 0 || divisor == 1 || num_digits != 0) {
    57ae:	80 f9 01             	cmp    $0x1,%cl
    57b1:	0f 94 c3             	sete   %bl
    57b4:	45 84 c0             	test   %r8b,%r8b
    57b7:	41 0f 95 c3          	setne  %r11b
    57bb:	44 08 db             	or     %r11b,%bl
    57be:	0f b6 d4             	movzbl %ah,%edx
    57c1:	75 04                	jne    57c7 <u8_to_dec+0x3c>
    57c3:	84 c0                	test   %al,%al
    57c5:	74 10                	je     57d7 <u8_to_dec+0x4c>
			*buf = (char)digit + '0';
    57c7:	83 c0 30             	add    $0x30,%eax
			buf++;
    57ca:	48 ff c7             	inc    %rdi
			buflen--;
    57cd:	ff ce                	dec    %esi
			*buf = (char)digit + '0';
    57cf:	88 47 ff             	mov    %al,-0x1(%rdi)
			num_digits++;
    57d2:	41 ff c0             	inc    %r8d
    57d5:	eb 03                	jmp    57da <u8_to_dec+0x4f>
    57d7:	45 31 c0             	xor    %r8d,%r8d
		divisor /= 10;
    57da:	0f b6 c1             	movzbl %cl,%eax
    57dd:	41 f6 f1             	div    %r9b
	while (buflen > 0 && divisor > 0) {
    57e0:	40 84 f6             	test   %sil,%sil
		divisor /= 10;
    57e3:	88 c1                	mov    %al,%cl
	while (buflen > 0 && divisor > 0) {
    57e5:	74 04                	je     57eb <u8_to_dec+0x60>
    57e7:	84 c0                	test   %al,%al
    57e9:	75 be                	jne    57a9 <u8_to_dec+0x1e>
	if (buflen) {
    57eb:	40 84 f6             	test   %sil,%sil
    57ee:	74 03                	je     57f3 <u8_to_dec+0x68>
		*buf = '\0';
    57f0:	c6 07 00             	movb   $0x0,(%rdi)
}
    57f3:	44 88 c0             	mov    %r8b,%al
    57f6:	5b                   	pop    %rbx
    57f7:	c3                   	retq   

00000000000057f8 <char2hex>:
#include <errno.h>
#include <sys/util.h>

int char2hex(char c, uint8_t *x)
{
	if (c >= '0' && c <= '9') {
    57f8:	8d 47 d0             	lea    -0x30(%rdi),%eax
    57fb:	3c 09                	cmp    $0x9,%al
    57fd:	77 04                	ja     5803 <char2hex+0xb>
		*x = c - '0';
    57ff:	88 06                	mov    %al,(%rsi)
    5801:	eb 1f                	jmp    5822 <char2hex+0x2a>
	} else if (c >= 'a' && c <= 'f') {
    5803:	8d 47 9f             	lea    -0x61(%rdi),%eax
    5806:	3c 05                	cmp    $0x5,%al
    5808:	77 05                	ja     580f <char2hex+0x17>
		*x = c - 'a' + 10;
    580a:	83 ef 57             	sub    $0x57,%edi
    580d:	eb 10                	jmp    581f <char2hex+0x27>
	} else if (c >= 'A' && c <= 'F') {
    580f:	8d 57 bf             	lea    -0x41(%rdi),%edx
		*x = c - 'A' + 10;
	} else {
		return -EINVAL;
    5812:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	} else if (c >= 'A' && c <= 'F') {
    5817:	80 fa 05             	cmp    $0x5,%dl
    581a:	77 08                	ja     5824 <char2hex+0x2c>
		*x = c - 'A' + 10;
    581c:	83 ef 37             	sub    $0x37,%edi
    581f:	40 88 3e             	mov    %dil,(%rsi)
	}

	return 0;
    5822:	31 c0                	xor    %eax,%eax
}
    5824:	c3                   	retq   

0000000000005825 <hex2bin>:
	hex[2 * buflen] = '\0';
	return 2 * buflen;
}

size_t hex2bin(const char *hex, size_t hexlen, uint8_t *buf, size_t buflen)
{
    5825:	41 57                	push   %r15
    5827:	41 56                	push   %r14
    5829:	41 55                	push   %r13
	uint8_t dec;

	if (buflen < hexlen / 2 + hexlen % 2) {
    582b:	49 89 f5             	mov    %rsi,%r13
{
    582e:	41 54                	push   %r12
	if (buflen < hexlen / 2 + hexlen % 2) {
    5830:	49 d1 ed             	shr    %r13
{
    5833:	55                   	push   %rbp
	if (buflen < hexlen / 2 + hexlen % 2) {
    5834:	83 e6 01             	and    $0x1,%esi
{
    5837:	53                   	push   %rbx
	if (buflen < hexlen / 2 + hexlen % 2) {
    5838:	4d 8d 74 35 00       	lea    0x0(%r13,%rsi,1),%r14
{
    583d:	48 83 ec 18          	sub    $0x18,%rsp
    5841:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5848:	00 00 
    584a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    584f:	31 c0                	xor    %eax,%eax
	if (buflen < hexlen / 2 + hexlen % 2) {
    5851:	49 39 ce             	cmp    %rcx,%r14
    5854:	76 05                	jbe    585b <hex2bin+0x36>
		return 0;
    5856:	45 31 f6             	xor    %r14d,%r14d
    5859:	eb 70                	jmp    58cb <hex2bin+0xa6>
	}

	/* if hexlen is uneven, insert leading zero nibble */
	if (hexlen % 2) {
    585b:	48 85 f6             	test   %rsi,%rsi
    585e:	49 89 fc             	mov    %rdi,%r12
    5861:	48 89 d5             	mov    %rdx,%rbp
    5864:	74 1e                	je     5884 <hex2bin+0x5f>
		if (char2hex(hex[0], &dec) < 0) {
    5866:	0f be 3f             	movsbl (%rdi),%edi
    5869:	48 8d 74 24 07       	lea    0x7(%rsp),%rsi
    586e:	e8 85 ff ff ff       	callq  57f8 <char2hex>
    5873:	85 c0                	test   %eax,%eax
    5875:	78 df                	js     5856 <hex2bin+0x31>
			return 0;
		}
		buf[0] = dec;
    5877:	8a 44 24 07          	mov    0x7(%rsp),%al
		hex++;
    587b:	49 ff c4             	inc    %r12
		buf++;
    587e:	48 ff c5             	inc    %rbp
		buf[0] = dec;
    5881:	88 45 ff             	mov    %al,-0x1(%rbp)
	}

	/* regular hex conversion */
	for (size_t i = 0; i < hexlen / 2; i++) {
		if (char2hex(hex[2 * i], &dec) < 0) {
    5884:	4c 8d 7c 24 07       	lea    0x7(%rsp),%r15
	for (size_t i = 0; i < hexlen / 2; i++) {
    5889:	31 db                	xor    %ebx,%ebx
    588b:	49 39 dd             	cmp    %rbx,%r13
    588e:	74 3b                	je     58cb <hex2bin+0xa6>
		if (char2hex(hex[2 * i], &dec) < 0) {
    5890:	41 0f be 3c 5c       	movsbl (%r12,%rbx,2),%edi
    5895:	4c 89 fe             	mov    %r15,%rsi
    5898:	e8 5b ff ff ff       	callq  57f8 <char2hex>
    589d:	85 c0                	test   %eax,%eax
    589f:	78 b5                	js     5856 <hex2bin+0x31>
			return 0;
		}
		buf[i] = dec << 4;
    58a1:	8a 44 24 07          	mov    0x7(%rsp),%al

		if (char2hex(hex[2 * i + 1], &dec) < 0) {
    58a5:	4c 89 fe             	mov    %r15,%rsi
		buf[i] = dec << 4;
    58a8:	c1 e0 04             	shl    $0x4,%eax
    58ab:	88 44 1d 00          	mov    %al,0x0(%rbp,%rbx,1)
		if (char2hex(hex[2 * i + 1], &dec) < 0) {
    58af:	41 0f be 7c 5c 01    	movsbl 0x1(%r12,%rbx,2),%edi
    58b5:	e8 3e ff ff ff       	callq  57f8 <char2hex>
    58ba:	85 c0                	test   %eax,%eax
    58bc:	78 98                	js     5856 <hex2bin+0x31>
			return 0;
		}
		buf[i] += dec;
    58be:	8a 44 24 07          	mov    0x7(%rsp),%al
    58c2:	00 44 1d 00          	add    %al,0x0(%rbp,%rbx,1)
	for (size_t i = 0; i < hexlen / 2; i++) {
    58c6:	48 ff c3             	inc    %rbx
    58c9:	eb c0                	jmp    588b <hex2bin+0x66>
	}

	return hexlen / 2 + hexlen % 2;
}
    58cb:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    58d0:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
    58d7:	00 00 
    58d9:	4c 89 f0             	mov    %r14,%rax
    58dc:	74 05                	je     58e3 <hex2bin+0xbe>
    58de:	e8 5d ed ff ff       	callq  4640 <__stack_chk_fail@plt>
    58e3:	48 83 c4 18          	add    $0x18,%rsp
    58e7:	5b                   	pop    %rbx
    58e8:	5d                   	pop    %rbp
    58e9:	41 5c                	pop    %r12
    58eb:	41 5d                	pop    %r13
    58ed:	41 5e                	pop    %r14
    58ef:	41 5f                	pop    %r15
    58f1:	c3                   	retq   

00000000000058f2 <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
    58f2:	31 c0                	xor    %eax,%eax
    58f4:	c3                   	retq   

00000000000058f5 <char_out>:
static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
	return _char_out(c);
    58f5:	48 8d 05 4c 11 23 00 	lea    0x23114c(%rip),%rax        # 236a48 <_char_out>
	ctx->count++;
    58fc:	ff 06                	incl   (%rsi)
	return _char_out(c);
    58fe:	ff 20                	jmpq   *(%rax)

0000000000005900 <str_out>:
	int count;
};

static int str_out(int c, struct str_context *ctx)
{
	if (ctx->str == NULL || ctx->count >= ctx->max) {
    5900:	48 8b 16             	mov    (%rsi),%rdx
    5903:	8b 4e 0c             	mov    0xc(%rsi),%ecx
{
    5906:	89 f8                	mov    %edi,%eax
	if (ctx->str == NULL || ctx->count >= ctx->max) {
    5908:	48 85 d2             	test   %rdx,%rdx
    590b:	44 8d 49 01          	lea    0x1(%rcx),%r9d
    590f:	74 09                	je     591a <str_out+0x1a>
    5911:	44 8b 46 08          	mov    0x8(%rsi),%r8d
    5915:	41 39 c8             	cmp    %ecx,%r8d
    5918:	7f 05                	jg     591f <str_out+0x1f>
		ctx->count++;
    591a:	44 89 4e 0c          	mov    %r9d,0xc(%rsi)
		return c;
    591e:	c3                   	retq   
    591f:	48 63 f9             	movslq %ecx,%rdi
	}

	if (ctx->count == ctx->max - 1) {
    5922:	41 ff c8             	dec    %r8d
		ctx->str[ctx->count++] = '\0';
    5925:	44 89 4e 0c          	mov    %r9d,0xc(%rsi)
    5929:	48 01 fa             	add    %rdi,%rdx
	if (ctx->count == ctx->max - 1) {
    592c:	41 39 c8             	cmp    %ecx,%r8d
    592f:	75 04                	jne    5935 <str_out+0x35>
		ctx->str[ctx->count++] = '\0';
    5931:	c6 02 00             	movb   $0x0,(%rdx)
    5934:	c3                   	retq   
	} else {
		ctx->str[ctx->count++] = c;
    5935:	88 02                	mov    %al,(%rdx)
	}

	return c;
}
    5937:	c3                   	retq   

0000000000005938 <__printk_hook_install>:
	_char_out = fn;
    5938:	48 8d 05 09 11 23 00 	lea    0x231109(%rip),%rax        # 236a48 <_char_out>
    593f:	48 89 38             	mov    %rdi,(%rax)
}
    5942:	c3                   	retq   

0000000000005943 <vprintk>:
{
    5943:	48 83 ec 18          	sub    $0x18,%rsp
    5947:	48 89 fa             	mov    %rdi,%rdx
    594a:	48 89 f1             	mov    %rsi,%rcx
	cbvprintf(char_out, &ctx, fmt, ap);
    594d:	48 8d 3d a1 ff ff ff 	lea    -0x5f(%rip),%rdi        # 58f5 <char_out>
    5954:	48 8d 74 24 04       	lea    0x4(%rsp),%rsi
	struct out_context ctx = { 0 };
    5959:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%rsp)
    5960:	00 
{
    5961:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5968:	00 00 
    596a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    596f:	31 c0                	xor    %eax,%eax
	cbvprintf(char_out, &ctx, fmt, ap);
    5971:	e8 75 08 00 00       	callq  61eb <cbvprintf>
}
    5976:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    597b:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    5982:	00 00 
    5984:	74 05                	je     598b <vprintk+0x48>
    5986:	e8 b5 ec ff ff       	callq  4640 <__stack_chk_fail@plt>
    598b:	48 83 c4 18          	add    $0x18,%rsp
    598f:	c3                   	retq   

0000000000005990 <printk>:
{
    5990:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    5997:	84 c0                	test   %al,%al
    5999:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    599e:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    59a3:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    59a8:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    59ad:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    59b2:	74 37                	je     59eb <printk+0x5b>
    59b4:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    59b9:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    59be:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    59c3:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    59ca:	00 
    59cb:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    59d2:	00 
    59d3:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    59da:	00 
    59db:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    59e2:	00 
    59e3:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    59ea:	00 
    59eb:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    59f2:	00 00 
    59f4:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    59f9:	31 c0                	xor    %eax,%eax
	va_start(ap, fmt);
    59fb:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    5a02:	00 
		vprintk(fmt, ap);
    5a03:	48 89 e6             	mov    %rsp,%rsi
	va_start(ap, fmt);
    5a06:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    5a0b:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    5a10:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    5a17:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    5a1e:	00 
    5a1f:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
		vprintk(fmt, ap);
    5a24:	e8 1a ff ff ff       	callq  5943 <vprintk>
}
    5a29:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    5a2e:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    5a35:	00 00 
    5a37:	74 05                	je     5a3e <printk+0xae>
    5a39:	e8 02 ec ff ff       	callq  4640 <__stack_chk_fail@plt>
    5a3e:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    5a45:	c3                   	retq   

0000000000005a46 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
    5a46:	53                   	push   %rbx
    5a47:	48 89 fb             	mov    %rdi,%rbx
    5a4a:	48 83 ec 20          	sub    $0x20,%rsp
	struct str_context ctx = { str, size, 0 };
    5a4e:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
    5a53:	89 74 24 10          	mov    %esi,0x10(%rsp)

	cbvprintf(str_out, &ctx, fmt, ap);
    5a57:	48 8d 3d a2 fe ff ff 	lea    -0x15e(%rip),%rdi        # 5900 <str_out>
    5a5e:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
	struct str_context ctx = { str, size, 0 };
    5a63:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%rsp)
    5a6a:	00 
{
    5a6b:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5a72:	00 00 
    5a74:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    5a79:	31 c0                	xor    %eax,%eax
	cbvprintf(str_out, &ctx, fmt, ap);
    5a7b:	e8 6b 07 00 00       	callq  61eb <cbvprintf>

	if (ctx.count < ctx.max) {
    5a80:	8b 44 24 14          	mov    0x14(%rsp),%eax
    5a84:	3b 44 24 10          	cmp    0x10(%rsp),%eax
    5a88:	7d 07                	jge    5a91 <vsnprintk+0x4b>
		str[ctx.count] = '\0';
    5a8a:	48 63 d0             	movslq %eax,%rdx
    5a8d:	c6 04 13 00          	movb   $0x0,(%rbx,%rdx,1)
	}

	return ctx.count;
}
    5a91:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
    5a96:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
    5a9d:	00 00 
    5a9f:	74 05                	je     5aa6 <vsnprintk+0x60>
    5aa1:	e8 9a eb ff ff       	callq  4640 <__stack_chk_fail@plt>
    5aa6:	48 83 c4 20          	add    $0x20,%rsp
    5aaa:	5b                   	pop    %rbx
    5aab:	c3                   	retq   

0000000000005aac <snprintk>:
{
    5aac:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    5ab3:	84 c0                	test   %al,%al
    5ab5:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    5aba:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    5abf:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    5ac4:	74 37                	je     5afd <snprintk+0x51>
    5ac6:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    5acb:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    5ad0:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    5ad5:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    5adc:	00 
    5add:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    5ae4:	00 
    5ae5:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    5aec:	00 
    5aed:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    5af4:	00 
    5af5:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    5afc:	00 
    5afd:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5b04:	00 00 
    5b06:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    5b0b:	31 c0                	xor    %eax,%eax
	va_start(ap, fmt);
    5b0d:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    5b14:	00 
	ret = vsnprintk(str, size, fmt, ap);
    5b15:	48 89 e1             	mov    %rsp,%rcx
	va_start(ap, fmt);
    5b18:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    5b1d:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    5b22:	c7 04 24 18 00 00 00 	movl   $0x18,(%rsp)
    5b29:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    5b30:	00 
    5b31:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
	ret = vsnprintk(str, size, fmt, ap);
    5b36:	e8 0b ff ff ff       	callq  5a46 <vsnprintk>
}
    5b3b:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
    5b40:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
    5b47:	00 00 
    5b49:	74 05                	je     5b50 <snprintk+0xa4>
    5b4b:	e8 f0 ea ff ff       	callq  4640 <__stack_chk_fail@plt>
    5b50:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    5b57:	c3                   	retq   

0000000000005b58 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    5b58:	48 89 f8             	mov    %rdi,%rax
    5b5b:	48 83 ec 08          	sub    $0x8,%rsp
    5b5f:	48 89 f7             	mov    %rsi,%rdi
    5b62:	48 89 d6             	mov    %rdx,%rsi
    5b65:	48 89 ca             	mov    %rcx,%rdx
	entry(p1, p2, p3);
    5b68:	ff d0                	callq  *%rax
	return z_impl_k_current_get();
    5b6a:	31 c0                	xor    %eax,%eax
    5b6c:	e8 8f 63 02 00       	callq  2bf00 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
    5b71:	48 89 c7             	mov    %rax,%rdi
    5b74:	e8 5d 4d 00 00       	callq  a8d6 <z_impl_k_thread_abort>
	/*
	 * Compiler can't tell that k_thread_abort() won't return and issues a
	 * warning unless we tell it that control never gets this far.
	 */

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    5b79:	48 8d 35 aa b5 02 00 	lea    0x2b5aa(%rip),%rsi        # 3112a <__func__.5785+0x4c2>
    5b80:	48 8d 3d cb b5 02 00 	lea    0x2b5cb(%rip),%rdi        # 31152 <__func__.5785+0x4ea>
    5b87:	ba 26 00 00 00       	mov    $0x26,%edx
    5b8c:	31 c0                	xor    %eax,%eax
    5b8e:	e8 2f 67 00 00       	callq  c2c2 <posix_print_error_and_exit>

0000000000005b93 <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
    5b93:	55                   	push   %rbp
    5b94:	53                   	push   %rbx
	if (z_syscall_trap()) {
		return (void *) arch_syscall_invoke2(*(uintptr_t *)&queue, *(uintptr_t *)&timeout, K_SYSCALL_K_QUEUE_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_queue_get(queue, timeout);
    5b95:	48 83 cd ff          	or     $0xffffffffffffffff,%rbp
    5b99:	48 89 fb             	mov    %rdi,%rbx
    5b9c:	48 83 ec 08          	sub    $0x8,%rsp
    5ba0:	48 89 df             	mov    %rbx,%rdi
    5ba3:	48 89 ee             	mov    %rbp,%rsi
    5ba6:	e8 49 58 02 00       	callq  2b3f4 <z_impl_k_queue_get>
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
    5bab:	48 85 c0             	test   %rax,%rax
    5bae:	48 89 c7             	mov    %rax,%rdi
    5bb1:	74 ed                	je     5ba0 <z_work_q_main+0xd>
			continue;
		}

		handler = work->handler;
    5bb3:	48 8b 50 08          	mov    0x8(%rax),%rdx
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    5bb7:	8b 40 10             	mov    0x10(%rax),%eax
    5bba:	89 c6                	mov    %eax,%esi
    5bbc:	89 c1                	mov    %eax,%ecx
    5bbe:	83 e6 fe             	and    $0xfffffffe,%esi
    5bc1:	f0 0f b1 77 10       	lock cmpxchg %esi,0x10(%rdi)
    5bc6:	75 f2                	jne    5bba <z_work_q_main+0x27>
		__ASSERT(handler != NULL, "handler must be provided");

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
    5bc8:	80 e1 01             	and    $0x1,%cl
    5bcb:	74 02                	je     5bcf <z_work_q_main+0x3c>
					      K_WORK_STATE_PENDING)) {
			handler(work);
    5bcd:	ff d2                	callq  *%rdx
	z_impl_k_yield();
    5bcf:	31 c0                	xor    %eax,%eax
    5bd1:	e8 20 62 02 00       	callq  2bdf6 <z_impl_k_yield>
    5bd6:	eb c8                	jmp    5ba0 <z_work_q_main+0xd>

0000000000005bd8 <chunk_size>:
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
    5bd8:	8b 44 f7 04          	mov    0x4(%rdi,%rsi,8),%eax
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline size_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
    5bdc:	48 d1 e8             	shr    %rax
}
    5bdf:	c3                   	retq   

0000000000005be0 <set_chunk_used>:

static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
    5be0:	48 8d 0c f7          	lea    (%rdi,%rsi,8),%rcx
    5be4:	8b 41 04             	mov    0x4(%rcx),%eax

	if (big_heap(h)) {
		if (used) {
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
    5be7:	89 c6                	mov    %eax,%esi
    5be9:	83 c8 01             	or     $0x1,%eax
    5bec:	83 e6 fe             	and    $0xfffffffe,%esi
    5bef:	84 d2                	test   %dl,%dl
    5bf1:	0f 44 c6             	cmove  %esi,%eax
    5bf4:	89 41 04             	mov    %eax,0x4(%rcx)
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
		}
	}
}
    5bf7:	c3                   	retq   

0000000000005bf8 <free_list_remove_bidx>:
	void *cmem = &buf[c];
    5bf8:	4c 8d 0c f5 00 00 00 	lea    0x0(,%rsi,8),%r9
    5bff:	00 
		return ((uint32_t *)cmem)[f];
    5c00:	42 8b 44 0f 0c       	mov    0xc(%rdi,%r9,1),%eax

	CHECK(!chunk_used(h, c));
	CHECK(b->next != 0);
	CHECK(h->avail_buckets & (1 << bidx));

	if (next_free_chunk(h, c) == c) {
    5c05:	48 39 c6             	cmp    %rax,%rsi
    5c08:	48 63 f2             	movslq %edx,%rsi
    5c0b:	75 16                	jne    5c23 <free_list_remove_bidx+0x2b>
		/* this is the last chunk */
		h->avail_buckets &= ~(1 << bidx);
    5c0d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    5c12:	88 d1                	mov    %dl,%cl
    5c14:	d3 c0                	rol    %cl,%eax
    5c16:	21 47 0c             	and    %eax,0xc(%rdi)
		b->next = 0;
    5c19:	48 c7 44 f7 10 00 00 	movq   $0x0,0x10(%rdi,%rsi,8)
    5c20:	00 00 
    5c22:	c3                   	retq   
    5c23:	42 8b 4c 0f 08       	mov    0x8(%rdi,%r9,1),%ecx
	} else {
		chunkid_t first = prev_free_chunk(h, c),
			  second = next_free_chunk(h, c);

		b->next = second;
    5c28:	48 89 44 f7 10       	mov    %rax,0x10(%rdi,%rsi,8)
		((uint32_t *)cmem)[f] = val;
    5c2d:	89 44 cf 0c          	mov    %eax,0xc(%rdi,%rcx,8)
    5c31:	89 4c c7 08          	mov    %ecx,0x8(%rdi,%rax,8)
		set_next_free_chunk(h, first, second);
		set_prev_free_chunk(h, second, first);
	}
}
    5c35:	c3                   	retq   

0000000000005c36 <alloc_chunk>:
}

static inline int bucket_idx(struct z_heap *h, size_t sz)
{
	size_t usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
    5c36:	8b 47 08             	mov    0x8(%rdi),%eax
	size_t usable_sz = sz - min_chunk_size(h) + 1;
    5c39:	4c 8d 4e ff          	lea    -0x1(%rsi),%r9
	return 31 - __builtin_clz(usable_sz);
    5c3d:	b9 1f 00 00 00       	mov    $0x1f,%ecx
    5c42:	89 ca                	mov    %ecx,%edx
    5c44:	45 0f bd c9          	bsr    %r9d,%r9d
    5c48:	ff c8                	dec    %eax
    5c4a:	41 83 f1 1f          	xor    $0x1f,%r9d
    5c4e:	0f bd c0             	bsr    %eax,%eax
    5c51:	44 29 ca             	sub    %r9d,%edx
    5c54:	83 f0 1f             	xor    $0x1f,%eax
    5c57:	29 c1                	sub    %eax,%ecx
static chunkid_t alloc_chunk(struct z_heap *h, size_t sz)
{
	int bi = bucket_idx(h, sz);
	struct z_heap_bucket *b = &h->buckets[bi];

	if (bi > bucket_idx(h, h->len)) {
    5c59:	39 d1                	cmp    %edx,%ecx
    5c5b:	7c 7c                	jl     5cd9 <alloc_chunk+0xa3>
    5c5d:	48 63 c2             	movslq %edx,%rax
{
    5c60:	55                   	push   %rbp
    5c61:	53                   	push   %rbx
    5c62:	48 8d 1c c7          	lea    (%rdi,%rax,8),%rbx
    5c66:	48 89 f1             	mov    %rsi,%rcx
    5c69:	49 89 f8             	mov    %rdi,%r8
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
    5c6c:	48 8b 6b 10          	mov    0x10(%rbx),%rbp
    5c70:	48 85 ed             	test   %rbp,%rbp
    5c73:	74 30                	je     5ca5 <alloc_chunk+0x6f>
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
    5c75:	41 bb 03 00 00 00    	mov    $0x3,%r11d
		do {
			chunkid_t c = b->next;
    5c7b:	4c 8b 53 10          	mov    0x10(%rbx),%r10
			if (chunk_size(h, c) >= sz) {
    5c7f:	4c 89 c7             	mov    %r8,%rdi
    5c82:	4c 89 d6             	mov    %r10,%rsi
    5c85:	e8 4e ff ff ff       	callq  5bd8 <chunk_size>
    5c8a:	48 39 c8             	cmp    %rcx,%rax
    5c8d:	73 39                	jae    5cc8 <alloc_chunk+0x92>
		return ((uint32_t *)cmem)[f];
    5c8f:	43 8b 44 d0 0c       	mov    0xc(%r8,%r10,8),%eax
				free_list_remove_bidx(h, c, bi);
				return c;
			}
			b->next = next_free_chunk(h, c);
			CHECK(b->next != 0);
		} while (--i && b->next != first);
    5c94:	41 ff cb             	dec    %r11d
    5c97:	48 39 c5             	cmp    %rax,%rbp
			b->next = next_free_chunk(h, c);
    5c9a:	48 89 43 10          	mov    %rax,0x10(%rbx)
		} while (--i && b->next != first);
    5c9e:	74 05                	je     5ca5 <alloc_chunk+0x6f>
    5ca0:	45 85 db             	test   %r11d,%r11d
    5ca3:	75 d6                	jne    5c7b <alloc_chunk+0x45>
	}

	/* Otherwise pick the smallest non-empty bucket guaranteed to
	 * fit and use that unconditionally.
	 */
	size_t bmask = h->avail_buckets & ~((1 << (bi + 1)) - 1);
    5ca5:	b9 20 00 00 00       	mov    $0x20,%ecx
    5caa:	83 ca ff             	or     $0xffffffff,%edx
    5cad:	44 29 c9             	sub    %r9d,%ecx
    5cb0:	d3 e2                	shl    %cl,%edx

	if ((bmask & h->avail_buckets) != 0U) {
    5cb2:	41 23 50 0c          	and    0xc(%r8),%edx
    5cb6:	75 05                	jne    5cbd <alloc_chunk+0x87>
		return 0;
    5cb8:	45 31 d2             	xor    %r10d,%r10d
    5cbb:	eb 16                	jmp    5cd3 <alloc_chunk+0x9d>
		int minbucket = __builtin_ctz(bmask & h->avail_buckets);
    5cbd:	0f bc d2             	bsf    %edx,%edx
		chunkid_t c = h->buckets[minbucket].next;
    5cc0:	48 63 c2             	movslq %edx,%rax
    5cc3:	4d 8b 54 c0 10       	mov    0x10(%r8,%rax,8),%r10

		free_list_remove_bidx(h, c, minbucket);
    5cc8:	4c 89 d6             	mov    %r10,%rsi
    5ccb:	4c 89 c7             	mov    %r8,%rdi
    5cce:	e8 25 ff ff ff       	callq  5bf8 <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
    5cd3:	4c 89 d0             	mov    %r10,%rax
    5cd6:	5b                   	pop    %rbx
    5cd7:	5d                   	pop    %rbp
    5cd8:	c3                   	retq   
		return 0;
    5cd9:	45 31 d2             	xor    %r10d,%r10d
}
    5cdc:	4c 89 d0             	mov    %r10,%rax
    5cdf:	c3                   	retq   

0000000000005ce0 <free_list_add>:
{
    5ce0:	48 89 fa             	mov    %rdi,%rdx
    5ce3:	49 89 f0             	mov    %rsi,%r8
	return big_heap(h) && chunk_size(h, c) == 1U;
    5ce6:	e8 ed fe ff ff       	callq  5bd8 <chunk_size>
	if (!solo_free_header(h, c)) {
    5ceb:	48 83 f8 01          	cmp    $0x1,%rax
    5cef:	74 5b                	je     5d4c <free_list_add+0x6c>
	size_t usable_sz = sz - min_chunk_size(h) + 1;
    5cf1:	48 ff c8             	dec    %rax
	return 31 - __builtin_clz(usable_sz);
    5cf4:	b9 1f 00 00 00       	mov    $0x1f,%ecx
    5cf9:	0f bd c0             	bsr    %eax,%eax
    5cfc:	83 f0 1f             	xor    $0x1f,%eax
    5cff:	29 c1                	sub    %eax,%ecx
    5d01:	48 63 c1             	movslq %ecx,%rax
    5d04:	4c 8d 14 c7          	lea    (%rdi,%rax,8),%r10
    5d08:	4a 8d 04 c5 00 00 00 	lea    0x0(,%r8,8),%rax
    5d0f:	00 
	if (b->next == 0U) {
    5d10:	49 8b 72 10          	mov    0x10(%r10),%rsi
    5d14:	4c 8d 4c 07 08       	lea    0x8(%rdi,%rax,1),%r9
    5d19:	48 8d 7c 07 0c       	lea    0xc(%rdi,%rax,1),%rdi
    5d1e:	48 85 f6             	test   %rsi,%rsi
    5d21:	75 15                	jne    5d38 <free_list_add+0x58>
		h->avail_buckets |= (1 << bidx);
    5d23:	b8 01 00 00 00       	mov    $0x1,%eax
    5d28:	d3 e0                	shl    %cl,%eax
    5d2a:	09 42 0c             	or     %eax,0xc(%rdx)
		b->next = c;
    5d2d:	4d 89 42 10          	mov    %r8,0x10(%r10)
		((uint32_t *)cmem)[f] = val;
    5d31:	45 89 01             	mov    %r8d,(%r9)
    5d34:	44 89 07             	mov    %r8d,(%rdi)
    5d37:	c3                   	retq   
		return ((uint32_t *)cmem)[f];
    5d38:	48 8d 4c f2 08       	lea    0x8(%rdx,%rsi,8),%rcx
    5d3d:	8b 01                	mov    (%rcx),%eax
		((uint32_t *)cmem)[f] = val;
    5d3f:	41 89 01             	mov    %eax,(%r9)
    5d42:	89 37                	mov    %esi,(%rdi)
    5d44:	44 89 44 c2 0c       	mov    %r8d,0xc(%rdx,%rax,8)
    5d49:	44 89 01             	mov    %r8d,(%rcx)
}
    5d4c:	c3                   	retq   

0000000000005d4d <merge_chunks>:
{
    5d4d:	49 89 f1             	mov    %rsi,%r9
	size_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
    5d50:	e8 83 fe ff ff       	callq  5bd8 <chunk_size>
    5d55:	48 89 d6             	mov    %rdx,%rsi
    5d58:	49 89 c0             	mov    %rax,%r8
    5d5b:	e8 78 fe ff ff       	callq  5bd8 <chunk_size>
    5d60:	49 01 c0             	add    %rax,%r8
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    5d63:	4b 8d 04 00          	lea    (%r8,%r8,1),%rax
		((uint32_t *)cmem)[f] = val;
    5d67:	42 89 44 cf 04       	mov    %eax,0x4(%rdi,%r9,8)
	return c + chunk_size(h, c);
    5d6c:	e8 67 fe ff ff       	callq  5bd8 <chunk_size>
	void *cmem = &buf[c];
    5d71:	48 01 c2             	add    %rax,%rdx
		((uint32_t *)cmem)[f] = val;
    5d74:	44 89 04 d7          	mov    %r8d,(%rdi,%rdx,8)
}
    5d78:	c3                   	retq   

0000000000005d79 <split_chunks>:
{
    5d79:	49 89 f1             	mov    %rsi,%r9
	size_t sz0 = chunk_size(h, lc);
    5d7c:	e8 57 fe ff ff       	callq  5bd8 <chunk_size>
	size_t lsz = rc - lc;
    5d81:	48 89 d6             	mov    %rdx,%rsi
    5d84:	4c 29 ce             	sub    %r9,%rsi
	size_t rsz = sz0 - lsz;
    5d87:	48 29 f0             	sub    %rsi,%rax
    5d8a:	49 89 c0             	mov    %rax,%r8
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    5d8d:	48 8d 04 36          	lea    (%rsi,%rsi,1),%rax
		((uint32_t *)cmem)[f] = val;
    5d91:	42 89 44 cf 04       	mov    %eax,0x4(%rdi,%r9,8)
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    5d96:	4b 8d 04 00          	lea    (%r8,%r8,1),%rax
		((uint32_t *)cmem)[f] = val;
    5d9a:	89 34 d7             	mov    %esi,(%rdi,%rdx,8)
	return c + chunk_size(h, c);
    5d9d:	48 89 d6             	mov    %rdx,%rsi
		((uint32_t *)cmem)[f] = val;
    5da0:	89 44 d7 04          	mov    %eax,0x4(%rdi,%rdx,8)
	return c + chunk_size(h, c);
    5da4:	e8 2f fe ff ff       	callq  5bd8 <chunk_size>
	void *cmem = &buf[c];
    5da9:	48 01 c2             	add    %rax,%rdx
		((uint32_t *)cmem)[f] = val;
    5dac:	44 89 04 d7          	mov    %r8d,(%rdi,%rdx,8)
}
    5db0:	c3                   	retq   

0000000000005db1 <free_list_remove>:
	return big_heap(h) && chunk_size(h, c) == 1U;
    5db1:	e8 22 fe ff ff       	callq  5bd8 <chunk_size>
	if (!solo_free_header(h, c)) {
    5db6:	48 83 f8 01          	cmp    $0x1,%rax
    5dba:	74 15                	je     5dd1 <free_list_remove+0x20>
	size_t usable_sz = sz - min_chunk_size(h) + 1;
    5dbc:	48 ff c8             	dec    %rax
	return 31 - __builtin_clz(usable_sz);
    5dbf:	ba 1f 00 00 00       	mov    $0x1f,%edx
    5dc4:	0f bd c0             	bsr    %eax,%eax
    5dc7:	83 f0 1f             	xor    $0x1f,%eax
    5dca:	29 c2                	sub    %eax,%edx
		free_list_remove_bidx(h, c, bidx);
    5dcc:	e9 27 fe ff ff       	jmpq   5bf8 <free_list_remove_bidx>
}
    5dd1:	c3                   	retq   

0000000000005dd2 <free_chunk>:
{
    5dd2:	53                   	push   %rbx
    5dd3:	49 89 f2             	mov    %rsi,%r10
    5dd6:	49 89 fb             	mov    %rdi,%r11
	return c + chunk_size(h, c);
    5dd9:	e8 fa fd ff ff       	callq  5bd8 <chunk_size>
    5dde:	48 01 c6             	add    %rax,%rsi
	if (!chunk_used(h, right_chunk(h, c))) {
    5de1:	f6 44 f7 04 01       	testb  $0x1,0x4(%rdi,%rsi,8)
    5de6:	75 16                	jne    5dfe <free_chunk+0x2c>
		free_list_remove(h, right_chunk(h, c));
    5de8:	e8 c4 ff ff ff       	callq  5db1 <free_list_remove>
    5ded:	4c 89 d6             	mov    %r10,%rsi
    5df0:	e8 e3 fd ff ff       	callq  5bd8 <chunk_size>
    5df5:	49 8d 14 02          	lea    (%r10,%rax,1),%rdx
		merge_chunks(h, c, right_chunk(h, c));
    5df9:	e8 4f ff ff ff       	callq  5d4d <merge_chunks>
		return ((uint32_t *)cmem)[f];
    5dfe:	4b 8d 1c d3          	lea    (%r11,%r10,8),%rbx
	return c - chunk_field(h, c, LEFT_SIZE);
    5e02:	4c 89 d6             	mov    %r10,%rsi
		return ((uint32_t *)cmem)[f];
    5e05:	8b 03                	mov    (%rbx),%eax
	return c - chunk_field(h, c, LEFT_SIZE);
    5e07:	48 29 c6             	sub    %rax,%rsi
	if (!chunk_used(h, left_chunk(h, c))) {
    5e0a:	41 f6 44 f3 04 01    	testb  $0x1,0x4(%r11,%rsi,8)
    5e10:	75 1d                	jne    5e2f <free_chunk+0x5d>
		free_list_remove(h, left_chunk(h, c));
    5e12:	4c 89 df             	mov    %r11,%rdi
    5e15:	e8 97 ff ff ff       	callq  5db1 <free_list_remove>
		return ((uint32_t *)cmem)[f];
    5e1a:	8b 03                	mov    (%rbx),%eax
	return c - chunk_field(h, c, LEFT_SIZE);
    5e1c:	4c 89 d6             	mov    %r10,%rsi
		merge_chunks(h, left_chunk(h, c), c);
    5e1f:	4c 89 d2             	mov    %r10,%rdx
    5e22:	48 29 c6             	sub    %rax,%rsi
    5e25:	e8 23 ff ff ff       	callq  5d4d <merge_chunks>
		return ((uint32_t *)cmem)[f];
    5e2a:	8b 03                	mov    (%rbx),%eax
	return c - chunk_field(h, c, LEFT_SIZE);
    5e2c:	49 29 c2             	sub    %rax,%r10
}
    5e2f:	5b                   	pop    %rbx
	free_list_add(h, c);
    5e30:	4c 89 d6             	mov    %r10,%rsi
    5e33:	4c 89 df             	mov    %r11,%rdi
    5e36:	e9 a5 fe ff ff       	jmpq   5ce0 <free_list_add>

0000000000005e3b <sys_heap_free>:
	if (mem == NULL) {
    5e3b:	48 85 f6             	test   %rsi,%rsi
    5e3e:	74 2c                	je     5e6c <sys_heap_free+0x31>
	struct z_heap *h = heap->heap;
    5e40:	4c 8b 0f             	mov    (%rdi),%r9
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    5e43:	48 8d 46 f8          	lea    -0x8(%rsi),%rax
    5e47:	b9 08 00 00 00       	mov    $0x8,%ecx
    5e4c:	4c 29 c8             	sub    %r9,%rax
	set_chunk_used(h, c, false);
    5e4f:	4c 89 cf             	mov    %r9,%rdi
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    5e52:	48 99                	cqto   
    5e54:	48 f7 f9             	idiv   %rcx
	set_chunk_used(h, c, false);
    5e57:	31 d2                	xor    %edx,%edx
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    5e59:	49 89 c0             	mov    %rax,%r8
	set_chunk_used(h, c, false);
    5e5c:	48 89 c6             	mov    %rax,%rsi
    5e5f:	e8 7c fd ff ff       	callq  5be0 <set_chunk_used>
	free_chunk(h, c);
    5e64:	4c 89 c6             	mov    %r8,%rsi
    5e67:	e9 66 ff ff ff       	jmpq   5dd2 <free_chunk>
}
    5e6c:	c3                   	retq   

0000000000005e6d <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
	struct z_heap *h = heap->heap;

	if (bytes == 0U || size_too_big(h, bytes)) {
    5e6d:	48 85 f6             	test   %rsi,%rsi
{
    5e70:	55                   	push   %rbp
    5e71:	53                   	push   %rbx
	struct z_heap *h = heap->heap;
    5e72:	48 8b 2f             	mov    (%rdi),%rbp
	if (bytes == 0U || size_too_big(h, bytes)) {
    5e75:	75 04                	jne    5e7b <sys_heap_alloc+0xe>
		return NULL;
    5e77:	31 c0                	xor    %eax,%eax
    5e79:	eb 62                	jmp    5edd <sys_heap_alloc+0x70>
	/*
	 * Quick check to bail out early if size is too big.
	 * Also guards against potential arithmetic overflows elsewhere.
	 * There is a minimum of one chunk always in use by the heap header.
	 */
	return (bytes / CHUNK_UNIT) >= h->len;
    5e7b:	8b 55 08             	mov    0x8(%rbp),%edx
    5e7e:	48 89 f0             	mov    %rsi,%rax
    5e81:	48 c1 e8 03          	shr    $0x3,%rax
	if (bytes == 0U || size_too_big(h, bytes)) {
    5e85:	48 39 c2             	cmp    %rax,%rdx
    5e88:	76 ed                	jbe    5e77 <sys_heap_alloc+0xa>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    5e8a:	48 8d 5e 0f          	lea    0xf(%rsi),%rbx
	}

	size_t chunk_sz = bytes_to_chunksz(h, bytes);
	chunkid_t c = alloc_chunk(h, chunk_sz);
    5e8e:	48 89 ef             	mov    %rbp,%rdi
    5e91:	48 c1 eb 03          	shr    $0x3,%rbx
    5e95:	48 89 de             	mov    %rbx,%rsi
    5e98:	e8 99 fd ff ff       	callq  5c36 <alloc_chunk>
	if (c == 0U) {
    5e9d:	48 85 c0             	test   %rax,%rax
	chunkid_t c = alloc_chunk(h, chunk_sz);
    5ea0:	49 89 c3             	mov    %rax,%r11
	if (c == 0U) {
    5ea3:	74 d2                	je     5e77 <sys_heap_alloc+0xa>
		return NULL;
	}

	/* Split off remainder if any */
	if (chunk_size(h, c) > chunk_sz) {
    5ea5:	48 89 c6             	mov    %rax,%rsi
    5ea8:	48 89 ef             	mov    %rbp,%rdi
    5eab:	e8 28 fd ff ff       	callq  5bd8 <chunk_size>
    5eb0:	48 39 d8             	cmp    %rbx,%rax
    5eb3:	76 13                	jbe    5ec8 <sys_heap_alloc+0x5b>
		split_chunks(h, c, c + chunk_sz);
    5eb5:	4c 01 db             	add    %r11,%rbx
    5eb8:	48 89 da             	mov    %rbx,%rdx
    5ebb:	e8 b9 fe ff ff       	callq  5d79 <split_chunks>
		free_list_add(h, c + chunk_sz);
    5ec0:	48 89 de             	mov    %rbx,%rsi
    5ec3:	e8 18 fe ff ff       	callq  5ce0 <free_list_add>
	}

	set_chunk_used(h, c, true);
    5ec8:	ba 01 00 00 00       	mov    $0x1,%edx
    5ecd:	4c 89 de             	mov    %r11,%rsi
    5ed0:	48 89 ef             	mov    %rbp,%rdi
    5ed3:	e8 08 fd ff ff       	callq  5be0 <set_chunk_used>
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
    5ed8:	4a 8d 44 dd 08       	lea    0x8(%rbp,%r11,8),%rax
	return chunk_mem(h, c);
}
    5edd:	5b                   	pop    %rbx
    5ede:	5d                   	pop    %rbp
    5edf:	c3                   	retq   

0000000000005ee0 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
    5ee0:	41 55                	push   %r13
    5ee2:	41 54                	push   %r12
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rewind = align & -align;
    5ee4:	49 89 f4             	mov    %rsi,%r12
{
    5ee7:	55                   	push   %rbp
	rewind = align & -align;
    5ee8:	49 f7 dc             	neg    %r12
{
    5eeb:	53                   	push   %rbx
	rewind = align & -align;
    5eec:	49 21 f4             	and    %rsi,%r12
{
    5eef:	48 89 f5             	mov    %rsi,%rbp
    5ef2:	49 89 d5             	mov    %rdx,%r13
    5ef5:	48 83 ec 08          	sub    $0x8,%rsp
	if (align != rewind) {
    5ef9:	4c 39 e6             	cmp    %r12,%rsi
    5efc:	74 12                	je     5f10 <sys_heap_aligned_alloc+0x30>
		align -= rewind;
    5efe:	4c 29 e5             	sub    %r12,%rbp
    5f01:	b8 08 00 00 00       	mov    $0x8,%eax
    5f06:	49 83 fc 08          	cmp    $0x8,%r12
    5f0a:	49 0f 46 c4          	cmovbe %r12,%rax
    5f0e:	eb 1d                	jmp    5f2d <sys_heap_aligned_alloc+0x4d>
		gap = MIN(rewind, chunk_header_bytes(h));
	} else {
		if (align <= chunk_header_bytes(h)) {
    5f10:	48 83 fe 08          	cmp    $0x8,%rsi
    5f14:	77 0f                	ja     5f25 <sys_heap_aligned_alloc+0x45>
		free_list_add(h, c_end);
	}

	set_chunk_used(h, c, true);
	return mem;
}
    5f16:	59                   	pop    %rcx
    5f17:	5b                   	pop    %rbx
    5f18:	5d                   	pop    %rbp
    5f19:	41 5c                	pop    %r12
    5f1b:	41 5d                	pop    %r13
			return sys_heap_alloc(heap, bytes);
    5f1d:	48 89 d6             	mov    %rdx,%rsi
    5f20:	e9 48 ff ff ff       	jmpq   5e6d <sys_heap_alloc>
		rewind = 0;
    5f25:	45 31 e4             	xor    %r12d,%r12d
		gap = chunk_header_bytes(h);
    5f28:	b8 08 00 00 00       	mov    $0x8,%eax
	if (bytes == 0 || size_too_big(h, bytes)) {
    5f2d:	4d 85 ed             	test   %r13,%r13
    5f30:	75 07                	jne    5f39 <sys_heap_aligned_alloc+0x59>
		return NULL;
    5f32:	31 ed                	xor    %ebp,%ebp
    5f34:	e9 b6 00 00 00       	jmpq   5fef <sys_heap_aligned_alloc+0x10f>
	struct z_heap *h = heap->heap;
    5f39:	48 8b 1f             	mov    (%rdi),%rbx
	return (bytes / CHUNK_UNIT) >= h->len;
    5f3c:	4c 89 ea             	mov    %r13,%rdx
    5f3f:	48 c1 ea 03          	shr    $0x3,%rdx
    5f43:	8b 4b 08             	mov    0x8(%rbx),%ecx
	if (bytes == 0 || size_too_big(h, bytes)) {
    5f46:	48 39 d1             	cmp    %rdx,%rcx
    5f49:	76 e7                	jbe    5f32 <sys_heap_aligned_alloc+0x52>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    5f4b:	4a 8d 74 2d 0f       	lea    0xf(%rbp,%r13,1),%rsi
	chunkid_t c0 = alloc_chunk(h, padded_sz);
    5f50:	48 89 df             	mov    %rbx,%rdi
    5f53:	48 29 c6             	sub    %rax,%rsi
    5f56:	48 c1 ee 03          	shr    $0x3,%rsi
    5f5a:	e8 d7 fc ff ff       	callq  5c36 <alloc_chunk>
	if (c0 == 0) {
    5f5f:	48 85 c0             	test   %rax,%rax
	chunkid_t c0 = alloc_chunk(h, padded_sz);
    5f62:	48 89 c1             	mov    %rax,%rcx
	if (c0 == 0) {
    5f65:	74 cb                	je     5f32 <sys_heap_aligned_alloc+0x52>
	mem = (uint8_t *) ROUND_UP(mem + rewind, align) - rewind;
    5f67:	49 8d 44 c4 08       	lea    0x8(%r12,%rax,8),%rax
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    5f6c:	be 08 00 00 00       	mov    $0x8,%esi
	mem = (uint8_t *) ROUND_UP(mem + rewind, align) - rewind;
    5f71:	48 01 d8             	add    %rbx,%rax
    5f74:	48 8d 44 05 ff       	lea    -0x1(%rbp,%rax,1),%rax
    5f79:	48 f7 dd             	neg    %rbp
    5f7c:	48 21 c5             	and    %rax,%rbp
    5f7f:	4c 29 e5             	sub    %r12,%rbp
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    5f82:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
    5f86:	4e 8d 5c 2d 07       	lea    0x7(%rbp,%r13,1),%r11
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    5f8b:	48 29 d8             	sub    %rbx,%rax
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
    5f8e:	49 83 e3 f8          	and    $0xfffffffffffffff8,%r11
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    5f92:	48 99                	cqto   
	chunkid_t c_end = end - chunk_buf(h);
    5f94:	49 29 db             	sub    %rbx,%r11
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    5f97:	48 f7 fe             	idiv   %rsi
	chunkid_t c_end = end - chunk_buf(h);
    5f9a:	49 c1 fb 03          	sar    $0x3,%r11
	if (c > c0) {
    5f9e:	48 39 c1             	cmp    %rax,%rcx
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    5fa1:	49 89 c4             	mov    %rax,%r12
	if (c > c0) {
    5fa4:	73 16                	jae    5fbc <sys_heap_aligned_alloc+0xdc>
		split_chunks(h, c0, c);
    5fa6:	48 89 ce             	mov    %rcx,%rsi
    5fa9:	48 89 c2             	mov    %rax,%rdx
    5fac:	48 89 df             	mov    %rbx,%rdi
    5faf:	e8 c5 fd ff ff       	callq  5d79 <split_chunks>
		free_list_add(h, c0);
    5fb4:	48 89 ce             	mov    %rcx,%rsi
    5fb7:	e8 24 fd ff ff       	callq  5ce0 <free_list_add>
	return c + chunk_size(h, c);
    5fbc:	4c 89 e6             	mov    %r12,%rsi
    5fbf:	48 89 df             	mov    %rbx,%rdi
    5fc2:	e8 11 fc ff ff       	callq  5bd8 <chunk_size>
    5fc7:	4c 01 e0             	add    %r12,%rax
	if (right_chunk(h, c) > c_end) {
    5fca:	49 39 c3             	cmp    %rax,%r11
    5fcd:	73 10                	jae    5fdf <sys_heap_aligned_alloc+0xff>
		split_chunks(h, c, c_end);
    5fcf:	4c 89 da             	mov    %r11,%rdx
    5fd2:	e8 a2 fd ff ff       	callq  5d79 <split_chunks>
		free_list_add(h, c_end);
    5fd7:	4c 89 de             	mov    %r11,%rsi
    5fda:	e8 01 fd ff ff       	callq  5ce0 <free_list_add>
	set_chunk_used(h, c, true);
    5fdf:	ba 01 00 00 00       	mov    $0x1,%edx
    5fe4:	4c 89 e6             	mov    %r12,%rsi
    5fe7:	48 89 df             	mov    %rbx,%rdi
    5fea:	e8 f1 fb ff ff       	callq  5be0 <set_chunk_used>
}
    5fef:	5a                   	pop    %rdx
    5ff0:	48 89 e8             	mov    %rbp,%rax
    5ff3:	5b                   	pop    %rbx
    5ff4:	5d                   	pop    %rbp
    5ff5:	41 5c                	pop    %r12
    5ff7:	41 5d                	pop    %r13
    5ff9:	c3                   	retq   

0000000000005ffa <sys_heap_init>:
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    5ffa:	4c 8d 5c 16 f8       	lea    -0x8(%rsi,%rdx,1),%r11
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    5fff:	4c 8d 46 07          	lea    0x7(%rsi),%r8
	heap->heap = h;
	h->chunk0_hdr_area = 0;
	h->len = buf_sz;
	h->avail_buckets = 0;

	int nb_buckets = bucket_idx(h, buf_sz) + 1;
    6003:	ba 20 00 00 00       	mov    $0x20,%edx
{
    6008:	53                   	push   %rbx
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    6009:	49 83 e3 f8          	and    $0xfffffffffffffff8,%r11
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    600d:	49 83 e0 f8          	and    $0xfffffffffffffff8,%r8
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
    6011:	4d 89 d9             	mov    %r11,%r9
	heap->heap = h;
    6014:	4c 89 07             	mov    %r8,(%rdi)
	h->chunk0_hdr_area = 0;
    6017:	49 c7 00 00 00 00 00 	movq   $0x0,(%r8)
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
    601e:	4d 29 c1             	sub    %r8,%r9
	h->avail_buckets = 0;
    6021:	41 c7 40 0c 00 00 00 	movl   $0x0,0xc(%r8)
    6028:	00 
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
    6029:	49 c1 e9 03          	shr    $0x3,%r9
	size_t usable_sz = sz - min_chunk_size(h) + 1;
    602d:	49 8d 41 ff          	lea    -0x1(%r9),%rax
	h->len = buf_sz;
    6031:	45 89 48 08          	mov    %r9d,0x8(%r8)
	return 31 - __builtin_clz(usable_sz);
    6035:	0f bd c0             	bsr    %eax,%eax
    6038:	83 f0 1f             	xor    $0x1f,%eax
	int nb_buckets = bucket_idx(h, buf_sz) + 1;
    603b:	29 c2                	sub    %eax,%edx
	size_t chunk0_size = chunksz(sizeof(struct z_heap) +
    603d:	48 63 c2             	movslq %edx,%rax
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    6040:	48 8d 1c c5 17 00 00 	lea    0x17(,%rax,8),%rbx
    6047:	00 
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) < buf_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
    6048:	31 c0                	xor    %eax,%eax
    604a:	49 89 da             	mov    %rbx,%r10
    604d:	49 c1 ea 03          	shr    $0x3,%r10
    6051:	39 c2                	cmp    %eax,%edx
    6053:	7e 0e                	jle    6063 <sys_heap_init+0x69>
		h->buckets[i].next = 0;
    6055:	49 c7 44 c0 10 00 00 	movq   $0x0,0x10(%r8,%rax,8)
    605c:	00 00 
    605e:	48 ff c0             	inc    %rax
    6061:	eb ee                	jmp    6051 <sys_heap_init+0x57>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    6063:	4b 8d 04 12          	lea    (%r10,%r10,1),%rax
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
	set_chunk_used(h, 0, true);
    6067:	ba 01 00 00 00       	mov    $0x1,%edx
    606c:	31 f6                	xor    %esi,%esi
    606e:	4c 89 c7             	mov    %r8,%rdi
	void *cmem = &buf[c];
    6071:	48 83 e3 f8          	and    $0xfffffffffffffff8,%rbx
		((uint32_t *)cmem)[f] = val;
    6075:	41 89 40 04          	mov    %eax,0x4(%r8)
    6079:	e8 62 fb ff ff       	callq  5be0 <set_chunk_used>

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, buf_sz - chunk0_size);
    607e:	4c 89 c8             	mov    %r9,%rax
    6081:	45 89 14 18          	mov    %r10d,(%r8,%rbx,1)
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, buf_sz, 0);
	set_left_chunk_size(h, buf_sz, buf_sz - chunk0_size);
	set_chunk_used(h, buf_sz, true);
    6085:	4c 89 ce             	mov    %r9,%rsi
	set_chunk_size(h, chunk0_size, buf_sz - chunk0_size);
    6088:	4c 29 d0             	sub    %r10,%rax
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    608b:	48 8d 14 00          	lea    (%rax,%rax,1),%rdx
		((uint32_t *)cmem)[f] = val;
    608f:	41 89 54 18 04       	mov    %edx,0x4(%r8,%rbx,1)
    6094:	41 c7 43 04 00 00 00 	movl   $0x0,0x4(%r11)
    609b:	00 
	set_chunk_used(h, buf_sz, true);
    609c:	ba 01 00 00 00       	mov    $0x1,%edx
    60a1:	41 89 03             	mov    %eax,(%r11)
    60a4:	e8 37 fb ff ff       	callq  5be0 <set_chunk_used>

	free_list_add(h, chunk0_size);
}
    60a9:	5b                   	pop    %rbx
	free_list_add(h, chunk0_size);
    60aa:	4c 89 d6             	mov    %r10,%rsi
    60ad:	e9 2e fc ff ff       	jmpq   5ce0 <free_list_add>

00000000000060b2 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
    60b2:	41 56                	push   %r14
    60b4:	49 89 fe             	mov    %rdi,%r14
    60b7:	41 55                	push   %r13
    60b9:	49 89 f5             	mov    %rsi,%r13
    60bc:	41 54                	push   %r12
    60be:	49 89 cc             	mov    %rcx,%r12
    60c1:	55                   	push   %rbp
    60c2:	48 89 d5             	mov    %rdx,%rbp
    60c5:	53                   	push   %rbx
	size_t count = 0;

	while ((sp < ep) || ((ep == NULL) && *sp)) {
    60c6:	48 89 d3             	mov    %rdx,%rbx
    60c9:	48 89 d8             	mov    %rbx,%rax
    60cc:	48 29 e8             	sub    %rbp,%rax
    60cf:	4c 39 e3             	cmp    %r12,%rbx
    60d2:	73 15                	jae    60e9 <outs+0x37>
		int rc = out((int)*sp++, ctx);
    60d4:	48 ff c3             	inc    %rbx
    60d7:	0f be 7b ff          	movsbl -0x1(%rbx),%edi
    60db:	31 c0                	xor    %eax,%eax
    60dd:	4c 89 ee             	mov    %r13,%rsi
    60e0:	41 ff d6             	callq  *%r14

		if (rc < 0) {
    60e3:	85 c0                	test   %eax,%eax
    60e5:	79 e2                	jns    60c9 <outs+0x17>
    60e7:	eb 0a                	jmp    60f3 <outs+0x41>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    60e9:	4d 85 e4             	test   %r12,%r12
    60ec:	75 05                	jne    60f3 <outs+0x41>
    60ee:	80 3b 00             	cmpb   $0x0,(%rbx)
    60f1:	75 e1                	jne    60d4 <outs+0x22>
		}
		++count;
	}

	return (int)count;
}
    60f3:	5b                   	pop    %rbx
    60f4:	5d                   	pop    %rbp
    60f5:	41 5c                	pop    %r12
    60f7:	41 5d                	pop    %r13
    60f9:	41 5e                	pop    %r14
    60fb:	c3                   	retq   

00000000000060fc <extract_decimal>:
{
    60fc:	55                   	push   %rbp
    60fd:	53                   	push   %rbx
    60fe:	48 89 fd             	mov    %rdi,%rbp
    6101:	48 83 ec 08          	sub    $0x8,%rsp
	const char *sp = *str;
    6105:	48 8b 1f             	mov    (%rdi),%rbx
	while (isdigit((int)(unsigned char)*sp)) {
    6108:	e8 03 e5 ff ff       	callq  4610 <__ctype_b_loc@plt>
    610d:	48 8b 08             	mov    (%rax),%rcx
	size_t val = 0;
    6110:	31 c0                	xor    %eax,%eax
	while (isdigit((int)(unsigned char)*sp)) {
    6112:	48 0f be 13          	movsbq (%rbx),%rdx
    6116:	0f b6 f2             	movzbl %dl,%esi
    6119:	f6 44 71 01 08       	testb  $0x8,0x1(%rcx,%rsi,2)
    611e:	74 0e                	je     612e <extract_decimal+0x32>
		val = 10U * val + *sp++ - '0';
    6120:	48 6b c0 0a          	imul   $0xa,%rax,%rax
    6124:	48 ff c3             	inc    %rbx
    6127:	48 8d 44 10 d0       	lea    -0x30(%rax,%rdx,1),%rax
    612c:	eb e4                	jmp    6112 <extract_decimal+0x16>
	*str = sp;
    612e:	48 89 5d 00          	mov    %rbx,0x0(%rbp)
}
    6132:	5a                   	pop    %rdx
    6133:	5b                   	pop    %rbx
    6134:	5d                   	pop    %rbp
    6135:	c3                   	retq   

0000000000006136 <encode_uint>:
{
    6136:	41 54                	push   %r12
    6138:	55                   	push   %rbp
    6139:	49 89 d4             	mov    %rdx,%r12
    613c:	53                   	push   %rbx
    613d:	48 89 f3             	mov    %rsi,%rbx
    6140:	48 89 fd             	mov    %rdi,%rbp
    6143:	48 83 ec 10          	sub    $0x10,%rsp
    6147:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
	bool upcase = isupper((int)conv->specifier);
    614c:	e8 bf e4 ff ff       	callq  4610 <__ctype_b_loc@plt>
    6151:	48 0f be 73 03       	movsbq 0x3(%rbx),%rsi
    6156:	48 8b 00             	mov    (%rax),%rax
	switch (specifier) {
    6159:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    615e:	66 44 8b 04 70       	mov    (%rax,%rsi,2),%r8w
	bool upcase = isupper((int)conv->specifier);
    6163:	48 89 f2             	mov    %rsi,%rdx
		return 8;
    6166:	be 08 00 00 00       	mov    $0x8,%esi
    616b:	66 41 81 e0 00 01    	and    $0x100,%r8w
	switch (specifier) {
    6171:	80 fa 6f             	cmp    $0x6f,%dl
    6174:	74 1b                	je     6191 <encode_uint+0x5b>
    6176:	7f 05                	jg     617d <encode_uint+0x47>
    6178:	80 fa 58             	cmp    $0x58,%dl
    617b:	eb 08                	jmp    6185 <encode_uint+0x4f>
    617d:	80 fa 70             	cmp    $0x70,%dl
    6180:	74 0a                	je     618c <encode_uint+0x56>
    6182:	80 fa 78             	cmp    $0x78,%dl
		return 10;
    6185:	be 0a 00 00 00       	mov    $0xa,%esi
	switch (specifier) {
    618a:	75 05                	jne    6191 <encode_uint+0x5b>
		return 16;
    618c:	be 10 00 00 00       	mov    $0x10,%esi
    6191:	48 89 e8             	mov    %rbp,%rax
    6194:	31 d2                	xor    %edx,%edx
    6196:	48 f7 f6             	div    %rsi
		*--bp = (lsv <= 9) ? ('0' + lsv)
    6199:	48 83 fa 09          	cmp    $0x9,%rdx
    619d:	48 89 c5             	mov    %rax,%rbp
    61a0:	44 8d 4a 30          	lea    0x30(%rdx),%r9d
    61a4:	76 0e                	jbe    61b4 <encode_uint+0x7e>
    61a6:	66 45 85 c0          	test   %r8w,%r8w
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    61aa:	44 8d 4a 57          	lea    0x57(%rdx),%r9d
		*--bp = (lsv <= 9) ? ('0' + lsv)
    61ae:	74 04                	je     61b4 <encode_uint+0x7e>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    61b0:	44 8d 4a 37          	lea    0x37(%rdx),%r9d
		*--bp = (lsv <= 9) ? ('0' + lsv)
    61b4:	48 ff c9             	dec    %rcx
	} while ((value != 0) && (bps < bp));
    61b7:	48 85 ed             	test   %rbp,%rbp
		*--bp = (lsv <= 9) ? ('0' + lsv)
    61ba:	44 88 09             	mov    %r9b,(%rcx)
	} while ((value != 0) && (bps < bp));
    61bd:	74 05                	je     61c4 <encode_uint+0x8e>
    61bf:	49 39 cc             	cmp    %rcx,%r12
    61c2:	72 cd                	jb     6191 <encode_uint+0x5b>
	if (conv->flag_hash) {
    61c4:	f6 03 20             	testb  $0x20,(%rbx)
    61c7:	74 16                	je     61df <encode_uint+0xa9>
		if (radix == 8) {
    61c9:	48 83 fe 08          	cmp    $0x8,%rsi
    61cd:	75 06                	jne    61d5 <encode_uint+0x9f>
			conv->altform_0 = true;
    61cf:	80 4b 02 08          	orb    $0x8,0x2(%rbx)
    61d3:	eb 0a                	jmp    61df <encode_uint+0xa9>
		} else if (radix == 16) {
    61d5:	48 83 fe 10          	cmp    $0x10,%rsi
    61d9:	75 04                	jne    61df <encode_uint+0xa9>
			conv->altform_0c = true;
    61db:	80 4b 02 10          	orb    $0x10,0x2(%rbx)
}
    61df:	48 83 c4 10          	add    $0x10,%rsp
    61e3:	48 89 c8             	mov    %rcx,%rax
    61e6:	5b                   	pop    %rbx
    61e7:	5d                   	pop    %rbp
    61e8:	41 5c                	pop    %r12
    61ea:	c3                   	retq   

00000000000061eb <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    61eb:	41 57                	push   %r15
    61ed:	41 56                	push   %r14
    61ef:	49 89 d7             	mov    %rdx,%r15
    61f2:	41 55                	push   %r13
    61f4:	41 54                	push   %r12
    61f6:	49 89 fe             	mov    %rdi,%r14
    61f9:	55                   	push   %rbp
    61fa:	53                   	push   %rbx
    61fb:	49 89 cd             	mov    %rcx,%r13
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    61fe:	31 db                	xor    %ebx,%ebx
{
    6200:	48 83 ec 78          	sub    $0x78,%rsp
    6204:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    620b:	00 00 
    620d:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
    6212:	31 c0                	xor    %eax,%eax
    6214:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
    6219:	41 0f be 3f          	movsbl (%r15),%edi
    621d:	40 84 ff             	test   %dil,%dil
    6220:	0f 84 e0 09 00 00    	je     6c06 <cbvprintf+0xa1b>
		if (*fp != '%') {
    6226:	40 80 ff 25          	cmp    $0x25,%dil
    622a:	49 8d 6f 01          	lea    0x1(%r15),%rbp
    622e:	74 0a                	je     623a <cbvprintf+0x4f>
			OUTC(*fp++);
    6230:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    6235:	e9 91 06 00 00       	jmpq   68cb <cbvprintf+0x6e0>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
    623a:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
    623f:	31 c0                	xor    %eax,%eax
    6241:	b9 08 00 00 00       	mov    $0x8,%ecx
    6246:	4c 8d 64 24 30       	lea    0x30(%rsp),%r12
    624b:	f3 ab                	rep stos %eax,%es:(%rdi)
	if (*sp == '%') {
    624d:	41 80 7f 01 25       	cmpb   $0x25,0x1(%r15)
    6252:	75 1c                	jne    6270 <cbvprintf+0x85>
		conv->specifier = *sp++;
    6254:	49 8d 6f 02          	lea    0x2(%r15),%rbp
    6258:	c6 44 24 43 25       	movb   $0x25,0x43(%rsp)
    625d:	e9 d9 02 00 00       	jmpq   653b <cbvprintf+0x350>
		switch (*sp) {
    6262:	7e 15                	jle    6279 <cbvprintf+0x8e>
    6264:	3c 2d                	cmp    $0x2d,%al
    6266:	75 1b                	jne    6283 <cbvprintf+0x98>
			conv->flag_dash = true;
    6268:	80 4c 24 40 04       	orb    $0x4,0x40(%rsp)
			++sp;
    626d:	48 ff c5             	inc    %rbp
		switch (*sp) {
    6270:	8a 45 00             	mov    0x0(%rbp),%al
    6273:	3c 2b                	cmp    $0x2b,%al
    6275:	75 eb                	jne    6262 <cbvprintf+0x77>
    6277:	eb 25                	jmp    629e <cbvprintf+0xb3>
    6279:	3c 20                	cmp    $0x20,%al
    627b:	74 28                	je     62a5 <cbvprintf+0xba>
    627d:	3c 23                	cmp    $0x23,%al
    627f:	74 2b                	je     62ac <cbvprintf+0xc1>
    6281:	eb 04                	jmp    6287 <cbvprintf+0x9c>
    6283:	3c 30                	cmp    $0x30,%al
    6285:	74 2c                	je     62b3 <cbvprintf+0xc8>
	if (conv->flag_zero && conv->flag_dash) {
    6287:	8a 44 24 40          	mov    0x40(%rsp),%al
    628b:	88 c2                	mov    %al,%dl
    628d:	83 e2 44             	and    $0x44,%edx
    6290:	80 fa 44             	cmp    $0x44,%dl
    6293:	75 25                	jne    62ba <cbvprintf+0xcf>
		conv->flag_zero = false;
    6295:	83 e0 bf             	and    $0xffffffbf,%eax
    6298:	88 44 24 40          	mov    %al,0x40(%rsp)
    629c:	eb 1c                	jmp    62ba <cbvprintf+0xcf>
			conv->flag_plus = true;
    629e:	80 4c 24 40 08       	orb    $0x8,0x40(%rsp)
    62a3:	eb c8                	jmp    626d <cbvprintf+0x82>
			conv->flag_space = true;
    62a5:	80 4c 24 40 10       	orb    $0x10,0x40(%rsp)
    62aa:	eb c1                	jmp    626d <cbvprintf+0x82>
			conv->flag_hash = true;
    62ac:	80 4c 24 40 20       	orb    $0x20,0x40(%rsp)
    62b1:	eb ba                	jmp    626d <cbvprintf+0x82>
			conv->flag_zero = true;
    62b3:	80 4c 24 40 40       	orb    $0x40,0x40(%rsp)
    62b8:	eb b3                	jmp    626d <cbvprintf+0x82>
	conv->width_present = true;
    62ba:	80 4c 24 40 80       	orb    $0x80,0x40(%rsp)
    62bf:	48 89 6c 24 28       	mov    %rbp,0x28(%rsp)
	if (*sp == '*') {
    62c4:	80 7d 00 2a          	cmpb   $0x2a,0x0(%rbp)
    62c8:	75 0a                	jne    62d4 <cbvprintf+0xe9>
		conv->width_star = true;
    62ca:	80 4c 24 41 01       	orb    $0x1,0x41(%rsp)
		return ++sp;
    62cf:	48 ff c5             	inc    %rbp
    62d2:	eb 53                	jmp    6327 <cbvprintf+0x13c>
	size_t width = extract_decimal(&sp);
    62d4:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
    62d9:	e8 1e fe ff ff       	callq  60fc <extract_decimal>
	if (sp != wp) {
    62de:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
    62e3:	48 39 e9             	cmp    %rbp,%rcx
    62e6:	74 3f                	je     6327 <cbvprintf+0x13c>
		conv->width_present = true;
    62e8:	8a 54 24 40          	mov    0x40(%rsp),%dl
		conv->width_value = width;
    62ec:	89 44 24 44          	mov    %eax,0x44(%rsp)
				      || (width != (size_t)conv->width_value));
    62f0:	be 01 00 00 00       	mov    $0x1,%esi
		conv->width_present = true;
    62f5:	83 ca 80             	or     $0xffffff80,%edx
    62f8:	88 54 24 40          	mov    %dl,0x40(%rsp)
		conv->unsupported |= ((conv->width_value < 0)
    62fc:	d0 ea                	shr    %dl
    62fe:	83 e2 01             	and    $0x1,%edx
				      || (width != (size_t)conv->width_value));
    6301:	85 c0                	test   %eax,%eax
    6303:	78 0e                	js     6313 <cbvprintf+0x128>
    6305:	48 63 f0             	movslq %eax,%rsi
    6308:	48 39 c6             	cmp    %rax,%rsi
    630b:	40 0f 95 c6          	setne  %sil
    630f:	40 0f b6 f6          	movzbl %sil,%esi
		conv->unsupported |= ((conv->width_value < 0)
    6313:	8a 44 24 40          	mov    0x40(%rsp),%al
    6317:	09 f2                	or     %esi,%edx
    6319:	48 89 cd             	mov    %rcx,%rbp
    631c:	01 d2                	add    %edx,%edx
    631e:	83 e0 fd             	and    $0xfffffffd,%eax
    6321:	09 c2                	or     %eax,%edx
    6323:	88 54 24 40          	mov    %dl,0x40(%rsp)
    6327:	48 89 6c 24 20       	mov    %rbp,0x20(%rsp)
	conv->prec_present = (*sp == '.');
    632c:	8a 4d 00             	mov    0x0(%rbp),%cl
    632f:	80 f9 2e             	cmp    $0x2e,%cl
    6332:	0f 94 c0             	sete   %al
    6335:	8d 14 00             	lea    (%rax,%rax,1),%edx
    6338:	8a 44 24 41          	mov    0x41(%rsp),%al
    633c:	83 e0 fd             	and    $0xfffffffd,%eax
    633f:	09 d0                	or     %edx,%eax
	if (!conv->prec_present) {
    6341:	80 f9 2e             	cmp    $0x2e,%cl
	conv->prec_present = (*sp == '.');
    6344:	88 44 24 41          	mov    %al,0x41(%rsp)
	if (!conv->prec_present) {
    6348:	75 60                	jne    63aa <cbvprintf+0x1bf>
	++sp;
    634a:	48 8d 55 01          	lea    0x1(%rbp),%rdx
    634e:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
	if (*sp == '*') {
    6353:	80 7d 01 2a          	cmpb   $0x2a,0x1(%rbp)
    6357:	75 0d                	jne    6366 <cbvprintf+0x17b>
		conv->prec_star = true;
    6359:	83 c8 04             	or     $0x4,%eax
		return ++sp;
    635c:	48 83 c5 02          	add    $0x2,%rbp
		conv->prec_star = true;
    6360:	88 44 24 41          	mov    %al,0x41(%rsp)
    6364:	eb 44                	jmp    63aa <cbvprintf+0x1bf>
	size_t prec = extract_decimal(&sp);
    6366:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
    636b:	e8 8c fd ff ff       	callq  60fc <extract_decimal>
	conv->unsupported |= ((conv->prec_value < 0)
    6370:	8a 54 24 40          	mov    0x40(%rsp),%dl
	conv->prec_value = prec;
    6374:	89 44 24 48          	mov    %eax,0x48(%rsp)
			      || (prec != (size_t)conv->prec_value));
    6378:	b9 01 00 00 00       	mov    $0x1,%ecx
	conv->unsupported |= ((conv->prec_value < 0)
    637d:	d0 ea                	shr    %dl
    637f:	83 e2 01             	and    $0x1,%edx
			      || (prec != (size_t)conv->prec_value));
    6382:	85 c0                	test   %eax,%eax
    6384:	78 0c                	js     6392 <cbvprintf+0x1a7>
    6386:	48 63 c8             	movslq %eax,%rcx
    6389:	48 39 c1             	cmp    %rax,%rcx
    638c:	0f 95 c1             	setne  %cl
    638f:	0f b6 c9             	movzbl %cl,%ecx
	conv->unsupported |= ((conv->prec_value < 0)
    6392:	88 d0                	mov    %dl,%al
    6394:	8a 54 24 40          	mov    0x40(%rsp),%dl
	return sp;
    6398:	48 8b 6c 24 20       	mov    0x20(%rsp),%rbp
	conv->unsupported |= ((conv->prec_value < 0)
    639d:	09 c8                	or     %ecx,%eax
    639f:	01 c0                	add    %eax,%eax
    63a1:	83 e2 fd             	and    $0xfffffffd,%edx
    63a4:	09 d0                	or     %edx,%eax
    63a6:	88 44 24 40          	mov    %al,0x40(%rsp)
	switch (*sp) {
    63aa:	8a 4d 00             	mov    0x0(%rbp),%cl
    63ad:	48 8d 55 01          	lea    0x1(%rbp),%rdx
    63b1:	8a 44 24 41          	mov    0x41(%rsp),%al
    63b5:	80 f9 6a             	cmp    $0x6a,%cl
    63b8:	74 51                	je     640b <cbvprintf+0x220>
    63ba:	7f 0c                	jg     63c8 <cbvprintf+0x1dd>
    63bc:	80 f9 4c             	cmp    $0x4c,%cl
    63bf:	74 62                	je     6423 <cbvprintf+0x238>
    63c1:	80 f9 68             	cmp    $0x68,%cl
    63c4:	74 13                	je     63d9 <cbvprintf+0x1ee>
    63c6:	eb 6c                	jmp    6434 <cbvprintf+0x249>
    63c8:	80 f9 74             	cmp    $0x74,%cl
    63cb:	74 4e                	je     641b <cbvprintf+0x230>
    63cd:	80 f9 7a             	cmp    $0x7a,%cl
    63d0:	74 41                	je     6413 <cbvprintf+0x228>
    63d2:	80 f9 6c             	cmp    $0x6c,%cl
    63d5:	75 5d                	jne    6434 <cbvprintf+0x249>
    63d7:	eb 13                	jmp    63ec <cbvprintf+0x201>
			conv->length_mod = LENGTH_HH;
    63d9:	83 e0 87             	and    $0xffffff87,%eax
		if (*++sp == 'h') {
    63dc:	80 7d 01 68          	cmpb   $0x68,0x1(%rbp)
    63e0:	75 05                	jne    63e7 <cbvprintf+0x1fc>
			conv->length_mod = LENGTH_HH;
    63e2:	83 c8 08             	or     $0x8,%eax
    63e5:	eb 11                	jmp    63f8 <cbvprintf+0x20d>
			conv->length_mod = LENGTH_H;
    63e7:	83 c8 10             	or     $0x10,%eax
    63ea:	eb 19                	jmp    6405 <cbvprintf+0x21a>
			conv->length_mod = LENGTH_LL;
    63ec:	83 e0 87             	and    $0xffffff87,%eax
		if (*++sp == 'l') {
    63ef:	80 7d 01 6c          	cmpb   $0x6c,0x1(%rbp)
    63f3:	75 0d                	jne    6402 <cbvprintf+0x217>
			conv->length_mod = LENGTH_LL;
    63f5:	83 c8 20             	or     $0x20,%eax
    63f8:	88 44 24 41          	mov    %al,0x41(%rsp)
			++sp;
    63fc:	48 8d 55 02          	lea    0x2(%rbp),%rdx
    6400:	eb 3c                	jmp    643e <cbvprintf+0x253>
			conv->length_mod = LENGTH_L;
    6402:	83 c8 18             	or     $0x18,%eax
    6405:	88 44 24 41          	mov    %al,0x41(%rsp)
    6409:	eb 33                	jmp    643e <cbvprintf+0x253>
		conv->length_mod = LENGTH_J;
    640b:	83 e0 87             	and    $0xffffff87,%eax
    640e:	83 c8 28             	or     $0x28,%eax
    6411:	eb f2                	jmp    6405 <cbvprintf+0x21a>
		conv->length_mod = LENGTH_Z;
    6413:	83 e0 87             	and    $0xffffff87,%eax
    6416:	83 c8 30             	or     $0x30,%eax
    6419:	eb ea                	jmp    6405 <cbvprintf+0x21a>
		conv->length_mod = LENGTH_T;
    641b:	83 e0 87             	and    $0xffffff87,%eax
    641e:	83 c8 38             	or     $0x38,%eax
    6421:	eb e2                	jmp    6405 <cbvprintf+0x21a>
		conv->length_mod = LENGTH_UPPER_L;
    6423:	83 e0 87             	and    $0xffffff87,%eax
		conv->unsupported = true;
    6426:	80 4c 24 40 02       	orb    $0x2,0x40(%rsp)
		conv->length_mod = LENGTH_UPPER_L;
    642b:	83 c8 40             	or     $0x40,%eax
    642e:	88 44 24 41          	mov    %al,0x41(%rsp)
    6432:	eb 0a                	jmp    643e <cbvprintf+0x253>
		conv->length_mod = LENGTH_NONE;
    6434:	83 e0 87             	and    $0xffffff87,%eax
    6437:	48 89 ea             	mov    %rbp,%rdx
    643a:	88 44 24 41          	mov    %al,0x41(%rsp)
	conv->specifier = *sp++;
    643e:	8a 02                	mov    (%rdx),%al
    6440:	48 8d 6a 01          	lea    0x1(%rdx),%rbp
    6444:	8a 54 24 41          	mov    0x41(%rsp),%dl
	switch (conv->specifier) {
    6448:	3c 67                	cmp    $0x67,%al
	conv->specifier = *sp++;
    644a:	88 44 24 43          	mov    %al,0x43(%rsp)
	switch (conv->specifier) {
    644e:	7f 37                	jg     6487 <cbvprintf+0x29c>
    6450:	3c 65                	cmp    $0x65,%al
    6452:	0f 8d 83 00 00 00    	jge    64db <cbvprintf+0x2f0>
    6458:	3c 58                	cmp    $0x58,%al
    645a:	74 5a                	je     64b6 <cbvprintf+0x2cb>
    645c:	7f 16                	jg     6474 <cbvprintf+0x289>
    645e:	3c 41                	cmp    $0x41,%al
    6460:	74 79                	je     64db <cbvprintf+0x2f0>
    6462:	0f 8c b4 00 00 00    	jl     651c <cbvprintf+0x331>
    6468:	83 e8 45             	sub    $0x45,%eax
    646b:	3c 02                	cmp    $0x2,%al
    646d:	76 6c                	jbe    64db <cbvprintf+0x2f0>
    646f:	e9 a8 00 00 00       	jmpq   651c <cbvprintf+0x331>
    6474:	3c 61                	cmp    $0x61,%al
    6476:	74 63                	je     64db <cbvprintf+0x2f0>
    6478:	0f 8c 9e 00 00 00    	jl     651c <cbvprintf+0x331>
    647e:	3c 63                	cmp    $0x63,%al
    6480:	7d 28                	jge    64aa <cbvprintf+0x2bf>
    6482:	e9 95 00 00 00       	jmpq   651c <cbvprintf+0x331>
    6487:	3c 70                	cmp    $0x70,%al
    6489:	74 7b                	je     6506 <cbvprintf+0x31b>
    648b:	7f 0f                	jg     649c <cbvprintf+0x2b1>
    648d:	3c 6e                	cmp    $0x6e,%al
    648f:	74 5c                	je     64ed <cbvprintf+0x302>
    6491:	7f 23                	jg     64b6 <cbvprintf+0x2cb>
    6493:	3c 69                	cmp    $0x69,%al
    6495:	74 13                	je     64aa <cbvprintf+0x2bf>
    6497:	e9 80 00 00 00       	jmpq   651c <cbvprintf+0x331>
    649c:	3c 75                	cmp    $0x75,%al
    649e:	74 16                	je     64b6 <cbvprintf+0x2cb>
    64a0:	3c 78                	cmp    $0x78,%al
    64a2:	74 12                	je     64b6 <cbvprintf+0x2cb>
    64a4:	3c 73                	cmp    $0x73,%al
    64a6:	74 5e                	je     6506 <cbvprintf+0x31b>
    64a8:	eb 72                	jmp    651c <cbvprintf+0x331>
		conv->specifier_cat = SPECIFIER_SINT;
    64aa:	8a 4c 24 42          	mov    0x42(%rsp),%cl
    64ae:	83 e1 f8             	and    $0xfffffff8,%ecx
    64b1:	83 c9 01             	or     $0x1,%ecx
    64b4:	eb 0a                	jmp    64c0 <cbvprintf+0x2d5>
		conv->specifier_cat = SPECIFIER_UINT;
    64b6:	8a 4c 24 42          	mov    0x42(%rsp),%cl
    64ba:	83 e1 f8             	and    $0xfffffff8,%ecx
    64bd:	83 c9 02             	or     $0x2,%ecx
		if (conv->length_mod == LENGTH_UPPER_L) {
    64c0:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_UINT;
    64c3:	88 4c 24 42          	mov    %cl,0x42(%rsp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    64c7:	80 fa 40             	cmp    $0x40,%dl
    64ca:	75 05                	jne    64d1 <cbvprintf+0x2e6>
			conv->invalid = true;
    64cc:	80 4c 24 40 01       	orb    $0x1,0x40(%rsp)
	bool unsupported = false;
    64d1:	31 c9                	xor    %ecx,%ecx
		if (conv->specifier == 'c') {
    64d3:	3c 63                	cmp    $0x63,%al
    64d5:	75 4c                	jne    6523 <cbvprintf+0x338>
			unsupported = (conv->length_mod != LENGTH_NONE);
    64d7:	84 d2                	test   %dl,%dl
    64d9:	eb 3c                	jmp    6517 <cbvprintf+0x32c>
		conv->specifier_cat = SPECIFIER_FP;
    64db:	8a 44 24 42          	mov    0x42(%rsp),%al
			unsupported = true;
    64df:	b1 01                	mov    $0x1,%cl
		conv->specifier_cat = SPECIFIER_FP;
    64e1:	83 e0 f8             	and    $0xfffffff8,%eax
    64e4:	83 c8 04             	or     $0x4,%eax
    64e7:	88 44 24 42          	mov    %al,0x42(%rsp)
    64eb:	eb 36                	jmp    6523 <cbvprintf+0x338>
		conv->specifier_cat = SPECIFIER_PTR;
    64ed:	8a 44 24 42          	mov    0x42(%rsp),%al
		if (conv->length_mod == LENGTH_UPPER_L) {
    64f1:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_PTR;
    64f4:	83 e0 f8             	and    $0xfffffff8,%eax
    64f7:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod == LENGTH_UPPER_L) {
    64fa:	80 fa 40             	cmp    $0x40,%dl
		conv->specifier_cat = SPECIFIER_PTR;
    64fd:	88 44 24 42          	mov    %al,0x42(%rsp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    6501:	0f 94 c1             	sete   %cl
    6504:	eb 1d                	jmp    6523 <cbvprintf+0x338>
		conv->specifier_cat = SPECIFIER_PTR;
    6506:	8a 44 24 42          	mov    0x42(%rsp),%al
    650a:	83 e0 f8             	and    $0xfffffff8,%eax
    650d:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod != LENGTH_NONE) {
    6510:	80 e2 78             	and    $0x78,%dl
		conv->specifier_cat = SPECIFIER_PTR;
    6513:	88 44 24 42          	mov    %al,0x42(%rsp)
		if (conv->length_mod != LENGTH_NONE) {
    6517:	0f 95 c1             	setne  %cl
    651a:	eb 07                	jmp    6523 <cbvprintf+0x338>
		conv->invalid = true;
    651c:	80 4c 24 40 01       	orb    $0x1,0x40(%rsp)
	bool unsupported = false;
    6521:	31 c9                	xor    %ecx,%ecx
	conv->unsupported |= unsupported;
    6523:	8a 54 24 40          	mov    0x40(%rsp),%dl
    6527:	88 d0                	mov    %dl,%al
    6529:	83 e2 fd             	and    $0xfffffffd,%edx
    652c:	d0 e8                	shr    %al
    652e:	83 e0 01             	and    $0x1,%eax
    6531:	09 c8                	or     %ecx,%eax
    6533:	01 c0                	add    %eax,%eax
    6535:	09 d0                	or     %edx,%eax
    6537:	88 44 24 40          	mov    %al,0x40(%rsp)
		fp = extract_conversion(conv, sp);

		/* If dynamic width is specified, process it,
		 * otherwise set with if present.
		 */
		if (conv->width_star) {
    653b:	8a 4c 24 41          	mov    0x41(%rsp),%cl
    653f:	f6 c1 01             	test   $0x1,%cl
    6542:	74 39                	je     657d <cbvprintf+0x392>
			width = va_arg(ap, int);
    6544:	41 8b 55 00          	mov    0x0(%r13),%edx
    6548:	83 fa 2f             	cmp    $0x2f,%edx
    654b:	77 0f                	ja     655c <cbvprintf+0x371>
    654d:	89 d0                	mov    %edx,%eax
    654f:	83 c2 08             	add    $0x8,%edx
    6552:	49 03 45 10          	add    0x10(%r13),%rax
    6556:	41 89 55 00          	mov    %edx,0x0(%r13)
    655a:	eb 0c                	jmp    6568 <cbvprintf+0x37d>
    655c:	49 8b 45 08          	mov    0x8(%r13),%rax
    6560:	48 8d 50 08          	lea    0x8(%rax),%rdx
    6564:	49 89 55 08          	mov    %rdx,0x8(%r13)
    6568:	8b 00                	mov    (%rax),%eax

			if (width < 0) {
    656a:	85 c0                	test   %eax,%eax
			width = va_arg(ap, int);
    656c:	89 44 24 18          	mov    %eax,0x18(%rsp)
			if (width < 0) {
    6570:	79 22                	jns    6594 <cbvprintf+0x3a9>
				conv->flag_dash = true;
    6572:	80 4c 24 40 04       	orb    $0x4,0x40(%rsp)
				width = -width;
    6577:	f7 5c 24 18          	negl   0x18(%rsp)
    657b:	eb 17                	jmp    6594 <cbvprintf+0x3a9>
			}
		} else if (conv->width_present) {
    657d:	80 7c 24 40 00       	cmpb   $0x0,0x40(%rsp)
		int width = -1;
    6582:	c7 44 24 18 ff ff ff 	movl   $0xffffffff,0x18(%rsp)
    6589:	ff 
		} else if (conv->width_present) {
    658a:	79 08                	jns    6594 <cbvprintf+0x3a9>
			width = conv->width_value;
    658c:	8b 44 24 44          	mov    0x44(%rsp),%eax
    6590:	89 44 24 18          	mov    %eax,0x18(%rsp)

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
    6594:	f6 c1 04             	test   $0x4,%cl
    6597:	74 37                	je     65d0 <cbvprintf+0x3e5>
			int arg = va_arg(ap, int);
    6599:	41 8b 55 00          	mov    0x0(%r13),%edx
    659d:	83 fa 2f             	cmp    $0x2f,%edx
    65a0:	77 0f                	ja     65b1 <cbvprintf+0x3c6>
    65a2:	89 d0                	mov    %edx,%eax
    65a4:	83 c2 08             	add    $0x8,%edx
    65a7:	49 03 45 10          	add    0x10(%r13),%rax
    65ab:	41 89 55 00          	mov    %edx,0x0(%r13)
    65af:	eb 0c                	jmp    65bd <cbvprintf+0x3d2>
    65b1:	49 8b 45 08          	mov    0x8(%r13),%rax
    65b5:	48 8d 50 08          	lea    0x8(%rax),%rdx
    65b9:	49 89 55 08          	mov    %rdx,0x8(%r13)
    65bd:	44 8b 08             	mov    (%rax),%r9d

			if (arg < 0) {
    65c0:	45 85 c9             	test   %r9d,%r9d
    65c3:	79 19                	jns    65de <cbvprintf+0x3f3>
				conv->prec_present = false;
    65c5:	80 64 24 41 fd       	andb   $0xfd,0x41(%rsp)
		int precision = -1;
    65ca:	41 83 c9 ff          	or     $0xffffffff,%r9d
    65ce:	eb 0e                	jmp    65de <cbvprintf+0x3f3>
    65d0:	41 83 c9 ff          	or     $0xffffffff,%r9d
			} else {
				precision = arg;
			}
		} else if (conv->prec_present) {
    65d4:	80 e1 02             	and    $0x2,%cl
    65d7:	74 05                	je     65de <cbvprintf+0x3f3>
			precision = conv->prec_value;
    65d9:	44 8b 4c 24 48       	mov    0x48(%rsp),%r9d
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
    65de:	40 8a 74 24 41       	mov    0x41(%rsp),%sil
			= (enum specifier_cat_enum)conv->specifier_cat;
    65e3:	8a 44 24 42          	mov    0x42(%rsp),%al
		conv->pad0_value = 0;
    65e7:	48 c7 44 24 44 00 00 	movq   $0x0,0x44(%rsp)
    65ee:	00 00 
			= (enum length_mod_enum)conv->length_mod;
    65f0:	40 88 f2             	mov    %sil,%dl
		enum specifier_cat_enum specifier_cat
    65f3:	83 e0 07             	and    $0x7,%eax
			= (enum length_mod_enum)conv->length_mod;
    65f6:	c0 ea 03             	shr    $0x3,%dl
    65f9:	83 e2 0f             	and    $0xf,%edx
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
    65fc:	83 f8 01             	cmp    $0x1,%eax
		enum length_mod_enum length_mod
    65ff:	0f b6 ca             	movzbl %dl,%ecx
		if (specifier_cat == SPECIFIER_SINT) {
    6602:	0f 85 ca 00 00 00    	jne    66d2 <cbvprintf+0x4e7>
			switch (length_mod) {
    6608:	83 c2 0d             	add    $0xd,%edx
    660b:	41 8b 45 00          	mov    0x0(%r13),%eax
    660f:	83 e2 0f             	and    $0xf,%edx
    6612:	80 fa 04             	cmp    $0x4,%dl
    6615:	77 13                	ja     662a <cbvprintf+0x43f>
    6617:	48 8d 3d 82 a6 02 00 	lea    0x2a682(%rip),%rdi        # 30ca0 <__func__.5785+0x38>
    661e:	0f b6 d2             	movzbl %dl,%edx
    6621:	48 63 14 97          	movslq (%rdi,%rdx,4),%rdx
    6625:	48 01 fa             	add    %rdi,%rdx
    6628:	ff e2                	jmpq   *%rdx
			default:
			case LENGTH_NONE:
			case LENGTH_HH:
			case LENGTH_H:
				value->sint = va_arg(ap, int);
    662a:	83 f8 2f             	cmp    $0x2f,%eax
    662d:	77 0f                	ja     663e <cbvprintf+0x453>
    662f:	89 c2                	mov    %eax,%edx
    6631:	83 c0 08             	add    $0x8,%eax
    6634:	49 03 55 10          	add    0x10(%r13),%rdx
    6638:	41 89 45 00          	mov    %eax,0x0(%r13)
    663c:	eb 0c                	jmp    664a <cbvprintf+0x45f>
    663e:	49 8b 55 08          	mov    0x8(%r13),%rdx
    6642:	48 8d 42 08          	lea    0x8(%rdx),%rax
    6646:	49 89 45 08          	mov    %rax,0x8(%r13)
    664a:	48 63 02             	movslq (%rdx),%rax
    664d:	eb 5a                	jmp    66a9 <cbvprintf+0x4be>
				break;
			case LENGTH_L:
				if (WCHAR_IS_SIGNED
    664f:	80 7c 24 43 63       	cmpb   $0x63,0x43(%rsp)
    6654:	75 28                	jne    667e <cbvprintf+0x493>
				    && (conv->specifier == 'c')) {
					value->sint = (wchar_t)va_arg(ap,
    6656:	83 f8 2f             	cmp    $0x2f,%eax
    6659:	77 0f                	ja     666a <cbvprintf+0x47f>
    665b:	89 c2                	mov    %eax,%edx
    665d:	83 c0 08             	add    $0x8,%eax
    6660:	49 03 55 10          	add    0x10(%r13),%rdx
    6664:	41 89 45 00          	mov    %eax,0x0(%r13)
    6668:	eb 0c                	jmp    6676 <cbvprintf+0x48b>
    666a:	49 8b 55 08          	mov    0x8(%r13),%rdx
    666e:	48 8d 42 08          	lea    0x8(%rdx),%rax
    6672:	49 89 45 08          	mov    %rax,0x8(%r13)
    6676:	48 63 02             	movslq (%rdx),%rax
    6679:	e9 9f 01 00 00       	jmpq   681d <cbvprintf+0x632>
				value->sint =
					(sint_value_type)va_arg(ap, long long);
				break;
			case LENGTH_J:
				value->sint =
					(sint_value_type)va_arg(ap, intmax_t);
    667e:	83 f8 2f             	cmp    $0x2f,%eax
    6681:	e9 9e 00 00 00       	jmpq   6724 <cbvprintf+0x539>
				 * unsigned and signed equivalents of each
				 * other.  This can be checked in a platform
				 * test.
				 */
				value->sint =
					(sint_value_type)va_arg(ap, ptrdiff_t);
    6686:	83 f8 2f             	cmp    $0x2f,%eax
    6689:	77 0f                	ja     669a <cbvprintf+0x4af>
    668b:	89 c2                	mov    %eax,%edx
    668d:	83 c0 08             	add    $0x8,%eax
    6690:	49 03 55 10          	add    0x10(%r13),%rdx
    6694:	41 89 45 00          	mov    %eax,0x0(%r13)
    6698:	eb 0c                	jmp    66a6 <cbvprintf+0x4bb>
    669a:	49 8b 55 08          	mov    0x8(%r13),%rdx
    669e:	48 8d 42 08          	lea    0x8(%rdx),%rax
    66a2:	49 89 45 08          	mov    %rax,0x8(%r13)
    66a6:	48 8b 02             	mov    (%rdx),%rax
				break;
			}
			if (length_mod == LENGTH_HH) {
    66a9:	83 f9 01             	cmp    $0x1,%ecx
				value->sint =
    66ac:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
			if (length_mod == LENGTH_HH) {
    66b1:	75 0b                	jne    66be <cbvprintf+0x4d3>
				value->sint = (char)value->sint;
    66b3:	48 0f be 44 24 30    	movsbq 0x30(%rsp),%rax
    66b9:	e9 5f 01 00 00       	jmpq   681d <cbvprintf+0x632>
			} else if (length_mod == LENGTH_H) {
    66be:	83 f9 02             	cmp    $0x2,%ecx
    66c1:	0f 85 5b 01 00 00    	jne    6822 <cbvprintf+0x637>
				value->sint = (short)value->sint;
    66c7:	48 0f bf 44 24 30    	movswq 0x30(%rsp),%rax
    66cd:	e9 4b 01 00 00       	jmpq   681d <cbvprintf+0x632>
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
    66d2:	83 f8 02             	cmp    $0x2,%eax
    66d5:	0f 85 bd 00 00 00    	jne    6798 <cbvprintf+0x5ad>
			switch (length_mod) {
    66db:	83 c2 0d             	add    $0xd,%edx
    66de:	41 8b 45 00          	mov    0x0(%r13),%eax
    66e2:	83 e2 0f             	and    $0xf,%edx
    66e5:	80 fa 04             	cmp    $0x4,%dl
    66e8:	77 16                	ja     6700 <cbvprintf+0x515>
    66ea:	48 8d 3d c3 a5 02 00 	lea    0x2a5c3(%rip),%rdi        # 30cb4 <__func__.5785+0x4c>
    66f1:	0f b6 d2             	movzbl %dl,%edx
    66f4:	48 63 14 97          	movslq (%rdi,%rdx,4),%rdx
    66f8:	48 01 fa             	add    %rdi,%rdx
								uintmax_t);
				break;
			case LENGTH_Z:		/* size_t */
			case LENGTH_T:		/* ptrdiff_t */
				value->uint =
					(uint_value_type)va_arg(ap, size_t);
    66fb:	83 f8 2f             	cmp    $0x2f,%eax
			switch (length_mod) {
    66fe:	ff e2                	jmpq   *%rdx
				value->uint = va_arg(ap, unsigned int);
    6700:	83 f8 2f             	cmp    $0x2f,%eax
    6703:	77 0f                	ja     6714 <cbvprintf+0x529>
    6705:	89 c2                	mov    %eax,%edx
    6707:	83 c0 08             	add    $0x8,%eax
    670a:	49 03 55 10          	add    0x10(%r13),%rdx
    670e:	41 89 45 00          	mov    %eax,0x0(%r13)
    6712:	eb 0c                	jmp    6720 <cbvprintf+0x535>
    6714:	49 8b 55 08          	mov    0x8(%r13),%rdx
    6718:	48 8d 42 08          	lea    0x8(%rdx),%rax
    671c:	49 89 45 08          	mov    %rax,0x8(%r13)
    6720:	8b 02                	mov    (%rdx),%eax
    6722:	eb 45                	jmp    6769 <cbvprintf+0x57e>
					(uint_value_type)va_arg(ap,
    6724:	77 0f                	ja     6735 <cbvprintf+0x54a>
    6726:	89 c2                	mov    %eax,%edx
    6728:	83 c0 08             	add    $0x8,%eax
    672b:	49 03 55 10          	add    0x10(%r13),%rdx
    672f:	41 89 45 00          	mov    %eax,0x0(%r13)
    6733:	eb 0c                	jmp    6741 <cbvprintf+0x556>
    6735:	49 8b 55 08          	mov    0x8(%r13),%rdx
    6739:	48 8d 42 08          	lea    0x8(%rdx),%rax
    673d:	49 89 45 08          	mov    %rax,0x8(%r13)
    6741:	48 8b 02             	mov    (%rdx),%rax
    6744:	e9 d4 00 00 00       	jmpq   681d <cbvprintf+0x632>
					(uint_value_type)va_arg(ap, size_t);
    6749:	77 0f                	ja     675a <cbvprintf+0x56f>
    674b:	89 c2                	mov    %eax,%edx
    674d:	83 c0 08             	add    $0x8,%eax
    6750:	49 03 55 10          	add    0x10(%r13),%rdx
    6754:	41 89 45 00          	mov    %eax,0x0(%r13)
    6758:	eb 0c                	jmp    6766 <cbvprintf+0x57b>
    675a:	49 8b 55 08          	mov    0x8(%r13),%rdx
    675e:	48 8d 42 08          	lea    0x8(%rdx),%rax
    6762:	49 89 45 08          	mov    %rax,0x8(%r13)
    6766:	48 8b 02             	mov    (%rdx),%rax
				break;
			}
			if (length_mod == LENGTH_HH) {
    6769:	83 f9 01             	cmp    $0x1,%ecx
				value->uint =
    676c:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
			if (length_mod == LENGTH_HH) {
    6771:	75 0e                	jne    6781 <cbvprintf+0x596>
				value->uint = (unsigned char)value->uint;
    6773:	48 81 64 24 30 ff 00 	andq   $0xff,0x30(%rsp)
    677a:	00 00 
    677c:	e9 a1 00 00 00       	jmpq   6822 <cbvprintf+0x637>
			} else if (length_mod == LENGTH_H) {
    6781:	83 f9 02             	cmp    $0x2,%ecx
    6784:	0f 85 98 00 00 00    	jne    6822 <cbvprintf+0x637>
				value->uint = (unsigned short)value->uint;
    678a:	48 81 64 24 30 ff ff 	andq   $0xffff,0x30(%rsp)
    6791:	00 00 
    6793:	e9 8a 00 00 00       	jmpq   6822 <cbvprintf+0x637>
			}
		} else if (specifier_cat == SPECIFIER_FP) {
    6798:	83 f8 04             	cmp    $0x4,%eax
    679b:	75 54                	jne    67f1 <cbvprintf+0x606>
			if (length_mod == LENGTH_UPPER_L) {
    679d:	83 f9 08             	cmp    $0x8,%ecx
    67a0:	75 1c                	jne    67be <cbvprintf+0x5d3>
				value->ldbl = va_arg(ap, long double);
    67a2:	49 8b 45 08          	mov    0x8(%r13),%rax
    67a6:	48 83 c0 0f          	add    $0xf,%rax
    67aa:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
    67ae:	48 8d 50 10          	lea    0x10(%rax),%rdx
    67b2:	49 89 55 08          	mov    %rdx,0x8(%r13)
    67b6:	db 28                	fldt   (%rax)
    67b8:	db 7c 24 30          	fstpt  0x30(%rsp)
    67bc:	eb 64                	jmp    6822 <cbvprintf+0x637>
			} else {
				value->dbl = va_arg(ap, double);
    67be:	41 8b 55 04          	mov    0x4(%r13),%edx
    67c2:	81 fa af 00 00 00    	cmp    $0xaf,%edx
    67c8:	77 0f                	ja     67d9 <cbvprintf+0x5ee>
    67ca:	89 d0                	mov    %edx,%eax
    67cc:	83 c2 10             	add    $0x10,%edx
    67cf:	49 03 45 10          	add    0x10(%r13),%rax
    67d3:	41 89 55 04          	mov    %edx,0x4(%r13)
    67d7:	eb 0c                	jmp    67e5 <cbvprintf+0x5fa>
    67d9:	49 8b 45 08          	mov    0x8(%r13),%rax
    67dd:	48 8d 50 08          	lea    0x8(%rax),%rdx
    67e1:	49 89 55 08          	mov    %rdx,0x8(%r13)
    67e5:	f2 0f 10 00          	movsd  (%rax),%xmm0
    67e9:	f2 0f 11 44 24 30    	movsd  %xmm0,0x30(%rsp)
    67ef:	eb 31                	jmp    6822 <cbvprintf+0x637>
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
    67f1:	83 f8 03             	cmp    $0x3,%eax
    67f4:	75 2c                	jne    6822 <cbvprintf+0x637>
			value->ptr = va_arg(ap, void *);
    67f6:	41 8b 55 00          	mov    0x0(%r13),%edx
    67fa:	83 fa 2f             	cmp    $0x2f,%edx
    67fd:	77 0f                	ja     680e <cbvprintf+0x623>
    67ff:	89 d0                	mov    %edx,%eax
    6801:	83 c2 08             	add    $0x8,%edx
    6804:	49 03 45 10          	add    0x10(%r13),%rax
    6808:	41 89 55 00          	mov    %edx,0x0(%r13)
    680c:	eb 0c                	jmp    681a <cbvprintf+0x62f>
    680e:	49 8b 45 08          	mov    0x8(%r13),%rax
    6812:	48 8d 50 08          	lea    0x8(%rax),%rdx
    6816:	49 89 55 08          	mov    %rdx,0x8(%r13)
    681a:	48 8b 00             	mov    (%rax),%rax
    681d:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
    6822:	8a 4c 24 40          	mov    0x40(%rsp),%cl
    6826:	88 c8                	mov    %cl,%al
    6828:	24 03                	and    $0x3,%al
    682a:	74 25                	je     6851 <cbvprintf+0x666>
			OUTS(sp, fp);
    682c:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    6831:	48 89 e9             	mov    %rbp,%rcx
    6834:	4c 89 fa             	mov    %r15,%rdx
    6837:	4c 89 f7             	mov    %r14,%rdi
    683a:	e8 73 f8 ff ff       	callq  60b2 <outs>
    683f:	85 c0                	test   %eax,%eax
    6841:	0f 88 c1 03 00 00    	js     6c08 <cbvprintf+0xa1d>
    6847:	48 98                	cltq   
    6849:	48 01 c3             	add    %rax,%rbx
			continue;
    684c:	e9 ad 03 00 00       	jmpq   6bfe <cbvprintf+0xa13>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
    6851:	8a 54 24 43          	mov    0x43(%rsp),%dl
    6855:	80 fa 6e             	cmp    $0x6e,%dl
    6858:	0f 84 a3 01 00 00    	je     6a01 <cbvprintf+0x816>
    685e:	7f 2c                	jg     688c <cbvprintf+0x6a1>
    6860:	80 fa 63             	cmp    $0x63,%dl
    6863:	0f 84 ba 00 00 00    	je     6923 <cbvprintf+0x738>
    6869:	7f 0a                	jg     6875 <cbvprintf+0x68a>
    686b:	80 fa 25             	cmp    $0x25,%dl
    686e:	74 51                	je     68c1 <cbvprintf+0x6d6>
    6870:	80 fa 58             	cmp    $0x58,%dl
    6873:	eb 41                	jmp    68b6 <cbvprintf+0x6cb>
    6875:	80 fa 64             	cmp    $0x64,%dl
    6878:	0f 84 c0 00 00 00    	je     693e <cbvprintf+0x753>
    687e:	80 fa 69             	cmp    $0x69,%dl
    6881:	0f 84 b7 00 00 00    	je     693e <cbvprintf+0x753>
    6887:	e9 72 03 00 00       	jmpq   6bfe <cbvprintf+0xa13>
    688c:	80 fa 73             	cmp    $0x73,%dl
    688f:	74 4f                	je     68e0 <cbvprintf+0x6f5>
    6891:	7f 17                	jg     68aa <cbvprintf+0x6bf>
    6893:	80 fa 6f             	cmp    $0x6f,%dl
    6896:	0f 84 cc 00 00 00    	je     6968 <cbvprintf+0x77d>
    689c:	80 fa 70             	cmp    $0x70,%dl
    689f:	0f 84 24 01 00 00    	je     69c9 <cbvprintf+0x7de>
    68a5:	e9 54 03 00 00       	jmpq   6bfe <cbvprintf+0xa13>
    68aa:	80 fa 75             	cmp    $0x75,%dl
    68ad:	0f 84 b5 00 00 00    	je     6968 <cbvprintf+0x77d>
    68b3:	80 fa 78             	cmp    $0x78,%dl
    68b6:	0f 84 ac 00 00 00    	je     6968 <cbvprintf+0x77d>
    68bc:	e9 3d 03 00 00       	jmpq   6bfe <cbvprintf+0xa13>
		case '%':
			OUTC('%');
    68c1:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    68c6:	bf 25 00 00 00       	mov    $0x25,%edi
    68cb:	31 c0                	xor    %eax,%eax
    68cd:	41 ff d6             	callq  *%r14
    68d0:	85 c0                	test   %eax,%eax
    68d2:	0f 88 30 03 00 00    	js     6c08 <cbvprintf+0xa1d>
    68d8:	48 ff c3             	inc    %rbx
			break;
    68db:	e9 1e 03 00 00       	jmpq   6bfe <cbvprintf+0xa13>
		case 's': {
			bps = (const char *)value->ptr;

			size_t len;

			if (precision >= 0) {
    68e0:	45 85 c9             	test   %r9d,%r9d
			bps = (const char *)value->ptr;
    68e3:	4c 8b 64 24 30       	mov    0x30(%rsp),%r12
			if (precision >= 0) {
    68e8:	78 0d                	js     68f7 <cbvprintf+0x70c>
				len = strnlen(bps, precision);
    68ea:	49 63 f1             	movslq %r9d,%rsi
    68ed:	4c 89 e7             	mov    %r12,%rdi
    68f0:	e8 3b de ff ff       	callq  4730 <strnlen@plt>
    68f5:	eb 12                	jmp    6909 <cbvprintf+0x71e>
			} else {
				len = strlen(bps);
    68f7:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    68fb:	4c 89 e7             	mov    %r12,%rdi
    68fe:	f2 ae                	repnz scas %es:(%rdi),%al
    6900:	48 89 c8             	mov    %rcx,%rax
    6903:	48 f7 d0             	not    %rax
    6906:	48 ff c8             	dec    %rax
			}

			bpe = bps + len;
    6909:	49 8d 34 04          	lea    (%r12,%rax,1),%rsi
		char sign = 0;
    690d:	45 31 d2             	xor    %r10d,%r10d
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
    6910:	4d 85 e4             	test   %r12,%r12
			bpe = bps + len;
    6913:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
		if (bps == NULL) {
    6918:	0f 85 66 01 00 00    	jne    6a84 <cbvprintf+0x899>
    691e:	e9 db 02 00 00       	jmpq   6bfe <cbvprintf+0xa13>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    6923:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
			bpe = buf + 1;
    6928:	4c 8d 64 24 52       	lea    0x52(%rsp),%r12
			break;
    692d:	45 31 d2             	xor    %r10d,%r10d
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    6930:	88 44 24 52          	mov    %al,0x52(%rsp)
			bpe = buf + 1;
    6934:	49 8d 44 24 01       	lea    0x1(%r12),%rax
    6939:	e9 1c 01 00 00       	jmpq   6a5a <cbvprintf+0x86f>
			if (conv->flag_plus) {
    693e:	f6 c1 08             	test   $0x8,%cl
				sign = '+';
    6941:	41 b2 2b             	mov    $0x2b,%r10b
			if (conv->flag_plus) {
    6944:	75 0b                	jne    6951 <cbvprintf+0x766>
		char sign = 0;
    6946:	80 e1 10             	and    $0x10,%cl
    6949:	41 0f 95 c2          	setne  %r10b
    694d:	41 c1 e2 05          	shl    $0x5,%r10d
			sint = value->sint;
    6951:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
			if (sint < 0) {
    6956:	48 85 c0             	test   %rax,%rax
    6959:	79 10                	jns    696b <cbvprintf+0x780>
				value->uint = (uint_value_type)-sint;
    695b:	48 f7 d8             	neg    %rax
				sign = '-';
    695e:	41 b2 2d             	mov    $0x2d,%r10b
				value->uint = (uint_value_type)-sint;
    6961:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    6966:	eb 03                	jmp    696b <cbvprintf+0x780>
		char sign = 0;
    6968:	45 31 d2             	xor    %r10d,%r10d
			bps = encode_uint(value->uint, conv, buf, bpe);
    696b:	48 8d 54 24 52       	lea    0x52(%rsp),%rdx
    6970:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
    6975:	49 8d 74 24 10       	lea    0x10(%r12),%rsi
    697a:	44 88 54 24 1f       	mov    %r10b,0x1f(%rsp)
    697f:	44 89 4c 24 10       	mov    %r9d,0x10(%rsp)
    6984:	48 8d 4a 16          	lea    0x16(%rdx),%rcx
    6988:	e8 a9 f7 ff ff       	callq  6136 <encode_uint>
    698d:	44 8a 54 24 1f       	mov    0x1f(%rsp),%r10b
    6992:	49 89 c4             	mov    %rax,%r12
    6995:	44 8b 4c 24 10       	mov    0x10(%rsp),%r9d
			if (precision >= 0) {
    699a:	45 85 c9             	test   %r9d,%r9d
    699d:	0f 88 a9 00 00 00    	js     6a4c <cbvprintf+0x861>
				size_t len = bpe - bps;
    69a3:	48 8d 44 24 68       	lea    0x68(%rsp),%rax
				if (len < (size_t)precision) {
    69a8:	49 63 d1             	movslq %r9d,%rdx
				conv->flag_zero = false;
    69ab:	80 64 24 40 bf       	andb   $0xbf,0x40(%rsp)
				size_t len = bpe - bps;
    69b0:	4c 29 e0             	sub    %r12,%rax
				if (len < (size_t)precision) {
    69b3:	48 39 c2             	cmp    %rax,%rdx
    69b6:	0f 86 90 00 00 00    	jbe    6a4c <cbvprintf+0x861>
					conv->pad0_value = precision - (int)len;
    69bc:	41 29 c1             	sub    %eax,%r9d
    69bf:	44 89 4c 24 44       	mov    %r9d,0x44(%rsp)
    69c4:	e9 83 00 00 00       	jmpq   6a4c <cbvprintf+0x861>
			if (value->ptr != NULL) {
    69c9:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
    69ce:	44 89 4c 24 10       	mov    %r9d,0x10(%rsp)
    69d3:	48 85 ff             	test   %rdi,%rdi
    69d6:	0f 84 85 00 00 00    	je     6a61 <cbvprintf+0x876>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    69dc:	48 8d 54 24 52       	lea    0x52(%rsp),%rdx
    69e1:	49 8d 74 24 10       	lea    0x10(%r12),%rsi
    69e6:	48 8d 4a 16          	lea    0x16(%rdx),%rcx
    69ea:	e8 47 f7 ff ff       	callq  6136 <encode_uint>
				conv->altform_0c = true;
    69ef:	80 4c 24 42 10       	orb    $0x10,0x42(%rsp)
				bps = encode_uint((uintptr_t)value->ptr, conv,
    69f4:	49 89 c4             	mov    %rax,%r12
				conv->specifier = 'x';
    69f7:	c6 44 24 43 78       	movb   $0x78,0x43(%rsp)
		char sign = 0;
    69fc:	45 31 d2             	xor    %r10d,%r10d
    69ff:	eb 94                	jmp    6995 <cbvprintf+0x7aa>
	switch ((enum length_mod_enum)conv->length_mod) {
    6a01:	40 c0 ee 03          	shr    $0x3,%sil
				store_count(conv, value->ptr, count);
    6a05:	48 63 c3             	movslq %ebx,%rax
    6a08:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
	switch ((enum length_mod_enum)conv->length_mod) {
    6a0d:	83 e6 0f             	and    $0xf,%esi
    6a10:	40 80 fe 07          	cmp    $0x7,%sil
    6a14:	0f 87 e4 01 00 00    	ja     6bfe <cbvprintf+0xa13>
    6a1a:	48 8d 3d a7 a2 02 00 	lea    0x2a2a7(%rip),%rdi        # 30cc8 <__func__.5785+0x60>
    6a21:	40 0f b6 f6          	movzbl %sil,%esi
    6a25:	48 63 0c b7          	movslq (%rdi,%rsi,4),%rcx
    6a29:	48 01 f9             	add    %rdi,%rcx
    6a2c:	ff e1                	jmpq   *%rcx
		*(int *)dp = count;
    6a2e:	89 02                	mov    %eax,(%rdx)
    6a30:	e9 c9 01 00 00       	jmpq   6bfe <cbvprintf+0xa13>
		*(signed char *)dp = (signed char)count;
    6a35:	88 1a                	mov    %bl,(%rdx)
    6a37:	e9 c2 01 00 00       	jmpq   6bfe <cbvprintf+0xa13>
		*(short *)dp = (short)count;
    6a3c:	66 89 1a             	mov    %bx,(%rdx)
    6a3f:	e9 ba 01 00 00       	jmpq   6bfe <cbvprintf+0xa13>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    6a44:	48 89 02             	mov    %rax,(%rdx)
    6a47:	e9 b2 01 00 00       	jmpq   6bfe <cbvprintf+0xa13>
		if (bps == NULL) {
    6a4c:	4d 85 e4             	test   %r12,%r12
    6a4f:	0f 84 a9 01 00 00    	je     6bfe <cbvprintf+0xa13>
    6a55:	48 8d 44 24 68       	lea    0x68(%rsp),%rax
    6a5a:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    6a5f:	eb 13                	jmp    6a74 <cbvprintf+0x889>
			bpe = bps + 5;
    6a61:	48 8d 05 14 a7 02 00 	lea    0x2a714(%rip),%rax        # 3117c <__func__.5785+0x514>
    6a68:	45 31 d2             	xor    %r10d,%r10d
			bps = "(nil)";
    6a6b:	4c 8d 60 fb          	lea    -0x5(%rax),%r12
			bpe = bps + 5;
    6a6f:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
		 *   * any exponent content from the converted value
		 * * for non-FP:
		 *   * any pad0_prefix
		 *   * the converted value
		 */
		size_t nj_len = (bpe - bps);
    6a74:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
    6a79:	4c 29 e0             	sub    %r12,%rax
		int pad_len = 0;

		if (sign != 0) {
    6a7c:	45 84 d2             	test   %r10b,%r10b
    6a7f:	74 03                	je     6a84 <cbvprintf+0x899>
			nj_len += 1U;
    6a81:	48 ff c0             	inc    %rax
		}

		if (conv->altform_0c) {
    6a84:	8a 54 24 42          	mov    0x42(%rsp),%dl
    6a88:	f6 c2 10             	test   $0x10,%dl
    6a8b:	74 06                	je     6a93 <cbvprintf+0x8a8>
			nj_len += 2U;
    6a8d:	48 83 c0 02          	add    $0x2,%rax
    6a91:	eb 0b                	jmp    6a9e <cbvprintf+0x8b3>
		} else if (conv->altform_0) {
			nj_len += 1U;
    6a93:	31 c9                	xor    %ecx,%ecx
    6a95:	f6 c2 08             	test   $0x8,%dl
    6a98:	0f 95 c1             	setne  %cl
    6a9b:	48 01 c8             	add    %rcx,%rax
		}

		nj_len += conv->pad0_value;
    6a9e:	48 63 4c 24 44       	movslq 0x44(%rsp),%rcx
    6aa3:	48 01 c8             	add    %rcx,%rax
		if (conv->pad_fp) {
    6aa6:	80 e2 40             	and    $0x40,%dl
    6aa9:	74 08                	je     6ab3 <cbvprintf+0x8c8>
			nj_len += conv->pad0_pre_exp;
    6aab:	48 63 54 24 48       	movslq 0x48(%rsp),%rdx
    6ab0:	48 01 d0             	add    %rdx,%rax
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
    6ab3:	83 7c 24 18 00       	cmpl   $0x0,0x18(%rsp)
    6ab8:	7e 73                	jle    6b2d <cbvprintf+0x942>
			width -= (int)nj_len;
    6aba:	29 44 24 18          	sub    %eax,0x18(%rsp)

			if (!conv->flag_dash) {
    6abe:	8a 44 24 40          	mov    0x40(%rsp),%al
    6ac2:	a8 04                	test   $0x4,%al
    6ac4:	75 67                	jne    6b2d <cbvprintf+0x942>
				char pad = ' ';

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
    6ac6:	a8 40                	test   $0x40,%al
    6ac8:	74 23                	je     6aed <cbvprintf+0x902>
					if (sign != 0) {
    6aca:	45 84 d2             	test   %r10b,%r10b
    6acd:	74 26                	je     6af5 <cbvprintf+0x90a>
						OUTC(sign);
    6acf:	31 c0                	xor    %eax,%eax
    6ad1:	41 0f be fa          	movsbl %r10b,%edi
    6ad5:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    6ada:	41 ff d6             	callq  *%r14
    6add:	85 c0                	test   %eax,%eax
    6adf:	0f 88 23 01 00 00    	js     6c08 <cbvprintf+0xa1d>
    6ae5:	48 ff c3             	inc    %rbx
						sign = 0;
    6ae8:	45 31 d2             	xor    %r10d,%r10d
    6aeb:	eb 08                	jmp    6af5 <cbvprintf+0x90a>
				char pad = ' ';
    6aed:	41 bf 20 00 00 00    	mov    $0x20,%r15d
    6af3:	eb 06                	jmp    6afb <cbvprintf+0x910>
					}
					pad = '0';
    6af5:	41 bf 30 00 00 00    	mov    $0x30,%r15d
				}

				while (width-- > 0) {
    6afb:	ff 4c 24 18          	decl   0x18(%rsp)
    6aff:	8b 44 24 18          	mov    0x18(%rsp),%eax
    6b03:	ff c0                	inc    %eax
    6b05:	85 c0                	test   %eax,%eax
    6b07:	7e 24                	jle    6b2d <cbvprintf+0x942>
					OUTC(pad);
    6b09:	31 c0                	xor    %eax,%eax
    6b0b:	44 88 54 24 1f       	mov    %r10b,0x1f(%rsp)
    6b10:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    6b15:	44 89 ff             	mov    %r15d,%edi
    6b18:	41 ff d6             	callq  *%r14
    6b1b:	85 c0                	test   %eax,%eax
    6b1d:	0f 88 e5 00 00 00    	js     6c08 <cbvprintf+0xa1d>
    6b23:	48 ff c3             	inc    %rbx
    6b26:	44 8a 54 24 1f       	mov    0x1f(%rsp),%r10b
    6b2b:	eb ce                	jmp    6afb <cbvprintf+0x910>
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
    6b2d:	45 84 d2             	test   %r10b,%r10b
    6b30:	74 19                	je     6b4b <cbvprintf+0x960>
			OUTC(sign);
    6b32:	31 c0                	xor    %eax,%eax
    6b34:	41 0f be fa          	movsbl %r10b,%edi
    6b38:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    6b3d:	41 ff d6             	callq  *%r14
    6b40:	85 c0                	test   %eax,%eax
    6b42:	0f 88 c0 00 00 00    	js     6c08 <cbvprintf+0xa1d>
    6b48:	48 ff c3             	inc    %rbx
				OUTC('0');
			}

			OUTS(cp, bpe);
		} else {
			if (conv->altform_0c | conv->altform_0) {
    6b4b:	8a 44 24 42          	mov    0x42(%rsp),%al
    6b4f:	a8 10                	test   $0x10,%al
    6b51:	75 04                	jne    6b57 <cbvprintf+0x96c>
    6b53:	a8 08                	test   $0x8,%al
    6b55:	74 1a                	je     6b71 <cbvprintf+0x986>
				OUTC('0');
    6b57:	31 c0                	xor    %eax,%eax
    6b59:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    6b5e:	bf 30 00 00 00       	mov    $0x30,%edi
    6b63:	41 ff d6             	callq  *%r14
    6b66:	85 c0                	test   %eax,%eax
    6b68:	0f 88 9a 00 00 00    	js     6c08 <cbvprintf+0xa1d>
    6b6e:	48 ff c3             	inc    %rbx
			}

			if (conv->altform_0c) {
    6b71:	f6 44 24 42 10       	testb  $0x10,0x42(%rsp)
    6b76:	74 16                	je     6b8e <cbvprintf+0x9a3>
				OUTC(conv->specifier);
    6b78:	0f be 7c 24 43       	movsbl 0x43(%rsp),%edi
    6b7d:	31 c0                	xor    %eax,%eax
    6b7f:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    6b84:	41 ff d6             	callq  *%r14
    6b87:	85 c0                	test   %eax,%eax
    6b89:	78 7d                	js     6c08 <cbvprintf+0xa1d>
    6b8b:	48 ff c3             	inc    %rbx
    6b8e:	44 8b 7c 24 44       	mov    0x44(%rsp),%r15d
    6b93:	41 01 df             	add    %ebx,%r15d
    6b96:	44 89 f8             	mov    %r15d,%eax
    6b99:	29 d8                	sub    %ebx,%eax
			}

			pad_len = conv->pad0_value;
			while (pad_len-- > 0) {
    6b9b:	85 c0                	test   %eax,%eax
    6b9d:	7e 18                	jle    6bb7 <cbvprintf+0x9cc>
				OUTC('0');
    6b9f:	31 c0                	xor    %eax,%eax
    6ba1:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    6ba6:	bf 30 00 00 00       	mov    $0x30,%edi
    6bab:	41 ff d6             	callq  *%r14
    6bae:	85 c0                	test   %eax,%eax
    6bb0:	78 56                	js     6c08 <cbvprintf+0xa1d>
    6bb2:	48 ff c3             	inc    %rbx
    6bb5:	eb df                	jmp    6b96 <cbvprintf+0x9ab>
			}

			OUTS(bps, bpe);
    6bb7:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
    6bbc:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    6bc1:	4c 89 e2             	mov    %r12,%rdx
    6bc4:	4c 89 f7             	mov    %r14,%rdi
    6bc7:	e8 e6 f4 ff ff       	callq  60b2 <outs>
    6bcc:	85 c0                	test   %eax,%eax
    6bce:	78 38                	js     6c08 <cbvprintf+0xa1d>
    6bd0:	44 8b 64 24 18       	mov    0x18(%rsp),%r12d
    6bd5:	48 98                	cltq   
    6bd7:	48 01 c3             	add    %rax,%rbx
    6bda:	41 01 dc             	add    %ebx,%r12d
    6bdd:	44 89 e0             	mov    %r12d,%eax
    6be0:	29 d8                	sub    %ebx,%eax
		}

		/* Finish left justification */
		while (width > 0) {
    6be2:	85 c0                	test   %eax,%eax
    6be4:	7e 18                	jle    6bfe <cbvprintf+0xa13>
			OUTC(' ');
    6be6:	31 c0                	xor    %eax,%eax
    6be8:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    6bed:	bf 20 00 00 00       	mov    $0x20,%edi
    6bf2:	41 ff d6             	callq  *%r14
    6bf5:	85 c0                	test   %eax,%eax
    6bf7:	78 0f                	js     6c08 <cbvprintf+0xa1d>
    6bf9:	48 ff c3             	inc    %rbx
    6bfc:	eb df                	jmp    6bdd <cbvprintf+0x9f2>
			OUTS(bps, bpe);
    6bfe:	49 89 ef             	mov    %rbp,%r15
    6c01:	e9 13 f6 ff ff       	jmpq   6219 <cbvprintf+0x2e>
			--width;
		}
	}

	return count;
    6c06:	89 d8                	mov    %ebx,%eax
#undef OUTS
#undef OUTC
}
    6c08:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
    6c0d:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
    6c14:	00 00 
    6c16:	74 05                	je     6c1d <cbvprintf+0xa32>
    6c18:	e8 23 da ff ff       	callq  4640 <__stack_chk_fail@plt>
    6c1d:	48 83 c4 78          	add    $0x78,%rsp
    6c21:	5b                   	pop    %rbx
    6c22:	5d                   	pop    %rbp
    6c23:	41 5c                	pop    %r12
    6c25:	41 5d                	pop    %r13
    6c27:	41 5e                	pop    %r14
    6c29:	41 5f                	pop    %r15
    6c2b:	c3                   	retq   

0000000000006c2c <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_KERNEL_BIN_NAME, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    6c2c:	c3                   	retq   

0000000000006c2d <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
    6c2d:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
    6c34:	00 
	list->head = NULL;
    6c35:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
}
    6c3c:	c3                   	retq   

0000000000006c3d <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
    6c3d:	48 83 3f 00          	cmpq   $0x0,(%rdi)
    6c41:	75 05                	jne    6c48 <log_list_add_tail+0xb>
		list->head = msg;
    6c43:	48 89 37             	mov    %rsi,(%rdi)
    6c46:	eb 07                	jmp    6c4f <log_list_add_tail+0x12>
	} else {
		list->tail->next = msg;
    6c48:	48 8b 47 08          	mov    0x8(%rdi),%rax
    6c4c:	48 89 30             	mov    %rsi,(%rax)
	}

	list->tail = msg;
    6c4f:	48 89 77 08          	mov    %rsi,0x8(%rdi)
	msg->next = NULL;
    6c53:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
}
    6c5a:	c3                   	retq   

0000000000006c5b <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
    6c5b:	48 8b 07             	mov    (%rdi),%rax
}
    6c5e:	c3                   	retq   

0000000000006c5f <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
	struct log_msg *msg = list->head;
    6c5f:	48 8b 07             	mov    (%rdi),%rax

	if (list->head != NULL) {
    6c62:	48 85 c0             	test   %rax,%rax
    6c65:	74 06                	je     6c6d <log_list_head_get+0xe>
		list->head = list->head->next;
    6c67:	48 8b 10             	mov    (%rax),%rdx
    6c6a:	48 89 17             	mov    %rdx,(%rdi)
	}

	return msg;
}
    6c6d:	c3                   	retq   

0000000000006c6e <dummy_timestamp>:
bool log_is_strdup(const void *buf);

static uint32_t dummy_timestamp(void)
{
	return 0;
}
    6c6e:	31 c0                	xor    %eax,%eax
    6c70:	c3                   	retq   

0000000000006c71 <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
    6c71:	48 83 ec 08          	sub    $0x8,%rsp
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    6c75:	e8 5e 09 00 00       	callq  75d8 <log_msg_chunk_alloc>

	if (msg != NULL) {
    6c7a:	48 85 c0             	test   %rax,%rax
    6c7d:	74 0d                	je     6c8c <z_log_msg_std_alloc+0x1b>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
    6c7f:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%rax)
    6c86:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%rax)
			msg->hdr.ids.source_id = 0;
		}
	}

	return msg;
}
    6c8c:	5a                   	pop    %rdx
    6c8d:	c3                   	retq   

0000000000006c8e <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    6c8e:	48 8d 3d 13 3a 23 00 	lea    0x233a13(%rip),%rdi        # 23a6a8 <_k_msgq_list_end>
    6c95:	e9 9c 52 02 00       	jmpq   2bf36 <z_impl_k_sem_give>

0000000000006c9a <k_cycle_get_32_wrapper>:

extern uint32_t z_timer_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return z_timer_cycle_get_32();
    6c9a:	e9 76 26 00 00       	jmpq   9315 <z_timer_cycle_get_32>

0000000000006c9f <enable_logger>:
static int enable_logger(const struct device *arg)
{
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
    6c9f:	48 8d 35 e8 ff ff ff 	lea    -0x18(%rip),%rsi        # 6c8e <log_process_thread_timer_expiry_fn>
    6ca6:	48 8d 3d 93 3e 23 00 	lea    0x233e93(%rip),%rdi        # 23ab40 <log_process_thread_timer>
{
    6cad:	48 83 ec 08          	sub    $0x8,%rsp
		k_timer_init(&log_process_thread_timer,
    6cb1:	31 d2                	xor    %edx,%edx
    6cb3:	e8 9c 5b 02 00       	callq  2c854 <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    6cb8:	48 8d 35 61 fe 22 00 	lea    0x22fe61(%rip),%rsi        # 236b20 <logging_stack>
    6cbf:	48 8d 3d da 3d 23 00 	lea    0x233dda(%rip),%rdi        # 23aaa0 <logging_thread>
    6cc6:	48 8d 0d f8 04 00 00 	lea    0x4f8(%rip),%rcx        # 71c5 <log_process_thread_func>
    6ccd:	6a 00                	pushq  $0x0
    6ccf:	6a 00                	pushq  $0x0
    6cd1:	45 31 c9             	xor    %r9d,%r9d
    6cd4:	6a 0e                	pushq  $0xe
    6cd6:	6a 00                	pushq  $0x0
    6cd8:	45 31 c0             	xor    %r8d,%r8d
    6cdb:	ba 00 03 00 00       	mov    $0x300,%edx
    6ce0:	e8 2b 54 02 00       	callq  2c110 <z_impl_k_thread_create>
    6ce5:	48 83 c4 20          	add    $0x20,%rsp
	return z_impl_k_thread_name_set(thread_id, value);
    6ce9:	48 8d 3d b0 3d 23 00 	lea    0x233db0(%rip),%rdi        # 23aaa0 <logging_thread>
    6cf0:	48 8d 35 86 a4 02 00 	lea    0x2a486(%rip),%rsi        # 3117d <__func__.5785+0x515>
    6cf7:	e8 31 53 02 00       	callq  2c02d <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
    6cfc:	31 c0                	xor    %eax,%eax
    6cfe:	5a                   	pop    %rdx
    6cff:	c3                   	retq   

0000000000006d00 <z_log_get_s_mask>:
{
    6d00:	41 57                	push   %r15
    6d02:	41 56                	push   %r14
				mask |= BIT(arg);
    6d04:	41 bf 01 00 00 00    	mov    $0x1,%r15d
{
    6d0a:	41 55                	push   %r13
    6d0c:	41 54                	push   %r12
    6d0e:	49 89 fe             	mov    %rdi,%r14
    6d11:	55                   	push   %rbp
    6d12:	53                   	push   %rbx
	uint32_t mask = 0;
    6d13:	45 31 ed             	xor    %r13d,%r13d
	uint32_t arg = 0;
    6d16:	31 ed                	xor    %ebp,%ebp
	bool arm = false;
    6d18:	45 31 e4             	xor    %r12d,%r12d
{
    6d1b:	48 83 ec 18          	sub    $0x18,%rsp
	while ((curr = *str++) && arg < nargs) {
    6d1f:	49 ff c6             	inc    %r14
    6d22:	39 f5                	cmp    %esi,%ebp
    6d24:	41 8a 5e ff          	mov    -0x1(%r14),%bl
    6d28:	73 47                	jae    6d71 <z_log_get_s_mask+0x71>
    6d2a:	84 db                	test   %bl,%bl
    6d2c:	74 43                	je     6d71 <z_log_get_s_mask+0x71>
		if (curr == '%') {
    6d2e:	80 fb 25             	cmp    $0x25,%bl
    6d31:	75 06                	jne    6d39 <z_log_get_s_mask+0x39>
			arm = !arm;
    6d33:	41 83 f4 01          	xor    $0x1,%r12d
    6d37:	eb e6                	jmp    6d1f <z_log_get_s_mask+0x1f>
		} else if (arm && isalpha((int)curr)) {
    6d39:	45 84 e4             	test   %r12b,%r12b
    6d3c:	74 e1                	je     6d1f <z_log_get_s_mask+0x1f>
    6d3e:	89 74 24 0c          	mov    %esi,0xc(%rsp)
    6d42:	e8 c9 d8 ff ff       	callq  4610 <__ctype_b_loc@plt>
    6d47:	48 8b 08             	mov    (%rax),%rcx
    6d4a:	48 0f be d3          	movsbq %bl,%rdx
    6d4e:	8b 74 24 0c          	mov    0xc(%rsp),%esi
    6d52:	f6 44 51 01 04       	testb  $0x4,0x1(%rcx,%rdx,2)
    6d57:	74 c6                	je     6d1f <z_log_get_s_mask+0x1f>
			if (curr == 's') {
    6d59:	80 fb 73             	cmp    $0x73,%bl
    6d5c:	75 0c                	jne    6d6a <z_log_get_s_mask+0x6a>
				mask |= BIT(arg);
    6d5e:	4c 89 f8             	mov    %r15,%rax
    6d61:	40 88 e9             	mov    %bpl,%cl
    6d64:	48 d3 e0             	shl    %cl,%rax
    6d67:	41 09 c5             	or     %eax,%r13d
			arg++;
    6d6a:	ff c5                	inc    %ebp
			arm = false;
    6d6c:	45 31 e4             	xor    %r12d,%r12d
    6d6f:	eb ae                	jmp    6d1f <z_log_get_s_mask+0x1f>
}
    6d71:	48 83 c4 18          	add    $0x18,%rsp
    6d75:	44 89 e8             	mov    %r13d,%eax
    6d78:	5b                   	pop    %rbx
    6d79:	5d                   	pop    %rbp
    6d7a:	41 5c                	pop    %r12
    6d7c:	41 5d                	pop    %r13
    6d7e:	41 5e                	pop    %r14
    6d80:	41 5f                	pop    %r15
    6d82:	c3                   	retq   

0000000000006d83 <log_core_init>:
{
    6d83:	48 83 ec 08          	sub    $0x8,%rsp
		log_msg_pool_init();
    6d87:	e8 bf 07 00 00       	callq  754b <log_msg_pool_init>
		log_list_init(&list);
    6d8c:	48 8d 3d fd 0e 25 00 	lea    0x250efd(%rip),%rdi        # 257c90 <list>
    6d93:	e8 95 fe ff ff       	callq  6c2d <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
    6d98:	48 8d 3d 01 3e 23 00 	lea    0x233e01(%rip),%rdi        # 23aba0 <log_strdup_pool>
    6d9f:	48 8d 35 7a 00 23 00 	lea    0x23007a(%rip),%rsi        # 236e20 <log_strdup_pool_buf>
    6da6:	b9 04 00 00 00       	mov    $0x4,%ecx
    6dab:	ba 28 00 00 00       	mov    $0x28,%edx
    6db0:	e8 17 3f 02 00       	callq  2accc <k_mem_slab_init>
		timestamp_func = k_cycle_get_32_wrapper;
    6db5:	48 8d 05 de fe ff ff 	lea    -0x122(%rip),%rax        # 6c9a <k_cycle_get_32_wrapper>
	log_output_timestamp_freq_set(freq);
    6dbc:	bf 40 42 0f 00       	mov    $0xf4240,%edi
		timestamp_func = k_cycle_get_32_wrapper;
    6dc1:	48 89 05 88 fc 22 00 	mov    %rax,0x22fc88(%rip)        # 236a50 <timestamp_func>
}
    6dc8:	58                   	pop    %rax
	log_output_timestamp_freq_set(freq);
    6dc9:	e9 9f 14 00 00       	jmpq   826d <log_output_timestamp_freq_set>

0000000000006dce <dropped_notify>:
{
    6dce:	41 55                	push   %r13
    6dd0:	41 54                	push   %r12
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    6dd2:	45 31 ed             	xor    %r13d,%r13d
    6dd5:	55                   	push   %rbp
    6dd6:	53                   	push   %rbx
    6dd7:	48 83 ec 08          	sub    $0x8,%rsp
    6ddb:	44 87 2d 72 52 25 00 	xchg   %r13d,0x255272(%rip)        # 25c054 <dropped_cnt>
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
    6de2:	4c 8d 25 a7 36 23 00 	lea    0x2336a7(%rip),%r12        # 23a490 <__log_const_end>
    6de9:	48 8d 1d c0 36 23 00 	lea    0x2336c0(%rip),%rbx        # 23a4b0 <__log_backends_end>
	for (int i = 0; i < log_backend_count_get(); i++) {
    6df0:	31 ed                	xor    %ebp,%ebp
    6df2:	4c 29 e3             	sub    %r12,%rbx
    6df5:	48 c1 fb 05          	sar    $0x5,%rbx
    6df9:	39 eb                	cmp    %ebp,%ebx
    6dfb:	7e 2d                	jle    6e2a <dropped_notify+0x5c>
    6dfd:	48 89 e8             	mov    %rbp,%rax
    6e00:	48 c1 e0 05          	shl    $0x5,%rax
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
    6e04:	4a 8b 54 20 08       	mov    0x8(%rax,%r12,1),%rdx
    6e09:	4a 8d 3c 20          	lea    (%rax,%r12,1),%rdi
		if (log_backend_is_active(backend)) {
    6e0d:	80 7a 09 00          	cmpb   $0x0,0x9(%rdx)
    6e11:	74 12                	je     6e25 <dropped_notify+0x57>
	if (backend->api->dropped != NULL) {
    6e13:	4a 8b 04 20          	mov    (%rax,%r12,1),%rax
    6e17:	48 8b 40 18          	mov    0x18(%rax),%rax
    6e1b:	48 85 c0             	test   %rax,%rax
    6e1e:	74 05                	je     6e25 <dropped_notify+0x57>
		backend->api->dropped(backend, cnt);
    6e20:	44 89 ee             	mov    %r13d,%esi
    6e23:	ff d0                	callq  *%rax
    6e25:	48 ff c5             	inc    %rbp
    6e28:	eb cf                	jmp    6df9 <dropped_notify+0x2b>
}
    6e2a:	58                   	pop    %rax
    6e2b:	5b                   	pop    %rbx
    6e2c:	5d                   	pop    %rbp
    6e2d:	41 5c                	pop    %r12
    6e2f:	41 5d                	pop    %r13
    6e31:	c3                   	retq   

0000000000006e32 <log_dropped>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    6e32:	f0 ff 05 1b 52 25 00 	lock incl 0x25521b(%rip)        # 25c054 <dropped_cnt>
}
    6e39:	c3                   	retq   

0000000000006e3a <log_source_name_get>:
    6e3a:	48 8d 0d 1f 35 23 00 	lea    0x23351f(%rip),%rcx        # 23a360 <_settings_handler_static_list_end>
    6e41:	48 8d 15 48 36 23 00 	lea    0x233648(%rip),%rdx        # 23a490 <__log_const_end>
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
    6e48:	31 c0                	xor    %eax,%eax
    6e4a:	48 29 ca             	sub    %rcx,%rdx
    6e4d:	48 c1 ea 04          	shr    $0x4,%rdx
    6e51:	39 d6                	cmp    %edx,%esi
    6e53:	73 0a                	jae    6e5f <log_source_name_get+0x25>
	return __log_const_start[source_id].name;
    6e55:	89 f6                	mov    %esi,%esi
    6e57:	48 c1 e6 04          	shl    $0x4,%rsi
    6e5b:	48 8b 04 31          	mov    (%rcx,%rsi,1),%rax
}
    6e5f:	c3                   	retq   

0000000000006e60 <log_backend_enable>:
	id += backend - log_backend_get(0);
    6e60:	48 89 f8             	mov    %rdi,%rax
    6e63:	48 2b 05 46 f1 22 00 	sub    0x22f146(%rip),%rax        # 235fb0 <_GLOBAL_OFFSET_TABLE_+0x2d0>
	backend->cb->id = id;
    6e6a:	48 8b 57 08          	mov    0x8(%rdi),%rdx
    6e6e:	48 c1 f8 05          	sar    $0x5,%rax
    6e72:	ff c0                	inc    %eax
	if (!backend_attached) {
    6e74:	80 3d 66 82 25 00 00 	cmpb   $0x0,0x258266(%rip)        # 25f0e1 <backend_attached>
	log_backend_id_set(backend, id);
    6e7b:	88 42 08             	mov    %al,0x8(%rdx)
	log_backend_activate(backend, ctx);
    6e7e:	48 8b 47 08          	mov    0x8(%rdi),%rax
	backend->cb->ctx = ctx;
    6e82:	48 89 30             	mov    %rsi,(%rax)
	backend->cb->active = true;
    6e85:	c6 40 09 01          	movb   $0x1,0x9(%rax)
	if (!backend_attached) {
    6e89:	75 19                	jne    6ea4 <log_backend_enable+0x44>
{
    6e8b:	48 83 ec 08          	sub    $0x8,%rsp
	z_impl_k_sem_give(sem);
    6e8f:	48 8d 3d 12 38 23 00 	lea    0x233812(%rip),%rdi        # 23a6a8 <_k_msgq_list_end>
    6e96:	e8 9b 50 02 00       	callq  2bf36 <z_impl_k_sem_give>
	backend_attached = true;
    6e9b:	c6 05 3f 82 25 00 01 	movb   $0x1,0x25823f(%rip)        # 25f0e1 <backend_attached>
}
    6ea2:	58                   	pop    %rax
    6ea3:	c3                   	retq   
	backend_attached = true;
    6ea4:	c6 05 36 82 25 00 01 	movb   $0x1,0x258236(%rip)        # 25f0e1 <backend_attached>
    6eab:	c3                   	retq   

0000000000006eac <log_init>:
    6eac:	b8 01 00 00 00       	mov    $0x1,%eax
    6eb1:	f0 0f c1 05 a3 51 25 	lock xadd %eax,0x2551a3(%rip)        # 25c05c <initialized>
    6eb8:	00 
	if (atomic_inc(&initialized) != 0) {
    6eb9:	85 c0                	test   %eax,%eax
    6ebb:	75 52                	jne    6f0f <log_init+0x63>
{
    6ebd:	41 54                	push   %r12
    6ebf:	55                   	push   %rbp
	for (i = 0; i < log_backend_count_get(); i++) {
    6ec0:	45 31 e4             	xor    %r12d,%r12d
{
    6ec3:	53                   	push   %rbx
	return __log_backends_end - __log_backends_start;
    6ec4:	48 8d 2d e5 35 23 00 	lea    0x2335e5(%rip),%rbp        # 23a4b0 <__log_backends_end>
    6ecb:	48 8d 1d be 35 23 00 	lea    0x2335be(%rip),%rbx        # 23a490 <__log_const_end>
    6ed2:	48 29 dd             	sub    %rbx,%rbp
    6ed5:	48 c1 fd 05          	sar    $0x5,%rbp
	for (i = 0; i < log_backend_count_get(); i++) {
    6ed9:	41 39 ec             	cmp    %ebp,%r12d
    6edc:	7d 2c                	jge    6f0a <log_init+0x5e>
		if (backend->autostart) {
    6ede:	80 7b 18 00          	cmpb   $0x0,0x18(%rbx)
    6ee2:	74 1d                	je     6f01 <log_init+0x55>
			if (backend->api->init != NULL) {
    6ee4:	48 8b 03             	mov    (%rbx),%rax
    6ee7:	48 8b 40 28          	mov    0x28(%rax),%rax
    6eeb:	48 85 c0             	test   %rax,%rax
    6eee:	74 02                	je     6ef2 <log_init+0x46>
				backend->api->init();
    6ef0:	ff d0                	callq  *%rax
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
    6ef2:	ba 04 00 00 00       	mov    $0x4,%edx
    6ef7:	31 f6                	xor    %esi,%esi
    6ef9:	48 89 df             	mov    %rbx,%rdi
    6efc:	e8 5f ff ff ff       	callq  6e60 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
    6f01:	41 ff c4             	inc    %r12d
    6f04:	48 83 c3 20          	add    $0x20,%rbx
    6f08:	eb cf                	jmp    6ed9 <log_init+0x2d>
}
    6f0a:	5b                   	pop    %rbx
    6f0b:	5d                   	pop    %rbp
    6f0c:	41 5c                	pop    %r12
    6f0e:	c3                   	retq   
    6f0f:	c3                   	retq   

0000000000006f10 <log_strdup>:
{
    6f10:	53                   	push   %rbx
    6f11:	48 89 fb             	mov    %rdi,%rbx
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
    6f14:	31 d2                	xor    %edx,%edx
{
    6f16:	48 83 ec 10          	sub    $0x10,%rsp
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
    6f1a:	48 8d 3d 7f 3c 23 00 	lea    0x233c7f(%rip),%rdi        # 23aba0 <log_strdup_pool>
    6f21:	48 89 e6             	mov    %rsp,%rsi
{
    6f24:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    6f2b:	00 00 
    6f2d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    6f32:	31 c0                	xor    %eax,%eax
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
    6f34:	e8 e0 3d 02 00       	callq  2ad19 <k_mem_slab_alloc>
	if (err != 0) {
    6f39:	85 c0                	test   %eax,%eax
    6f3b:	48 8d 15 43 a2 02 00 	lea    0x2a243(%rip),%rdx        # 31185 <__func__.5785+0x51d>
    6f42:	75 2e                	jne    6f72 <log_strdup+0x62>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    6f44:	48 8b 14 24          	mov    (%rsp),%rdx
    6f48:	b8 01 00 00 00       	mov    $0x1,%eax
    6f4d:	87 02                	xchg   %eax,(%rdx)

__fortify_function char *
__NTH (strncpy (char *__restrict __dest, const char *__restrict __src,
		size_t __len))
{
  return __builtin___strncpy_chk (__dest, __src, __len, __bos (__dest));
    6f4f:	48 8b 04 24          	mov    (%rsp),%rax
    6f53:	ba 1f 00 00 00       	mov    $0x1f,%edx
    6f58:	48 89 de             	mov    %rbx,%rsi
    6f5b:	48 8d 78 04          	lea    0x4(%rax),%rdi
    6f5f:	e8 fc d4 ff ff       	callq  4460 <strncpy@plt>
	dup->buf[sizeof(dup->buf) - 2] = '~';
    6f64:	48 8b 14 24          	mov    (%rsp),%rdx
    6f68:	66 c7 42 23 7e 00    	movw   $0x7e,0x23(%rdx)
	return dup->buf;
    6f6e:	48 83 c2 04          	add    $0x4,%rdx
}
    6f72:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    6f77:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    6f7e:	00 00 
    6f80:	48 89 d0             	mov    %rdx,%rax
    6f83:	74 05                	je     6f8a <log_strdup+0x7a>
    6f85:	e8 b6 d6 ff ff       	callq  4640 <__stack_chk_fail@plt>
    6f8a:	48 83 c4 10          	add    $0x10,%rsp
    6f8e:	5b                   	pop    %rbx
    6f8f:	c3                   	retq   

0000000000006f90 <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (uint8_t *)buf);
    6f90:	48 8d 15 89 fe 22 00 	lea    0x22fe89(%rip),%rdx        # 236e20 <log_strdup_pool_buf>
    6f97:	48 85 ff             	test   %rdi,%rdi
    6f9a:	0f 95 c0             	setne  %al
    6f9d:	48 39 d7             	cmp    %rdx,%rdi
    6fa0:	0f 93 c2             	setae  %dl
    6fa3:	21 d0                	and    %edx,%eax
    6fa5:	48 8d 15 14 ff 22 00 	lea    0x22ff14(%rip),%rdx        # 236ec0 <log_msg_pool_buf>
    6fac:	48 39 d7             	cmp    %rdx,%rdi
    6faf:	0f 92 c2             	setb   %dl
    6fb2:	21 d0                	and    %edx,%eax
}
    6fb4:	c3                   	retq   

0000000000006fb5 <z_impl_log_process>:
	if (!backend_attached && !bypass) {
    6fb5:	40 88 f8             	mov    %dil,%al
    6fb8:	0a 05 23 81 25 00    	or     0x258123(%rip),%al        # 25f0e1 <backend_attached>
    6fbe:	0f 84 9d 01 00 00    	je     7161 <z_impl_log_process+0x1ac>
{
    6fc4:	41 57                	push   %r15
    6fc6:	41 56                	push   %r14
    6fc8:	41 55                	push   %r13
    6fca:	41 54                	push   %r12
    6fcc:	55                   	push   %rbp
    6fcd:	53                   	push   %rbx
    6fce:	89 fd                	mov    %edi,%ebp
    6fd0:	48 83 ec 18          	sub    $0x18,%rsp
	return key == false;
}

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	return posix_irq_lock();
    6fd4:	e8 b9 4f 00 00       	callq  bf92 <posix_irq_lock>
	msg = log_list_head_get(&list);
    6fd9:	48 8d 3d b0 0c 25 00 	lea    0x250cb0(%rip),%rdi        # 257c90 <list>
    6fe0:	41 89 c4             	mov    %eax,%r12d
    6fe3:	e8 77 fc ff ff       	callq  6c5f <log_list_head_get>
}


static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	posix_irq_unlock(key);
    6fe8:	44 89 e7             	mov    %r12d,%edi
    6feb:	48 89 c3             	mov    %rax,%rbx
    6fee:	e8 a9 4f 00 00       	callq  bf9c <posix_irq_unlock>
	if (msg != NULL) {
    6ff3:	48 85 db             	test   %rbx,%rbx
    6ff6:	0f 84 31 01 00 00    	je     712d <z_impl_log_process+0x178>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    6ffc:	f0 ff 0d 55 50 25 00 	lock decl 0x255055(%rip)        # 25c058 <buffered_cnt>
	if (!bypass) {
    7003:	40 84 ed             	test   %bpl,%bpl
    7006:	74 0d                	je     7015 <z_impl_log_process+0x60>
	log_msg_put(msg);
    7008:	48 89 df             	mov    %rbx,%rdi
    700b:	e8 6e 07 00 00       	callq  777e <log_msg_put>
    7010:	e9 18 01 00 00       	jmpq   712d <z_impl_log_process+0x178>
		if (IS_ENABLED(CONFIG_LOG_DETECT_MISSED_STRDUP) &&
    7015:	80 3d c6 80 25 00 00 	cmpb   $0x0,0x2580c6(%rip)        # 25f0e2 <panic_mode>
    701c:	74 1d                	je     703b <z_impl_log_process+0x86>
    701e:	4c 8d 35 6b 34 23 00 	lea    0x23346b(%rip),%r14        # 23a490 <__log_const_end>
    7025:	4c 8d 25 84 34 23 00 	lea    0x233484(%rip),%r12        # 23a4b0 <__log_backends_end>
    702c:	45 31 ed             	xor    %r13d,%r13d
    702f:	4d 29 f4             	sub    %r14,%r12
    7032:	49 c1 fc 05          	sar    $0x5,%r12
    7036:	e9 e8 00 00 00       	jmpq   7123 <z_impl_log_process+0x16e>
	if (!log_msg_is_std(msg)) {
    703b:	f6 43 0c 01          	testb  $0x1,0xc(%rbx)
    703f:	75 dd                	jne    701e <z_impl_log_process+0x69>
	msg_str = log_msg_str_get(msg);
    7041:	48 89 df             	mov    %rbx,%rdi
    7044:	e8 34 06 00 00       	callq  767d <log_msg_str_get>
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    7049:	48 89 df             	mov    %rbx,%rdi
	msg_str = log_msg_str_get(msg);
    704c:	49 89 c6             	mov    %rax,%r14
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    704f:	e8 dc 05 00 00       	callq  7630 <log_msg_nargs_get>
    7054:	4c 89 f7             	mov    %r14,%rdi
    7057:	89 c6                	mov    %eax,%esi
    7059:	e8 a2 fc ff ff       	callq  6d00 <z_log_get_s_mask>
    705e:	41 89 c5             	mov    %eax,%r13d
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    7061:	48 8d 05 d8 33 23 00 	lea    0x2333d8(%rip),%rax        # 23a440 <log_const_log>
    7068:	48 2b 05 e1 ee 22 00 	sub    0x22eee1(%rip),%rax        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
    706f:	48 c1 e8 04          	shr    $0x4,%rax
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
    7073:	66 25 ff 03          	and    $0x3ff,%ax
    7077:	66 89 44 24 0e       	mov    %ax,0xe(%rsp)
	while (mask) {
    707c:	45 85 ed             	test   %r13d,%r13d
    707f:	74 9d                	je     701e <z_impl_log_process+0x69>
		idx = 31 - __builtin_clz(mask);
    7081:	41 0f bd c5          	bsr    %r13d,%eax
    7085:	41 bc 1f 00 00 00    	mov    $0x1f,%r12d
		str = (const char *)log_msg_arg_get(msg, idx);
    708b:	48 89 df             	mov    %rbx,%rdi
		idx = 31 - __builtin_clz(mask);
    708e:	83 f0 1f             	xor    $0x1f,%eax
    7091:	41 29 c4             	sub    %eax,%r12d
		str = (const char *)log_msg_arg_get(msg, idx);
    7094:	44 89 e6             	mov    %r12d,%esi
    7097:	e8 9e 05 00 00       	callq  763a <log_msg_arg_get>
		if (!is_rodata(str) && !log_is_strdup(str) &&
    709c:	48 89 c7             	mov    %rax,%rdi
		str = (const char *)log_msg_arg_get(msg, idx);
    709f:	49 89 c7             	mov    %rax,%r15
		if (!is_rodata(str) && !log_is_strdup(str) &&
    70a2:	e8 e9 fe ff ff       	callq  6f90 <log_is_strdup>
    70a7:	48 8d 15 d7 a0 02 00 	lea    0x2a0d7(%rip),%rdx        # 31185 <__func__.5785+0x51d>
    70ae:	4c 39 fa             	cmp    %r15,%rdx
    70b1:	74 39                	je     70ec <z_impl_log_process+0x137>
    70b3:	fe c8                	dec    %al
    70b5:	74 35                	je     70ec <z_impl_log_process+0x137>
	return msg->hdr.ids.source_id;
    70b7:	66 8b 73 0e          	mov    0xe(%rbx),%si
			const char *src_name =
    70bb:	31 ff                	xor    %edi,%edi
    70bd:	66 c1 ee 06          	shr    $0x6,%si
    70c1:	0f b7 f6             	movzwl %si,%esi
    70c4:	e8 71 fd ff ff       	callq  6e3a <log_source_name_get>
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
    70c9:	66 44 8b 44 24 0e    	mov    0xe(%rsp),%r8w
    70cf:	48 8d 3d c9 a0 02 00 	lea    0x2a0c9(%rip),%rdi        # 3119f <__func__.5785+0x537>
    70d6:	49 63 f4             	movslq %r12d,%rsi
    70d9:	4c 89 f1             	mov    %r14,%rcx
    70dc:	48 89 c2             	mov    %rax,%rdx
    70df:	41 c1 e0 06          	shl    $0x6,%r8d
    70e3:	41 83 c8 01          	or     $0x1,%r8d
    70e7:	e8 98 02 00 00       	callq  7384 <log_3>
		mask &= ~BIT(idx);
    70ec:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
    70f3:	44 88 e1             	mov    %r12b,%cl
    70f6:	48 d3 c0             	rol    %cl,%rax
    70f9:	41 21 c5             	and    %eax,%r13d
    70fc:	e9 7b ff ff ff       	jmpq   707c <z_impl_log_process+0xc7>
    7101:	4c 89 e8             	mov    %r13,%rax
    7104:	48 c1 e0 05          	shl    $0x5,%rax
	return backend->cb->active;
    7108:	4a 8b 54 30 08       	mov    0x8(%rax,%r14,1),%rdx
    710d:	4a 8d 3c 30          	lea    (%rax,%r14,1),%rdi
			if (log_backend_is_active(backend) &&
    7111:	80 7a 09 00          	cmpb   $0x0,0x9(%rdx)
    7115:	74 09                	je     7120 <z_impl_log_process+0x16b>
	backend->api->put(backend, msg);
    7117:	4a 8b 04 30          	mov    (%rax,%r14,1),%rax
    711b:	48 89 de             	mov    %rbx,%rsi
    711e:	ff 10                	callq  *(%rax)
    7120:	49 ff c5             	inc    %r13
		for (int i = 0; i < log_backend_count_get(); i++) {
    7123:	45 39 ec             	cmp    %r13d,%r12d
    7126:	7f d9                	jg     7101 <z_impl_log_process+0x14c>
    7128:	e9 db fe ff ff       	jmpq   7008 <z_impl_log_process+0x53>
	if (!bypass && dropped_cnt) {
    712d:	40 84 ed             	test   %bpl,%bpl
    7130:	75 0e                	jne    7140 <z_impl_log_process+0x18b>
    7132:	83 3d 1b 4f 25 00 00 	cmpl   $0x0,0x254f1b(%rip)        # 25c054 <dropped_cnt>
    7139:	74 05                	je     7140 <z_impl_log_process+0x18b>
		dropped_notify();
    713b:	e8 8e fc ff ff       	callq  6dce <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
    7140:	48 8d 3d 49 0b 25 00 	lea    0x250b49(%rip),%rdi        # 257c90 <list>
    7147:	e8 0f fb ff ff       	callq  6c5b <log_list_head_peek>
    714c:	48 85 c0             	test   %rax,%rax
    714f:	0f 95 c0             	setne  %al
}
    7152:	48 83 c4 18          	add    $0x18,%rsp
    7156:	5b                   	pop    %rbx
    7157:	5d                   	pop    %rbp
    7158:	41 5c                	pop    %r12
    715a:	41 5d                	pop    %r13
    715c:	41 5e                	pop    %r14
    715e:	41 5f                	pop    %r15
    7160:	c3                   	retq   
    7161:	c3                   	retq   

0000000000007162 <z_impl_log_panic>:
	if (panic_mode) {
    7162:	80 3d 79 7f 25 00 00 	cmpb   $0x0,0x257f79(%rip)        # 25f0e2 <panic_mode>
    7169:	75 59                	jne    71c4 <z_impl_log_panic+0x62>
{
    716b:	41 54                	push   %r12
    716d:	55                   	push   %rbp
	for (int i = 0; i < log_backend_count_get(); i++) {
    716e:	45 31 e4             	xor    %r12d,%r12d
{
    7171:	53                   	push   %rbx
	log_init();
    7172:	e8 35 fd ff ff       	callq  6eac <log_init>
	return __log_backends_end - __log_backends_start;
    7177:	48 8d 1d 12 33 23 00 	lea    0x233312(%rip),%rbx        # 23a490 <__log_const_end>
    717e:	48 8d 2d 2b 33 23 00 	lea    0x23332b(%rip),%rbp        # 23a4b0 <__log_backends_end>
    7185:	48 29 dd             	sub    %rbx,%rbp
    7188:	48 c1 fd 05          	sar    $0x5,%rbp
	for (int i = 0; i < log_backend_count_get(); i++) {
    718c:	41 39 ec             	cmp    %ebp,%r12d
    718f:	7d 1c                	jge    71ad <z_impl_log_panic+0x4b>
	return backend->cb->active;
    7191:	48 8b 43 08          	mov    0x8(%rbx),%rax
		if (log_backend_is_active(backend)) {
    7195:	80 78 09 00          	cmpb   $0x0,0x9(%rax)
    7199:	74 09                	je     71a4 <z_impl_log_panic+0x42>
	backend->api->panic(backend);
    719b:	48 8b 03             	mov    (%rbx),%rax
    719e:	48 89 df             	mov    %rbx,%rdi
    71a1:	ff 50 20             	callq  *0x20(%rax)
	for (int i = 0; i < log_backend_count_get(); i++) {
    71a4:	41 ff c4             	inc    %r12d
    71a7:	48 83 c3 20          	add    $0x20,%rbx
    71ab:	eb df                	jmp    718c <z_impl_log_panic+0x2a>
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
    71ad:	31 ff                	xor    %edi,%edi
    71af:	e8 01 fe ff ff       	callq  6fb5 <z_impl_log_process>
		while (log_process(false) == true) {
    71b4:	84 c0                	test   %al,%al
    71b6:	75 f5                	jne    71ad <z_impl_log_panic+0x4b>
}
    71b8:	5b                   	pop    %rbx
	panic_mode = true;
    71b9:	c6 05 22 7f 25 00 01 	movb   $0x1,0x257f22(%rip)        # 25f0e2 <panic_mode>
}
    71c0:	5d                   	pop    %rbp
    71c1:	41 5c                	pop    %r12
    71c3:	c3                   	retq   
    71c4:	c3                   	retq   

00000000000071c5 <log_process_thread_func>:
{
    71c5:	53                   	push   %rbx
	log_init();
    71c6:	e8 e1 fc ff ff       	callq  6eac <log_init>
	return z_impl_k_current_get();
    71cb:	31 c0                	xor    %eax,%eax
    71cd:	e8 2e 4d 02 00       	callq  2bf00 <z_impl_k_current_get>
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
    71d2:	48 85 c0             	test   %rax,%rax
	proc_tid = process_tid;
    71d5:	48 89 05 ec 0c 25 00 	mov    %rax,0x250cec(%rip)        # 257ec8 <proc_tid>
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
    71dc:	74 15                	je     71f3 <log_process_thread_func+0x2e>
	    process_tid &&
    71de:	83 3d 73 4e 25 00 09 	cmpl   $0x9,0x254e73(%rip)        # 25c058 <buffered_cnt>
    71e5:	7e 0c                	jle    71f3 <log_process_thread_func+0x2e>
	z_impl_k_sem_give(sem);
    71e7:	48 8d 3d ba 34 23 00 	lea    0x2334ba(%rip),%rdi        # 23a6a8 <_k_msgq_list_end>
    71ee:	e8 43 4d 02 00       	callq  2bf36 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
    71f3:	48 83 cb ff          	or     $0xffffffffffffffff,%rbx
    71f7:	31 ff                	xor    %edi,%edi
    71f9:	e8 b7 fd ff ff       	callq  6fb5 <z_impl_log_process>
		if (log_process(false) == false) {
    71fe:	84 c0                	test   %al,%al
    7200:	75 f5                	jne    71f7 <log_process_thread_func+0x32>
    7202:	48 8d 3d 9f 34 23 00 	lea    0x23349f(%rip),%rdi        # 23a6a8 <_k_msgq_list_end>
    7209:	48 89 de             	mov    %rbx,%rsi
    720c:	e8 82 4d 02 00       	callq  2bf93 <z_impl_k_sem_take>
    7211:	eb e4                	jmp    71f7 <log_process_thread_func+0x32>

0000000000007213 <msg_finalize>:
{
    7213:	55                   	push   %rbp
    7214:	53                   	push   %rbx
    7215:	48 89 fb             	mov    %rdi,%rbx
    7218:	48 83 ec 08          	sub    $0x8,%rsp
	msg->hdr.ids = src_level;
    721c:	66 89 77 0e          	mov    %si,0xe(%rdi)
	msg->hdr.timestamp = timestamp_func();
    7220:	ff 15 2a f8 22 00    	callq  *0x22f82a(%rip)        # 236a50 <timestamp_func>
    7226:	89 43 10             	mov    %eax,0x10(%rbx)
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    7229:	f0 ff 05 28 4e 25 00 	lock incl 0x254e28(%rip)        # 25c058 <buffered_cnt>
	return posix_irq_lock();
    7230:	e8 5d 4d 00 00       	callq  bf92 <posix_irq_lock>
	log_list_add_tail(&list, msg);
    7235:	48 8d 3d 54 0a 25 00 	lea    0x250a54(%rip),%rdi        # 257c90 <list>
    723c:	89 c5                	mov    %eax,%ebp
    723e:	48 89 de             	mov    %rbx,%rsi
    7241:	e8 f7 f9 ff ff       	callq  6c3d <log_list_add_tail>
	posix_irq_unlock(key);
    7246:	89 ef                	mov    %ebp,%edi
    7248:	e8 4f 4d 00 00       	callq  bf9c <posix_irq_unlock>
	if (panic_mode) {
    724d:	80 3d 8e 7e 25 00 00 	cmpb   $0x0,0x257e8e(%rip)        # 25f0e2 <panic_mode>
    7254:	74 18                	je     726e <msg_finalize+0x5b>
	return posix_irq_lock();
    7256:	e8 37 4d 00 00       	callq  bf92 <posix_irq_lock>
    725b:	89 c3                	mov    %eax,%ebx
    725d:	31 ff                	xor    %edi,%edi
    725f:	e8 51 fd ff ff       	callq  6fb5 <z_impl_log_process>
}
    7264:	5e                   	pop    %rsi
	posix_irq_unlock(key);
    7265:	89 df                	mov    %ebx,%edi
    7267:	5b                   	pop    %rbx
    7268:	5d                   	pop    %rbp
    7269:	e9 2e 4d 00 00       	jmpq   bf9c <posix_irq_unlock>
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    726e:	48 8b 15 53 0c 25 00 	mov    0x250c53(%rip),%rdx        # 257ec8 <proc_tid>
    7275:	8b 05 dd 4d 25 00    	mov    0x254ddd(%rip),%eax        # 25c058 <buffered_cnt>
    727b:	48 85 d2             	test   %rdx,%rdx
    727e:	74 1b                	je     729b <msg_finalize+0x88>
    7280:	83 f8 01             	cmp    $0x1,%eax
    7283:	75 16                	jne    729b <msg_finalize+0x88>
}
    7285:	59                   	pop    %rcx
    7286:	5b                   	pop    %rbx
    7287:	5d                   	pop    %rbp
	z_impl_k_timer_start(timer, duration, period);
    7288:	48 8d 3d b1 38 23 00 	lea    0x2338b1(%rip),%rdi        # 23ab40 <log_process_thread_timer>
    728f:	31 d2                	xor    %edx,%edx
    7291:	be 64 00 00 00       	mov    $0x64,%esi
    7296:	e9 ec 55 02 00       	jmpq   2c887 <z_impl_k_timer_start>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    729b:	48 85 d2             	test   %rdx,%rdx
    729e:	74 20                	je     72c0 <msg_finalize+0xad>
    72a0:	83 f8 0a             	cmp    $0xa,%eax
    72a3:	75 1b                	jne    72c0 <msg_finalize+0xad>
	z_impl_k_timer_stop(timer);
    72a5:	48 8d 3d 94 38 23 00 	lea    0x233894(%rip),%rdi        # 23ab40 <log_process_thread_timer>
    72ac:	e8 4b 56 02 00       	callq  2c8fc <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
    72b1:	48 8d 3d f0 33 23 00 	lea    0x2333f0(%rip),%rdi        # 23a6a8 <_k_msgq_list_end>
}
    72b8:	5a                   	pop    %rdx
    72b9:	5b                   	pop    %rbx
    72ba:	5d                   	pop    %rbp
    72bb:	e9 76 4c 02 00       	jmpq   2bf36 <z_impl_k_sem_give>
    72c0:	58                   	pop    %rax
    72c1:	5b                   	pop    %rbx
    72c2:	5d                   	pop    %rbp
    72c3:	c3                   	retq   

00000000000072c4 <log_0>:
{
    72c4:	53                   	push   %rbx
    72c5:	48 89 fb             	mov    %rdi,%rbx
    72c8:	48 83 ec 10          	sub    $0x10,%rsp
    72cc:	89 74 24 0c          	mov    %esi,0xc(%rsp)
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
    72d0:	e8 9c f9 ff ff       	callq  6c71 <z_log_msg_std_alloc>

	if (msg != NULL) {
    72d5:	48 85 c0             	test   %rax,%rax
    72d8:	74 15                	je     72ef <log_0+0x2b>
		msg->str = str;
    72da:	48 89 58 18          	mov    %rbx,0x18(%rax)
		msg_finalize(msg, src_level);
    72de:	8b 74 24 0c          	mov    0xc(%rsp),%esi
}
    72e2:	48 83 c4 10          	add    $0x10,%rsp
    72e6:	5b                   	pop    %rbx
		msg_finalize(msg, src_level);
    72e7:	48 89 c7             	mov    %rax,%rdi
    72ea:	e9 24 ff ff ff       	jmpq   7213 <msg_finalize>
}
    72ef:	48 83 c4 10          	add    $0x10,%rsp
    72f3:	5b                   	pop    %rbx
    72f4:	c3                   	retq   

00000000000072f5 <log_1>:
{
    72f5:	41 54                	push   %r12
    72f7:	55                   	push   %rbp
    72f8:	49 89 fc             	mov    %rdi,%r12
    72fb:	53                   	push   %rbx
    72fc:	48 89 f5             	mov    %rsi,%rbp
    72ff:	89 d3                	mov    %edx,%ebx
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
    7301:	e8 6b f9 ff ff       	callq  6c71 <z_log_msg_std_alloc>

	if (msg != NULL) {
    7306:	48 85 c0             	test   %rax,%rax
    7309:	74 22                	je     732d <log_1+0x38>
		msg->str = str;
		msg->hdr.params.std.nargs = 1U;
    730b:	8a 48 0d             	mov    0xd(%rax),%cl
		msg->str = str;
    730e:	4c 89 60 18          	mov    %r12,0x18(%rax)
		msg_finalize(msg, src_level);
    7312:	89 de                	mov    %ebx,%esi
		msg->payload.single.args[0] = arg1;
    7314:	48 89 68 20          	mov    %rbp,0x20(%rax)
    7318:	48 89 c7             	mov    %rax,%rdi
		msg->hdr.params.std.nargs = 1U;
    731b:	83 e1 0f             	and    $0xf,%ecx
    731e:	83 c9 10             	or     $0x10,%ecx
    7321:	88 48 0d             	mov    %cl,0xd(%rax)
}
    7324:	5b                   	pop    %rbx
    7325:	5d                   	pop    %rbp
    7326:	41 5c                	pop    %r12
		msg_finalize(msg, src_level);
    7328:	e9 e6 fe ff ff       	jmpq   7213 <msg_finalize>
}
    732d:	5b                   	pop    %rbx
    732e:	5d                   	pop    %rbp
    732f:	41 5c                	pop    %r12
    7331:	c3                   	retq   

0000000000007332 <log_2>:
{
    7332:	41 55                	push   %r13
    7334:	41 54                	push   %r12
    7336:	49 89 fd             	mov    %rdi,%r13
    7339:	55                   	push   %rbp
    733a:	53                   	push   %rbx
    733b:	49 89 f4             	mov    %rsi,%r12
    733e:	48 89 d5             	mov    %rdx,%rbp
    7341:	89 cb                	mov    %ecx,%ebx
    7343:	48 83 ec 08          	sub    $0x8,%rsp
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
    7347:	e8 25 f9 ff ff       	callq  6c71 <z_log_msg_std_alloc>

	if (msg != NULL) {
    734c:	48 85 c0             	test   %rax,%rax
    734f:	74 2b                	je     737c <log_2+0x4a>
		msg->str = str;
		msg->hdr.params.std.nargs = 2U;
    7351:	40 8a 78 0d          	mov    0xd(%rax),%dil
		msg->str = str;
    7355:	4c 89 68 18          	mov    %r13,0x18(%rax)
		msg_finalize(msg, src_level);
    7359:	89 de                	mov    %ebx,%esi
		msg->payload.single.args[0] = arg1;
    735b:	4c 89 60 20          	mov    %r12,0x20(%rax)
		msg->payload.single.args[1] = arg2;
    735f:	48 89 68 28          	mov    %rbp,0x28(%rax)
		msg->hdr.params.std.nargs = 2U;
    7363:	83 e7 0f             	and    $0xf,%edi
    7366:	83 cf 20             	or     $0x20,%edi
    7369:	40 88 78 0d          	mov    %dil,0xd(%rax)
    736d:	48 89 c7             	mov    %rax,%rdi
}
    7370:	5a                   	pop    %rdx
    7371:	5b                   	pop    %rbx
    7372:	5d                   	pop    %rbp
    7373:	41 5c                	pop    %r12
    7375:	41 5d                	pop    %r13
		msg_finalize(msg, src_level);
    7377:	e9 97 fe ff ff       	jmpq   7213 <msg_finalize>
}
    737c:	58                   	pop    %rax
    737d:	5b                   	pop    %rbx
    737e:	5d                   	pop    %rbp
    737f:	41 5c                	pop    %r12
    7381:	41 5d                	pop    %r13
    7383:	c3                   	retq   

0000000000007384 <log_3>:
{
    7384:	41 55                	push   %r13
    7386:	41 54                	push   %r12
    7388:	49 89 fd             	mov    %rdi,%r13
    738b:	55                   	push   %rbp
    738c:	53                   	push   %rbx
    738d:	49 89 f4             	mov    %rsi,%r12
    7390:	48 89 d5             	mov    %rdx,%rbp
    7393:	48 89 cb             	mov    %rcx,%rbx
    7396:	48 83 ec 18          	sub    $0x18,%rsp
    739a:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
    739f:	e8 cd f8 ff ff       	callq  6c71 <z_log_msg_std_alloc>

	if (msg != NULL) {
    73a4:	48 85 c0             	test   %rax,%rax
    73a7:	74 38                	je     73e1 <log_3+0x5d>
		msg->str = str;
		msg->hdr.params.std.nargs = 3U;
    73a9:	40 8a 78 0d          	mov    0xd(%rax),%dil
		msg->str = str;
    73ad:	4c 89 68 18          	mov    %r13,0x18(%rax)
		msg->payload.single.args[0] = arg1;
    73b1:	4c 89 60 20          	mov    %r12,0x20(%rax)
		msg->payload.single.args[1] = arg2;
    73b5:	48 89 68 28          	mov    %rbp,0x28(%rax)
		msg->payload.single.args[2] = arg3;
    73b9:	48 89 58 30          	mov    %rbx,0x30(%rax)
		msg->hdr.params.std.nargs = 3U;
    73bd:	83 e7 0f             	and    $0xf,%edi
    73c0:	83 cf 30             	or     $0x30,%edi
    73c3:	40 88 78 0d          	mov    %dil,0xd(%rax)
		msg_finalize(msg, src_level);
    73c7:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
}
    73cc:	48 83 c4 18          	add    $0x18,%rsp
    73d0:	5b                   	pop    %rbx
    73d1:	5d                   	pop    %rbp
    73d2:	41 5c                	pop    %r12
    73d4:	41 5d                	pop    %r13
		msg_finalize(msg, src_level);
    73d6:	44 89 c6             	mov    %r8d,%esi
    73d9:	48 89 c7             	mov    %rax,%rdi
    73dc:	e9 32 fe ff ff       	jmpq   7213 <msg_finalize>
}
    73e1:	48 83 c4 18          	add    $0x18,%rsp
    73e5:	5b                   	pop    %rbx
    73e6:	5d                   	pop    %rbp
    73e7:	41 5c                	pop    %r12
    73e9:	41 5d                	pop    %r13
    73eb:	c3                   	retq   

00000000000073ec <log_n>:
{
    73ec:	53                   	push   %rbx
    73ed:	89 cb                	mov    %ecx,%ebx
		struct log_msg *msg = log_msg_create_n(str, args, narg);
    73ef:	e8 9a 03 00 00       	callq  778e <log_msg_create_n>
		if (msg == NULL) {
    73f4:	48 85 c0             	test   %rax,%rax
    73f7:	74 0b                	je     7404 <log_n+0x18>
		msg_finalize(msg, src_level);
    73f9:	89 de                	mov    %ebx,%esi
    73fb:	48 89 c7             	mov    %rax,%rdi
}
    73fe:	5b                   	pop    %rbx
		msg_finalize(msg, src_level);
    73ff:	e9 0f fe ff ff       	jmpq   7213 <msg_finalize>
}
    7404:	5b                   	pop    %rbx
    7405:	c3                   	retq   

0000000000007406 <log_free>:
{
    7406:	48 83 ec 18          	sub    $0x18,%rsp
    740a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    7411:	00 00 
    7413:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    7418:	31 c0                	xor    %eax,%eax
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
    741a:	48 8d 47 fc          	lea    -0x4(%rdi),%rax
    741e:	48 89 04 24          	mov    %rax,(%rsp)
	if (atomic_dec(&dup->refcount) == 1) {
    7422:	f0 ff 4f fc          	lock decl -0x4(%rdi)
    7426:	75 0f                	jne    7437 <log_free+0x31>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
    7428:	48 8d 3d 71 37 23 00 	lea    0x233771(%rip),%rdi        # 23aba0 <log_strdup_pool>
    742f:	48 89 e6             	mov    %rsp,%rsi
    7432:	e8 64 39 02 00       	callq  2ad9b <k_mem_slab_free>
}
    7437:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    743c:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    7443:	00 00 
    7445:	74 05                	je     744c <log_free+0x46>
    7447:	e8 f4 d1 ff ff       	callq  4640 <__stack_chk_fail@plt>
    744c:	48 83 c4 18          	add    $0x18,%rsp
    7450:	c3                   	retq   

0000000000007451 <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    uint8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
    7451:	48 89 c8             	mov    %rcx,%rax
	uint32_t available_len = msg->hdr.params.hexdump.length;
    7454:	8b 4f 0c             	mov    0xc(%rdi),%ecx
{
    7457:	49 89 f1             	mov    %rsi,%r9
	uint32_t available_len = msg->hdr.params.hexdump.length;
    745a:	66 c1 e9 02          	shr    $0x2,%cx
	uint8_t *head_data;
	uint32_t chunk_len;
	uint32_t req_len;
	uint32_t cpy_len;

	if (offset >= available_len) {
    745e:	0f b7 f1             	movzwl %cx,%esi
    7461:	48 39 c6             	cmp    %rax,%rsi
    7464:	77 08                	ja     746e <log_msg_hexdump_data_op+0x1d>
		*length = 0;
    7466:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
    746d:	c3                   	retq   
{
    746e:	41 54                	push   %r12
    7470:	55                   	push   %rbp
    7471:	44 88 c5             	mov    %r8b,%bpl
    7474:	53                   	push   %rbx
		return;
	}

	if ((offset + *length) > available_len) {
    7475:	4c 8b 12             	mov    (%rdx),%r10
    7478:	49 01 c2             	add    %rax,%r10
    747b:	4c 39 d6             	cmp    %r10,%rsi
    747e:	73 06                	jae    7486 <log_msg_hexdump_data_op+0x35>
		*length = available_len - offset;
    7480:	48 29 c6             	sub    %rax,%rsi
    7483:	48 89 32             	mov    %rsi,(%rdx)
	}

	req_len = *length;
    7486:	4c 8b 22             	mov    (%rdx),%r12
	uint32_t available_len = msg->hdr.params.hexdump.length;
    7489:	0f b7 c9             	movzwl %cx,%ecx

	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
    748c:	83 f9 20             	cmp    $0x20,%ecx
	req_len = *length;
    748f:	44 89 e2             	mov    %r12d,%edx
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
    7492:	76 0f                	jbe    74a3 <log_msg_hexdump_data_op+0x52>
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
		head_data = msg->payload.ext.data.bytes;
    7494:	4c 8d 5f 28          	lea    0x28(%rdi),%r11
		cont = msg->payload.ext.next;
    7498:	4c 8b 57 20          	mov    0x20(%rdi),%r10
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
    749c:	b9 18 00 00 00       	mov    $0x18,%ecx
    74a1:	eb 07                	jmp    74aa <log_msg_hexdump_data_op+0x59>
	} else {
		head_data = msg->payload.single.bytes;
    74a3:	4c 8d 5f 20          	lea    0x20(%rdi),%r11
	struct log_msg_cont *cont = NULL;
    74a7:	45 31 d2             	xor    %r10d,%r10d
		chunk_len = available_len;

	}

	if (offset < chunk_len) {
    74aa:	89 ce                	mov    %ecx,%esi
    74ac:	48 39 c6             	cmp    %rax,%rsi
    74af:	76 37                	jbe    74e8 <log_msg_hexdump_data_op+0x97>
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
    74b1:	44 39 e1             	cmp    %r12d,%ecx
    74b4:	89 ca                	mov    %ecx,%edx
    74b6:	41 0f 47 d4          	cmova  %r12d,%edx
    74ba:	49 01 c3             	add    %rax,%r11

		if (put_op) {
    74bd:	45 84 c0             	test   %r8b,%r8b
    74c0:	89 d3                	mov    %edx,%ebx
    74c2:	74 08                	je     74cc <log_msg_hexdump_data_op+0x7b>
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    74c4:	4c 89 df             	mov    %r11,%rdi
    74c7:	4c 89 ce             	mov    %r9,%rsi
    74ca:	eb 06                	jmp    74d2 <log_msg_hexdump_data_op+0x81>
    74cc:	4c 89 cf             	mov    %r9,%rdi
    74cf:	4c 89 de             	mov    %r11,%rsi
    74d2:	48 89 d9             	mov    %rbx,%rcx
		} else {
			(void)memcpy(data, &head_data[offset], cpy_len);
		}

		req_len -= cpy_len;
		data += cpy_len;
    74d5:	49 01 d9             	add    %rbx,%r9
    74d8:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		req_len -= cpy_len;
    74da:	44 89 e7             	mov    %r12d,%edi
    74dd:	29 d7                	sub    %edx,%edi
    74df:	89 fa                	mov    %edi,%edx
			offset -= chunk_len;
		}
	}

	while ((req_len > 0) && (cont != NULL)) {
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
    74e1:	bb 38 00 00 00       	mov    $0x38,%ebx
    74e6:	eb 50                	jmp    7538 <log_msg_hexdump_data_op+0xe7>
		offset -= chunk_len;
    74e8:	48 29 f0             	sub    %rsi,%rax
		if (cont == NULL) {
    74eb:	4d 85 d2             	test   %r10,%r10
    74ee:	75 04                	jne    74f4 <log_msg_hexdump_data_op+0xa3>
			cont = msg->payload.ext.next;
    74f0:	4c 8b 57 20          	mov    0x20(%rdi),%r10
		while (offset >= chunk_len) {
    74f4:	48 83 f8 37          	cmp    $0x37,%rax
    74f8:	76 e7                	jbe    74e1 <log_msg_hexdump_data_op+0x90>
			cont = cont->next;
    74fa:	4d 8b 12             	mov    (%r10),%r10
			offset -= chunk_len;
    74fd:	48 83 e8 38          	sub    $0x38,%rax
    7501:	eb f1                	jmp    74f4 <log_msg_hexdump_data_op+0xa3>
	while ((req_len > 0) && (cont != NULL)) {
    7503:	4d 85 d2             	test   %r10,%r10
    7506:	74 3e                	je     7546 <log_msg_hexdump_data_op+0xf5>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
    7508:	41 89 d8             	mov    %ebx,%r8d
    750b:	4d 8d 5c 02 08       	lea    0x8(%r10,%rax,1),%r11
    7510:	41 29 c0             	sub    %eax,%r8d
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
    7513:	41 39 d0             	cmp    %edx,%r8d
    7516:	44 0f 47 c2          	cmova  %edx,%r8d

		if (put_op) {
    751a:	40 84 ed             	test   %bpl,%bpl
    751d:	44 89 c0             	mov    %r8d,%eax
    7520:	74 1c                	je     753e <log_msg_hexdump_data_op+0xed>
    7522:	4c 89 df             	mov    %r11,%rdi
    7525:	4c 89 ce             	mov    %r9,%rsi
    7528:	48 89 c1             	mov    %rax,%rcx
		}

		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
    752b:	49 01 c1             	add    %rax,%r9
		req_len -= cpy_len;
    752e:	44 29 c2             	sub    %r8d,%edx
    7531:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		offset = 0;
    7533:	31 c0                	xor    %eax,%eax
		cont = cont->next;
    7535:	4d 8b 12             	mov    (%r10),%r10
	while ((req_len > 0) && (cont != NULL)) {
    7538:	85 d2                	test   %edx,%edx
    753a:	75 c7                	jne    7503 <log_msg_hexdump_data_op+0xb2>
    753c:	eb 08                	jmp    7546 <log_msg_hexdump_data_op+0xf5>
    753e:	4c 89 cf             	mov    %r9,%rdi
    7541:	4c 89 de             	mov    %r11,%rsi
    7544:	eb e2                	jmp    7528 <log_msg_hexdump_data_op+0xd7>
	}
}
    7546:	5b                   	pop    %rbx
    7547:	5d                   	pop    %rbp
    7548:	41 5c                	pop    %r12
    754a:	c3                   	retq   

000000000000754b <log_msg_pool_init>:
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
    754b:	48 8d 3d 8e 36 23 00 	lea    0x23368e(%rip),%rdi        # 23abe0 <log_msg_pool>
    7552:	48 8d 35 67 f9 22 00 	lea    0x22f967(%rip),%rsi        # 236ec0 <log_msg_pool_buf>
    7559:	b9 10 00 00 00       	mov    $0x10,%ecx
    755e:	ba 40 00 00 00       	mov    $0x40,%edx
    7563:	e9 64 37 02 00       	jmpq   2accc <k_mem_slab_init>

0000000000007568 <log_msg_get>:
    7568:	f0 ff 47 08          	lock incl 0x8(%rdi)
}
    756c:	c3                   	retq   

000000000000756d <log_msg_no_space_handle>:
{
    756d:	55                   	push   %rbp
    756e:	53                   	push   %rbx
    756f:	48 83 ec 18          	sub    $0x18,%rsp
    7573:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    757a:	00 00 
    757c:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    7581:	31 c0                	xor    %eax,%eax
	union log_msg_chunk *msg = NULL;
    7583:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
    758a:	00 
			err = k_mem_slab_alloc(&log_msg_pool,
    758b:	48 89 e5             	mov    %rsp,%rbp
    758e:	bf 01 00 00 00       	mov    $0x1,%edi
    7593:	e8 1d fa ff ff       	callq  6fb5 <z_impl_log_process>
    7598:	88 c3                	mov    %al,%bl
			log_dropped();
    759a:	e8 93 f8 ff ff       	callq  6e32 <log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
    759f:	48 8d 3d 3a 36 23 00 	lea    0x23363a(%rip),%rdi        # 23abe0 <log_msg_pool>
    75a6:	31 d2                	xor    %edx,%edx
    75a8:	48 89 ee             	mov    %rbp,%rsi
    75ab:	e8 69 37 02 00       	callq  2ad19 <k_mem_slab_alloc>
		} while ((err != 0) && more);
    75b0:	85 c0                	test   %eax,%eax
    75b2:	74 04                	je     75b8 <log_msg_no_space_handle+0x4b>
    75b4:	84 db                	test   %bl,%bl
    75b6:	75 d6                	jne    758e <log_msg_no_space_handle+0x21>
}
    75b8:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    75bd:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    75c4:	00 00 
    75c6:	48 8b 04 24          	mov    (%rsp),%rax
    75ca:	74 05                	je     75d1 <log_msg_no_space_handle+0x64>
    75cc:	e8 6f d0 ff ff       	callq  4640 <__stack_chk_fail@plt>
    75d1:	48 83 c4 18          	add    $0x18,%rsp
    75d5:	5b                   	pop    %rbx
    75d6:	5d                   	pop    %rbp
    75d7:	c3                   	retq   

00000000000075d8 <log_msg_chunk_alloc>:
{
    75d8:	48 83 ec 18          	sub    $0x18,%rsp
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    75dc:	48 8d 3d fd 35 23 00 	lea    0x2335fd(%rip),%rdi        # 23abe0 <log_msg_pool>
    75e3:	31 d2                	xor    %edx,%edx
    75e5:	48 89 e6             	mov    %rsp,%rsi
	union log_msg_chunk *msg = NULL;
    75e8:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
    75ef:	00 
{
    75f0:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    75f7:	00 00 
    75f9:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    75fe:	31 c0                	xor    %eax,%eax
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    7600:	e8 14 37 02 00       	callq  2ad19 <k_mem_slab_alloc>
	if (err != 0) {
    7605:	85 c0                	test   %eax,%eax
    7607:	74 09                	je     7612 <log_msg_chunk_alloc+0x3a>
		msg = log_msg_no_space_handle();
    7609:	e8 5f ff ff ff       	callq  756d <log_msg_no_space_handle>
    760e:	48 89 04 24          	mov    %rax,(%rsp)
}
    7612:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    7617:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    761e:	00 00 
    7620:	48 8b 04 24          	mov    (%rsp),%rax
    7624:	74 05                	je     762b <log_msg_chunk_alloc+0x53>
    7626:	e8 15 d0 ff ff       	callq  4640 <__stack_chk_fail@plt>
    762b:	48 83 c4 18          	add    $0x18,%rsp
    762f:	c3                   	retq   

0000000000007630 <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
    7630:	8a 47 0d             	mov    0xd(%rdi),%al
    7633:	c0 e8 04             	shr    $0x4,%al
    7636:	0f b6 c0             	movzbl %al,%eax
}
    7639:	c3                   	retq   

000000000000763a <log_msg_arg_get>:
	if (arg_idx >= msg->hdr.params.std.nargs) {
    763a:	8a 57 0d             	mov    0xd(%rdi),%dl
		return 0;
    763d:	31 c0                	xor    %eax,%eax
	if (arg_idx >= msg->hdr.params.std.nargs) {
    763f:	c0 ea 04             	shr    $0x4,%dl
    7642:	0f b6 ca             	movzbl %dl,%ecx
    7645:	39 f1                	cmp    %esi,%ecx
    7647:	76 33                	jbe    767c <log_msg_arg_get+0x42>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
    7649:	80 fa 04             	cmp    $0x4,%dl
    764c:	77 08                	ja     7656 <log_msg_arg_get+0x1c>
		arg = msg->payload.single.args[arg_idx];
    764e:	89 f6                	mov    %esi,%esi
    7650:	48 8b 44 f7 20       	mov    0x20(%rdi,%rsi,8),%rax
    7655:	c3                   	retq   
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
    7656:	83 fe 02             	cmp    $0x2,%esi
    7659:	77 08                	ja     7663 <log_msg_arg_get+0x29>
		return msg->payload.ext.data.args[arg_idx];
    765b:	89 f6                	mov    %esi,%esi
    765d:	48 8b 44 f7 28       	mov    0x28(%rdi,%rsi,8),%rax
    7662:	c3                   	retq   
	cont = msg->payload.ext.next;
    7663:	48 8b 47 20          	mov    0x20(%rdi),%rax
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
    7667:	83 ee 03             	sub    $0x3,%esi
	while (arg_idx >= ARGS_CONT_MSG) {
    766a:	83 fe 06             	cmp    $0x6,%esi
    766d:	76 08                	jbe    7677 <log_msg_arg_get+0x3d>
		arg_idx -= ARGS_CONT_MSG;
    766f:	83 ee 07             	sub    $0x7,%esi
		cont = cont->next;
    7672:	48 8b 00             	mov    (%rax),%rax
    7675:	eb f3                	jmp    766a <log_msg_arg_get+0x30>
	return cont->payload.args[arg_idx];
    7677:	48 8b 44 f0 08       	mov    0x8(%rax,%rsi,8),%rax
}
    767c:	c3                   	retq   

000000000000767d <log_msg_str_get>:
	return msg->str;
    767d:	48 8b 47 18          	mov    0x18(%rdi),%rax
}
    7681:	c3                   	retq   

0000000000007682 <msg_free>:
{
    7682:	41 55                	push   %r13
    7684:	41 54                	push   %r12
    7686:	55                   	push   %rbp
    7687:	53                   	push   %rbx
    7688:	48 83 ec 28          	sub    $0x28,%rsp
    768c:	64 48 8b 14 25 28 00 	mov    %fs:0x28,%rdx
    7693:	00 00 
    7695:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
    769a:	31 d2                	xor    %edx,%edx
    769c:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	uint32_t nargs = log_msg_nargs_get(msg);
    76a1:	e8 8a ff ff ff       	callq  7630 <log_msg_nargs_get>
    76a6:	41 89 c4             	mov    %eax,%r12d
	if (log_msg_is_std(msg) && nargs) {
    76a9:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    76ae:	f6 40 0c 01          	testb  $0x1,0xc(%rax)
    76b2:	75 05                	jne    76b9 <msg_free+0x37>
    76b4:	45 85 e4             	test   %r12d,%r12d
    76b7:	75 14                	jne    76cd <msg_free+0x4b>
	if (msg->hdr.params.generic.ext == 1) {
    76b9:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    76be:	48 8d 1d 1b 35 23 00 	lea    0x23351b(%rip),%rbx        # 23abe0 <log_msg_pool>
    76c5:	f6 40 0c 02          	testb  $0x2,0xc(%rax)
    76c9:	74 59                	je     7724 <msg_free+0xa2>
    76cb:	eb 79                	jmp    7746 <msg_free+0xc4>
		uint32_t smask = 0;
    76cd:	31 ed                	xor    %ebp,%ebp
		for (i = 0; i < nargs; i++) {
    76cf:	31 db                	xor    %ebx,%ebx
    76d1:	44 39 e3             	cmp    %r12d,%ebx
    76d4:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    76d9:	74 de                	je     76b9 <msg_free+0x37>
			void *buf = (void *)log_msg_arg_get(msg, i);
    76db:	89 de                	mov    %ebx,%esi
    76dd:	e8 58 ff ff ff       	callq  763a <log_msg_arg_get>
			if (log_is_strdup(buf)) {
    76e2:	48 89 c7             	mov    %rax,%rdi
			void *buf = (void *)log_msg_arg_get(msg, i);
    76e5:	49 89 c5             	mov    %rax,%r13
			if (log_is_strdup(buf)) {
    76e8:	e8 a3 f8 ff ff       	callq  6f90 <log_is_strdup>
    76ed:	84 c0                	test   %al,%al
    76ef:	74 2f                	je     7720 <msg_free+0x9e>
				if (smask == 0) {
    76f1:	85 ed                	test   %ebp,%ebp
    76f3:	75 1b                	jne    7710 <msg_free+0x8e>
					smask = z_log_get_s_mask(
    76f5:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    76fa:	e8 7e ff ff ff       	callq  767d <log_msg_str_get>
    76ff:	44 89 e6             	mov    %r12d,%esi
    7702:	48 89 c7             	mov    %rax,%rdi
    7705:	e8 f6 f5 ff ff       	callq  6d00 <z_log_get_s_mask>
					if (smask == 0) {
    770a:	85 c0                	test   %eax,%eax
					smask = z_log_get_s_mask(
    770c:	89 c5                	mov    %eax,%ebp
					if (smask == 0) {
    770e:	74 a9                	je     76b9 <msg_free+0x37>
				if (smask & BIT(i)) {
    7710:	89 e8                	mov    %ebp,%eax
    7712:	48 0f a3 d8          	bt     %rbx,%rax
    7716:	73 08                	jae    7720 <msg_free+0x9e>
					log_free(buf);
    7718:	4c 89 ef             	mov    %r13,%rdi
    771b:	e8 e6 fc ff ff       	callq  7406 <log_free>
		for (i = 0; i < nargs; i++) {
    7720:	ff c3                	inc    %ebx
    7722:	eb ad                	jmp    76d1 <msg_free+0x4f>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
    7724:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    7729:	48 89 df             	mov    %rbx,%rdi
    772c:	e8 6a 36 02 00       	callq  2ad9b <k_mem_slab_free>
}
    7731:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    7736:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    773d:	00 00 
    773f:	74 32                	je     7773 <msg_free+0xf1>
    7741:	e8 fa ce ff ff       	callq  4640 <__stack_chk_fail@plt>
    7746:	48 8b 40 20          	mov    0x20(%rax),%rax
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    774a:	48 8d 6c 24 10       	lea    0x10(%rsp),%rbp
    774f:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
	while (cont != NULL) {
    7754:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
    7759:	48 85 c0             	test   %rax,%rax
    775c:	74 c6                	je     7724 <msg_free+0xa2>
		next = cont->next;
    775e:	4c 8b 20             	mov    (%rax),%r12
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    7761:	48 89 ee             	mov    %rbp,%rsi
    7764:	48 89 df             	mov    %rbx,%rdi
    7767:	e8 2f 36 02 00       	callq  2ad9b <k_mem_slab_free>
		cont = next;
    776c:	4c 89 64 24 10       	mov    %r12,0x10(%rsp)
    7771:	eb e1                	jmp    7754 <msg_free+0xd2>
}
    7773:	48 83 c4 28          	add    $0x28,%rsp
    7777:	5b                   	pop    %rbx
    7778:	5d                   	pop    %rbp
    7779:	41 5c                	pop    %r12
    777b:	41 5d                	pop    %r13
    777d:	c3                   	retq   

000000000000777e <log_msg_put>:
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    777e:	f0 ff 4f 08          	lock decl 0x8(%rdi)
	if (msg->hdr.ref_cnt == 0) {
    7782:	83 7f 08 00          	cmpl   $0x0,0x8(%rdi)
    7786:	75 05                	jne    778d <log_msg_put+0xf>
		msg_free(msg);
    7788:	e9 f5 fe ff ff       	jmpq   7682 <msg_free>
}
    778d:	c3                   	retq   

000000000000778e <log_msg_create_n>:
{
    778e:	41 57                	push   %r15
    7790:	41 56                	push   %r14
    7792:	49 89 fe             	mov    %rdi,%r14
    7795:	41 55                	push   %r13
    7797:	41 54                	push   %r12
    7799:	49 89 f4             	mov    %rsi,%r12
    779c:	55                   	push   %rbp
    779d:	53                   	push   %rbx
    779e:	89 d5                	mov    %edx,%ebp
    77a0:	48 83 ec 08          	sub    $0x8,%rsp
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    77a4:	e8 2f fe ff ff       	callq  75d8 <log_msg_chunk_alloc>
	if (msg != NULL) {
    77a9:	48 85 c0             	test   %rax,%rax
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    77ac:	48 89 c3             	mov    %rax,%rbx
	if (msg != NULL) {
    77af:	74 0d                	je     77be <log_msg_create_n+0x30>
		msg->hdr.ref_cnt = 1;
    77b1:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%rax)
    77b8:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%rax)
	if ((msg == NULL) || nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
    77be:	48 85 db             	test   %rbx,%rbx
    77c1:	74 4e                	je     7811 <log_msg_create_n+0x83>
    77c3:	83 fd 04             	cmp    $0x4,%ebp
    77c6:	76 49                	jbe    7811 <log_msg_create_n+0x83>
	msg->hdr.params.std.nargs = 0U;
    77c8:	80 63 0d 0f          	andb   $0xf,0xd(%rbx)
	msg->hdr.params.generic.ext = 1;
    77cc:	80 4b 0c 02          	orb    $0x2,0xc(%rbx)
	n -= LOG_MSG_NARGS_HEAD_CHUNK;
    77d0:	44 8d 6d fd          	lea    -0x3(%rbp),%r13d
	next = &msg->payload.ext.next;
    77d4:	4c 8d 7b 20          	lea    0x20(%rbx),%r15
	*next = NULL;
    77d8:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
    77df:	00 
	while (n > 0) {
    77e0:	45 85 ed             	test   %r13d,%r13d
    77e3:	7e 31                	jle    7816 <log_msg_create_n+0x88>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
    77e5:	e8 ee fd ff ff       	callq  75d8 <log_msg_chunk_alloc>
		if (cont == NULL) {
    77ea:	48 85 c0             	test   %rax,%rax
    77ed:	75 0f                	jne    77fe <log_msg_create_n+0x70>
			msg_free(msg);
    77ef:	48 89 df             	mov    %rbx,%rdi
			return NULL;
    77f2:	31 db                	xor    %ebx,%ebx
			msg_free(msg);
    77f4:	e8 89 fe ff ff       	callq  7682 <msg_free>
    77f9:	e9 94 00 00 00       	jmpq   7892 <log_msg_create_n+0x104>
		*next = cont;
    77fe:	49 89 07             	mov    %rax,(%r15)
    7801:	41 83 ed 07          	sub    $0x7,%r13d
		cont->next = NULL;
    7805:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		next = &cont->next;
    780c:	49 89 c7             	mov    %rax,%r15
    780f:	eb cf                	jmp    77e0 <log_msg_create_n+0x52>
	if (msg != NULL) {
    7811:	48 85 db             	test   %rbx,%rbx
    7814:	74 7c                	je     7892 <log_msg_create_n+0x104>
		msg->hdr.params.std.nargs = nargs;
    7816:	8a 43 0d             	mov    0xd(%rbx),%al
    7819:	40 88 ea             	mov    %bpl,%dl
		msg->str = str;
    781c:	4c 89 73 18          	mov    %r14,0x18(%rbx)
		msg->hdr.params.std.nargs = nargs;
    7820:	c1 e2 04             	shl    $0x4,%edx
    7823:	83 e0 0f             	and    $0xf,%eax
    7826:	09 d0                	or     %edx,%eax
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
    7828:	83 fd 04             	cmp    $0x4,%ebp
		msg->hdr.params.std.nargs = nargs;
    782b:	88 43 0d             	mov    %al,0xd(%rbx)
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
    782e:	76 25                	jbe    7855 <log_msg_create_n+0xc7>
    7830:	41 0f 10 04 24       	movups (%r12),%xmm0
		nargs -= LOG_MSG_NARGS_HEAD_CHUNK;
    7835:	83 ed 03             	sub    $0x3,%ebp
		args += LOG_MSG_NARGS_HEAD_CHUNK;
    7838:	49 83 c4 18          	add    $0x18,%r12
	struct log_msg_cont *cont = msg->payload.ext.next;
    783c:	4c 8b 43 20          	mov    0x20(%rbx),%r8
		uint32_t cpy_args = MIN(nargs, ARGS_CONT_MSG);
    7840:	41 ba 07 00 00 00    	mov    $0x7,%r10d
    7846:	0f 11 43 28          	movups %xmm0,0x28(%rbx)
    784a:	49 8b 44 24 f8       	mov    -0x8(%r12),%rax
    784f:	48 89 43 38          	mov    %rax,0x38(%rbx)
    7853:	eb 16                	jmp    786b <log_msg_create_n+0xdd>
    7855:	48 8d 43 20          	lea    0x20(%rbx),%rax
		(void)memcpy(msg->payload.single.args, args,
    7859:	89 e9                	mov    %ebp,%ecx
    785b:	4c 89 e6             	mov    %r12,%rsi
    785e:	48 c1 e1 03          	shl    $0x3,%rcx
    7862:	89 c9                	mov    %ecx,%ecx
    7864:	48 89 c7             	mov    %rax,%rdi
    7867:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
    7869:	eb 27                	jmp    7892 <log_msg_create_n+0x104>
		uint32_t cpy_args = MIN(nargs, ARGS_CONT_MSG);
    786b:	83 fd 07             	cmp    $0x7,%ebp
    786e:	44 89 d2             	mov    %r10d,%edx
    7871:	4d 8d 48 08          	lea    0x8(%r8),%r9
    7875:	0f 46 d5             	cmovbe %ebp,%edx
    7878:	4c 89 e6             	mov    %r12,%rsi
		(void)memcpy(cont->payload.args, args,
    787b:	89 d0                	mov    %edx,%eax
    787d:	4c 89 cf             	mov    %r9,%rdi
    7880:	48 c1 e0 03          	shl    $0x3,%rax
    7884:	89 c1                	mov    %eax,%ecx
		args += cpy_args;
    7886:	49 01 c4             	add    %rax,%r12
	while (nargs != 0U) {
    7889:	29 d5                	sub    %edx,%ebp
    788b:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		cont = cont->next;
    788d:	4d 8b 00             	mov    (%r8),%r8
	while (nargs != 0U) {
    7890:	75 d9                	jne    786b <log_msg_create_n+0xdd>
}
    7892:	5a                   	pop    %rdx
    7893:	48 89 d8             	mov    %rbx,%rax
    7896:	5b                   	pop    %rbx
    7897:	5d                   	pop    %rbp
    7898:	41 5c                	pop    %r12
    789a:	41 5d                	pop    %r13
    789c:	41 5e                	pop    %r14
    789e:	41 5f                	pop    %r15
    78a0:	c3                   	retq   

00000000000078a1 <log_msg_hexdump_data_get>:
void log_msg_hexdump_data_get(struct log_msg *msg,
			      uint8_t *data,
			      size_t *length,
			      size_t offset)
{
	log_msg_hexdump_data_op(msg, data, length, offset, false);
    78a1:	45 31 c0             	xor    %r8d,%r8d
    78a4:	e9 a8 fb ff ff       	jmpq   7451 <log_msg_hexdump_data_op>

00000000000078a9 <buffer_write>:
	return length;
}

static void buffer_write(log_output_func_t outf, uint8_t *buf, size_t len,
			 void *ctx)
{
    78a9:	41 55                	push   %r13
    78ab:	41 54                	push   %r12
    78ad:	49 89 cd             	mov    %rcx,%r13
    78b0:	55                   	push   %rbp
    78b1:	53                   	push   %rbx
    78b2:	49 89 fc             	mov    %rdi,%r12
    78b5:	48 89 f5             	mov    %rsi,%rbp
    78b8:	48 89 d3             	mov    %rdx,%rbx
    78bb:	48 83 ec 08          	sub    $0x8,%rsp
	int processed;

	do {
		processed = outf(buf, len, ctx);
    78bf:	48 89 de             	mov    %rbx,%rsi
    78c2:	48 89 ef             	mov    %rbp,%rdi
    78c5:	4c 89 ea             	mov    %r13,%rdx
    78c8:	41 ff d4             	callq  *%r12
		len -= processed;
    78cb:	48 98                	cltq   
		buf += processed;
    78cd:	48 01 c5             	add    %rax,%rbp
	} while (len != 0);
    78d0:	48 29 c3             	sub    %rax,%rbx
    78d3:	75 ea                	jne    78bf <buffer_write+0x16>
}
    78d5:	58                   	pop    %rax
    78d6:	5b                   	pop    %rbx
    78d7:	5d                   	pop    %rbp
    78d8:	41 5c                	pop    %r12
    78da:	41 5d                	pop    %r13
    78dc:	c3                   	retq   

00000000000078dd <print_formatted>:
{
    78dd:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    78e4:	84 c0                	test   %al,%al
    78e6:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    78eb:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    78f0:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    78f5:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    78fa:	74 37                	je     7933 <print_formatted+0x56>
    78fc:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    7901:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    7906:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    790b:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    7912:	00 
    7913:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    791a:	00 
    791b:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    7922:	00 
    7923:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    792a:	00 
    792b:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    7932:	00 
    7933:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    793a:	00 00 
    793c:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    7941:	31 c0                	xor    %eax,%eax
	va_start(args, fmt);
    7943:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    794a:	00 
	length = cbvprintf(out_func, (void *)log_output, fmt, args);
    794b:	48 89 f2             	mov    %rsi,%rdx
    794e:	48 89 fe             	mov    %rdi,%rsi
    7951:	48 8d 3d 6f 06 00 00 	lea    0x66f(%rip),%rdi        # 7fc7 <out_func>
    7958:	48 89 e1             	mov    %rsp,%rcx
	va_start(args, fmt);
    795b:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    7960:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    7965:	c7 04 24 10 00 00 00 	movl   $0x10,(%rsp)
    796c:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    7973:	00 
    7974:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
	length = cbvprintf(out_func, (void *)log_output, fmt, args);
    7979:	e8 6d e8 ff ff       	callq  61eb <cbvprintf>
}
    797e:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
    7983:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
    798a:	00 00 
    798c:	74 05                	je     7993 <print_formatted+0xb6>
    798e:	e8 ad cc ff ff       	callq  4640 <__stack_chk_fail@plt>
    7993:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    799a:	c3                   	retq   

000000000000799b <std_print>:
	}
}

static void std_print(struct log_msg *msg,
		      const struct log_output *log_output)
{
    799b:	55                   	push   %rbp
    799c:	48 89 e5             	mov    %rsp,%rbp
    799f:	41 57                	push   %r15
    79a1:	41 56                	push   %r14
    79a3:	41 55                	push   %r13
    79a5:	41 54                	push   %r12
    79a7:	49 89 ff             	mov    %rdi,%r15
    79aa:	53                   	push   %rbx
    79ab:	49 89 f4             	mov    %rsi,%r12
	const char *str = log_msg_str_get(msg);
	uint32_t nargs = log_msg_nargs_get(msg);
	log_arg_t *args = alloca(sizeof(log_arg_t)*nargs);
	int i;

	for (i = 0; i < nargs; i++) {
    79ae:	45 31 f6             	xor    %r14d,%r14d
{
    79b1:	48 83 ec 28          	sub    $0x28,%rsp
    79b5:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    79bc:	00 00 
    79be:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    79c2:	31 c0                	xor    %eax,%eax
	const char *str = log_msg_str_get(msg);
    79c4:	e8 b4 fc ff ff       	callq  767d <log_msg_str_get>
	uint32_t nargs = log_msg_nargs_get(msg);
    79c9:	4c 89 ff             	mov    %r15,%rdi
	const char *str = log_msg_str_get(msg);
    79cc:	49 89 c5             	mov    %rax,%r13
	uint32_t nargs = log_msg_nargs_get(msg);
    79cf:	e8 5c fc ff ff       	callq  7630 <log_msg_nargs_get>
    79d4:	89 c0                	mov    %eax,%eax
    79d6:	48 89 c2             	mov    %rax,%rdx
	log_arg_t *args = alloca(sizeof(log_arg_t)*nargs);
    79d9:	48 8d 04 c5 1e 00 00 	lea    0x1e(,%rax,8),%rax
    79e0:	00 
    79e1:	48 c1 e8 04          	shr    $0x4,%rax
    79e5:	48 c1 e0 04          	shl    $0x4,%rax
    79e9:	48 29 c4             	sub    %rax,%rsp
    79ec:	48 8d 5c 24 0f       	lea    0xf(%rsp),%rbx
    79f1:	48 83 e3 f0          	and    $0xfffffffffffffff0,%rbx
	for (i = 0; i < nargs; i++) {
    79f5:	41 39 d6             	cmp    %edx,%r14d
    79f8:	74 28                	je     7a22 <std_print+0x87>
		args[i] = log_msg_arg_get(msg, i);
    79fa:	49 63 c6             	movslq %r14d,%rax
    79fd:	44 89 f6             	mov    %r14d,%esi
    7a00:	4c 89 ff             	mov    %r15,%rdi
    7a03:	48 8d 0c c3          	lea    (%rbx,%rax,8),%rcx
    7a07:	89 55 b4             	mov    %edx,-0x4c(%rbp)
	for (i = 0; i < nargs; i++) {
    7a0a:	41 ff c6             	inc    %r14d
		args[i] = log_msg_arg_get(msg, i);
    7a0d:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
    7a11:	e8 24 fc ff ff       	callq  763a <log_msg_arg_get>
    7a16:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
	for (i = 0; i < nargs; i++) {
    7a1a:	8b 55 b4             	mov    -0x4c(%rbp),%edx
		args[i] = log_msg_arg_get(msg, i);
    7a1d:	48 89 01             	mov    %rax,(%rcx)
    7a20:	eb d3                	jmp    79f5 <std_print+0x5a>
	}

	switch (log_msg_nargs_get(msg)) {
    7a22:	4c 89 ff             	mov    %r15,%rdi
    7a25:	e8 06 fc ff ff       	callq  7630 <log_msg_nargs_get>
    7a2a:	83 f8 0f             	cmp    $0xf,%eax
    7a2d:	0f 87 15 02 00 00    	ja     7c48 <std_print+0x2ad>
    7a33:	48 8d 15 ae 92 02 00 	lea    0x292ae(%rip),%rdx        # 30ce8 <__func__.5785+0x80>
    7a3a:	89 c0                	mov    %eax,%eax
    7a3c:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
    7a40:	48 01 d0             	add    %rdx,%rax
    7a43:	ff e0                	jmpq   *%rax
	case 0:
		print_formatted(log_output, str);
    7a45:	4c 89 ee             	mov    %r13,%rsi
    7a48:	4c 89 e7             	mov    %r12,%rdi
    7a4b:	31 c0                	xor    %eax,%eax
    7a4d:	e8 8b fe ff ff       	callq  78dd <print_formatted>
		break;
    7a52:	e9 f1 01 00 00       	jmpq   7c48 <std_print+0x2ad>
	case 1:
		print_formatted(log_output, str, args[0]);
    7a57:	48 8b 13             	mov    (%rbx),%rdx
    7a5a:	4c 89 ee             	mov    %r13,%rsi
    7a5d:	4c 89 e7             	mov    %r12,%rdi
    7a60:	31 c0                	xor    %eax,%eax
    7a62:	e8 76 fe ff ff       	callq  78dd <print_formatted>
		break;
    7a67:	e9 dc 01 00 00       	jmpq   7c48 <std_print+0x2ad>
	case 2:
		print_formatted(log_output, str, args[0], args[1]);
    7a6c:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    7a70:	48 8b 13             	mov    (%rbx),%rdx
    7a73:	4c 89 ee             	mov    %r13,%rsi
    7a76:	4c 89 e7             	mov    %r12,%rdi
    7a79:	31 c0                	xor    %eax,%eax
    7a7b:	e8 5d fe ff ff       	callq  78dd <print_formatted>
		break;
    7a80:	e9 c3 01 00 00       	jmpq   7c48 <std_print+0x2ad>
	case 3:
		print_formatted(log_output, str, args[0], args[1], args[2]);
    7a85:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    7a89:	4c 8b 43 10          	mov    0x10(%rbx),%r8
    7a8d:	4c 89 ee             	mov    %r13,%rsi
    7a90:	48 8b 13             	mov    (%rbx),%rdx
    7a93:	4c 89 e7             	mov    %r12,%rdi
    7a96:	31 c0                	xor    %eax,%eax
    7a98:	e8 40 fe ff ff       	callq  78dd <print_formatted>
		break;
    7a9d:	e9 a6 01 00 00       	jmpq   7c48 <std_print+0x2ad>
	case 4:
		print_formatted(log_output, str, args[0], args[1], args[2],
    7aa2:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    7aa6:	4c 8b 4b 18          	mov    0x18(%rbx),%r9
    7aaa:	4c 89 ee             	mov    %r13,%rsi
    7aad:	4c 8b 43 10          	mov    0x10(%rbx),%r8
    7ab1:	48 8b 13             	mov    (%rbx),%rdx
    7ab4:	4c 89 e7             	mov    %r12,%rdi
    7ab7:	31 c0                	xor    %eax,%eax
    7ab9:	e8 1f fe ff ff       	callq  78dd <print_formatted>
				args[3]);
		break;
    7abe:	e9 85 01 00 00       	jmpq   7c48 <std_print+0x2ad>
	case 5:
		print_formatted(log_output, str, args[0], args[1], args[2],
    7ac3:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    7ac7:	48 83 ec 08          	sub    $0x8,%rsp
    7acb:	eb 07                	jmp    7ad4 <std_print+0x139>
				args[3], args[4]);
		break;
	case 6:
		print_formatted(log_output, str, args[0], args[1], args[2],
    7acd:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    7ad1:	ff 73 28             	pushq  0x28(%rbx)
    7ad4:	ff 73 20             	pushq  0x20(%rbx)
    7ad7:	48 8b 13             	mov    (%rbx),%rdx
    7ada:	4c 89 ee             	mov    %r13,%rsi
    7add:	4c 8b 4b 18          	mov    0x18(%rbx),%r9
    7ae1:	4c 8b 43 10          	mov    0x10(%rbx),%r8
    7ae5:	4c 89 e7             	mov    %r12,%rdi
    7ae8:	31 c0                	xor    %eax,%eax
    7aea:	e8 ee fd ff ff       	callq  78dd <print_formatted>
    7aef:	58                   	pop    %rax
    7af0:	5a                   	pop    %rdx
				args[3], args[4], args[5]);
		break;
    7af1:	e9 52 01 00 00       	jmpq   7c48 <std_print+0x2ad>
	case 7:
		print_formatted(log_output, str, args[0], args[1], args[2],
    7af6:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    7afa:	48 83 ec 08          	sub    $0x8,%rsp
    7afe:	eb 07                	jmp    7b07 <std_print+0x16c>
				args[3], args[4], args[5], args[6]);
		break;
	case 8:
		print_formatted(log_output, str, args[0], args[1], args[2],
    7b00:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    7b04:	ff 73 38             	pushq  0x38(%rbx)
    7b07:	ff 73 30             	pushq  0x30(%rbx)
    7b0a:	ff 73 28             	pushq  0x28(%rbx)
    7b0d:	4c 89 ee             	mov    %r13,%rsi
    7b10:	ff 73 20             	pushq  0x20(%rbx)
    7b13:	4c 8b 4b 18          	mov    0x18(%rbx),%r9
    7b17:	4c 89 e7             	mov    %r12,%rdi
    7b1a:	4c 8b 43 10          	mov    0x10(%rbx),%r8
    7b1e:	48 8b 13             	mov    (%rbx),%rdx
    7b21:	31 c0                	xor    %eax,%eax
    7b23:	e8 b5 fd ff ff       	callq  78dd <print_formatted>
    7b28:	48 83 c4 20          	add    $0x20,%rsp
				args[3], args[4], args[5], args[6], args[7]);
		break;
    7b2c:	e9 17 01 00 00       	jmpq   7c48 <std_print+0x2ad>
	case 9:
		print_formatted(log_output, str, args[0], args[1], args[2],
    7b31:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    7b35:	48 83 ec 08          	sub    $0x8,%rsp
    7b39:	eb 07                	jmp    7b42 <std_print+0x1a7>
				args[3], args[4], args[5], args[6],  args[7],
				args[8]);
		break;
	case 10:
		print_formatted(log_output, str, args[0], args[1], args[2],
    7b3b:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    7b3f:	ff 73 48             	pushq  0x48(%rbx)
    7b42:	ff 73 40             	pushq  0x40(%rbx)
    7b45:	ff 73 38             	pushq  0x38(%rbx)
    7b48:	4c 89 ee             	mov    %r13,%rsi
    7b4b:	ff 73 30             	pushq  0x30(%rbx)
    7b4e:	ff 73 28             	pushq  0x28(%rbx)
    7b51:	4c 89 e7             	mov    %r12,%rdi
    7b54:	ff 73 20             	pushq  0x20(%rbx)
    7b57:	4c 8b 4b 18          	mov    0x18(%rbx),%r9
    7b5b:	31 c0                	xor    %eax,%eax
    7b5d:	4c 8b 43 10          	mov    0x10(%rbx),%r8
    7b61:	48 8b 13             	mov    (%rbx),%rdx
    7b64:	e8 74 fd ff ff       	callq  78dd <print_formatted>
    7b69:	48 83 c4 30          	add    $0x30,%rsp
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9]);
		break;
    7b6d:	e9 d6 00 00 00       	jmpq   7c48 <std_print+0x2ad>
	case 11:
		print_formatted(log_output, str, args[0], args[1], args[2],
    7b72:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    7b76:	48 83 ec 08          	sub    $0x8,%rsp
    7b7a:	eb 07                	jmp    7b83 <std_print+0x1e8>
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9], args[10]);
		break;
	case 12:
		print_formatted(log_output, str, args[0], args[1], args[2],
    7b7c:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    7b80:	ff 73 58             	pushq  0x58(%rbx)
    7b83:	ff 73 50             	pushq  0x50(%rbx)
    7b86:	ff 73 48             	pushq  0x48(%rbx)
    7b89:	4c 89 ee             	mov    %r13,%rsi
    7b8c:	ff 73 40             	pushq  0x40(%rbx)
    7b8f:	ff 73 38             	pushq  0x38(%rbx)
    7b92:	4c 89 e7             	mov    %r12,%rdi
    7b95:	ff 73 30             	pushq  0x30(%rbx)
    7b98:	ff 73 28             	pushq  0x28(%rbx)
    7b9b:	31 c0                	xor    %eax,%eax
    7b9d:	ff 73 20             	pushq  0x20(%rbx)
    7ba0:	4c 8b 4b 18          	mov    0x18(%rbx),%r9
    7ba4:	4c 8b 43 10          	mov    0x10(%rbx),%r8
    7ba8:	48 8b 13             	mov    (%rbx),%rdx
    7bab:	e8 2d fd ff ff       	callq  78dd <print_formatted>
    7bb0:	48 83 c4 40          	add    $0x40,%rsp
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9], args[10], args[11]);
		break;
    7bb4:	e9 8f 00 00 00       	jmpq   7c48 <std_print+0x2ad>
	case 13:
		print_formatted(log_output, str, args[0], args[1], args[2],
    7bb9:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    7bbd:	48 83 ec 08          	sub    $0x8,%rsp
    7bc1:	eb 07                	jmp    7bca <std_print+0x22f>
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9], args[10], args[11], args[12]);
		break;
	case 14:
		print_formatted(log_output, str, args[0], args[1], args[2],
    7bc3:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    7bc7:	ff 73 68             	pushq  0x68(%rbx)
    7bca:	ff 73 60             	pushq  0x60(%rbx)
    7bcd:	ff 73 58             	pushq  0x58(%rbx)
    7bd0:	4c 89 ee             	mov    %r13,%rsi
    7bd3:	ff 73 50             	pushq  0x50(%rbx)
    7bd6:	ff 73 48             	pushq  0x48(%rbx)
    7bd9:	4c 89 e7             	mov    %r12,%rdi
    7bdc:	ff 73 40             	pushq  0x40(%rbx)
    7bdf:	ff 73 38             	pushq  0x38(%rbx)
    7be2:	31 c0                	xor    %eax,%eax
    7be4:	ff 73 30             	pushq  0x30(%rbx)
    7be7:	ff 73 28             	pushq  0x28(%rbx)
    7bea:	ff 73 20             	pushq  0x20(%rbx)
    7bed:	4c 8b 4b 18          	mov    0x18(%rbx),%r9
    7bf1:	4c 8b 43 10          	mov    0x10(%rbx),%r8
    7bf5:	48 8b 13             	mov    (%rbx),%rdx
    7bf8:	e8 e0 fc ff ff       	callq  78dd <print_formatted>
    7bfd:	48 83 c4 50          	add    $0x50,%rsp
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9], args[10], args[11], args[12],
				args[13]);
		break;
    7c01:	eb 45                	jmp    7c48 <std_print+0x2ad>
	case 15:
		print_formatted(log_output, str, args[0], args[1], args[2],
    7c03:	48 83 ec 08          	sub    $0x8,%rsp
    7c07:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    7c0b:	ff 73 70             	pushq  0x70(%rbx)
    7c0e:	ff 73 68             	pushq  0x68(%rbx)
    7c11:	ff 73 60             	pushq  0x60(%rbx)
    7c14:	4c 89 ee             	mov    %r13,%rsi
    7c17:	ff 73 58             	pushq  0x58(%rbx)
    7c1a:	ff 73 50             	pushq  0x50(%rbx)
    7c1d:	4c 89 e7             	mov    %r12,%rdi
    7c20:	ff 73 48             	pushq  0x48(%rbx)
    7c23:	ff 73 40             	pushq  0x40(%rbx)
    7c26:	31 c0                	xor    %eax,%eax
    7c28:	ff 73 38             	pushq  0x38(%rbx)
    7c2b:	ff 73 30             	pushq  0x30(%rbx)
    7c2e:	ff 73 28             	pushq  0x28(%rbx)
    7c31:	ff 73 20             	pushq  0x20(%rbx)
    7c34:	4c 8b 4b 18          	mov    0x18(%rbx),%r9
    7c38:	4c 8b 43 10          	mov    0x10(%rbx),%r8
    7c3c:	48 8b 13             	mov    (%rbx),%rdx
    7c3f:	e8 99 fc ff ff       	callq  78dd <print_formatted>
    7c44:	48 83 c4 60          	add    $0x60,%rsp
	default:
		/* Unsupported number of arguments. */
		__ASSERT_NO_MSG(true);
		break;
	}
}
    7c48:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    7c4c:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    7c53:	00 00 
    7c55:	74 05                	je     7c5c <std_print+0x2c1>
    7c57:	e8 e4 c9 ff ff       	callq  4640 <__stack_chk_fail@plt>
    7c5c:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    7c60:	5b                   	pop    %rbx
    7c61:	41 5c                	pop    %r12
    7c63:	41 5d                	pop    %r13
    7c65:	41 5e                	pop    %r14
    7c67:	41 5f                	pop    %r15
    7c69:	5d                   	pop    %rbp
    7c6a:	c3                   	retq   

0000000000007c6b <prefix_print>:
}

static uint32_t prefix_print(const struct log_output *log_output,
			 uint32_t flags, bool func_on, uint32_t timestamp, uint8_t level,
			 uint8_t domain_id, uint16_t source_id)
{
    7c6b:	41 57                	push   %r15
    7c6d:	41 56                	push   %r14
    7c6f:	89 f0                	mov    %esi,%eax
    7c71:	41 55                	push   %r13
    7c73:	41 54                	push   %r12
    7c75:	83 e0 01             	and    $0x1,%eax
    7c78:	55                   	push   %rbp
    7c79:	53                   	push   %rbx
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
    7c7a:	89 f3                	mov    %esi,%ebx
{
    7c7c:	48 89 fd             	mov    %rdi,%rbp
    7c7f:	41 89 d5             	mov    %edx,%r13d
    7c82:	45 89 c4             	mov    %r8d,%r12d
    7c85:	48 83 ec 18          	sub    $0x18,%rsp
    7c89:	45 89 ce             	mov    %r9d,%r14d
    7c8c:	89 44 24 08          	mov    %eax,0x8(%rsp)
    7c90:	89 f0                	mov    %esi,%eax
    7c92:	44 8b 7c 24 50       	mov    0x50(%rsp),%r15d
    7c97:	83 e0 08             	and    $0x8,%eax
	if (stamp) {
    7c9a:	83 e3 02             	and    $0x2,%ebx
    7c9d:	89 44 24 0c          	mov    %eax,0xc(%rsp)
    7ca1:	0f 84 8d 00 00 00    	je     7d34 <prefix_print+0xc9>
	if (!format) {
    7ca7:	40 80 e6 44          	and    $0x44,%sil
    7cab:	89 ca                	mov    %ecx,%edx
    7cad:	75 10                	jne    7cbf <prefix_print+0x54>
		length = print_formatted(log_output, "[%08lu] ", timestamp);
    7caf:	48 8d 35 3a 95 02 00 	lea    0x2953a(%rip),%rsi        # 311f0 <__func__.5785+0x588>
    7cb6:	31 c0                	xor    %eax,%eax
    7cb8:	e8 20 fc ff ff       	callq  78dd <print_formatted>
    7cbd:	eb 73                	jmp    7d32 <prefix_print+0xc7>
	} else if (freq != 0U) {
    7cbf:	8b 35 9f 43 25 00    	mov    0x25439f(%rip),%esi        # 25c064 <freq>
		length = 0;
    7cc5:	31 c0                	xor    %eax,%eax
	} else if (freq != 0U) {
    7cc7:	85 f6                	test   %esi,%esi
    7cc9:	74 67                	je     7d32 <prefix_print+0xc7>
		timestamp /= timestamp_div;
    7ccb:	89 c8                	mov    %ecx,%eax
    7ccd:	31 d2                	xor    %edx,%edx
    7ccf:	bb 10 0e 00 00       	mov    $0xe10,%ebx
    7cd4:	f7 35 86 43 25 00    	divl   0x254386(%rip)        # 25c060 <timestamp_div>
    7cda:	31 d2                	xor    %edx,%edx
			length = print_formatted(log_output,
    7cdc:	48 83 ec 08          	sub    $0x8,%rsp
    7ce0:	f7 f6                	div    %esi
    7ce2:	41 89 d1             	mov    %edx,%r9d
    7ce5:	31 d2                	xor    %edx,%edx
    7ce7:	f7 f3                	div    %ebx
    7ce9:	bb 3c 00 00 00       	mov    $0x3c,%ebx
		ms = (remainder * 1000U) / freq;
    7cee:	45 69 c9 e8 03 00 00 	imul   $0x3e8,%r9d,%r9d
    7cf5:	89 d1                	mov    %edx,%ecx
    7cf7:	89 c7                	mov    %eax,%edi
    7cf9:	31 d2                	xor    %edx,%edx
    7cfb:	44 89 c8             	mov    %r9d,%eax
    7cfe:	f7 f6                	div    %esi
    7d00:	41 89 d2             	mov    %edx,%r10d
    7d03:	41 89 c1             	mov    %eax,%r9d
			length = print_formatted(log_output,
    7d06:	31 d2                	xor    %edx,%edx
    7d08:	89 c8                	mov    %ecx,%eax
    7d0a:	f7 f3                	div    %ebx
    7d0c:	89 c1                	mov    %eax,%ecx
    7d0e:	41 89 d0             	mov    %edx,%r8d
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    7d11:	31 d2                	xor    %edx,%edx
    7d13:	41 69 c2 e8 03 00 00 	imul   $0x3e8,%r10d,%eax
    7d1a:	f7 f6                	div    %esi
			length = print_formatted(log_output,
    7d1c:	48 8d 35 d6 94 02 00 	lea    0x294d6(%rip),%rsi        # 311f9 <__func__.5785+0x591>
    7d23:	89 fa                	mov    %edi,%edx
    7d25:	48 89 ef             	mov    %rbp,%rdi
    7d28:	50                   	push   %rax
    7d29:	31 c0                	xor    %eax,%eax
    7d2b:	e8 ad fb ff ff       	callq  78dd <print_formatted>
    7d30:	5a                   	pop    %rdx
    7d31:	59                   	pop    %rcx
		length += timestamp_print(log_output, flags, timestamp);
    7d32:	89 c3                	mov    %eax,%ebx
	if (color) {
    7d34:	83 7c 24 08 00       	cmpl   $0x0,0x8(%rsp)
			log_output, "%s - - - - ",
			log_output->control_block->hostname ?
			log_output->control_block->hostname :
			"zephyr");
	} else {
		color_prefix(log_output, colors_on, level);
    7d39:	45 0f b6 e4          	movzbl %r12b,%r12d
	if (color) {
    7d3d:	74 2b                	je     7d6a <prefix_print+0xff>
		const char *log_color = start && (colors[level] != NULL) ?
    7d3f:	48 8d 15 5a d4 22 00 	lea    0x22d45a(%rip),%rdx        # 2351a0 <colors>
    7d46:	44 89 e0             	mov    %r12d,%eax
    7d49:	48 8b 14 c2          	mov    (%rdx,%rax,8),%rdx
    7d4d:	48 85 d2             	test   %rdx,%rdx
    7d50:	75 07                	jne    7d59 <prefix_print+0xee>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
    7d52:	48 8d 15 89 94 02 00 	lea    0x29489(%rip),%rdx        # 311e2 <__func__.5785+0x57a>
		print_formatted(log_output, "%s", log_color);
    7d59:	48 8d 35 c3 93 02 00 	lea    0x293c3(%rip),%rsi        # 31123 <__func__.5785+0x4bb>
    7d60:	48 89 ef             	mov    %rbp,%rdi
    7d63:	31 c0                	xor    %eax,%eax
    7d65:	e8 73 fb ff ff       	callq  78dd <print_formatted>
	}

	length += ids_print(log_output, level_on, func_on,
    7d6a:	41 0f b6 c6          	movzbl %r14b,%eax
	int total = 0;
    7d6e:	45 31 f6             	xor    %r14d,%r14d
	if (level_on) {
    7d71:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp)
	length += ids_print(log_output, level_on, func_on,
    7d76:	45 0f b7 ff          	movzwl %r15w,%r15d
    7d7a:	89 44 24 08          	mov    %eax,0x8(%rsp)
	if (level_on) {
    7d7e:	74 22                	je     7da2 <prefix_print+0x137>
		total += print_formatted(log_output, "<%s> ", severity[level]);
    7d80:	48 8d 15 59 d4 22 00 	lea    0x22d459(%rip),%rdx        # 2351e0 <severity>
    7d87:	44 89 e0             	mov    %r12d,%eax
    7d8a:	48 8d 35 84 94 02 00 	lea    0x29484(%rip),%rsi        # 31215 <__func__.5785+0x5ad>
    7d91:	48 89 ef             	mov    %rbp,%rdi
    7d94:	48 8b 14 c2          	mov    (%rdx,%rax,8),%rdx
    7d98:	31 c0                	xor    %eax,%eax
    7d9a:	e8 3e fb ff ff       	callq  78dd <print_formatted>
    7d9f:	41 89 c6             	mov    %eax,%r14d
	total += print_formatted(log_output,
    7da2:	8b 7c 24 08          	mov    0x8(%rsp),%edi
    7da6:	44 89 fe             	mov    %r15d,%esi
    7da9:	e8 8c f0 ff ff       	callq  6e3a <log_source_name_get>
    7dae:	45 84 ed             	test   %r13b,%r13b
    7db1:	48 8d 35 33 94 02 00 	lea    0x29433(%rip),%rsi        # 311eb <__func__.5785+0x583>
    7db8:	74 19                	je     7dd3 <prefix_print+0x168>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
    7dba:	bf 01 00 00 00       	mov    $0x1,%edi
    7dbf:	44 88 e1             	mov    %r12b,%cl
	total += print_formatted(log_output,
    7dc2:	48 8d 15 1e 94 02 00 	lea    0x2941e(%rip),%rdx        # 311e7 <__func__.5785+0x57f>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
    7dc9:	d3 e7                	shl    %cl,%edi
	total += print_formatted(log_output,
    7dcb:	40 80 e7 10          	and    $0x10,%dil
    7dcf:	48 0f 45 f2          	cmovne %rdx,%rsi
    7dd3:	48 89 c2             	mov    %rax,%rdx
    7dd6:	48 89 ef             	mov    %rbp,%rdi
    7dd9:	31 c0                	xor    %eax,%eax
    7ddb:	e8 fd fa ff ff       	callq  78dd <print_formatted>
			domain_id, source_id, level);

	return length;
}
    7de0:	48 83 c4 18          	add    $0x18,%rsp
	total += print_formatted(log_output,
    7de4:	44 01 f0             	add    %r14d,%eax
	length += ids_print(log_output, level_on, func_on,
    7de7:	01 d8                	add    %ebx,%eax
}
    7de9:	5b                   	pop    %rbx
    7dea:	5d                   	pop    %rbp
    7deb:	41 5c                	pop    %r12
    7ded:	41 5d                	pop    %r13
    7def:	41 5e                	pop    %r14
    7df1:	41 5f                	pop    %r15
    7df3:	c3                   	retq   

0000000000007df4 <postfix_print>:

static void postfix_print(const struct log_output *log_output,
			  uint32_t flags, uint8_t level)
{
    7df4:	55                   	push   %rbp
    7df5:	53                   	push   %rbx
    7df6:	89 f5                	mov    %esi,%ebp
    7df8:	48 89 fb             	mov    %rdi,%rbx
    7dfb:	48 83 ec 08          	sub    $0x8,%rsp
	if (color) {
    7dff:	40 80 e6 01          	and    $0x1,%sil
    7e03:	74 15                	je     7e1a <postfix_print+0x26>
		print_formatted(log_output, "%s", log_color);
    7e05:	48 8d 15 d6 93 02 00 	lea    0x293d6(%rip),%rdx        # 311e2 <__func__.5785+0x57a>
    7e0c:	48 8d 35 10 93 02 00 	lea    0x29310(%rip),%rsi        # 31123 <__func__.5785+0x4bb>
    7e13:	31 c0                	xor    %eax,%eax
    7e15:	e8 c3 fa ff ff       	callq  78dd <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    7e1a:	40 f6 c5 10          	test   $0x10,%bpl
    7e1e:	75 21                	jne    7e41 <postfix_print+0x4d>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    7e20:	40 80 e5 20          	and    $0x20,%bpl
		print_formatted(ctx, "\n");
    7e24:	48 8d 35 55 a2 02 00 	lea    0x2a255(%rip),%rsi        # 32080 <__func__.5785+0x1418>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    7e2b:	75 07                	jne    7e34 <postfix_print+0x40>
		print_formatted(ctx, "\r\n");
    7e2d:	48 8d 35 e7 93 02 00 	lea    0x293e7(%rip),%rsi        # 3121b <__func__.5785+0x5b3>
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(log_output, flags);
}
    7e34:	5a                   	pop    %rdx
		print_formatted(ctx, "\r\n");
    7e35:	48 89 df             	mov    %rbx,%rdi
    7e38:	31 c0                	xor    %eax,%eax
}
    7e3a:	5b                   	pop    %rbx
    7e3b:	5d                   	pop    %rbp
		print_formatted(ctx, "\r\n");
    7e3c:	e9 9c fa ff ff       	jmpq   78dd <print_formatted>
}
    7e41:	58                   	pop    %rax
    7e42:	5b                   	pop    %rbx
    7e43:	5d                   	pop    %rbp
    7e44:	c3                   	retq   

0000000000007e45 <hexdump_line_print>:
{
    7e45:	41 57                	push   %r15
    7e47:	41 56                	push   %r14
    7e49:	41 89 d6             	mov    %edx,%r14d
    7e4c:	41 55                	push   %r13
    7e4e:	41 54                	push   %r12
    7e50:	49 89 f5             	mov    %rsi,%r13
    7e53:	55                   	push   %rbp
    7e54:	53                   	push   %rbx
    7e55:	41 89 cc             	mov    %ecx,%r12d
    7e58:	48 89 fb             	mov    %rdi,%rbx
    7e5b:	48 83 ec 18          	sub    $0x18,%rsp
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    7e5f:	41 f6 c0 10          	test   $0x10,%r8b
    7e63:	75 1e                	jne    7e83 <hexdump_line_print+0x3e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    7e65:	41 80 e0 20          	and    $0x20,%r8b
		print_formatted(ctx, "\n");
    7e69:	48 8d 35 10 a2 02 00 	lea    0x2a210(%rip),%rsi        # 32080 <__func__.5785+0x1418>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    7e70:	75 07                	jne    7e79 <hexdump_line_print+0x34>
		print_formatted(ctx, "\r\n");
    7e72:	48 8d 35 a2 93 02 00 	lea    0x293a2(%rip),%rsi        # 3121b <__func__.5785+0x5b3>
    7e79:	48 89 df             	mov    %rbx,%rdi
    7e7c:	31 c0                	xor    %eax,%eax
    7e7e:	e8 5a fa ff ff       	callq  78dd <print_formatted>
		print_formatted(log_output, " ");
    7e83:	4c 8d 3d 9c 93 02 00 	lea    0x2939c(%rip),%r15        # 31226 <__func__.5785+0x5be>
{
    7e8a:	31 ed                	xor    %ebp,%ebp
	for (int i = 0; i < prefix_offset; i++) {
    7e8c:	44 39 e5             	cmp    %r12d,%ebp
    7e8f:	7d 11                	jge    7ea2 <hexdump_line_print+0x5d>
		print_formatted(log_output, " ");
    7e91:	4c 89 fe             	mov    %r15,%rsi
    7e94:	48 89 df             	mov    %rbx,%rdi
    7e97:	31 c0                	xor    %eax,%eax
    7e99:	e8 3f fa ff ff       	callq  78dd <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
    7e9e:	ff c5                	inc    %ebp
    7ea0:	eb ea                	jmp    7e8c <hexdump_line_print+0x47>
			print_formatted(log_output, "   ");
    7ea2:	4c 8d 3d 7b 93 02 00 	lea    0x2937b(%rip),%r15        # 31224 <__func__.5785+0x5bc>
    7ea9:	31 ed                	xor    %ebp,%ebp
		if (i < length) {
    7eab:	41 39 ee             	cmp    %ebp,%r14d
    7eae:	41 89 ec             	mov    %ebp,%r12d
    7eb1:	76 19                	jbe    7ecc <hexdump_line_print+0x87>
			print_formatted(log_output, "%02x ", data[i]);
    7eb3:	41 0f b6 54 2d 00    	movzbl 0x0(%r13,%rbp,1),%edx
    7eb9:	48 8d 35 5e 93 02 00 	lea    0x2935e(%rip),%rsi        # 3121e <__func__.5785+0x5b6>
    7ec0:	48 89 df             	mov    %rbx,%rdi
    7ec3:	31 c0                	xor    %eax,%eax
    7ec5:	e8 13 fa ff ff       	callq  78dd <print_formatted>
    7eca:	eb 0d                	jmp    7ed9 <hexdump_line_print+0x94>
			print_formatted(log_output, "   ");
    7ecc:	4c 89 fe             	mov    %r15,%rsi
    7ecf:	48 89 df             	mov    %rbx,%rdi
    7ed2:	31 c0                	xor    %eax,%eax
    7ed4:	e8 04 fa ff ff       	callq  78dd <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    7ed9:	48 83 fd 0f          	cmp    $0xf,%rbp
    7edd:	75 63                	jne    7f42 <hexdump_line_print+0xfd>
	print_formatted(log_output, "|");
    7edf:	48 8d 35 42 93 02 00 	lea    0x29342(%rip),%rsi        # 31228 <__func__.5785+0x5c0>
    7ee6:	48 89 df             	mov    %rbx,%rdi
    7ee9:	31 c0                	xor    %eax,%eax
    7eeb:	31 ed                	xor    %ebp,%ebp
			print_formatted(log_output, "%c",
    7eed:	41 b7 2e             	mov    $0x2e,%r15b
	print_formatted(log_output, "|");
    7ef0:	e8 e8 f9 ff ff       	callq  78dd <print_formatted>
		if (i < length) {
    7ef5:	41 39 ee             	cmp    %ebp,%r14d
    7ef8:	89 6c 24 0c          	mov    %ebp,0xc(%rsp)
    7efc:	76 31                	jbe    7f2f <hexdump_line_print+0xea>
			char c = (char)data[i];
    7efe:	45 8a 64 2d 00       	mov    0x0(%r13,%rbp,1),%r12b
			      isprint((int)c) ? c : '.');
    7f03:	e8 08 c7 ff ff       	callq  4610 <__ctype_b_loc@plt>
    7f08:	48 8b 00             	mov    (%rax),%rax
			print_formatted(log_output, "%c",
    7f0b:	48 8d 35 18 93 02 00 	lea    0x29318(%rip),%rsi        # 3122a <__func__.5785+0x5c2>
    7f12:	48 89 df             	mov    %rbx,%rdi
			      isprint((int)c) ? c : '.');
    7f15:	49 0f be cc          	movsbq %r12b,%rcx
			print_formatted(log_output, "%c",
    7f19:	f6 44 48 01 40       	testb  $0x40,0x1(%rax,%rcx,2)
    7f1e:	45 0f 44 e7          	cmove  %r15d,%r12d
    7f22:	31 c0                	xor    %eax,%eax
    7f24:	41 0f be d4          	movsbl %r12b,%edx
    7f28:	e8 b0 f9 ff ff       	callq  78dd <print_formatted>
    7f2d:	eb 35                	jmp    7f64 <hexdump_line_print+0x11f>
			print_formatted(log_output, " ");
    7f2f:	48 8d 35 f0 92 02 00 	lea    0x292f0(%rip),%rsi        # 31226 <__func__.5785+0x5be>
    7f36:	48 89 df             	mov    %rbx,%rdi
    7f39:	31 c0                	xor    %eax,%eax
    7f3b:	e8 9d f9 ff ff       	callq  78dd <print_formatted>
    7f40:	eb 22                	jmp    7f64 <hexdump_line_print+0x11f>
		if (i > 0 && !(i % 8)) {
    7f42:	41 ff c4             	inc    %r12d
    7f45:	41 80 e4 07          	and    $0x7,%r12b
    7f49:	75 11                	jne    7f5c <hexdump_line_print+0x117>
			print_formatted(log_output, " ");
    7f4b:	48 8d 35 d4 92 02 00 	lea    0x292d4(%rip),%rsi        # 31226 <__func__.5785+0x5be>
    7f52:	48 89 df             	mov    %rbx,%rdi
    7f55:	31 c0                	xor    %eax,%eax
    7f57:	e8 81 f9 ff ff       	callq  78dd <print_formatted>
    7f5c:	48 ff c5             	inc    %rbp
    7f5f:	e9 47 ff ff ff       	jmpq   7eab <hexdump_line_print+0x66>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    7f64:	48 83 fd 0f          	cmp    $0xf,%rbp
    7f68:	74 27                	je     7f91 <hexdump_line_print+0x14c>
		if (i > 0 && !(i % 8)) {
    7f6a:	44 8b 64 24 0c       	mov    0xc(%rsp),%r12d
    7f6f:	41 ff c4             	inc    %r12d
    7f72:	41 80 e4 07          	and    $0x7,%r12b
    7f76:	75 11                	jne    7f89 <hexdump_line_print+0x144>
			print_formatted(log_output, " ");
    7f78:	48 8d 35 a7 92 02 00 	lea    0x292a7(%rip),%rsi        # 31226 <__func__.5785+0x5be>
    7f7f:	48 89 df             	mov    %rbx,%rdi
    7f82:	31 c0                	xor    %eax,%eax
    7f84:	e8 54 f9 ff ff       	callq  78dd <print_formatted>
    7f89:	48 ff c5             	inc    %rbp
    7f8c:	e9 64 ff ff ff       	jmpq   7ef5 <hexdump_line_print+0xb0>
}
    7f91:	48 83 c4 18          	add    $0x18,%rsp
    7f95:	5b                   	pop    %rbx
    7f96:	5d                   	pop    %rbp
    7f97:	41 5c                	pop    %r12
    7f99:	41 5d                	pop    %r13
    7f9b:	41 5e                	pop    %r14
    7f9d:	41 5f                	pop    %r15
    7f9f:	c3                   	retq   

0000000000007fa0 <log_output_flush>:
{
    7fa0:	53                   	push   %rbx
		     log_output->control_block->ctx);
    7fa1:	48 8b 47 08          	mov    0x8(%rdi),%rax
{
    7fa5:	48 89 fb             	mov    %rdi,%rbx
	buffer_write(log_output->func, log_output->buf,
    7fa8:	48 8b 77 10          	mov    0x10(%rdi),%rsi
    7fac:	48 8b 3f             	mov    (%rdi),%rdi
    7faf:	48 63 10             	movslq (%rax),%rdx
    7fb2:	48 8b 48 08          	mov    0x8(%rax),%rcx
    7fb6:	e8 ee f8 ff ff       	callq  78a9 <buffer_write>
	log_output->control_block->offset = 0;
    7fbb:	48 8b 43 08          	mov    0x8(%rbx),%rax
    7fbf:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
    7fc5:	5b                   	pop    %rbx
    7fc6:	c3                   	retq   

0000000000007fc7 <out_func>:
{
    7fc7:	55                   	push   %rbp
    7fc8:	53                   	push   %rbx
    7fc9:	89 fd                	mov    %edi,%ebp
    7fcb:	48 89 f3             	mov    %rsi,%rbx
    7fce:	48 83 ec 08          	sub    $0x8,%rsp
	if (out_ctx->control_block->offset == out_ctx->size) {
    7fd2:	48 8b 46 08          	mov    0x8(%rsi),%rax
    7fd6:	48 63 00             	movslq (%rax),%rax
    7fd9:	48 3b 46 18          	cmp    0x18(%rsi),%rax
    7fdd:	75 08                	jne    7fe7 <out_func+0x20>
		log_output_flush(out_ctx);
    7fdf:	48 89 f7             	mov    %rsi,%rdi
    7fe2:	e8 b9 ff ff ff       	callq  7fa0 <log_output_flush>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    7fe7:	48 8b 53 08          	mov    0x8(%rbx),%rdx
    7feb:	b8 01 00 00 00       	mov    $0x1,%eax
    7ff0:	f0 0f c1 02          	lock xadd %eax,(%rdx)
	out_ctx->buf[idx] = (uint8_t)c;
    7ff4:	48 8b 53 10          	mov    0x10(%rbx),%rdx
    7ff8:	48 98                	cltq   
    7ffa:	40 88 2c 02          	mov    %bpl,(%rdx,%rax,1)
}
    7ffe:	31 c0                	xor    %eax,%eax
    8000:	5a                   	pop    %rdx
    8001:	5b                   	pop    %rbx
    8002:	5d                   	pop    %rbp
    8003:	c3                   	retq   

0000000000008004 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *log_output,
			    struct log_msg *msg,
			    uint32_t flags)
{
    8004:	41 57                	push   %r15
    8006:	41 56                	push   %r14
    8008:	41 55                	push   %r13
    800a:	41 54                	push   %r12
    800c:	41 89 d5             	mov    %edx,%r13d
    800f:	55                   	push   %rbp
    8010:	53                   	push   %rbx
    8011:	48 89 f5             	mov    %rsi,%rbp
    8014:	48 89 fb             	mov    %rdi,%rbx
    8017:	48 83 ec 38          	sub    $0x38,%rsp
	return msg->hdr.ids.level;
    801b:	44 8a 4e 0e          	mov    0xe(%rsi),%r9b
    801f:	66 8b 56 0c          	mov    0xc(%rsi),%dx
    8023:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    802a:	00 00 
    802c:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    8031:	31 c0                	xor    %eax,%eax
		log_output_msg_syst_process(log_output, msg, flags);
		return;
	}

	prefix_offset = raw_string ?
			0 : prefix_print(log_output, flags, std_msg, timestamp,
    8033:	45 88 cc             	mov    %r9b,%r12b
    8036:	41 80 e4 07          	and    $0x7,%r12b
    803a:	74 36                	je     8072 <log_output_msg_process+0x6e>
	return msg->hdr.ids.source_id;
    803c:	66 8b 46 0e          	mov    0xe(%rsi),%ax
    8040:	8b 4e 10             	mov    0x10(%rsi),%ecx
    8043:	48 83 ec 08          	sub    $0x8,%rsp
	return msg->hdr.ids.domain_id;
    8047:	41 c0 e9 03          	shr    $0x3,%r9b
    804b:	f7 d2                	not    %edx
    804d:	45 89 e0             	mov    %r12d,%r8d
    8050:	83 e2 01             	and    $0x1,%edx
    8053:	41 83 e1 07          	and    $0x7,%r9d
    8057:	41 83 e0 07          	and    $0x7,%r8d
	return msg->hdr.ids.source_id;
    805b:	66 c1 e8 06          	shr    $0x6,%ax
    805f:	44 89 ee             	mov    %r13d,%esi
    8062:	0f b7 c0             	movzwl %ax,%eax
    8065:	50                   	push   %rax
    8066:	e8 00 fc ff ff       	callq  7c6b <prefix_print>
    806b:	5a                   	pop    %rdx
    806c:	41 89 c7             	mov    %eax,%r15d
    806f:	59                   	pop    %rcx
    8070:	eb 03                	jmp    8075 <log_output_msg_process+0x71>
    8072:	45 31 ff             	xor    %r15d,%r15d
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
    8075:	f6 45 0c 01          	testb  $0x1,0xc(%rbp)
    8079:	75 19                	jne    8094 <log_output_msg_process+0x90>
		std_print(msg, log_output);
    807b:	48 89 de             	mov    %rbx,%rsi
    807e:	48 89 ef             	mov    %rbp,%rdi
    8081:	e8 15 f9 ff ff       	callq  799b <std_print>
		raw_string_print(msg, log_output);
	} else {
		hexdump_print(msg, log_output, prefix_offset, flags);
	}

	if (!raw_string) {
    8086:	45 84 e4             	test   %r12b,%r12b
    8089:	0f 84 fa 00 00 00    	je     8189 <log_output_msg_process+0x185>
    808f:	e9 e6 00 00 00       	jmpq   817a <log_output_msg_process+0x176>
    8094:	48 8d 44 24 10       	lea    0x10(%rsp),%rax
	} else if (raw_string) {
    8099:	45 84 e4             	test   %r12b,%r12b
    809c:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    80a1:	75 6f                	jne    8112 <log_output_msg_process+0x10e>
	bool eol = false;
    80a3:	45 31 ed             	xor    %r13d,%r13d
	size_t offset = 0;
    80a6:	45 31 e4             	xor    %r12d,%r12d
		length = log_output->size;
    80a9:	48 8b 43 18          	mov    0x18(%rbx),%rax
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
    80ad:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    80b2:	4c 89 e1             	mov    %r12,%rcx
    80b5:	48 8b 73 10          	mov    0x10(%rbx),%rsi
    80b9:	48 89 ef             	mov    %rbp,%rdi
		length = log_output->size;
    80bc:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
    80c1:	e8 db f7 ff ff       	callq  78a1 <log_msg_hexdump_data_get>
		log_output->control_block->offset = length;
    80c6:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
    80cb:	48 8b 53 08          	mov    0x8(%rbx),%rdx
		if (length != 0) {
    80cf:	48 85 c0             	test   %rax,%rax
		log_output->control_block->offset = length;
    80d2:	89 02                	mov    %eax,(%rdx)
		if (length != 0) {
    80d4:	74 0d                	je     80e3 <log_output_msg_process+0xdf>
			eol = (log_output->buf[length - 1] == '\n');
    80d6:	48 8b 53 10          	mov    0x10(%rbx),%rdx
    80da:	80 7c 02 ff 0a       	cmpb   $0xa,-0x1(%rdx,%rax,1)
    80df:	41 0f 94 c5          	sete   %r13b
		log_output_flush(log_output);
    80e3:	48 89 df             	mov    %rbx,%rdi
    80e6:	e8 b5 fe ff ff       	callq  7fa0 <log_output_flush>
		offset += length;
    80eb:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
    80f0:	49 01 c4             	add    %rax,%r12
	} while (length > 0);
    80f3:	48 85 c0             	test   %rax,%rax
    80f6:	75 b1                	jne    80a9 <log_output_msg_process+0xa5>
	if (eol) {
    80f8:	45 84 ed             	test   %r13b,%r13b
    80fb:	0f 84 88 00 00 00    	je     8189 <log_output_msg_process+0x185>
		print_formatted(log_output, "\r");
    8101:	48 8d 35 25 91 02 00 	lea    0x29125(%rip),%rsi        # 3122d <__func__.5785+0x5c5>
    8108:	48 89 df             	mov    %rbx,%rdi
    810b:	e8 cd f7 ff ff       	callq  78dd <print_formatted>
    8110:	eb 77                	jmp    8189 <log_output_msg_process+0x185>
	print_formatted(log_output, "%s", log_msg_str_get(msg));
    8112:	48 89 ef             	mov    %rbp,%rdi
	uint32_t offset = 0U;
    8115:	45 31 f6             	xor    %r14d,%r14d
	print_formatted(log_output, "%s", log_msg_str_get(msg));
    8118:	e8 60 f5 ff ff       	callq  767d <log_msg_str_get>
    811d:	48 8d 35 ff 8f 02 00 	lea    0x28fff(%rip),%rsi        # 31123 <__func__.5785+0x4bb>
    8124:	48 89 c2             	mov    %rax,%rdx
    8127:	48 89 df             	mov    %rbx,%rdi
    812a:	31 c0                	xor    %eax,%eax
    812c:	e8 ac f7 ff ff       	callq  78dd <print_formatted>
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    8131:	48 8d 44 24 18       	lea    0x18(%rsp),%rax
    8136:	48 89 04 24          	mov    %rax,(%rsp)
    813a:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    813f:	48 8b 34 24          	mov    (%rsp),%rsi
    8143:	44 89 f1             	mov    %r14d,%ecx
    8146:	48 89 ef             	mov    %rbp,%rdi
		length = sizeof(buf);
    8149:	48 c7 44 24 10 10 00 	movq   $0x10,0x10(%rsp)
    8150:	00 00 
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    8152:	e8 4a f7 ff ff       	callq  78a1 <log_msg_hexdump_data_get>
		if (length) {
    8157:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
    815c:	48 85 d2             	test   %rdx,%rdx
    815f:	74 19                	je     817a <log_output_msg_process+0x176>
			hexdump_line_print(log_output, buf, length,
    8161:	48 8b 34 24          	mov    (%rsp),%rsi
    8165:	45 89 e8             	mov    %r13d,%r8d
    8168:	44 89 f9             	mov    %r15d,%ecx
    816b:	48 89 df             	mov    %rbx,%rdi
    816e:	e8 d2 fc ff ff       	callq  7e45 <hexdump_line_print>
			offset += length;
    8173:	44 03 74 24 10       	add    0x10(%rsp),%r14d
    8178:	eb c0                	jmp    813a <log_output_msg_process+0x136>
		postfix_print(log_output, flags, level);
    817a:	41 0f b6 d4          	movzbl %r12b,%edx
    817e:	44 89 ee             	mov    %r13d,%esi
    8181:	48 89 df             	mov    %rbx,%rdi
    8184:	e8 6b fc ff ff       	callq  7df4 <postfix_print>
	}

	log_output_flush(log_output);
    8189:	48 89 df             	mov    %rbx,%rdi
    818c:	e8 0f fe ff ff       	callq  7fa0 <log_output_flush>
}
    8191:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    8196:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    819d:	00 00 
    819f:	74 05                	je     81a6 <log_output_msg_process+0x1a2>
    81a1:	e8 9a c4 ff ff       	callq  4640 <__stack_chk_fail@plt>
    81a6:	48 83 c4 38          	add    $0x38,%rsp
    81aa:	5b                   	pop    %rbx
    81ab:	5d                   	pop    %rbp
    81ac:	41 5c                	pop    %r12
    81ae:	41 5d                	pop    %r13
    81b0:	41 5e                	pop    %r14
    81b2:	41 5f                	pop    %r15
    81b4:	c3                   	retq   

00000000000081b5 <log_output_dropped_process>:
	postfix_print(log_output, flags, level);
	log_output_flush(log_output);
}

void log_output_dropped_process(const struct log_output *log_output, uint32_t cnt)
{
    81b5:	41 55                	push   %r13
    81b7:	41 54                	push   %r12
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = log_output->func;

	cnt = MIN(cnt, 9999);
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    81b9:	48 8d 15 e1 ad 02 00 	lea    0x2ade1(%rip),%rdx        # 32fa1 <__func__.5785+0x2339>
{
    81c0:	55                   	push   %rbp
    81c1:	53                   	push   %rbx
	cnt = MIN(cnt, 9999);
    81c2:	b9 0f 27 00 00       	mov    $0x270f,%ecx
{
    81c7:	48 89 fb             	mov    %rdi,%rbx
    81ca:	48 83 ec 18          	sub    $0x18,%rsp
	log_output_func_t outf = log_output->func;
    81ce:	48 8b 2f             	mov    (%rdi),%rbp
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    81d1:	4c 8d 6c 24 03       	lea    0x3(%rsp),%r13
{
    81d6:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    81dd:	00 00 
    81df:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    81e4:	31 c0                	xor    %eax,%eax
	cnt = MIN(cnt, 9999);
    81e6:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    81ec:	4c 89 ef             	mov    %r13,%rdi
	cnt = MIN(cnt, 9999);
    81ef:	0f 46 ce             	cmovbe %esi,%ecx
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    81f2:	be 05 00 00 00       	mov    $0x5,%esi
    81f7:	e8 b0 d8 ff ff       	callq  5aac <snprintk>
    81fc:	41 89 c4             	mov    %eax,%r12d

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
    81ff:	48 8b 43 08          	mov    0x8(%rbx),%rax
    8203:	48 8d 35 66 89 02 00 	lea    0x28966(%rip),%rsi        # 30b70 <prefix.6006>
    820a:	ba 0b 00 00 00       	mov    $0xb,%edx
    820f:	48 89 ef             	mov    %rbp,%rdi
    8212:	48 8b 48 08          	mov    0x8(%rax),%rcx
    8216:	e8 8e f6 ff ff       	callq  78a9 <buffer_write>
		     log_output->control_block->ctx);
	buffer_write(outf, buf, len, log_output->control_block->ctx);
    821b:	48 8b 43 08          	mov    0x8(%rbx),%rax
    821f:	49 63 d4             	movslq %r12d,%rdx
    8222:	4c 89 ee             	mov    %r13,%rsi
    8225:	48 89 ef             	mov    %rbp,%rdi
    8228:	48 8b 48 08          	mov    0x8(%rax),%rcx
    822c:	e8 78 f6 ff ff       	callq  78a9 <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
    8231:	48 8b 43 08          	mov    0x8(%rbx),%rax
    8235:	48 8d 35 a4 85 02 00 	lea    0x285a4(%rip),%rsi        # 307e0 <postfix.6007>
    823c:	ba 1b 00 00 00       	mov    $0x1b,%edx
    8241:	48 89 ef             	mov    %rbp,%rdi
    8244:	48 8b 48 08          	mov    0x8(%rax),%rcx
    8248:	e8 5c f6 ff ff       	callq  78a9 <buffer_write>
		     log_output->control_block->ctx);
}
    824d:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    8252:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    8259:	00 00 
    825b:	74 05                	je     8262 <log_output_dropped_process+0xad>
    825d:	e8 de c3 ff ff       	callq  4640 <__stack_chk_fail@plt>
    8262:	48 83 c4 18          	add    $0x18,%rsp
    8266:	5b                   	pop    %rbx
    8267:	5d                   	pop    %rbp
    8268:	41 5c                	pop    %r12
    826a:	41 5d                	pop    %r13
    826c:	c3                   	retq   

000000000000826d <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
    826d:	c7 05 e9 3d 25 00 01 	movl   $0x1,0x253de9(%rip)        # 25c060 <timestamp_div>
    8274:	00 00 00 
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
    8277:	31 d2                	xor    %edx,%edx
    8279:	b8 01 00 00 00       	mov    $0x1,%eax
    827e:	81 ff 40 42 0f 00    	cmp    $0xf4240,%edi
    8284:	76 08                	jbe    828e <log_output_timestamp_freq_set+0x21>
		frequency /= 2U;
    8286:	d1 ef                	shr    %edi
		timestamp_div *= 2U;
    8288:	01 c0                	add    %eax,%eax
    828a:	b2 01                	mov    $0x1,%dl
    828c:	eb f0                	jmp    827e <log_output_timestamp_freq_set+0x11>
    828e:	84 d2                	test   %dl,%dl
    8290:	74 06                	je     8298 <log_output_timestamp_freq_set+0x2b>
    8292:	89 05 c8 3d 25 00    	mov    %eax,0x253dc8(%rip)        # 25c060 <timestamp_div>
	}

	freq = frequency;
    8298:	89 3d c6 3d 25 00    	mov    %edi,0x253dc6(%rip)        # 25c064 <freq>
}
    829e:	c3                   	retq   

000000000000829f <panic>:

}

static void panic(struct log_backend const *const backend)
{
	log_output_flush(&log_output_posix);
    829f:	48 8d 3d ba cf 22 00 	lea    0x22cfba(%rip),%rdi        # 235260 <log_output_posix>
    82a6:	e9 f5 fc ff ff       	jmpq   7fa0 <log_output_flush>

00000000000082ab <char_out>:
{
    82ab:	41 54                	push   %r12
    82ad:	55                   	push   %rbp
    82ae:	48 8d 2c 37          	lea    (%rdi,%rsi,1),%rbp
    82b2:	53                   	push   %rbx
    82b3:	49 89 f4             	mov    %rsi,%r12
    82b6:	48 89 fb             	mov    %rdi,%rbx
	for (size_t i = 0; i < length; i++) {
    82b9:	48 39 eb             	cmp    %rbp,%rbx
    82bc:	74 72                	je     8330 <char_out+0x85>
		preprint_char(data[i]);
    82be:	0f b6 13             	movzbl (%rbx),%edx
	if (c == '\r') {
    82c1:	83 fa 0d             	cmp    $0xd,%edx
		preprint_char(data[i]);
    82c4:	89 d6                	mov    %edx,%esi
	if (c == '\r') {
    82c6:	74 63                	je     832b <char_out+0x80>
	if (c != '\n') {
    82c8:	83 fa 0a             	cmp    $0xa,%edx
		printnow = 1;
    82cb:	b8 01 00 00 00       	mov    $0x1,%eax
	if (c != '\n') {
    82d0:	74 23                	je     82f5 <char_out+0x4a>
    82d2:	48 63 15 8f 3d 25 00 	movslq 0x253d8f(%rip),%rdx        # 25c068 <n_pend>
		stdout_buff[n_pend++] = c;
    82d9:	48 8d 0d 40 2a 23 00 	lea    0x232a40(%rip),%rcx        # 23ad20 <stdout_buff>
    82e0:	8d 42 01             	lea    0x1(%rdx),%eax
    82e3:	40 88 34 11          	mov    %sil,(%rcx,%rdx,1)
    82e7:	89 05 7b 3d 25 00    	mov    %eax,0x253d7b(%rip)        # 25c068 <n_pend>
		stdout_buff[n_pend] = 0;
    82ed:	48 98                	cltq   
    82ef:	c6 04 01 00          	movb   $0x0,(%rcx,%rax,1)
	int printnow = 0;
    82f3:	31 c0                	xor    %eax,%eax
	if (printnow) {
    82f5:	81 3d 69 3d 25 00 fe 	cmpl   $0xfe,0x253d69(%rip)        # 25c068 <n_pend>
    82fc:	00 00 00 
    82ff:	7f 04                	jg     8305 <char_out+0x5a>
    8301:	85 c0                	test   %eax,%eax
    8303:	74 26                	je     832b <char_out+0x80>
		posix_print_trace("%s\n", stdout_buff);
    8305:	48 8d 35 14 2a 23 00 	lea    0x232a14(%rip),%rsi        # 23ad20 <stdout_buff>
    830c:	48 8d 3d ba 91 02 00 	lea    0x291ba(%rip),%rdi        # 314cd <__func__.5785+0x865>
    8313:	31 c0                	xor    %eax,%eax
    8315:	e8 42 41 00 00       	callq  c45c <posix_print_trace>
		n_pend = 0;
    831a:	c7 05 44 3d 25 00 00 	movl   $0x0,0x253d44(%rip)        # 25c068 <n_pend>
    8321:	00 00 00 
		stdout_buff[0] = 0;
    8324:	c6 05 f5 29 23 00 00 	movb   $0x0,0x2329f5(%rip)        # 23ad20 <stdout_buff>
    832b:	48 ff c3             	inc    %rbx
    832e:	eb 89                	jmp    82b9 <char_out+0xe>
}
    8330:	44 89 e0             	mov    %r12d,%eax
    8333:	5b                   	pop    %rbx
    8334:	5d                   	pop    %rbp
    8335:	41 5c                	pop    %r12
    8337:	c3                   	retq   

0000000000008338 <dropped>:

static void dropped(const struct log_backend *const backend, uint32_t cnt)
{
	ARG_UNUSED(backend);

	log_output_dropped_process(&log_output_posix, cnt);
    8338:	48 8d 3d 21 cf 22 00 	lea    0x22cf21(%rip),%rdi        # 235260 <log_output_posix>
    833f:	e9 71 fe ff ff       	jmpq   81b5 <log_output_dropped_process>

0000000000008344 <put>:
{
    8344:	53                   	push   %rbx
	log_msg_get(msg);
    8345:	48 89 f7             	mov    %rsi,%rdi
{
    8348:	48 89 f3             	mov    %rsi,%rbx
	log_msg_get(msg);
    834b:	e8 18 f2 ff ff       	callq  7568 <log_msg_get>
		if (posix_trace_over_tty(0)) {
    8350:	31 ff                	xor    %edi,%edi
    8352:	e8 cd 41 00 00       	callq  c524 <posix_trace_over_tty>
			flags |= LOG_OUTPUT_FLAG_COLORS;
    8357:	83 f8 01             	cmp    $0x1,%eax
	log_output_msg_process(&log_output_posix, msg, flags);
    835a:	48 8d 3d ff ce 22 00 	lea    0x22ceff(%rip),%rdi        # 235260 <log_output_posix>
    8361:	48 89 de             	mov    %rbx,%rsi
			flags |= LOG_OUTPUT_FLAG_COLORS;
    8364:	19 d2                	sbb    %edx,%edx
    8366:	83 c2 0b             	add    $0xb,%edx
		flags |= LOG_OUTPUT_FLAG_FORMAT_TIMESTAMP;
    8369:	83 ca 04             	or     $0x4,%edx
	log_output_msg_process(&log_output_posix, msg, flags);
    836c:	e8 93 fc ff ff       	callq  8004 <log_output_msg_process>
	log_msg_put(msg);
    8371:	48 89 df             	mov    %rbx,%rdi
}
    8374:	5b                   	pop    %rbx
	log_msg_put(msg);
    8375:	e9 04 f4 ff ff       	jmpq   777e <log_msg_put>

000000000000837a <settings_save_one>:

/*
 * Append a single value to persisted config. Don't store duplicate value.
 */
int settings_save_one(const char *name, const void *value, size_t val_len)
{
    837a:	41 55                	push   %r13
    837c:	41 54                	push   %r12
    837e:	55                   	push   %rbp
    837f:	53                   	push   %rbx
    8380:	bd fe ff ff ff       	mov    $0xfffffffe,%ebp
    8385:	48 83 ec 08          	sub    $0x8,%rsp
	int rc;
	struct settings_store *cs;

	cs = settings_save_dst;
    8389:	48 8d 05 40 fb 24 00 	lea    0x24fb40(%rip),%rax        # 257ed0 <settings_save_dst>
    8390:	48 8b 18             	mov    (%rax),%rbx
	if (!cs) {
    8393:	48 85 db             	test   %rbx,%rbx
    8396:	74 3a                	je     83d2 <settings_save_one+0x58>
    8398:	49 89 d5             	mov    %rdx,%r13
    839b:	49 89 f4             	mov    %rsi,%r12
    839e:	48 89 fd             	mov    %rdi,%rbp
	return z_impl_k_mutex_lock(mutex, timeout);
    83a1:	48 8d 3d 98 22 23 00 	lea    0x232298(%rip),%rdi        # 23a640 <_k_heap_list_end>
    83a8:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
    83ac:	e8 35 2c 02 00       	callq  2afe6 <z_impl_k_mutex_lock>
		return -ENOENT;
	}

	k_mutex_lock(&settings_lock, K_FOREVER);

	rc = cs->cs_itf->csi_save(cs, name, (char *)value, val_len);
    83b1:	48 8b 43 08          	mov    0x8(%rbx),%rax
    83b5:	48 89 ee             	mov    %rbp,%rsi
    83b8:	4c 89 e9             	mov    %r13,%rcx
    83bb:	4c 89 e2             	mov    %r12,%rdx
    83be:	48 89 df             	mov    %rbx,%rdi
    83c1:	ff 50 10             	callq  *0x10(%rax)
    83c4:	89 c5                	mov    %eax,%ebp
	return z_impl_k_mutex_unlock(mutex);
    83c6:	48 8d 3d 73 22 23 00 	lea    0x232273(%rip),%rdi        # 23a640 <_k_heap_list_end>
    83cd:	e8 39 2d 02 00       	callq  2b10b <z_impl_k_mutex_unlock>

	k_mutex_unlock(&settings_lock);

	return rc;
}
    83d2:	5a                   	pop    %rdx
    83d3:	89 e8                	mov    %ebp,%eax
    83d5:	5b                   	pop    %rbx
    83d6:	5d                   	pop    %rbp
    83d7:	41 5c                	pop    %r12
    83d9:	41 5d                	pop    %r13
    83db:	c3                   	retq   

00000000000083dc <settings_load_subtree>:
{
    83dc:	41 54                	push   %r12
	const struct settings_load_arg arg = {
    83de:	0f 57 c0             	xorps  %xmm0,%xmm0
{
    83e1:	55                   	push   %rbp
    83e2:	53                   	push   %rbx
    83e3:	48 89 fd             	mov    %rdi,%rbp
    83e6:	48 83 ec 20          	sub    $0x20,%rsp
    83ea:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    83f1:	00 00 
    83f3:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    83f8:	31 c0                	xor    %eax,%eax
	const struct settings_load_arg arg = {
    83fa:	0f 11 44 24 08       	movups %xmm0,0x8(%rsp)
    83ff:	48 89 3c 24          	mov    %rdi,(%rsp)
	return z_impl_k_mutex_lock(mutex, timeout);
    8403:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
    8407:	48 8d 3d 32 22 23 00 	lea    0x232232(%rip),%rdi        # 23a640 <_k_heap_list_end>
    840e:	e8 d3 2b 02 00       	callq  2afe6 <z_impl_k_mutex_lock>
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_load_srcs, cs, cs_next) {
    8413:	48 8d 05 b6 f8 24 00 	lea    0x24f8b6(%rip),%rax        # 257cd0 <settings_load_srcs>
    841a:	48 8b 18             	mov    (%rax),%rbx
    841d:	48 85 db             	test   %rbx,%rbx
    8420:	74 17                	je     8439 <settings_load_subtree+0x5d>
		cs->cs_itf->csi_load(cs, &arg);
    8422:	49 89 e4             	mov    %rsp,%r12
    8425:	48 8b 43 08          	mov    0x8(%rbx),%rax
    8429:	48 89 df             	mov    %rbx,%rdi
    842c:	4c 89 e6             	mov    %r12,%rsi
    842f:	ff 10                	callq  *(%rax)

#define SYS_SLIST_STATIC_INIT(ptr_to_list) {NULL, NULL}

static inline sys_snode_t *z_snode_next_peek(sys_snode_t *node)
{
	return node->next;
    8431:	48 8b 1b             	mov    (%rbx),%rbx
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_load_srcs, cs, cs_next) {
    8434:	48 85 db             	test   %rbx,%rbx
    8437:	75 ec                	jne    8425 <settings_load_subtree+0x49>
	rc = settings_commit_subtree(subtree);
    8439:	48 89 ef             	mov    %rbp,%rdi
    843c:	e8 96 02 00 00       	callq  86d7 <settings_commit_subtree>
    8441:	89 c3                	mov    %eax,%ebx
	return z_impl_k_mutex_unlock(mutex);
    8443:	48 8d 3d f6 21 23 00 	lea    0x2321f6(%rip),%rdi        # 23a640 <_k_heap_list_end>
    844a:	e8 bc 2c 02 00       	callq  2b10b <z_impl_k_mutex_unlock>
}
    844f:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
    8454:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
    845b:	00 00 
    845d:	89 d8                	mov    %ebx,%eax
    845f:	74 05                	je     8466 <settings_load_subtree+0x8a>
    8461:	e8 da c1 ff ff       	callq  4640 <__stack_chk_fail@plt>
    8466:	48 83 c4 20          	add    $0x20,%rsp
    846a:	5b                   	pop    %rbx
    846b:	5d                   	pop    %rbp
    846c:	41 5c                	pop    %r12
    846e:	c3                   	retq   

000000000000846f <settings_load>:
	return settings_load_subtree(NULL);
    846f:	31 ff                	xor    %edi,%edi
    8471:	e9 66 ff ff ff       	jmpq   83dc <settings_load_subtree>

0000000000008476 <settings_load_subtree_direct>:
{
    8476:	55                   	push   %rbp
    8477:	53                   	push   %rbx
    8478:	48 83 ec 28          	sub    $0x28,%rsp
    847c:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    8483:	00 00 
    8485:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    848a:	31 c0                	xor    %eax,%eax
	const struct settings_load_arg arg = {
    848c:	48 89 3c 24          	mov    %rdi,(%rsp)
    8490:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
    8495:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
	return z_impl_k_mutex_lock(mutex, timeout);
    849a:	48 8d 3d 9f 21 23 00 	lea    0x23219f(%rip),%rdi        # 23a640 <_k_heap_list_end>
    84a1:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
    84a5:	e8 3c 2b 02 00       	callq  2afe6 <z_impl_k_mutex_lock>
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_load_srcs, cs, cs_next) {
    84aa:	48 8d 05 1f f8 24 00 	lea    0x24f81f(%rip),%rax        # 257cd0 <settings_load_srcs>
    84b1:	48 8b 18             	mov    (%rax),%rbx
    84b4:	48 85 db             	test   %rbx,%rbx
    84b7:	74 17                	je     84d0 <settings_load_subtree_direct+0x5a>
		cs->cs_itf->csi_load(cs, &arg);
    84b9:	48 89 e5             	mov    %rsp,%rbp
    84bc:	48 8b 43 08          	mov    0x8(%rbx),%rax
    84c0:	48 89 df             	mov    %rbx,%rdi
    84c3:	48 89 ee             	mov    %rbp,%rsi
    84c6:	ff 10                	callq  *(%rax)
    84c8:	48 8b 1b             	mov    (%rbx),%rbx
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_load_srcs, cs, cs_next) {
    84cb:	48 85 db             	test   %rbx,%rbx
    84ce:	75 ec                	jne    84bc <settings_load_subtree_direct+0x46>
	return z_impl_k_mutex_unlock(mutex);
    84d0:	48 8d 3d 69 21 23 00 	lea    0x232169(%rip),%rdi        # 23a640 <_k_heap_list_end>
    84d7:	e8 2f 2c 02 00       	callq  2b10b <z_impl_k_mutex_unlock>
}
    84dc:	31 c0                	xor    %eax,%eax
    84de:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    84e3:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    84ea:	00 00 
    84ec:	74 05                	je     84f3 <settings_load_subtree_direct+0x7d>
    84ee:	e8 4d c1 ff ff       	callq  4640 <__stack_chk_fail@plt>
    84f3:	48 83 c4 28          	add    $0x28,%rsp
    84f7:	5b                   	pop    %rbx
    84f8:	5d                   	pop    %rbp
    84f9:	c3                   	retq   

00000000000084fa <settings_delete>:

int settings_delete(const char *name)
{
	return settings_save_one(name, NULL, 0);
    84fa:	31 d2                	xor    %edx,%edx
    84fc:	31 f6                	xor    %esi,%esi
    84fe:	e9 77 fe ff ff       	jmpq   837a <settings_save_one>

0000000000008503 <settings_store_init>:
	list->head = NULL;
    8503:	48 8d 05 c6 f7 24 00 	lea    0x24f7c6(%rip),%rax        # 257cd0 <settings_load_srcs>
    850a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	list->tail = NULL;
    8511:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
    8518:	00 
}

void settings_store_init(void)
{
	sys_slist_init(&settings_load_srcs);
}
    8519:	c3                   	retq   

000000000000851a <settings_init>:
	list->head = NULL;
    851a:	48 8d 05 bf f7 24 00 	lea    0x24f7bf(%rip),%rax        # 257ce0 <settings_handlers>
    8521:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	list->tail = NULL;
    8528:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
    852f:	00 
void settings_init(void)
{
#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	sys_slist_init(&settings_handlers);
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */
	settings_store_init();
    8530:	e9 ce ff ff ff       	jmpq   8503 <settings_store_init>

0000000000008535 <settings_name_steq>:
}
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */

int settings_name_steq(const char *name, const char *key, const char **next)
{
	if (next) {
    8535:	48 85 d2             	test   %rdx,%rdx
    8538:	74 07                	je     8541 <settings_name_steq+0xc>
		*next = NULL;
    853a:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
	}

	if ((!name) || (!key)) {
    8541:	48 85 ff             	test   %rdi,%rdi
    8544:	74 1e                	je     8564 <settings_name_steq+0x2f>
    8546:	48 85 f6             	test   %rsi,%rsi
    8549:	74 19                	je     8564 <settings_name_steq+0x2f>
	/* name might come from flash directly, in flash the name would end
	 * with '=' or '\0' depending how storage is done. Flash reading is
	 * limited to what can be read
	 */

	while ((*key != '\0') && (*key == *name) &&
    854b:	8a 06                	mov    (%rsi),%al
    854d:	8a 0f                	mov    (%rdi),%cl
    854f:	84 c0                	test   %al,%al
    8551:	74 14                	je     8567 <settings_name_steq+0x32>
	       (*name != '\0') && (*name != SETTINGS_NAME_END)) {
    8553:	80 f9 3d             	cmp    $0x3d,%cl
    8556:	74 0c                	je     8564 <settings_name_steq+0x2f>
    8558:	38 c8                	cmp    %cl,%al
    855a:	75 08                	jne    8564 <settings_name_steq+0x2f>
		key++;
    855c:	48 ff c6             	inc    %rsi
		name++;
    855f:	48 ff c7             	inc    %rdi
    8562:	eb e7                	jmp    854b <settings_name_steq+0x16>
		return 0;
    8564:	31 c0                	xor    %eax,%eax
    8566:	c3                   	retq   

	if (*key != '\0') {
		return 0;
	}

	if (*name == SETTINGS_NAME_SEPARATOR) {
    8567:	80 f9 2f             	cmp    $0x2f,%cl
    856a:	75 11                	jne    857d <settings_name_steq+0x48>
		if (next) {
    856c:	48 85 d2             	test   %rdx,%rdx
			*next = name + 1;
		}
		return 1;
    856f:	b8 01 00 00 00       	mov    $0x1,%eax
		if (next) {
    8574:	74 18                	je     858e <settings_name_steq+0x59>
			*next = name + 1;
    8576:	48 ff c7             	inc    %rdi
    8579:	48 89 3a             	mov    %rdi,(%rdx)
    857c:	c3                   	retq   
	}

	if ((*name == SETTINGS_NAME_END) || (*name == '\0')) {
    857d:	80 f9 3d             	cmp    $0x3d,%cl
    8580:	0f 94 c0             	sete   %al
    8583:	84 c9                	test   %cl,%cl
    8585:	0f 94 c2             	sete   %dl
    8588:	09 d0                	or     %edx,%eax
		return 0;
    858a:	0f b6 c0             	movzbl %al,%eax
    858d:	c3                   	retq   
		return 1;
	}

	return 0;
}
    858e:	c3                   	retq   

000000000000858f <settings_name_next>:

int settings_name_next(const char *name, const char **next)
{
	int rc = 0;

	if (next) {
    858f:	48 85 f6             	test   %rsi,%rsi
    8592:	74 07                	je     859b <settings_name_next+0xc>
		*next = NULL;
    8594:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
	}

	if (!name) {
		return 0;
    859b:	31 c0                	xor    %eax,%eax
	if (!name) {
    859d:	48 85 ff             	test   %rdi,%rdi
    85a0:	48 89 fa             	mov    %rdi,%rdx
    85a3:	74 2a                	je     85cf <settings_name_next+0x40>

	/* name might come from flash directly, in flash the name would end
	 * with '=' or '\0' depending how storage is done. Flash reading is
	 * limited to what can be read
	 */
	while ((*name != '\0') && (*name != SETTINGS_NAME_END) &&
    85a5:	8a 0a                	mov    (%rdx),%cl
    85a7:	89 d0                	mov    %edx,%eax
    85a9:	29 f8                	sub    %edi,%eax
    85ab:	84 c9                	test   %cl,%cl
    85ad:	74 0f                	je     85be <settings_name_next+0x2f>
    85af:	80 f9 3d             	cmp    $0x3d,%cl
    85b2:	74 0a                	je     85be <settings_name_next+0x2f>
    85b4:	80 f9 2f             	cmp    $0x2f,%cl
    85b7:	74 0a                	je     85c3 <settings_name_next+0x34>
	       (*name != SETTINGS_NAME_SEPARATOR)) {
		rc++;
		name++;
    85b9:	48 ff c2             	inc    %rdx
    85bc:	eb e7                	jmp    85a5 <settings_name_next+0x16>
	}

	if (*name == SETTINGS_NAME_SEPARATOR) {
    85be:	80 f9 2f             	cmp    $0x2f,%cl
    85c1:	75 0c                	jne    85cf <settings_name_next+0x40>
		if (next) {
    85c3:	48 85 f6             	test   %rsi,%rsi
    85c6:	75 01                	jne    85c9 <settings_name_next+0x3a>
    85c8:	c3                   	retq   
			*next = name + 1;
    85c9:	48 ff c2             	inc    %rdx
    85cc:	48 89 16             	mov    %rdx,(%rsi)
		}
		return rc;
	}

	return rc;
}
    85cf:	c3                   	retq   

00000000000085d0 <settings_parse_and_lookup>:

struct settings_handler_static *settings_parse_and_lookup(const char *name,
							const char **next)
{
    85d0:	41 56                	push   %r14
    85d2:	41 55                	push   %r13
    85d4:	49 89 fd             	mov    %rdi,%r13
    85d7:	41 54                	push   %r12
    85d9:	55                   	push   %rbp
    85da:	49 89 f4             	mov    %rsi,%r12
    85dd:	53                   	push   %rbx
    85de:	48 83 ec 10          	sub    $0x10,%rsp
    85e2:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    85e9:	00 00 
    85eb:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    85f0:	31 c0                	xor    %eax,%eax
	struct settings_handler_static *bestmatch;
	const char *tmpnext;

	bestmatch = NULL;
	if (next) {
    85f2:	48 85 f6             	test   %rsi,%rsi
    85f5:	74 07                	je     85fe <settings_parse_and_lookup+0x2e>
		*next = NULL;
    85f7:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
    85fe:	48 8d 1d 93 1c 23 00 	lea    0x231c93(%rip),%rbx        # 23a298 <_bt_gatt_service_static_list_end>
    8605:	31 ed                	xor    %ebp,%ebp
	}

	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    8607:	48 3b 1d 62 d9 22 00 	cmp    0x22d962(%rip),%rbx        # 235f70 <_GLOBAL_OFFSET_TABLE_+0x290>
    860e:	73 3f                	jae    864f <settings_parse_and_lookup+0x7f>
		if (!settings_name_steq(name, ch->name, &tmpnext)) {
    8610:	48 8b 33             	mov    (%rbx),%rsi
    8613:	48 89 e2             	mov    %rsp,%rdx
    8616:	4c 89 ef             	mov    %r13,%rdi
    8619:	e8 17 ff ff ff       	callq  8535 <settings_name_steq>
    861e:	85 c0                	test   %eax,%eax
    8620:	74 27                	je     8649 <settings_parse_and_lookup+0x79>
			continue;
		}
		if (!bestmatch) {
    8622:	48 85 ed             	test   %rbp,%rbp
    8625:	74 12                	je     8639 <settings_parse_and_lookup+0x69>
			if (next) {
				*next = tmpnext;
			}
			continue;
		}
		if (settings_name_steq(ch->name, bestmatch->name, NULL)) {
    8627:	48 8b 75 00          	mov    0x0(%rbp),%rsi
    862b:	48 8b 3b             	mov    (%rbx),%rdi
    862e:	31 d2                	xor    %edx,%edx
    8630:	e8 00 ff ff ff       	callq  8535 <settings_name_steq>
    8635:	85 c0                	test   %eax,%eax
    8637:	74 10                	je     8649 <settings_parse_and_lookup+0x79>
			bestmatch = ch;
			if (next) {
    8639:	4d 85 e4             	test   %r12,%r12
    863c:	48 89 dd             	mov    %rbx,%rbp
    863f:	74 08                	je     8649 <settings_parse_and_lookup+0x79>
				*next = tmpnext;
    8641:	48 8b 04 24          	mov    (%rsp),%rax
    8645:	49 89 04 24          	mov    %rax,(%r12)
	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    8649:	48 83 c3 28          	add    $0x28,%rbx
    864d:	eb b8                	jmp    8607 <settings_parse_and_lookup+0x37>
	}

#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	struct settings_handler *ch;

	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
    864f:	48 8d 05 8a f6 24 00 	lea    0x24f68a(%rip),%rax        # 257ce0 <settings_handlers>
    8656:	48 8b 18             	mov    (%rax),%rbx
    8659:	48 85 db             	test   %rbx,%rbx
    865c:	74 54                	je     86b2 <settings_parse_and_lookup+0xe2>
    865e:	48 83 eb 28          	sub    $0x28,%rbx
		if (!settings_name_steq(name, ch->name, &tmpnext)) {
    8662:	49 89 e6             	mov    %rsp,%r14
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
    8665:	48 85 db             	test   %rbx,%rbx
    8668:	74 48                	je     86b2 <settings_parse_and_lookup+0xe2>
		if (!settings_name_steq(name, ch->name, &tmpnext)) {
    866a:	48 8b 33             	mov    (%rbx),%rsi
    866d:	4c 89 f2             	mov    %r14,%rdx
    8670:	4c 89 ef             	mov    %r13,%rdi
    8673:	e8 bd fe ff ff       	callq  8535 <settings_name_steq>
    8678:	85 c0                	test   %eax,%eax
    867a:	74 27                	je     86a3 <settings_parse_and_lookup+0xd3>
			continue;
		}
		if (!bestmatch) {
    867c:	48 85 ed             	test   %rbp,%rbp
    867f:	74 12                	je     8693 <settings_parse_and_lookup+0xc3>
			if (next) {
				*next = tmpnext;
			}
			continue;
		}
		if (settings_name_steq(ch->name, bestmatch->name, NULL)) {
    8681:	48 8b 75 00          	mov    0x0(%rbp),%rsi
    8685:	48 8b 3b             	mov    (%rbx),%rdi
    8688:	31 d2                	xor    %edx,%edx
    868a:	e8 a6 fe ff ff       	callq  8535 <settings_name_steq>
    868f:	85 c0                	test   %eax,%eax
    8691:	74 10                	je     86a3 <settings_parse_and_lookup+0xd3>
			bestmatch = (struct settings_handler_static *)ch;
			if (next) {
    8693:	4d 85 e4             	test   %r12,%r12
    8696:	48 89 dd             	mov    %rbx,%rbp
    8699:	74 08                	je     86a3 <settings_parse_and_lookup+0xd3>
				*next = tmpnext;
    869b:	48 8b 04 24          	mov    (%rsp),%rax
    869f:	49 89 04 24          	mov    %rax,(%r12)
	return node->next;
    86a3:	48 8b 5b 28          	mov    0x28(%rbx),%rbx
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
    86a7:	48 85 db             	test   %rbx,%rbx
    86aa:	74 06                	je     86b2 <settings_parse_and_lookup+0xe2>
    86ac:	48 83 eb 28          	sub    $0x28,%rbx
    86b0:	eb b3                	jmp    8665 <settings_parse_and_lookup+0x95>
			}
		}
	}
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */
	return bestmatch;
}
    86b2:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    86b7:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    86be:	00 00 
    86c0:	48 89 e8             	mov    %rbp,%rax
    86c3:	74 05                	je     86ca <settings_parse_and_lookup+0xfa>
    86c5:	e8 76 bf ff ff       	callq  4640 <__stack_chk_fail@plt>
    86ca:	48 83 c4 10          	add    $0x10,%rsp
    86ce:	5b                   	pop    %rbx
    86cf:	5d                   	pop    %rbp
    86d0:	41 5c                	pop    %r12
    86d2:	41 5d                	pop    %r13
    86d4:	41 5e                	pop    %r14
    86d6:	c3                   	retq   

00000000000086d7 <settings_commit_subtree>:
{
	return settings_commit_subtree(NULL);
}

int settings_commit_subtree(const char *subtree)
{
    86d7:	41 54                	push   %r12
    86d9:	55                   	push   %rbp
    86da:	49 89 fc             	mov    %rdi,%r12
    86dd:	53                   	push   %rbx
	int rc;
	int rc2;

	rc = 0;

	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    86de:	48 8d 1d b3 1b 23 00 	lea    0x231bb3(%rip),%rbx        # 23a298 <_bt_gatt_service_static_list_end>
	rc = 0;
    86e5:	31 ed                	xor    %ebp,%ebp
	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    86e7:	48 3b 1d 82 d8 22 00 	cmp    0x22d882(%rip),%rbx        # 235f70 <_GLOBAL_OFFSET_TABLE_+0x290>
    86ee:	73 2e                	jae    871e <settings_commit_subtree+0x47>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
    86f0:	4d 85 e4             	test   %r12,%r12
    86f3:	75 12                	jne    8707 <settings_commit_subtree+0x30>
			continue;
		}
		if (ch->h_commit) {
    86f5:	48 8b 43 18          	mov    0x18(%rbx),%rax
    86f9:	48 85 c0             	test   %rax,%rax
    86fc:	74 1a                	je     8718 <settings_commit_subtree+0x41>
			rc2 = ch->h_commit();
    86fe:	ff d0                	callq  *%rax
			if (!rc) {
				rc = rc2;
    8700:	85 ed                	test   %ebp,%ebp
    8702:	0f 44 e8             	cmove  %eax,%ebp
    8705:	eb 11                	jmp    8718 <settings_commit_subtree+0x41>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
    8707:	48 8b 3b             	mov    (%rbx),%rdi
    870a:	31 d2                	xor    %edx,%edx
    870c:	4c 89 e6             	mov    %r12,%rsi
    870f:	e8 21 fe ff ff       	callq  8535 <settings_name_steq>
    8714:	85 c0                	test   %eax,%eax
    8716:	75 dd                	jne    86f5 <settings_commit_subtree+0x1e>
	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    8718:	48 83 c3 28          	add    $0x28,%rbx
    871c:	eb c9                	jmp    86e7 <settings_commit_subtree+0x10>
		}
	}

#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	struct settings_handler *ch;
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
    871e:	48 8d 05 bb f5 24 00 	lea    0x24f5bb(%rip),%rax        # 257ce0 <settings_handlers>
    8725:	48 8b 18             	mov    (%rax),%rbx
    8728:	48 85 db             	test   %rbx,%rbx
    872b:	74 37                	je     8764 <settings_commit_subtree+0x8d>
    872d:	48 83 eb 28          	sub    $0x28,%rbx
    8731:	48 85 db             	test   %rbx,%rbx
    8734:	74 2e                	je     8764 <settings_commit_subtree+0x8d>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
    8736:	4d 85 e4             	test   %r12,%r12
    8739:	75 12                	jne    874d <settings_commit_subtree+0x76>
			continue;
		}
		if (ch->h_commit) {
    873b:	48 8b 43 18          	mov    0x18(%rbx),%rax
    873f:	48 85 c0             	test   %rax,%rax
    8742:	74 1a                	je     875e <settings_commit_subtree+0x87>
			rc2 = ch->h_commit();
    8744:	ff d0                	callq  *%rax
			if (!rc) {
				rc = rc2;
    8746:	85 ed                	test   %ebp,%ebp
    8748:	0f 44 e8             	cmove  %eax,%ebp
    874b:	eb 11                	jmp    875e <settings_commit_subtree+0x87>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
    874d:	48 8b 3b             	mov    (%rbx),%rdi
    8750:	31 d2                	xor    %edx,%edx
    8752:	4c 89 e6             	mov    %r12,%rsi
    8755:	e8 db fd ff ff       	callq  8535 <settings_name_steq>
    875a:	85 c0                	test   %eax,%eax
    875c:	75 dd                	jne    873b <settings_commit_subtree+0x64>
    875e:	48 8b 5b 28          	mov    0x28(%rbx),%rbx
    8762:	eb c4                	jmp    8728 <settings_commit_subtree+0x51>
		}
	}
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */

	return rc;
}
    8764:	89 e8                	mov    %ebp,%eax
    8766:	5b                   	pop    %rbx
    8767:	5d                   	pop    %rbp
    8768:	41 5c                	pop    %r12
    876a:	c3                   	retq   

000000000000876b <settings_subsys_init>:
void settings_init(void);

int settings_backend_init(void);

int settings_subsys_init(void)
{
    876b:	53                   	push   %rbx

	int err = 0;

	if (settings_subsys_initialized) {
    876c:	48 8d 1d 70 69 25 00 	lea    0x256970(%rip),%rbx        # 25f0e3 <settings_subsys_initialized>
		return 0;
    8773:	31 c0                	xor    %eax,%eax
	if (settings_subsys_initialized) {
    8775:	80 3b 00             	cmpb   $0x0,(%rbx)
    8778:	75 11                	jne    878b <settings_subsys_init+0x20>
	}

	settings_init();
    877a:	e8 9b fd ff ff       	callq  851a <settings_init>

	err = settings_backend_init(); /* func rises kernel panic once error */
    877f:	e8 9e 00 00 00       	callq  8822 <settings_backend_init>

	if (!err) {
    8784:	85 c0                	test   %eax,%eax
    8786:	75 03                	jne    878b <settings_subsys_init+0x20>
		settings_subsys_initialized = true;
    8788:	c6 03 01             	movb   $0x1,(%rbx)
	}

	return err;
}
    878b:	5b                   	pop    %rbx
    878c:	c3                   	retq   

000000000000878d <settings_runtime_read_cb>:

static ssize_t settings_runtime_read_cb(void *cb_arg, void *data, size_t len)
{
	struct read_cb_arg *arg = (struct read_cb_arg *)cb_arg;

	memcpy(data, arg->data, MIN(arg->len, len));
    878d:	48 39 57 08          	cmp    %rdx,0x8(%rdi)
{
    8791:	49 89 f0             	mov    %rsi,%r8
	memcpy(data, arg->data, MIN(arg->len, len));
    8794:	48 89 d1             	mov    %rdx,%rcx
    8797:	48 0f 46 4f 08       	cmovbe 0x8(%rdi),%rcx
{
    879c:	48 89 f8             	mov    %rdi,%rax
    879f:	48 8b 37             	mov    (%rdi),%rsi
    87a2:	4c 89 c7             	mov    %r8,%rdi
    87a5:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
	return MIN(arg->len, len);
    87a7:	48 39 50 08          	cmp    %rdx,0x8(%rax)
    87ab:	48 0f 46 50 08       	cmovbe 0x8(%rax),%rdx
    87b0:	48 89 d0             	mov    %rdx,%rax
}
    87b3:	c3                   	retq   

00000000000087b4 <settings_runtime_set>:

int settings_runtime_set(const char *name, const void *data, size_t len)
{
    87b4:	55                   	push   %rbp
    87b5:	53                   	push   %rbx
    87b6:	48 89 f5             	mov    %rsi,%rbp
    87b9:	48 89 d3             	mov    %rdx,%rbx
    87bc:	48 83 ec 28          	sub    $0x28,%rsp
	struct settings_handler_static *ch;
	const char *name_key;
	struct read_cb_arg arg;

	ch = settings_parse_and_lookup(name, &name_key);
    87c0:	48 89 e6             	mov    %rsp,%rsi
{
    87c3:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    87ca:	00 00 
    87cc:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    87d1:	31 c0                	xor    %eax,%eax
	ch = settings_parse_and_lookup(name, &name_key);
    87d3:	e8 f8 fd ff ff       	callq  85d0 <settings_parse_and_lookup>
    87d8:	49 89 c0             	mov    %rax,%r8
    87db:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (!ch) {
    87e0:	4d 85 c0             	test   %r8,%r8
    87e3:	74 21                	je     8806 <settings_runtime_set+0x52>
		return -EINVAL;
	}

	arg.data = data;
    87e5:	48 89 6c 24 08       	mov    %rbp,0x8(%rsp)
	arg.len = len;
    87ea:	48 89 5c 24 10       	mov    %rbx,0x10(%rsp)
	return ch->h_set(name_key, len, settings_runtime_read_cb, (void *)&arg);
    87ef:	48 8d 4c 24 08       	lea    0x8(%rsp),%rcx
    87f4:	48 8d 15 92 ff ff ff 	lea    -0x6e(%rip),%rdx        # 878d <settings_runtime_read_cb>
    87fb:	48 89 de             	mov    %rbx,%rsi
    87fe:	48 8b 3c 24          	mov    (%rsp),%rdi
    8802:	41 ff 50 10          	callq  *0x10(%r8)
}
    8806:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
    880b:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
    8812:	00 00 
    8814:	74 05                	je     881b <settings_runtime_set+0x67>
    8816:	e8 25 be ff ff       	callq  4640 <__stack_chk_fail@plt>
    881b:	48 83 c4 28          	add    $0x28,%rsp
    881f:	5b                   	pop    %rbx
    8820:	5d                   	pop    %rbp
    8821:	c3                   	retq   

0000000000008822 <settings_backend_init>:
 */

int settings_backend_init(void)
{
	return 0;
}
    8822:	31 c0                	xor    %eax,%eax
    8824:	c3                   	retq   

0000000000008825 <native_posix_console_init>:
	}
}
#endif /* CONFIG_NATIVE_POSIX_STDIN_CONSOLE */

static int native_posix_console_init(const struct device *arg)
{
    8825:	48 83 ec 08          	sub    $0x8,%rsp
	setvbuf(stdout, NULL, _IOLBF, 512);
    8829:	48 8b 05 10 d7 22 00 	mov    0x22d710(%rip),%rax        # 235f40 <stdout@GLIBC_2.2.5>
    8830:	b9 00 02 00 00       	mov    $0x200,%ecx
    8835:	ba 01 00 00 00       	mov    $0x1,%edx
    883a:	31 f6                	xor    %esi,%esi
    883c:	48 8b 38             	mov    (%rax),%rdi
    883f:	e8 fc ba ff ff       	callq  4340 <setvbuf@plt>
	setvbuf(stderr, NULL, _IOLBF, 512);
    8844:	48 8b 05 3d d7 22 00 	mov    0x22d73d(%rip),%rax        # 235f88 <stderr@GLIBC_2.2.5>
    884b:	ba 01 00 00 00       	mov    $0x1,%edx
    8850:	b9 00 02 00 00       	mov    $0x200,%ecx
    8855:	31 f6                	xor    %esi,%esi
    8857:	48 8b 38             	mov    (%rax),%rdi
    885a:	e8 e1 ba ff ff       	callq  4340 <setvbuf@plt>
	__printk_hook_install(putchar);
    885f:	48 8b 3d 2a d7 22 00 	mov    0x22d72a(%rip),%rdi        # 235f90 <putchar@GLIBC_2.2.5>
    8866:	e8 cd d0 ff ff       	callq  5938 <__printk_hook_install>
#if defined(CONFIG_NATIVE_POSIX_STDOUT_CONSOLE)
	native_posix_stdout_init();
#endif

	return 0;
}
    886b:	31 c0                	xor    %eax,%eax
    886d:	5a                   	pop    %rdx
    886e:	c3                   	retq   

000000000000886f <sdl_display_write_mono>:
			"Input buffer height not aligned per 8 pixels");

	if (one_is_black) {
		one_color = 0U;
	} else {
		one_color = 0x00FFFFFF;
    886f:	80 f9 01             	cmp    $0x1,%cl
	}

	for (tile_idx = 0U; tile_idx < desc->height/8U; ++tile_idx) {
    8872:	66 8b 4e 06          	mov    0x6(%rsi),%cx
{
    8876:	41 57                	push   %r15
		one_color = 0x00FFFFFF;
    8878:	45 19 db             	sbb    %r11d,%r11d
{
    887b:	41 56                	push   %r14
    887d:	41 55                	push   %r13
		one_color = 0x00FFFFFF;
    887f:	41 81 e3 ff ff ff 00 	and    $0xffffff,%r11d
{
    8886:	41 54                	push   %r12
    8888:	55                   	push   %rbp
			disp_buf_start = disp_buf;
			for (h_idx = 0U; h_idx < 8; ++h_idx) {
				if ((*byte_ptr & BIT(7-h_idx)) != 0U)  {
					pixel = one_color;
				} else {
					pixel = (~one_color) & 0x00FFFFFF;
    8889:	44 89 d8             	mov    %r11d,%eax
{
    888c:	53                   	push   %rbx
	for (tile_idx = 0U; tile_idx < desc->height/8U; ++tile_idx) {
    888d:	66 c1 e9 03          	shr    $0x3,%cx
					pixel = (~one_color) & 0x00FFFFFF;
    8891:	35 ff ff ff 00       	xor    $0xffffff,%eax
	for (tile_idx = 0U; tile_idx < desc->height/8U; ++tile_idx) {
    8896:	0f b7 c9             	movzwl %cx,%ecx
    8899:	45 31 d2             	xor    %r10d,%r10d
					pixel = (~one_color) & 0x00FFFFFF;
    889c:	89 44 24 fc          	mov    %eax,-0x4(%rsp)
	for (tile_idx = 0U; tile_idx < desc->height/8U; ++tile_idx) {
    88a0:	44 39 d1             	cmp    %r10d,%ecx
    88a3:	76 72                	jbe    8917 <sdl_display_write_mono+0xa8>
		for (w_idx = 0U; w_idx < desc->width; ++w_idx) {
    88a5:	44 0f b7 4e 04       	movzwl 0x4(%rsi),%r9d
				}
				*((uint32_t *)disp_buf) = pixel;
				disp_buf += (desc->width * 4U);
    88aa:	48 89 fd             	mov    %rdi,%rbp
		for (w_idx = 0U; w_idx < desc->width; ++w_idx) {
    88ad:	45 31 c0             	xor    %r8d,%r8d
    88b0:	41 0f b7 c1          	movzwl %r9w,%eax
				disp_buf += (desc->width * 4U);
    88b4:	8d 1c 85 00 00 00 00 	lea    0x0(,%rax,4),%ebx
    88bb:	48 89 5c 24 f0       	mov    %rbx,-0x10(%rsp)
		for (w_idx = 0U; w_idx < desc->width; ++w_idx) {
    88c0:	44 39 c0             	cmp    %r8d,%eax
    88c3:	76 43                	jbe    8908 <sdl_display_write_mono+0x99>
				((tile_idx * desc->pitch) + w_idx);
    88c5:	0f b7 5e 08          	movzwl 0x8(%rsi),%ebx
			byte_ptr = (const uint8_t *)buf +
    88c9:	49 89 ec             	mov    %rbp,%r12
				((tile_idx * desc->pitch) + w_idx);
    88cc:	41 0f af da          	imul   %r10d,%ebx
    88d0:	46 8d 2c 03          	lea    (%rbx,%r8,1),%r13d
			byte_ptr = (const uint8_t *)buf +
    88d4:	bb 07 00 00 00       	mov    $0x7,%ebx
    88d9:	49 01 d5             	add    %rdx,%r13
				if ((*byte_ptr & BIT(7-h_idx)) != 0U)  {
    88dc:	45 0f b6 7d 00       	movzbl 0x0(%r13),%r15d
					pixel = one_color;
    88e1:	45 89 de             	mov    %r11d,%r14d
				if ((*byte_ptr & BIT(7-h_idx)) != 0U)  {
    88e4:	49 0f a3 df          	bt     %rbx,%r15
    88e8:	72 05                	jb     88ef <sdl_display_write_mono+0x80>
					pixel = (~one_color) & 0x00FFFFFF;
    88ea:	44 8b 74 24 fc       	mov    -0x4(%rsp),%r14d
    88ef:	ff cb                	dec    %ebx
				*((uint32_t *)disp_buf) = pixel;
    88f1:	45 89 34 24          	mov    %r14d,(%r12)
				disp_buf += (desc->width * 4U);
    88f5:	4c 03 64 24 f0       	add    -0x10(%rsp),%r12
			for (h_idx = 0U; h_idx < 8; ++h_idx) {
    88fa:	83 fb ff             	cmp    $0xffffffff,%ebx
    88fd:	75 dd                	jne    88dc <sdl_display_write_mono+0x6d>
			}
			disp_buf = disp_buf_start;
			disp_buf += 4;
    88ff:	48 83 c5 04          	add    $0x4,%rbp
		for (w_idx = 0U; w_idx < desc->width; ++w_idx) {
    8903:	41 ff c0             	inc    %r8d
    8906:	eb b8                	jmp    88c0 <sdl_display_write_mono+0x51>
		}
		disp_buf += 7 * (desc->width * 4U);
    8908:	6b c0 1c             	imul   $0x1c,%eax,%eax
	for (tile_idx = 0U; tile_idx < desc->height/8U; ++tile_idx) {
    890b:	41 ff c2             	inc    %r10d
		disp_buf += 7 * (desc->width * 4U);
    890e:	4a 8d 04 88          	lea    (%rax,%r9,4),%rax
    8912:	48 01 c7             	add    %rax,%rdi
    8915:	eb 89                	jmp    88a0 <sdl_display_write_mono+0x31>
	}
}
    8917:	5b                   	pop    %rbx
    8918:	5d                   	pop    %rbp
    8919:	41 5c                	pop    %r12
    891b:	41 5d                	pop    %r13
    891d:	41 5e                	pop    %r14
    891f:	41 5f                	pop    %r15
    8921:	c3                   	retq   

0000000000008922 <sdl_display_get_framebuffer>:
}

static void *sdl_display_get_framebuffer(const struct device *dev)
{
	return NULL;
}
    8922:	31 c0                	xor    %eax,%eax
    8924:	c3                   	retq   

0000000000008925 <sdl_display_set_brightness>:

static int sdl_display_set_brightness(const struct device *dev,
		const uint8_t brightness)
{
	return -ENOTSUP;
}
    8925:	b8 a1 ff ff ff       	mov    $0xffffffa1,%eax
    892a:	c3                   	retq   

000000000000892b <sdl_display_get_capabilities>:
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    892b:	48 8d 56 08          	lea    0x8(%rsi),%rdx
}

static void sdl_display_get_capabilities(
	const struct device *dev, struct display_capabilities *capabilities)
{
	struct sdl_display_data *disp_data =
    892f:	4c 8b 47 18          	mov    0x18(%rdi),%r8
    8933:	31 c0                	xor    %eax,%eax
    8935:	b9 03 00 00 00       	mov    $0x3,%ecx
    893a:	48 89 d7             	mov    %rdx,%rdi
    893d:	f3 ab                	rep stos %eax,%es:(%rdi)
	    (struct sdl_display_data *)dev->data;

	memset(capabilities, 0, sizeof(struct display_capabilities));
	capabilities->x_resolution = CONFIG_SDL_DISPLAY_X_RES;
    893f:	48 b8 2c 01 5e 00 3f 	movabs $0x3f005e012c,%rax
    8946:	00 00 00 
    8949:	48 89 06             	mov    %rax,(%rsi)
		PIXEL_FORMAT_RGB_888 |
		PIXEL_FORMAT_MONO01 |
		PIXEL_FORMAT_MONO10 |
		PIXEL_FORMAT_RGB_565 |
		PIXEL_FORMAT_BGR_565;
	capabilities->current_pixel_format = disp_data->current_pixel_format;
    894c:	41 8b 40 1c          	mov    0x1c(%r8),%eax
	capabilities->screen_info = SCREEN_INFO_MONO_VTILED |
    8950:	c7 46 08 03 00 00 00 	movl   $0x3,0x8(%rsi)
	capabilities->current_pixel_format = disp_data->current_pixel_format;
    8957:	89 46 0c             	mov    %eax,0xc(%rsi)
		SCREEN_INFO_MONO_MSB_FIRST;
}
    895a:	c3                   	retq   

000000000000895b <sdl_display_read>:
{
    895b:	48 83 ec 28          	sub    $0x28,%rsp
    895f:	48 89 c8             	mov    %rcx,%rax
	rect.y = y;
    8962:	0f b7 d2             	movzwl %dx,%edx
    8965:	89 54 24 0c          	mov    %edx,0xc(%rsp)
	rect.w = desc->width;
    8969:	0f b7 50 04          	movzwl 0x4(%rax),%edx
{
    896d:	4c 89 c1             	mov    %r8,%rcx
	struct sdl_display_data *disp_data =
    8970:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
			desc->pitch * 4U);
    8974:	44 0f b7 40 08       	movzwl 0x8(%rax),%r8d
	rect.x = x;
    8979:	0f b7 f6             	movzwl %si,%esi
    897c:	89 74 24 08          	mov    %esi,0x8(%rsp)
	return SDL_RenderReadPixels(disp_data->renderer, &rect, 0, buf,
    8980:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
{
    8985:	64 4c 8b 0c 25 28 00 	mov    %fs:0x28,%r9
    898c:	00 00 
    898e:	4c 89 4c 24 18       	mov    %r9,0x18(%rsp)
    8993:	45 31 c9             	xor    %r9d,%r9d
	rect.w = desc->width;
    8996:	89 54 24 10          	mov    %edx,0x10(%rsp)
	rect.h = desc->height;
    899a:	0f b7 50 06          	movzwl 0x6(%rax),%edx
	return SDL_RenderReadPixels(disp_data->renderer, &rect, 0, buf,
    899e:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
    89a2:	41 c1 e0 02          	shl    $0x2,%r8d
	rect.h = desc->height;
    89a6:	89 54 24 14          	mov    %edx,0x14(%rsp)
	return SDL_RenderReadPixels(disp_data->renderer, &rect, 0, buf,
    89aa:	31 d2                	xor    %edx,%edx
    89ac:	e8 cf bb ff ff       	callq  4580 <SDL_RenderReadPixels@plt>
}
    89b1:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    89b6:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    89bd:	00 00 
    89bf:	74 05                	je     89c6 <sdl_display_read+0x6b>
    89c1:	e8 7a bc ff ff       	callq  4640 <__stack_chk_fail@plt>
    89c6:	48 83 c4 28          	add    $0x28,%rsp
    89ca:	c3                   	retq   

00000000000089cb <sdl_display_blanking_off>:
{
    89cb:	53                   	push   %rbx
	struct sdl_display_data *disp_data =
    89cc:	48 8b 5f 18          	mov    0x18(%rdi),%rbx
	SDL_RenderClear(disp_data->renderer);
    89d0:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
	disp_data->display_on = true;
    89d4:	c6 43 18 01          	movb   $0x1,0x18(%rbx)
	SDL_RenderClear(disp_data->renderer);
    89d8:	e8 03 bc ff ff       	callq  45e0 <SDL_RenderClear@plt>
	SDL_RenderCopy(disp_data->renderer, disp_data->texture, NULL, NULL);
    89dd:	48 8b 73 10          	mov    0x10(%rbx),%rsi
    89e1:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    89e5:	31 c9                	xor    %ecx,%ecx
    89e7:	31 d2                	xor    %edx,%edx
    89e9:	e8 62 bc ff ff       	callq  4650 <SDL_RenderCopy@plt>
	SDL_RenderPresent(disp_data->renderer);
    89ee:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    89f2:	e8 a9 b9 ff ff       	callq  43a0 <SDL_RenderPresent@plt>
}
    89f7:	31 c0                	xor    %eax,%eax
    89f9:	5b                   	pop    %rbx
    89fa:	c3                   	retq   

00000000000089fb <sdl_display_blanking_on>:
{
    89fb:	53                   	push   %rbx
	struct sdl_display_data *disp_data =
    89fc:	48 8b 5f 18          	mov    0x18(%rdi),%rbx
	SDL_RenderClear(disp_data->renderer);
    8a00:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
	disp_data->display_on = false;
    8a04:	c6 43 18 00          	movb   $0x0,0x18(%rbx)
	SDL_RenderClear(disp_data->renderer);
    8a08:	e8 d3 bb ff ff       	callq  45e0 <SDL_RenderClear@plt>
	SDL_RenderPresent(disp_data->renderer);
    8a0d:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    8a11:	e8 8a b9 ff ff       	callq  43a0 <SDL_RenderPresent@plt>
}
    8a16:	31 c0                	xor    %eax,%eax
    8a18:	5b                   	pop    %rbx
    8a19:	c3                   	retq   

0000000000008a1a <sdl_display_init>:
{
    8a1a:	53                   	push   %rbx
	struct sdl_display_data *disp_data =
    8a1b:	48 8b 5f 18          	mov    0x18(%rdi),%rbx
    8a1f:	31 c0                	xor    %eax,%eax
    8a21:	b9 30 6e 00 00       	mov    $0x6e30,%ecx
	    SDL_CreateWindow("Zephyr Display", SDL_WINDOWPOS_UNDEFINED,
    8a26:	41 b9 04 00 00 00    	mov    $0x4,%r9d
    8a2c:	41 b8 5e 00 00 00    	mov    $0x5e,%r8d
    8a32:	ba 00 00 ff 1f       	mov    $0x1fff0000,%edx
    8a37:	be 00 00 ff 1f       	mov    $0x1fff0000,%esi
    8a3c:	48 89 df             	mov    %rbx,%rdi
    8a3f:	f3 ab                	rep stos %eax,%es:(%rdi)
    8a41:	48 8d 3d 20 88 02 00 	lea    0x28820(%rip),%rdi        # 31268 <__func__.5785+0x600>
	disp_data->current_pixel_format =
    8a48:	c7 43 1c 08 00 00 00 	movl   $0x8,0x1c(%rbx)
	    SDL_CreateWindow("Zephyr Display", SDL_WINDOWPOS_UNDEFINED,
    8a4f:	b9 2c 01 00 00       	mov    $0x12c,%ecx
    8a54:	e8 17 b9 ff ff       	callq  4370 <SDL_CreateWindow@plt>
	if (disp_data->window == NULL) {
    8a59:	48 85 c0             	test   %rax,%rax
	disp_data->window =
    8a5c:	48 89 03             	mov    %rax,(%rbx)
	if (disp_data->window == NULL) {
    8a5f:	75 2e                	jne    8a8f <sdl_display_init+0x75>
    8a61:	48 8d 1d b8 19 23 00 	lea    0x2319b8(%rip),%rbx        # 23a420 <log_const_display_sdl>
    8a68:	48 2b 1d e1 d4 22 00 	sub    0x22d4e1(%rip),%rbx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		LOG_ERR("Failed to create SDL window: %s", SDL_GetError());
    8a6f:	e8 6c ba ff ff       	callq  44e0 <SDL_GetError@plt>
    8a74:	48 8d 3d fc 87 02 00 	lea    0x287fc(%rip),%rdi        # 31277 <__func__.5785+0x60f>
    8a7b:	48 89 c6             	mov    %rax,%rsi
    8a7e:	48 c1 eb 04          	shr    $0x4,%rbx
    8a82:	c1 e3 06             	shl    $0x6,%ebx
    8a85:	83 cb 01             	or     $0x1,%ebx
    8a88:	89 da                	mov    %ebx,%edx
    8a8a:	e9 90 00 00 00       	jmpq   8b1f <sdl_display_init+0x105>
	    SDL_CreateRenderer(disp_data->window, -1, SDL_RENDERER_ACCELERATED);
    8a8f:	83 ce ff             	or     $0xffffffff,%esi
    8a92:	ba 02 00 00 00       	mov    $0x2,%edx
    8a97:	48 89 c7             	mov    %rax,%rdi
    8a9a:	e8 b1 b8 ff ff       	callq  4350 <SDL_CreateRenderer@plt>
	if (disp_data->renderer == NULL) {
    8a9f:	48 85 c0             	test   %rax,%rax
	disp_data->renderer =
    8aa2:	48 89 43 08          	mov    %rax,0x8(%rbx)
	if (disp_data->renderer == NULL) {
    8aa6:	75 2b                	jne    8ad3 <sdl_display_init+0xb9>
    8aa8:	48 8d 1d 71 19 23 00 	lea    0x231971(%rip),%rbx        # 23a420 <log_const_display_sdl>
    8aaf:	48 2b 1d 9a d4 22 00 	sub    0x22d49a(%rip),%rbx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		LOG_ERR("Failed to create SDL renderer: %s",
    8ab6:	e8 25 ba ff ff       	callq  44e0 <SDL_GetError@plt>
    8abb:	48 8d 3d d5 87 02 00 	lea    0x287d5(%rip),%rdi        # 31297 <__func__.5785+0x62f>
    8ac2:	48 89 c6             	mov    %rax,%rsi
    8ac5:	48 c1 eb 04          	shr    $0x4,%rbx
    8ac9:	c1 e3 06             	shl    $0x6,%ebx
    8acc:	83 cb 01             	or     $0x1,%ebx
    8acf:	89 da                	mov    %ebx,%edx
    8ad1:	eb 4c                	jmp    8b1f <sdl_display_init+0x105>
	disp_data->texture = SDL_CreateTexture(
    8ad3:	31 d2                	xor    %edx,%edx
    8ad5:	41 b8 5e 00 00 00    	mov    $0x5e,%r8d
    8adb:	b9 2c 01 00 00       	mov    $0x12c,%ecx
    8ae0:	be 04 20 36 16       	mov    $0x16362004,%esi
    8ae5:	48 89 c7             	mov    %rax,%rdi
    8ae8:	e8 b3 bc ff ff       	callq  47a0 <SDL_CreateTexture@plt>
	if (disp_data->texture == NULL) {
    8aed:	48 85 c0             	test   %rax,%rax
	disp_data->texture = SDL_CreateTexture(
    8af0:	48 89 43 10          	mov    %rax,0x10(%rbx)
	if (disp_data->texture == NULL) {
    8af4:	75 35                	jne    8b2b <sdl_display_init+0x111>
    8af6:	48 8d 1d 23 19 23 00 	lea    0x231923(%rip),%rbx        # 23a420 <log_const_display_sdl>
    8afd:	48 2b 1d 4c d4 22 00 	sub    0x22d44c(%rip),%rbx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		LOG_ERR("Failed to create SDL texture: %s", SDL_GetError());
    8b04:	e8 d7 b9 ff ff       	callq  44e0 <SDL_GetError@plt>
    8b09:	48 8d 3d a9 87 02 00 	lea    0x287a9(%rip),%rdi        # 312b9 <__func__.5785+0x651>
    8b10:	48 89 c6             	mov    %rax,%rsi
    8b13:	48 c1 eb 04          	shr    $0x4,%rbx
    8b17:	c1 e3 06             	shl    $0x6,%ebx
    8b1a:	83 cb 01             	or     $0x1,%ebx
    8b1d:	89 da                	mov    %ebx,%edx
    8b1f:	e8 d1 e7 ff ff       	callq  72f5 <log_1>
		return -EIO;
    8b24:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    8b29:	eb 2d                	jmp    8b58 <sdl_display_init+0x13e>
	SDL_SetRenderDrawColor(disp_data->renderer, 0, 0, 0, 0xFF);
    8b2b:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    8b2f:	41 b8 ff 00 00 00    	mov    $0xff,%r8d
    8b35:	31 c9                	xor    %ecx,%ecx
    8b37:	31 d2                	xor    %edx,%edx
    8b39:	31 f6                	xor    %esi,%esi
	disp_data->display_on = false;
    8b3b:	c6 43 18 00          	movb   $0x0,0x18(%rbx)
	SDL_SetRenderDrawColor(disp_data->renderer, 0, 0, 0, 0xFF);
    8b3f:	e8 8c bb ff ff       	callq  46d0 <SDL_SetRenderDrawColor@plt>
	SDL_RenderClear(disp_data->renderer);
    8b44:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    8b48:	e8 93 ba ff ff       	callq  45e0 <SDL_RenderClear@plt>
	SDL_RenderPresent(disp_data->renderer);
    8b4d:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    8b51:	e8 4a b8 ff ff       	callq  43a0 <SDL_RenderPresent@plt>
	return 0;
    8b56:	31 c0                	xor    %eax,%eax
}
    8b58:	5b                   	pop    %rbx
    8b59:	c3                   	retq   

0000000000008b5a <sdl_display_cleanup>:
		return -ENOTSUP;
	}
}

static void sdl_display_cleanup(void)
{
    8b5a:	48 83 ec 08          	sub    $0x8,%rsp
	if (sdl_display_data.texture != NULL) {
    8b5e:	48 8b 3d cb 22 23 00 	mov    0x2322cb(%rip),%rdi        # 23ae30 <sdl_display_data+0x10>
    8b65:	48 85 ff             	test   %rdi,%rdi
    8b68:	74 10                	je     8b7a <sdl_display_cleanup+0x20>
		SDL_DestroyTexture(sdl_display_data.texture);
    8b6a:	e8 61 b9 ff ff       	callq  44d0 <SDL_DestroyTexture@plt>
		sdl_display_data.texture = NULL;
    8b6f:	48 c7 05 b6 22 23 00 	movq   $0x0,0x2322b6(%rip)        # 23ae30 <sdl_display_data+0x10>
    8b76:	00 00 00 00 
	}

	if (sdl_display_data.renderer != NULL) {
    8b7a:	48 8b 3d a7 22 23 00 	mov    0x2322a7(%rip),%rdi        # 23ae28 <sdl_display_data+0x8>
    8b81:	48 85 ff             	test   %rdi,%rdi
    8b84:	74 10                	je     8b96 <sdl_display_cleanup+0x3c>
		SDL_DestroyRenderer(sdl_display_data.renderer);
    8b86:	e8 a5 b8 ff ff       	callq  4430 <SDL_DestroyRenderer@plt>
		sdl_display_data.renderer = NULL;
    8b8b:	48 c7 05 92 22 23 00 	movq   $0x0,0x232292(%rip)        # 23ae28 <sdl_display_data+0x8>
    8b92:	00 00 00 00 
	}

	if (sdl_display_data.window != NULL) {
    8b96:	48 8b 3d 83 22 23 00 	mov    0x232283(%rip),%rdi        # 23ae20 <sdl_display_data>
    8b9d:	48 85 ff             	test   %rdi,%rdi
    8ba0:	74 10                	je     8bb2 <sdl_display_cleanup+0x58>
		SDL_DestroyWindow(sdl_display_data.window);
    8ba2:	e8 89 b7 ff ff       	callq  4330 <SDL_DestroyWindow@plt>
		sdl_display_data.window = NULL;
    8ba7:	48 c7 05 6e 22 23 00 	movq   $0x0,0x23226e(%rip)        # 23ae20 <sdl_display_data>
    8bae:	00 00 00 00 
	}
}
    8bb2:	58                   	pop    %rax
    8bb3:	c3                   	retq   

0000000000008bb4 <sdl_display_write>:
{
    8bb4:	41 57                	push   %r15
    8bb6:	41 56                	push   %r14
    8bb8:	41 55                	push   %r13
    8bba:	41 54                	push   %r12
		return -EINVAL;
    8bbc:	41 bc ea ff ff ff    	mov    $0xffffffea,%r12d
{
    8bc2:	55                   	push   %rbp
    8bc3:	53                   	push   %rbx
    8bc4:	48 89 cd             	mov    %rcx,%rbp
    8bc7:	48 83 ec 48          	sub    $0x48,%rsp
	struct sdl_display_data *disp_data =
    8bcb:	48 8b 5f 18          	mov    0x18(%rdi),%rbx
{
    8bcf:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    8bd6:	00 00 
    8bd8:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    8bdd:	31 c0                	xor    %eax,%eax
	if (desc->width > desc->pitch ||
    8bdf:	0f b7 41 04          	movzwl 0x4(%rcx),%eax
    8be3:	8b 49 08             	mov    0x8(%rcx),%ecx
    8be6:	66 39 c8             	cmp    %cx,%ax
    8be9:	0f 87 78 02 00 00    	ja     8e67 <sdl_display_write+0x2b3>
	    x + desc->pitch > CONFIG_SDL_DISPLAY_X_RES ||
    8bef:	0f b7 f6             	movzwl %si,%esi
    8bf2:	89 74 24 0c          	mov    %esi,0xc(%rsp)
    8bf6:	0f b7 f1             	movzwl %cx,%esi
    8bf9:	8b 4c 24 0c          	mov    0xc(%rsp),%ecx
    8bfd:	01 f1                	add    %esi,%ecx
	if (desc->width > desc->pitch ||
    8bff:	81 f9 2c 01 00 00    	cmp    $0x12c,%ecx
    8c05:	0f 8f 5c 02 00 00    	jg     8e67 <sdl_display_write+0x2b3>
	    y + desc->height > CONFIG_SDL_DISPLAY_Y_RES) {
    8c0b:	0f b7 4d 06          	movzwl 0x6(%rbp),%ecx
    8c0f:	0f b7 d2             	movzwl %dx,%edx
    8c12:	89 54 24 18          	mov    %edx,0x18(%rsp)
    8c16:	01 ca                	add    %ecx,%edx
	    x + desc->pitch > CONFIG_SDL_DISPLAY_X_RES ||
    8c18:	83 fa 5e             	cmp    $0x5e,%edx
    8c1b:	0f 8f 46 02 00 00    	jg     8e67 <sdl_display_write+0x2b3>
	if (disp_data->current_pixel_format == PIXEL_FORMAT_ARGB_8888) {
    8c21:	8b 53 1c             	mov    0x1c(%rbx),%edx
    8c24:	4c 8d 63 20          	lea    0x20(%rbx),%r12
    8c28:	83 fa 08             	cmp    $0x8,%edx
    8c2b:	75 13                	jne    8c40 <sdl_display_write+0x8c>
	memcpy(disp_buf, buf, desc->pitch * 4U * desc->height);
    8c2d:	0f af ce             	imul   %esi,%ecx
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    8c30:	4c 89 e7             	mov    %r12,%rdi
    8c33:	4c 89 c6             	mov    %r8,%rsi
    8c36:	c1 e1 02             	shl    $0x2,%ecx
    8c39:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
    8c3b:	e9 c7 01 00 00       	jmpq   8e07 <sdl_display_write+0x253>
	} else if (disp_data->current_pixel_format == PIXEL_FORMAT_RGB_888) {
    8c40:	83 fa 01             	cmp    $0x1,%edx
    8c43:	75 5a                	jne    8c9f <sdl_display_write+0xeb>
    8c45:	44 0f b7 e8          	movzwl %ax,%r13d
    8c49:	4d 89 e3             	mov    %r12,%r11
    8c4c:	45 31 d2             	xor    %r10d,%r10d
    8c4f:	49 c1 e5 02          	shl    $0x2,%r13
	for (h_idx = 0U; h_idx < desc->height; ++h_idx) {
    8c53:	45 31 c9             	xor    %r9d,%r9d
    8c56:	41 39 c9             	cmp    %ecx,%r9d
    8c59:	0f 83 a8 01 00 00    	jae    8e07 <sdl_display_write+0x253>
    8c5f:	31 ff                	xor    %edi,%edi
		for (w_idx = 0U; w_idx < desc->width; ++w_idx) {
    8c61:	39 c7                	cmp    %eax,%edi
    8c63:	73 2f                	jae    8c94 <sdl_display_write+0xe0>
				((h_idx * desc->pitch) + w_idx) * 3U;
    8c65:	41 8d 14 3a          	lea    (%r10,%rdi,1),%edx
    8c69:	6b d2 03             	imul   $0x3,%edx,%edx
			byte_ptr = (const uint8_t *)buf +
    8c6c:	4c 01 c2             	add    %r8,%rdx
			pixel = *byte_ptr << 16;
    8c6f:	44 0f b6 3a          	movzbl (%rdx),%r15d
			pixel |= *(byte_ptr + 1) << 8;
    8c73:	44 0f b6 72 01       	movzbl 0x1(%rdx),%r14d
			pixel = *byte_ptr << 16;
    8c78:	41 c1 e7 10          	shl    $0x10,%r15d
			pixel |= *(byte_ptr + 1) << 8;
    8c7c:	41 c1 e6 08          	shl    $0x8,%r14d
    8c80:	45 09 fe             	or     %r15d,%r14d
			pixel |= *(byte_ptr + 2);
    8c83:	44 0f b6 7a 02       	movzbl 0x2(%rdx),%r15d
    8c88:	45 09 fe             	or     %r15d,%r14d
    8c8b:	45 89 34 bb          	mov    %r14d,(%r11,%rdi,4)
    8c8f:	48 ff c7             	inc    %rdi
    8c92:	eb cd                	jmp    8c61 <sdl_display_write+0xad>
    8c94:	4d 01 eb             	add    %r13,%r11
	for (h_idx = 0U; h_idx < desc->height; ++h_idx) {
    8c97:	41 ff c1             	inc    %r9d
    8c9a:	41 01 f2             	add    %esi,%r10d
    8c9d:	eb b7                	jmp    8c56 <sdl_display_write+0xa2>
	} else if (disp_data->current_pixel_format == PIXEL_FORMAT_MONO10) {
    8c9f:	83 fa 04             	cmp    $0x4,%edx
    8ca2:	75 07                	jne    8cab <sdl_display_write+0xf7>
		sdl_display_write_mono(disp_data->buf, desc, buf, true);
    8ca4:	b9 01 00 00 00       	mov    $0x1,%ecx
    8ca9:	eb 07                	jmp    8cb2 <sdl_display_write+0xfe>
	} else if (disp_data->current_pixel_format == PIXEL_FORMAT_MONO01) {
    8cab:	83 fa 02             	cmp    $0x2,%edx
    8cae:	75 15                	jne    8cc5 <sdl_display_write+0x111>
		sdl_display_write_mono(disp_data->buf, desc, buf, false);
    8cb0:	31 c9                	xor    %ecx,%ecx
    8cb2:	4c 89 c2             	mov    %r8,%rdx
    8cb5:	48 89 ee             	mov    %rbp,%rsi
    8cb8:	4c 89 e7             	mov    %r12,%rdi
    8cbb:	e8 af fb ff ff       	callq  886f <sdl_display_write_mono>
    8cc0:	e9 42 01 00 00       	jmpq   8e07 <sdl_display_write+0x253>
	} else if (disp_data->current_pixel_format == PIXEL_FORMAT_RGB_565) {
    8cc5:	83 fa 10             	cmp    $0x10,%edx
    8cc8:	0f 85 9c 00 00 00    	jne    8d6a <sdl_display_write+0x1b6>
    8cce:	0f b7 d0             	movzwl %ax,%edx
    8cd1:	4d 89 e5             	mov    %r12,%r13
    8cd4:	45 31 db             	xor    %r11d,%r11d
    8cd7:	48 c1 e2 02          	shl    $0x2,%rdx
	for (h_idx = 0U; h_idx < desc->height; ++h_idx) {
    8cdb:	45 31 d2             	xor    %r10d,%r10d
		for (w_idx = 0U; w_idx < desc->width; ++w_idx) {
    8cde:	89 44 24 1c          	mov    %eax,0x1c(%rsp)
    8ce2:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
			pixel = (((rgb565 >> 11) & 0x1F) * 255 / 31) << 16;
    8ce7:	41 bf 1f 00 00 00    	mov    $0x1f,%r15d
	for (h_idx = 0U; h_idx < desc->height; ++h_idx) {
    8ced:	41 39 ca             	cmp    %ecx,%r10d
    8cf0:	0f 83 11 01 00 00    	jae    8e07 <sdl_display_write+0x253>
    8cf6:	45 31 c9             	xor    %r9d,%r9d
		for (w_idx = 0U; w_idx < desc->width; ++w_idx) {
    8cf9:	44 3b 4c 24 1c       	cmp    0x1c(%rsp),%r9d
    8cfe:	73 5d                	jae    8d5d <sdl_display_write+0x1a9>
				((h_idx * desc->pitch) + w_idx);
    8d00:	43 8d 04 0b          	lea    (%r11,%r9,1),%eax
			rgb565 = sys_be16_to_cpu(*pix_ptr);
    8d04:	66 41 8b 3c 40       	mov    (%r8,%rax,2),%di
    8d09:	66 c1 c7 08          	rol    $0x8,%di
			pixel = (((rgb565 >> 11) & 0x1F) * 255 / 31) << 16;
    8d0d:	89 f8                	mov    %edi,%eax
    8d0f:	66 c1 e8 0b          	shr    $0xb,%ax
    8d13:	0f b7 c0             	movzwl %ax,%eax
    8d16:	69 c0 ff 00 00 00    	imul   $0xff,%eax,%eax
    8d1c:	99                   	cltd   
    8d1d:	41 f7 ff             	idiv   %r15d
    8d20:	c1 e0 10             	shl    $0x10,%eax
    8d23:	41 89 c6             	mov    %eax,%r14d
			pixel |= (rgb565 & 0x1F) * 255 / 31;
    8d26:	89 f8                	mov    %edi,%eax
			pixel |= (((rgb565 >> 5) & 0x3F) * 255 / 63) << 8;
    8d28:	66 c1 ef 05          	shr    $0x5,%di
			pixel |= (rgb565 & 0x1F) * 255 / 31;
    8d2c:	83 e0 1f             	and    $0x1f,%eax
			pixel |= (((rgb565 >> 5) & 0x3F) * 255 / 63) << 8;
    8d2f:	83 e7 3f             	and    $0x3f,%edi
			pixel |= (rgb565 & 0x1F) * 255 / 31;
    8d32:	69 c0 ff 00 00 00    	imul   $0xff,%eax,%eax
    8d38:	99                   	cltd   
    8d39:	41 f7 ff             	idiv   %r15d
    8d3c:	41 09 c6             	or     %eax,%r14d
			pixel |= (((rgb565 >> 5) & 0x3F) * 255 / 63) << 8;
    8d3f:	69 c7 ff 00 00 00    	imul   $0xff,%edi,%eax
    8d45:	bf 3f 00 00 00       	mov    $0x3f,%edi
    8d4a:	99                   	cltd   
    8d4b:	f7 ff                	idiv   %edi
    8d4d:	c1 e0 08             	shl    $0x8,%eax
			pixel |= (rgb565 & 0x1F) * 255 / 31;
    8d50:	44 09 f0             	or     %r14d,%eax
    8d53:	43 89 44 8d 00       	mov    %eax,0x0(%r13,%r9,4)
    8d58:	49 ff c1             	inc    %r9
    8d5b:	eb 9c                	jmp    8cf9 <sdl_display_write+0x145>
    8d5d:	4c 03 6c 24 10       	add    0x10(%rsp),%r13
	for (h_idx = 0U; h_idx < desc->height; ++h_idx) {
    8d62:	41 ff c2             	inc    %r10d
    8d65:	41 01 f3             	add    %esi,%r11d
    8d68:	eb 83                	jmp    8ced <sdl_display_write+0x139>
	} else if (disp_data->current_pixel_format == PIXEL_FORMAT_BGR_565) {
    8d6a:	83 fa 20             	cmp    $0x20,%edx
    8d6d:	0f 85 94 00 00 00    	jne    8e07 <sdl_display_write+0x253>
    8d73:	0f b7 d0             	movzwl %ax,%edx
    8d76:	4d 89 e3             	mov    %r12,%r11
    8d79:	45 31 ed             	xor    %r13d,%r13d
    8d7c:	48 c1 e2 02          	shl    $0x2,%rdx
	for (h_idx = 0U; h_idx < desc->height; ++h_idx) {
    8d80:	45 31 d2             	xor    %r10d,%r10d
		for (w_idx = 0U; w_idx < desc->width; ++w_idx) {
    8d83:	89 44 24 1c          	mov    %eax,0x1c(%rsp)
    8d87:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
			pixel = (((*pix_ptr >> 11) & 0x1F) * 255 / 31) << 16;
    8d8c:	41 bf 1f 00 00 00    	mov    $0x1f,%r15d
	for (h_idx = 0U; h_idx < desc->height; ++h_idx) {
    8d92:	41 39 ca             	cmp    %ecx,%r10d
    8d95:	73 70                	jae    8e07 <sdl_display_write+0x253>
    8d97:	45 31 c9             	xor    %r9d,%r9d
		for (w_idx = 0U; w_idx < desc->width; ++w_idx) {
    8d9a:	44 39 4c 24 1c       	cmp    %r9d,0x1c(%rsp)
    8d9f:	76 59                	jbe    8dfa <sdl_display_write+0x246>
				((h_idx * desc->pitch) + w_idx);
    8da1:	43 8d 44 0d 00       	lea    0x0(%r13,%r9,1),%eax
			pixel = (((*pix_ptr >> 11) & 0x1F) * 255 / 31) << 16;
    8da6:	66 41 8b 3c 40       	mov    (%r8,%rax,2),%di
    8dab:	89 f8                	mov    %edi,%eax
    8dad:	66 c1 e8 0b          	shr    $0xb,%ax
    8db1:	0f b7 c0             	movzwl %ax,%eax
    8db4:	69 c0 ff 00 00 00    	imul   $0xff,%eax,%eax
    8dba:	99                   	cltd   
    8dbb:	41 f7 ff             	idiv   %r15d
    8dbe:	c1 e0 10             	shl    $0x10,%eax
    8dc1:	41 89 c6             	mov    %eax,%r14d
			pixel |= (*pix_ptr & 0x1F) * 255 / 31;
    8dc4:	89 f8                	mov    %edi,%eax
			pixel |= (((*pix_ptr >> 5) & 0x3F) * 255 / 63) << 8;
    8dc6:	66 c1 ef 05          	shr    $0x5,%di
			pixel |= (*pix_ptr & 0x1F) * 255 / 31;
    8dca:	83 e0 1f             	and    $0x1f,%eax
			pixel |= (((*pix_ptr >> 5) & 0x3F) * 255 / 63) << 8;
    8dcd:	83 e7 3f             	and    $0x3f,%edi
			pixel |= (*pix_ptr & 0x1F) * 255 / 31;
    8dd0:	69 c0 ff 00 00 00    	imul   $0xff,%eax,%eax
    8dd6:	99                   	cltd   
    8dd7:	41 f7 ff             	idiv   %r15d
    8dda:	41 09 c6             	or     %eax,%r14d
			pixel |= (((*pix_ptr >> 5) & 0x3F) * 255 / 63) << 8;
    8ddd:	69 c7 ff 00 00 00    	imul   $0xff,%edi,%eax
    8de3:	bf 3f 00 00 00       	mov    $0x3f,%edi
    8de8:	99                   	cltd   
    8de9:	f7 ff                	idiv   %edi
    8deb:	c1 e0 08             	shl    $0x8,%eax
			pixel |= (*pix_ptr & 0x1F) * 255 / 31;
    8dee:	44 09 f0             	or     %r14d,%eax
    8df1:	43 89 04 8b          	mov    %eax,(%r11,%r9,4)
    8df5:	49 ff c1             	inc    %r9
    8df8:	eb a0                	jmp    8d9a <sdl_display_write+0x1e6>
    8dfa:	4c 03 5c 24 10       	add    0x10(%rsp),%r11
	for (h_idx = 0U; h_idx < desc->height; ++h_idx) {
    8dff:	41 ff c2             	inc    %r10d
    8e02:	41 01 f5             	add    %esi,%r13d
    8e05:	eb 8b                	jmp    8d92 <sdl_display_write+0x1de>
	rect.x = x;
    8e07:	8b 44 24 0c          	mov    0xc(%rsp),%eax
	rect.w = desc->width;
    8e0b:	0f b7 4d 04          	movzwl 0x4(%rbp),%ecx
	SDL_UpdateTexture(disp_data->texture, &rect, disp_data->buf,
    8e0f:	48 8d 74 24 28       	lea    0x28(%rsp),%rsi
    8e14:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
    8e18:	4c 89 e2             	mov    %r12,%rdx
	return 0;
    8e1b:	45 31 e4             	xor    %r12d,%r12d
	rect.x = x;
    8e1e:	89 44 24 28          	mov    %eax,0x28(%rsp)
	rect.y = y;
    8e22:	8b 44 24 18          	mov    0x18(%rsp),%eax
	rect.w = desc->width;
    8e26:	89 4c 24 30          	mov    %ecx,0x30(%rsp)
	SDL_UpdateTexture(disp_data->texture, &rect, disp_data->buf,
    8e2a:	c1 e1 02             	shl    $0x2,%ecx
	rect.y = y;
    8e2d:	89 44 24 2c          	mov    %eax,0x2c(%rsp)
	rect.h = desc->height;
    8e31:	0f b7 45 06          	movzwl 0x6(%rbp),%eax
    8e35:	89 44 24 34          	mov    %eax,0x34(%rsp)
	SDL_UpdateTexture(disp_data->texture, &rect, disp_data->buf,
    8e39:	e8 b2 b6 ff ff       	callq  44f0 <SDL_UpdateTexture@plt>
	if (disp_data->display_on) {
    8e3e:	80 7b 18 00          	cmpb   $0x0,0x18(%rbx)
    8e42:	74 23                	je     8e67 <sdl_display_write+0x2b3>
		SDL_RenderClear(disp_data->renderer);
    8e44:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    8e48:	e8 93 b7 ff ff       	callq  45e0 <SDL_RenderClear@plt>
		SDL_RenderCopy(disp_data->renderer, disp_data->texture, NULL,
    8e4d:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    8e51:	48 8b 73 10          	mov    0x10(%rbx),%rsi
    8e55:	31 c9                	xor    %ecx,%ecx
    8e57:	31 d2                	xor    %edx,%edx
    8e59:	e8 f2 b7 ff ff       	callq  4650 <SDL_RenderCopy@plt>
		SDL_RenderPresent(disp_data->renderer);
    8e5e:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    8e62:	e8 39 b5 ff ff       	callq  43a0 <SDL_RenderPresent@plt>
}
    8e67:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
    8e6c:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
    8e73:	00 00 
    8e75:	44 89 e0             	mov    %r12d,%eax
    8e78:	74 05                	je     8e7f <sdl_display_write+0x2cb>
    8e7a:	e8 c1 b7 ff ff       	callq  4640 <__stack_chk_fail@plt>
    8e7f:	48 83 c4 48          	add    $0x48,%rsp
    8e83:	5b                   	pop    %rbx
    8e84:	5d                   	pop    %rbp
    8e85:	41 5c                	pop    %r12
    8e87:	41 5d                	pop    %r13
    8e89:	41 5e                	pop    %r14
    8e8b:	41 5f                	pop    %r15
    8e8d:	c3                   	retq   

0000000000008e8e <sdl_display_set_pixel_format>:
{
    8e8e:	83 fe 20             	cmp    $0x20,%esi
	struct sdl_display_data *disp_data =
    8e91:	48 8b 47 18          	mov    0x18(%rdi),%rax
    8e95:	77 16                	ja     8ead <sdl_display_set_pixel_format+0x1f>
    8e97:	48 ba 16 01 01 00 01 	movabs $0x100010116,%rdx
    8e9e:	00 00 00 
    8ea1:	48 0f a3 f2          	bt     %rsi,%rdx
    8ea5:	73 06                	jae    8ead <sdl_display_set_pixel_format+0x1f>
		disp_data->current_pixel_format = pixel_format;
    8ea7:	89 70 1c             	mov    %esi,0x1c(%rax)
		return 0;
    8eaa:	31 c0                	xor    %eax,%eax
}
    8eac:	c3                   	retq   
{
    8ead:	48 83 ec 08          	sub    $0x8,%rsp
    8eb1:	48 8d 35 68 15 23 00 	lea    0x231568(%rip),%rsi        # 23a420 <log_const_display_sdl>
    8eb8:	48 2b 35 91 d0 22 00 	sub    0x22d091(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		LOG_ERR("Pixel format not supported");
    8ebf:	48 8d 3d 14 84 02 00 	lea    0x28414(%rip),%rdi        # 312da <__func__.5785+0x672>
    8ec6:	48 c1 ee 04          	shr    $0x4,%rsi
    8eca:	c1 e6 06             	shl    $0x6,%esi
    8ecd:	83 ce 01             	or     $0x1,%esi
    8ed0:	e8 ef e3 ff ff       	callq  72c4 <log_0>
    8ed5:	b8 a1 ff ff ff       	mov    $0xffffffa1,%eax
}
    8eda:	5a                   	pop    %rdx
    8edb:	c3                   	retq   

0000000000008edc <sdl_display_set_contrast>:
    8edc:	b8 a1 ff ff ff       	mov    $0xffffffa1,%eax
    8ee1:	c3                   	retq   

0000000000008ee2 <bt_uc_init>:

static int bt_uc_init(const struct device *unused)
{
	ARG_UNUSED(unused);

	bt_hci_driver_register(&drv);
    8ee2:	48 8d 3d f7 c3 22 00 	lea    0x22c3f7(%rip),%rdi        # 2352e0 <drv>
{
    8ee9:	48 83 ec 08          	sub    $0x8,%rsp
	bt_hci_driver_register(&drv);
    8eed:	e8 2c 68 00 00       	callq  f71e <bt_hci_driver_register>

	return 0;
}
    8ef2:	31 c0                	xor    %eax,%eax
    8ef4:	5a                   	pop    %rdx
    8ef5:	c3                   	retq   

0000000000008ef6 <add_btuserchan_arg>:
		NULL, cmd_bt_dev_found,
		"A local HCI device to be used for Bluetooth (e.g. hci0)" },
		ARG_TABLE_ENDMARKER
	};

	native_add_command_line_opts(btuserchan_args);
    8ef6:	48 8d 3d 23 d3 22 00 	lea    0x22d323(%rip),%rdi        # 236220 <btuserchan_args.9261>
    8efd:	e9 ff 3d 00 00       	jmpq   cd01 <native_add_command_line_opts>

0000000000008f02 <btuserchan_check_arg>:
}

static void btuserchan_check_arg(void)
{
	if (bt_dev_index < 0) {
    8f02:	83 3d 9f db 22 00 00 	cmpl   $0x0,0x22db9f(%rip)        # 236aa8 <bt_dev_index>
    8f09:	79 0e                	jns    8f19 <btuserchan_check_arg+0x17>
		posix_print_error_and_exit("Error: Bluetooth device missing. "
    8f0b:	48 8d 3d ef 83 02 00 	lea    0x283ef(%rip),%rdi        # 31301 <__func__.5785+0x699>
    8f12:	31 c0                	xor    %eax,%eax
    8f14:	e9 a9 33 00 00       	jmpq   c2c2 <posix_print_error_and_exit>
					   "Specify one using --bt-dev=hciN\n");
	}
}
    8f19:	c3                   	retq   

0000000000008f1a <cmd_bt_dev_found>:
{
    8f1a:	41 54                	push   %r12
    8f1c:	55                   	push   %rbp
    8f1d:	49 89 fc             	mov    %rdi,%r12
    8f20:	53                   	push   %rbx
	if (strncmp(&argv[offset], "hci", 3) || strlen(&argv[offset]) < 4) {
    8f21:	48 63 de             	movslq %esi,%rbx
    8f24:	48 8d 35 18 84 02 00 	lea    0x28418(%rip),%rsi        # 31343 <__func__.5785+0x6db>
    8f2b:	48 8d 2c 1f          	lea    (%rdi,%rbx,1),%rbp
    8f2f:	ba 03 00 00 00       	mov    $0x3,%edx
    8f34:	48 89 ef             	mov    %rbp,%rdi
    8f37:	e8 14 b5 ff ff       	callq  4450 <strncmp@plt>
    8f3c:	85 c0                	test   %eax,%eax
    8f3e:	75 18                	jne    8f58 <cmd_bt_dev_found+0x3e>
    8f40:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    8f44:	48 89 ef             	mov    %rbp,%rdi
    8f47:	f2 ae                	repnz scas %es:(%rdi),%al
    8f49:	48 89 c8             	mov    %rcx,%rax
    8f4c:	48 f7 d0             	not    %rax
    8f4f:	48 ff c8             	dec    %rax
    8f52:	48 83 f8 03          	cmp    $0x3,%rax
    8f56:	77 15                	ja     8f6d <cmd_bt_dev_found+0x53>
}
    8f58:	5b                   	pop    %rbx
		posix_print_error_and_exit("Error: Invalid Bluetooth device "
    8f59:	48 89 ee             	mov    %rbp,%rsi
    8f5c:	48 8d 3d e4 83 02 00 	lea    0x283e4(%rip),%rdi        # 31347 <__func__.5785+0x6df>
    8f63:	31 c0                	xor    %eax,%eax
}
    8f65:	5d                   	pop    %rbp
    8f66:	41 5c                	pop    %r12
		posix_print_error_and_exit("Error: Invalid Bluetooth device "
    8f68:	e9 55 33 00 00       	jmpq   c2c2 <posix_print_error_and_exit>
	bt_dev_index = strtol(&argv[offset + 3], NULL, 10);
    8f6d:	49 8d 7c 1c 03       	lea    0x3(%r12,%rbx,1),%rdi
    8f72:	ba 0a 00 00 00       	mov    $0xa,%edx
    8f77:	31 f6                	xor    %esi,%esi
    8f79:	e8 42 b7 ff ff       	callq  46c0 <strtol@plt>
}
    8f7e:	5b                   	pop    %rbx
	bt_dev_index = strtol(&argv[offset + 3], NULL, 10);
    8f7f:	89 05 23 db 22 00    	mov    %eax,0x22db23(%rip)        # 236aa8 <bt_dev_index>
}
    8f85:	5d                   	pop    %rbp
    8f86:	41 5c                	pop    %r12
    8f88:	c3                   	retq   

0000000000008f89 <uc_send>:
	if (uc_fd < 0) {
    8f89:	83 3d 1c db 22 00 00 	cmpl   $0x0,0x22db1c(%rip)        # 236aac <uc_fd>
{
    8f90:	53                   	push   %rbx
	if (uc_fd < 0) {
    8f91:	79 2b                	jns    8fbe <uc_send+0x35>
    8f93:	48 8d 35 16 14 23 00 	lea    0x231416(%rip),%rsi        # 23a3b0 <log_const_bt_driver>
    8f9a:	48 2b 35 af cf 22 00 	sub    0x22cfaf(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("User channel not open");
    8fa1:	48 8d 3d e0 83 02 00 	lea    0x283e0(%rip),%rdi        # 31388 <__func__.5785+0x720>
    8fa8:	48 c1 ee 04          	shr    $0x4,%rsi
    8fac:	c1 e6 06             	shl    $0x6,%esi
    8faf:	83 ce 01             	or     $0x1,%esi
    8fb2:	e8 0d e3 ff ff       	callq  72c4 <log_0>
		return -EIO;
    8fb7:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    8fbc:	eb 7f                	jmp    903d <uc_send+0xb4>
	switch (bt_buf_get_type(buf)) {
    8fbe:	8a 47 28             	mov    0x28(%rdi),%al
    8fc1:	48 89 fb             	mov    %rdi,%rbx
    8fc4:	84 c0                	test   %al,%al
    8fc6:	74 0f                	je     8fd7 <uc_send+0x4e>
    8fc8:	3c 02                	cmp    $0x2,%al
    8fca:	75 3c                	jne    9008 <uc_send+0x7f>
 * @param buf Buffer to update.
 * @param val 8-bit value to be pushed to the buffer.
 */
static inline void net_buf_push_u8(struct net_buf *buf, uint8_t val)
{
	net_buf_simple_push_u8(&buf->b, val);
    8fcc:	48 8d 7f 10          	lea    0x10(%rdi),%rdi
    8fd0:	be 02 00 00 00       	mov    $0x2,%esi
    8fd5:	eb 09                	jmp    8fe0 <uc_send+0x57>
    8fd7:	48 8d 7f 10          	lea    0x10(%rdi),%rdi
    8fdb:	be 01 00 00 00       	mov    $0x1,%esi
    8fe0:	e8 0b 01 01 00       	callq  190f0 <net_buf_simple_push_u8>
	if (write(uc_fd, buf->data, buf->len) < 0) {
    8fe5:	0f b7 53 18          	movzwl 0x18(%rbx),%edx
    8fe9:	48 8b 73 10          	mov    0x10(%rbx),%rsi
    8fed:	8b 3d b9 da 22 00    	mov    0x22dab9(%rip),%edi        # 236aac <uc_fd>
    8ff3:	e8 28 b4 ff ff       	callq  4420 <write@plt>
    8ff8:	48 85 c0             	test   %rax,%rax
    8ffb:	79 36                	jns    9033 <uc_send+0xaa>
		return -errno;
    8ffd:	e8 5e b3 ff ff       	callq  4360 <__errno_location@plt>
    9002:	8b 00                	mov    (%rax),%eax
    9004:	f7 d8                	neg    %eax
    9006:	eb 35                	jmp    903d <uc_send+0xb4>
    9008:	48 8d 35 a1 13 23 00 	lea    0x2313a1(%rip),%rsi        # 23a3b0 <log_const_bt_driver>
    900f:	48 2b 35 3a cf 22 00 	sub    0x22cf3a(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unknown buffer type");
    9016:	48 8d 3d 81 83 02 00 	lea    0x28381(%rip),%rdi        # 3139e <__func__.5785+0x736>
    901d:	48 c1 ee 04          	shr    $0x4,%rsi
    9021:	c1 e6 06             	shl    $0x6,%esi
    9024:	83 ce 01             	or     $0x1,%esi
    9027:	e8 98 e2 ff ff       	callq  72c4 <log_0>
		return -EINVAL;
    902c:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    9031:	eb 0a                	jmp    903d <uc_send+0xb4>
	net_buf_unref(buf);
    9033:	48 89 df             	mov    %rbx,%rdi
    9036:	e8 5f ff 00 00       	callq  18f9a <net_buf_unref>
	return 0;
    903b:	31 c0                	xor    %eax,%eax
}
    903d:	5b                   	pop    %rbx
    903e:	c3                   	retq   

000000000000903f <rx_thread>:
{
    903f:	41 55                	push   %r13
    9041:	41 54                	push   %r12
    9043:	55                   	push   %rbp
    9044:	53                   	push   %rbx
    9045:	48 83 ec 18          	sub    $0x18,%rsp
    9049:	48 8d 1d 60 13 23 00 	lea    0x231360(%rip),%rbx        # 23a3b0 <log_const_bt_driver>
    9050:	48 2b 1d f9 ce 22 00 	sub    0x22cef9(%rip),%rbx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
    9057:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    905e:	00 00 
    9060:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    9065:	31 c0                	xor    %eax,%eax
	return __poll_chk (__fds, __nfds, __timeout, __bos (__fds));
      else if (__bos (__fds) / sizeof (*__fds) < __nfds)
	return __poll_chk_warn (__fds, __nfds, __timeout, __bos (__fds));
    }

  return __poll_alias (__fds, __nfds, __timeout);
    9067:	49 89 e4             	mov    %rsp,%r12
    906a:	48 c1 eb 04          	shr    $0x4,%rbx
		BT_ERR("Unknown packet type: %u", buf[0]);
    906e:	66 81 e3 ff 03       	and    $0x3ff,%bx
	struct pollfd pollfd = { .fd = uc_fd, .events = POLLIN };
    9073:	8b 05 33 da 22 00    	mov    0x22da33(%rip),%eax        # 236aac <uc_fd>
    9079:	31 d2                	xor    %edx,%edx
    907b:	be 01 00 00 00       	mov    $0x1,%esi
    9080:	4c 89 e7             	mov    %r12,%rdi
    9083:	66 c7 44 24 06 00 00 	movw   $0x0,0x6(%rsp)
    908a:	66 c7 44 24 04 01 00 	movw   $0x1,0x4(%rsp)
    9091:	89 04 24             	mov    %eax,(%rsp)
    9094:	e8 77 b6 ff ff       	callq  4710 <poll@plt>
    9099:	89 c5                	mov    %eax,%ebp
    909b:	e8 c0 b2 ff ff       	callq  4360 <__errno_location@plt>
		if (!uc_ready()) {
    90a0:	ff cd                	dec    %ebp
    90a2:	49 89 c5             	mov    %rax,%r13
    90a5:	74 0c                	je     90b3 <rx_thread+0x74>
	return z_impl_k_sleep(timeout);
    90a7:	bf 02 00 00 00       	mov    $0x2,%edi
    90ac:	e8 15 2e 02 00       	callq  2bec6 <z_impl_k_sleep>
			continue;
    90b1:	eb c0                	jmp    9073 <rx_thread+0x34>
	return __read_chk (__fd, __buf, __nbytes, __bos0 (__buf));

      if (__nbytes > __bos0 (__buf))
	return __read_chk_warn (__fd, __buf, __nbytes, __bos0 (__buf));
    }
  return __read_alias (__fd, __buf, __nbytes);
    90b3:	8b 3d f3 d9 22 00    	mov    0x22d9f3(%rip),%edi        # 236aac <uc_fd>
    90b9:	48 8d 35 20 d6 24 00 	lea    0x24d620(%rip),%rsi        # 2566e0 <frame.9200>
    90c0:	ba 00 02 00 00       	mov    $0x200,%edx
    90c5:	e8 26 b6 ff ff       	callq  46f0 <read@plt>
		if (len < 0) {
    90ca:	48 85 c0             	test   %rax,%rax
    90cd:	48 89 c5             	mov    %rax,%rbp
    90d0:	79 4f                	jns    9121 <rx_thread+0xe2>
			if (errno == EINTR) {
    90d2:	49 63 75 00          	movslq 0x0(%r13),%rsi
    90d6:	83 fe 04             	cmp    $0x4,%esi
    90d9:	0f 84 df 00 00 00    	je     91be <rx_thread+0x17f>
			BT_ERR("Reading socket failed, errno %d", errno);
    90df:	c1 e3 06             	shl    $0x6,%ebx
    90e2:	48 8d 3d c9 82 02 00 	lea    0x282c9(%rip),%rdi        # 313b2 <__func__.5785+0x74a>
    90e9:	89 da                	mov    %ebx,%edx
    90eb:	83 ca 01             	or     $0x1,%edx
    90ee:	e8 02 e2 ff ff       	callq  72f5 <log_1>
			close(uc_fd);
    90f3:	8b 3d b3 d9 22 00    	mov    0x22d9b3(%rip),%edi        # 236aac <uc_fd>
    90f9:	e8 b2 b6 ff ff       	callq  47b0 <close@plt>
}
    90fe:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    9103:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    910a:	00 00 
			uc_fd = -1;
    910c:	c7 05 96 d9 22 00 ff 	movl   $0xffffffff,0x22d996(%rip)        # 236aac <uc_fd>
    9113:	ff ff ff 
}
    9116:	0f 84 ae 00 00 00    	je     91ca <rx_thread+0x18b>
    911c:	e8 1f b5 ff ff       	callq  4640 <__stack_chk_fail@plt>
	switch (buf[0]) {
    9121:	8a 05 b9 d5 24 00    	mov    0x24d5b9(%rip),%al        # 2566e0 <frame.9200>
	k_timeout_t timeout = K_FOREVER;
    9127:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
	switch (buf[0]) {
    912b:	3c 02                	cmp    $0x2,%al
    912d:	74 3c                	je     916b <rx_thread+0x12c>
    912f:	3c 04                	cmp    $0x4,%al
    9131:	75 6f                	jne    91a2 <rx_thread+0x163>
		if (buf[1] == BT_HCI_EVT_LE_META_EVENT &&
    9133:	0f b6 3d a7 d5 24 00 	movzbl 0x24d5a7(%rip),%edi        # 2566e1 <frame.9200+0x1>
	bool discardable = false;
    913a:	31 c0                	xor    %eax,%eax
		if (buf[1] == BT_HCI_EVT_LE_META_EVENT &&
    913c:	40 80 ff 3e          	cmp    $0x3e,%dil
    9140:	75 1f                	jne    9161 <rx_thread+0x122>
		    (buf[3] == BT_HCI_EVT_LE_ADVERTISING_REPORT ||
    9142:	8a 0d 9b d5 24 00    	mov    0x24d59b(%rip),%cl        # 2566e3 <frame.9200+0x3>
    9148:	80 f9 02             	cmp    $0x2,%cl
    914b:	0f 94 c0             	sete   %al
    914e:	80 f9 0d             	cmp    $0xd,%cl
			timeout = K_NO_WAIT;
    9151:	b9 00 00 00 00       	mov    $0x0,%ecx
		    (buf[3] == BT_HCI_EVT_LE_ADVERTISING_REPORT ||
    9156:	40 0f 94 c6          	sete   %sil
			timeout = K_NO_WAIT;
    915a:	40 08 f0             	or     %sil,%al
    915d:	48 0f 45 d1          	cmovne %rcx,%rdx
		return bt_buf_get_evt(buf[1], discardable, timeout);
    9161:	0f b6 f0             	movzbl %al,%esi
    9164:	e8 a1 45 00 00       	callq  d70a <bt_buf_get_evt>
    9169:	eb 0d                	jmp    9178 <rx_thread+0x139>
		return bt_buf_get_rx(BT_BUF_ACL_IN, K_FOREVER);
    916b:	48 89 d6             	mov    %rdx,%rsi
    916e:	bf 03 00 00 00       	mov    $0x3,%edi
    9173:	e8 ec 44 00 00       	callq  d664 <bt_buf_get_rx>
		if (!buf) {
    9178:	48 85 c0             	test   %rax,%rax
		return bt_buf_get_rx(BT_BUF_ACL_IN, K_FOREVER);
    917b:	49 89 c5             	mov    %rax,%r13
		if (!buf) {
    917e:	0f 84 ef fe ff ff    	je     9073 <rx_thread+0x34>
		net_buf_add_mem(buf, &frame[1], len - 1);
    9184:	48 8d 55 ff          	lea    -0x1(%rbp),%rdx
	return net_buf_simple_add_mem(&buf->b, mem, len);
    9188:	48 8d 78 10          	lea    0x10(%rax),%rdi
    918c:	48 8d 35 4e d5 24 00 	lea    0x24d54e(%rip),%rsi        # 2566e1 <frame.9200+0x1>
    9193:	e8 02 ff 00 00       	callq  1909a <net_buf_simple_add_mem>
		bt_recv(buf);
    9198:	4c 89 ef             	mov    %r13,%rdi
    919b:	e8 da 64 00 00       	callq  f67a <bt_recv>
    91a0:	eb 1c                	jmp    91be <rx_thread+0x17f>
		BT_ERR("Unknown packet type: %u", buf[0]);
    91a2:	89 da                	mov    %ebx,%edx
    91a4:	48 8d 3d 27 82 02 00 	lea    0x28227(%rip),%rdi        # 313d2 <__func__.5785+0x76a>
    91ab:	0f b6 f0             	movzbl %al,%esi
    91ae:	c1 e2 06             	shl    $0x6,%edx
    91b1:	83 ca 01             	or     $0x1,%edx
    91b4:	e8 3c e1 ff ff       	callq  72f5 <log_1>
    91b9:	e9 b5 fe ff ff       	jmpq   9073 <rx_thread+0x34>
	z_impl_k_yield();
    91be:	31 c0                	xor    %eax,%eax
    91c0:	e8 31 2c 02 00       	callq  2bdf6 <z_impl_k_yield>
    91c5:	e9 a9 fe ff ff       	jmpq   9073 <rx_thread+0x34>
}
    91ca:	48 83 c4 18          	add    $0x18,%rsp
    91ce:	5b                   	pop    %rbx
    91cf:	5d                   	pop    %rbp
    91d0:	41 5c                	pop    %r12
    91d2:	41 5d                	pop    %r13
    91d4:	c3                   	retq   

00000000000091d5 <uc_open>:
{
    91d5:	55                   	push   %rbp
    91d6:	53                   	push   %rbx
    91d7:	48 83 ec 18          	sub    $0x18,%rsp
	if (bt_dev_index < 0) {
    91db:	8b 2d c7 d8 22 00    	mov    0x22d8c7(%rip),%ebp        # 236aa8 <bt_dev_index>
{
    91e1:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    91e8:	00 00 
    91ea:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    91ef:	31 c0                	xor    %eax,%eax
	if (bt_dev_index < 0) {
    91f1:	85 ed                	test   %ebp,%ebp
    91f3:	79 2e                	jns    9223 <uc_open+0x4e>
    91f5:	48 8d 35 b4 11 23 00 	lea    0x2311b4(%rip),%rsi        # 23a3b0 <log_const_bt_driver>
    91fc:	48 2b 35 4d cd 22 00 	sub    0x22cd4d(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("No Bluetooth device specified");
    9203:	48 8d 3d e0 81 02 00 	lea    0x281e0(%rip),%rdi        # 313ea <__func__.5785+0x782>
    920a:	bb ed ff ff ff       	mov    $0xffffffed,%ebx
    920f:	48 c1 ee 04          	shr    $0x4,%rsi
    9213:	c1 e6 06             	shl    $0x6,%esi
    9216:	83 ce 01             	or     $0x1,%esi
    9219:	e8 a6 e0 ff ff       	callq  72c4 <log_0>
    921e:	e9 9c 00 00 00       	jmpq   92bf <uc_open+0xea>
	fd = socket(PF_BLUETOOTH, SOCK_RAW | SOCK_CLOEXEC | SOCK_NONBLOCK,
    9223:	ba 01 00 00 00       	mov    $0x1,%edx
    9228:	be 03 08 08 00       	mov    $0x80803,%esi
    922d:	bf 1f 00 00 00       	mov    $0x1f,%edi
    9232:	e8 99 b1 ff ff       	callq  43d0 <socket@plt>
	if (fd < 0) {
    9237:	85 c0                	test   %eax,%eax
	fd = socket(PF_BLUETOOTH, SOCK_RAW | SOCK_CLOEXEC | SOCK_NONBLOCK,
    9239:	89 c3                	mov    %eax,%ebx
	if (fd < 0) {
    923b:	79 0b                	jns    9248 <uc_open+0x73>
		return -errno;
    923d:	e8 1e b1 ff ff       	callq  4360 <__errno_location@plt>
    9242:	8b 18                	mov    (%rax),%ebx
    9244:	f7 db                	neg    %ebx
    9246:	eb 3a                	jmp    9282 <uc_open+0xad>
	if (bind(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
    9248:	48 8d 74 24 02       	lea    0x2(%rsp),%rsi
    924d:	ba 06 00 00 00       	mov    $0x6,%edx
    9252:	89 c7                	mov    %eax,%edi
	addr.hci_family = AF_BLUETOOTH;
    9254:	66 c7 44 24 02 1f 00 	movw   $0x1f,0x2(%rsp)
	addr.hci_dev = index;
    925b:	66 89 6c 24 04       	mov    %bp,0x4(%rsp)
	addr.hci_channel = HCI_CHANNEL_USER;
    9260:	66 c7 44 24 06 01 00 	movw   $0x1,0x6(%rsp)
	if (bind(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
    9267:	e8 54 b1 ff ff       	callq  43c0 <bind@plt>
    926c:	85 c0                	test   %eax,%eax
    926e:	79 12                	jns    9282 <uc_open+0xad>
		int err = -errno;
    9270:	e8 eb b0 ff ff       	callq  4360 <__errno_location@plt>
    9275:	8b 28                	mov    (%rax),%ebp
		close(fd);
    9277:	89 df                	mov    %ebx,%edi
    9279:	e8 32 b5 ff ff       	callq  47b0 <close@plt>
		int err = -errno;
    927e:	f7 dd                	neg    %ebp
		return err;
    9280:	89 eb                	mov    %ebp,%ebx
	if (uc_fd < 0) {
    9282:	85 db                	test   %ebx,%ebx
	uc_fd = user_chan_open(bt_dev_index);
    9284:	89 1d 22 d8 22 00    	mov    %ebx,0x22d822(%rip)        # 236aac <uc_fd>
	if (uc_fd < 0) {
    928a:	78 33                	js     92bf <uc_open+0xea>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    928c:	48 8d 0d ac fd ff ff 	lea    -0x254(%rip),%rcx        # 903f <rx_thread>
    9293:	6a 00                	pushq  $0x0
    9295:	48 8d 35 24 e0 22 00 	lea    0x22e024(%rip),%rsi        # 2372c0 <rx_thread_stack>
    929c:	6a 00                	pushq  $0x0
    929e:	48 8d 3d 3b d6 24 00 	lea    0x24d63b(%rip),%rdi        # 2568e0 <rx_thread_data>
    92a5:	6a f6                	pushq  $0xfffffffffffffff6
    92a7:	6a 00                	pushq  $0x0
    92a9:	45 31 c9             	xor    %r9d,%r9d
    92ac:	45 31 c0             	xor    %r8d,%r8d
    92af:	ba 28 00 00 00       	mov    $0x28,%edx
	return 0;
    92b4:	31 db                	xor    %ebx,%ebx
    92b6:	e8 55 2e 02 00       	callq  2c110 <z_impl_k_thread_create>
    92bb:	48 83 c4 20          	add    $0x20,%rsp
}
    92bf:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    92c4:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    92cb:	00 00 
    92cd:	89 d8                	mov    %ebx,%eax
    92cf:	74 05                	je     92d6 <uc_open+0x101>
    92d1:	e8 6a b3 ff ff       	callq  4640 <__stack_chk_fail@plt>
    92d6:	48 83 c4 18          	add    $0x18,%rsp
    92da:	5b                   	pop    %rbx
    92db:	5d                   	pop    %rbp
    92dc:	c3                   	retq   

00000000000092dd <np_timer_isr>:
/**
 * Interrupt handler for the timer interrupt
 * Announce to the kernel that a number of ticks have passed
 */
static void np_timer_isr(const void *arg)
{
    92dd:	48 83 ec 08          	sub    $0x8,%rsp
	ARG_UNUSED(arg);

	uint64_t now = hwm_get_time();
    92e1:	e8 6e 26 00 00       	callq  b954 <hwm_get_time>
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
    92e6:	48 8b 35 eb eb 24 00 	mov    0x24ebeb(%rip),%rsi        # 257ed8 <last_tick_time>
    92ed:	48 8b 0d ec eb 24 00 	mov    0x24ebec(%rip),%rcx        # 257ee0 <tick_period>
    92f4:	31 d2                	xor    %edx,%edx
    92f6:	48 29 f0             	sub    %rsi,%rax
    92f9:	48 f7 f1             	div    %rcx

	last_tick_time += elapsed_ticks*tick_period;
    92fc:	48 63 d0             	movslq %eax,%rdx
	z_clock_announce(elapsed_ticks);
    92ff:	89 c7                	mov    %eax,%edi
	last_tick_time += elapsed_ticks*tick_period;
    9301:	48 0f af d1          	imul   %rcx,%rdx
    9305:	48 01 f2             	add    %rsi,%rdx
    9308:	48 89 15 c9 eb 24 00 	mov    %rdx,0x24ebc9(%rip)        # 257ed8 <last_tick_time>
}
    930f:	58                   	pop    %rax
	z_clock_announce(elapsed_ticks);
    9310:	e9 b4 33 02 00       	jmpq   2c6c9 <z_clock_announce>

0000000000009315 <z_timer_cycle_get_32>:
{
    9315:	48 83 ec 08          	sub    $0x8,%rsp
	return hwm_get_time();
    9319:	e8 36 26 00 00       	callq  b954 <hwm_get_time>
}
    931e:	5a                   	pop    %rdx
    931f:	c3                   	retq   

0000000000009320 <z_clock_driver_init>:
 * @brief Initialize system timer driver
 *
 * Enable the hw timer, setting its tick period, and setup its interrupt
 */
int z_clock_driver_init(const struct device *device)
{
    9320:	48 83 ec 08          	sub    $0x8,%rsp
	ARG_UNUSED(device);

	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
    9324:	48 c7 05 b1 eb 24 00 	movq   $0x2710,0x24ebb1(%rip)        # 257ee0 <tick_period>
    932b:	10 27 00 00 

	last_tick_time = hwm_get_time();
    932f:	e8 20 26 00 00       	callq  b954 <hwm_get_time>
	hwtimer_enable(tick_period);
    9334:	48 8b 3d a5 eb 24 00 	mov    0x24eba5(%rip),%rdi        # 257ee0 <tick_period>
	last_tick_time = hwm_get_time();
    933b:	48 89 05 96 eb 24 00 	mov    %rax,0x24eb96(%rip)        # 257ed8 <last_tick_time>
	hwtimer_enable(tick_period);
    9342:	e8 a3 28 00 00       	callq  bbea <hwtimer_enable>

	IRQ_CONNECT(TIMER_TICK_IRQ, 1, np_timer_isr, 0, 0);
    9347:	48 8d 15 8f ff ff ff 	lea    -0x71(%rip),%rdx        # 92dd <np_timer_isr>
    934e:	31 c9                	xor    %ecx,%ecx
    9350:	31 f6                	xor    %esi,%esi
    9352:	31 ff                	xor    %edi,%edi
    9354:	e8 54 2c 00 00       	callq  bfad <posix_isr_declare>
    9359:	31 d2                	xor    %edx,%edx
    935b:	be 01 00 00 00       	mov    $0x1,%esi
    9360:	31 ff                	xor    %edi,%edi
    9362:	e8 64 2c 00 00       	callq  bfcb <posix_irq_priority_set>
	irq_enable(TIMER_TICK_IRQ);
    9367:	31 ff                	xor    %edi,%edi
    9369:	e8 79 11 00 00       	callq  a4e7 <arch_irq_enable>

	return 0;
}
    936e:	31 c0                	xor    %eax,%eax
    9370:	5a                   	pop    %rdx
    9371:	c3                   	retq   

0000000000009372 <z_clock_set_timeout>:
 * @param ticks Timeout in tick units
 * @param idle Hint to the driver that the system is about to enter
 *        the idle state immediately after setting the timeout
 */
void z_clock_set_timeout(int32_t ticks, bool idle)
{
    9372:	89 f8                	mov    %edi,%eax

	/* Note that we treat INT_MAX literally as anyhow the maximum amount of
	 * ticks we can report with z_clock_announce() is INT_MAX
	 */
	if (ticks == K_TICKS_FOREVER) {
		silent_ticks = INT64_MAX;
    9374:	48 bf ff ff ff ff ff 	movabs $0x7fffffffffffffff,%rdi
    937b:	ff ff 7f 
	if (ticks == K_TICKS_FOREVER) {
    937e:	83 f8 ff             	cmp    $0xffffffff,%eax
    9381:	74 0b                	je     938e <z_clock_set_timeout+0x1c>
	} else if (ticks > 0) {
		silent_ticks = ticks - 1;
	} else {
		silent_ticks = 0;
    9383:	31 ff                	xor    %edi,%edi
	} else if (ticks > 0) {
    9385:	85 c0                	test   %eax,%eax
    9387:	7e 05                	jle    938e <z_clock_set_timeout+0x1c>
		silent_ticks = ticks - 1;
    9389:	ff c8                	dec    %eax
    938b:	48 63 f8             	movslq %eax,%rdi
	}
	hwtimer_set_silent_ticks(silent_ticks);
    938e:	e9 0c 2a 00 00       	jmpq   bd9f <hwtimer_set_silent_ticks>

0000000000009393 <z_clock_elapsed>:
 * last call to z_clock_announce() was made.  The kernel will call
 * this with appropriate locking, the driver needs only provide an
 * instantaneous answer.
 */
uint32_t z_clock_elapsed(void)
{
    9393:	48 83 ec 08          	sub    $0x8,%rsp
	return (hwm_get_time() - last_tick_time)/tick_period;
    9397:	e8 b8 25 00 00       	callq  b954 <hwm_get_time>
    939c:	48 2b 05 35 eb 24 00 	sub    0x24eb35(%rip),%rax        # 257ed8 <last_tick_time>
    93a3:	31 d2                	xor    %edx,%edx
    93a5:	48 f7 35 34 eb 24 00 	divq   0x24eb34(%rip)        # 257ee0 <tick_period>
}
    93ac:	5a                   	pop    %rdx
    93ad:	c3                   	retq   

00000000000093ae <_copy>:
#define MASK_TWENTY_SEVEN 0x1b

unsigned int _copy(uint8_t *to, unsigned int to_len,
		   const uint8_t *from, unsigned int from_len)
{
	if (from_len <= to_len) {
    93ae:	39 f1                	cmp    %esi,%ecx
{
    93b0:	89 c8                	mov    %ecx,%eax
	if (from_len <= to_len) {
    93b2:	77 08                	ja     93bc <_copy+0xe>
    93b4:	48 89 d6             	mov    %rdx,%rsi
		(void)memcpy(to, from, from_len);
    93b7:	89 c9                	mov    %ecx,%ecx
    93b9:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		return from_len;
    93bb:	c3                   	retq   
	} else {
		return TC_CRYPTO_FAIL;
    93bc:	31 c0                	xor    %eax,%eax
	}
}
    93be:	c3                   	retq   

00000000000093bf <_set>:

void _set(void *to, uint8_t val, unsigned int len)
{
	(void)memset(to, val, len);
    93bf:	89 d1                	mov    %edx,%ecx
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    93c1:	40 88 f0             	mov    %sil,%al
    93c4:	f3 aa                	rep stos %al,%es:(%rdi)
}
    93c6:	c3                   	retq   

00000000000093c7 <_double_byte>:
/*
 * Doubles the value of a byte for values up to 127.
 */
uint8_t _double_byte(uint8_t a)
{
	return ((a<<1) ^ ((a>>7) * MASK_TWENTY_SEVEN));
    93c7:	40 88 f8             	mov    %dil,%al
    93ca:	b2 1b                	mov    $0x1b,%dl
    93cc:	01 ff                	add    %edi,%edi
    93ce:	c0 e8 07             	shr    $0x7,%al
    93d1:	0f af c2             	imul   %edx,%eax
    93d4:	31 f8                	xor    %edi,%eax
}
    93d6:	c3                   	retq   

00000000000093d7 <add_round_key>:
	return TC_CRYPTO_SUCCESS;
}

static inline void add_round_key(uint8_t *s, const unsigned int *k)
{
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
    93d7:	8a 46 03             	mov    0x3(%rsi),%al
    93da:	30 07                	xor    %al,(%rdi)
    93dc:	8a 46 02             	mov    0x2(%rsi),%al
    93df:	30 47 01             	xor    %al,0x1(%rdi)
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
    93e2:	8a 46 01             	mov    0x1(%rsi),%al
    93e5:	30 47 02             	xor    %al,0x2(%rdi)
    93e8:	8b 06                	mov    (%rsi),%eax
    93ea:	30 47 03             	xor    %al,0x3(%rdi)
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
    93ed:	0f b6 46 07          	movzbl 0x7(%rsi),%eax
    93f1:	30 47 04             	xor    %al,0x4(%rdi)
    93f4:	0f b7 46 06          	movzwl 0x6(%rsi),%eax
    93f8:	30 47 05             	xor    %al,0x5(%rdi)
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
    93fb:	8a 46 05             	mov    0x5(%rsi),%al
    93fe:	30 47 06             	xor    %al,0x6(%rdi)
    9401:	8b 46 04             	mov    0x4(%rsi),%eax
    9404:	30 47 07             	xor    %al,0x7(%rdi)
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
    9407:	0f b6 46 0b          	movzbl 0xb(%rsi),%eax
    940b:	30 47 08             	xor    %al,0x8(%rdi)
    940e:	0f b7 46 0a          	movzwl 0xa(%rsi),%eax
    9412:	30 47 09             	xor    %al,0x9(%rdi)
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
    9415:	8a 46 09             	mov    0x9(%rsi),%al
    9418:	30 47 0a             	xor    %al,0xa(%rdi)
    941b:	8b 46 08             	mov    0x8(%rsi),%eax
    941e:	30 47 0b             	xor    %al,0xb(%rdi)
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
    9421:	0f b6 46 0f          	movzbl 0xf(%rsi),%eax
    9425:	30 47 0c             	xor    %al,0xc(%rdi)
    9428:	0f b7 46 0e          	movzwl 0xe(%rsi),%eax
    942c:	30 47 0d             	xor    %al,0xd(%rdi)
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
    942f:	8a 46 0d             	mov    0xd(%rsi),%al
    9432:	30 47 0e             	xor    %al,0xe(%rdi)
    9435:	8b 46 0c             	mov    0xc(%rsi),%eax
    9438:	30 47 0f             	xor    %al,0xf(%rdi)
}
    943b:	c3                   	retq   

000000000000943c <shift_rows>:
/*
 * This shift_rows also implements the matrix flip required for mix_columns, but
 * performs it here to reduce the number of memory operations.
 */
static inline void shift_rows(uint8_t *s)
{
    943c:	48 83 ec 28          	sub    $0x28,%rsp

	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
	(void) _copy(s, sizeof(t), t, sizeof(t));
    9440:	b9 10 00 00 00       	mov    $0x10,%ecx
    9445:	be 10 00 00 00       	mov    $0x10,%esi
{
    944a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    9451:	00 00 
    9453:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    9458:	31 c0                	xor    %eax,%eax
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
    945a:	8a 07                	mov    (%rdi),%al
	(void) _copy(s, sizeof(t), t, sizeof(t));
    945c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
    9461:	88 44 24 08          	mov    %al,0x8(%rsp)
    9465:	8a 47 05             	mov    0x5(%rdi),%al
    9468:	88 44 24 09          	mov    %al,0x9(%rsp)
    946c:	8a 47 0a             	mov    0xa(%rdi),%al
    946f:	88 44 24 0a          	mov    %al,0xa(%rsp)
    9473:	8a 47 0f             	mov    0xf(%rdi),%al
    9476:	88 44 24 0b          	mov    %al,0xb(%rsp)
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
    947a:	8a 47 04             	mov    0x4(%rdi),%al
    947d:	88 44 24 0c          	mov    %al,0xc(%rsp)
    9481:	8a 47 09             	mov    0x9(%rdi),%al
    9484:	88 44 24 0d          	mov    %al,0xd(%rsp)
    9488:	8a 47 0e             	mov    0xe(%rdi),%al
    948b:	88 44 24 0e          	mov    %al,0xe(%rsp)
    948f:	8a 47 03             	mov    0x3(%rdi),%al
    9492:	88 44 24 0f          	mov    %al,0xf(%rsp)
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
    9496:	8a 47 08             	mov    0x8(%rdi),%al
    9499:	88 44 24 10          	mov    %al,0x10(%rsp)
    949d:	8a 47 0d             	mov    0xd(%rdi),%al
    94a0:	88 44 24 11          	mov    %al,0x11(%rsp)
    94a4:	8a 47 02             	mov    0x2(%rdi),%al
    94a7:	88 44 24 12          	mov    %al,0x12(%rsp)
    94ab:	8a 47 07             	mov    0x7(%rdi),%al
    94ae:	88 44 24 13          	mov    %al,0x13(%rsp)
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
    94b2:	8a 47 0c             	mov    0xc(%rdi),%al
    94b5:	88 44 24 14          	mov    %al,0x14(%rsp)
    94b9:	8a 47 01             	mov    0x1(%rdi),%al
    94bc:	88 44 24 15          	mov    %al,0x15(%rsp)
    94c0:	8a 47 06             	mov    0x6(%rdi),%al
    94c3:	88 44 24 16          	mov    %al,0x16(%rsp)
    94c7:	8a 47 0b             	mov    0xb(%rdi),%al
    94ca:	88 44 24 17          	mov    %al,0x17(%rsp)
	(void) _copy(s, sizeof(t), t, sizeof(t));
    94ce:	e8 db fe ff ff       	callq  93ae <_copy>
}
    94d3:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    94d8:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    94df:	00 00 
    94e1:	74 05                	je     94e8 <shift_rows+0xac>
    94e3:	e8 58 b1 ff ff       	callq  4640 <__stack_chk_fail@plt>
    94e8:	48 83 c4 28          	add    $0x28,%rsp
    94ec:	c3                   	retq   

00000000000094ed <mult_row_column>:
{
    94ed:	41 55                	push   %r13
    94ef:	41 54                	push   %r12
    94f1:	49 89 fc             	mov    %rdi,%r12
    94f4:	55                   	push   %rbp
    94f5:	53                   	push   %rbx
    94f6:	48 89 f3             	mov    %rsi,%rbx
    94f9:	48 83 ec 08          	sub    $0x8,%rsp
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
    94fd:	0f b6 3e             	movzbl (%rsi),%edi
    9500:	e8 c2 fe ff ff       	callq  93c7 <_double_byte>
    9505:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    9509:	40 88 c5             	mov    %al,%bpl
    950c:	e8 b6 fe ff ff       	callq  93c7 <_double_byte>
    9511:	8a 53 01             	mov    0x1(%rbx),%dl
    9514:	32 53 02             	xor    0x2(%rbx),%dl
    9517:	32 53 03             	xor    0x3(%rbx),%dl
    951a:	31 ea                	xor    %ebp,%edx
    951c:	31 d0                	xor    %edx,%eax
    951e:	41 88 04 24          	mov    %al,(%r12)
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
    9522:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    9526:	40 8a 2b             	mov    (%rbx),%bpl
    9529:	e8 99 fe ff ff       	callq  93c7 <_double_byte>
    952e:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    9532:	41 88 c5             	mov    %al,%r13b
    9535:	e8 8d fe ff ff       	callq  93c7 <_double_byte>
    953a:	40 32 6b 02          	xor    0x2(%rbx),%bpl
    953e:	40 32 6b 03          	xor    0x3(%rbx),%bpl
    9542:	44 31 ed             	xor    %r13d,%ebp
    9545:	31 e8                	xor    %ebp,%eax
    9547:	41 88 44 24 01       	mov    %al,0x1(%r12)
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
    954c:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    9550:	40 8a 2b             	mov    (%rbx),%bpl
    9553:	40 32 6b 01          	xor    0x1(%rbx),%bpl
    9557:	e8 6b fe ff ff       	callq  93c7 <_double_byte>
    955c:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    9560:	41 88 c5             	mov    %al,%r13b
    9563:	e8 5f fe ff ff       	callq  93c7 <_double_byte>
    9568:	40 32 6b 03          	xor    0x3(%rbx),%bpl
    956c:	44 31 ed             	xor    %r13d,%ebp
    956f:	31 e8                	xor    %ebp,%eax
    9571:	41 88 44 24 02       	mov    %al,0x2(%r12)
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
    9576:	0f b6 3b             	movzbl (%rbx),%edi
    9579:	e8 49 fe ff ff       	callq  93c7 <_double_byte>
    957e:	40 8a 2b             	mov    (%rbx),%bpl
    9581:	40 32 6b 01          	xor    0x1(%rbx),%bpl
    9585:	40 32 6b 02          	xor    0x2(%rbx),%bpl
    9589:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    958d:	31 c5                	xor    %eax,%ebp
    958f:	e8 33 fe ff ff       	callq  93c7 <_double_byte>
    9594:	31 c5                	xor    %eax,%ebp
    9596:	41 88 6c 24 03       	mov    %bpl,0x3(%r12)
}
    959b:	58                   	pop    %rax
    959c:	5b                   	pop    %rbx
    959d:	5d                   	pop    %rbp
    959e:	41 5c                	pop    %r12
    95a0:	41 5d                	pop    %r13
    95a2:	c3                   	retq   

00000000000095a3 <tc_aes128_set_encrypt_key>:
{
    95a3:	48 83 ec 48          	sub    $0x48,%rsp
    95a7:	49 89 f8             	mov    %rdi,%r8
    95aa:	49 89 f1             	mov    %rsi,%r9
    95ad:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    95b4:	00 00 
    95b6:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    95bb:	31 c0                	xor    %eax,%eax
	} else if (k == (const uint8_t *) 0) {
    95bd:	4d 85 c0             	test   %r8,%r8
	const unsigned int rconst[11] = {
    95c0:	48 8d 7c 24 0c       	lea    0xc(%rsp),%rdi
    95c5:	48 8d 35 94 39 02 00 	lea    0x23994(%rip),%rsi        # 2cf60 <_fini+0x20>
    95cc:	b9 0b 00 00 00       	mov    $0xb,%ecx
    95d1:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
	} else if (k == (const uint8_t *) 0) {
    95d3:	0f 84 ad 00 00 00    	je     9686 <tc_aes128_set_encrypt_key+0xe3>
    95d9:	4d 85 c9             	test   %r9,%r9
    95dc:	0f 84 a4 00 00 00    	je     9686 <tc_aes128_set_encrypt_key+0xe3>
    95e2:	31 d2                	xor    %edx,%edx
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
    95e4:	41 0f b6 04 11       	movzbl (%r9,%rdx,1),%eax
    95e9:	41 0f b6 4c 11 01    	movzbl 0x1(%r9,%rdx,1),%ecx
    95ef:	c1 e0 18             	shl    $0x18,%eax
    95f2:	c1 e1 10             	shl    $0x10,%ecx
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
    95f5:	09 c8                	or     %ecx,%eax
    95f7:	41 0f b6 4c 11 03    	movzbl 0x3(%r9,%rdx,1),%ecx
    95fd:	09 c8                	or     %ecx,%eax
    95ff:	41 0f b6 4c 11 02    	movzbl 0x2(%r9,%rdx,1),%ecx
    9605:	c1 e1 08             	shl    $0x8,%ecx
    9608:	09 c8                	or     %ecx,%eax
    960a:	41 89 04 10          	mov    %eax,(%r8,%rdx,1)
    960e:	48 83 c2 04          	add    $0x4,%rdx
	for (i = 0; i < Nk; ++i) {
    9612:	48 83 fa 10          	cmp    $0x10,%rdx
    9616:	75 cc                	jne    95e4 <tc_aes128_set_encrypt_key+0x41>
			t = subword(rotword(t)) ^ rconst[i/Nk];
    9618:	48 8d 3d 81 39 02 00 	lea    0x23981(%rip),%rdi        # 2cfa0 <sbox>
    961f:	be 04 00 00 00       	mov    $0x4,%esi
		if ((i % Nk) == 0) {
    9624:	40 f6 c6 03          	test   $0x3,%sil
		t = s->words[i-1];
    9628:	41 8b 44 b0 fc       	mov    -0x4(%r8,%rsi,4),%eax
		if ((i % Nk) == 0) {
    962d:	75 3e                	jne    966d <tc_aes128_set_encrypt_key+0xca>
	return (((a) >> 24)|((a) << 8));
    962f:	c1 c0 08             	rol    $0x8,%eax
			t = subword(rotword(t)) ^ rconst[i/Nk];
    9632:	89 c2                	mov    %eax,%edx
    9634:	c1 ea 18             	shr    $0x18,%edx
    9637:	0f b6 0c 17          	movzbl (%rdi,%rdx,1),%ecx
    963b:	0f b6 d0             	movzbl %al,%edx
    963e:	0f b6 14 17          	movzbl (%rdi,%rdx,1),%edx
    9642:	c1 e1 18             	shl    $0x18,%ecx
    9645:	09 d1                	or     %edx,%ecx
    9647:	89 c2                	mov    %eax,%edx
    9649:	0f b6 c4             	movzbl %ah,%eax
    964c:	c1 ea 10             	shr    $0x10,%edx
    964f:	0f b6 04 07          	movzbl (%rdi,%rax,1),%eax
    9653:	0f b6 d2             	movzbl %dl,%edx
    9656:	0f b6 14 17          	movzbl (%rdi,%rdx,1),%edx
    965a:	c1 e0 08             	shl    $0x8,%eax
    965d:	c1 e2 10             	shl    $0x10,%edx
    9660:	09 d1                	or     %edx,%ecx
    9662:	89 f2                	mov    %esi,%edx
    9664:	c1 ea 02             	shr    $0x2,%edx
    9667:	09 c8                	or     %ecx,%eax
    9669:	33 44 94 0c          	xor    0xc(%rsp,%rdx,4),%eax
		s->words[i] = s->words[i-Nk] ^ t;
    966d:	41 33 44 b0 f0       	xor    -0x10(%r8,%rsi,4),%eax
    9672:	41 89 04 b0          	mov    %eax,(%r8,%rsi,4)
    9676:	48 ff c6             	inc    %rsi
	for (; i < (Nb * (Nr + 1)); ++i) {
    9679:	48 83 fe 2c          	cmp    $0x2c,%rsi
    967d:	75 a5                	jne    9624 <tc_aes128_set_encrypt_key+0x81>
	return TC_CRYPTO_SUCCESS;
    967f:	b8 01 00 00 00       	mov    $0x1,%eax
    9684:	eb 02                	jmp    9688 <tc_aes128_set_encrypt_key+0xe5>
		return TC_CRYPTO_FAIL;
    9686:	31 c0                	xor    %eax,%eax
}
    9688:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
    968d:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
    9694:	00 00 
    9696:	74 05                	je     969d <tc_aes128_set_encrypt_key+0xfa>
    9698:	e8 a3 af ff ff       	callq  4640 <__stack_chk_fail@plt>
    969d:	48 83 c4 48          	add    $0x48,%rsp
    96a1:	c3                   	retq   

00000000000096a2 <tc_aes_encrypt>:

int tc_aes_encrypt(uint8_t *out, const uint8_t *in, const TCAesKeySched_t s)
{
    96a2:	41 57                	push   %r15
    96a4:	41 56                	push   %r14
    96a6:	41 55                	push   %r13
    96a8:	41 54                	push   %r12
    96aa:	55                   	push   %rbp
    96ab:	53                   	push   %rbx
    96ac:	48 89 d5             	mov    %rdx,%rbp
    96af:	48 83 ec 38          	sub    $0x38,%rsp
    96b3:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    96ba:	00 00 
    96bc:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    96c1:	31 c0                	xor    %eax,%eax

	if (out == (uint8_t *) 0) {
		return TC_CRYPTO_FAIL;
	} else if (in == (const uint8_t *) 0) {
		return TC_CRYPTO_FAIL;
	} else if (s == (TCAesKeySched_t) 0) {
    96c3:	48 85 d2             	test   %rdx,%rdx
    96c6:	0f 94 c2             	sete   %dl
	} else if (in == (const uint8_t *) 0) {
    96c9:	48 85 f6             	test   %rsi,%rsi
    96cc:	0f 94 c0             	sete   %al
	} else if (s == (TCAesKeySched_t) 0) {
    96cf:	08 c2                	or     %al,%dl
    96d1:	0f 85 1c 01 00 00    	jne    97f3 <tc_aes_encrypt+0x151>
    96d7:	48 85 ff             	test   %rdi,%rdi
    96da:	49 89 fd             	mov    %rdi,%r13
    96dd:	0f 84 10 01 00 00    	je     97f3 <tc_aes_encrypt+0x151>
		return TC_CRYPTO_FAIL;
	}

	(void)_copy(state, sizeof(state), in, sizeof(state));
    96e3:	48 8d 5c 24 08       	lea    0x8(%rsp),%rbx
    96e8:	48 89 f2             	mov    %rsi,%rdx
    96eb:	b9 10 00 00 00       	mov    $0x10,%ecx
    96f0:	be 10 00 00 00       	mov    $0x10,%esi
		s[i] = sbox[s[i]];
    96f5:	4c 8d 3d a4 38 02 00 	lea    0x238a4(%rip),%r15        # 2cfa0 <sbox>
    96fc:	4c 8d 75 10          	lea    0x10(%rbp),%r14
	(void)_copy(state, sizeof(state), in, sizeof(state));
    9700:	48 89 df             	mov    %rbx,%rdi
    9703:	e8 a6 fc ff ff       	callq  93ae <_copy>
	add_round_key(state, s->words);
    9708:	48 89 ee             	mov    %rbp,%rsi
    970b:	48 89 df             	mov    %rbx,%rdi
    970e:	48 81 c5 a0 00 00 00 	add    $0xa0,%rbp
    9715:	e8 bd fc ff ff       	callq  93d7 <add_round_key>
{
    971a:	31 c0                	xor    %eax,%eax
		s[i] = sbox[s[i]];
    971c:	0f b6 14 03          	movzbl (%rbx,%rax,1),%edx
    9720:	41 8a 14 17          	mov    (%r15,%rdx,1),%dl
    9724:	88 14 03             	mov    %dl,(%rbx,%rax,1)
    9727:	48 ff c0             	inc    %rax
	for (i = 0; i < (Nb * Nk); ++i) {
    972a:	48 83 f8 10          	cmp    $0x10,%rax
    972e:	75 ec                	jne    971c <tc_aes_encrypt+0x7a>
	mult_row_column(t, s);
    9730:	4c 8d 64 24 18       	lea    0x18(%rsp),%r12

	for (i = 0; i < (Nr - 1); ++i) {
		sub_bytes(state);
		shift_rows(state);
    9735:	48 89 df             	mov    %rbx,%rdi
    9738:	e8 ff fc ff ff       	callq  943c <shift_rows>
	mult_row_column(t, s);
    973d:	48 89 de             	mov    %rbx,%rsi
    9740:	4c 89 e7             	mov    %r12,%rdi
    9743:	e8 a5 fd ff ff       	callq  94ed <mult_row_column>
	mult_row_column(&t[Nb], s+Nb);
    9748:	48 8d 73 04          	lea    0x4(%rbx),%rsi
    974c:	49 8d 7c 24 04       	lea    0x4(%r12),%rdi
    9751:	e8 97 fd ff ff       	callq  94ed <mult_row_column>
	mult_row_column(&t[2 * Nb], s + (2 * Nb));
    9756:	48 8d 73 08          	lea    0x8(%rbx),%rsi
    975a:	49 8d 7c 24 08       	lea    0x8(%r12),%rdi
    975f:	e8 89 fd ff ff       	callq  94ed <mult_row_column>
	mult_row_column(&t[3 * Nb], s + (3 * Nb));
    9764:	48 8d 73 0c          	lea    0xc(%rbx),%rsi
    9768:	49 8d 7c 24 0c       	lea    0xc(%r12),%rdi
    976d:	e8 7b fd ff ff       	callq  94ed <mult_row_column>
	(void) _copy(s, sizeof(t), t, sizeof(t));
    9772:	b9 10 00 00 00       	mov    $0x10,%ecx
    9777:	4c 89 e2             	mov    %r12,%rdx
    977a:	be 10 00 00 00       	mov    $0x10,%esi
    977f:	48 89 df             	mov    %rbx,%rdi
    9782:	e8 27 fc ff ff       	callq  93ae <_copy>
		mix_columns(state);
		add_round_key(state, s->words + Nb*(i+1));
    9787:	4c 89 f6             	mov    %r14,%rsi
    978a:	48 89 df             	mov    %rbx,%rdi
    978d:	49 83 c6 10          	add    $0x10,%r14
    9791:	e8 41 fc ff ff       	callq  93d7 <add_round_key>
	for (i = 0; i < (Nr - 1); ++i) {
    9796:	4c 39 f5             	cmp    %r14,%rbp
    9799:	0f 85 7b ff ff ff    	jne    971a <tc_aes_encrypt+0x78>
    979f:	31 c0                	xor    %eax,%eax
		s[i] = sbox[s[i]];
    97a1:	0f b6 14 03          	movzbl (%rbx,%rax,1),%edx
    97a5:	41 8a 14 17          	mov    (%r15,%rdx,1),%dl
    97a9:	88 14 03             	mov    %dl,(%rbx,%rax,1)
    97ac:	48 ff c0             	inc    %rax
	for (i = 0; i < (Nb * Nk); ++i) {
    97af:	48 83 f8 10          	cmp    $0x10,%rax
    97b3:	75 ec                	jne    97a1 <tc_aes_encrypt+0xff>
	}

	sub_bytes(state);
	shift_rows(state);
    97b5:	48 89 df             	mov    %rbx,%rdi
    97b8:	e8 7f fc ff ff       	callq  943c <shift_rows>
	add_round_key(state, s->words + Nb*(i+1));
    97bd:	48 89 ee             	mov    %rbp,%rsi
    97c0:	48 89 df             	mov    %rbx,%rdi
    97c3:	e8 0f fc ff ff       	callq  93d7 <add_round_key>

	(void)_copy(out, sizeof(state), state, sizeof(state));
    97c8:	b9 10 00 00 00       	mov    $0x10,%ecx
    97cd:	48 89 da             	mov    %rbx,%rdx
    97d0:	be 10 00 00 00       	mov    $0x10,%esi
    97d5:	4c 89 ef             	mov    %r13,%rdi
    97d8:	e8 d1 fb ff ff       	callq  93ae <_copy>

	/* zeroing out the state buffer */
	_set(state, TC_ZERO_BYTE, sizeof(state));
    97dd:	ba 10 00 00 00       	mov    $0x10,%edx
    97e2:	31 f6                	xor    %esi,%esi
    97e4:	48 89 df             	mov    %rbx,%rdi
    97e7:	e8 d3 fb ff ff       	callq  93bf <_set>

	return TC_CRYPTO_SUCCESS;
    97ec:	b8 01 00 00 00       	mov    $0x1,%eax
    97f1:	eb 02                	jmp    97f5 <tc_aes_encrypt+0x153>
		return TC_CRYPTO_FAIL;
    97f3:	31 c0                	xor    %eax,%eax
}
    97f5:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
    97fa:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    9801:	00 00 
    9803:	74 05                	je     980a <tc_aes_encrypt+0x168>
    9805:	e8 36 ae ff ff       	callq  4640 <__stack_chk_fail@plt>
    980a:	48 83 c4 38          	add    $0x38,%rsp
    980e:	5b                   	pop    %rbx
    980f:	5d                   	pop    %rbp
    9810:	41 5c                	pop    %r12
    9812:	41 5d                	pop    %r13
    9814:	41 5e                	pop    %r14
    9816:	41 5f                	pop    %r15
    9818:	c3                   	retq   

0000000000009819 <gf_double>:

	/* start with low order byte */
	uint8_t *x = in + (TC_AES_BLOCK_SIZE - 1);

	/* if msb == 1, we need to add the gf_wrap value, otherwise add 0 */
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
    9819:	8a 06                	mov    (%rsi),%al
    981b:	ba 10 00 00 00       	mov    $0x10,%edx
    9820:	c0 f8 07             	sar    $0x7,%al
    9823:	83 e0 87             	and    $0xffffff87,%eax

	out += (TC_AES_BLOCK_SIZE - 1);
	for (;;) {
		*out-- = (*x << 1) ^ carry;
    9826:	0f b6 4c 16 ff       	movzbl -0x1(%rsi,%rdx,1),%ecx
    982b:	01 c9                	add    %ecx,%ecx
    982d:	31 c8                	xor    %ecx,%eax
    982f:	88 44 17 ff          	mov    %al,-0x1(%rdi,%rdx,1)
		if (x == in) {
    9833:	48 ff ca             	dec    %rdx
    9836:	74 08                	je     9840 <gf_double+0x27>
			break;
		}
		carry = *x-- >> 7;
    9838:	8a 04 16             	mov    (%rsi,%rdx,1),%al
    983b:	c0 e8 07             	shr    $0x7,%al
		*out-- = (*x << 1) ^ carry;
    983e:	eb e6                	jmp    9826 <gf_double+0xd>
	}
}
    9840:	c3                   	retq   

0000000000009841 <tc_cmac_erase>:
	return TC_CRYPTO_SUCCESS;
}

int tc_cmac_erase(TCCmacState_t s)
{
	if (s == (TCCmacState_t) 0) {
    9841:	48 85 ff             	test   %rdi,%rdi
    9844:	74 17                	je     985d <tc_cmac_erase+0x1c>
{
    9846:	48 83 ec 08          	sub    $0x8,%rsp
		return TC_CRYPTO_FAIL;
	}

	/* destroy the current state */
	_set(s, 0, sizeof(*s));
    984a:	ba 58 00 00 00       	mov    $0x58,%edx
    984f:	31 f6                	xor    %esi,%esi
    9851:	e8 69 fb ff ff       	callq  93bf <_set>
    9856:	b8 01 00 00 00       	mov    $0x1,%eax

	return TC_CRYPTO_SUCCESS;
}
    985b:	5a                   	pop    %rdx
    985c:	c3                   	retq   
    985d:	31 c0                	xor    %eax,%eax
    985f:	c3                   	retq   

0000000000009860 <tc_cmac_init>:

int tc_cmac_init(TCCmacState_t s)
{
	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
    9860:	48 85 ff             	test   %rdi,%rdi
    9863:	74 3c                	je     98a1 <tc_cmac_init+0x41>
{
    9865:	53                   	push   %rbx
		return TC_CRYPTO_FAIL;
	}

	/* CMAC starts with an all zero initialization vector */
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
    9866:	ba 10 00 00 00       	mov    $0x10,%edx
    986b:	48 89 fb             	mov    %rdi,%rbx
    986e:	31 f6                	xor    %esi,%esi
    9870:	e8 4a fb ff ff       	callq  93bf <_set>

	/* and the leftover buffer is empty */
	_set(s->leftover, 0, TC_AES_BLOCK_SIZE);
    9875:	48 8d 7b 30          	lea    0x30(%rbx),%rdi
    9879:	ba 10 00 00 00       	mov    $0x10,%edx
    987e:	31 f6                	xor    %esi,%esi
    9880:	e8 3a fb ff ff       	callq  93bf <_set>
	s->leftover_offset = 0;

	/* Set countdown to max number of calls allowed before re-keying: */
	s->countdown = MAX_CALLS;
    9885:	48 b8 00 00 00 00 00 	movabs $0x1000000000000,%rax
    988c:	00 01 00 
	s->leftover_offset = 0;
    988f:	c7 43 44 00 00 00 00 	movl   $0x0,0x44(%rbx)
	s->countdown = MAX_CALLS;
    9896:	48 89 43 50          	mov    %rax,0x50(%rbx)
    989a:	b8 01 00 00 00       	mov    $0x1,%eax

	return TC_CRYPTO_SUCCESS;
}
    989f:	5b                   	pop    %rbx
    98a0:	c3                   	retq   
    98a1:	31 c0                	xor    %eax,%eax
    98a3:	c3                   	retq   

00000000000098a4 <tc_cmac_setup>:
	if (s == (TCCmacState_t) 0 ||
    98a4:	48 85 ff             	test   %rdi,%rdi
    98a7:	74 78                	je     9921 <tc_cmac_setup+0x7d>
    98a9:	48 85 f6             	test   %rsi,%rsi
    98ac:	74 73                	je     9921 <tc_cmac_setup+0x7d>
{
    98ae:	41 54                	push   %r12
    98b0:	55                   	push   %rbp
    98b1:	49 89 f4             	mov    %rsi,%r12
    98b4:	53                   	push   %rbx
    98b5:	48 89 d5             	mov    %rdx,%rbp
    98b8:	48 89 fb             	mov    %rdi,%rbx
	_set(s, 0, sizeof(*s));
    98bb:	ba 58 00 00 00       	mov    $0x58,%edx
    98c0:	31 f6                	xor    %esi,%esi
    98c2:	e8 f8 fa ff ff       	callq  93bf <_set>
	s->sched = sched;
    98c7:	48 89 6b 48          	mov    %rbp,0x48(%rbx)
	tc_aes128_set_encrypt_key(s->sched, key);
    98cb:	4c 89 e6             	mov    %r12,%rsi
    98ce:	48 89 ef             	mov    %rbp,%rdi
    98d1:	e8 cd fc ff ff       	callq  95a3 <tc_aes128_set_encrypt_key>
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
    98d6:	48 89 df             	mov    %rbx,%rdi
    98d9:	ba 10 00 00 00       	mov    $0x10,%edx
    98de:	31 f6                	xor    %esi,%esi
    98e0:	e8 da fa ff ff       	callq  93bf <_set>
	tc_aes_encrypt(s->iv, s->iv, s->sched);
    98e5:	48 8b 53 48          	mov    0x48(%rbx),%rdx
	gf_double (s->K1, s->iv);
    98e9:	48 8d 6b 10          	lea    0x10(%rbx),%rbp
	tc_aes_encrypt(s->iv, s->iv, s->sched);
    98ed:	48 89 de             	mov    %rbx,%rsi
    98f0:	48 89 df             	mov    %rbx,%rdi
    98f3:	e8 aa fd ff ff       	callq  96a2 <tc_aes_encrypt>
	gf_double (s->K1, s->iv);
    98f8:	48 89 de             	mov    %rbx,%rsi
    98fb:	48 89 ef             	mov    %rbp,%rdi
    98fe:	e8 16 ff ff ff       	callq  9819 <gf_double>
	gf_double (s->K2, s->K1);
    9903:	48 8d 7b 20          	lea    0x20(%rbx),%rdi
    9907:	48 89 ee             	mov    %rbp,%rsi
    990a:	e8 0a ff ff ff       	callq  9819 <gf_double>
	tc_cmac_init(s);
    990f:	48 89 df             	mov    %rbx,%rdi
    9912:	e8 49 ff ff ff       	callq  9860 <tc_cmac_init>
}
    9917:	5b                   	pop    %rbx
	return TC_CRYPTO_SUCCESS;
    9918:	b8 01 00 00 00       	mov    $0x1,%eax
}
    991d:	5d                   	pop    %rbp
    991e:	41 5c                	pop    %r12
    9920:	c3                   	retq   
		return TC_CRYPTO_FAIL;
    9921:	31 c0                	xor    %eax,%eax
}
    9923:	c3                   	retq   

0000000000009924 <tc_cmac_update>:
{
	unsigned int i;

	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
		return TC_CRYPTO_FAIL;
    9924:	31 c0                	xor    %eax,%eax
	if (s == (TCCmacState_t) 0) {
    9926:	48 85 ff             	test   %rdi,%rdi
    9929:	0f 84 f9 00 00 00    	je     9a28 <tc_cmac_update+0x104>
{
    992f:	41 55                	push   %r13
    9931:	41 54                	push   %r12
    9933:	55                   	push   %rbp
    9934:	53                   	push   %rbx
    9935:	48 89 d5             	mov    %rdx,%rbp
    9938:	48 83 ec 08          	sub    $0x8,%rsp
	}
	if (data_length == 0) {
    993c:	48 85 d2             	test   %rdx,%rdx
    993f:	0f 84 d6 00 00 00    	je     9a1b <tc_cmac_update+0xf7>
		return TC_CRYPTO_FAIL;
    9945:	31 c0                	xor    %eax,%eax
		return  TC_CRYPTO_SUCCESS;
	}
	if (data == (const uint8_t *) 0) {
    9947:	48 85 f6             	test   %rsi,%rsi
    994a:	49 89 f4             	mov    %rsi,%r12
    994d:	0f 84 cd 00 00 00    	je     9a20 <tc_cmac_update+0xfc>
		return TC_CRYPTO_FAIL;
	}

	if (s->countdown == 0) {
    9953:	48 8b 57 50          	mov    0x50(%rdi),%rdx
    9957:	48 89 fb             	mov    %rdi,%rbx
    995a:	48 85 d2             	test   %rdx,%rdx
    995d:	0f 84 bd 00 00 00    	je     9a20 <tc_cmac_update+0xfc>
		return TC_CRYPTO_FAIL;
	}

	s->countdown--;

	if (s->leftover_offset > 0) {
    9963:	8b 47 44             	mov    0x44(%rdi),%eax
	s->countdown--;
    9966:	48 ff ca             	dec    %rdx
    9969:	48 89 57 50          	mov    %rdx,0x50(%rdi)
	if (s->leftover_offset > 0) {
    996d:	85 c0                	test   %eax,%eax
    996f:	74 60                	je     99d1 <tc_cmac_update+0xad>
		/* last data added to s didn't end on a TC_AES_BLOCK_SIZE byte boundary */
		size_t remaining_space = TC_AES_BLOCK_SIZE - s->leftover_offset;
    9971:	be 10 00 00 00       	mov    $0x10,%esi
    9976:	48 8d 7c 07 30       	lea    0x30(%rdi,%rax,1),%rdi
    997b:	29 c6                	sub    %eax,%esi
    997d:	41 89 f5             	mov    %esi,%r13d

		if (data_length < remaining_space) {
    9980:	4c 39 ed             	cmp    %r13,%rbp
    9983:	73 14                	jae    9999 <tc_cmac_update+0x75>
			/* still not enough data to encrypt this time either */
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
    9985:	89 e9                	mov    %ebp,%ecx
    9987:	4c 89 e2             	mov    %r12,%rdx
    998a:	89 ee                	mov    %ebp,%esi
    998c:	e8 1d fa ff ff       	callq  93ae <_copy>
			s->leftover_offset += data_length;
    9991:	01 6b 44             	add    %ebp,0x44(%rbx)
    9994:	e9 82 00 00 00       	jmpq   9a1b <tc_cmac_update+0xf7>
			return TC_CRYPTO_SUCCESS;
		}
		/* leftover block is now full; encrypt it first */
		_copy(&s->leftover[s->leftover_offset],
    9999:	4c 89 e2             	mov    %r12,%rdx
    999c:	89 f1                	mov    %esi,%ecx
		      remaining_space,
		      data,
		      remaining_space);
		data_length -= remaining_space;
    999e:	4c 29 ed             	sub    %r13,%rbp
		_copy(&s->leftover[s->leftover_offset],
    99a1:	e8 08 fa ff ff       	callq  93ae <_copy>
		data += remaining_space;
    99a6:	4d 01 ec             	add    %r13,%r12
		s->leftover_offset = 0;
    99a9:	c7 43 44 00 00 00 00 	movl   $0x0,0x44(%rbx)
    99b0:	31 c0                	xor    %eax,%eax

		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
			s->iv[i] ^= s->leftover[i];
    99b2:	8a 54 03 30          	mov    0x30(%rbx,%rax,1),%dl
    99b6:	30 14 03             	xor    %dl,(%rbx,%rax,1)
    99b9:	48 ff c0             	inc    %rax
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
    99bc:	48 83 f8 10          	cmp    $0x10,%rax
    99c0:	75 f0                	jne    99b2 <tc_cmac_update+0x8e>
		}
		tc_aes_encrypt(s->iv, s->iv, s->sched);
    99c2:	48 8b 53 48          	mov    0x48(%rbx),%rdx
    99c6:	48 89 de             	mov    %rbx,%rsi
    99c9:	48 89 df             	mov    %rbx,%rdi
    99cc:	e8 d1 fc ff ff       	callq  96a2 <tc_aes_encrypt>
    99d1:	49 01 ec             	add    %rbp,%r12
    99d4:	4c 89 e2             	mov    %r12,%rdx
    99d7:	48 29 ea             	sub    %rbp,%rdx
	}

	/* CBC encrypt each (except the last) of the data blocks */
	while (data_length > TC_AES_BLOCK_SIZE) {
    99da:	48 83 fd 10          	cmp    $0x10,%rbp
    99de:	76 26                	jbe    9a06 <tc_cmac_update+0xe2>
    99e0:	31 c0                	xor    %eax,%eax
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
			s->iv[i] ^= data[i];
    99e2:	8a 0c 02             	mov    (%rdx,%rax,1),%cl
    99e5:	30 0c 03             	xor    %cl,(%rbx,%rax,1)
    99e8:	48 ff c0             	inc    %rax
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
    99eb:	48 83 f8 10          	cmp    $0x10,%rax
    99ef:	75 f1                	jne    99e2 <tc_cmac_update+0xbe>
		}
		tc_aes_encrypt(s->iv, s->iv, s->sched);
    99f1:	48 8b 53 48          	mov    0x48(%rbx),%rdx
    99f5:	48 89 de             	mov    %rbx,%rsi
    99f8:	48 89 df             	mov    %rbx,%rdi
		data += TC_AES_BLOCK_SIZE;
		data_length  -= TC_AES_BLOCK_SIZE;
    99fb:	48 83 ed 10          	sub    $0x10,%rbp
		tc_aes_encrypt(s->iv, s->iv, s->sched);
    99ff:	e8 9e fc ff ff       	callq  96a2 <tc_aes_encrypt>
    9a04:	eb ce                	jmp    99d4 <tc_cmac_update+0xb0>
	}

	if (data_length > 0) {
    9a06:	48 85 ed             	test   %rbp,%rbp
    9a09:	74 10                	je     9a1b <tc_cmac_update+0xf7>
		/* save leftover data for next time */
		_copy(s->leftover, data_length, data, data_length);
    9a0b:	48 8d 7b 30          	lea    0x30(%rbx),%rdi
    9a0f:	89 e9                	mov    %ebp,%ecx
    9a11:	89 ee                	mov    %ebp,%esi
    9a13:	e8 96 f9 ff ff       	callq  93ae <_copy>
		s->leftover_offset = data_length;
    9a18:	89 6b 44             	mov    %ebp,0x44(%rbx)
	}

	return TC_CRYPTO_SUCCESS;
    9a1b:	b8 01 00 00 00       	mov    $0x1,%eax
}
    9a20:	5a                   	pop    %rdx
    9a21:	5b                   	pop    %rbx
    9a22:	5d                   	pop    %rbp
    9a23:	41 5c                	pop    %r12
    9a25:	41 5d                	pop    %r13
    9a27:	c3                   	retq   
    9a28:	c3                   	retq   

0000000000009a29 <tc_cmac_final>:
{
	uint8_t *k;
	unsigned int i;

	/* input sanity check: */
	if (tag == (uint8_t *) 0 ||
    9a29:	48 85 ff             	test   %rdi,%rdi
    9a2c:	74 74                	je     9aa2 <tc_cmac_final+0x79>
    9a2e:	48 85 f6             	test   %rsi,%rsi
    9a31:	74 6f                	je     9aa2 <tc_cmac_final+0x79>
{
    9a33:	55                   	push   %rbp
    9a34:	53                   	push   %rbx
    9a35:	48 89 fd             	mov    %rdi,%rbp
    9a38:	48 89 f3             	mov    %rsi,%rbx
		return TC_CRYPTO_FAIL;
	}

	if (s->leftover_offset == TC_AES_BLOCK_SIZE) {
		/* the last message block is a full-sized block */
		k = (uint8_t *) s->K1;
    9a3b:	48 8d 4e 10          	lea    0x10(%rsi),%rcx
{
    9a3f:	48 83 ec 08          	sub    $0x8,%rsp
	if (s->leftover_offset == TC_AES_BLOCK_SIZE) {
    9a43:	8b 46 44             	mov    0x44(%rsi),%eax
    9a46:	83 f8 10             	cmp    $0x10,%eax
    9a49:	74 1f                	je     9a6a <tc_cmac_final+0x41>
	} else {
		/* the final message block is not a full-sized  block */
		size_t remaining = TC_AES_BLOCK_SIZE - s->leftover_offset;

		_set(&s->leftover[s->leftover_offset], 0, remaining);
    9a4b:	48 8d 7c 06 30       	lea    0x30(%rsi,%rax,1),%rdi
		size_t remaining = TC_AES_BLOCK_SIZE - s->leftover_offset;
    9a50:	ba 10 00 00 00       	mov    $0x10,%edx
		_set(&s->leftover[s->leftover_offset], 0, remaining);
    9a55:	31 f6                	xor    %esi,%esi
		size_t remaining = TC_AES_BLOCK_SIZE - s->leftover_offset;
    9a57:	29 c2                	sub    %eax,%edx
		_set(&s->leftover[s->leftover_offset], 0, remaining);
    9a59:	e8 61 f9 ff ff       	callq  93bf <_set>
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
    9a5e:	8b 43 44             	mov    0x44(%rbx),%eax
		k = (uint8_t *) s->K2;
    9a61:	48 8d 4b 20          	lea    0x20(%rbx),%rcx
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
    9a65:	c6 44 03 30 80       	movb   $0x80,0x30(%rbx,%rax,1)
{
    9a6a:	31 c0                	xor    %eax,%eax
	}
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
		s->iv[i] ^= s->leftover[i] ^ k[i];
    9a6c:	8a 14 03             	mov    (%rbx,%rax,1),%dl
    9a6f:	32 54 03 30          	xor    0x30(%rbx,%rax,1),%dl
    9a73:	32 14 01             	xor    (%rcx,%rax,1),%dl
    9a76:	88 14 03             	mov    %dl,(%rbx,%rax,1)
    9a79:	48 ff c0             	inc    %rax
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
    9a7c:	48 83 f8 10          	cmp    $0x10,%rax
    9a80:	75 ea                	jne    9a6c <tc_cmac_final+0x43>
	}

	tc_aes_encrypt(tag, s->iv, s->sched);
    9a82:	48 8b 53 48          	mov    0x48(%rbx),%rdx
    9a86:	48 89 de             	mov    %rbx,%rsi
    9a89:	48 89 ef             	mov    %rbp,%rdi
    9a8c:	e8 11 fc ff ff       	callq  96a2 <tc_aes_encrypt>

	/* erasing state: */
	tc_cmac_erase(s);
    9a91:	48 89 df             	mov    %rbx,%rdi
    9a94:	e8 a8 fd ff ff       	callq  9841 <tc_cmac_erase>

	return TC_CRYPTO_SUCCESS;
}
    9a99:	5a                   	pop    %rdx
	return TC_CRYPTO_SUCCESS;
    9a9a:	b8 01 00 00 00       	mov    $0x1,%eax
}
    9a9f:	5b                   	pop    %rbx
    9aa0:	5d                   	pop    %rbp
    9aa1:	c3                   	retq   
		return TC_CRYPTO_FAIL;
    9aa2:	31 c0                	xor    %eax,%eax
}
    9aa4:	c3                   	retq   

0000000000009aa5 <compress>:
	n |= ((unsigned int)(*((*c)++)));
	return n;
}

static void compress(unsigned int *iv, const uint8_t *data)
{
    9aa5:	41 57                	push   %r15
    9aa7:	41 56                	push   %r14
    9aa9:	41 55                	push   %r13
    9aab:	41 54                	push   %r12
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];

	for (i = 0; i < 16; ++i) {
		n = BigEndian(&data);
		t1 = work_space[i] = n;
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    9aad:	4c 8d 2d ec 35 02 00 	lea    0x235ec(%rip),%r13        # 2d0a0 <k256>
{
    9ab4:	55                   	push   %rbp
    9ab5:	53                   	push   %rbx
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
    9ab6:	31 ed                	xor    %ebp,%ebp
{
    9ab8:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
    9abf:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    9ac6:	00 00 
    9ac8:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
    9acd:	31 c0                	xor    %eax,%eax
	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
    9acf:	8b 07                	mov    (%rdi),%eax
    9ad1:	89 44 24 10          	mov    %eax,0x10(%rsp)
    9ad5:	8b 47 04             	mov    0x4(%rdi),%eax
    9ad8:	8b 4c 24 10          	mov    0x10(%rsp),%ecx
    9adc:	89 44 24 14          	mov    %eax,0x14(%rsp)
    9ae0:	8b 47 08             	mov    0x8(%rdi),%eax
    9ae3:	44 8b 4c 24 14       	mov    0x14(%rsp),%r9d
    9ae8:	89 44 24 18          	mov    %eax,0x18(%rsp)
    9aec:	8b 47 0c             	mov    0xc(%rdi),%eax
    9aef:	8b 5c 24 18          	mov    0x18(%rsp),%ebx
    9af3:	89 44 24 1c          	mov    %eax,0x1c(%rsp)
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
    9af7:	8b 47 10             	mov    0x10(%rdi),%eax
	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
    9afa:	44 8b 64 24 1c       	mov    0x1c(%rsp),%r12d
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
    9aff:	89 44 24 20          	mov    %eax,0x20(%rsp)
    9b03:	8b 47 14             	mov    0x14(%rdi),%eax
    9b06:	8b 54 24 20          	mov    0x20(%rsp),%edx
    9b0a:	89 44 24 24          	mov    %eax,0x24(%rsp)
    9b0e:	8b 47 18             	mov    0x18(%rdi),%eax
    9b11:	44 8b 5c 24 24       	mov    0x24(%rsp),%r11d
    9b16:	89 44 24 28          	mov    %eax,0x28(%rsp)
    9b1a:	8b 47 1c             	mov    0x1c(%rdi),%eax
    9b1d:	89 44 24 2c          	mov    %eax,0x2c(%rsp)
    9b21:	41 89 c6             	mov    %eax,%r14d
    9b24:	8b 44 24 28          	mov    0x28(%rsp),%eax
    9b28:	89 44 24 0c          	mov    %eax,0xc(%rsp)
    9b2c:	44 8b 3c 2e          	mov    (%rsi,%rbp,1),%r15d
	return (((a) >> n) | ((a) << (32 - n)));
    9b30:	41 89 d0             	mov    %edx,%r8d
    9b33:	41 89 d2             	mov    %edx,%r10d
    9b36:	41 c1 c8 06          	ror    $0x6,%r8d
    9b3a:	41 c1 ca 0b          	ror    $0xb,%r10d
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    9b3e:	89 d0                	mov    %edx,%eax
    9b40:	45 31 c2             	xor    %r8d,%r10d
    9b43:	f7 d0                	not    %eax
	return (((a) >> n) | ((a) << (32 - n)));
    9b45:	41 89 d0             	mov    %edx,%r8d
    9b48:	41 0f cf             	bswap  %r15d
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    9b4b:	23 44 24 0c          	and    0xc(%rsp),%eax
	return (((a) >> n) | ((a) << (32 - n)));
    9b4f:	41 c1 c0 07          	rol    $0x7,%r8d
		t1 = work_space[i] = n;
    9b53:	44 89 7c 2c 38       	mov    %r15d,0x38(%rsp,%rbp,1)
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    9b58:	45 03 7c 2d 00       	add    0x0(%r13,%rbp,1),%r15d
    9b5d:	45 31 d0             	xor    %r10d,%r8d
    9b60:	41 89 d2             	mov    %edx,%r10d
    9b63:	48 83 c5 04          	add    $0x4,%rbp
    9b67:	45 21 da             	and    %r11d,%r10d
    9b6a:	44 31 d0             	xor    %r10d,%eax
    9b6d:	45 01 f8             	add    %r15d,%r8d
    9b70:	44 01 c0             	add    %r8d,%eax
	return (((a) >> n) | ((a) << (32 - n)));
    9b73:	41 89 c8             	mov    %ecx,%r8d
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    9b76:	46 8d 14 30          	lea    (%rax,%r14,1),%r10d
	return (((a) >> n) | ((a) << (32 - n)));
    9b7a:	89 c8                	mov    %ecx,%eax
    9b7c:	41 c1 c8 0d          	ror    $0xd,%r8d
    9b80:	c1 c8 02             	ror    $0x2,%eax
		t2 = Sigma0(a) + Maj(a, b, c);
    9b83:	45 89 ce             	mov    %r9d,%r14d
    9b86:	41 31 c0             	xor    %eax,%r8d
	return (((a) >> n) | ((a) << (32 - n)));
    9b89:	89 c8                	mov    %ecx,%eax
		t2 = Sigma0(a) + Maj(a, b, c);
    9b8b:	41 21 de             	and    %ebx,%r14d
	return (((a) >> n) | ((a) << (32 - n)));
    9b8e:	c1 c0 0a             	rol    $0xa,%eax
		t2 = Sigma0(a) + Maj(a, b, c);
    9b91:	41 31 c0             	xor    %eax,%r8d
    9b94:	44 89 c8             	mov    %r9d,%eax
    9b97:	31 d8                	xor    %ebx,%eax
    9b99:	21 c8                	and    %ecx,%eax
    9b9b:	44 31 f0             	xor    %r14d,%eax
    9b9e:	44 8b 74 24 0c       	mov    0xc(%rsp),%r14d
    9ba3:	44 01 c0             	add    %r8d,%eax
		h = g; g = f; f = e; e = d + t1;
    9ba6:	47 8d 04 22          	lea    (%r10,%r12,1),%r8d
    9baa:	41 89 dc             	mov    %ebx,%r12d
		d = c; c = b; b = a; a = t1 + t2;
    9bad:	44 01 d0             	add    %r10d,%eax
	for (i = 0; i < 16; ++i) {
    9bb0:	48 83 fd 40          	cmp    $0x40,%rbp
    9bb4:	74 18                	je     9bce <compress+0x129>
    9bb6:	44 89 5c 24 0c       	mov    %r11d,0xc(%rsp)
    9bbb:	44 89 cb             	mov    %r9d,%ebx
    9bbe:	41 89 d3             	mov    %edx,%r11d
    9bc1:	41 89 c9             	mov    %ecx,%r9d
		h = g; g = f; f = e; e = d + t1;
    9bc4:	44 89 c2             	mov    %r8d,%edx
		d = c; c = b; b = a; a = t1 + t2;
    9bc7:	89 c1                	mov    %eax,%ecx
    9bc9:	e9 5e ff ff ff       	jmpq   9b2c <compress+0x87>
    9bce:	be 10 00 00 00       	mov    $0x10,%esi
	}

	for ( ; i < 64; ++i) {
		s0 = work_space[(i+1)&0x0f];
    9bd3:	44 8d 56 01          	lea    0x1(%rsi),%r10d
		s0 = sigma0(s0);
		s1 = work_space[(i+14)&0x0f];
		s1 = sigma1(s1);

		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
    9bd7:	49 89 f7             	mov    %rsi,%r15
    9bda:	41 83 e7 0f          	and    $0xf,%r15d
		s0 = work_space[(i+1)&0x0f];
    9bde:	41 83 e2 0f          	and    $0xf,%r10d
    9be2:	46 8b 74 94 38       	mov    0x38(%rsp,%r10,4),%r14d
	return (((a) >> n) | ((a) << (32 - n)));
    9be7:	45 89 f5             	mov    %r14d,%r13d
    9bea:	45 89 f2             	mov    %r14d,%r10d
		s0 = sigma0(s0);
    9bed:	41 c1 ee 03          	shr    $0x3,%r14d
	return (((a) >> n) | ((a) << (32 - n)));
    9bf1:	41 c1 c2 0e          	rol    $0xe,%r10d
    9bf5:	41 c1 cd 07          	ror    $0x7,%r13d
		s0 = sigma0(s0);
    9bf9:	45 31 d5             	xor    %r10d,%r13d
		s1 = work_space[(i+14)&0x0f];
    9bfc:	44 8d 56 0e          	lea    0xe(%rsi),%r10d
		s0 = sigma0(s0);
    9c00:	45 31 f5             	xor    %r14d,%r13d
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    9c03:	4c 8d 35 96 34 02 00 	lea    0x23496(%rip),%r14        # 2d0a0 <k256>
		s1 = work_space[(i+14)&0x0f];
    9c0a:	41 83 e2 0f          	and    $0xf,%r10d
    9c0e:	46 8b 64 94 38       	mov    0x38(%rsp,%r10,4),%r12d
	return (((a) >> n) | ((a) << (32 - n)));
    9c13:	44 89 e5             	mov    %r12d,%ebp
    9c16:	45 89 e2             	mov    %r12d,%r10d
		s1 = sigma1(s1);
    9c19:	41 c1 ec 0a          	shr    $0xa,%r12d
	return (((a) >> n) | ((a) << (32 - n)));
    9c1d:	41 c1 c2 0d          	rol    $0xd,%r10d
    9c21:	c1 c5 0f             	rol    $0xf,%ebp
		s1 = sigma1(s1);
    9c24:	44 31 d5             	xor    %r10d,%ebp
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
    9c27:	44 8d 56 09          	lea    0x9(%rsi),%r10d
		s1 = sigma1(s1);
    9c2b:	44 31 e5             	xor    %r12d,%ebp
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    9c2e:	45 89 c4             	mov    %r8d,%r12d
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
    9c31:	41 83 e2 0f          	and    $0xf,%r10d
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    9c35:	41 21 d4             	and    %edx,%r12d
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
    9c38:	46 8b 54 94 38       	mov    0x38(%rsp,%r10,4),%r10d
    9c3d:	46 03 54 bc 38       	add    0x38(%rsp,%r15,4),%r10d
    9c42:	45 01 d5             	add    %r10d,%r13d
	return (((a) >> n) | ((a) << (32 - n)));
    9c45:	45 89 c2             	mov    %r8d,%r10d
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
    9c48:	44 01 ed             	add    %r13d,%ebp
	return (((a) >> n) | ((a) << (32 - n)));
    9c4b:	41 c1 ca 06          	ror    $0x6,%r10d
		t2 = Sigma0(a) + Maj(a, b, c);
    9c4f:	41 89 cd             	mov    %ecx,%r13d
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
    9c52:	42 89 6c bc 38       	mov    %ebp,0x38(%rsp,%r15,4)
	return (((a) >> n) | ((a) << (32 - n)));
    9c57:	45 89 c7             	mov    %r8d,%r15d
    9c5a:	41 c1 cf 0b          	ror    $0xb,%r15d
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    9c5e:	45 31 d7             	xor    %r10d,%r15d
	return (((a) >> n) | ((a) << (32 - n)));
    9c61:	45 89 c2             	mov    %r8d,%r10d
    9c64:	41 c1 c2 07          	rol    $0x7,%r10d
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    9c68:	45 31 d7             	xor    %r10d,%r15d
    9c6b:	45 89 c2             	mov    %r8d,%r10d
    9c6e:	41 f7 d2             	not    %r10d
    9c71:	45 21 da             	and    %r11d,%r10d
    9c74:	45 31 e2             	xor    %r12d,%r10d
	return (((a) >> n) | ((a) << (32 - n)));
    9c77:	41 89 c4             	mov    %eax,%r12d
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    9c7a:	45 01 fa             	add    %r15d,%r10d
    9c7d:	45 03 14 b6          	add    (%r14,%rsi,4),%r10d
	return (((a) >> n) | ((a) << (32 - n)));
    9c81:	41 c1 cc 0d          	ror    $0xd,%r12d
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    9c85:	44 01 d5             	add    %r10d,%ebp
	return (((a) >> n) | ((a) << (32 - n)));
    9c88:	41 89 c2             	mov    %eax,%r10d
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    9c8b:	03 6c 24 0c          	add    0xc(%rsp),%ebp
	return (((a) >> n) | ((a) << (32 - n)));
    9c8f:	41 c1 ca 02          	ror    $0x2,%r10d
    9c93:	44 89 5c 24 0c       	mov    %r11d,0xc(%rsp)
		t2 = Sigma0(a) + Maj(a, b, c);
    9c98:	45 31 d4             	xor    %r10d,%r12d
	return (((a) >> n) | ((a) << (32 - n)));
    9c9b:	41 89 c2             	mov    %eax,%r10d
    9c9e:	41 c1 c2 0a          	rol    $0xa,%r10d
		t2 = Sigma0(a) + Maj(a, b, c);
    9ca2:	45 21 cd             	and    %r9d,%r13d
    9ca5:	48 ff c6             	inc    %rsi
    9ca8:	45 31 d4             	xor    %r10d,%r12d
    9cab:	41 89 ca             	mov    %ecx,%r10d
		h = g; g = f; f = e; e = d + t1;
    9cae:	44 8d 74 1d 00       	lea    0x0(%rbp,%rbx,1),%r14d
		t2 = Sigma0(a) + Maj(a, b, c);
    9cb3:	45 31 ca             	xor    %r9d,%r10d
    9cb6:	44 89 cb             	mov    %r9d,%ebx
    9cb9:	41 21 c2             	and    %eax,%r10d
    9cbc:	45 31 ea             	xor    %r13d,%r10d
    9cbf:	45 01 d4             	add    %r10d,%r12d
		d = c; c = b; b = a; a = t1 + t2;
    9cc2:	44 01 e5             	add    %r12d,%ebp
	for ( ; i < 64; ++i) {
    9cc5:	48 83 fe 40          	cmp    $0x40,%rsi
    9cc9:	74 15                	je     9ce0 <compress+0x23b>
    9ccb:	41 89 d3             	mov    %edx,%r11d
    9cce:	41 89 c9             	mov    %ecx,%r9d
    9cd1:	44 89 c2             	mov    %r8d,%edx
    9cd4:	89 c1                	mov    %eax,%ecx
		h = g; g = f; f = e; e = d + t1;
    9cd6:	45 89 f0             	mov    %r14d,%r8d
		d = c; c = b; b = a; a = t1 + t2;
    9cd9:	89 e8                	mov    %ebp,%eax
    9cdb:	e9 f3 fe ff ff       	jmpq   9bd3 <compress+0x12e>
	}

	iv[0] += a; iv[1] += b; iv[2] += c; iv[3] += d;
    9ce0:	03 44 24 14          	add    0x14(%rsp),%eax
    9ce4:	03 6c 24 10          	add    0x10(%rsp),%ebp
    9ce8:	03 4c 24 18          	add    0x18(%rsp),%ecx
    9cec:	44 03 4c 24 1c       	add    0x1c(%rsp),%r9d
	iv[4] += e; iv[5] += f; iv[6] += g; iv[7] += h;
    9cf1:	44 03 74 24 20       	add    0x20(%rsp),%r14d
    9cf6:	44 03 44 24 24       	add    0x24(%rsp),%r8d
    9cfb:	03 54 24 28          	add    0x28(%rsp),%edx
    9cff:	44 03 5c 24 2c       	add    0x2c(%rsp),%r11d
	iv[0] += a; iv[1] += b; iv[2] += c; iv[3] += d;
    9d04:	89 47 04             	mov    %eax,0x4(%rdi)
    9d07:	89 2f                	mov    %ebp,(%rdi)
}
    9d09:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
    9d0e:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    9d15:	00 00 
	iv[0] += a; iv[1] += b; iv[2] += c; iv[3] += d;
    9d17:	89 4f 08             	mov    %ecx,0x8(%rdi)
    9d1a:	44 89 4f 0c          	mov    %r9d,0xc(%rdi)
	iv[4] += e; iv[5] += f; iv[6] += g; iv[7] += h;
    9d1e:	44 89 77 10          	mov    %r14d,0x10(%rdi)
    9d22:	44 89 47 14          	mov    %r8d,0x14(%rdi)
    9d26:	89 57 18             	mov    %edx,0x18(%rdi)
    9d29:	44 89 5f 1c          	mov    %r11d,0x1c(%rdi)
}
    9d2d:	74 05                	je     9d34 <compress+0x28f>
    9d2f:	e8 0c a9 ff ff       	callq  4640 <__stack_chk_fail@plt>
    9d34:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
    9d3b:	5b                   	pop    %rbx
    9d3c:	5d                   	pop    %rbp
    9d3d:	41 5c                	pop    %r12
    9d3f:	41 5d                	pop    %r13
    9d41:	41 5e                	pop    %r14
    9d43:	41 5f                	pop    %r15
    9d45:	c3                   	retq   

0000000000009d46 <tc_sha256_init>:
	if (s == (TCSha256State_t) 0) {
    9d46:	48 85 ff             	test   %rdi,%rdi
    9d49:	74 4e                	je     9d99 <tc_sha256_init+0x53>
{
    9d4b:	53                   	push   %rbx
	_set((uint8_t *) s, 0x00, sizeof(*s));
    9d4c:	ba 70 00 00 00       	mov    $0x70,%edx
    9d51:	31 f6                	xor    %esi,%esi
    9d53:	48 89 fb             	mov    %rdi,%rbx
    9d56:	e8 64 f6 ff ff       	callq  93bf <_set>
	s->iv[0] = 0x6a09e667;
    9d5b:	48 b8 67 e6 09 6a 85 	movabs $0xbb67ae856a09e667,%rax
    9d62:	ae 67 bb 
    9d65:	48 89 03             	mov    %rax,(%rbx)
	s->iv[1] = 0xbb67ae85;
    9d68:	48 b8 72 f3 6e 3c 3a 	movabs $0xa54ff53a3c6ef372,%rax
    9d6f:	f5 4f a5 
    9d72:	48 89 43 08          	mov    %rax,0x8(%rbx)
	s->iv[3] = 0xa54ff53a;
    9d76:	48 b8 7f 52 0e 51 8c 	movabs $0x9b05688c510e527f,%rax
    9d7d:	68 05 9b 
    9d80:	48 89 43 10          	mov    %rax,0x10(%rbx)
	s->iv[5] = 0x9b05688c;
    9d84:	48 b8 ab d9 83 1f 19 	movabs $0x5be0cd191f83d9ab,%rax
    9d8b:	cd e0 5b 
    9d8e:	48 89 43 18          	mov    %rax,0x18(%rbx)
	return TC_CRYPTO_SUCCESS;
    9d92:	b8 01 00 00 00       	mov    $0x1,%eax
}
    9d97:	5b                   	pop    %rbx
    9d98:	c3                   	retq   
    9d99:	31 c0                	xor    %eax,%eax
    9d9b:	c3                   	retq   

0000000000009d9c <tc_sha256_update>:
	if (s == (TCSha256State_t) 0 ||
    9d9c:	48 85 ff             	test   %rdi,%rdi
    9d9f:	74 71                	je     9e12 <tc_sha256_update+0x76>
{
    9da1:	41 55                	push   %r13
    9da3:	41 54                	push   %r12
		return TC_CRYPTO_FAIL;
    9da5:	31 c0                	xor    %eax,%eax
{
    9da7:	55                   	push   %rbp
    9da8:	53                   	push   %rbx
    9da9:	48 89 f5             	mov    %rsi,%rbp
    9dac:	48 83 ec 08          	sub    $0x8,%rsp
	if (s == (TCSha256State_t) 0 ||
    9db0:	48 85 f6             	test   %rsi,%rsi
    9db3:	74 55                	je     9e0a <tc_sha256_update+0x6e>
	} else if (datalen == 0) {
    9db5:	48 85 d2             	test   %rdx,%rdx
    9db8:	48 89 fb             	mov    %rdi,%rbx
    9dbb:	4c 8d 24 16          	lea    (%rsi,%rdx,1),%r12
			compress(s->iv, s->leftover);
    9dbf:	4c 8d 6f 28          	lea    0x28(%rdi),%r13
	} else if (datalen == 0) {
    9dc3:	75 3e                	jne    9e03 <tc_sha256_update+0x67>
		return TC_CRYPTO_SUCCESS;
    9dc5:	b8 01 00 00 00       	mov    $0x1,%eax
    9dca:	eb 3e                	jmp    9e0a <tc_sha256_update+0x6e>
		s->leftover[s->leftover_offset++] = *(data++);
    9dcc:	48 8b 53 68          	mov    0x68(%rbx),%rdx
    9dd0:	48 ff c5             	inc    %rbp
    9dd3:	48 8d 42 01          	lea    0x1(%rdx),%rax
    9dd7:	48 89 43 68          	mov    %rax,0x68(%rbx)
    9ddb:	8a 4d ff             	mov    -0x1(%rbp),%cl
		if (s->leftover_offset >= TC_SHA256_BLOCK_SIZE) {
    9dde:	48 83 f8 3f          	cmp    $0x3f,%rax
		s->leftover[s->leftover_offset++] = *(data++);
    9de2:	88 4c 13 28          	mov    %cl,0x28(%rbx,%rdx,1)
		if (s->leftover_offset >= TC_SHA256_BLOCK_SIZE) {
    9de6:	76 1b                	jbe    9e03 <tc_sha256_update+0x67>
			compress(s->iv, s->leftover);
    9de8:	4c 89 ee             	mov    %r13,%rsi
    9deb:	48 89 df             	mov    %rbx,%rdi
    9dee:	e8 b2 fc ff ff       	callq  9aa5 <compress>
			s->bits_hashed += (TC_SHA256_BLOCK_SIZE << 3);
    9df3:	48 81 43 20 00 02 00 	addq   $0x200,0x20(%rbx)
    9dfa:	00 
			s->leftover_offset = 0;
    9dfb:	48 c7 43 68 00 00 00 	movq   $0x0,0x68(%rbx)
    9e02:	00 
	while (datalen-- > 0) {
    9e03:	49 39 ec             	cmp    %rbp,%r12
    9e06:	75 c4                	jne    9dcc <tc_sha256_update+0x30>
    9e08:	eb bb                	jmp    9dc5 <tc_sha256_update+0x29>
}
    9e0a:	5a                   	pop    %rdx
    9e0b:	5b                   	pop    %rbx
    9e0c:	5d                   	pop    %rbp
    9e0d:	41 5c                	pop    %r12
    9e0f:	41 5d                	pop    %r13
    9e11:	c3                   	retq   
		return TC_CRYPTO_FAIL;
    9e12:	31 c0                	xor    %eax,%eax
}
    9e14:	c3                   	retq   

0000000000009e15 <tc_sha256_final>:
	if (digest == (uint8_t *) 0 ||
    9e15:	48 85 ff             	test   %rdi,%rdi
    9e18:	0f 84 0a 01 00 00    	je     9f28 <tc_sha256_final+0x113>
    9e1e:	48 85 f6             	test   %rsi,%rsi
    9e21:	0f 84 01 01 00 00    	je     9f28 <tc_sha256_final+0x113>
{
    9e27:	41 54                	push   %r12
    9e29:	55                   	push   %rbp
    9e2a:	48 89 fd             	mov    %rdi,%rbp
    9e2d:	53                   	push   %rbx
	s->bits_hashed += (s->leftover_offset << 3);
    9e2e:	48 8b 46 68          	mov    0x68(%rsi),%rax
    9e32:	48 89 f3             	mov    %rsi,%rbx
    9e35:	4c 8d 66 28          	lea    0x28(%rsi),%r12
	s->leftover[s->leftover_offset++] = 0x80; /* always room for one byte */
    9e39:	48 8d 78 01          	lea    0x1(%rax),%rdi
	s->bits_hashed += (s->leftover_offset << 3);
    9e3d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    9e44:	00 
    9e45:	48 01 56 20          	add    %rdx,0x20(%rsi)
	if (s->leftover_offset > (sizeof(s->leftover) - 8)) {
    9e49:	48 83 ff 38          	cmp    $0x38,%rdi
	s->leftover[s->leftover_offset++] = 0x80; /* always room for one byte */
    9e4d:	48 89 7e 68          	mov    %rdi,0x68(%rsi)
    9e51:	c6 44 06 28 80       	movb   $0x80,0x28(%rsi,%rax,1)
	if (s->leftover_offset > (sizeof(s->leftover) - 8)) {
    9e56:	76 24                	jbe    9e7c <tc_sha256_final+0x67>
		_set(s->leftover + s->leftover_offset, 0x00,
    9e58:	ba 40 00 00 00       	mov    $0x40,%edx
    9e5d:	31 f6                	xor    %esi,%esi
    9e5f:	29 fa                	sub    %edi,%edx
    9e61:	4c 01 e7             	add    %r12,%rdi
    9e64:	e8 56 f5 ff ff       	callq  93bf <_set>
		compress(s->iv, s->leftover);
    9e69:	4c 89 e6             	mov    %r12,%rsi
    9e6c:	48 89 df             	mov    %rbx,%rdi
    9e6f:	e8 31 fc ff ff       	callq  9aa5 <compress>
		s->leftover_offset = 0;
    9e74:	48 c7 43 68 00 00 00 	movq   $0x0,0x68(%rbx)
    9e7b:	00 
	     sizeof(s->leftover) - 8 - s->leftover_offset);
    9e7c:	48 8b 7b 68          	mov    0x68(%rbx),%rdi
	_set(s->leftover + s->leftover_offset, 0x00,
    9e80:	ba 38 00 00 00       	mov    $0x38,%edx
    9e85:	31 f6                	xor    %esi,%esi
    9e87:	29 fa                	sub    %edi,%edx
    9e89:	4c 01 e7             	add    %r12,%rdi
    9e8c:	e8 2e f5 ff ff       	callq  93bf <_set>
	s->leftover[sizeof(s->leftover) - 1] = (uint8_t)(s->bits_hashed);
    9e91:	48 8b 43 20          	mov    0x20(%rbx),%rax
	compress(s->iv, s->leftover);
    9e95:	4c 89 e6             	mov    %r12,%rsi
    9e98:	48 89 df             	mov    %rbx,%rdi
	s->leftover[sizeof(s->leftover) - 2] = (uint8_t)(s->bits_hashed >> 8);
    9e9b:	48 89 c2             	mov    %rax,%rdx
	s->leftover[sizeof(s->leftover) - 1] = (uint8_t)(s->bits_hashed);
    9e9e:	88 43 67             	mov    %al,0x67(%rbx)
	s->leftover[sizeof(s->leftover) - 2] = (uint8_t)(s->bits_hashed >> 8);
    9ea1:	48 c1 ea 08          	shr    $0x8,%rdx
    9ea5:	88 53 66             	mov    %dl,0x66(%rbx)
	s->leftover[sizeof(s->leftover) - 3] = (uint8_t)(s->bits_hashed >> 16);
    9ea8:	48 89 c2             	mov    %rax,%rdx
    9eab:	48 c1 ea 10          	shr    $0x10,%rdx
    9eaf:	88 53 65             	mov    %dl,0x65(%rbx)
	s->leftover[sizeof(s->leftover) - 4] = (uint8_t)(s->bits_hashed >> 24);
    9eb2:	48 89 c2             	mov    %rax,%rdx
    9eb5:	48 c1 ea 18          	shr    $0x18,%rdx
    9eb9:	88 53 64             	mov    %dl,0x64(%rbx)
	s->leftover[sizeof(s->leftover) - 5] = (uint8_t)(s->bits_hashed >> 32);
    9ebc:	48 89 c2             	mov    %rax,%rdx
    9ebf:	48 c1 ea 20          	shr    $0x20,%rdx
    9ec3:	88 53 63             	mov    %dl,0x63(%rbx)
	s->leftover[sizeof(s->leftover) - 6] = (uint8_t)(s->bits_hashed >> 40);
    9ec6:	48 89 c2             	mov    %rax,%rdx
    9ec9:	48 c1 ea 28          	shr    $0x28,%rdx
    9ecd:	88 53 62             	mov    %dl,0x62(%rbx)
	s->leftover[sizeof(s->leftover) - 7] = (uint8_t)(s->bits_hashed >> 48);
    9ed0:	48 89 c2             	mov    %rax,%rdx
	s->leftover[sizeof(s->leftover) - 8] = (uint8_t)(s->bits_hashed >> 56);
    9ed3:	48 c1 e8 38          	shr    $0x38,%rax
	s->leftover[sizeof(s->leftover) - 7] = (uint8_t)(s->bits_hashed >> 48);
    9ed7:	48 c1 ea 30          	shr    $0x30,%rdx
	s->leftover[sizeof(s->leftover) - 8] = (uint8_t)(s->bits_hashed >> 56);
    9edb:	88 43 60             	mov    %al,0x60(%rbx)
	s->leftover[sizeof(s->leftover) - 7] = (uint8_t)(s->bits_hashed >> 48);
    9ede:	88 53 61             	mov    %dl,0x61(%rbx)
	compress(s->iv, s->leftover);
    9ee1:	e8 bf fb ff ff       	callq  9aa5 <compress>
    9ee6:	31 c0                	xor    %eax,%eax
		unsigned int t = *((unsigned int *) &s->iv[i]);
    9ee8:	8b 14 03             	mov    (%rbx,%rax,1),%edx
		*digest++ = (uint8_t)(t >> 24);
    9eeb:	89 d1                	mov    %edx,%ecx
		*digest++ = (uint8_t)(t >> 8);
    9eed:	88 74 05 02          	mov    %dh,0x2(%rbp,%rax,1)
		*digest++ = (uint8_t)(t);
    9ef1:	88 54 05 03          	mov    %dl,0x3(%rbp,%rax,1)
		*digest++ = (uint8_t)(t >> 24);
    9ef5:	c1 e9 18             	shr    $0x18,%ecx
    9ef8:	88 4c 05 00          	mov    %cl,0x0(%rbp,%rax,1)
		*digest++ = (uint8_t)(t >> 16);
    9efc:	89 d1                	mov    %edx,%ecx
    9efe:	c1 e9 10             	shr    $0x10,%ecx
    9f01:	88 4c 05 01          	mov    %cl,0x1(%rbp,%rax,1)
    9f05:	48 83 c0 04          	add    $0x4,%rax
	for (i = 0; i < TC_SHA256_STATE_BLOCKS; ++i) {
    9f09:	48 83 f8 20          	cmp    $0x20,%rax
    9f0d:	75 d9                	jne    9ee8 <tc_sha256_final+0xd3>
	_set(s, 0, sizeof(*s));
    9f0f:	48 89 df             	mov    %rbx,%rdi
    9f12:	ba 70 00 00 00       	mov    $0x70,%edx
    9f17:	31 f6                	xor    %esi,%esi
    9f19:	e8 a1 f4 ff ff       	callq  93bf <_set>
}
    9f1e:	5b                   	pop    %rbx
	return TC_CRYPTO_SUCCESS;
    9f1f:	b8 01 00 00 00       	mov    $0x1,%eax
}
    9f24:	5d                   	pop    %rbp
    9f25:	41 5c                	pop    %r12
    9f27:	c3                   	retq   
		return TC_CRYPTO_FAIL;
    9f28:	31 c0                	xor    %eax,%eax
}
    9f2a:	c3                   	retq   

0000000000009f2b <rekey>:
{
	const uint8_t inner_pad = (uint8_t) 0x36;
	const uint8_t outer_pad = (uint8_t) 0x5c;
	unsigned int i;

	for (i = 0; i < key_size; ++i) {
    9f2b:	31 c0                	xor    %eax,%eax
    9f2d:	39 c2                	cmp    %eax,%edx
    9f2f:	76 1c                	jbe    9f4d <rekey+0x22>
		key[i] = inner_pad ^ new_key[i];
    9f31:	8a 0c 06             	mov    (%rsi,%rax,1),%cl
		key[i + TC_SHA256_BLOCK_SIZE] = outer_pad ^ new_key[i];
    9f34:	44 8d 40 40          	lea    0x40(%rax),%r8d
		key[i] = inner_pad ^ new_key[i];
    9f38:	83 f1 36             	xor    $0x36,%ecx
    9f3b:	88 0c 07             	mov    %cl,(%rdi,%rax,1)
		key[i + TC_SHA256_BLOCK_SIZE] = outer_pad ^ new_key[i];
    9f3e:	8a 0c 06             	mov    (%rsi,%rax,1),%cl
    9f41:	48 ff c0             	inc    %rax
    9f44:	83 f1 5c             	xor    $0x5c,%ecx
    9f47:	42 88 0c 07          	mov    %cl,(%rdi,%r8,1)
    9f4b:	eb e0                	jmp    9f2d <rekey+0x2>
	}
	for (; i < TC_SHA256_BLOCK_SIZE; ++i) {
		key[i] = inner_pad; key[i + TC_SHA256_BLOCK_SIZE] = outer_pad;
    9f4d:	8d 72 40             	lea    0x40(%rdx),%esi
    9f50:	89 d1                	mov    %edx,%ecx
    9f52:	31 c0                	xor    %eax,%eax
    9f54:	48 01 f9             	add    %rdi,%rcx
    9f57:	48 01 f7             	add    %rsi,%rdi
	for (; i < TC_SHA256_BLOCK_SIZE; ++i) {
    9f5a:	8d 34 02             	lea    (%rdx,%rax,1),%esi
    9f5d:	83 fe 3f             	cmp    $0x3f,%esi
    9f60:	77 0d                	ja     9f6f <rekey+0x44>
		key[i] = inner_pad; key[i + TC_SHA256_BLOCK_SIZE] = outer_pad;
    9f62:	c6 04 01 36          	movb   $0x36,(%rcx,%rax,1)
    9f66:	c6 04 07 5c          	movb   $0x5c,(%rdi,%rax,1)
    9f6a:	48 ff c0             	inc    %rax
    9f6d:	eb eb                	jmp    9f5a <rekey+0x2f>
	}
}
    9f6f:	c3                   	retq   

0000000000009f70 <tc_hmac_set_key>:

int tc_hmac_set_key(TCHmacState_t ctx, const uint8_t *key,
		    unsigned int key_size)
{
    9f70:	41 56                	push   %r14
    9f72:	41 55                	push   %r13
    9f74:	41 54                	push   %r12
    9f76:	55                   	push   %rbp
    9f77:	89 d5                	mov    %edx,%ebp
    9f79:	53                   	push   %rbx
    9f7a:	48 81 ec 40 01 00 00 	sub    $0x140,%rsp
    9f81:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    9f88:	00 00 
    9f8a:	48 89 84 24 38 01 00 	mov    %rax,0x138(%rsp)
    9f91:	00 
    9f92:	31 c0                	xor    %eax,%eax
	/* Input sanity check */
	if (ctx == (TCHmacState_t) 0 ||
	    key == (const uint8_t *) 0 ||
    9f94:	48 85 f6             	test   %rsi,%rsi
    9f97:	0f 94 c2             	sete   %dl
    9f9a:	85 ed                	test   %ebp,%ebp
    9f9c:	0f 94 c0             	sete   %al
    9f9f:	08 c2                	or     %al,%dl
    9fa1:	0f 85 8d 00 00 00    	jne    a034 <tc_hmac_set_key+0xc4>
    9fa7:	48 85 ff             	test   %rdi,%rdi
    9faa:	48 89 fb             	mov    %rdi,%rbx
    9fad:	0f 84 81 00 00 00    	je     a034 <tc_hmac_set_key+0xc4>
	}

	const uint8_t dummy_key[TC_SHA256_BLOCK_SIZE];
	struct tc_hmac_state_struct dummy_state;

	if (key_size <= TC_SHA256_BLOCK_SIZE) {
    9fb3:	83 fd 40             	cmp    $0x40,%ebp
    9fb6:	49 89 f4             	mov    %rsi,%r12
    9fb9:	41 89 ee             	mov    %ebp,%r14d
    9fbc:	4c 8d 6f 70          	lea    0x70(%rdi),%r13
    9fc0:	77 36                	ja     9ff8 <tc_hmac_set_key+0x88>
		 * certain timing attacks. Without these dummy calls,
		 * adversaries would be able to learn whether the key_size is
		 * greater than TC_SHA256_BLOCK_SIZE by measuring the time
		 * consumed in this process.
		 */
		(void)tc_sha256_init(&dummy_state.hash_state);
    9fc2:	48 8d 5c 24 08       	lea    0x8(%rsp),%rbx
    9fc7:	48 89 df             	mov    %rbx,%rdi
    9fca:	e8 77 fd ff ff       	callq  9d46 <tc_sha256_init>
		(void)tc_sha256_update(&dummy_state.hash_state,
    9fcf:	48 8d b4 24 f8 00 00 	lea    0xf8(%rsp),%rsi
    9fd6:	00 
    9fd7:	4c 89 f2             	mov    %r14,%rdx
    9fda:	48 89 df             	mov    %rbx,%rdi
    9fdd:	e8 ba fd ff ff       	callq  9d9c <tc_sha256_update>
				       dummy_key,
				       key_size);
		(void)tc_sha256_final(&dummy_state.key[TC_SHA256_DIGEST_SIZE],
    9fe2:	48 8d bb 90 00 00 00 	lea    0x90(%rbx),%rdi
    9fe9:	48 89 de             	mov    %rbx,%rsi
    9fec:	e8 24 fe ff ff       	callq  9e15 <tc_sha256_final>
				      &dummy_state.hash_state);

		/* Actual code for when key_size <= TC_SHA256_BLOCK_SIZE: */
		rekey(ctx->key, key, key_size);
    9ff1:	89 ea                	mov    %ebp,%edx
    9ff3:	4c 89 e6             	mov    %r12,%rsi
    9ff6:	eb 2d                	jmp    a025 <tc_hmac_set_key+0xb5>
	} else {
		(void)tc_sha256_init(&ctx->hash_state);
		(void)tc_sha256_update(&ctx->hash_state, key, key_size);
		(void)tc_sha256_final(&ctx->key[TC_SHA256_DIGEST_SIZE],
    9ff8:	48 8d ab 90 00 00 00 	lea    0x90(%rbx),%rbp
		(void)tc_sha256_init(&ctx->hash_state);
    9fff:	e8 42 fd ff ff       	callq  9d46 <tc_sha256_init>
		(void)tc_sha256_update(&ctx->hash_state, key, key_size);
    a004:	4c 89 f2             	mov    %r14,%rdx
    a007:	4c 89 e6             	mov    %r12,%rsi
    a00a:	48 89 df             	mov    %rbx,%rdi
    a00d:	e8 8a fd ff ff       	callq  9d9c <tc_sha256_update>
		(void)tc_sha256_final(&ctx->key[TC_SHA256_DIGEST_SIZE],
    a012:	48 89 de             	mov    %rbx,%rsi
    a015:	48 89 ef             	mov    %rbp,%rdi
    a018:	e8 f8 fd ff ff       	callq  9e15 <tc_sha256_final>
				      &ctx->hash_state);
		rekey(ctx->key,
    a01d:	ba 20 00 00 00       	mov    $0x20,%edx
    a022:	48 89 ee             	mov    %rbp,%rsi
    a025:	4c 89 ef             	mov    %r13,%rdi
    a028:	e8 fe fe ff ff       	callq  9f2b <rekey>
		      &ctx->key[TC_SHA256_DIGEST_SIZE],
		      TC_SHA256_DIGEST_SIZE);
	}

	return TC_CRYPTO_SUCCESS;
    a02d:	b8 01 00 00 00       	mov    $0x1,%eax
    a032:	eb 02                	jmp    a036 <tc_hmac_set_key+0xc6>
		return TC_CRYPTO_FAIL;
    a034:	31 c0                	xor    %eax,%eax
}
    a036:	48 8b 8c 24 38 01 00 	mov    0x138(%rsp),%rcx
    a03d:	00 
    a03e:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    a045:	00 00 
    a047:	74 05                	je     a04e <tc_hmac_set_key+0xde>
    a049:	e8 f2 a5 ff ff       	callq  4640 <__stack_chk_fail@plt>
    a04e:	48 81 c4 40 01 00 00 	add    $0x140,%rsp
    a055:	5b                   	pop    %rbx
    a056:	5d                   	pop    %rbp
    a057:	41 5c                	pop    %r12
    a059:	41 5d                	pop    %r13
    a05b:	41 5e                	pop    %r14
    a05d:	c3                   	retq   

000000000000a05e <tc_hmac_init>:

int tc_hmac_init(TCHmacState_t ctx)
{

	/* input sanity check: */
	if (ctx == (TCHmacState_t) 0) {
    a05e:	48 85 ff             	test   %rdi,%rdi
    a061:	74 21                	je     a084 <tc_hmac_init+0x26>
{
    a063:	53                   	push   %rbx
    a064:	48 89 fb             	mov    %rdi,%rbx
		return TC_CRYPTO_FAIL;
	}

  (void) tc_sha256_init(&ctx->hash_state);
    a067:	e8 da fc ff ff       	callq  9d46 <tc_sha256_init>
  (void) tc_sha256_update(&ctx->hash_state, ctx->key, TC_SHA256_BLOCK_SIZE);
    a06c:	48 8d 73 70          	lea    0x70(%rbx),%rsi
    a070:	48 89 df             	mov    %rbx,%rdi
    a073:	ba 40 00 00 00       	mov    $0x40,%edx
    a078:	e8 1f fd ff ff       	callq  9d9c <tc_sha256_update>

	return TC_CRYPTO_SUCCESS;
    a07d:	b8 01 00 00 00       	mov    $0x1,%eax
}
    a082:	5b                   	pop    %rbx
    a083:	c3                   	retq   
    a084:	31 c0                	xor    %eax,%eax
    a086:	c3                   	retq   

000000000000a087 <tc_hmac_update>:
		   const void *data,
		   unsigned int data_length)
{

	/* input sanity check: */
	if (ctx == (TCHmacState_t) 0) {
    a087:	48 85 ff             	test   %rdi,%rdi
    a08a:	74 12                	je     a09e <tc_hmac_update+0x17>
{
    a08c:	48 83 ec 08          	sub    $0x8,%rsp
		return TC_CRYPTO_FAIL;
	}

	(void)tc_sha256_update(&ctx->hash_state, data, data_length);
    a090:	89 d2                	mov    %edx,%edx
    a092:	e8 05 fd ff ff       	callq  9d9c <tc_sha256_update>

	return TC_CRYPTO_SUCCESS;
    a097:	b8 01 00 00 00       	mov    $0x1,%eax
}
    a09c:	5a                   	pop    %rdx
    a09d:	c3                   	retq   
    a09e:	31 c0                	xor    %eax,%eax
    a0a0:	c3                   	retq   

000000000000a0a1 <tc_hmac_final>:
int tc_hmac_final(uint8_t *tag, unsigned int taglen, TCHmacState_t ctx)
{

	/* input sanity check: */
	if (tag == (uint8_t *) 0 ||
	    taglen != TC_SHA256_DIGEST_SIZE ||
    a0a1:	83 fe 20             	cmp    $0x20,%esi
    a0a4:	0f 95 c1             	setne  %cl
    a0a7:	48 85 d2             	test   %rdx,%rdx
    a0aa:	0f 94 c0             	sete   %al
    a0ad:	08 c1                	or     %al,%cl
    a0af:	75 68                	jne    a119 <tc_hmac_final+0x78>
    a0b1:	48 85 ff             	test   %rdi,%rdi
    a0b4:	74 63                	je     a119 <tc_hmac_final+0x78>
{
    a0b6:	55                   	push   %rbp
    a0b7:	53                   	push   %rbx
	    ctx == (TCHmacState_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	(void) tc_sha256_final(tag, &ctx->hash_state);
    a0b8:	48 89 d6             	mov    %rdx,%rsi
    a0bb:	48 89 d3             	mov    %rdx,%rbx
    a0be:	48 89 fd             	mov    %rdi,%rbp
{
    a0c1:	48 83 ec 08          	sub    $0x8,%rsp
	(void) tc_sha256_final(tag, &ctx->hash_state);
    a0c5:	e8 4b fd ff ff       	callq  9e15 <tc_sha256_final>

	(void)tc_sha256_init(&ctx->hash_state);
    a0ca:	48 89 df             	mov    %rbx,%rdi
    a0cd:	e8 74 fc ff ff       	callq  9d46 <tc_sha256_init>
	(void)tc_sha256_update(&ctx->hash_state,
			       &ctx->key[TC_SHA256_BLOCK_SIZE],
    a0d2:	48 8d b3 b0 00 00 00 	lea    0xb0(%rbx),%rsi
	(void)tc_sha256_update(&ctx->hash_state,
    a0d9:	48 89 df             	mov    %rbx,%rdi
    a0dc:	ba 40 00 00 00       	mov    $0x40,%edx
    a0e1:	e8 b6 fc ff ff       	callq  9d9c <tc_sha256_update>
				TC_SHA256_BLOCK_SIZE);
	(void)tc_sha256_update(&ctx->hash_state, tag, TC_SHA256_DIGEST_SIZE);
    a0e6:	ba 20 00 00 00       	mov    $0x20,%edx
    a0eb:	48 89 ee             	mov    %rbp,%rsi
    a0ee:	48 89 df             	mov    %rbx,%rdi
    a0f1:	e8 a6 fc ff ff       	callq  9d9c <tc_sha256_update>
	(void)tc_sha256_final(tag, &ctx->hash_state);
    a0f6:	48 89 de             	mov    %rbx,%rsi
    a0f9:	48 89 ef             	mov    %rbp,%rdi
    a0fc:	e8 14 fd ff ff       	callq  9e15 <tc_sha256_final>

	/* destroy the current state */
	_set(ctx, 0, sizeof(*ctx));
    a101:	ba f0 00 00 00       	mov    $0xf0,%edx
    a106:	48 89 df             	mov    %rbx,%rdi
    a109:	31 f6                	xor    %esi,%esi
    a10b:	e8 af f2 ff ff       	callq  93bf <_set>

	return TC_CRYPTO_SUCCESS;
}
    a110:	5a                   	pop    %rdx
	return TC_CRYPTO_SUCCESS;
    a111:	b8 01 00 00 00       	mov    $0x1,%eax
}
    a116:	5b                   	pop    %rbx
    a117:	5d                   	pop    %rbp
    a118:	c3                   	retq   
		return TC_CRYPTO_FAIL;
    a119:	31 c0                	xor    %eax,%eax
}
    a11b:	c3                   	retq   

000000000000a11c <update>:

/*
 * Assumes: prng != NULL
 */
static void update(TCHmacPrng_t prng, const uint8_t *data, unsigned int datalen, const uint8_t *additional_data, unsigned int additional_datalen)
{
    a11c:	41 57                	push   %r15
    a11e:	41 56                	push   %r14
    a120:	41 89 d6             	mov    %edx,%r14d
    a123:	41 55                	push   %r13
    a125:	41 54                	push   %r12
	const uint8_t separator0 = 0x00;
	const uint8_t separator1 = 0x01;

	/* configure the new prng key into the prng's instance of hmac */
	tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
    a127:	4c 8d a7 f0 00 00 00 	lea    0xf0(%rdi),%r12
{
    a12e:	55                   	push   %rbp
    a12f:	53                   	push   %rbx
    a130:	48 89 fb             	mov    %rdi,%rbx
	tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
    a133:	ba 20 00 00 00       	mov    $0x20,%edx
{
    a138:	49 89 f5             	mov    %rsi,%r13

	/* use current state, e and separator 0 to compute a new prng key: */
	(void)tc_hmac_init(&prng->h);
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
    a13b:	48 8d ab 10 01 00 00 	lea    0x110(%rbx),%rbp
{
    a142:	48 83 ec 28          	sub    $0x28,%rsp
	tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
    a146:	4c 89 e6             	mov    %r12,%rsi
{
    a149:	45 89 c7             	mov    %r8d,%r15d
    a14c:	48 89 0c 24          	mov    %rcx,(%rsp)
	const uint8_t separator0 = 0x00;
    a150:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)
{
    a155:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    a15c:	00 00 
    a15e:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    a163:	31 c0                	xor    %eax,%eax
	const uint8_t separator1 = 0x01;
    a165:	c6 44 24 17 01       	movb   $0x1,0x17(%rsp)
	tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
    a16a:	e8 01 fe ff ff       	callq  9f70 <tc_hmac_set_key>
	(void)tc_hmac_init(&prng->h);
    a16f:	48 89 df             	mov    %rbx,%rdi
    a172:	e8 e7 fe ff ff       	callq  a05e <tc_hmac_init>
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
    a177:	ba 20 00 00 00       	mov    $0x20,%edx
    a17c:	48 89 ee             	mov    %rbp,%rsi
    a17f:	48 89 df             	mov    %rbx,%rdi
    a182:	e8 00 ff ff ff       	callq  a087 <tc_hmac_update>
	(void)tc_hmac_update(&prng->h, &separator0, sizeof(separator0));
    a187:	48 8d 74 24 16       	lea    0x16(%rsp),%rsi
    a18c:	ba 01 00 00 00       	mov    $0x1,%edx
    a191:	48 89 df             	mov    %rbx,%rdi
    a194:	e8 ee fe ff ff       	callq  a087 <tc_hmac_update>

	if (data && datalen)
    a199:	4d 85 ed             	test   %r13,%r13
    a19c:	74 13                	je     a1b1 <update+0x95>
    a19e:	45 85 f6             	test   %r14d,%r14d
    a1a1:	74 0e                	je     a1b1 <update+0x95>
		(void)tc_hmac_update(&prng->h, data, datalen);
    a1a3:	44 89 f2             	mov    %r14d,%edx
    a1a6:	4c 89 ee             	mov    %r13,%rsi
    a1a9:	48 89 df             	mov    %rbx,%rdi
    a1ac:	e8 d6 fe ff ff       	callq  a087 <tc_hmac_update>
	if (additional_data && additional_datalen)
    a1b1:	48 83 3c 24 00       	cmpq   $0x0,(%rsp)
    a1b6:	0f 95 c2             	setne  %dl
    a1b9:	45 85 ff             	test   %r15d,%r15d
    a1bc:	0f 95 c0             	setne  %al
    a1bf:	20 c2                	and    %al,%dl
    a1c1:	88 54 24 0f          	mov    %dl,0xf(%rsp)
    a1c5:	74 0f                	je     a1d6 <update+0xba>
		(void)tc_hmac_update(&prng->h, additional_data, additional_datalen);
    a1c7:	48 8b 34 24          	mov    (%rsp),%rsi
    a1cb:	44 89 fa             	mov    %r15d,%edx
    a1ce:	48 89 df             	mov    %rbx,%rdi
    a1d1:	e8 b1 fe ff ff       	callq  a087 <tc_hmac_update>

	(void)tc_hmac_final(prng->key, sizeof(prng->key), &prng->h);
    a1d6:	48 89 da             	mov    %rbx,%rdx
    a1d9:	be 20 00 00 00       	mov    $0x20,%esi
    a1de:	4c 89 e7             	mov    %r12,%rdi
    a1e1:	e8 bb fe ff ff       	callq  a0a1 <tc_hmac_final>

	/* configure the new prng key into the prng's instance of hmac */
	(void)tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
    a1e6:	ba 20 00 00 00       	mov    $0x20,%edx
    a1eb:	4c 89 e6             	mov    %r12,%rsi
    a1ee:	48 89 df             	mov    %rbx,%rdi
    a1f1:	e8 7a fd ff ff       	callq  9f70 <tc_hmac_set_key>

	/* use the new key to compute a new state variable v */
	(void)tc_hmac_init(&prng->h);
    a1f6:	48 89 df             	mov    %rbx,%rdi
    a1f9:	e8 60 fe ff ff       	callq  a05e <tc_hmac_init>
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
    a1fe:	ba 20 00 00 00       	mov    $0x20,%edx
    a203:	48 89 ee             	mov    %rbp,%rsi
    a206:	48 89 df             	mov    %rbx,%rdi
    a209:	e8 79 fe ff ff       	callq  a087 <tc_hmac_update>
	(void)tc_hmac_final(prng->v, sizeof(prng->v), &prng->h);
    a20e:	48 89 da             	mov    %rbx,%rdx
    a211:	be 20 00 00 00       	mov    $0x20,%esi
    a216:	48 89 ef             	mov    %rbp,%rdi
    a219:	e8 83 fe ff ff       	callq  a0a1 <tc_hmac_final>

	if (data == 0 || datalen == 0)
    a21e:	4d 85 ed             	test   %r13,%r13
    a221:	0f 84 af 00 00 00    	je     a2d6 <update+0x1ba>
    a227:	45 85 f6             	test   %r14d,%r14d
    a22a:	0f 84 a6 00 00 00    	je     a2d6 <update+0x1ba>
		return;

	/* configure the new prng key into the prng's instance of hmac */
	tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
    a230:	ba 20 00 00 00       	mov    $0x20,%edx
    a235:	4c 89 e6             	mov    %r12,%rsi
    a238:	48 89 df             	mov    %rbx,%rdi
    a23b:	e8 30 fd ff ff       	callq  9f70 <tc_hmac_set_key>

	/* use current state, e and separator 1 to compute a new prng key: */
	(void)tc_hmac_init(&prng->h);
    a240:	48 89 df             	mov    %rbx,%rdi
    a243:	e8 16 fe ff ff       	callq  a05e <tc_hmac_init>
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
    a248:	ba 20 00 00 00       	mov    $0x20,%edx
    a24d:	48 89 ee             	mov    %rbp,%rsi
    a250:	48 89 df             	mov    %rbx,%rdi
    a253:	e8 2f fe ff ff       	callq  a087 <tc_hmac_update>
	(void)tc_hmac_update(&prng->h, &separator1, sizeof(separator1));
    a258:	48 8d 74 24 17       	lea    0x17(%rsp),%rsi
    a25d:	ba 01 00 00 00       	mov    $0x1,%edx
    a262:	48 89 df             	mov    %rbx,%rdi
    a265:	e8 1d fe ff ff       	callq  a087 <tc_hmac_update>
	(void)tc_hmac_update(&prng->h, data, datalen);
    a26a:	44 89 f2             	mov    %r14d,%edx
    a26d:	4c 89 ee             	mov    %r13,%rsi
    a270:	48 89 df             	mov    %rbx,%rdi
    a273:	e8 0f fe ff ff       	callq  a087 <tc_hmac_update>
	if (additional_data && additional_datalen)
    a278:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%rsp)
    a27d:	74 0f                	je     a28e <update+0x172>
		(void)tc_hmac_update(&prng->h, additional_data, additional_datalen);
    a27f:	48 8b 34 24          	mov    (%rsp),%rsi
    a283:	44 89 fa             	mov    %r15d,%edx
    a286:	48 89 df             	mov    %rbx,%rdi
    a289:	e8 f9 fd ff ff       	callq  a087 <tc_hmac_update>
	(void)tc_hmac_final(prng->key, sizeof(prng->key), &prng->h);
    a28e:	48 89 da             	mov    %rbx,%rdx
    a291:	be 20 00 00 00       	mov    $0x20,%esi
    a296:	4c 89 e7             	mov    %r12,%rdi
    a299:	e8 03 fe ff ff       	callq  a0a1 <tc_hmac_final>

	/* configure the new prng key into the prng's instance of hmac */
	(void)tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
    a29e:	ba 20 00 00 00       	mov    $0x20,%edx
    a2a3:	4c 89 e6             	mov    %r12,%rsi
    a2a6:	48 89 df             	mov    %rbx,%rdi
    a2a9:	e8 c2 fc ff ff       	callq  9f70 <tc_hmac_set_key>

	/* use the new key to compute a new state variable v */
	(void)tc_hmac_init(&prng->h);
    a2ae:	48 89 df             	mov    %rbx,%rdi
    a2b1:	e8 a8 fd ff ff       	callq  a05e <tc_hmac_init>
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
    a2b6:	ba 20 00 00 00       	mov    $0x20,%edx
    a2bb:	48 89 ee             	mov    %rbp,%rsi
    a2be:	48 89 df             	mov    %rbx,%rdi
    a2c1:	e8 c1 fd ff ff       	callq  a087 <tc_hmac_update>
	(void)tc_hmac_final(prng->v, sizeof(prng->v), &prng->h);
    a2c6:	48 89 da             	mov    %rbx,%rdx
    a2c9:	be 20 00 00 00       	mov    $0x20,%esi
    a2ce:	48 89 ef             	mov    %rbp,%rdi
    a2d1:	e8 cb fd ff ff       	callq  a0a1 <tc_hmac_final>
}
    a2d6:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    a2db:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    a2e2:	00 00 
    a2e4:	74 05                	je     a2eb <update+0x1cf>
    a2e6:	e8 55 a3 ff ff       	callq  4640 <__stack_chk_fail@plt>
    a2eb:	48 83 c4 28          	add    $0x28,%rsp
    a2ef:	5b                   	pop    %rbx
    a2f0:	5d                   	pop    %rbp
    a2f1:	41 5c                	pop    %r12
    a2f3:	41 5d                	pop    %r13
    a2f5:	41 5e                	pop    %r14
    a2f7:	41 5f                	pop    %r15
    a2f9:	c3                   	retq   

000000000000a2fa <tc_hmac_prng_init>:
		      const uint8_t *personalization,
		      unsigned int plen)
{

	/* input sanity check: */
	if (prng == (TCHmacPrng_t) 0 ||
    a2fa:	48 85 ff             	test   %rdi,%rdi
    a2fd:	74 62                	je     a361 <tc_hmac_prng_init+0x67>
    a2ff:	48 85 f6             	test   %rsi,%rsi
    a302:	74 5d                	je     a361 <tc_hmac_prng_init+0x67>
{
    a304:	41 54                	push   %r12
    a306:	55                   	push   %rbp
    a307:	41 89 d4             	mov    %edx,%r12d
    a30a:	53                   	push   %rbx
    a30b:	48 89 fb             	mov    %rdi,%rbx
	    plen > MAX_PLEN) {
		return TC_CRYPTO_FAIL;
	}

	/* put the generator into a known state: */
	_set(prng->key, 0x00, sizeof(prng->key));
    a30e:	48 8d bf f0 00 00 00 	lea    0xf0(%rdi),%rdi
    a315:	48 89 f5             	mov    %rsi,%rbp
    a318:	ba 20 00 00 00       	mov    $0x20,%edx
    a31d:	31 f6                	xor    %esi,%esi
    a31f:	e8 9b f0 ff ff       	callq  93bf <_set>
	_set(prng->v, 0x01, sizeof(prng->v));
    a324:	48 8d bb 10 01 00 00 	lea    0x110(%rbx),%rdi
    a32b:	ba 20 00 00 00       	mov    $0x20,%edx
    a330:	be 01 00 00 00       	mov    $0x1,%esi
    a335:	e8 85 f0 ff ff       	callq  93bf <_set>

	update(prng, personalization, plen, 0, 0);
    a33a:	44 89 e2             	mov    %r12d,%edx
    a33d:	48 89 ee             	mov    %rbp,%rsi
    a340:	48 89 df             	mov    %rbx,%rdi
    a343:	45 31 c0             	xor    %r8d,%r8d
    a346:	31 c9                	xor    %ecx,%ecx
    a348:	e8 cf fd ff ff       	callq  a11c <update>

	/* force a reseed before allowing tc_hmac_prng_generate to succeed: */
	prng->countdown = 0;
    a34d:	c7 83 30 01 00 00 00 	movl   $0x0,0x130(%rbx)
    a354:	00 00 00 

	return TC_CRYPTO_SUCCESS;
    a357:	b8 01 00 00 00       	mov    $0x1,%eax
}
    a35c:	5b                   	pop    %rbx
    a35d:	5d                   	pop    %rbp
    a35e:	41 5c                	pop    %r12
    a360:	c3                   	retq   
		return TC_CRYPTO_FAIL;
    a361:	31 c0                	xor    %eax,%eax
}
    a363:	c3                   	retq   

000000000000a364 <tc_hmac_prng_reseed>:
			unsigned int additionallen)
{

	/* input sanity check: */
	if (prng == (TCHmacPrng_t) 0 ||
	    seed == (const uint8_t *) 0 ||
    a364:	48 85 f6             	test   %rsi,%rsi
    a367:	41 0f 94 c1          	sete   %r9b
	    seedlen < MIN_SLEN ||
    a36b:	83 fa 1f             	cmp    $0x1f,%edx
    a36e:	0f 96 c0             	setbe  %al
    a371:	41 08 c1             	or     %al,%r9b
    a374:	75 35                	jne    a3ab <tc_hmac_prng_reseed+0x47>
    a376:	48 85 ff             	test   %rdi,%rdi
    a379:	74 30                	je     a3ab <tc_hmac_prng_reseed+0x47>
	    seedlen > MAX_SLEN) {
		return TC_CRYPTO_FAIL;
	}

	if (additional_input != (const uint8_t *) 0) {
    a37b:	48 85 c9             	test   %rcx,%rcx
{
    a37e:	53                   	push   %rbx
    a37f:	48 89 fb             	mov    %rdi,%rbx
	if (additional_input != (const uint8_t *) 0) {
    a382:	74 09                	je     a38d <tc_hmac_prng_reseed+0x29>
		return TC_CRYPTO_FAIL;
    a384:	31 c0                	xor    %eax,%eax
		/*
		 * Abort if additional_input is provided but has inappropriate
		 * length
		 */
		if (additionallen == 0 ||
    a386:	45 85 c0             	test   %r8d,%r8d
    a389:	74 23                	je     a3ae <tc_hmac_prng_reseed+0x4a>
    a38b:	eb 05                	jmp    a392 <tc_hmac_prng_reseed+0x2e>
			/* call update for the seed and additional_input */
			update(prng, seed, seedlen, additional_input, additionallen);
		}
	} else {
		/* call update only for the seed */
		update(prng, seed, seedlen, 0, 0);
    a38d:	45 31 c0             	xor    %r8d,%r8d
    a390:	31 c9                	xor    %ecx,%ecx
    a392:	48 89 df             	mov    %rbx,%rdi
    a395:	e8 82 fd ff ff       	callq  a11c <update>
	}

	/* ... and enable hmac_prng_generate */
	prng->countdown = MAX_GENS;
    a39a:	c7 83 30 01 00 00 ff 	movl   $0xffffffff,0x130(%rbx)
    a3a1:	ff ff ff 

	return TC_CRYPTO_SUCCESS;
    a3a4:	b8 01 00 00 00       	mov    $0x1,%eax
    a3a9:	eb 03                	jmp    a3ae <tc_hmac_prng_reseed+0x4a>
		return TC_CRYPTO_FAIL;
    a3ab:	31 c0                	xor    %eax,%eax
}
    a3ad:	c3                   	retq   
    a3ae:	5b                   	pop    %rbx
    a3af:	c3                   	retq   

000000000000a3b0 <tc_hmac_prng_generate>:
int tc_hmac_prng_generate(uint8_t *out, unsigned int outlen, TCHmacPrng_t prng)
{
	unsigned int bufferlen;

	/* input sanity check: */
	if (out == (uint8_t *) 0 ||
    a3b0:	48 85 ff             	test   %rdi,%rdi
    a3b3:	0f 84 f0 00 00 00    	je     a4a9 <tc_hmac_prng_generate+0xf9>
{
    a3b9:	41 57                	push   %r15
    a3bb:	41 56                	push   %r14
	    prng == (TCHmacPrng_t) 0 ||
	    outlen == 0 ||
	    outlen > MAX_OUT) {
		return TC_CRYPTO_FAIL;
    a3bd:	31 c0                	xor    %eax,%eax
{
    a3bf:	41 55                	push   %r13
    a3c1:	41 54                	push   %r12
    a3c3:	55                   	push   %rbp
    a3c4:	53                   	push   %rbx
    a3c5:	48 89 d3             	mov    %rdx,%rbx
    a3c8:	48 83 ec 18          	sub    $0x18,%rsp
	if (out == (uint8_t *) 0 ||
    a3cc:	48 85 d2             	test   %rdx,%rdx
    a3cf:	0f 84 c5 00 00 00    	je     a49a <tc_hmac_prng_generate+0xea>
	    outlen == 0 ||
    a3d5:	8d 56 ff             	lea    -0x1(%rsi),%edx
		return TC_CRYPTO_FAIL;
    a3d8:	31 c0                	xor    %eax,%eax
    a3da:	89 f5                	mov    %esi,%ebp
	    outlen == 0 ||
    a3dc:	81 fa ff ff 07 00    	cmp    $0x7ffff,%edx
    a3e2:	0f 87 b2 00 00 00    	ja     a49a <tc_hmac_prng_generate+0xea>
	} else if (prng->countdown == 0) {
    a3e8:	8b 93 30 01 00 00    	mov    0x130(%rbx),%edx
		return TC_HMAC_PRNG_RESEED_REQ;
    a3ee:	83 c8 ff             	or     $0xffffffff,%eax
	} else if (prng->countdown == 0) {
    a3f1:	85 d2                	test   %edx,%edx
    a3f3:	0f 84 a1 00 00 00    	je     a49a <tc_hmac_prng_generate+0xea>
	}

	prng->countdown--;
    a3f9:	01 c2                	add    %eax,%edx

	while (outlen != 0) {
		/* configure the new prng key into the prng's instance of hmac */
		tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
    a3fb:	48 8d 83 f0 00 00 00 	lea    0xf0(%rbx),%rax
    a402:	49 89 fd             	mov    %rdi,%r13
	prng->countdown--;
    a405:	89 93 30 01 00 00    	mov    %edx,0x130(%rbx)
		tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
    a40b:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    a410:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    a415:	ba 20 00 00 00       	mov    $0x20,%edx

		/* operate HMAC in OFB mode to create "random" outputs */
		(void)tc_hmac_init(&prng->h);
		(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
    a41a:	4c 8d bb 10 01 00 00 	lea    0x110(%rbx),%r15
		tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
    a421:	48 89 df             	mov    %rbx,%rdi
		(void)tc_hmac_final(prng->v, sizeof(prng->v), &prng->h);

		bufferlen = (TC_SHA256_DIGEST_SIZE > outlen) ?
    a424:	41 be 20 00 00 00    	mov    $0x20,%r14d
    a42a:	45 89 f4             	mov    %r14d,%r12d
		tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
    a42d:	e8 3e fb ff ff       	callq  9f70 <tc_hmac_set_key>
		(void)tc_hmac_init(&prng->h);
    a432:	48 89 df             	mov    %rbx,%rdi
    a435:	e8 24 fc ff ff       	callq  a05e <tc_hmac_init>
		(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
    a43a:	ba 20 00 00 00       	mov    $0x20,%edx
    a43f:	4c 89 fe             	mov    %r15,%rsi
    a442:	48 89 df             	mov    %rbx,%rdi
    a445:	e8 3d fc ff ff       	callq  a087 <tc_hmac_update>
		(void)tc_hmac_final(prng->v, sizeof(prng->v), &prng->h);
    a44a:	48 89 da             	mov    %rbx,%rdx
    a44d:	be 20 00 00 00       	mov    $0x20,%esi
    a452:	4c 89 ff             	mov    %r15,%rdi
    a455:	e8 47 fc ff ff       	callq  a0a1 <tc_hmac_final>
		bufferlen = (TC_SHA256_DIGEST_SIZE > outlen) ?
    a45a:	83 fd 20             	cmp    $0x20,%ebp
			outlen : TC_SHA256_DIGEST_SIZE;
		(void)_copy(out, bufferlen, prng->v, bufferlen);
    a45d:	4c 89 ef             	mov    %r13,%rdi
    a460:	4c 89 fa             	mov    %r15,%rdx
		bufferlen = (TC_SHA256_DIGEST_SIZE > outlen) ?
    a463:	44 0f 46 e5          	cmovbe %ebp,%r12d
		(void)_copy(out, bufferlen, prng->v, bufferlen);
    a467:	44 89 e1             	mov    %r12d,%ecx
    a46a:	44 89 e6             	mov    %r12d,%esi

		out += bufferlen;
    a46d:	45 89 e4             	mov    %r12d,%r12d
		(void)_copy(out, bufferlen, prng->v, bufferlen);
    a470:	e8 39 ef ff ff       	callq  93ae <_copy>
		out += bufferlen;
    a475:	4d 01 e5             	add    %r12,%r13
		outlen = (outlen > TC_SHA256_DIGEST_SIZE) ?
			(outlen - TC_SHA256_DIGEST_SIZE) : 0;
    a478:	83 fd 20             	cmp    $0x20,%ebp
    a47b:	41 0f 42 ee          	cmovb  %r14d,%ebp
	while (outlen != 0) {
    a47f:	83 ed 20             	sub    $0x20,%ebp
    a482:	75 8c                	jne    a410 <tc_hmac_prng_generate+0x60>
	}

	/* block future PRNG compromises from revealing past state */
	update(prng, 0, 0, 0, 0);
    a484:	45 31 c0             	xor    %r8d,%r8d
    a487:	31 c9                	xor    %ecx,%ecx
    a489:	31 d2                	xor    %edx,%edx
    a48b:	31 f6                	xor    %esi,%esi
    a48d:	48 89 df             	mov    %rbx,%rdi
    a490:	e8 87 fc ff ff       	callq  a11c <update>

	return TC_CRYPTO_SUCCESS;
    a495:	b8 01 00 00 00       	mov    $0x1,%eax
}
    a49a:	48 83 c4 18          	add    $0x18,%rsp
    a49e:	5b                   	pop    %rbx
    a49f:	5d                   	pop    %rbp
    a4a0:	41 5c                	pop    %r12
    a4a2:	41 5d                	pop    %r13
    a4a4:	41 5e                	pop    %r14
    a4a6:	41 5f                	pop    %r15
    a4a8:	c3                   	retq   
		return TC_CRYPTO_FAIL;
    a4a9:	31 c0                	xor    %eax,%eax
}
    a4ab:	c3                   	retq   

000000000000a4ac <arch_cpu_idle>:
 * arch_busy_wait()
 */
#endif

void arch_cpu_idle(void)
{
    a4ac:	48 83 ec 08          	sub    $0x8,%rsp
	sys_trace_idle();
	posix_irq_full_unlock();
    a4b0:	e8 ec 1a 00 00       	callq  bfa1 <posix_irq_full_unlock>
	posix_halt_cpu();
}
    a4b5:	58                   	pop    %rax
	posix_halt_cpu();
    a4b6:	e9 d9 10 00 00       	jmpq   b594 <posix_halt_cpu>

000000000000a4bb <arch_system_halt>:

FUNC_NORETURN void arch_system_halt(unsigned int reason)
{
	ARG_UNUSED(reason);

	posix_print_error_and_exit("Exiting due to fatal error\n");
    a4bb:	48 8d 3d af 6f 02 00 	lea    0x26faf(%rip),%rdi        # 31471 <__func__.5785+0x809>
    a4c2:	31 c0                	xor    %eax,%eax
{
    a4c4:	48 83 ec 08          	sub    $0x8,%rsp
	posix_print_error_and_exit("Exiting due to fatal error\n");
    a4c8:	e8 f5 1d 00 00       	callq  c2c2 <posix_print_error_and_exit>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    a4cd:	48 8d 35 b9 6f 02 00 	lea    0x26fb9(%rip),%rsi        # 3148d <__func__.5785+0x825>
    a4d4:	48 8d 3d 77 6c 02 00 	lea    0x26c77(%rip),%rdi        # 31152 <__func__.5785+0x4ea>
    a4db:	ba 15 00 00 00       	mov    $0x15,%edx
    a4e0:	31 c0                	xor    %eax,%eax
    a4e2:	e8 db 1d 00 00       	callq  c2c2 <posix_print_error_and_exit>

000000000000a4e7 <arch_irq_enable>:
}
#endif

void arch_irq_enable(unsigned int irq)
{
	posix_irq_enable(irq);
    a4e7:	e9 bc 1a 00 00       	jmpq   bfa8 <posix_irq_enable>

000000000000a4ec <pc_safe_call>:
#endif

static inline void pc_safe_call(int test, const char *test_str)
{
	/* LCOV_EXCL_START */ /* See Note1 */
	if (unlikely(test)) {
    a4ec:	85 ff                	test   %edi,%edi
    a4ee:	74 0e                	je     a4fe <pc_safe_call+0x12>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    a4f0:	48 8d 3d c0 6f 02 00 	lea    0x26fc0(%rip),%rdi        # 314b7 <__func__.5785+0x84f>
    a4f7:	31 c0                	xor    %eax,%eax
    a4f9:	e9 c4 1d 00 00       	jmpq   c2c2 <posix_print_error_and_exit>
					   test_str);
	}
	/* LCOV_EXCL_STOP */
}
    a4fe:	c3                   	retq   

000000000000a4ff <posix_preexit_cleanup>:
static void posix_preexit_cleanup(void)
{
	/*
	 * Release the mutex so the next allowed thread can run
	 */
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
    a4ff:	48 8d 3d 7a c4 24 00 	lea    0x24c47a(%rip),%rdi        # 256980 <mtx_threads>
{
    a506:	48 83 ec 08          	sub    $0x8,%rsp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
    a50a:	e8 01 a0 ff ff       	callq  4510 <pthread_mutex_unlock@plt>
    a50f:	48 8d 35 bb 6f 02 00 	lea    0x26fbb(%rip),%rsi        # 314d1 <__func__.5785+0x869>
    a516:	89 c7                	mov    %eax,%edi
    a518:	e8 cf ff ff ff       	callq  a4ec <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
    a51d:	e8 6e a0 ff ff       	callq  4590 <pthread_self@plt>
    a522:	48 89 c7             	mov    %rax,%rdi
}
    a525:	58                   	pop    %rax
	pthread_detach(pthread_self());
    a526:	e9 d5 a0 ff ff       	jmpq   4600 <pthread_detach@plt>

000000000000a52b <abort_tail>:
	threads_table[this_th_nbr].running = false;
    a52b:	48 63 ff             	movslq %edi,%rdi
{
    a52e:	48 83 ec 08          	sub    $0x8,%rsp
	threads_table[this_th_nbr].running = false;
    a532:	48 c1 e7 05          	shl    $0x5,%rdi
    a536:	48 03 3d ab d9 24 00 	add    0x24d9ab(%rip),%rdi        # 257ee8 <threads_table>
    a53d:	c6 47 04 00          	movb   $0x0,0x4(%rdi)
	threads_table[this_th_nbr].state = ABORTED;
    a541:	c7 07 03 00 00 00    	movl   $0x3,(%rdi)
	posix_preexit_cleanup();
    a547:	e8 b3 ff ff ff       	callq  a4ff <posix_preexit_cleanup>
	pthread_exit(NULL);
    a54c:	31 ff                	xor    %edi,%edi
    a54e:	e8 3d a2 ff ff       	callq  4790 <pthread_exit@plt>

000000000000a553 <posix_wait_until_allowed>:
	threads_table[this_th_nbr].running = false;
    a553:	48 8b 05 8e d9 24 00 	mov    0x24d98e(%rip),%rax        # 257ee8 <threads_table>
{
    a55a:	41 54                	push   %r12
		pthread_cond_wait(&cond_threads, &mtx_threads);
    a55c:	4c 8d 25 1d c4 24 00 	lea    0x24c41d(%rip),%r12        # 256980 <mtx_threads>
{
    a563:	55                   	push   %rbp
    a564:	53                   	push   %rbx
    a565:	48 63 df             	movslq %edi,%rbx
    a568:	48 89 dd             	mov    %rbx,%rbp
	threads_table[this_th_nbr].running = false;
    a56b:	48 c1 e3 05          	shl    $0x5,%rbx
    a56f:	c6 44 18 04 00       	movb   $0x0,0x4(%rax,%rbx,1)
	while (this_th_nbr != currently_allowed_thread) {
    a574:	39 2d f2 1a 25 00    	cmp    %ebp,0x251af2(%rip)        # 25c06c <currently_allowed_thread>
    a57a:	74 28                	je     a5a4 <posix_wait_until_allowed+0x51>
		pthread_cond_wait(&cond_threads, &mtx_threads);
    a57c:	48 8d 3d 3d c4 24 00 	lea    0x24c43d(%rip),%rdi        # 2569c0 <cond_threads>
    a583:	4c 89 e6             	mov    %r12,%rsi
    a586:	e8 95 a1 ff ff       	callq  4720 <pthread_cond_wait@plt>
		if (threads_table &&
    a58b:	48 8b 05 56 d9 24 00 	mov    0x24d956(%rip),%rax        # 257ee8 <threads_table>
    a592:	48 85 c0             	test   %rax,%rax
    a595:	74 dd                	je     a574 <posix_wait_until_allowed+0x21>
    a597:	83 3c 18 02          	cmpl   $0x2,(%rax,%rbx,1)
    a59b:	75 d7                	jne    a574 <posix_wait_until_allowed+0x21>
			abort_tail(this_th_nbr);
    a59d:	89 ef                	mov    %ebp,%edi
    a59f:	e8 87 ff ff ff       	callq  a52b <abort_tail>
	threads_table[this_th_nbr].running = true;
    a5a4:	48 8b 05 3d d9 24 00 	mov    0x24d93d(%rip),%rax        # 257ee8 <threads_table>
    a5ab:	c6 44 18 04 01       	movb   $0x1,0x4(%rax,%rbx,1)
}
    a5b0:	5b                   	pop    %rbx
    a5b1:	5d                   	pop    %rbp
    a5b2:	41 5c                	pop    %r12
    a5b4:	c3                   	retq   

000000000000a5b5 <posix_cleanup_handler>:
	 * and the mutex was already released
	 * Otherwise, release the mutex so other threads which may be
	 * caught waiting for it could terminate
	 */

	if (!terminate) {
    a5b5:	80 3d 28 4b 25 00 00 	cmpb   $0x0,0x254b28(%rip)        # 25f0e4 <terminate>
    a5bc:	74 2c                	je     a5ea <posix_cleanup_handler+0x35>
		ptr->thread_idx,
		__func__);
#endif


	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
    a5be:	48 8d 3d bb c3 24 00 	lea    0x24c3bb(%rip),%rdi        # 256980 <mtx_threads>
{
    a5c5:	48 83 ec 08          	sub    $0x8,%rsp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
    a5c9:	e8 42 9f ff ff       	callq  4510 <pthread_mutex_unlock@plt>
    a5ce:	48 8d 35 fc 6e 02 00 	lea    0x26efc(%rip),%rsi        # 314d1 <__func__.5785+0x869>
    a5d5:	89 c7                	mov    %eax,%edi
    a5d7:	e8 10 ff ff ff       	callq  a4ec <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
    a5dc:	e8 af 9f ff ff       	callq  4590 <pthread_self@plt>
    a5e1:	48 89 c7             	mov    %rax,%rdi
}
    a5e4:	58                   	pop    %rax
	pthread_detach(pthread_self());
    a5e5:	e9 16 a0 ff ff       	jmpq   4600 <pthread_detach@plt>
    a5ea:	c3                   	retq   

000000000000a5eb <posix_thread_starter>:
 *  It will block the thread until a arch_swap() is called for it
 *
 * Spawned from posix_new_thread() below
 */
static void *posix_thread_starter(void *arg)
{
    a5eb:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
    a5f2:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)

	/*
	 * We block until all other running threads reach the while loop
	 * in posix_wait_until_allowed() and they release the mutex
	 */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    a5f7:	48 8d 3d 82 c3 24 00 	lea    0x24c382(%rip),%rdi        # 256980 <mtx_threads>
{
    a5fe:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    a605:	00 00 
    a607:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
    a60c:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    a60e:	e8 ed a0 ff ff       	callq  4700 <pthread_mutex_lock@plt>
    a613:	48 8d 35 da 6e 02 00 	lea    0x26eda(%rip),%rsi        # 314f4 <__func__.5785+0x88c>
    a61a:	89 c7                	mov    %eax,%edi
    a61c:	e8 cb fe ff ff       	callq  a4ec <pc_safe_call>

	/*
	 * The program may have been finished before this thread ever got to run
	 */
	/* LCOV_EXCL_START */ /* See Note1 */
	if (!threads_table) {
    a621:	48 83 3d bf d8 24 00 	cmpq   $0x0,0x24d8bf(%rip)        # 257ee8 <threads_table>
    a628:	00 
    a629:	75 11                	jne    a63c <posix_thread_starter+0x51>
		posix_cleanup_handler(arg);
    a62b:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    a630:	e8 80 ff ff ff       	callq  a5b5 <posix_cleanup_handler>
		pthread_exit(NULL);
    a635:	31 ff                	xor    %edi,%edi
    a637:	e8 54 a1 ff ff       	callq  4790 <pthread_exit@plt>
	}
	/* LCOV_EXCL_STOP */

	pthread_cleanup_push(posix_cleanup_handler, arg);
    a63c:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    a641:	31 f6                	xor    %esi,%esi
    a643:	e8 98 a0 ff ff       	callq  46e0 <__sigsetjmp@plt>
    a648:	85 c0                	test   %eax,%eax
    a64a:	74 14                	je     a660 <posix_thread_starter+0x75>
    a64c:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    a651:	e8 5f ff ff ff       	callq  a5b5 <posix_cleanup_handler>
    a656:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    a65b:	e8 50 9f ff ff       	callq  45b0 <__pthread_unwind_next@plt>
    a660:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    a665:	e8 f6 9e ff ff       	callq  4560 <__pthread_register_cancel@plt>

	/*
	 * The thread would try to execute immediately, so we block it
	 * until allowed
	 */
	posix_wait_until_allowed(thread_idx);
    a66a:	8b 7c 24 08          	mov    0x8(%rsp),%edi
    a66e:	e8 e0 fe ff ff       	callq  a553 <posix_wait_until_allowed>

	posix_new_thread_pre_start();
    a673:	e8 8c 03 00 00       	callq  aa04 <posix_new_thread_pre_start>

	posix_thread_status_t *ptr = threads_table[thread_idx].t_status;
    a678:	48 63 44 24 08       	movslq 0x8(%rsp),%rax
    a67d:	48 c1 e0 05          	shl    $0x5,%rax
    a681:	48 03 05 60 d8 24 00 	add    0x24d860(%rip),%rax        # 257ee8 <threads_table>
    a688:	48 8b 40 18          	mov    0x18(%rax),%rax

	z_thread_entry(ptr->entry_point, ptr->arg1, ptr->arg2, ptr->arg3);
    a68c:	48 8b 48 18          	mov    0x18(%rax),%rcx
    a690:	48 8b 50 10          	mov    0x10(%rax),%rdx
    a694:	48 8b 70 08          	mov    0x8(%rax),%rsi
    a698:	48 8b 38             	mov    (%rax),%rdi
    a69b:	e8 b8 b4 ff ff       	callq  5b58 <z_thread_entry>

000000000000a6a0 <posix_swap>:
{
    a6a0:	53                   	push   %rbx
	currently_allowed_thread = next_allowed_th;
    a6a1:	89 3d c5 19 25 00    	mov    %edi,0x2519c5(%rip)        # 25c06c <currently_allowed_thread>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    a6a7:	48 8d 3d 12 c3 24 00 	lea    0x24c312(%rip),%rdi        # 2569c0 <cond_threads>
{
    a6ae:	89 f3                	mov    %esi,%ebx
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    a6b0:	e8 5b 9d ff ff       	callq  4410 <pthread_cond_broadcast@plt>
    a6b5:	48 8d 35 59 6e 02 00 	lea    0x26e59(%rip),%rsi        # 31515 <__func__.5785+0x8ad>
    a6bc:	89 c7                	mov    %eax,%edi
    a6be:	e8 29 fe ff ff       	callq  a4ec <pc_safe_call>
	if (threads_table[this_th_nbr].state == ABORTING) {
    a6c3:	48 63 c3             	movslq %ebx,%rax
		abort_tail(this_th_nbr);
    a6c6:	89 df                	mov    %ebx,%edi
	if (threads_table[this_th_nbr].state == ABORTING) {
    a6c8:	48 c1 e0 05          	shl    $0x5,%rax
    a6cc:	48 03 05 15 d8 24 00 	add    0x24d815(%rip),%rax        # 257ee8 <threads_table>
    a6d3:	83 38 02             	cmpl   $0x2,(%rax)
    a6d6:	75 05                	jne    a6dd <posix_swap+0x3d>
		abort_tail(this_th_nbr);
    a6d8:	e8 4e fe ff ff       	callq  a52b <abort_tail>
}
    a6dd:	5b                   	pop    %rbx
		posix_wait_until_allowed(this_th_nbr);
    a6de:	e9 70 fe ff ff       	jmpq   a553 <posix_wait_until_allowed>

000000000000a6e3 <posix_main_thread_start>:
{
    a6e3:	48 83 ec 08          	sub    $0x8,%rsp
	currently_allowed_thread = next_allowed_th;
    a6e7:	89 3d 7f 19 25 00    	mov    %edi,0x25197f(%rip)        # 25c06c <currently_allowed_thread>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    a6ed:	48 8d 3d cc c2 24 00 	lea    0x24c2cc(%rip),%rdi        # 2569c0 <cond_threads>
    a6f4:	e8 17 9d ff ff       	callq  4410 <pthread_cond_broadcast@plt>
    a6f9:	48 8d 35 15 6e 02 00 	lea    0x26e15(%rip),%rsi        # 31515 <__func__.5785+0x8ad>
    a700:	89 c7                	mov    %eax,%edi
    a702:	e8 e5 fd ff ff       	callq  a4ec <pc_safe_call>
	posix_preexit_cleanup();
    a707:	e8 f3 fd ff ff       	callq  a4ff <posix_preexit_cleanup>
	pthread_exit(NULL);
    a70c:	31 ff                	xor    %edi,%edi
    a70e:	e8 7d a0 ff ff       	callq  4790 <pthread_exit@plt>

000000000000a713 <posix_new_thread>:
 * Create a new POSIX thread for the new Zephyr thread.
 * arch_new_thread() picks from the kernel structures what it is that we need
 * to call with what parameters
 */
void posix_new_thread(posix_thread_status_t *ptr)
{
    a713:	53                   	push   %rbx
	for (int i = 0; i < threads_table_size; i++) {
    a714:	8b 35 5a 19 25 00    	mov    0x25195a(%rip),%esi        # 25c074 <threads_table_size>
{
    a71a:	48 89 fb             	mov    %rdi,%rbx
		if ((threads_table[i].state == NOTUSED)
    a71d:	48 8b 3d c4 d7 24 00 	mov    0x24d7c4(%rip),%rdi        # 257ee8 <threads_table>
    a724:	31 c0                	xor    %eax,%eax
	for (int i = 0; i < threads_table_size; i++) {
    a726:	39 f0                	cmp    %esi,%eax
    a728:	41 89 c0             	mov    %eax,%r8d
    a72b:	7d 13                	jge    a740 <posix_new_thread+0x2d>
    a72d:	48 ff c0             	inc    %rax
		if ((threads_table[i].state == NOTUSED)
    a730:	48 89 c2             	mov    %rax,%rdx
    a733:	48 c1 e2 05          	shl    $0x5,%rdx
    a737:	83 7c 17 e0 00       	cmpl   $0x0,-0x20(%rdi,%rdx,1)
    a73c:	75 e8                	jne    a726 <posix_new_thread+0x13>
    a73e:	eb 52                	jmp    a792 <posix_new_thread+0x7f>
				(threads_table_size + PC_ALLOC_CHUNK_SIZE)
    a740:	83 c6 40             	add    $0x40,%esi
    a743:	48 63 f6             	movslq %esi,%rsi
	threads_table = realloc(threads_table,
    a746:	48 c1 e6 05          	shl    $0x5,%rsi
    a74a:	e8 01 a0 ff ff       	callq  4750 <realloc@plt>
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
    a74f:	48 85 c0             	test   %rax,%rax
	threads_table = realloc(threads_table,
    a752:	48 89 05 8f d7 24 00 	mov    %rax,0x24d78f(%rip)        # 257ee8 <threads_table>
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
    a759:	75 0c                	jne    a767 <posix_new_thread+0x54>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
    a75b:	48 8d 3d d9 6d 02 00 	lea    0x26dd9(%rip),%rdi        # 3153b <__func__.5785+0x8d3>
    a762:	e8 5b 1b 00 00       	callq  c2c2 <posix_print_error_and_exit>
	(void)memset(&threads_table[threads_table_size], 0,
    a767:	48 63 15 06 19 25 00 	movslq 0x251906(%rip),%rdx        # 25c074 <threads_table_size>
    a76e:	31 c0                	xor    %eax,%eax
    a770:	b9 00 02 00 00       	mov    $0x200,%ecx
    a775:	49 89 d0             	mov    %rdx,%r8
    a778:	48 c1 e2 05          	shl    $0x5,%rdx
    a77c:	48 03 15 65 d7 24 00 	add    0x24d765(%rip),%rdx        # 257ee8 <threads_table>
    a783:	48 89 d7             	mov    %rdx,%rdi
    a786:	f3 ab                	rep stos %eax,%es:(%rdi)
	threads_table_size += PC_ALLOC_CHUNK_SIZE;
    a788:	41 8d 40 40          	lea    0x40(%r8),%eax
    a78c:	89 05 e2 18 25 00    	mov    %eax,0x2518e2(%rip)        # 25c074 <threads_table_size>
	int t_slot;

	t_slot = ttable_get_empty_slot();
	threads_table[t_slot].state = USED;
	threads_table[t_slot].running = false;
	threads_table[t_slot].thead_cnt = thread_create_count++;
    a792:	8b 05 d8 18 25 00    	mov    0x2518d8(%rip),%eax        # 25c070 <thread_create_count>
	threads_table[t_slot].state = USED;
    a798:	49 63 c8             	movslq %r8d,%rcx
	threads_table[t_slot].t_status = ptr;
	ptr->thread_idx = t_slot;

	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    a79b:	31 f6                	xor    %esi,%esi
	threads_table[t_slot].state = USED;
    a79d:	48 89 cf             	mov    %rcx,%rdi
    a7a0:	48 c1 e7 05          	shl    $0x5,%rdi
    a7a4:	48 03 3d 3d d7 24 00 	add    0x24d73d(%rip),%rdi        # 257ee8 <threads_table>
	threads_table[t_slot].thead_cnt = thread_create_count++;
    a7ab:	8d 50 01             	lea    0x1(%rax),%edx
    a7ae:	89 15 bc 18 25 00    	mov    %edx,0x2518bc(%rip)        # 25c070 <thread_create_count>
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    a7b4:	48 8d 15 30 fe ff ff 	lea    -0x1d0(%rip),%rdx        # a5eb <posix_thread_starter>
	threads_table[t_slot].t_status = ptr;
    a7bb:	48 89 5f 18          	mov    %rbx,0x18(%rdi)
	threads_table[t_slot].state = USED;
    a7bf:	c7 07 01 00 00 00    	movl   $0x1,(%rdi)
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    a7c5:	48 83 c7 08          	add    $0x8,%rdi
	threads_table[t_slot].running = false;
    a7c9:	c6 47 fc 00          	movb   $0x0,-0x4(%rdi)
	threads_table[t_slot].thead_cnt = thread_create_count++;
    a7cd:	89 47 08             	mov    %eax,0x8(%rdi)
	ptr->thread_idx = t_slot;
    a7d0:	44 89 43 20          	mov    %r8d,0x20(%rbx)
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    a7d4:	e8 97 9c ff ff       	callq  4470 <pthread_create@plt>
		__func__,
		threads_table[t_slot].thead_cnt,
		t_slot,
		threads_table[t_slot].thread);

}
    a7d9:	5b                   	pop    %rbx
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    a7da:	48 8d 35 82 6d 02 00 	lea    0x26d82(%rip),%rsi        # 31563 <__func__.5785+0x8fb>
    a7e1:	89 c7                	mov    %eax,%edi
    a7e3:	e9 04 fd ff ff       	jmpq   a4ec <pc_safe_call>

000000000000a7e8 <posix_init_multithreading>:
/**
 * Called from zephyr_wrapper()
 * prepare whatever needs to be prepared to be able to start threads
 */
void posix_init_multithreading(void)
{
    a7e8:	48 83 ec 08          	sub    $0x8,%rsp
	thread_create_count = 0;

	currently_allowed_thread = -1;

	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
    a7ec:	be 20 00 00 00       	mov    $0x20,%esi
    a7f1:	bf 40 00 00 00       	mov    $0x40,%edi
	thread_create_count = 0;
    a7f6:	c7 05 70 18 25 00 00 	movl   $0x0,0x251870(%rip)        # 25c070 <thread_create_count>
    a7fd:	00 00 00 
	currently_allowed_thread = -1;
    a800:	c7 05 62 18 25 00 ff 	movl   $0xffffffff,0x251862(%rip)        # 25c06c <currently_allowed_thread>
    a807:	ff ff ff 
	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
    a80a:	e8 a1 9c ff ff       	callq  44b0 <calloc@plt>
				sizeof(struct threads_table_el));
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
    a80f:	48 85 c0             	test   %rax,%rax
	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
    a812:	48 89 05 cf d6 24 00 	mov    %rax,0x24d6cf(%rip)        # 257ee8 <threads_table>
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
    a819:	75 0c                	jne    a827 <posix_init_multithreading+0x3f>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
    a81b:	48 8d 3d 19 6d 02 00 	lea    0x26d19(%rip),%rdi        # 3153b <__func__.5785+0x8d3>
    a822:	e8 9b 1a 00 00       	callq  c2c2 <posix_print_error_and_exit>
	}

	threads_table_size = PC_ALLOC_CHUNK_SIZE;


	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    a827:	48 8d 3d 52 c1 24 00 	lea    0x24c152(%rip),%rdi        # 256980 <mtx_threads>
	threads_table_size = PC_ALLOC_CHUNK_SIZE;
    a82e:	c7 05 3c 18 25 00 40 	movl   $0x40,0x25183c(%rip)        # 25c074 <threads_table_size>
    a835:	00 00 00 
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    a838:	e8 c3 9e ff ff       	callq  4700 <pthread_mutex_lock@plt>
    a83d:	89 c7                	mov    %eax,%edi
    a83f:	48 8d 35 ae 6c 02 00 	lea    0x26cae(%rip),%rsi        # 314f4 <__func__.5785+0x88c>
}
    a846:	58                   	pop    %rax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    a847:	e9 a0 fc ff ff       	jmpq   a4ec <pc_safe_call>

000000000000a84c <posix_core_clean_up>:
 *
 */
void posix_core_clean_up(void)
{

	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
    a84c:	48 83 3d 94 d6 24 00 	cmpq   $0x0,0x24d694(%rip)        # 257ee8 <threads_table>
    a853:	00 
    a854:	74 65                	je     a8bb <posix_core_clean_up+0x6f>
{
    a856:	55                   	push   %rbp
    a857:	53                   	push   %rbx
			continue;
		}

		/* LCOV_EXCL_START */
		if (pthread_cancel(threads_table[i].thread)) {
			posix_print_warning(
    a858:	48 8d 2d 68 6d 02 00 	lea    0x26d68(%rip),%rbp        # 315c7 <__func__.5785+0x95f>
	for (int i = 0; i < threads_table_size; i++) {
    a85f:	31 db                	xor    %ebx,%ebx
{
    a861:	48 83 ec 08          	sub    $0x8,%rsp
	terminate = true;
    a865:	c6 05 78 48 25 00 01 	movb   $0x1,0x254878(%rip)        # 25f0e4 <terminate>
	for (int i = 0; i < threads_table_size; i++) {
    a86c:	39 1d 02 18 25 00    	cmp    %ebx,0x251802(%rip)        # 25c074 <threads_table_size>
    a872:	48 8b 3d 6f d6 24 00 	mov    0x24d66f(%rip),%rdi        # 257ee8 <threads_table>
    a879:	7e 2c                	jle    a8a7 <posix_core_clean_up+0x5b>
		if (threads_table[i].state != USED) {
    a87b:	48 63 c3             	movslq %ebx,%rax
    a87e:	48 c1 e0 05          	shl    $0x5,%rax
    a882:	48 01 c7             	add    %rax,%rdi
    a885:	83 3f 01             	cmpl   $0x1,(%rdi)
    a888:	75 19                	jne    a8a3 <posix_core_clean_up+0x57>
		if (pthread_cancel(threads_table[i].thread)) {
    a88a:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
    a88e:	e8 ed 9a ff ff       	callq  4380 <pthread_cancel@plt>
    a893:	85 c0                	test   %eax,%eax
    a895:	74 0c                	je     a8a3 <posix_core_clean_up+0x57>
			posix_print_warning(
    a897:	89 de                	mov    %ebx,%esi
    a899:	48 89 ef             	mov    %rbp,%rdi
    a89c:	31 c0                	xor    %eax,%eax
    a89e:	e8 f1 1a 00 00       	callq  c394 <posix_print_warning>
	for (int i = 0; i < threads_table_size; i++) {
    a8a3:	ff c3                	inc    %ebx
    a8a5:	eb c5                	jmp    a86c <posix_core_clean_up+0x20>
				i);
		}
		/* LCOV_EXCL_STOP */
	}

	free(threads_table);
    a8a7:	e8 b4 9d ff ff       	callq  4660 <free@plt>
	threads_table = NULL;
    a8ac:	48 c7 05 31 d6 24 00 	movq   $0x0,0x24d631(%rip)        # 257ee8 <threads_table>
    a8b3:	00 00 00 00 
}
    a8b7:	58                   	pop    %rax
    a8b8:	5b                   	pop    %rbx
    a8b9:	5d                   	pop    %rbp
    a8ba:	c3                   	retq   
    a8bb:	c3                   	retq   

000000000000a8bc <posix_abort_thread>:


void posix_abort_thread(int thread_idx)
{
	if (threads_table[thread_idx].state != USED) { /* LCOV_EXCL_BR_LINE */
    a8bc:	48 63 ff             	movslq %edi,%rdi
    a8bf:	48 c1 e7 05          	shl    $0x5,%rdi
    a8c3:	48 03 3d 1e d6 24 00 	add    0x24d61e(%rip),%rdi        # 257ee8 <threads_table>
    a8ca:	83 3f 01             	cmpl   $0x1,(%rdi)
    a8cd:	75 06                	jne    a8d5 <posix_abort_thread+0x19>

	PC_DEBUG("Aborting not scheduled thread [%i] %i\n",
		threads_table[thread_idx].thead_cnt,
		thread_idx);

	threads_table[thread_idx].state = ABORTING;
    a8cf:	c7 07 02 00 00 00    	movl   $0x2,(%rdi)
	 * mutex or awakes on the condition.
	 * Note that even if we would pthread_cancel() the thread here, that
	 * would be the case, but with a pthread_cancel() the mutex state would
	 * be uncontrolled
	 */
}
    a8d5:	c3                   	retq   

000000000000a8d6 <z_impl_k_thread_abort>:


#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
    a8d6:	41 56                	push   %r14
    a8d8:	41 55                	push   %r13
    a8da:	49 89 fd             	mov    %rdi,%r13
    a8dd:	41 54                	push   %r12
    a8df:	55                   	push   %rbp
    a8e0:	53                   	push   %rbx
	unsigned int key;
	int thread_idx;

	posix_thread_status_t *tstatus =
    a8e1:	48 8b 6f 60          	mov    0x60(%rdi),%rbp
					(posix_thread_status_t *)
					thread->callee_saved.thread_status;

	thread_idx = tstatus->thread_idx;
    a8e5:	48 63 5d 20          	movslq 0x20(%rbp),%rbx
	return posix_irq_lock();
    a8e9:	e8 a4 16 00 00       	callq  bf92 <posix_irq_lock>

	key = irq_lock();

	if (_current == thread) {
    a8ee:	4c 8d 25 4b d2 24 00 	lea    0x24d24b(%rip),%r12        # 257b40 <_kernel>
    a8f5:	4d 39 6c 24 10       	cmp    %r13,0x10(%r12)
    a8fa:	75 4c                	jne    a948 <z_impl_k_thread_abort+0x72>
		if (tstatus->aborted == 0) { /* LCOV_EXCL_BR_LINE */
    a8fc:	83 7d 24 00          	cmpl   $0x0,0x24(%rbp)
    a900:	75 09                	jne    a90b <z_impl_k_thread_abort+0x35>
			tstatus->aborted = 1;
    a902:	c7 45 24 01 00 00 00 	movl   $0x1,0x24(%rbp)
    a909:	eb 10                	jmp    a91b <z_impl_k_thread_abort+0x45>
		} else {
			posix_print_warning(/* LCOV_EXCL_LINE */
    a90b:	48 8d 3d e9 6c 02 00 	lea    0x26ce9(%rip),%rdi        # 315fb <__func__.5785+0x993>
    a912:	89 de                	mov    %ebx,%esi
    a914:	31 c0                	xor    %eax,%eax
    a916:	e8 79 1a 00 00       	callq  c394 <posix_print_warning>
				PREFIX"The kernel is trying to abort and swap "
				"out of an already aborted thread %i. This "
				"should NOT have happened\n",
				thread_idx);
		}
		threads_table[thread_idx].state = ABORTING;
    a91b:	48 c1 e3 05          	shl    $0x5,%rbx
    a91f:	48 03 1d c2 d5 24 00 	add    0x24d5c2(%rip),%rbx        # 257ee8 <threads_table>
			"as aborting\n",
			threads_table[thread_idx].thead_cnt,
			thread_idx,
			__func__);

		if (arch_is_in_isr()) {
    a926:	41 83 3c 24 00       	cmpl   $0x0,(%r12)
		threads_table[thread_idx].state = ABORTING;
    a92b:	c7 03 02 00 00 00    	movl   $0x2,(%rbx)
		if (arch_is_in_isr()) {
    a931:	74 10                	je     a943 <z_impl_k_thread_abort+0x6d>
			thread_idx);
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
}
    a933:	5b                   	pop    %rbx
			z_thread_single_abort(thread);
    a934:	4c 89 ef             	mov    %r13,%rdi
}
    a937:	5d                   	pop    %rbp
    a938:	41 5c                	pop    %r12
    a93a:	41 5d                	pop    %r13
    a93c:	41 5e                	pop    %r14
			z_thread_single_abort(thread);
    a93e:	e9 6f 10 02 00       	jmpq   2b9b2 <z_thread_single_abort>
		z_self_abort();
    a943:	e8 cf 18 02 00       	callq  2c217 <z_self_abort>
	z_thread_single_abort(thread);
    a948:	4c 89 ef             	mov    %r13,%rdi
    a94b:	41 89 c6             	mov    %eax,%r14d
    a94e:	e8 5f 10 02 00       	callq  2b9b2 <z_thread_single_abort>
	if (tstatus->aborted == 0) {
    a953:	83 7d 24 00          	cmpl   $0x0,0x24(%rbp)
    a957:	75 0e                	jne    a967 <z_impl_k_thread_abort+0x91>
		tstatus->aborted = 1;
    a959:	c7 45 24 01 00 00 00 	movl   $0x1,0x24(%rbp)
		posix_abort_thread(thread_idx);
    a960:	89 df                	mov    %ebx,%edi
    a962:	e8 55 ff ff ff       	callq  a8bc <posix_abort_thread>
}
    a967:	5b                   	pop    %rbx
	z_reschedule_irqlock(key);
    a968:	44 89 f7             	mov    %r14d,%edi
}
    a96b:	5d                   	pop    %rbp
    a96c:	41 5c                	pop    %r12
    a96e:	41 5d                	pop    %r13
    a970:	41 5e                	pop    %r14
	z_reschedule_irqlock(key);
    a972:	e9 1b 0c 02 00       	jmpq   2b592 <z_reschedule_irqlock>

000000000000a977 <arch_swap>:
#include "irq.h"
#include "kswap.h"
#include <power/power.h>

int arch_swap(unsigned int key)
{
    a977:	53                   	push   %rbx
	 * threads => those are all nicely kept by the native OS kernel
	 */
#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif
	_current->callee_saved.key = key;
    a978:	48 8d 1d c1 d1 24 00 	lea    0x24d1c1(%rip),%rbx        # 257b40 <_kernel>
    a97f:	48 8b 43 10          	mov    0x10(%rbx),%rax
	 * arch_thread_return_value_set()
	 */

	posix_thread_status_t *ready_thread_ptr =
		(posix_thread_status_t *)
		_kernel.ready_q.cache->callee_saved.thread_status;
    a983:	48 8b 53 40          	mov    0x40(%rbx),%rdx
	_current->callee_saved.key = key;
    a987:	89 78 58             	mov    %edi,0x58(%rax)
	posix_thread_status_t *ready_thread_ptr =
    a98a:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
	_current->callee_saved.retval = -EAGAIN;
    a98e:	c7 40 5c f5 ff ff ff 	movl   $0xfffffff5,0x5c(%rax)

	posix_thread_status_t *this_thread_ptr  =
    a995:	48 8b 40 60          	mov    0x60(%rax),%rax
		(posix_thread_status_t *)
		_current->callee_saved.thread_status;


	_current = _kernel.ready_q.cache;
    a999:	48 89 53 10          	mov    %rdx,0x10(%rbx)
	 * Here a "real" arch would load all processor registers for the thread
	 * to run. In this arch case, we just block this thread until allowed
	 * to run later, and signal to whomever is allowed to run to
	 * continue.
	 */
	posix_swap(ready_thread_ptr->thread_idx,
    a99d:	8b 79 20             	mov    0x20(%rcx),%edi
    a9a0:	8b 70 20             	mov    0x20(%rax),%esi
    a9a3:	e8 f8 fc ff ff       	callq  a6a0 <posix_swap>
		this_thread_ptr->thread_idx);

	/* When we continue, _kernel->current points back to this thread */

	irq_unlock(_current->callee_saved.key);
    a9a8:	48 8b 43 10          	mov    0x10(%rbx),%rax
	posix_irq_unlock(key);
    a9ac:	8b 78 58             	mov    0x58(%rax),%edi
    a9af:	e8 e8 15 00 00       	callq  bf9c <posix_irq_unlock>

	return _current->callee_saved.retval;
    a9b4:	48 8b 43 10          	mov    0x10(%rbx),%rax
}
    a9b8:	5b                   	pop    %rbx
	return _current->callee_saved.retval;
    a9b9:	8b 40 5c             	mov    0x5c(%rax),%eax
}
    a9bc:	c3                   	retq   

000000000000a9bd <arch_switch_to_main_thread>:
	ARG_UNUSED(stack_ptr);
	ARG_UNUSED(_main);

	posix_thread_status_t *ready_thread_ptr =
			(posix_thread_status_t *)
			_kernel.ready_q.cache->callee_saved.thread_status;
    a9bd:	48 8d 05 7c d1 24 00 	lea    0x24d17c(%rip),%rax        # 257b40 <_kernel>
    a9c4:	48 8b 50 40          	mov    0x40(%rax),%rdx
	posix_thread_status_t *ready_thread_ptr =
    a9c8:	48 8b 4a 60          	mov    0x60(%rdx),%rcx

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif

	_current = _kernel.ready_q.cache;
    a9cc:	48 89 50 10          	mov    %rdx,0x10(%rax)

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_in();
#endif

	posix_main_thread_start(ready_thread_ptr->thread_idx);
    a9d0:	8b 79 20             	mov    0x20(%rcx),%edi
    a9d3:	e9 0b fd ff ff       	jmpq   a6e3 <posix_main_thread_start>

000000000000a9d8 <arch_new_thread>:
	 * "initial stack frame"
	 */
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);

	/* z_thread_entry() arguments */
	thread_status->entry_point = entry;
    a9d8:	48 89 4a d8          	mov    %rcx,-0x28(%rdx)
	thread_status->arg1 = p1;
	thread_status->arg2 = p2;
	thread_status->arg3 = p3;
    a9dc:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);
    a9e1:	48 8d 42 d8          	lea    -0x28(%rdx),%rax
	thread_status->arg1 = p1;
    a9e5:	4c 89 42 e0          	mov    %r8,-0x20(%rdx)
	thread_status->arg2 = p2;
    a9e9:	4c 89 4a e8          	mov    %r9,-0x18(%rdx)
#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
	thread_status->aborted = 0;
    a9ed:	c7 42 fc 00 00 00 00 	movl   $0x0,-0x4(%rdx)
	thread_status->arg3 = p3;
    a9f4:	48 89 4a f0          	mov    %rcx,-0x10(%rdx)
#endif

	thread->callee_saved.thread_status = thread_status;
    a9f8:	48 89 47 60          	mov    %rax,0x60(%rdi)

	posix_new_thread(thread_status);
    a9fc:	48 89 c7             	mov    %rax,%rdi
    a9ff:	e9 0f fd ff ff       	jmpq   a713 <posix_new_thread>

000000000000aa04 <posix_new_thread_pre_start>:
}

void posix_new_thread_pre_start(void)
{
	posix_irq_full_unlock();
    aa04:	e9 98 15 00 00       	jmpq   bfa1 <posix_irq_full_unlock>

000000000000aa09 <lvgl_log>:
	 * * LOG_LEVEL_ERR 1
	 * * LOG_LEVEL_WRN 2
	 * * LOG_LEVEL_INF 3
	 * * LOG_LEVEL_DBG 4
	 */
	uint8_t zephyr_level = LOG_LEVEL_DBG - level;
    aa09:	40 b6 04             	mov    $0x4,%sil
    aa0c:	29 fe                	sub    %edi,%esi

	ARG_UNUSED(file);
	ARG_UNUSED(line);
	ARG_UNUSED(func);

	Z_LOG(zephyr_level, "%s", log_strdup(dsc));
    aa0e:	40 80 fe 03          	cmp    $0x3,%sil
    aa12:	77 5b                	ja     aa6f <lvgl_log+0x66>
    aa14:	48 8d 05 35 fa 22 00 	lea    0x22fa35(%rip),%rax        # 23a450 <log_const_lvgl>
    aa1b:	48 2b 05 2e b5 22 00 	sub    0x22b52e(%rip),%rax        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
    aa22:	4c 89 c7             	mov    %r8,%rdi
{
    aa25:	53                   	push   %rbx
	Z_LOG(zephyr_level, "%s", log_strdup(dsc));
    aa26:	89 f3                	mov    %esi,%ebx
    aa28:	83 e3 07             	and    $0x7,%ebx
    aa2b:	48 c1 e8 04          	shr    $0x4,%rax
    aa2f:	c1 e0 06             	shl    $0x6,%eax
    aa32:	09 c3                	or     %eax,%ebx
    aa34:	40 80 fe 04          	cmp    $0x4,%sil
    aa38:	75 1e                	jne    aa58 <lvgl_log+0x4f>
    aa3a:	e8 d1 c4 ff ff       	callq  6f10 <log_strdup>
    aa3f:	89 d9                	mov    %ebx,%ecx
    aa41:	48 8d 35 38 61 02 00 	lea    0x26138(%rip),%rsi        # 30b80 <__func__.9913>
    aa48:	48 8d 3d 28 6c 02 00 	lea    0x26c28(%rip),%rdi        # 31677 <__func__.5785+0xa0f>
}
    aa4f:	5b                   	pop    %rbx
	Z_LOG(zephyr_level, "%s", log_strdup(dsc));
    aa50:	48 89 c2             	mov    %rax,%rdx
    aa53:	e9 da c8 ff ff       	jmpq   7332 <log_2>
    aa58:	e8 b3 c4 ff ff       	callq  6f10 <log_strdup>
    aa5d:	89 da                	mov    %ebx,%edx
    aa5f:	48 8d 3d bd 66 02 00 	lea    0x266bd(%rip),%rdi        # 31123 <__func__.5785+0x4bb>
    aa66:	48 89 c6             	mov    %rax,%rsi
}
    aa69:	5b                   	pop    %rbx
	Z_LOG(zephyr_level, "%s", log_strdup(dsc));
    aa6a:	e9 86 c8 ff ff       	jmpq   72f5 <log_1>
    aa6f:	c3                   	retq   

000000000000aa70 <lvgl_pointer_kscan_read>:
		LOG_ERR("Could put input data into queue");
	}
}

static bool lvgl_pointer_kscan_read(lv_indev_drv_t *drv, lv_indev_data_t *data)
{
    aa70:	55                   	push   %rbp
    aa71:	53                   	push   %rbx
    aa72:	48 89 f5             	mov    %rsi,%rbp
    aa75:	48 83 ec 38          	sub    $0x38,%rsp
    aa79:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    aa80:	00 00 
    aa82:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    aa87:	31 c0                	xor    %eax,%eax
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&msgq, *(uintptr_t *)&data, *(uintptr_t *)&timeout, K_SYSCALL_K_MSGQ_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_get(msgq, data, timeout);
    aa89:	48 8d 1d d0 fb 22 00 	lea    0x22fbd0(%rip),%rbx        # 23a660 <_k_mutex_list_end>
    aa90:	48 8d 74 24 04       	lea    0x4(%rsp),%rsi
    aa95:	31 d2                	xor    %edx,%edx
    aa97:	48 89 df             	mov    %rbx,%rdi
    aa9a:	e8 4c 04 02 00       	callq  2aeeb <z_impl_k_msgq_get>
		.point.x = 0,
		.point.y = 0,
		.state = LV_INDEV_STATE_REL,
	};

	if (k_msgq_get(&kscan_msgq, &curr, K_NO_WAIT) != 0) {
    aa9f:	85 c0                	test   %eax,%eax
    aaa1:	0f 85 98 00 00 00    	jne    ab3f <lvgl_pointer_kscan_read+0xcf>
		goto set_and_release;
	}

	prev = curr;
    aaa7:	0f 10 44 24 04       	movups 0x4(%rsp),%xmm0
    aaac:	0f 29 05 3d d2 24 00 	movaps %xmm0,0x24d23d(%rip)        # 257cf0 <prev.9946>

	disp = lv_disp_get_default();
    aab3:	e8 86 a5 01 00       	callq  2503e <lv_disp_get_default>
					    capabilities)
{
	struct display_driver_api *api =
		(struct display_driver_api *)dev->api;

	api->get_capabilities(dev, capabilities);
    aab8:	48 8d 74 24 14       	lea    0x14(%rsp),%rsi
	disp_dev = disp->driver.user_data;
    aabd:	48 8b 78 58          	mov    0x58(%rax),%rdi
    aac1:	48 8b 47 10          	mov    0x10(%rdi),%rax
    aac5:	ff 50 38             	callq  *0x38(%rax)
			prev.point.y = cap.x_resolution - prev.point.y;
		}
	}

	/* rotate touch point to match display rotation */
	if (cap.current_orientation == DISPLAY_ORIENTATION_ROTATED_90) {
    aac8:	8b 44 24 24          	mov    0x24(%rsp),%eax
    aacc:	83 f8 01             	cmp    $0x1,%eax
    aacf:	75 1f                	jne    aaf0 <lvgl_pointer_kscan_read+0x80>
		lv_coord_t x;

		x = prev.point.x;
    aad1:	8b 05 19 d2 24 00    	mov    0x24d219(%rip),%eax        # 257cf0 <prev.9946>
		prev.point.x = prev.point.y;
		prev.point.y = cap.y_resolution - x;
    aad7:	66 8b 4c 24 16       	mov    0x16(%rsp),%cx
		prev.point.x = prev.point.y;
    aadc:	66 8b 15 0f d2 24 00 	mov    0x24d20f(%rip),%dx        # 257cf2 <prev.9946+0x2>
		prev.point.y = cap.y_resolution - x;
    aae3:	29 c1                	sub    %eax,%ecx
		prev.point.x = prev.point.y;
    aae5:	66 89 15 04 d2 24 00 	mov    %dx,0x24d204(%rip)        # 257cf0 <prev.9946>
		prev.point.y = cap.y_resolution - x;
    aaec:	89 c8                	mov    %ecx,%eax
    aaee:	eb 22                	jmp    ab12 <lvgl_pointer_kscan_read+0xa2>
	} else if (cap.current_orientation == DISPLAY_ORIENTATION_ROTATED_180) {
    aaf0:	83 f8 02             	cmp    $0x2,%eax
    aaf3:	75 26                	jne    ab1b <lvgl_pointer_kscan_read+0xab>
		prev.point.x = cap.x_resolution - prev.point.x;
    aaf5:	8b 44 24 14          	mov    0x14(%rsp),%eax
    aaf9:	2b 05 f1 d1 24 00    	sub    0x24d1f1(%rip),%eax        # 257cf0 <prev.9946>
    aaff:	66 89 05 ea d1 24 00 	mov    %ax,0x24d1ea(%rip)        # 257cf0 <prev.9946>
		prev.point.y = cap.y_resolution - prev.point.y;
    ab06:	66 8b 44 24 16       	mov    0x16(%rsp),%ax
    ab0b:	66 2b 05 e0 d1 24 00 	sub    0x24d1e0(%rip),%ax        # 257cf2 <prev.9946+0x2>
    ab12:	66 89 05 d9 d1 24 00 	mov    %ax,0x24d1d9(%rip)        # 257cf2 <prev.9946+0x2>
    ab19:	eb 24                	jmp    ab3f <lvgl_pointer_kscan_read+0xcf>
	} else if (cap.current_orientation == DISPLAY_ORIENTATION_ROTATED_270) {
    ab1b:	83 f8 03             	cmp    $0x3,%eax
    ab1e:	75 1f                	jne    ab3f <lvgl_pointer_kscan_read+0xcf>
		lv_coord_t x;

		x = prev.point.x;
		prev.point.x = cap.x_resolution - prev.point.y;
    ab20:	8b 44 24 14          	mov    0x14(%rsp),%eax
    ab24:	66 2b 05 c7 d1 24 00 	sub    0x24d1c7(%rip),%ax        # 257cf2 <prev.9946+0x2>
		x = prev.point.x;
    ab2b:	8b 15 bf d1 24 00    	mov    0x24d1bf(%rip),%edx        # 257cf0 <prev.9946>
		prev.point.x = cap.x_resolution - prev.point.y;
    ab31:	66 89 05 b8 d1 24 00 	mov    %ax,0x24d1b8(%rip)        # 257cf0 <prev.9946>
		prev.point.y = x;
    ab38:	66 89 15 b3 d1 24 00 	mov    %dx,0x24d1b3(%rip)        # 257cf2 <prev.9946+0x2>
	}

set_and_release:
	*data = prev;
    ab3f:	0f 28 0d aa d1 24 00 	movaps 0x24d1aa(%rip),%xmm1        # 257cf0 <prev.9946>
    ab46:	0f 11 4d 00          	movups %xmm1,0x0(%rbp)

	return k_msgq_num_used_get(&kscan_msgq) > 0;
    ab4a:	83 7b 40 00          	cmpl   $0x0,0x40(%rbx)
    ab4e:	0f 95 c0             	setne  %al
}
    ab51:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
    ab56:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    ab5d:	00 00 
    ab5f:	74 05                	je     ab66 <lvgl_pointer_kscan_read+0xf6>
    ab61:	e8 da 9a ff ff       	callq  4640 <__stack_chk_fail@plt>
    ab66:	48 83 c4 38          	add    $0x38,%rsp
    ab6a:	5b                   	pop    %rbx
    ab6b:	5d                   	pop    %rbp
    ab6c:	c3                   	retq   

000000000000ab6d <lvgl_pointer_kscan_callback>:
{
    ab6d:	48 83 ec 28          	sub    $0x28,%rsp
    ab71:	41 89 c8             	mov    %ecx,%r8d
	lv_indev_data_t data = {
    ab74:	b9 03 00 00 00       	mov    $0x3,%ecx
{
    ab79:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    ab80:	00 00 
    ab82:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    ab87:	31 c0                	xor    %eax,%eax
	lv_indev_data_t data = {
    ab89:	48 8d 7c 24 0c       	lea    0xc(%rsp),%rdi
    ab8e:	66 89 54 24 08       	mov    %dx,0x8(%rsp)
    ab93:	66 89 74 24 0a       	mov    %si,0xa(%rsp)
    ab98:	f3 ab                	rep stos %eax,%es:(%rdi)
    ab9a:	44 88 44 24 16       	mov    %r8b,0x16(%rsp)
	return z_impl_k_msgq_put(msgq, data, timeout);
    ab9f:	48 8d 3d ba fa 22 00 	lea    0x22faba(%rip),%rdi        # 23a660 <_k_mutex_list_end>
    aba6:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    abab:	31 d2                	xor    %edx,%edx
    abad:	e8 5b 02 02 00       	callq  2ae0d <z_impl_k_msgq_put>
	if (k_msgq_put(&kscan_msgq, &data, K_NO_WAIT) != 0) {
    abb2:	85 c0                	test   %eax,%eax
    abb4:	74 24                	je     abda <lvgl_pointer_kscan_callback+0x6d>
    abb6:	48 8d 35 93 f8 22 00 	lea    0x22f893(%rip),%rsi        # 23a450 <log_const_lvgl>
    abbd:	48 2b 35 8c b3 22 00 	sub    0x22b38c(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		LOG_ERR("Could put input data into queue");
    abc4:	48 8d 3d b3 6a 02 00 	lea    0x26ab3(%rip),%rdi        # 3167e <__func__.5785+0xa16>
    abcb:	48 c1 ee 04          	shr    $0x4,%rsi
    abcf:	c1 e6 06             	shl    $0x6,%esi
    abd2:	83 ce 01             	or     $0x1,%esi
    abd5:	e8 ea c6 ff ff       	callq  72c4 <log_0>
}
    abda:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    abdf:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    abe6:	00 00 
    abe8:	74 05                	je     abef <lvgl_pointer_kscan_callback+0x82>
    abea:	e8 51 9a ff ff       	callq  4640 <__stack_chk_fail@plt>
    abef:	48 83 c4 28          	add    $0x28,%rsp
    abf3:	c3                   	retq   

000000000000abf4 <lvgl_init>:
	return 0;
}
#endif /* CONFIG_LVGL_POINTER_KSCAN */

static int lvgl_init(const struct device *dev)
{
    abf4:	41 54                	push   %r12
    abf6:	55                   	push   %rbp
    abf7:	53                   	push   %rbx
    abf8:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
    abff:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    ac06:	00 00 
    ac08:	48 89 84 24 98 00 00 	mov    %rax,0x98(%rsp)
    ac0f:	00 
    ac10:	31 c0                	xor    %eax,%eax
    ac12:	48 8d 3d f0 64 02 00 	lea    0x264f0(%rip),%rdi        # 31109 <__func__.5785+0x4a1>
    ac19:	e8 2e fc 01 00       	callq  2a84c <z_impl_device_get_binding>
	const struct device *display_dev =
		device_get_binding(CONFIG_LVGL_DISPLAY_DEV_NAME);
	int err = 0;
	lv_disp_drv_t disp_drv;

	if (display_dev == NULL) {
    ac1e:	48 85 c0             	test   %rax,%rax
    ac21:	75 2e                	jne    ac51 <lvgl_init+0x5d>
    ac23:	48 8d 35 26 f8 22 00 	lea    0x22f826(%rip),%rsi        # 23a450 <log_const_lvgl>
    ac2a:	48 2b 35 1f b3 22 00 	sub    0x22b31f(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		LOG_ERR("Display device not found.");
    ac31:	48 8d 3d 66 6a 02 00 	lea    0x26a66(%rip),%rdi        # 3169e <__func__.5785+0xa36>
		return -ENODEV;
    ac38:	bb ed ff ff ff       	mov    $0xffffffed,%ebx
    ac3d:	48 c1 ee 04          	shr    $0x4,%rsi
		LOG_ERR("Display device not found.");
    ac41:	c1 e6 06             	shl    $0x6,%esi
    ac44:	83 ce 01             	or     $0x1,%esi
    ac47:	e8 78 c6 ff ff       	callq  72c4 <log_0>
		return -ENODEV;
    ac4c:	e9 13 02 00 00       	jmpq   ae64 <lvgl_init+0x270>
	}

#if CONFIG_LVGL_LOG_LEVEL != 0
	lv_log_register_print_cb(lvgl_log);
    ac51:	48 8d 3d b1 fd ff ff 	lea    -0x24f(%rip),%rdi        # aa09 <lvgl_log>

#ifdef CONFIG_LVGL_USE_FILESYSTEM
	lvgl_fs_init();
#endif

	lv_disp_drv_init(&disp_drv);
    ac58:	4c 8d 64 24 38       	lea    0x38(%rsp),%r12
    ac5d:	48 89 c3             	mov    %rax,%rbx
    ac60:	48 89 e5             	mov    %rsp,%rbp
	lv_log_register_print_cb(lvgl_log);
    ac63:	e8 e6 b2 01 00       	callq  25f4e <lv_log_register_print_cb>
	lv_init();
    ac68:	e8 20 f9 00 00       	callq  1a58d <lv_init>
	lv_disp_drv_init(&disp_drv);
    ac6d:	4c 89 e7             	mov    %r12,%rdi
    ac70:	e8 5f a3 01 00       	callq  24fd4 <lv_disp_drv_init>
    ac75:	48 8b 43 10          	mov    0x10(%rbx),%rax
	disp_drv.user_data = (void *) display_dev;
    ac79:	48 89 9c 24 90 00 00 	mov    %rbx,0x90(%rsp)
    ac80:	00 
    ac81:	48 89 ee             	mov    %rbp,%rsi
    ac84:	48 89 df             	mov    %rbx,%rdi
    ac87:	ff 50 38             	callq  *0x38(%rax)
	if (cap.x_resolution <= CONFIG_LVGL_HOR_RES_MAX) {
    ac8a:	8b 04 24             	mov    (%rsp),%eax
    ac8d:	66 3d e0 01          	cmp    $0x1e0,%ax
    ac91:	77 09                	ja     ac9c <lvgl_init+0xa8>
		disp_drv->hor_res = cap.x_resolution;
    ac93:	66 89 44 24 38       	mov    %ax,0x38(%rsp)
	int err = 0;
    ac98:	31 db                	xor    %ebx,%ebx
    ac9a:	eb 29                	jmp    acc5 <lvgl_init+0xd1>
    ac9c:	48 8d 35 ad f7 22 00 	lea    0x22f7ad(%rip),%rsi        # 23a450 <log_const_lvgl>
    aca3:	48 2b 35 a6 b2 22 00 	sub    0x22b2a6(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		LOG_ERR("Horizontal resolution is larger than maximum");
    acaa:	48 8d 3d 07 6a 02 00 	lea    0x26a07(%rip),%rdi        # 316b8 <__func__.5785+0xa50>
		err = -ENOTSUP;
    acb1:	bb a1 ff ff ff       	mov    $0xffffffa1,%ebx
    acb6:	48 c1 ee 04          	shr    $0x4,%rsi
		LOG_ERR("Horizontal resolution is larger than maximum");
    acba:	c1 e6 06             	shl    $0x6,%esi
    acbd:	83 ce 01             	or     $0x1,%esi
    acc0:	e8 ff c5 ff ff       	callq  72c4 <log_0>
	if (cap.y_resolution <= CONFIG_LVGL_VER_RES_MAX) {
    acc5:	66 8b 44 24 02       	mov    0x2(%rsp),%ax
    acca:	66 3d 40 01          	cmp    $0x140,%ax
    acce:	77 07                	ja     acd7 <lvgl_init+0xe3>
		disp_drv->ver_res = cap.y_resolution;
    acd0:	66 89 44 24 3a       	mov    %ax,0x3a(%rsp)
    acd5:	eb 29                	jmp    ad00 <lvgl_init+0x10c>
    acd7:	48 8d 35 72 f7 22 00 	lea    0x22f772(%rip),%rsi        # 23a450 <log_const_lvgl>
    acde:	48 2b 35 6b b2 22 00 	sub    0x22b26b(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		LOG_ERR("Vertical resolution is larger than maximum");
    ace5:	48 8d 3d f9 69 02 00 	lea    0x269f9(%rip),%rdi        # 316e5 <__func__.5785+0xa7d>
		err = -ENOTSUP;
    acec:	bb a1 ff ff ff       	mov    $0xffffffa1,%ebx
    acf1:	48 c1 ee 04          	shr    $0x4,%rsi
		LOG_ERR("Vertical resolution is larger than maximum");
    acf5:	c1 e6 06             	shl    $0x6,%esi
    acf8:	83 ce 01             	or     $0x1,%esi
    acfb:	e8 c4 c5 ff ff       	callq  72c4 <log_0>
	disp_drv->buffer = &disp_buf;
    ad00:	48 8d 3d f9 bc 24 00 	lea    0x24bcf9(%rip),%rdi        # 256a00 <disp_buf>
	lv_disp_buf_init(disp_drv->buffer, &buf0, NULL, NBR_PIXELS_IN_BUFFER);
    ad07:	48 8d 35 6a 13 25 00 	lea    0x25136a(%rip),%rsi        # 25c078 <buf0>
    ad0e:	31 d2                	xor    %edx,%edx
    ad10:	b9 00 0c 00 00       	mov    $0xc00,%ecx
	disp_drv->buffer = &disp_buf;
    ad15:	48 89 7c 24 40       	mov    %rdi,0x40(%rsp)
	lv_disp_buf_init(disp_drv->buffer, &buf0, NULL, NBR_PIXELS_IN_BUFFER);
    ad1a:	e8 f9 a2 01 00       	callq  25018 <lv_disp_buf_init>

	err = lvgl_allocate_rendering_buffers(&disp_drv);
	if (err != 0) {
    ad1f:	85 db                	test   %ebx,%ebx
    ad21:	0f 85 3d 01 00 00    	jne    ae64 <lvgl_init+0x270>
		return err;
	}

	if (set_lvgl_rendering_cb(&disp_drv) != 0) {
    ad27:	4c 89 e7             	mov    %r12,%rdi
    ad2a:	e8 5b 01 00 00       	callq  ae8a <set_lvgl_rendering_cb>
    ad2f:	85 c0                	test   %eax,%eax
    ad31:	89 c3                	mov    %eax,%ebx
    ad33:	74 2e                	je     ad63 <lvgl_init+0x16f>
    ad35:	48 8d 35 14 f7 22 00 	lea    0x22f714(%rip),%rsi        # 23a450 <log_const_lvgl>
    ad3c:	48 2b 35 0d b2 22 00 	sub    0x22b20d(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		LOG_ERR("Display not supported.");
    ad43:	48 8d 3d c6 69 02 00 	lea    0x269c6(%rip),%rdi        # 31710 <__func__.5785+0xaa8>
		return -ENOTSUP;
    ad4a:	bb a1 ff ff ff       	mov    $0xffffffa1,%ebx
    ad4f:	48 c1 ee 04          	shr    $0x4,%rsi
		LOG_ERR("Display not supported.");
    ad53:	c1 e6 06             	shl    $0x6,%esi
    ad56:	83 ce 01             	or     $0x1,%esi
    ad59:	e8 66 c5 ff ff       	callq  72c4 <log_0>
		return -ENOTSUP;
    ad5e:	e9 01 01 00 00       	jmpq   ae64 <lvgl_init+0x270>
	}

	if (lv_disp_drv_register(&disp_drv) == NULL) {
    ad63:	4c 89 e7             	mov    %r12,%rdi
    ad66:	e8 17 a4 01 00       	callq  25182 <lv_disp_drv_register>
    ad6b:	48 85 c0             	test   %rax,%rax
    ad6e:	75 2c                	jne    ad9c <lvgl_init+0x1a8>
    ad70:	48 8d 35 d9 f6 22 00 	lea    0x22f6d9(%rip),%rsi        # 23a450 <log_const_lvgl>
    ad77:	48 2b 35 d2 b1 22 00 	sub    0x22b1d2(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		LOG_ERR("Failed to register display device.");
    ad7e:	48 8d 3d a2 69 02 00 	lea    0x269a2(%rip),%rdi        # 31727 <__func__.5785+0xabf>
		return -EPERM;
    ad85:	83 cb ff             	or     $0xffffffff,%ebx
    ad88:	48 c1 ee 04          	shr    $0x4,%rsi
		LOG_ERR("Failed to register display device.");
    ad8c:	c1 e6 06             	shl    $0x6,%esi
    ad8f:	83 ce 01             	or     $0x1,%esi
    ad92:	e8 2d c5 ff ff       	callq  72c4 <log_0>
		return -EPERM;
    ad97:	e9 c8 00 00 00       	jmpq   ae64 <lvgl_init+0x270>
    ad9c:	48 8d 3d a7 69 02 00 	lea    0x269a7(%rip),%rdi        # 3174a <__func__.5785+0xae2>
    ada3:	e8 a4 fa 01 00       	callq  2a84c <z_impl_device_get_binding>
	if (kscan_dev == NULL) {
    ada8:	48 85 c0             	test   %rax,%rax
    adab:	49 89 c4             	mov    %rax,%r12
    adae:	75 21                	jne    add1 <lvgl_init+0x1dd>
    adb0:	48 8d 35 99 f6 22 00 	lea    0x22f699(%rip),%rsi        # 23a450 <log_const_lvgl>
    adb7:	48 2b 35 92 b1 22 00 	sub    0x22b192(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		LOG_ERR("Keyboard scan device not found.");
    adbe:	48 8d 3d 8b 69 02 00 	lea    0x2698b(%rip),%rdi        # 31750 <__func__.5785+0xae8>
    adc5:	48 c1 ee 04          	shr    $0x4,%rsi
    adc9:	c1 e6 06             	shl    $0x6,%esi
    adcc:	83 ce 01             	or     $0x1,%esi
    adcf:	eb 33                	jmp    ae04 <lvgl_init+0x210>
					kscan_callback_t callback)
{
	const struct kscan_driver_api *api =
				(struct kscan_driver_api *)dev->api;

	return api->config(dev, callback);
    add1:	48 8b 40 10          	mov    0x10(%rax),%rax
    add5:	48 8d 35 91 fd ff ff 	lea    -0x26f(%rip),%rsi        # ab6d <lvgl_pointer_kscan_callback>
    addc:	4c 89 e7             	mov    %r12,%rdi
    addf:	ff 10                	callq  *(%rax)
	if (kscan_config(kscan_dev, lvgl_pointer_kscan_callback) < 0) {
    ade1:	85 c0                	test   %eax,%eax
    ade3:	79 26                	jns    ae0b <lvgl_init+0x217>
    ade5:	48 8d 35 64 f6 22 00 	lea    0x22f664(%rip),%rsi        # 23a450 <log_const_lvgl>
    adec:	48 2b 35 5d b1 22 00 	sub    0x22b15d(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		LOG_ERR("Could not configure keyboard scan device.");
    adf3:	48 8d 3d 76 69 02 00 	lea    0x26976(%rip),%rdi        # 31770 <__func__.5785+0xb08>
    adfa:	48 c1 ee 04          	shr    $0x4,%rsi
    adfe:	c1 e6 06             	shl    $0x6,%esi
    ae01:	83 ce 01             	or     $0x1,%esi
    ae04:	e8 bb c4 ff ff       	callq  72c4 <log_0>
    ae09:	eb 59                	jmp    ae64 <lvgl_init+0x270>
	lv_indev_drv_init(&indev_drv);
    ae0b:	48 89 ef             	mov    %rbp,%rdi
    ae0e:	e8 04 a5 01 00       	callq  25317 <lv_indev_drv_init>
	indev_drv.read_cb = lvgl_pointer_kscan_read;
    ae13:	48 8d 05 56 fc ff ff 	lea    -0x3aa(%rip),%rax        # aa70 <lvgl_pointer_kscan_read>
	if (lv_indev_drv_register(&indev_drv) == NULL) {
    ae1a:	48 89 ef             	mov    %rbp,%rdi
	indev_drv.type = LV_INDEV_TYPE_POINTER;
    ae1d:	c6 04 24 01          	movb   $0x1,(%rsp)
	indev_drv.read_cb = lvgl_pointer_kscan_read;
    ae21:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
	if (lv_indev_drv_register(&indev_drv) == NULL) {
    ae26:	e8 07 a5 01 00       	callq  25332 <lv_indev_drv_register>
    ae2b:	48 85 c0             	test   %rax,%rax
    ae2e:	75 21                	jne    ae51 <lvgl_init+0x25d>
    ae30:	48 8d 35 19 f6 22 00 	lea    0x22f619(%rip),%rsi        # 23a450 <log_const_lvgl>
    ae37:	48 2b 35 12 b1 22 00 	sub    0x22b112(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		LOG_ERR("Failed to register input device.");
    ae3e:	48 8d 3d 55 69 02 00 	lea    0x26955(%rip),%rdi        # 3179a <__func__.5785+0xb32>
    ae45:	48 c1 ee 04          	shr    $0x4,%rsi
    ae49:	c1 e6 06             	shl    $0x6,%esi
    ae4c:	83 ce 01             	or     $0x1,%esi
    ae4f:	eb b3                	jmp    ae04 <lvgl_init+0x210>
static inline int z_impl_kscan_enable_callback(const struct device *dev)
{
	const struct kscan_driver_api *api =
			(const struct kscan_driver_api *)dev->api;

	if (api->enable_callback == NULL) {
    ae51:	49 8b 44 24 10       	mov    0x10(%r12),%rax
    ae56:	48 8b 40 10          	mov    0x10(%rax),%rax
    ae5a:	48 85 c0             	test   %rax,%rax
    ae5d:	74 05                	je     ae64 <lvgl_init+0x270>
		return -ENOTSUP;
	}

	return api->enable_callback(dev);
    ae5f:	4c 89 e7             	mov    %r12,%rdi
    ae62:	ff d0                	callq  *%rax
#ifdef CONFIG_LVGL_POINTER_KSCAN
	lvgl_pointer_kscan_init();
#endif /* CONFIG_LVGL_POINTER_KSCAN */

	return 0;
}
    ae64:	48 8b 94 24 98 00 00 	mov    0x98(%rsp),%rdx
    ae6b:	00 
    ae6c:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
    ae73:	00 00 
    ae75:	89 d8                	mov    %ebx,%eax
    ae77:	74 05                	je     ae7e <lvgl_init+0x28a>
    ae79:	e8 c2 97 ff ff       	callq  4640 <__stack_chk_fail@plt>
    ae7e:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
    ae85:	5b                   	pop    %rbx
    ae86:	5d                   	pop    %rbp
    ae87:	41 5c                	pop    %r12
    ae89:	c3                   	retq   

000000000000ae8a <set_lvgl_rendering_cb>:
 */

#include "lvgl_display.h"

int set_lvgl_rendering_cb(lv_disp_drv_t *disp_drv)
{
    ae8a:	53                   	push   %rbx
    ae8b:	48 89 fb             	mov    %rdi,%rbx
    ae8e:	48 83 ec 20          	sub    $0x20,%rsp
	int err = 0;
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
    ae92:	48 8b 7f 58          	mov    0x58(%rdi),%rdi
{
    ae96:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    ae9d:	00 00 
    ae9f:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    aea4:	31 c0                	xor    %eax,%eax
    aea6:	48 8d 74 24 04       	lea    0x4(%rsp),%rsi
    aeab:	48 8b 47 10          	mov    0x10(%rdi),%rax
    aeaf:	ff 50 38             	callq  *0x38(%rax)
	struct display_capabilities cap;

	display_get_capabilities(display_dev, &cap);

	switch (cap.current_pixel_format) {
    aeb2:	8b 44 24 10          	mov    0x10(%rsp),%eax
    aeb6:	83 f8 04             	cmp    $0x4,%eax
    aeb9:	74 75                	je     af30 <set_lvgl_rendering_cb+0xa6>
    aebb:	77 0f                	ja     aecc <set_lvgl_rendering_cb+0x42>
    aebd:	83 f8 01             	cmp    $0x1,%eax
    aec0:	74 36                	je     aef8 <set_lvgl_rendering_cb+0x6e>
    aec2:	83 f8 02             	cmp    $0x2,%eax
    aec5:	74 69                	je     af30 <set_lvgl_rendering_cb+0xa6>
    aec7:	e9 89 00 00 00       	jmpq   af55 <set_lvgl_rendering_cb+0xcb>
    aecc:	83 f8 10             	cmp    $0x10,%eax
    aecf:	74 43                	je     af14 <set_lvgl_rendering_cb+0x8a>
    aed1:	83 f8 20             	cmp    $0x20,%eax
    aed4:	74 3e                	je     af14 <set_lvgl_rendering_cb+0x8a>
    aed6:	83 f8 08             	cmp    $0x8,%eax
    aed9:	75 7a                	jne    af55 <set_lvgl_rendering_cb+0xcb>
	case PIXEL_FORMAT_ARGB_8888:
		disp_drv->flush_cb = lvgl_flush_cb_32bit;
    aedb:	48 8d 05 1b 05 00 00 	lea    0x51b(%rip),%rax        # b3fd <lvgl_flush_cb_32bit>
		disp_drv->rounder_cb = NULL;
    aee2:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
    aee9:	00 
#ifdef CONFIG_LVGL_COLOR_DEPTH_32
		disp_drv->set_px_cb = NULL;
    aeea:	48 c7 43 28 00 00 00 	movq   $0x0,0x28(%rbx)
    aef1:	00 
		disp_drv->flush_cb = lvgl_flush_cb_32bit;
    aef2:	48 89 43 18          	mov    %rax,0x18(%rbx)
    aef6:	eb 59                	jmp    af51 <set_lvgl_rendering_cb+0xc7>
#else
		disp_drv->set_px_cb = lvgl_set_px_cb_32bit;
#endif
		break;
	case PIXEL_FORMAT_RGB_888:
		disp_drv->flush_cb = lvgl_flush_cb_24bit;
    aef8:	48 8d 05 9e 03 00 00 	lea    0x39e(%rip),%rax        # b29d <lvgl_flush_cb_24bit>
		disp_drv->rounder_cb = NULL;
    aeff:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
    af06:	00 
		disp_drv->flush_cb = lvgl_flush_cb_24bit;
    af07:	48 89 43 18          	mov    %rax,0x18(%rbx)
		disp_drv->set_px_cb = lvgl_set_px_cb_24bit;
    af0b:	48 8d 05 1f 04 00 00 	lea    0x41f(%rip),%rax        # b331 <lvgl_set_px_cb_24bit>
    af12:	eb 39                	jmp    af4d <set_lvgl_rendering_cb+0xc3>
		break;
	case PIXEL_FORMAT_RGB_565:
	case PIXEL_FORMAT_BGR_565:
		disp_drv->flush_cb = lvgl_flush_cb_16bit;
    af14:	48 8d 05 ac 02 00 00 	lea    0x2ac(%rip),%rax        # b1c7 <lvgl_flush_cb_16bit>
		disp_drv->rounder_cb = NULL;
    af1b:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
    af22:	00 
		disp_drv->flush_cb = lvgl_flush_cb_16bit;
    af23:	48 89 43 18          	mov    %rax,0x18(%rbx)
#ifdef CONFIG_LVGL_COLOR_DEPTH_16
		disp_drv->set_px_cb = NULL;
#else
		disp_drv->set_px_cb = lvgl_set_px_cb_16bit;
    af27:	48 8d 05 2c 03 00 00 	lea    0x32c(%rip),%rax        # b25a <lvgl_set_px_cb_16bit>
    af2e:	eb 1d                	jmp    af4d <set_lvgl_rendering_cb+0xc3>
#endif
		break;
	case PIXEL_FORMAT_MONO01:
	case PIXEL_FORMAT_MONO10:
		disp_drv->flush_cb = lvgl_flush_cb_mono;
    af30:	48 8d 05 5d 00 00 00 	lea    0x5d(%rip),%rax        # af94 <lvgl_flush_cb_mono>
    af37:	48 89 43 18          	mov    %rax,0x18(%rbx)
		disp_drv->rounder_cb = lvgl_rounder_cb_mono;
    af3b:	48 8d 05 12 02 00 00 	lea    0x212(%rip),%rax        # b154 <lvgl_rounder_cb_mono>
    af42:	48 89 43 20          	mov    %rax,0x20(%rbx)
		disp_drv->set_px_cb = lvgl_set_px_cb_mono;
    af46:	48 8d 05 1d 01 00 00 	lea    0x11d(%rip),%rax        # b06a <lvgl_set_px_cb_mono>
    af4d:	48 89 43 28          	mov    %rax,0x28(%rbx)
	int err = 0;
    af51:	31 c0                	xor    %eax,%eax
		break;
    af53:	eb 1d                	jmp    af72 <set_lvgl_rendering_cb+0xe8>
	default:
		disp_drv->flush_cb = NULL;
    af55:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
    af5c:	00 
		disp_drv->rounder_cb = NULL;
    af5d:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
    af64:	00 
		disp_drv->set_px_cb = NULL;
		err = -ENOTSUP;
    af65:	b8 a1 ff ff ff       	mov    $0xffffffa1,%eax
		disp_drv->set_px_cb = NULL;
    af6a:	48 c7 43 28 00 00 00 	movq   $0x0,0x28(%rbx)
    af71:	00 
		break;

	}

	return err;
}
    af72:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
    af77:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
    af7e:	00 00 
    af80:	74 05                	je     af87 <set_lvgl_rendering_cb+0xfd>
    af82:	e8 b9 96 ff ff       	callq  4640 <__stack_chk_fail@plt>
    af87:	48 83 c4 20          	add    $0x20,%rsp
    af8b:	5b                   	pop    %rbx
    af8c:	c3                   	retq   

000000000000af8d <display_get_capabilities>:
    af8d:	48 8b 47 10          	mov    0x10(%rdi),%rax
    af91:	ff 60 38             	jmpq   *0x38(%rax)

000000000000af94 <lvgl_flush_cb_mono>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_mono(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
    af94:	41 57                	push   %r15
    af96:	41 56                	push   %r14
    af98:	49 89 d6             	mov    %rdx,%r14
    af9b:	41 55                	push   %r13
    af9d:	41 54                	push   %r12
    af9f:	49 89 fd             	mov    %rdi,%r13
    afa2:	55                   	push   %rbp
    afa3:	53                   	push   %rbx
    afa4:	48 89 f3             	mov    %rsi,%rbx
    afa7:	48 83 ec 38          	sub    $0x38,%rsp
	uint16_t w = area->x2 - area->x1 + 1;
	uint16_t h = area->y2 - area->y1 + 1;
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
    afab:	4c 8b 7f 58          	mov    0x58(%rdi),%r15
{
    afaf:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    afb6:	00 00 
    afb8:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    afbd:	31 c0                	xor    %eax,%eax
	uint16_t w = area->x2 - area->x1 + 1;
    afbf:	66 8b 46 04          	mov    0x4(%rsi),%ax
	struct display_capabilities cap;
	struct display_buffer_descriptor desc;

	display_get_capabilities(display_dev, &cap);
    afc3:	4c 89 ff             	mov    %r15,%rdi
	uint16_t w = area->x2 - area->x1 + 1;
    afc6:	8d 68 01             	lea    0x1(%rax),%ebp
	uint16_t h = area->y2 - area->y1 + 1;
    afc9:	66 8b 46 06          	mov    0x6(%rsi),%ax
	uint16_t w = area->x2 - area->x1 + 1;
    afcd:	66 2b 2e             	sub    (%rsi),%bp
	uint16_t h = area->y2 - area->y1 + 1;
    afd0:	44 8d 60 01          	lea    0x1(%rax),%r12d
    afd4:	66 44 2b 66 02       	sub    0x2(%rsi),%r12w
	display_get_capabilities(display_dev, &cap);
    afd9:	48 8d 74 24 14       	lea    0x14(%rsp),%rsi
    afde:	e8 aa ff ff ff       	callq  af8d <display_get_capabilities>

	desc.buf_size = (w * h)/8U;
    afe3:	0f b7 c5             	movzwl %bp,%eax
	desc.width = w;
    afe6:	66 89 6c 24 0c       	mov    %bp,0xc(%rsp)
	desc.pitch = w;
    afeb:	66 89 6c 24 10       	mov    %bp,0x10(%rsp)
	desc.buf_size = (w * h)/8U;
    aff0:	41 0f b7 d4          	movzwl %r12w,%edx
	return api->write(dev, x, y, desc, buf);
    aff4:	48 8d 6c 24 08       	lea    0x8(%rsp),%rbp
	desc.height = h;
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);
    aff9:	0f b7 33             	movzwl (%rbx),%esi
	desc.buf_size = (w * h)/8U;
    affc:	0f af c2             	imul   %edx,%eax
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);
    afff:	0f b7 53 02          	movzwl 0x2(%rbx),%edx
	desc.height = h;
    b003:	66 44 89 64 24 0e    	mov    %r12w,0xe(%rsp)
    b009:	4d 89 f0             	mov    %r14,%r8
    b00c:	48 89 e9             	mov    %rbp,%rcx
    b00f:	4c 89 ff             	mov    %r15,%rdi
	desc.buf_size = (w * h)/8U;
    b012:	c1 e8 03             	shr    $0x3,%eax
    b015:	89 44 24 08          	mov    %eax,0x8(%rsp)
    b019:	49 8b 47 10          	mov    0x10(%r15),%rax
    b01d:	ff 50 10             	callq  *0x10(%rax)
	if (cap.screen_info & SCREEN_INFO_DOUBLE_BUFFER) {
    b020:	f6 44 24 1c 08       	testb  $0x8,0x1c(%rsp)
    b025:	74 17                	je     b03e <lvgl_flush_cb_mono+0xaa>
    b027:	49 8b 47 10          	mov    0x10(%r15),%rax
		display_write(display_dev, area->x1, area->y1, &desc,
    b02b:	0f b7 53 02          	movzwl 0x2(%rbx),%edx
    b02f:	4d 89 f0             	mov    %r14,%r8
    b032:	0f b7 33             	movzwl (%rbx),%esi
    b035:	48 89 e9             	mov    %rbp,%rcx
    b038:	4c 89 ff             	mov    %r15,%rdi
    b03b:	ff 50 10             	callq  *0x10(%rax)
				(void *) color_p);
	}

	lv_disp_flush_ready(disp_drv);
    b03e:	4c 89 ef             	mov    %r13,%rdi
    b041:	e8 a9 a0 01 00       	callq  250ef <lv_disp_flush_ready>
}
    b046:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    b04b:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    b052:	00 00 
    b054:	74 05                	je     b05b <lvgl_flush_cb_mono+0xc7>
    b056:	e8 e5 95 ff ff       	callq  4640 <__stack_chk_fail@plt>
    b05b:	48 83 c4 38          	add    $0x38,%rsp
    b05f:	5b                   	pop    %rbx
    b060:	5d                   	pop    %rbp
    b061:	41 5c                	pop    %r12
    b063:	41 5d                	pop    %r13
    b065:	41 5e                	pop    %r14
    b067:	41 5f                	pop    %r15
    b069:	c3                   	retq   

000000000000b06a <lvgl_set_px_cb_mono>:


void lvgl_set_px_cb_mono(struct _disp_drv_t *disp_drv,
		uint8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,
		lv_color_t color, lv_opa_t opa)
{
    b06a:	41 56                	push   %r14
    b06c:	41 55                	push   %r13
    b06e:	41 89 d6             	mov    %edx,%r14d
    b071:	41 54                	push   %r12
    b073:	55                   	push   %rbp
    b074:	49 89 f4             	mov    %rsi,%r12
    b077:	53                   	push   %rbx
    b078:	48 0f bf e9          	movswq %cx,%rbp
    b07c:	44 89 c3             	mov    %r8d,%ebx
    b07f:	48 83 ec 30          	sub    $0x30,%rsp
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
	uint8_t *buf_xy;
	uint8_t bit;
	struct display_capabilities cap;

	display_get_capabilities(display_dev, &cap);
    b083:	48 8b 7f 58          	mov    0x58(%rdi),%rdi
    b087:	48 8d 74 24 14       	lea    0x14(%rsp),%rsi
{
    b08c:	44 89 4c 24 0c       	mov    %r9d,0xc(%rsp)
    b091:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    b098:	00 00 
    b09a:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    b09f:	31 c0                	xor    %eax,%eax
	display_get_capabilities(display_dev, &cap);
    b0a1:	e8 e7 fe ff ff       	callq  af8d <display_get_capabilities>

	if (cap.screen_info & SCREEN_INFO_MONO_VTILED) {
    b0a6:	8b 7c 24 1c          	mov    0x1c(%rsp),%edi
    b0aa:	41 0f bf f6          	movswl %r14w,%esi
    b0ae:	44 8b 4c 24 0c       	mov    0xc(%rsp),%r9d
    b0b3:	40 f6 c7 01          	test   $0x1,%dil
    b0b7:	74 1c                	je     b0d5 <lvgl_set_px_cb_mono+0x6b>
		buf_xy = buf + x + y/8 * buf_w;
    b0b9:	89 da                	mov    %ebx,%edx
    b0bb:	b9 08 00 00 00       	mov    $0x8,%ecx
    b0c0:	89 d8                	mov    %ebx,%eax
    b0c2:	66 c1 fa 0f          	sar    $0xf,%dx
    b0c6:	66 f7 f9             	idiv   %cx
    b0c9:	98                   	cwtl   
    b0ca:	0f af c6             	imul   %esi,%eax
    b0cd:	48 63 f0             	movslq %eax,%rsi
    b0d0:	48 01 ee             	add    %rbp,%rsi
    b0d3:	eb 23                	jmp    b0f8 <lvgl_set_px_cb_mono+0x8e>
			bit = 7 - y%8;
		} else {
			bit = y%8;
		}
	} else {
		buf_xy = buf + x/8 + y * buf_w/8;
    b0d5:	0f bf c3             	movswl %bx,%eax
    b0d8:	b9 08 00 00 00       	mov    $0x8,%ecx
    b0dd:	0f af c6             	imul   %esi,%eax
    b0e0:	99                   	cltd   
    b0e1:	f7 f9                	idiv   %ecx
    b0e3:	89 ea                	mov    %ebp,%edx
    b0e5:	66 c1 fa 0f          	sar    $0xf,%dx
    b0e9:	48 63 d8             	movslq %eax,%rbx
    b0ec:	89 e8                	mov    %ebp,%eax
    b0ee:	66 f7 f9             	idiv   %cx
    b0f1:	48 0f bf f0          	movswq %ax,%rsi
    b0f5:	48 01 de             	add    %rbx,%rsi
    b0f8:	4c 01 e6             	add    %r12,%rsi

		if (cap.screen_info & SCREEN_INFO_MONO_MSB_FIRST) {
    b0fb:	40 80 e7 02          	and    $0x2,%dil
    b0ff:	88 d1                	mov    %dl,%cl
    b101:	74 04                	je     b107 <lvgl_set_px_cb_mono+0x9d>
			bit = 7 - x%8;
    b103:	b1 07                	mov    $0x7,%cl
    b105:	29 d1                	sub    %edx,%ecx
    b107:	b8 01 00 00 00       	mov    $0x1,%eax
    b10c:	8a 16                	mov    (%rsi),%dl
    b10e:	48 d3 e0             	shl    %cl,%rax
		} else {
			bit = x%8;
		}
	}

	if (cap.current_pixel_format == PIXEL_FORMAT_MONO10) {
    b111:	83 7c 24 20 04       	cmpl   $0x4,0x20(%rsp)
    b116:	75 0a                	jne    b122 <lvgl_set_px_cb_mono+0xb8>
		if (color.full == 0) {
			*buf_xy &= ~BIT(bit);
    b118:	88 d1                	mov    %dl,%cl
    b11a:	09 c1                	or     %eax,%ecx
    b11c:	f7 d0                	not    %eax
    b11e:	21 d0                	and    %edx,%eax
    b120:	eb 08                	jmp    b12a <lvgl_set_px_cb_mono+0xc0>
		} else {
			*buf_xy |= BIT(bit);
		}
	} else {
		if (color.full == 0) {
			*buf_xy |= BIT(bit);
    b122:	88 c1                	mov    %al,%cl
    b124:	09 d0                	or     %edx,%eax
    b126:	f7 d1                	not    %ecx
    b128:	21 d1                	and    %edx,%ecx
    b12a:	45 85 c9             	test   %r9d,%r9d
    b12d:	0f 45 c1             	cmovne %ecx,%eax
    b130:	88 06                	mov    %al,(%rsi)
		} else {
			*buf_xy &= ~BIT(bit);
		}
	}
}
    b132:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    b137:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    b13e:	00 00 
    b140:	74 05                	je     b147 <lvgl_set_px_cb_mono+0xdd>
    b142:	e8 f9 94 ff ff       	callq  4640 <__stack_chk_fail@plt>
    b147:	48 83 c4 30          	add    $0x30,%rsp
    b14b:	5b                   	pop    %rbx
    b14c:	5d                   	pop    %rbp
    b14d:	41 5c                	pop    %r12
    b14f:	41 5d                	pop    %r13
    b151:	41 5e                	pop    %r14
    b153:	c3                   	retq   

000000000000b154 <lvgl_rounder_cb_mono>:

void lvgl_rounder_cb_mono(struct _disp_drv_t *disp_drv,
		lv_area_t *area)
{
    b154:	53                   	push   %rbx
    b155:	48 89 f3             	mov    %rsi,%rbx
    b158:	48 83 ec 20          	sub    $0x20,%rsp
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
	struct display_capabilities cap;

	display_get_capabilities(display_dev, &cap);
    b15c:	48 8b 7f 58          	mov    0x58(%rdi),%rdi
    b160:	48 8d 74 24 04       	lea    0x4(%rsp),%rsi
{
    b165:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    b16c:	00 00 
    b16e:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    b173:	31 c0                	xor    %eax,%eax
	display_get_capabilities(display_dev, &cap);
    b175:	e8 13 fe ff ff       	callq  af8d <display_get_capabilities>

	if (cap.screen_info & SCREEN_INFO_X_ALIGNMENT_WIDTH) {
    b17a:	8b 44 24 0c          	mov    0xc(%rsp),%eax
    b17e:	a8 10                	test   $0x10,%al
    b180:	74 11                	je     b193 <lvgl_rounder_cb_mono+0x3f>
		area->x1 = 0;
		area->x2 = cap.x_resolution - 1;
    b182:	8b 44 24 04          	mov    0x4(%rsp),%eax
		area->x1 = 0;
    b186:	66 c7 03 00 00       	movw   $0x0,(%rbx)
		area->x2 = cap.x_resolution - 1;
    b18b:	ff c8                	dec    %eax
    b18d:	66 89 43 04          	mov    %ax,0x4(%rbx)
    b191:	eb 19                	jmp    b1ac <lvgl_rounder_cb_mono+0x58>
	} else {
		if (cap.screen_info & SCREEN_INFO_MONO_VTILED) {
    b193:	a8 01                	test   $0x1,%al
    b195:	74 0c                	je     b1a3 <lvgl_rounder_cb_mono+0x4f>
			area->y1 &= ~0x7;
    b197:	66 83 63 02 f8       	andw   $0xfff8,0x2(%rbx)
			area->y2 |= 0x7;
    b19c:	66 83 4b 06 07       	orw    $0x7,0x6(%rbx)
    b1a1:	eb 09                	jmp    b1ac <lvgl_rounder_cb_mono+0x58>
		} else {
			area->x1 &= ~0x7;
    b1a3:	66 83 23 f8          	andw   $0xfff8,(%rbx)
			area->x2 |= 0x7;
    b1a7:	66 83 4b 04 07       	orw    $0x7,0x4(%rbx)
		}
	}
}
    b1ac:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    b1b1:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    b1b8:	00 00 
    b1ba:	74 05                	je     b1c1 <lvgl_rounder_cb_mono+0x6d>
    b1bc:	e8 7f 94 ff ff       	callq  4640 <__stack_chk_fail@plt>
    b1c1:	48 83 c4 20          	add    $0x20,%rsp
    b1c5:	5b                   	pop    %rbx
    b1c6:	c3                   	retq   

000000000000b1c7 <lvgl_flush_cb_16bit>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_16bit(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
    b1c7:	53                   	push   %rbx
    b1c8:	48 89 fb             	mov    %rdi,%rbx
    b1cb:	49 89 d0             	mov    %rdx,%r8
    b1ce:	48 83 ec 20          	sub    $0x20,%rsp
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
	uint16_t w = area->x2 - area->x1 + 1;
	uint16_t h = area->y2 - area->y1 + 1;
    b1d2:	66 8b 4e 06          	mov    0x6(%rsi),%cx
    b1d6:	66 44 8b 5e 02       	mov    0x2(%rsi),%r11w
{
    b1db:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    b1e2:	00 00 
    b1e4:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    b1e9:	31 c0                	xor    %eax,%eax
	uint16_t w = area->x2 - area->x1 + 1;
    b1eb:	66 8b 46 04          	mov    0x4(%rsi),%ax
    b1ef:	66 44 8b 16          	mov    (%rsi),%r10w
	uint16_t h = area->y2 - area->y1 + 1;
    b1f3:	ff c1                	inc    %ecx
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
    b1f5:	48 8b 7f 58          	mov    0x58(%rdi),%rdi
	uint16_t h = area->y2 - area->y1 + 1;
    b1f9:	44 29 d9             	sub    %r11d,%ecx
	uint16_t w = area->x2 - area->x1 + 1;
    b1fc:	ff c0                	inc    %eax
	struct display_buffer_descriptor desc;

	desc.buf_size = w * 2U * h;
    b1fe:	0f b7 d1             	movzwl %cx,%edx
	desc.width = w;
	desc.pitch = w;
	desc.height = h;
    b201:	66 89 4c 24 12       	mov    %cx,0x12(%rsp)
	uint16_t w = area->x2 - area->x1 + 1;
    b206:	44 29 d0             	sub    %r10d,%eax
    b209:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);
    b20e:	41 0f b7 f2          	movzwl %r10w,%esi
	desc.buf_size = w * 2U * h;
    b212:	44 0f b7 c8          	movzwl %ax,%r9d
	desc.width = w;
    b216:	66 89 44 24 10       	mov    %ax,0x10(%rsp)
	desc.pitch = w;
    b21b:	66 89 44 24 14       	mov    %ax,0x14(%rsp)
	desc.buf_size = w * 2U * h;
    b220:	44 0f af ca          	imul   %edx,%r9d
    b224:	48 8b 47 10          	mov    0x10(%rdi),%rax
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);
    b228:	41 0f b7 d3          	movzwl %r11w,%edx
	desc.buf_size = w * 2U * h;
    b22c:	45 01 c9             	add    %r9d,%r9d
    b22f:	44 89 4c 24 0c       	mov    %r9d,0xc(%rsp)
    b234:	ff 50 10             	callq  *0x10(%rax)

	lv_disp_flush_ready(disp_drv);
    b237:	48 89 df             	mov    %rbx,%rdi
    b23a:	e8 b0 9e 01 00       	callq  250ef <lv_disp_flush_ready>
}
    b23f:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    b244:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    b24b:	00 00 
    b24d:	74 05                	je     b254 <lvgl_flush_cb_16bit+0x8d>
    b24f:	e8 ec 93 ff ff       	callq  4640 <__stack_chk_fail@plt>
    b254:	48 83 c4 20          	add    $0x20,%rsp
    b258:	5b                   	pop    %rbx
    b259:	c3                   	retq   

000000000000b25a <lvgl_set_px_cb_16bit>:
    return ret.full;
#elif LV_COLOR_DEPTH == 16
    return color.full;
#elif LV_COLOR_DEPTH == 32
    lv_color16_t ret;
    LV_COLOR_SET_R16(ret, LV_COLOR_GET_R(color) >> 3);   /* 8 - 5  = 3*/
    b25a:	44 89 c8             	mov    %r9d,%eax

#if LV_COLOR_16_SWAP == 0
    LV_COLOR_SET_G16(ret, LV_COLOR_GET_G(color) >> 2); /* 8 - 6  = 2*/
    b25d:	45 89 ca             	mov    %r9d,%r10d
#ifndef CONFIG_LVGL_COLOR_DEPTH_16
void lvgl_set_px_cb_16bit(struct _disp_drv_t *disp_drv,
		uint8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,
		lv_color_t color, lv_opa_t opa)
{
	uint16_t *buf_xy = (uint16_t *)(buf + x * 2U + y * 2U * buf_w);
    b260:	0f bf d2             	movswl %dx,%edx
    LV_COLOR_SET_R16(ret, LV_COLOR_GET_R(color) >> 3);   /* 8 - 5  = 3*/
    b263:	c1 e8 13             	shr    $0x13,%eax
    LV_COLOR_SET_G16(ret, LV_COLOR_GET_G(color) >> 2); /* 8 - 6  = 2*/
    b266:	66 41 c1 ea 0a       	shr    $0xa,%r10w
    b26b:	01 d2                	add    %edx,%edx
    b26d:	45 0f bf c0          	movswl %r8w,%r8d
#else
    LV_COLOR_SET_G16_SWAP(ret, ret.ch.green_h = (LV_COLOR_GET_G(color) >> 2); /*(2^6 - 1)/(2^3 - 1) = 63/7 = 9*/
#endif
    LV_COLOR_SET_B16(ret, LV_COLOR_GET_B(color) >> 3);  /* 8 - 5  = 3*/
    b271:	41 c0 e9 03          	shr    $0x3,%r9b
    LV_COLOR_SET_G16(ret, LV_COLOR_GET_G(color) >> 2); /* 8 - 6  = 2*/
    b275:	41 c1 e2 05          	shl    $0x5,%r10d
    b279:	c1 e0 0b             	shl    $0xb,%eax
    LV_COLOR_SET_B16(ret, LV_COLOR_GET_B(color) >> 3);  /* 8 - 5  = 3*/
    b27c:	44 89 cf             	mov    %r9d,%edi
    b27f:	0f bf c9             	movswl %cx,%ecx
    b282:	41 0f af d0          	imul   %r8d,%edx
    b286:	44 09 d0             	or     %r10d,%eax
    b289:	83 e7 1f             	and    $0x1f,%edi
    b28c:	41 89 c1             	mov    %eax,%r9d
    b28f:	01 c9                	add    %ecx,%ecx
    b291:	41 09 f9             	or     %edi,%r9d
	*buf_xy = lv_color_to16(color);
    b294:	48 01 f2             	add    %rsi,%rdx
    b297:	66 44 89 0c 0a       	mov    %r9w,(%rdx,%rcx,1)
}
    b29c:	c3                   	retq   

000000000000b29d <lvgl_flush_cb_24bit>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_24bit(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
    b29d:	53                   	push   %rbx
    b29e:	49 89 d0             	mov    %rdx,%r8
    b2a1:	48 89 fb             	mov    %rdi,%rbx
    b2a4:	48 83 ec 20          	sub    $0x20,%rsp
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
	uint16_t w = area->x2 - area->x1 + 1;
	uint16_t h = area->y2 - area->y1 + 1;
    b2a8:	66 8b 4e 06          	mov    0x6(%rsi),%cx
    b2ac:	66 44 8b 5e 02       	mov    0x2(%rsi),%r11w
{
    b2b1:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    b2b8:	00 00 
    b2ba:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    b2bf:	31 c0                	xor    %eax,%eax
	uint16_t w = area->x2 - area->x1 + 1;
    b2c1:	66 8b 46 04          	mov    0x4(%rsi),%ax
    b2c5:	66 44 8b 16          	mov    (%rsi),%r10w
	uint16_t h = area->y2 - area->y1 + 1;
    b2c9:	ff c1                	inc    %ecx
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
    b2cb:	48 8b 7f 58          	mov    0x58(%rdi),%rdi
	uint16_t h = area->y2 - area->y1 + 1;
    b2cf:	44 29 d9             	sub    %r11d,%ecx
	uint16_t w = area->x2 - area->x1 + 1;
    b2d2:	ff c0                	inc    %eax
	struct display_buffer_descriptor desc;

	desc.buf_size = w * 3U * h;
    b2d4:	0f b7 d1             	movzwl %cx,%edx
	desc.width = w;
	desc.pitch = w;
	desc.height = h;
    b2d7:	66 89 4c 24 12       	mov    %cx,0x12(%rsp)
	uint16_t w = area->x2 - area->x1 + 1;
    b2dc:	44 29 d0             	sub    %r10d,%eax
    b2df:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);
    b2e4:	41 0f b7 f2          	movzwl %r10w,%esi
	desc.buf_size = w * 3U * h;
    b2e8:	44 0f b7 c8          	movzwl %ax,%r9d
	desc.width = w;
    b2ec:	66 89 44 24 10       	mov    %ax,0x10(%rsp)
	desc.pitch = w;
    b2f1:	66 89 44 24 14       	mov    %ax,0x14(%rsp)
	desc.buf_size = w * 3U * h;
    b2f6:	44 0f af ca          	imul   %edx,%r9d
    b2fa:	48 8b 47 10          	mov    0x10(%rdi),%rax
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);
    b2fe:	41 0f b7 d3          	movzwl %r11w,%edx
	desc.buf_size = w * 3U * h;
    b302:	47 8d 0c 49          	lea    (%r9,%r9,2),%r9d
    b306:	44 89 4c 24 0c       	mov    %r9d,0xc(%rsp)
    b30b:	ff 50 10             	callq  *0x10(%rax)

	lv_disp_flush_ready(disp_drv);
    b30e:	48 89 df             	mov    %rbx,%rdi
    b311:	e8 d9 9d 01 00       	callq  250ef <lv_disp_flush_ready>
}
    b316:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    b31b:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    b322:	00 00 
    b324:	74 05                	je     b32b <lvgl_flush_cb_24bit+0x8e>
    b326:	e8 15 93 ff ff       	callq  4640 <__stack_chk_fail@plt>
    b32b:	48 83 c4 20          	add    $0x20,%rsp
    b32f:	5b                   	pop    %rbx
    b330:	c3                   	retq   

000000000000b331 <lvgl_set_px_cb_24bit>:

void lvgl_set_px_cb_24bit(struct _disp_drv_t *disp_drv,
		uint8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,
		lv_color_t color, lv_opa_t opa)
{
	uint8_t *buf_xy = buf + x * 3U + y * 3U * buf_w;
    b331:	0f bf d2             	movswl %dx,%edx
    b334:	45 0f bf c0          	movswl %r8w,%r8d
    b338:	0f bf c9             	movswl %cx,%ecx
    b33b:	8d 04 52             	lea    (%rdx,%rdx,2),%eax
{
    b33e:	8b 7c 24 08          	mov    0x8(%rsp),%edi
	uint8_t *buf_xy = buf + x * 3U + y * 3U * buf_w;
    b342:	6b c9 03             	imul   $0x3,%ecx,%ecx
    b345:	41 0f af c0          	imul   %r8d,%eax
    b349:	48 01 c8             	add    %rcx,%rax
    b34c:	48 01 c6             	add    %rax,%rsi
	lv_color32_t converted_color;

#ifdef CONFIG_LVGL_COLOR_DEPTH_32
	if (opa != LV_OPA_COVER) {
    b34f:	40 80 ff ff          	cmp    $0xff,%dil
    b353:	0f 84 91 00 00 00    	je     b3ea <lvgl_set_px_cb_24bit+0xb9>
LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
{
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
    b359:	44 0f b6 06          	movzbl (%rsi),%r8d
                                        (255 - mix) + LV_COLOR_MIX_ROUND_OFS));
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
    b35d:	0f b6 46 01          	movzbl 0x1(%rsi),%eax
		lv_color_t mix_color;

		mix_color.ch.red = *buf_xy;
		mix_color.ch.green = *(buf_xy+1);
		mix_color.ch.blue = *(buf_xy+2);
		color = lv_color_mix(color, mix_color, opa);
    b361:	40 0f b6 ff          	movzbl %dil,%edi
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
    b365:	b9 ff 00 00 00       	mov    $0xff,%ecx
    b36a:	29 f9                	sub    %edi,%ecx
    b36c:	44 89 c2             	mov    %r8d,%edx
    b36f:	45 89 c8             	mov    %r9d,%r8d
    b372:	41 c1 e8 10          	shr    $0x10,%r8d
    b376:	45 0f b6 c0          	movzbl %r8b,%r8d
    b37a:	0f af d1             	imul   %ecx,%edx
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
    b37d:	0f af c1             	imul   %ecx,%eax
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
    b380:	44 0f af c7          	imul   %edi,%r8d
    b384:	41 01 d0             	add    %edx,%r8d
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
    b387:	89 c2                	mov    %eax,%edx
    b389:	44 89 c8             	mov    %r9d,%eax
    b38c:	0f b6 c4             	movzbl %ah,%eax
    b38f:	0f af c7             	imul   %edi,%eax
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
    b392:	45 69 c0 81 80 00 00 	imul   $0x8081,%r8d,%r8d
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
    b399:	01 d0                	add    %edx,%eax
                                        (255 - mix) + LV_COLOR_MIX_ROUND_OFS));
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
    b39b:	41 0f b6 d1          	movzbl %r9b,%edx
    b39f:	0f af d7             	imul   %edi,%edx
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
    b3a2:	69 c0 81 80 00 00    	imul   $0x8081,%eax,%eax
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
    b3a8:	41 89 d1             	mov    %edx,%r9d
    b3ab:	0f b6 56 02          	movzbl 0x2(%rsi),%edx
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
    b3af:	c1 e8 17             	shr    $0x17,%eax
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
    b3b2:	0f af ca             	imul   %edx,%ecx
    b3b5:	41 8d 14 09          	lea    (%r9,%rcx,1),%edx
    b3b9:	31 c9                	xor    %ecx,%ecx
    b3bb:	45 89 c1             	mov    %r8d,%r9d
    b3be:	41 c1 e9 07          	shr    $0x7,%r9d
    b3c2:	69 d2 81 80 00 00    	imul   $0x8081,%edx,%edx
    b3c8:	c1 ea 17             	shr    $0x17,%edx
    b3cb:	88 d1                	mov    %dl,%cl
    b3cd:	88 c5                	mov    %al,%ch
    b3cf:	44 89 c8             	mov    %r9d,%eax
    b3d2:	81 e1 ff ff 00 ff    	and    $0xff00ffff,%ecx
    b3d8:	25 00 00 ff 00       	and    $0xff0000,%eax
    b3dd:	41 89 c9             	mov    %ecx,%r9d
    b3e0:	41 09 c1             	or     %eax,%r9d
    b3e3:	41 81 c9 00 00 00 ff 	or     $0xff000000,%r9d
	}
#endif

	converted_color.full = lv_color_to32(color);
	*buf_xy = converted_color.ch.red;
    b3ea:	44 89 c8             	mov    %r9d,%eax
	*(buf_xy + 1) = converted_color.ch.green;
	*(buf_xy + 2) = converted_color.ch.blue;
    b3ed:	44 88 4e 02          	mov    %r9b,0x2(%rsi)
	*buf_xy = converted_color.ch.red;
    b3f1:	c1 e8 10             	shr    $0x10,%eax
    b3f4:	88 06                	mov    %al,(%rsi)
	*(buf_xy + 1) = converted_color.ch.green;
    b3f6:	44 89 c8             	mov    %r9d,%eax
    b3f9:	88 66 01             	mov    %ah,0x1(%rsi)
}
    b3fc:	c3                   	retq   

000000000000b3fd <lvgl_flush_cb_32bit>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_32bit(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
    b3fd:	53                   	push   %rbx
    b3fe:	48 89 fb             	mov    %rdi,%rbx
    b401:	49 89 d0             	mov    %rdx,%r8
    b404:	48 83 ec 20          	sub    $0x20,%rsp
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
	uint16_t w = area->x2 - area->x1 + 1;
	uint16_t h = area->y2 - area->y1 + 1;
    b408:	66 8b 4e 06          	mov    0x6(%rsi),%cx
    b40c:	66 44 8b 5e 02       	mov    0x2(%rsi),%r11w
{
    b411:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    b418:	00 00 
    b41a:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    b41f:	31 c0                	xor    %eax,%eax
	uint16_t w = area->x2 - area->x1 + 1;
    b421:	66 8b 46 04          	mov    0x4(%rsi),%ax
    b425:	66 44 8b 16          	mov    (%rsi),%r10w
	uint16_t h = area->y2 - area->y1 + 1;
    b429:	ff c1                	inc    %ecx
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
    b42b:	48 8b 7f 58          	mov    0x58(%rdi),%rdi
	uint16_t h = area->y2 - area->y1 + 1;
    b42f:	44 29 d9             	sub    %r11d,%ecx
	uint16_t w = area->x2 - area->x1 + 1;
    b432:	ff c0                	inc    %eax
	struct display_buffer_descriptor desc;

	desc.buf_size = w * 4U * h;
    b434:	0f b7 d1             	movzwl %cx,%edx
	desc.width = w;
	desc.pitch = w;
	desc.height = h;
    b437:	66 89 4c 24 12       	mov    %cx,0x12(%rsp)
	uint16_t w = area->x2 - area->x1 + 1;
    b43c:	44 29 d0             	sub    %r10d,%eax
    b43f:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);
    b444:	41 0f b7 f2          	movzwl %r10w,%esi
	desc.buf_size = w * 4U * h;
    b448:	44 0f b7 c8          	movzwl %ax,%r9d
	desc.width = w;
    b44c:	66 89 44 24 10       	mov    %ax,0x10(%rsp)
	desc.pitch = w;
    b451:	66 89 44 24 14       	mov    %ax,0x14(%rsp)
	desc.buf_size = w * 4U * h;
    b456:	44 0f af ca          	imul   %edx,%r9d
    b45a:	48 8b 47 10          	mov    0x10(%rdi),%rax
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);
    b45e:	41 0f b7 d3          	movzwl %r11w,%edx
	desc.buf_size = w * 4U * h;
    b462:	41 c1 e1 02          	shl    $0x2,%r9d
    b466:	44 89 4c 24 0c       	mov    %r9d,0xc(%rsp)
    b46b:	ff 50 10             	callq  *0x10(%rax)

	lv_disp_flush_ready(disp_drv);
    b46e:	48 89 df             	mov    %rbx,%rdi
    b471:	e8 79 9c 01 00       	callq  250ef <lv_disp_flush_ready>
}
    b476:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    b47b:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    b482:	00 00 
    b484:	74 05                	je     b48b <lvgl_flush_cb_32bit+0x8e>
    b486:	e8 b5 91 ff ff       	callq  4640 <__stack_chk_fail@plt>
    b48b:	48 83 c4 20          	add    $0x20,%rsp
    b48f:	5b                   	pop    %rbx
    b490:	c3                   	retq   

000000000000b491 <pc_safe_call>:
	if (unlikely(test)) {
    b491:	85 ff                	test   %edi,%edi
    b493:	74 0e                	je     b4a3 <pc_safe_call+0x12>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    b495:	48 8d 3d 1b 60 02 00 	lea    0x2601b(%rip),%rdi        # 314b7 <__func__.5785+0x84f>
    b49c:	31 c0                	xor    %eax,%eax
    b49e:	e9 1f 0e 00 00       	jmpq   c2c2 <posix_print_error_and_exit>
}
    b4a3:	c3                   	retq   

000000000000b4a4 <zephyr_wrapper>:
 * called from posix_boot_cpu()
 */
static void *zephyr_wrapper(void *a)
{
	/* Ensure posix_boot_cpu has reached the cond loop */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    b4a4:	48 8d 3d 95 b5 24 00 	lea    0x24b595(%rip),%rdi        # 256a40 <mtx_cpu>
{
    b4ab:	48 83 ec 08          	sub    $0x8,%rsp
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    b4af:	e8 4c 92 ff ff       	callq  4700 <pthread_mutex_lock@plt>
    b4b4:	48 8d 35 05 63 02 00 	lea    0x26305(%rip),%rsi        # 317c0 <__func__.5785+0xb58>
    b4bb:	89 c7                	mov    %eax,%edi
    b4bd:	e8 cf ff ff ff       	callq  b491 <pc_safe_call>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    b4c2:	48 8d 3d 77 b5 24 00 	lea    0x24b577(%rip),%rdi        # 256a40 <mtx_cpu>
    b4c9:	e8 42 90 ff ff       	callq  4510 <pthread_mutex_unlock@plt>
    b4ce:	48 8d 35 08 63 02 00 	lea    0x26308(%rip),%rsi        # 317dd <__func__.5785+0xb75>
    b4d5:	89 c7                	mov    %eax,%edi
    b4d7:	e8 b5 ff ff ff       	callq  b491 <pc_safe_call>

		PS_DEBUG("Zephyr init started (%lu)\n",
			zephyr_thread);
#endif

	posix_init_multithreading();
    b4dc:	e8 07 f3 ff ff       	callq  a7e8 <posix_init_multithreading>

	/* Start Zephyr: */
	z_cstart();
    b4e1:	e8 4e f5 01 00       	callq  2aa34 <z_cstart>

000000000000b4e6 <posix_is_cpu_running>:
	return !cpu_halted;
    b4e6:	8a 05 31 b6 22 00    	mov    0x22b631(%rip),%al        # 236b1d <cpu_halted>
    b4ec:	83 f0 01             	xor    $0x1,%eax
    b4ef:	0f b6 c0             	movzbl %al,%eax
}
    b4f2:	c3                   	retq   

000000000000b4f3 <posix_change_cpu_state_and_wait>:
{
    b4f3:	55                   	push   %rbp
    b4f4:	53                   	push   %rbx
    b4f5:	40 88 fd             	mov    %dil,%bpl
    b4f8:	89 fb                	mov    %edi,%ebx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    b4fa:	48 8d 3d 3f b5 24 00 	lea    0x24b53f(%rip),%rdi        # 256a40 <mtx_cpu>
{
    b501:	48 83 ec 08          	sub    $0x8,%rsp
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    b505:	e8 f6 91 ff ff       	callq  4700 <pthread_mutex_lock@plt>
    b50a:	48 8d 35 af 62 02 00 	lea    0x262af(%rip),%rsi        # 317c0 <__func__.5785+0xb58>
    b511:	89 c7                	mov    %eax,%edi
    b513:	e8 79 ff ff ff       	callq  b491 <pc_safe_call>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    b518:	48 8d 3d 61 b5 24 00 	lea    0x24b561(%rip),%rdi        # 256a80 <cond_cpu>
	cpu_halted = halted;
    b51f:	88 1d f8 b5 22 00    	mov    %bl,0x22b5f8(%rip)        # 236b1d <cpu_halted>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    b525:	48 8d 1d 14 b5 24 00 	lea    0x24b514(%rip),%rbx        # 256a40 <mtx_cpu>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    b52c:	e8 df 8e ff ff       	callq  4410 <pthread_cond_broadcast@plt>
    b531:	48 8d 35 c4 62 02 00 	lea    0x262c4(%rip),%rsi        # 317fc <__func__.5785+0xb94>
    b538:	89 c7                	mov    %eax,%edi
    b53a:	e8 52 ff ff ff       	callq  b491 <pc_safe_call>
	while (cpu_halted == halted) {
    b53f:	40 38 2d d7 b5 22 00 	cmp    %bpl,0x22b5d7(%rip)        # 236b1d <cpu_halted>
    b546:	75 11                	jne    b559 <posix_change_cpu_state_and_wait+0x66>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    b548:	48 8d 3d 31 b5 24 00 	lea    0x24b531(%rip),%rdi        # 256a80 <cond_cpu>
    b54f:	48 89 de             	mov    %rbx,%rsi
    b552:	e8 c9 91 ff ff       	callq  4720 <pthread_cond_wait@plt>
    b557:	eb e6                	jmp    b53f <posix_change_cpu_state_and_wait+0x4c>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    b559:	48 8d 3d e0 b4 24 00 	lea    0x24b4e0(%rip),%rdi        # 256a40 <mtx_cpu>
    b560:	e8 ab 8f ff ff       	callq  4510 <pthread_mutex_unlock@plt>
    b565:	89 c7                	mov    %eax,%edi
    b567:	48 8d 35 6f 62 02 00 	lea    0x2626f(%rip),%rsi        # 317dd <__func__.5785+0xb75>
}
    b56e:	58                   	pop    %rax
    b56f:	5b                   	pop    %rbx
    b570:	5d                   	pop    %rbp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    b571:	e9 1b ff ff ff       	jmpq   b491 <pc_safe_call>

000000000000b576 <posix_interrupt_raised>:
{
    b576:	48 83 ec 08          	sub    $0x8,%rsp
	posix_change_cpu_state_and_wait(false);
    b57a:	31 ff                	xor    %edi,%edi
    b57c:	e8 72 ff ff ff       	callq  b4f3 <posix_change_cpu_state_and_wait>
	if (soc_terminate) {
    b581:	80 3d 5d 3b 25 00 00 	cmpb   $0x0,0x253b5d(%rip)        # 25f0e5 <soc_terminate>
    b588:	74 08                	je     b592 <posix_interrupt_raised+0x1c>
}
    b58a:	5a                   	pop    %rdx
		posix_exit(0);
    b58b:	31 ff                	xor    %edi,%edi
    b58d:	e9 46 0c 00 00       	jmpq   c1d8 <posix_exit>
}
    b592:	58                   	pop    %rax
    b593:	c3                   	retq   

000000000000b594 <posix_halt_cpu>:
{
    b594:	48 83 ec 08          	sub    $0x8,%rsp
	posix_change_cpu_state_and_wait(true);
    b598:	bf 01 00 00 00       	mov    $0x1,%edi
    b59d:	e8 51 ff ff ff       	callq  b4f3 <posix_change_cpu_state_and_wait>
}
    b5a2:	58                   	pop    %rax
	posix_irq_handler();
    b5a3:	e9 b0 08 00 00       	jmpq   be58 <posix_irq_handler>

000000000000b5a8 <posix_boot_cpu>:
 * The HW models will call this function to "boot" the CPU
 * == spawn the Zephyr init thread, which will then spawn
 * anything it wants, and run until the CPU is set back to idle again
 */
void posix_boot_cpu(void)
{
    b5a8:	53                   	push   %rbx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    b5a9:	48 8d 3d 90 b4 24 00 	lea    0x24b490(%rip),%rdi        # 256a40 <mtx_cpu>
	/* Create a thread for Zephyr init: */
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));

	/* And we wait until Zephyr has run til completion (has gone to idle) */
	while (cpu_halted == false) {
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    b5b0:	48 8d 1d 89 b4 24 00 	lea    0x24b489(%rip),%rbx        # 256a40 <mtx_cpu>
{
    b5b7:	48 83 ec 10          	sub    $0x10,%rsp
    b5bb:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    b5c2:	00 00 
    b5c4:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    b5c9:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    b5cb:	e8 30 91 ff ff       	callq  4700 <pthread_mutex_lock@plt>
    b5d0:	48 8d 35 e9 61 02 00 	lea    0x261e9(%rip),%rsi        # 317c0 <__func__.5785+0xb58>
    b5d7:	89 c7                	mov    %eax,%edi
    b5d9:	e8 b3 fe ff ff       	callq  b491 <pc_safe_call>
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
    b5de:	48 8d 15 bf fe ff ff 	lea    -0x141(%rip),%rdx        # b4a4 <zephyr_wrapper>
    b5e5:	48 89 e7             	mov    %rsp,%rdi
    b5e8:	31 c9                	xor    %ecx,%ecx
    b5ea:	31 f6                	xor    %esi,%esi
	cpu_halted = false;
    b5ec:	c6 05 2a b5 22 00 00 	movb   $0x0,0x22b52a(%rip)        # 236b1d <cpu_halted>
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
    b5f3:	e8 78 8e ff ff       	callq  4470 <pthread_create@plt>
    b5f8:	48 8d 35 1f 62 02 00 	lea    0x2621f(%rip),%rsi        # 3181e <__func__.5785+0xbb6>
    b5ff:	89 c7                	mov    %eax,%edi
    b601:	e8 8b fe ff ff       	callq  b491 <pc_safe_call>
	while (cpu_halted == false) {
    b606:	80 3d 10 b5 22 00 00 	cmpb   $0x0,0x22b510(%rip)        # 236b1d <cpu_halted>
    b60d:	75 11                	jne    b620 <posix_boot_cpu+0x78>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    b60f:	48 8d 3d 6a b4 24 00 	lea    0x24b46a(%rip),%rdi        # 256a80 <cond_cpu>
    b616:	48 89 de             	mov    %rbx,%rsi
    b619:	e8 02 91 ff ff       	callq  4720 <pthread_cond_wait@plt>
    b61e:	eb e6                	jmp    b606 <posix_boot_cpu+0x5e>
	}
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    b620:	48 8d 3d 19 b4 24 00 	lea    0x24b419(%rip),%rdi        # 256a40 <mtx_cpu>
    b627:	e8 e4 8e ff ff       	callq  4510 <pthread_mutex_unlock@plt>
    b62c:	48 8d 35 aa 61 02 00 	lea    0x261aa(%rip),%rsi        # 317dd <__func__.5785+0xb75>
    b633:	89 c7                	mov    %eax,%edi
    b635:	e8 57 fe ff ff       	callq  b491 <pc_safe_call>

	if (soc_terminate) {
    b63a:	80 3d a4 3a 25 00 00 	cmpb   $0x0,0x253aa4(%rip)        # 25f0e5 <soc_terminate>
    b641:	74 07                	je     b64a <posix_boot_cpu+0xa2>
		posix_exit(0);
    b643:	31 ff                	xor    %edi,%edi
    b645:	e8 8e 0b 00 00       	callq  c1d8 <posix_exit>
	}
}
    b64a:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    b64f:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    b656:	00 00 
    b658:	74 05                	je     b65f <posix_boot_cpu+0xb7>
    b65a:	e8 e1 8f ff ff       	callq  4640 <__stack_chk_fail@plt>
    b65f:	48 83 c4 10          	add    $0x10,%rsp
    b663:	5b                   	pop    %rbx
    b664:	c3                   	retq   

000000000000b665 <run_native_tasks>:
		__native_tasks_end
	};

	void (**fptr)(void);

	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    b665:	48 8d 05 14 a1 22 00 	lea    0x22a114(%rip),%rax        # 235780 <native_pre_tasks.6111>
    b66c:	48 63 d7             	movslq %edi,%rdx
{
    b66f:	41 54                	push   %r12
    b671:	55                   	push   %rbp
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    b672:	ff c7                	inc    %edi
{
    b674:	53                   	push   %rbx
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    b675:	48 8b 2c d0          	mov    (%rax,%rdx,8),%rbp
    b679:	49 89 c4             	mov    %rax,%r12
    b67c:	48 63 df             	movslq %edi,%rbx
    b67f:	49 39 2c dc          	cmp    %rbp,(%r12,%rbx,8)
    b683:	76 11                	jbe    b696 <run_native_tasks+0x31>
		fptr++) {
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
    b685:	48 8b 45 00          	mov    0x0(%rbp),%rax
    b689:	48 85 c0             	test   %rax,%rax
    b68c:	74 02                	je     b690 <run_native_tasks+0x2b>
			(*fptr)();
    b68e:	ff d0                	callq  *%rax
		fptr++) {
    b690:	48 83 c5 08          	add    $0x8,%rbp
    b694:	eb e9                	jmp    b67f <run_native_tasks+0x1a>
		}
	}
}
    b696:	5b                   	pop    %rbx
    b697:	5d                   	pop    %rbp
    b698:	41 5c                	pop    %r12
    b69a:	c3                   	retq   

000000000000b69b <posix_soc_clean_up>:
 * Clean up all memory allocated by the SOC and POSIX core
 *
 * This function can be called from both HW and SW threads
 */
void posix_soc_clean_up(void)
{
    b69b:	48 83 ec 08          	sub    $0x8,%rsp
	 * If we are being called from a HW thread we can cleanup
	 *
	 * Otherwise (!cpu_halted) we give back control to the HW thread and
	 * tell it to terminate ASAP
	 */
	if (cpu_halted) {
    b69f:	80 3d 77 b4 22 00 00 	cmpb   $0x0,0x22b477(%rip)        # 236b1d <cpu_halted>
    b6a6:	74 10                	je     b6b8 <posix_soc_clean_up+0x1d>

		posix_core_clean_up();
    b6a8:	e8 9f f1 ff ff       	callq  a84c <posix_core_clean_up>
			 * won't really wait 1 second
			 */
		}
	}
	/* LCOV_EXCL_STOP */
}
    b6ad:	5a                   	pop    %rdx
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
    b6ae:	bf 04 00 00 00       	mov    $0x4,%edi
    b6b3:	e9 ad ff ff ff       	jmpq   b665 <run_native_tasks>
	} else if (soc_terminate == false) {
    b6b8:	80 3d 26 3a 25 00 00 	cmpb   $0x0,0x253a26(%rip)        # 25f0e5 <soc_terminate>
    b6bf:	75 68                	jne    b729 <posix_soc_clean_up+0x8e>
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    b6c1:	48 8d 3d 78 b3 24 00 	lea    0x24b378(%rip),%rdi        # 256a40 <mtx_cpu>
		soc_terminate = true;
    b6c8:	c6 05 16 3a 25 00 01 	movb   $0x1,0x253a16(%rip)        # 25f0e5 <soc_terminate>
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    b6cf:	e8 2c 90 ff ff       	callq  4700 <pthread_mutex_lock@plt>
    b6d4:	48 8d 35 e5 60 02 00 	lea    0x260e5(%rip),%rsi        # 317c0 <__func__.5785+0xb58>
    b6db:	89 c7                	mov    %eax,%edi
    b6dd:	e8 af fd ff ff       	callq  b491 <pc_safe_call>
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    b6e2:	48 8d 3d 97 b3 24 00 	lea    0x24b397(%rip),%rdi        # 256a80 <cond_cpu>
		cpu_halted = true;
    b6e9:	c6 05 2d b4 22 00 01 	movb   $0x1,0x22b42d(%rip)        # 236b1d <cpu_halted>
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    b6f0:	e8 1b 8d ff ff       	callq  4410 <pthread_cond_broadcast@plt>
    b6f5:	48 8d 35 00 61 02 00 	lea    0x26100(%rip),%rsi        # 317fc <__func__.5785+0xb94>
    b6fc:	89 c7                	mov    %eax,%edi
    b6fe:	e8 8e fd ff ff       	callq  b491 <pc_safe_call>
		PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    b703:	48 8d 3d 36 b3 24 00 	lea    0x24b336(%rip),%rdi        # 256a40 <mtx_cpu>
    b70a:	e8 01 8e ff ff       	callq  4510 <pthread_mutex_unlock@plt>
    b70f:	48 8d 35 c7 60 02 00 	lea    0x260c7(%rip),%rsi        # 317dd <__func__.5785+0xb75>
    b716:	89 c7                	mov    %eax,%edi
    b718:	e8 74 fd ff ff       	callq  b491 <pc_safe_call>
			sleep(1);
    b71d:	bf 01 00 00 00       	mov    $0x1,%edi
    b722:	e8 d9 8d ff ff       	callq  4500 <sleep@plt>
    b727:	eb f4                	jmp    b71d <posix_soc_clean_up+0x82>
}
    b729:	58                   	pop    %rax
    b72a:	c3                   	retq   

000000000000b72b <hwm_signal_end_handler>:
/**
 * Handler for SIGTERM and SIGINT
 */
void hwm_signal_end_handler(int sig)
{
	signaled_end = 1;
    b72b:	c7 05 43 39 25 00 01 	movl   $0x1,0x253943(%rip)        # 25f078 <signaled_end>
    b732:	00 00 00 
}
    b735:	c3                   	retq   

000000000000b736 <hwm_set_sig_handler>:
 *
 * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or
 * _XOPEN_SOURCE>=500
 */
void hwm_set_sig_handler(void)
{
    b736:	53                   	push   %rbx
    b737:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
    b73e:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    b745:	00 00 
    b747:	48 89 84 24 98 00 00 	mov    %rax,0x98(%rsp)
    b74e:	00 
    b74f:	31 c0                	xor    %eax,%eax
	struct sigaction act;

	act.sa_handler = hwm_signal_end_handler;
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
    b751:	48 89 e3             	mov    %rsp,%rbx
	act.sa_handler = hwm_signal_end_handler;
    b754:	48 8d 05 d0 ff ff ff 	lea    -0x30(%rip),%rax        # b72b <hwm_signal_end_handler>
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
    b75b:	48 8d 7b 08          	lea    0x8(%rbx),%rdi
	act.sa_handler = hwm_signal_end_handler;
    b75f:	48 89 04 24          	mov    %rax,(%rsp)
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
    b763:	e8 18 8f ff ff       	callq  4680 <sigemptyset@plt>
	if (unlikely(test)) {
    b768:	85 c0                	test   %eax,%eax
    b76a:	74 15                	je     b781 <hwm_set_sig_handler+0x4b>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    b76c:	48 8d 35 e6 60 02 00 	lea    0x260e6(%rip),%rsi        # 31859 <__func__.5785+0xbf1>
    b773:	48 8d 3d 3d 5d 02 00 	lea    0x25d3d(%rip),%rdi        # 314b7 <__func__.5785+0x84f>
    b77a:	31 c0                	xor    %eax,%eax
    b77c:	e8 41 0b 00 00       	callq  c2c2 <posix_print_error_and_exit>

	act.sa_flags = SA_RESETHAND;

	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
    b781:	31 d2                	xor    %edx,%edx
    b783:	48 89 de             	mov    %rbx,%rsi
    b786:	bf 0f 00 00 00       	mov    $0xf,%edi
	act.sa_flags = SA_RESETHAND;
    b78b:	c7 84 24 88 00 00 00 	movl   $0x80000000,0x88(%rsp)
    b792:	00 00 00 80 
	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
    b796:	e8 f5 8e ff ff       	callq  4690 <sigaction@plt>
	if (unlikely(test)) {
    b79b:	85 c0                	test   %eax,%eax
    b79d:	74 15                	je     b7b4 <hwm_set_sig_handler+0x7e>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    b79f:	48 8d 35 cd 60 02 00 	lea    0x260cd(%rip),%rsi        # 31873 <__func__.5785+0xc0b>
    b7a6:	48 8d 3d 0a 5d 02 00 	lea    0x25d0a(%rip),%rdi        # 314b7 <__func__.5785+0x84f>
    b7ad:	31 c0                	xor    %eax,%eax
    b7af:	e8 0e 0b 00 00       	callq  c2c2 <posix_print_error_and_exit>
	PC_SAFE_CALL(sigaction(SIGINT, &act, NULL));
    b7b4:	31 d2                	xor    %edx,%edx
    b7b6:	48 89 de             	mov    %rbx,%rsi
    b7b9:	bf 02 00 00 00       	mov    $0x2,%edi
    b7be:	e8 cd 8e ff ff       	callq  4690 <sigaction@plt>
	if (unlikely(test)) {
    b7c3:	85 c0                	test   %eax,%eax
    b7c5:	74 15                	je     b7dc <hwm_set_sig_handler+0xa6>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    b7c7:	48 8d 35 c4 60 02 00 	lea    0x260c4(%rip),%rsi        # 31892 <__func__.5785+0xc2a>
    b7ce:	48 8d 3d e2 5c 02 00 	lea    0x25ce2(%rip),%rdi        # 314b7 <__func__.5785+0x84f>
    b7d5:	31 c0                	xor    %eax,%eax
    b7d7:	e8 e6 0a 00 00       	callq  c2c2 <posix_print_error_and_exit>
}
    b7dc:	48 8b 84 24 98 00 00 	mov    0x98(%rsp),%rax
    b7e3:	00 
    b7e4:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    b7eb:	00 00 
    b7ed:	74 05                	je     b7f4 <hwm_set_sig_handler+0xbe>
    b7ef:	e8 4c 8e ff ff       	callq  4640 <__stack_chk_fail@plt>
    b7f4:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
    b7fb:	5b                   	pop    %rbx
    b7fc:	c3                   	retq   

000000000000b7fd <hwm_find_next_timer>:
 * and update  next_timer_* accordingly
 */
void hwm_find_next_timer(void)
{
	next_timer_index = 0;
	next_timer_time  = *Timer_list[0];
    b7fd:	48 8d 05 34 c7 24 00 	lea    0x24c734(%rip),%rax        # 257f38 <hw_timer_timer>

	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
		if (next_timer_time > *Timer_list[i]) {
    b804:	48 8d 15 5d b2 22 00 	lea    0x22b25d(%rip),%rdx        # 236a68 <irq_ctrl_timer>
	next_timer_index = 0;
    b80b:	c7 05 9b b2 22 00 00 	movl   $0x0,0x22b29b(%rip)        # 236ab0 <next_timer_index>
    b812:	00 00 00 
	next_timer_time  = *Timer_list[0];
    b815:	48 8b 00             	mov    (%rax),%rax
		if (next_timer_time > *Timer_list[i]) {
    b818:	48 8b 12             	mov    (%rdx),%rdx
    b81b:	48 39 d0             	cmp    %rdx,%rax
	next_timer_time  = *Timer_list[0];
    b81e:	48 89 05 cb c6 24 00 	mov    %rax,0x24c6cb(%rip)        # 257ef0 <next_timer_time>
		if (next_timer_time > *Timer_list[i]) {
    b825:	76 0c                	jbe    b833 <hwm_find_next_timer+0x36>
    b827:	48 89 d0             	mov    %rdx,%rax
    b82a:	b1 01                	mov    $0x1,%cl
	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
    b82c:	ba 01 00 00 00       	mov    $0x1,%edx
    b831:	eb 04                	jmp    b837 <hwm_find_next_timer+0x3a>
		if (next_timer_time > *Timer_list[i]) {
    b833:	31 d2                	xor    %edx,%edx
    b835:	31 c9                	xor    %ecx,%ecx
    b837:	48 8d 35 4a c7 24 00 	lea    0x24c74a(%rip),%rsi        # 257f88 <hw_counter_timer>
    b83e:	48 8b 36             	mov    (%rsi),%rsi
    b841:	48 39 f0             	cmp    %rsi,%rax
    b844:	76 0a                	jbe    b850 <hwm_find_next_timer+0x53>
    b846:	48 89 f0             	mov    %rsi,%rax
	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
    b849:	ba 02 00 00 00       	mov    $0x2,%edx
		if (next_timer_time > *Timer_list[i]) {
    b84e:	b1 01                	mov    $0x1,%cl
    b850:	48 8d 35 39 c7 24 00 	lea    0x24c739(%rip),%rsi        # 257f90 <sdl_event_timer>
    b857:	48 8b 36             	mov    (%rsi),%rsi
    b85a:	48 39 c6             	cmp    %rax,%rsi
    b85d:	72 06                	jb     b865 <hwm_find_next_timer+0x68>
    b85f:	84 c9                	test   %cl,%cl
    b861:	74 17                	je     b87a <hwm_find_next_timer+0x7d>
    b863:	eb 08                	jmp    b86d <hwm_find_next_timer+0x70>
    b865:	48 89 f0             	mov    %rsi,%rax
	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
    b868:	ba 03 00 00 00       	mov    $0x3,%edx
    b86d:	48 89 05 7c c6 24 00 	mov    %rax,0x24c67c(%rip)        # 257ef0 <next_timer_time>
    b874:	89 15 36 b2 22 00    	mov    %edx,0x22b236(%rip)        # 236ab0 <next_timer_index>
			next_timer_index = i;
			next_timer_time = *Timer_list[i];
		}
	}
}
    b87a:	c3                   	retq   

000000000000b87b <hwm_main_loop>:
/**
 * Entry point for the HW models
 * The HW models execute in an infinite loop until terminated
 */
void hwm_main_loop(void)
{
    b87b:	48 83 ec 18          	sub    $0x18,%rsp
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
    b87f:	48 8b 35 6a c6 24 00 	mov    0x24c66a(%rip),%rsi        # 257ef0 <next_timer_time>
    b886:	48 8b 15 6b c6 24 00 	mov    0x24c66b(%rip),%rdx        # 257ef8 <simu_time>
    b88d:	48 39 d6             	cmp    %rdx,%rsi
    b890:	72 09                	jb     b89b <hwm_main_loop+0x20>
		simu_time = next_timer_time;
    b892:	48 89 35 5f c6 24 00 	mov    %rsi,0x24c65f(%rip)        # 257ef8 <simu_time>
    b899:	eb 14                	jmp    b8af <hwm_main_loop+0x34>
		posix_print_warning("next_timer_time corrupted (%"PRIu64"<= %"
    b89b:	8b 0d 0f b2 22 00    	mov    0x22b20f(%rip),%ecx        # 236ab0 <next_timer_index>
    b8a1:	48 8d 3d 08 60 02 00 	lea    0x26008(%rip),%rdi        # 318b0 <__func__.5785+0xc48>
    b8a8:	31 c0                	xor    %eax,%eax
    b8aa:	e8 e5 0a 00 00       	callq  c394 <posix_print_warning>
	if (signaled_end || (simu_time > end_of_time)) {
    b8af:	8b 15 c3 37 25 00    	mov    0x2537c3(%rip),%edx        # 25f078 <signaled_end>
    b8b5:	48 8b 05 3c c6 24 00 	mov    0x24c63c(%rip),%rax        # 257ef8 <simu_time>
    b8bc:	85 d2                	test   %edx,%edx
    b8be:	75 09                	jne    b8c9 <hwm_main_loop+0x4e>
    b8c0:	48 39 05 91 b1 22 00 	cmp    %rax,0x22b191(%rip)        # 236a58 <end_of_time>
    b8c7:	73 38                	jae    b901 <hwm_main_loop+0x86>
				((long double)simu_time)/1.0e6);
    b8c9:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    b8ce:	48 85 c0             	test   %rax,%rax
    b8d1:	df 6c 24 08          	fildll 0x8(%rsp)
    b8d5:	79 06                	jns    b8dd <hwm_main_loop+0x62>
    b8d7:	d8 05 4b 54 02 00    	fadds  0x2544b(%rip)        # 30d28 <__func__.5785+0xc0>
		posix_print_trace("\nStopped at %.3Lfs\n",
    b8dd:	d8 35 49 54 02 00    	fdivs  0x25449(%rip)        # 30d2c <__func__.5785+0xc4>
    b8e3:	48 8d 3d fb 5f 02 00 	lea    0x25ffb(%rip),%rdi        # 318e5 <__func__.5785+0xc7d>
    b8ea:	48 83 ec 10          	sub    $0x10,%rsp
    b8ee:	31 c0                	xor    %eax,%eax
    b8f0:	db 3c 24             	fstpt  (%rsp)
    b8f3:	e8 64 0b 00 00       	callq  c45c <posix_print_trace>
		posix_exit(0);
    b8f8:	31 ff                	xor    %edi,%edi
		posix_print_trace("\nStopped at %.3Lfs\n",
    b8fa:	58                   	pop    %rax
    b8fb:	5a                   	pop    %rdx
		posix_exit(0);
    b8fc:	e8 d7 08 00 00       	callq  c1d8 <posix_exit>
	while (1) {
		hwm_sleep_until_next_timer();

		switch (next_timer_index) { /* LCOV_EXCL_BR_LINE */
    b901:	8b 05 a9 b1 22 00    	mov    0x22b1a9(%rip),%eax        # 236ab0 <next_timer_index>
    b907:	83 f8 01             	cmp    $0x1,%eax
    b90a:	74 1a                	je     b926 <hwm_main_loop+0xab>
    b90c:	72 11                	jb     b91f <hwm_main_loop+0xa4>
    b90e:	83 f8 02             	cmp    $0x2,%eax
    b911:	74 1a                	je     b92d <hwm_main_loop+0xb2>
    b913:	83 f8 03             	cmp    $0x3,%eax
    b916:	75 1c                	jne    b934 <hwm_main_loop+0xb9>
		case HW_COUNTER:
			hw_counter_triggered();
			break;
#ifdef CONFIG_HAS_SDL
		case SDLEVENTTIMER:
			sdl_handle_events();
    b918:	e8 0d 16 00 00       	callq  cf2a <sdl_handle_events>
			break;
    b91d:	eb 23                	jmp    b942 <hwm_main_loop+0xc7>
			hwtimer_timer_reached();
    b91f:	e8 f2 02 00 00       	callq  bc16 <hwtimer_timer_reached>
			break;
    b924:	eb 1c                	jmp    b942 <hwm_main_loop+0xc7>
			hw_irq_ctrl_timer_triggered();
    b926:	e8 9a 08 00 00       	callq  c1c5 <hw_irq_ctrl_timer_triggered>
			break;
    b92b:	eb 15                	jmp    b942 <hwm_main_loop+0xc7>
			hw_counter_triggered();
    b92d:	e8 78 15 00 00       	callq  ceaa <hw_counter_triggered>
			break;
    b932:	eb 0e                	jmp    b942 <hwm_main_loop+0xc7>
#endif
		default:
			/* LCOV_EXCL_START */
			posix_print_error_and_exit(
    b934:	48 8d 3d be 5f 02 00 	lea    0x25fbe(%rip),%rdi        # 318f9 <__func__.5785+0xc91>
    b93b:	31 c0                	xor    %eax,%eax
    b93d:	e8 80 09 00 00       	callq  c2c2 <posix_print_error_and_exit>
					"next_timer_index corrupted\n");
			break;
			/* LCOV_EXCL_STOP */
		}

		hwm_find_next_timer();
    b942:	e8 b6 fe ff ff       	callq  b7fd <hwm_find_next_timer>
		hwm_sleep_until_next_timer();
    b947:	e9 33 ff ff ff       	jmpq   b87f <hwm_main_loop+0x4>

000000000000b94c <hwm_set_end_of_time>:
/**
 * Set the simulated time when the process will stop
 */
void hwm_set_end_of_time(uint64_t new_end_of_time)
{
	end_of_time = new_end_of_time;
    b94c:	48 89 3d 05 b1 22 00 	mov    %rdi,0x22b105(%rip)        # 236a58 <end_of_time>
}
    b953:	c3                   	retq   

000000000000b954 <hwm_get_time>:
 * Return the current time as known by the device
 */
uint64_t hwm_get_time(void)
{
	return simu_time;
}
    b954:	48 8b 05 9d c5 24 00 	mov    0x24c59d(%rip),%rax        # 257ef8 <simu_time>
    b95b:	c3                   	retq   

000000000000b95c <hwm_init>:

/**
 * Function to initialize the HW models
 */
void hwm_init(void)
{
    b95c:	48 83 ec 08          	sub    $0x8,%rsp
	hwm_set_sig_handler();
    b960:	e8 d1 fd ff ff       	callq  b736 <hwm_set_sig_handler>
	hwtimer_init();
    b965:	e8 78 01 00 00       	callq  bae2 <hwtimer_init>
	hw_counter_init();
    b96a:	e8 0c 15 00 00       	callq  ce7b <hw_counter_init>
	hw_irq_ctrl_init();
    b96f:	e8 bb 06 00 00       	callq  c02f <hw_irq_ctrl_init>

	hwm_find_next_timer();
}
    b974:	58                   	pop    %rax
	hwm_find_next_timer();
    b975:	e9 83 fe ff ff       	jmpq   b7fd <hwm_find_next_timer>

000000000000b97a <hwm_cleanup>:
 * Function to free any resources allocated by the HW models
 * Note that this function needs to be designed so it is possible
 * to call it more than once during cleanup
 */
void hwm_cleanup(void)
{
    b97a:	48 83 ec 08          	sub    $0x8,%rsp
	hwtimer_cleanup();
    b97e:	e8 66 02 00 00       	callq  bbe9 <hwtimer_cleanup>
	hw_irq_ctrl_cleanup();
}
    b983:	58                   	pop    %rax
	hw_irq_ctrl_cleanup();
    b984:	e9 e1 06 00 00       	jmpq   c06a <hw_irq_ctrl_cleanup>

000000000000b989 <hwtimer_update_timer>:
	real_time_mode = new_rt;
}

static void hwtimer_update_timer(void)
{
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
    b989:	48 8d 15 98 c5 24 00 	lea    0x24c598(%rip),%rdx        # 257f28 <hw_timer_awake_timer>
    b990:	48 8d 05 99 c5 24 00 	lea    0x24c599(%rip),%rax        # 257f30 <hw_timer_tick_timer>
    b997:	48 8b 00             	mov    (%rax),%rax
    b99a:	48 39 02             	cmp    %rax,(%rdx)
    b99d:	48 0f 46 02          	cmovbe (%rdx),%rax
    b9a1:	48 8d 15 90 c5 24 00 	lea    0x24c590(%rip),%rdx        # 257f38 <hw_timer_timer>
    b9a8:	48 89 02             	mov    %rax,(%rdx)
}
    b9ab:	c3                   	retq   

000000000000b9ac <native_add_time_options>:
		(void *)&args.stop_at, cmd_stop_at_found,
		"In simulated seconds, when to stop automatically"},

		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(timer_options);
    b9ac:	48 8d 3d ed a8 22 00 	lea    0x22a8ed(%rip),%rdi        # 2362a0 <timer_options.3127>
    b9b3:	e9 49 13 00 00       	jmpq   cd01 <native_add_command_line_opts>

000000000000b9b8 <cmd_stop_at_found>:
	if (args.stop_at < 0) {
    b9b8:	0f 57 c0             	xorps  %xmm0,%xmm0
{
    b9bb:	48 83 ec 08          	sub    $0x8,%rsp
	if (args.stop_at < 0) {
    b9bf:	66 0f 2e 05 f9 b0 24 	ucomisd 0x24b0f9(%rip),%xmm0        # 256ac0 <args>
    b9c6:	00 
    b9c7:	76 11                	jbe    b9da <cmd_stop_at_found+0x22>
    b9c9:	48 89 fe             	mov    %rdi,%rsi
		posix_print_error_and_exit("Error: stop-at must be positive "
    b9cc:	48 8d 3d 42 5f 02 00 	lea    0x25f42(%rip),%rdi        # 31915 <__func__.5785+0xcad>
    b9d3:	31 c0                	xor    %eax,%eax
    b9d5:	e8 e8 08 00 00       	callq  c2c2 <posix_print_error_and_exit>
	hwm_set_end_of_time(args.stop_at*1e6);
    b9da:	f2 0f 10 05 ae 51 02 	movsd  0x251ae(%rip),%xmm0        # 30b90 <__func__.9913+0x10>
    b9e1:	00 
    b9e2:	f2 0f 10 0d ae 51 02 	movsd  0x251ae(%rip),%xmm1        # 30b98 <__func__.9913+0x18>
    b9e9:	00 
    b9ea:	f2 0f 59 05 ce b0 24 	mulsd  0x24b0ce(%rip),%xmm0        # 256ac0 <args>
    b9f1:	00 
    b9f2:	66 0f 2e c1          	ucomisd %xmm1,%xmm0
    b9f6:	73 07                	jae    b9ff <cmd_stop_at_found+0x47>
    b9f8:	f2 48 0f 2c f8       	cvttsd2si %xmm0,%rdi
    b9fd:	eb 16                	jmp    ba15 <cmd_stop_at_found+0x5d>
    b9ff:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    ba03:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
    ba0a:	00 00 80 
    ba0d:	f2 48 0f 2c f8       	cvttsd2si %xmm0,%rdi
    ba12:	48 31 c7             	xor    %rax,%rdi
}
    ba15:	58                   	pop    %rax
	hwm_set_end_of_time(args.stop_at*1e6);
    ba16:	e9 31 ff ff ff       	jmpq   b94c <hwm_set_end_of_time>

000000000000ba1b <hwtimer_set_real_time_mode>:
	real_time_mode = new_rt;
    ba1b:	40 88 3d fc b0 22 00 	mov    %dil,0x22b0fc(%rip)        # 236b1e <real_time_mode>
}
    ba22:	c3                   	retq   

000000000000ba23 <cmd_no_realtime_found>:
	hwtimer_set_real_time_mode(false);
    ba23:	31 ff                	xor    %edi,%edi
    ba25:	e9 f1 ff ff ff       	jmpq   ba1b <hwtimer_set_real_time_mode>

000000000000ba2a <cmd_realtime_found>:
	hwtimer_set_real_time_mode(true);
    ba2a:	bf 01 00 00 00       	mov    $0x1,%edi
    ba2f:	e9 e7 ff ff ff       	jmpq   ba1b <hwtimer_set_real_time_mode>

000000000000ba34 <get_host_us_time>:
{
    ba34:	48 83 ec 28          	sub    $0x28,%rsp
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
    ba38:	bf 04 00 00 00       	mov    $0x4,%edi
    ba3d:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
{
    ba42:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    ba49:	00 00 
    ba4b:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    ba50:	31 c0                	xor    %eax,%eax
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
    ba52:	e8 69 8b ff ff       	callq  45c0 <clock_gettime@plt>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
    ba57:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    ba5c:	48 85 d2             	test   %rdx,%rdx
    ba5f:	78 07                	js     ba68 <get_host_us_time+0x34>
    ba61:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
    ba66:	eb 15                	jmp    ba7d <get_host_us_time+0x49>
    ba68:	48 89 d0             	mov    %rdx,%rax
    ba6b:	83 e2 01             	and    $0x1,%edx
    ba6e:	48 d1 e8             	shr    %rax
    ba71:	48 09 d0             	or     %rdx,%rax
    ba74:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    ba79:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
    ba7d:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
    ba82:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
    ba87:	f2 0f 59 05 01 51 02 	mulsd  0x25101(%rip),%xmm0        # 30b90 <__func__.9913+0x10>
    ba8e:	00 
    ba8f:	48 99                	cqto   
    ba91:	48 f7 f9             	idiv   %rcx
    ba94:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
    ba99:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
    ba9d:	f2 0f 10 0d f3 50 02 	movsd  0x250f3(%rip),%xmm1        # 30b98 <__func__.9913+0x18>
    baa4:	00 
    baa5:	66 0f 2e c1          	ucomisd %xmm1,%xmm0
    baa9:	73 07                	jae    bab2 <get_host_us_time+0x7e>
    baab:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    bab0:	eb 16                	jmp    bac8 <get_host_us_time+0x94>
    bab2:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    bab6:	48 ba 00 00 00 00 00 	movabs $0x8000000000000000,%rdx
    babd:	00 00 80 
    bac0:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    bac5:	48 31 d0             	xor    %rdx,%rax
}
    bac8:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
    bacd:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
    bad4:	00 00 
    bad6:	74 05                	je     badd <get_host_us_time+0xa9>
    bad8:	e8 63 8b ff ff       	callq  4640 <__stack_chk_fail@plt>
    badd:	48 83 c4 28          	add    $0x28,%rsp
    bae1:	c3                   	retq   

000000000000bae2 <hwtimer_init>:
{
    bae2:	48 83 ec 28          	sub    $0x28,%rsp
	hw_timer_tick_timer = NEVER;
    bae6:	48 8d 15 43 c4 24 00 	lea    0x24c443(%rip),%rdx        # 257f30 <hw_timer_tick_timer>
	silent_ticks = 0;
    baed:	48 c7 05 20 c4 24 00 	movq   $0x0,0x24c420(%rip)        # 257f18 <silent_ticks>
    baf4:	00 00 00 00 
{
    baf8:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    baff:	00 00 
    bb01:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    bb06:	31 c0                	xor    %eax,%eax
	hw_timer_tick_timer = NEVER;
    bb08:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
    bb0c:	48 89 02             	mov    %rax,(%rdx)
	hw_timer_awake_timer = NEVER;
    bb0f:	48 8d 15 12 c4 24 00 	lea    0x24c412(%rip),%rdx        # 257f28 <hw_timer_awake_timer>
    bb16:	48 89 02             	mov    %rax,(%rdx)
	hwtimer_update_timer();
    bb19:	e8 6b fe ff ff       	callq  b989 <hwtimer_update_timer>
	if (real_time_mode) {
    bb1e:	80 3d f9 af 22 00 00 	cmpb   $0x0,0x22aff9(%rip)        # 236b1e <real_time_mode>
    bb25:	74 17                	je     bb3e <hwtimer_init+0x5c>
		boot_time = get_host_us_time();
    bb27:	e8 08 ff ff ff       	callq  ba34 <get_host_us_time>
		last_radj_stime = 0U;
    bb2c:	48 c7 05 c9 c3 24 00 	movq   $0x0,0x24c3c9(%rip)        # 257f00 <last_radj_stime>
    bb33:	00 00 00 00 
		last_radj_rtime = boot_time;
    bb37:	48 89 05 ca c3 24 00 	mov    %rax,0x24c3ca(%rip)        # 257f08 <last_radj_rtime>
	if (!reset_rtc) {
    bb3e:	80 3d a1 35 25 00 00 	cmpb   $0x0,0x2535a1(%rip)        # 25f0e6 <reset_rtc>
    bb45:	0f 85 84 00 00 00    	jne    bbcf <hwtimer_init+0xed>
		clock_gettime(CLOCK_REALTIME, &tv);
    bb4b:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    bb50:	31 ff                	xor    %edi,%edi
    bb52:	e8 69 8a ff ff       	callq  45c0 <clock_gettime@plt>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
    bb57:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    bb5c:	48 85 d2             	test   %rdx,%rdx
    bb5f:	78 07                	js     bb68 <hwtimer_init+0x86>
    bb61:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
    bb66:	eb 15                	jmp    bb7d <hwtimer_init+0x9b>
    bb68:	48 89 d0             	mov    %rdx,%rax
    bb6b:	83 e2 01             	and    $0x1,%edx
    bb6e:	48 d1 e8             	shr    %rax
    bb71:	48 09 d0             	or     %rdx,%rax
    bb74:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    bb79:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
    bb7d:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
    bb82:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
    bb87:	f2 0f 59 05 01 50 02 	mulsd  0x25001(%rip),%xmm0        # 30b90 <__func__.9913+0x10>
    bb8e:	00 
    bb8f:	48 99                	cqto   
    bb91:	48 f7 f9             	idiv   %rcx
    bb94:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
    bb99:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
    bb9d:	f2 0f 10 0d f3 4f 02 	movsd  0x24ff3(%rip),%xmm1        # 30b98 <__func__.9913+0x18>
    bba4:	00 
    bba5:	66 0f 2e c1          	ucomisd %xmm1,%xmm0
    bba9:	73 07                	jae    bbb2 <hwtimer_init+0xd0>
    bbab:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    bbb0:	eb 16                	jmp    bbc8 <hwtimer_init+0xe6>
    bbb2:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    bbb6:	48 ba 00 00 00 00 00 	movabs $0x8000000000000000,%rdx
    bbbd:	00 00 80 
    bbc0:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    bbc5:	48 31 d0             	xor    %rdx,%rax
		rtc_offset += realhosttime;
    bbc8:	48 01 05 41 c3 24 00 	add    %rax,0x24c341(%rip)        # 257f10 <rtc_offset>
}
    bbcf:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    bbd4:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    bbdb:	00 00 
    bbdd:	74 05                	je     bbe4 <hwtimer_init+0x102>
    bbdf:	e8 5c 8a ff ff       	callq  4640 <__stack_chk_fail@plt>
    bbe4:	48 83 c4 28          	add    $0x28,%rsp
    bbe8:	c3                   	retq   

000000000000bbe9 <hwtimer_cleanup>:
}
    bbe9:	c3                   	retq   

000000000000bbea <hwtimer_enable>:
{
    bbea:	48 83 ec 08          	sub    $0x8,%rsp
	tick_p = period;
    bbee:	48 89 3d 2b c3 24 00 	mov    %rdi,0x24c32b(%rip)        # 257f20 <tick_p>
	hw_timer_tick_timer = hwm_get_time() + tick_p;
    bbf5:	e8 5a fd ff ff       	callq  b954 <hwm_get_time>
    bbfa:	48 03 05 1f c3 24 00 	add    0x24c31f(%rip),%rax        # 257f20 <tick_p>
    bc01:	48 8d 15 28 c3 24 00 	lea    0x24c328(%rip),%rdx        # 257f30 <hw_timer_tick_timer>
    bc08:	48 89 02             	mov    %rax,(%rdx)
	hwtimer_update_timer();
    bc0b:	e8 79 fd ff ff       	callq  b989 <hwtimer_update_timer>
}
    bc10:	58                   	pop    %rax
	hwm_find_next_timer();
    bc11:	e9 e7 fb ff ff       	jmpq   b7fd <hwm_find_next_timer>

000000000000bc16 <hwtimer_timer_reached>:
{
    bc16:	55                   	push   %rbp
    bc17:	53                   	push   %rbx
    bc18:	48 83 ec 38          	sub    $0x38,%rsp
    bc1c:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    bc23:	00 00 
    bc25:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    bc2a:	31 c0                	xor    %eax,%eax
	uint64_t Now = hw_timer_timer;
    bc2c:	48 8d 05 05 c3 24 00 	lea    0x24c305(%rip),%rax        # 257f38 <hw_timer_timer>
    bc33:	48 8b 18             	mov    (%rax),%rbx
	if (hw_timer_awake_timer == Now) {
    bc36:	48 8d 05 eb c2 24 00 	lea    0x24c2eb(%rip),%rax        # 257f28 <hw_timer_awake_timer>
    bc3d:	48 39 18             	cmp    %rbx,(%rax)
    bc40:	75 16                	jne    bc58 <hwtimer_timer_reached+0x42>
	hw_timer_awake_timer = NEVER;
    bc42:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	hwtimer_update_timer();
    bc49:	e8 3b fd ff ff       	callq  b989 <hwtimer_update_timer>
	hw_irq_ctrl_set_irq(PHONY_HARD_IRQ);
    bc4e:	bf ff ff 00 00       	mov    $0xffff,%edi
    bc53:	e8 fc 04 00 00       	callq  c154 <hw_irq_ctrl_set_irq>
	if (hw_timer_tick_timer == Now) {
    bc58:	48 8d 2d d1 c2 24 00 	lea    0x24c2d1(%rip),%rbp        # 257f30 <hw_timer_tick_timer>
    bc5f:	48 39 5d 00          	cmp    %rbx,0x0(%rbp)
    bc63:	0f 85 1a 01 00 00    	jne    bd83 <hwtimer_timer_reached+0x16d>
	if (real_time_mode) {
    bc69:	80 3d ae ae 22 00 00 	cmpb   $0x0,0x22aeae(%rip)        # 236b1e <real_time_mode>
    bc70:	0f 84 de 00 00 00    	je     bd54 <hwtimer_timer_reached+0x13e>
				    / clock_ratio
    bc76:	48 2b 1d 83 c2 24 00 	sub    0x24c283(%rip),%rbx        # 257f00 <last_radj_stime>
    bc7d:	78 07                	js     bc86 <hwtimer_timer_reached+0x70>
    bc7f:	f2 48 0f 2a c3       	cvtsi2sd %rbx,%xmm0
    bc84:	eb 15                	jmp    bc9b <hwtimer_timer_reached+0x85>
    bc86:	48 89 d8             	mov    %rbx,%rax
    bc89:	83 e3 01             	and    $0x1,%ebx
    bc8c:	48 d1 e8             	shr    %rax
    bc8f:	48 09 d8             	or     %rbx,%rax
    bc92:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    bc97:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
				    + last_radj_rtime;
    bc9b:	48 8b 15 66 c2 24 00 	mov    0x24c266(%rip),%rdx        # 257f08 <last_radj_rtime>
				    / clock_ratio
    bca2:	f2 0f 5e 05 b6 ad 22 	divsd  0x22adb6(%rip),%xmm0        # 236a60 <clock_ratio>
    bca9:	00 
				    + last_radj_rtime;
    bcaa:	48 85 d2             	test   %rdx,%rdx
    bcad:	78 07                	js     bcb6 <hwtimer_timer_reached+0xa0>
    bcaf:	f2 48 0f 2a ca       	cvtsi2sd %rdx,%xmm1
    bcb4:	eb 15                	jmp    bccb <hwtimer_timer_reached+0xb5>
    bcb6:	48 89 d0             	mov    %rdx,%rax
    bcb9:	83 e2 01             	and    $0x1,%edx
    bcbc:	48 d1 e8             	shr    %rax
    bcbf:	48 09 d0             	or     %rdx,%rax
    bcc2:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
    bcc7:	f2 0f 58 c9          	addsd  %xmm1,%xmm1
    bccb:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
    bccf:	f2 0f 10 0d c1 4e 02 	movsd  0x24ec1(%rip),%xmm1        # 30b98 <__func__.9913+0x18>
    bcd6:	00 
    bcd7:	66 0f 2e c1          	ucomisd %xmm1,%xmm0
    bcdb:	73 07                	jae    bce4 <hwtimer_timer_reached+0xce>
    bcdd:	f2 48 0f 2c d8       	cvttsd2si %xmm0,%rbx
    bce2:	eb 16                	jmp    bcfa <hwtimer_timer_reached+0xe4>
    bce4:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    bce8:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
    bcef:	00 00 80 
    bcf2:	f2 48 0f 2c d8       	cvttsd2si %xmm0,%rbx
    bcf7:	48 31 c3             	xor    %rax,%rbx
		uint64_t real_time = get_host_us_time();
    bcfa:	e8 35 fd ff ff       	callq  ba34 <get_host_us_time>
		int64_t diff = expected_rt - real_time;
    bcff:	48 29 c3             	sub    %rax,%rbx
		if (diff > 0) { /* we need to slow down */
    bd02:	48 85 db             	test   %rbx,%rbx
    bd05:	7e 4d                	jle    bd54 <hwtimer_timer_reached+0x13e>
			requested_time.tv_sec  = diff / 1e6;
    bd07:	f2 48 0f 2a c3       	cvtsi2sd %rbx,%xmm0
			(void) nanosleep(&requested_time, &remaining);
    bd0c:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
    bd11:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
			requested_time.tv_sec  = diff / 1e6;
    bd16:	f2 0f 10 1d 72 4e 02 	movsd  0x24e72(%rip),%xmm3        # 30b90 <__func__.9913+0x10>
    bd1d:	00 
    bd1e:	66 0f 28 d0          	movapd %xmm0,%xmm2
    bd22:	f2 0f 5e d3          	divsd  %xmm3,%xmm2
    bd26:	f2 48 0f 2c c2       	cvttsd2si %xmm2,%rax
						 requested_time.tv_sec*1e6)*1e3;
    bd2b:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
			requested_time.tv_sec  = diff / 1e6;
    bd30:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
						 requested_time.tv_sec*1e6)*1e3;
    bd35:	f2 0f 59 cb          	mulsd  %xmm3,%xmm1
			requested_time.tv_nsec = (diff -
    bd39:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
						 requested_time.tv_sec*1e6)*1e3;
    bd3d:	f2 0f 59 05 5b 4e 02 	mulsd  0x24e5b(%rip),%xmm0        # 30ba0 <__func__.9913+0x20>
    bd44:	00 
			requested_time.tv_nsec = (diff -
    bd45:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    bd4a:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
			(void) nanosleep(&requested_time, &remaining);
    bd4f:	e8 9c 86 ff ff       	callq  43f0 <nanosleep@plt>
	hw_timer_tick_timer += tick_p;
    bd54:	48 8b 05 c5 c1 24 00 	mov    0x24c1c5(%rip),%rax        # 257f20 <tick_p>
    bd5b:	48 01 45 00          	add    %rax,0x0(%rbp)
	hwtimer_update_timer();
    bd5f:	e8 25 fc ff ff       	callq  b989 <hwtimer_update_timer>
	if (silent_ticks > 0) {
    bd64:	48 8b 05 ad c1 24 00 	mov    0x24c1ad(%rip),%rax        # 257f18 <silent_ticks>
    bd6b:	48 85 c0             	test   %rax,%rax
    bd6e:	7e 0c                	jle    bd7c <hwtimer_timer_reached+0x166>
		silent_ticks -= 1;
    bd70:	48 ff c8             	dec    %rax
    bd73:	48 89 05 9e c1 24 00 	mov    %rax,0x24c19e(%rip)        # 257f18 <silent_ticks>
    bd7a:	eb 07                	jmp    bd83 <hwtimer_timer_reached+0x16d>
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
    bd7c:	31 ff                	xor    %edi,%edi
    bd7e:	e8 d1 03 00 00       	callq  c154 <hw_irq_ctrl_set_irq>
}
    bd83:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    bd88:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    bd8f:	00 00 
    bd91:	74 05                	je     bd98 <hwtimer_timer_reached+0x182>
    bd93:	e8 a8 88 ff ff       	callq  4640 <__stack_chk_fail@plt>
    bd98:	48 83 c4 38          	add    $0x38,%rsp
    bd9c:	5b                   	pop    %rbx
    bd9d:	5d                   	pop    %rbp
    bd9e:	c3                   	retq   

000000000000bd9f <hwtimer_set_silent_ticks>:
	silent_ticks = sys_ticks;
    bd9f:	48 89 3d 72 c1 24 00 	mov    %rdi,0x24c172(%rip)        # 257f18 <silent_ticks>
}
    bda6:	c3                   	retq   

000000000000bda7 <hwtimer_reset_rtc>:
	reset_rtc = true;
    bda7:	c6 05 38 33 25 00 01 	movb   $0x1,0x253338(%rip)        # 25f0e6 <reset_rtc>
}
    bdae:	c3                   	retq   

000000000000bdaf <cmd_rtcreset_found>:
	hwtimer_reset_rtc();
    bdaf:	e9 f3 ff ff ff       	jmpq   bda7 <hwtimer_reset_rtc>

000000000000bdb4 <hwtimer_set_rtc_offset>:
	rtc_offset = offset;
    bdb4:	48 89 3d 55 c1 24 00 	mov    %rdi,0x24c155(%rip)        # 257f10 <rtc_offset>
}
    bdbb:	c3                   	retq   

000000000000bdbc <cmd_rtcoffset_found>:
	hwtimer_set_rtc_offset(args.rtc_offset*1e6);
    bdbc:	f2 0f 10 05 cc 4d 02 	movsd  0x24dcc(%rip),%xmm0        # 30b90 <__func__.9913+0x10>
    bdc3:	00 
    bdc4:	f2 0f 59 05 fc ac 24 	mulsd  0x24acfc(%rip),%xmm0        # 256ac8 <args+0x8>
    bdcb:	00 
    bdcc:	f2 48 0f 2c f8       	cvttsd2si %xmm0,%rdi
    bdd1:	e9 de ff ff ff       	jmpq   bdb4 <hwtimer_set_rtc_offset>

000000000000bdd6 <hwtimer_set_rt_ratio>:
	clock_ratio = ratio;
    bdd6:	f2 0f 11 05 82 ac 22 	movsd  %xmm0,0x22ac82(%rip)        # 236a60 <clock_ratio>
    bddd:	00 
}
    bdde:	c3                   	retq   

000000000000bddf <cmd_rt_ratio_found>:
	if ((args.rt_ratio <= 0)) {
    bddf:	0f 57 c0             	xorps  %xmm0,%xmm0
    bde2:	66 0f 2e 05 ee ac 24 	ucomisd 0x24acee(%rip),%xmm0        # 256ad8 <args+0x18>
    bde9:	00 
    bdea:	72 1d                	jb     be09 <cmd_rt_ratio_found+0x2a>
		posix_print_error_and_exit("The ratio needs to be > 0. "
    bdec:	48 8d 3d 48 5b 02 00 	lea    0x25b48(%rip),%rdi        # 3193b <__func__.5785+0xcd3>
{
    bdf3:	48 83 ec 08          	sub    $0x8,%rsp
		posix_print_error_and_exit("The ratio needs to be > 0. "
    bdf7:	31 c0                	xor    %eax,%eax
    bdf9:	e8 c4 04 00 00       	callq  c2c2 <posix_print_error_and_exit>
	hwtimer_set_rt_ratio(args.rt_ratio);
    bdfe:	f2 0f 10 05 d2 ac 24 	movsd  0x24acd2(%rip),%xmm0        # 256ad8 <args+0x18>
    be05:	00 
}
    be06:	58                   	pop    %rax
    be07:	eb 08                	jmp    be11 <cmd_rt_ratio_found+0x32>
	hwtimer_set_rt_ratio(args.rt_ratio);
    be09:	f2 0f 10 05 c7 ac 24 	movsd  0x24acc7(%rip),%xmm0        # 256ad8 <args+0x18>
    be10:	00 
    be11:	e9 c0 ff ff ff       	jmpq   bdd6 <hwtimer_set_rt_ratio>

000000000000be16 <cmd_rt_drift_found>:
{
    be16:	48 83 ec 08          	sub    $0x8,%rsp
	if (!(args.rt_drift > -1)) {
    be1a:	f2 0f 10 05 ae ac 24 	movsd  0x24acae(%rip),%xmm0        # 256ad0 <args+0x10>
    be21:	00 
    be22:	66 0f 2e 05 7e 4d 02 	ucomisd 0x24d7e(%rip),%xmm0        # 30ba8 <__func__.9913+0x28>
    be29:	00 
    be2a:	77 0e                	ja     be3a <cmd_rt_drift_found+0x24>
		posix_print_error_and_exit("The drift needs to be > -1. "
    be2c:	48 8d 3d 44 5b 02 00 	lea    0x25b44(%rip),%rdi        # 31977 <__func__.5785+0xd0f>
    be33:	31 c0                	xor    %eax,%eax
    be35:	e8 88 04 00 00       	callq  c2c2 <posix_print_error_and_exit>
	args.rt_ratio = args.rt_drift + 1;
    be3a:	f2 0f 10 05 6e 4d 02 	movsd  0x24d6e(%rip),%xmm0        # 30bb0 <__func__.9913+0x30>
    be41:	00 
    be42:	f2 0f 58 05 86 ac 24 	addsd  0x24ac86(%rip),%xmm0        # 256ad0 <args+0x10>
    be49:	00 
    be4a:	f2 0f 11 05 86 ac 24 	movsd  %xmm0,0x24ac86(%rip)        # 256ad8 <args+0x18>
    be51:	00 
}
    be52:	58                   	pop    %rax
	hwtimer_set_rt_ratio(args.rt_ratio);
    be53:	e9 7e ff ff ff       	jmpq   bdd6 <hwtimer_set_rt_ratio>

000000000000be58 <posix_irq_handler>:
 * Note that even that this function is executing in a Zephyr thread,  it is
 * effectively the model of the interrupt controller passing context to the IRQ
 * handler and therefore its priority handling
 */
void posix_irq_handler(void)
{
    be58:	41 56                	push   %r14
    be5a:	41 55                	push   %r13
    be5c:	41 54                	push   %r12
    be5e:	55                   	push   %rbp
    be5f:	53                   	push   %rbx
	uint64_t irq_lock;
	int irq_nbr;
	static int may_swap;

	irq_lock = hw_irq_ctrl_get_current_lock();
    be60:	e8 2f 02 00 00       	callq  c094 <hw_irq_ctrl_get_current_lock>

	if (irq_lock) {
    be65:	85 c0                	test   %eax,%eax
    be67:	0f 85 eb 00 00 00    	jne    bf58 <posix_irq_handler+0x100>
		/* "spurious" wakes can happen with interrupts locked */
		return;
	}

	if (_kernel.cpus[0].nested == 0) {
    be6d:	48 8d 1d cc bc 24 00 	lea    0x24bccc(%rip),%rbx        # 257b40 <_kernel>
    be74:	8b 03                	mov    (%rbx),%eax
    be76:	85 c0                	test   %eax,%eax
    be78:	75 0a                	jne    be84 <posix_irq_handler+0x2c>
		may_swap = 0;
    be7a:	c7 05 f8 31 25 00 00 	movl   $0x0,0x2531f8(%rip)        # 25f07c <may_swap.4990>
    be81:	00 00 00 
	}

	_kernel.cpus[0].nested++;
    be84:	ff c0                	inc    %eax
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
    be86:	48 8d 2d 53 ac 24 00 	lea    0x24ac53(%rip),%rbp        # 256ae0 <irq_vector_table>
	_kernel.cpus[0].nested++;
    be8d:	89 03                	mov    %eax,(%rbx)

	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
    be8f:	e8 3a 02 00 00       	callq  c0ce <hw_irq_ctrl_get_highest_prio_irq>
    be94:	83 f8 ff             	cmp    $0xffffffff,%eax
    be97:	41 89 c6             	mov    %eax,%r14d
    be9a:	0f 84 88 00 00 00    	je     bf28 <posix_irq_handler+0xd0>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
    bea0:	e8 cd 01 00 00       	callq  c072 <hw_irq_ctrl_get_cur_prio>
		int last_running_irq = currently_running_irq;

		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
    bea5:	44 89 f7             	mov    %r14d,%edi
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
    bea8:	41 89 c4             	mov    %eax,%r12d
		int last_running_irq = currently_running_irq;
    beab:	44 8b 2d 02 ac 22 00 	mov    0x22ac02(%rip),%r13d        # 236ab4 <currently_running_irq>
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
    beb2:	e8 d0 01 00 00       	callq  c087 <hw_irq_ctrl_get_prio>
    beb7:	0f b6 f8             	movzbl %al,%edi
    beba:	e8 ac 01 00 00       	callq  c06b <hw_irq_ctrl_set_cur_prio>
		hw_irq_ctrl_clear_irq(irq_nbr);
    bebf:	44 89 f7             	mov    %r14d,%edi
    bec2:	e8 71 02 00 00       	callq  c138 <hw_irq_ctrl_clear_irq>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
    bec7:	49 63 c6             	movslq %r14d,%rax

		currently_running_irq = irq_nbr;
    beca:	44 89 35 e3 ab 22 00 	mov    %r14d,0x22abe3(%rip)        # 236ab4 <currently_running_irq>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
    bed1:	48 6b c0 18          	imul   $0x18,%rax,%rax
    bed5:	48 01 e8             	add    %rbp,%rax
    bed8:	48 8b 50 08          	mov    0x8(%rax),%rdx
    bedc:	48 85 d2             	test   %rdx,%rdx
    bedf:	75 13                	jne    bef4 <posix_irq_handler+0x9c>
		posix_print_error_and_exit("Received irq %i without a "
    bee1:	48 8d 3d a5 5e 02 00 	lea    0x25ea5(%rip),%rdi        # 31d8d <__func__.5785+0x1125>
    bee8:	44 89 f6             	mov    %r14d,%esi
    beeb:	31 c0                	xor    %eax,%eax
    beed:	e8 d0 03 00 00       	callq  c2c2 <posix_print_error_and_exit>
    bef2:	eb 20                	jmp    bf14 <posix_irq_handler+0xbc>
		if (irq_vector_table[irq_nbr].flags & ISR_FLAG_DIRECT) {
    bef4:	f6 40 04 01          	testb  $0x1,0x4(%rax)
    bef8:	74 0a                	je     bf04 <posix_irq_handler+0xac>
			*may_swap |= ((direct_irq_f_ptr)
    befa:	ff d2                	callq  *%rdx
    befc:	09 05 7a 31 25 00    	or     %eax,0x25317a(%rip)        # 25f07c <may_swap.4990>
    bf02:	eb 10                	jmp    bf14 <posix_irq_handler+0xbc>
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
    bf04:	48 8b 78 10          	mov    0x10(%rax),%rdi
    bf08:	ff d2                	callq  *%rdx
			*may_swap = 1;
    bf0a:	c7 05 68 31 25 00 01 	movl   $0x1,0x253168(%rip)        # 25f07c <may_swap.4990>
    bf11:	00 00 00 
		vector_to_irq(irq_nbr, &may_swap);
		currently_running_irq = last_running_irq;

		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
    bf14:	44 89 e7             	mov    %r12d,%edi
		currently_running_irq = last_running_irq;
    bf17:	44 89 2d 96 ab 22 00 	mov    %r13d,0x22ab96(%rip)        # 236ab4 <currently_running_irq>
		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
    bf1e:	e8 48 01 00 00       	callq  c06b <hw_irq_ctrl_set_cur_prio>
    bf23:	e9 67 ff ff ff       	jmpq   be8f <posix_irq_handler+0x37>
	}

	_kernel.cpus[0].nested--;
    bf28:	ff 0b                	decl   (%rbx)
	/* Call swap if all the following is true:
	 * 1) may_swap was enabled
	 * 2) We are not nesting irq_handler calls (interrupts)
	 * 3) Next thread to run in the ready queue is not this thread
	 */
	if (may_swap
    bf2a:	83 3d 4b 31 25 00 00 	cmpl   $0x0,0x25314b(%rip)        # 25f07c <may_swap.4990>
    bf31:	74 25                	je     bf58 <posix_irq_handler+0x100>
		&& (hw_irq_ctrl_get_cur_prio() == 256)
    bf33:	e8 3a 01 00 00       	callq  c072 <hw_irq_ctrl_get_cur_prio>
    bf38:	3d 00 01 00 00       	cmp    $0x100,%eax
    bf3d:	75 19                	jne    bf58 <posix_irq_handler+0x100>
		&& (_kernel.ready_q.cache != _current)) {
    bf3f:	48 8b 43 10          	mov    0x10(%rbx),%rax
    bf43:	48 39 43 40          	cmp    %rax,0x40(%rbx)
    bf47:	74 0f                	je     bf58 <posix_irq_handler+0x100>

		(void)z_swap_irqlock(irq_lock);
	}
}
    bf49:	5b                   	pop    %rbx
    bf4a:	5d                   	pop    %rbp
    bf4b:	41 5c                	pop    %r12
    bf4d:	41 5d                	pop    %r13
    bf4f:	41 5e                	pop    %r14

static inline int z_swap_irqlock(unsigned int key)
{
	int ret;
	z_check_stack_sentinel();
	ret = arch_swap(key);
    bf51:	31 ff                	xor    %edi,%edi
    bf53:	e9 1f ea ff ff       	jmpq   a977 <arch_swap>
    bf58:	5b                   	pop    %rbx
    bf59:	5d                   	pop    %rbp
    bf5a:	41 5c                	pop    %r12
    bf5c:	41 5d                	pop    %r13
    bf5e:	41 5e                	pop    %r14
    bf60:	c3                   	retq   

000000000000bf61 <posix_irq_handler_im_from_sw>:
 * Thru this function the IRQ controller can raise an immediate  interrupt which
 * will interrupt the SW itself
 * (this function should only be called from the HW model code, from SW threads)
 */
void posix_irq_handler_im_from_sw(void)
{
    bf61:	48 83 ec 08          	sub    $0x8,%rsp
	/*
	 * if a higher priority interrupt than the possibly currently running is
	 * pending we go immediately into irq_handler() to vector into its
	 * handler
	 */
	if (hw_irq_ctrl_get_highest_prio_irq() != -1) {
    bf65:	e8 64 01 00 00       	callq  c0ce <hw_irq_ctrl_get_highest_prio_irq>
    bf6a:	ff c0                	inc    %eax
    bf6c:	74 22                	je     bf90 <posix_irq_handler_im_from_sw+0x2f>
		if (!posix_is_cpu_running()) { /* LCOV_EXCL_BR_LINE */
    bf6e:	e8 73 f5 ff ff       	callq  b4e6 <posix_is_cpu_running>
    bf73:	85 c0                	test   %eax,%eax
    bf75:	75 13                	jne    bf8a <posix_irq_handler_im_from_sw+0x29>
			/* LCOV_EXCL_START */
			posix_print_error_and_exit("programming error: %s "
    bf77:	48 8d 35 82 48 02 00 	lea    0x24882(%rip),%rsi        # 30800 <__func__.4999>
    bf7e:	48 8d 3d 36 5e 02 00 	lea    0x25e36(%rip),%rdi        # 31dbb <__func__.5785+0x1153>
    bf85:	e8 38 03 00 00       	callq  c2c2 <posix_print_error_and_exit>
					__func__);
			/* LCOV_EXCL_STOP */
		}
		posix_irq_handler();
	}
}
    bf8a:	5a                   	pop    %rdx
		posix_irq_handler();
    bf8b:	e9 c8 fe ff ff       	jmpq   be58 <posix_irq_handler>
}
    bf90:	58                   	pop    %rax
    bf91:	c3                   	retq   

000000000000bf92 <posix_irq_lock>:
 * "interrupt disable state" prior to the call.
 *
 */
unsigned int posix_irq_lock(void)
{
	return hw_irq_ctrl_change_lock(true);
    bf92:	bf 01 00 00 00       	mov    $0x1,%edi
    bf97:	e9 00 01 00 00       	jmpq   c09c <hw_irq_ctrl_change_lock>

000000000000bf9c <posix_irq_unlock>:
 * @return N/A
 *
 */
void posix_irq_unlock(unsigned int key)
{
	hw_irq_ctrl_change_lock(key);
    bf9c:	e9 fb 00 00 00       	jmpq   c09c <hw_irq_ctrl_change_lock>

000000000000bfa1 <posix_irq_full_unlock>:
}

void posix_irq_full_unlock(void)
{
	hw_irq_ctrl_change_lock(false);
    bfa1:	31 ff                	xor    %edi,%edi
    bfa3:	e9 f4 00 00 00       	jmpq   c09c <hw_irq_ctrl_change_lock>

000000000000bfa8 <posix_irq_enable>:
}

void posix_irq_enable(unsigned int irq)
{
	hw_irq_ctrl_enable_irq(irq);
    bfa8:	e9 f3 01 00 00       	jmpq   c1a0 <hw_irq_ctrl_enable_irq>

000000000000bfad <posix_isr_declare>:
 * @param flags_p IRQ options
 */
void posix_isr_declare(unsigned int irq_p, int flags, void isr_p(const void *),
		       const void *isr_param_p)
{
	irq_vector_table[irq_p].irq   = irq_p;
    bfad:	89 f8                	mov    %edi,%eax
    bfaf:	4c 6b c0 18          	imul   $0x18,%rax,%r8
    bfb3:	48 8d 05 26 ab 24 00 	lea    0x24ab26(%rip),%rax        # 256ae0 <irq_vector_table>
    bfba:	4c 01 c0             	add    %r8,%rax
    bfbd:	89 38                	mov    %edi,(%rax)
	irq_vector_table[irq_p].func  = isr_p;
    bfbf:	48 89 50 08          	mov    %rdx,0x8(%rax)
	irq_vector_table[irq_p].param = isr_param_p;
    bfc3:	48 89 48 10          	mov    %rcx,0x10(%rax)
	irq_vector_table[irq_p].flags = flags;
    bfc7:	89 70 04             	mov    %esi,0x4(%rax)
}
    bfca:	c3                   	retq   

000000000000bfcb <posix_irq_priority_set>:
 *
 * @return N/A
 */
void posix_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
	hw_irq_ctrl_prio_set(irq, prio);
    bfcb:	e9 a9 00 00 00       	jmpq   c079 <hw_irq_ctrl_prio_set>

000000000000bfd0 <irq_raising_from_hw_now>:
	/*
	 * We always awake the CPU even if the IRQ was masked,
	 * but not if irqs are locked unless this is due to a
	 * PHONY_HARD_IRQ
	 */
	if ((irqs_locked == false) || (lock_ignore)) {
    bfd0:	80 3d 11 31 25 00 00 	cmpb   $0x0,0x253111(%rip)        # 25f0e8 <irqs_locked>
    bfd7:	74 09                	je     bfe2 <irq_raising_from_hw_now+0x12>
    bfd9:	80 3d 07 31 25 00 00 	cmpb   $0x0,0x253107(%rip)        # 25f0e7 <lock_ignore>
    bfe0:	74 0c                	je     bfee <irq_raising_from_hw_now+0x1e>
		lock_ignore = false;
    bfe2:	c6 05 fe 30 25 00 00 	movb   $0x0,0x2530fe(%rip)        # 25f0e7 <lock_ignore>
		posix_interrupt_raised();
    bfe9:	e9 88 f5 ff ff       	jmpq   b576 <posix_interrupt_raised>
	}
}
    bfee:	c3                   	retq   

000000000000bfef <hw_irq_ctrl_irq_raise_prefix>:
	if (irq < N_IRQS) {
    bfef:	83 ff 1f             	cmp    $0x1f,%edi
{
    bff2:	89 f9                	mov    %edi,%ecx
	if (irq < N_IRQS) {
    bff4:	77 29                	ja     c01f <hw_irq_ctrl_irq_raise_prefix+0x30>
		if (irq_mask & (1 << irq)) {
    bff6:	b8 01 00 00 00       	mov    $0x1,%eax
		irq_premask |= ((uint64_t)1<<irq);
    bffb:	ba 01 00 00 00       	mov    $0x1,%edx
		if (irq_mask & (1 << irq)) {
    c000:	d3 e0                	shl    %cl,%eax
		irq_premask |= ((uint64_t)1<<irq);
    c002:	48 d3 e2             	shl    %cl,%rdx
    c005:	48 09 15 3c bf 24 00 	or     %rdx,0x24bf3c(%rip)        # 257f48 <irq_premask>
		if (irq_mask & (1 << irq)) {
    c00c:	48 98                	cltq   
    c00e:	48 85 05 2b bf 24 00 	test   %rax,0x24bf2b(%rip)        # 257f40 <irq_mask>
    c015:	74 17                	je     c02e <hw_irq_ctrl_irq_raise_prefix+0x3f>
			irq_status |= ((uint64_t)1<<irq);
    c017:	48 09 15 32 bf 24 00 	or     %rdx,0x24bf32(%rip)        # 257f50 <irq_status>
    c01e:	c3                   	retq   
	} else if (irq == PHONY_HARD_IRQ) {
    c01f:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
    c025:	75 07                	jne    c02e <hw_irq_ctrl_irq_raise_prefix+0x3f>
		lock_ignore = true;
    c027:	c6 05 b9 30 25 00 01 	movb   $0x1,0x2530b9(%rip)        # 25f0e7 <lock_ignore>
}
    c02e:	c3                   	retq   

000000000000c02f <hw_irq_ctrl_init>:
		irq_prio[i] = 255U;
    c02f:	48 8d 15 aa ad 24 00 	lea    0x24adaa(%rip),%rdx        # 256de0 <irq_prio>
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
    c036:	48 c7 05 ff be 24 00 	movq   $0x0,0x24beff(%rip)        # 257f40 <irq_mask>
    c03d:	00 00 00 00 
	irq_premask = 0U;
    c041:	48 c7 05 fc be 24 00 	movq   $0x0,0x24befc(%rip)        # 257f48 <irq_premask>
    c048:	00 00 00 00 
	irqs_locked = false;
    c04c:	c6 05 95 30 25 00 00 	movb   $0x0,0x253095(%rip)        # 25f0e8 <irqs_locked>
	lock_ignore = false;
    c053:	c6 05 8d 30 25 00 00 	movb   $0x0,0x25308d(%rip)        # 25f0e7 <lock_ignore>
    c05a:	31 c0                	xor    %eax,%eax
		irq_prio[i] = 255U;
    c05c:	c6 04 02 ff          	movb   $0xff,(%rdx,%rax,1)
    c060:	48 ff c0             	inc    %rax
	for (int i = 0 ; i < N_IRQS; i++) {
    c063:	48 83 f8 20          	cmp    $0x20,%rax
    c067:	75 f3                	jne    c05c <hw_irq_ctrl_init+0x2d>
}
    c069:	c3                   	retq   

000000000000c06a <hw_irq_ctrl_cleanup>:
}
    c06a:	c3                   	retq   

000000000000c06b <hw_irq_ctrl_set_cur_prio>:
	currently_running_prio = new;
    c06b:	89 3d 47 aa 22 00    	mov    %edi,0x22aa47(%rip)        # 236ab8 <currently_running_prio>
}
    c071:	c3                   	retq   

000000000000c072 <hw_irq_ctrl_get_cur_prio>:
}
    c072:	8b 05 40 aa 22 00    	mov    0x22aa40(%rip),%eax        # 236ab8 <currently_running_prio>
    c078:	c3                   	retq   

000000000000c079 <hw_irq_ctrl_prio_set>:
	irq_prio[irq] = prio;
    c079:	48 8d 05 60 ad 24 00 	lea    0x24ad60(%rip),%rax        # 256de0 <irq_prio>
    c080:	89 ff                	mov    %edi,%edi
    c082:	40 88 34 38          	mov    %sil,(%rax,%rdi,1)
}
    c086:	c3                   	retq   

000000000000c087 <hw_irq_ctrl_get_prio>:
	return irq_prio[irq];
    c087:	48 8d 05 52 ad 24 00 	lea    0x24ad52(%rip),%rax        # 256de0 <irq_prio>
    c08e:	89 ff                	mov    %edi,%edi
    c090:	8a 04 38             	mov    (%rax,%rdi,1),%al
}
    c093:	c3                   	retq   

000000000000c094 <hw_irq_ctrl_get_current_lock>:
	return irqs_locked;
    c094:	0f b6 05 4d 30 25 00 	movzbl 0x25304d(%rip),%eax        # 25f0e8 <irqs_locked>
}
    c09b:	c3                   	retq   

000000000000c09c <hw_irq_ctrl_change_lock>:
	irqs_locked = new_lock;
    c09c:	85 ff                	test   %edi,%edi
{
    c09e:	53                   	push   %rbx
	uint32_t previous_lock = irqs_locked;
    c09f:	0f b6 1d 42 30 25 00 	movzbl 0x253042(%rip),%ebx        # 25f0e8 <irqs_locked>
	irqs_locked = new_lock;
    c0a6:	0f 95 05 3b 30 25 00 	setne  0x25303b(%rip)        # 25f0e8 <irqs_locked>
	if ((previous_lock == true) && (new_lock == false)) {
    c0ad:	75 13                	jne    c0c2 <hw_irq_ctrl_change_lock+0x26>
    c0af:	84 db                	test   %bl,%bl
    c0b1:	74 0f                	je     c0c2 <hw_irq_ctrl_change_lock+0x26>
		if (irq_status != 0U) {
    c0b3:	48 83 3d 95 be 24 00 	cmpq   $0x0,0x24be95(%rip)        # 257f50 <irq_status>
    c0ba:	00 
    c0bb:	74 05                	je     c0c2 <hw_irq_ctrl_change_lock+0x26>
			posix_irq_handler_im_from_sw();
    c0bd:	e8 9f fe ff ff       	callq  bf61 <posix_irq_handler_im_from_sw>
}
    c0c2:	89 d8                	mov    %ebx,%eax
    c0c4:	5b                   	pop    %rbx
    c0c5:	c3                   	retq   

000000000000c0c6 <hw_irq_ctrl_get_irq_status>:
}
    c0c6:	48 8b 05 83 be 24 00 	mov    0x24be83(%rip),%rax        # 257f50 <irq_status>
    c0cd:	c3                   	retq   

000000000000c0ce <hw_irq_ctrl_get_highest_prio_irq>:
	if (irqs_locked) {
    c0ce:	80 3d 13 30 25 00 00 	cmpb   $0x0,0x253013(%rip)        # 25f0e8 <irqs_locked>
    c0d5:	75 57                	jne    c12e <hw_irq_ctrl_get_highest_prio_irq+0x60>
{
    c0d7:	48 83 ec 08          	sub    $0x8,%rsp
	uint64_t irq_status = hw_irq_ctrl_get_irq_status();
    c0db:	e8 e6 ff ff ff       	callq  c0c6 <hw_irq_ctrl_get_irq_status>
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
    c0e0:	44 8b 05 d1 a9 22 00 	mov    0x22a9d1(%rip),%r8d        # 236ab8 <currently_running_prio>
	int winner = -1;
    c0e7:	83 ca ff             	or     $0xffffffff,%edx
		if ((winner_prio > (int)irq_prio[irq_nbr])
    c0ea:	4c 8d 1d ef ac 24 00 	lea    0x24acef(%rip),%r11        # 256de0 <irq_prio>
	int winner_prio = 256;
    c0f1:	bf 00 01 00 00       	mov    $0x100,%edi
 * @return least significant bit set, 0 if @a op is 0
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
	return __builtin_ffs(op);
    c0f6:	41 89 d1             	mov    %edx,%r9d
		irq_status &= ~((uint64_t) 1 << irq_nbr);
    c0f9:	41 ba 01 00 00 00    	mov    $0x1,%r10d
	while (irq_status != 0U) {
    c0ff:	48 85 c0             	test   %rax,%rax
    c102:	74 30                	je     c134 <hw_irq_ctrl_get_highest_prio_irq+0x66>
    c104:	0f bc c8             	bsf    %eax,%ecx
		irq_status &= ~((uint64_t) 1 << irq_nbr);
    c107:	4c 89 d6             	mov    %r10,%rsi
		int irq_nbr = find_lsb_set(irq_status) - 1;
    c10a:	41 0f 44 c9          	cmove  %r9d,%ecx
		irq_status &= ~((uint64_t) 1 << irq_nbr);
    c10e:	48 d3 e6             	shl    %cl,%rsi
    c111:	48 f7 d6             	not    %rsi
    c114:	48 21 f0             	and    %rsi,%rax
		if ((winner_prio > (int)irq_prio[irq_nbr])
    c117:	48 63 f1             	movslq %ecx,%rsi
    c11a:	41 0f b6 34 33       	movzbl (%r11,%rsi,1),%esi
    c11f:	39 fe                	cmp    %edi,%esi
    c121:	7d dc                	jge    c0ff <hw_irq_ctrl_get_highest_prio_irq+0x31>
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
    c123:	44 39 c6             	cmp    %r8d,%esi
    c126:	0f 4c fe             	cmovl  %esi,%edi
    c129:	0f 4c d1             	cmovl  %ecx,%edx
    c12c:	eb d1                	jmp    c0ff <hw_irq_ctrl_get_highest_prio_irq+0x31>
    c12e:	83 ca ff             	or     $0xffffffff,%edx
}
    c131:	89 d0                	mov    %edx,%eax
    c133:	c3                   	retq   
    c134:	89 d0                	mov    %edx,%eax
    c136:	5a                   	pop    %rdx
    c137:	c3                   	retq   

000000000000c138 <hw_irq_ctrl_clear_irq>:
	irq_status  &= ~((uint64_t)1<<irq);
    c138:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
    c13f:	40 88 f9             	mov    %dil,%cl
    c142:	48 d3 c0             	rol    %cl,%rax
    c145:	48 21 05 04 be 24 00 	and    %rax,0x24be04(%rip)        # 257f50 <irq_status>
	irq_premask &= ~((uint64_t)1<<irq);
    c14c:	48 21 05 f5 bd 24 00 	and    %rax,0x24bdf5(%rip)        # 257f48 <irq_premask>
}
    c153:	c3                   	retq   

000000000000c154 <hw_irq_ctrl_set_irq>:
{
    c154:	48 83 ec 08          	sub    $0x8,%rsp
	hw_irq_ctrl_irq_raise_prefix(irq);
    c158:	e8 92 fe ff ff       	callq  bfef <hw_irq_ctrl_irq_raise_prefix>
	if ((irqs_locked == false) || (lock_ignore)) {
    c15d:	80 3d 84 2f 25 00 00 	cmpb   $0x0,0x252f84(%rip)        # 25f0e8 <irqs_locked>
    c164:	74 09                	je     c16f <hw_irq_ctrl_set_irq+0x1b>
    c166:	80 3d 7a 2f 25 00 00 	cmpb   $0x0,0x252f7a(%rip)        # 25f0e7 <lock_ignore>
    c16d:	74 15                	je     c184 <hw_irq_ctrl_set_irq+0x30>
		irq_ctrl_timer = hwm_get_time();
    c16f:	e8 e0 f7 ff ff       	callq  b954 <hwm_get_time>
    c174:	48 8d 15 ed a8 22 00 	lea    0x22a8ed(%rip),%rdx        # 236a68 <irq_ctrl_timer>
    c17b:	48 89 02             	mov    %rax,(%rdx)
}
    c17e:	5a                   	pop    %rdx
		hwm_find_next_timer();
    c17f:	e9 79 f6 ff ff       	jmpq   b7fd <hwm_find_next_timer>
}
    c184:	58                   	pop    %rax
    c185:	c3                   	retq   

000000000000c186 <hw_irq_ctrl_raise_im_from_sw>:
 * Like hw_irq_ctrl_raise_im() but for SW threads
 *
 * Call only from SW threads
 */
void hw_irq_ctrl_raise_im_from_sw(unsigned int irq)
{
    c186:	48 83 ec 08          	sub    $0x8,%rsp
	hw_irq_ctrl_irq_raise_prefix(irq);
    c18a:	e8 60 fe ff ff       	callq  bfef <hw_irq_ctrl_irq_raise_prefix>

	if (irqs_locked == false) {
    c18f:	80 3d 52 2f 25 00 00 	cmpb   $0x0,0x252f52(%rip)        # 25f0e8 <irqs_locked>
    c196:	75 06                	jne    c19e <hw_irq_ctrl_raise_im_from_sw+0x18>
		posix_irq_handler_im_from_sw();
	}
}
    c198:	5a                   	pop    %rdx
		posix_irq_handler_im_from_sw();
    c199:	e9 c3 fd ff ff       	jmpq   bf61 <posix_irq_handler_im_from_sw>
}
    c19e:	58                   	pop    %rax
    c19f:	c3                   	retq   

000000000000c1a0 <hw_irq_ctrl_enable_irq>:
	irq_mask |= ((uint64_t)1<<irq);
    c1a0:	b8 01 00 00 00       	mov    $0x1,%eax
    c1a5:	40 88 f9             	mov    %dil,%cl
    c1a8:	48 d3 e0             	shl    %cl,%rax
    c1ab:	48 09 05 8e bd 24 00 	or     %rax,0x24bd8e(%rip)        # 257f40 <irq_mask>
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
    c1b2:	48 8b 05 8f bd 24 00 	mov    0x24bd8f(%rip),%rax        # 257f48 <irq_premask>
    c1b9:	48 0f a3 f8          	bt     %rdi,%rax
    c1bd:	73 05                	jae    c1c4 <hw_irq_ctrl_enable_irq+0x24>
		hw_irq_ctrl_raise_im_from_sw(irq);
    c1bf:	e9 c2 ff ff ff       	jmpq   c186 <hw_irq_ctrl_raise_im_from_sw>
}
    c1c4:	c3                   	retq   

000000000000c1c5 <hw_irq_ctrl_timer_triggered>:

void hw_irq_ctrl_timer_triggered(void)
{
	irq_ctrl_timer = NEVER;
    c1c5:	48 8d 05 9c a8 22 00 	lea    0x22a89c(%rip),%rax        # 236a68 <irq_ctrl_timer>
    c1cc:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	irq_raising_from_hw_now();
    c1d3:	e9 f8 fd ff ff       	jmpq   bfd0 <irq_raising_from_hw_now>

000000000000c1d8 <posix_exit>:
#include <stdlib.h>
#include <sys/util.h>
#include "cmdline.h"

void posix_exit(int exit_code)
{
    c1d8:	48 83 ec 08          	sub    $0x8,%rsp
	static int max_exit_code;

	max_exit_code = MAX(exit_code, max_exit_code);
    c1dc:	39 3d 9e 2e 25 00    	cmp    %edi,0x252e9e(%rip)        # 25f080 <max_exit_code.2336>
    c1e2:	0f 4d 3d 97 2e 25 00 	cmovge 0x252e97(%rip),%edi        # 25f080 <max_exit_code.2336>
    c1e9:	89 3d 91 2e 25 00    	mov    %edi,0x252e91(%rip)        # 25f080 <max_exit_code.2336>
	/*
	 * posix_soc_clean_up may not return if this is called from a SW thread,
	 * but instead it would get posix_exit() recalled again
	 * ASAP from the HW thread
	 */
	posix_soc_clean_up();
    c1ef:	e8 a7 f4 ff ff       	callq  b69b <posix_soc_clean_up>
	hwm_cleanup();
    c1f4:	e8 81 f7 ff ff       	callq  b97a <hwm_cleanup>
	native_cleanup_cmd_line();
    c1f9:	e8 e0 0a 00 00       	callq  ccde <native_cleanup_cmd_line>
	exit(max_exit_code);
    c1fe:	8b 3d 7c 2e 25 00    	mov    0x252e7c(%rip),%edi        # 25f080 <max_exit_code.2336>
    c204:	e8 67 84 ff ff       	callq  4670 <exit@plt>

000000000000c209 <main>:
/**
 * This is the actual main for the Linux process,
 * the Zephyr application main is renamed something else thru a define.
 */
int main(int argc, char *argv[])
{
    c209:	53                   	push   %rbx
    c20a:	89 fb                	mov    %edi,%ebx
	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
    c20c:	31 ff                	xor    %edi,%edi
{
    c20e:	48 83 ec 10          	sub    $0x10,%rsp
    c212:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
    c217:	e8 49 f4 ff ff       	callq  b665 <run_native_tasks>

	native_handle_cmd_line(argc, argv);
    c21c:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    c221:	89 df                	mov    %ebx,%edi
    c223:	e8 99 0b 00 00       	callq  cdc1 <native_handle_cmd_line>

	run_native_tasks(_NATIVE_PRE_BOOT_2_LEVEL);
    c228:	bf 01 00 00 00       	mov    $0x1,%edi
    c22d:	e8 33 f4 ff ff       	callq  b665 <run_native_tasks>

	hwm_init();
    c232:	e8 25 f7 ff ff       	callq  b95c <hwm_init>

	run_native_tasks(_NATIVE_PRE_BOOT_3_LEVEL);
    c237:	bf 02 00 00 00       	mov    $0x2,%edi
    c23c:	e8 24 f4 ff ff       	callq  b665 <run_native_tasks>

	posix_boot_cpu();
    c241:	e8 62 f3 ff ff       	callq  b5a8 <posix_boot_cpu>

	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
    c246:	bf 03 00 00 00       	mov    $0x3,%edi
    c24b:	e8 15 f4 ff ff       	callq  b665 <run_native_tasks>

	hwm_main_loop();
    c250:	e8 26 f6 ff ff       	callq  b87b <hwm_main_loop>

	/* This line should be unreachable */
	return 1; /* LCOV_EXCL_LINE */
}
    c255:	48 83 c4 10          	add    $0x10,%rsp
    c259:	b8 01 00 00 00       	mov    $0x1,%eax
    c25e:	5b                   	pop    %rbx
    c25f:	c3                   	retq   

000000000000c260 <trace_disable_color>:
 */
static int is_a_tty[2] = {-1, -1};

void trace_disable_color(char *argv, int offset)
{
	is_a_tty[0] = 0;
    c260:	48 c7 05 05 a8 22 00 	movq   $0x0,0x22a805(%rip)        # 236a70 <is_a_tty>
    c267:	00 00 00 00 
	is_a_tty[1] = 0;
}
    c26b:	c3                   	retq   

000000000000c26c <trace_enable_color>:

void trace_enable_color(char *argv, int offset)
{
	is_a_tty[0] = -1;
    c26c:	48 c7 05 f9 a7 22 00 	movq   $0xffffffffffffffff,0x22a7f9(%rip)        # 236a70 <is_a_tty>
    c273:	ff ff ff ff 
	is_a_tty[1] = -1;

}
    c277:	c3                   	retq   

000000000000c278 <trace_force_color>:

void trace_force_color(char *argv, int offset)
{
	is_a_tty[0] = 1;
    c278:	48 b8 01 00 00 00 01 	movabs $0x100000001,%rax
    c27f:	00 00 00 
    c282:	48 89 05 e7 a7 22 00 	mov    %rax,0x22a7e7(%rip)        # 236a70 <is_a_tty>
	is_a_tty[1] = 1;
}
    c289:	c3                   	retq   

000000000000c28a <decide_about_color>:
{
	return is_a_tty[file_number];
}

static void decide_about_color(void)
{
    c28a:	48 83 ec 08          	sub    $0x8,%rsp
	if (is_a_tty[0] == -1) {
    c28e:	83 3d db a7 22 00 ff 	cmpl   $0xffffffff,0x22a7db(%rip)        # 236a70 <is_a_tty>
    c295:	75 10                	jne    c2a7 <decide_about_color+0x1d>
		is_a_tty[0] = isatty(STDOUT_FILENO);
    c297:	bf 01 00 00 00       	mov    $0x1,%edi
    c29c:	e8 df 84 ff ff       	callq  4780 <isatty@plt>
    c2a1:	89 05 c9 a7 22 00    	mov    %eax,0x22a7c9(%rip)        # 236a70 <is_a_tty>
	}
	if (is_a_tty[1] == -1) {
    c2a7:	83 3d c6 a7 22 00 ff 	cmpl   $0xffffffff,0x22a7c6(%rip)        # 236a74 <is_a_tty+0x4>
    c2ae:	75 10                	jne    c2c0 <decide_about_color+0x36>
		is_a_tty[1] = isatty(STDERR_FILENO);
    c2b0:	bf 02 00 00 00       	mov    $0x2,%edi
    c2b5:	e8 c6 84 ff ff       	callq  4780 <isatty@plt>
    c2ba:	89 05 b4 a7 22 00    	mov    %eax,0x22a7b4(%rip)        # 236a74 <is_a_tty+0x4>
	}
}
    c2c0:	58                   	pop    %rax
    c2c1:	c3                   	retq   

000000000000c2c2 <posix_print_error_and_exit>:
{
    c2c2:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    c2c9:	84 c0                	test   %al,%al
    c2cb:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    c2d0:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    c2d5:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    c2da:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    c2df:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    c2e4:	74 37                	je     c31d <posix_print_error_and_exit+0x5b>
    c2e6:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    c2eb:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    c2f0:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    c2f5:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    c2fc:	00 
    c2fd:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    c304:	00 
    c305:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    c30c:	00 
    c30d:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    c314:	00 
    c315:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    c31c:	00 
    c31d:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    c324:	00 00 
    c326:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    c32b:	31 c0                	xor    %eax,%eax
	va_start(variable_args, format);
    c32d:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    c334:	00 

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, _G_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
    c335:	48 89 fa             	mov    %rdi,%rdx
    c338:	48 89 e1             	mov    %rsp,%rcx
    c33b:	be 01 00 00 00       	mov    $0x1,%esi
    c340:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    c345:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    c34a:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    c351:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    c358:	00 
    c359:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    c35e:	48 8b 05 23 9c 22 00 	mov    0x229c23(%rip),%rax        # 235f88 <stderr@GLIBC_2.2.5>
    c365:	48 8b 38             	mov    (%rax),%rdi
    c368:	e8 73 80 ff ff       	callq  43e0 <__vfprintf_chk@plt>
	posix_exit(1);
    c36d:	bf 01 00 00 00       	mov    $0x1,%edi
    c372:	e8 61 fe ff ff       	callq  c1d8 <posix_exit>
}
    c377:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    c37c:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    c383:	00 00 
    c385:	74 05                	je     c38c <posix_print_error_and_exit+0xca>
    c387:	e8 b4 82 ff ff       	callq  4640 <__stack_chk_fail@plt>
    c38c:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    c393:	c3                   	retq   

000000000000c394 <posix_print_warning>:
{
    c394:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    c39b:	84 c0                	test   %al,%al
    c39d:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    c3a2:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    c3a7:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    c3ac:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    c3b1:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    c3b6:	74 37                	je     c3ef <posix_print_warning+0x5b>
    c3b8:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    c3bd:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    c3c2:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    c3c7:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    c3ce:	00 
    c3cf:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    c3d6:	00 
    c3d7:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    c3de:	00 
    c3df:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    c3e6:	00 
    c3e7:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    c3ee:	00 
    c3ef:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    c3f6:	00 00 
    c3f8:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    c3fd:	31 c0                	xor    %eax,%eax
	va_start(variable_args, format);
    c3ff:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    c406:	00 
    c407:	48 89 fa             	mov    %rdi,%rdx
    c40a:	48 89 e1             	mov    %rsp,%rcx
    c40d:	be 01 00 00 00       	mov    $0x1,%esi
    c412:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    c417:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    c41c:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    c423:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    c42a:	00 
    c42b:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    c430:	48 8b 05 51 9b 22 00 	mov    0x229b51(%rip),%rax        # 235f88 <stderr@GLIBC_2.2.5>
    c437:	48 8b 38             	mov    (%rax),%rdi
    c43a:	e8 a1 7f ff ff       	callq  43e0 <__vfprintf_chk@plt>
}
    c43f:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    c444:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    c44b:	00 00 
    c44d:	74 05                	je     c454 <posix_print_warning+0xc0>
    c44f:	e8 ec 81 ff ff       	callq  4640 <__stack_chk_fail@plt>
    c454:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    c45b:	c3                   	retq   

000000000000c45c <posix_print_trace>:
{
    c45c:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    c463:	84 c0                	test   %al,%al
    c465:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    c46a:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    c46f:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    c474:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    c479:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    c47e:	74 37                	je     c4b7 <posix_print_trace+0x5b>
    c480:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    c485:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    c48a:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    c48f:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    c496:	00 
    c497:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    c49e:	00 
    c49f:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    c4a6:	00 
    c4a7:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    c4ae:	00 
    c4af:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    c4b6:	00 
    c4b7:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    c4be:	00 00 
    c4c0:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    c4c5:	31 c0                	xor    %eax,%eax
	va_start(variable_args, format);
    c4c7:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    c4ce:	00 
    c4cf:	48 89 fa             	mov    %rdi,%rdx
    c4d2:	48 89 e1             	mov    %rsp,%rcx
    c4d5:	be 01 00 00 00       	mov    $0x1,%esi
    c4da:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    c4df:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    c4e4:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    c4eb:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    c4f2:	00 
    c4f3:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    c4f8:	48 8b 05 41 9a 22 00 	mov    0x229a41(%rip),%rax        # 235f40 <stdout@GLIBC_2.2.5>
    c4ff:	48 8b 38             	mov    (%rax),%rdi
    c502:	e8 d9 7e ff ff       	callq  43e0 <__vfprintf_chk@plt>
}
    c507:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    c50c:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    c513:	00 00 
    c515:	74 05                	je     c51c <posix_print_trace+0xc0>
    c517:	e8 24 81 ff ff       	callq  4640 <__stack_chk_fail@plt>
    c51c:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    c523:	c3                   	retq   

000000000000c524 <posix_trace_over_tty>:
	return is_a_tty[file_number];
    c524:	48 8d 05 45 a5 22 00 	lea    0x22a545(%rip),%rax        # 236a70 <is_a_tty>
    c52b:	48 63 ff             	movslq %edi,%rdi
    c52e:	8b 04 b8             	mov    (%rax,%rdi,4),%eax
}
    c531:	c3                   	retq   

000000000000c532 <native_add_tracing_options>:
		"force-color", "force-color", 'b',
		NULL, trace_force_color,
		"Enable color in traces even if printing to files/pipes"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(trace_options);
    c532:	48 8d 3d 27 9f 22 00 	lea    0x229f27(%rip),%rdi        # 236460 <trace_options.3563>
    c539:	e9 c3 07 00 00       	jmpq   cd01 <native_add_command_line_opts>

000000000000c53e <cmd_gen_switch_syntax.part.0.constprop.1>:
 * should be used
 *
 * The string is saved in <buf> which has been allocated <size> bytes by the
 * caller
 */
static void cmd_gen_switch_syntax(char *buf, int size,
    c53e:	41 55                	push   %r13
    c540:	41 54                	push   %r12
    c542:	49 89 f4             	mov    %rsi,%r12
    c545:	55                   	push   %rbp
    c546:	53                   	push   %rbx
    c547:	bd 46 00 00 00       	mov    $0x46,%ebp
    c54c:	48 89 fb             	mov    %rdi,%rbx
    c54f:	48 83 ec 08          	sub    $0x8,%rsp

	if (size <= 0) {
		return;
	}

	if (args_s_el->is_mandatory == false) {
    c553:	80 7e 01 00          	cmpb   $0x0,0x1(%rsi)
    c557:	75 0b                	jne    c564 <cmd_gen_switch_syntax.part.0.constprop.1+0x26>
		*buf++ = '[';
    c559:	c6 07 5b             	movb   $0x5b,(%rdi)
    c55c:	48 ff c3             	inc    %rbx
		size--;
    c55f:	bd 45 00 00 00       	mov    $0x45,%ebp
	}

	if (args_s_el->is_switch == true) {
    c564:	41 80 7c 24 02 00    	cmpb   $0x0,0x2(%r12)
    c56a:	4d 8b 4c 24 08       	mov    0x8(%r12),%r9
    c56f:	48 63 f5             	movslq %ebp,%rsi
    c572:	74 1c                	je     c590 <cmd_gen_switch_syntax.part.0.constprop.1+0x52>
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    c574:	4c 8d 05 2d 59 02 00 	lea    0x2592d(%rip),%r8        # 31ea8 <__func__.5785+0x1240>
    c57b:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    c57f:	ba 01 00 00 00       	mov    $0x1,%edx
    c584:	48 89 df             	mov    %rbx,%rdi
    c587:	31 c0                	xor    %eax,%eax
    c589:	e8 12 7f ff ff       	callq  44a0 <__snprintf_chk@plt>
    c58e:	eb 3c                	jmp    c5cc <cmd_gen_switch_syntax.part.0.constprop.1+0x8e>
		ret = snprintf(buf, size, "-%s", args_s_el->option);
	} else {
		if (args_s_el->type != 'l') {
    c590:	41 80 7c 24 18 6c    	cmpb   $0x6c,0x18(%r12)
    c596:	49 8b 44 24 10       	mov    0x10(%r12),%rax
    c59b:	74 0e                	je     c5ab <cmd_gen_switch_syntax.part.0.constprop.1+0x6d>
    c59d:	48 83 ec 08          	sub    $0x8,%rsp
    c5a1:	4c 8d 05 04 59 02 00 	lea    0x25904(%rip),%r8        # 31eac <__func__.5785+0x1244>
    c5a8:	50                   	push   %rax
    c5a9:	eb 0c                	jmp    c5b7 <cmd_gen_switch_syntax.part.0.constprop.1+0x79>
    c5ab:	48 83 ec 08          	sub    $0x8,%rsp
    c5af:	4c 8d 05 ff 58 02 00 	lea    0x258ff(%rip),%r8        # 31eb5 <__func__.5785+0x124d>
    c5b6:	50                   	push   %rax
    c5b7:	48 89 df             	mov    %rbx,%rdi
    c5ba:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    c5be:	ba 01 00 00 00       	mov    $0x1,%edx
    c5c3:	31 c0                	xor    %eax,%eax
    c5c5:	e8 d6 7e ff ff       	callq  44a0 <__snprintf_chk@plt>
    c5ca:	5e                   	pop    %rsi
    c5cb:	5f                   	pop    %rdi
			ret = snprintf(buf, size, "-%s <%s>...",
					args_s_el->option, args_s_el->name);
		}
	}

	if (ret < 0) {
    c5cc:	85 c0                	test   %eax,%eax
    c5ce:	41 89 c5             	mov    %eax,%r13d
    c5d1:	79 1a                	jns    c5ed <cmd_gen_switch_syntax.part.0.constprop.1+0xaf>
		posix_print_error_and_exit("Unexpected error in %s %i\n",
    c5d3:	48 8d 35 e7 58 02 00 	lea    0x258e7(%rip),%rsi        # 31ec1 <__func__.5785+0x1259>
    c5da:	48 8d 3d 1d 59 02 00 	lea    0x2591d(%rip),%rdi        # 31efe <__func__.5785+0x1296>
    c5e1:	ba 07 01 00 00       	mov    $0x107,%edx
    c5e6:	31 c0                	xor    %eax,%eax
    c5e8:	e8 d5 fc ff ff       	callq  c2c2 <posix_print_error_and_exit>
					   __FILE__, __LINE__);
	}
	if (size - ret < 0) {
    c5ed:	44 29 ed             	sub    %r13d,%ebp
    c5f0:	78 2d                	js     c61f <cmd_gen_switch_syntax.part.0.constprop.1+0xe1>
		 * If we run out of space we can just stop,
		 * this is not critical
		 */
		return;
	}
	buf += ret;
    c5f2:	49 63 fd             	movslq %r13d,%rdi
    c5f5:	48 63 f5             	movslq %ebp,%rsi
    c5f8:	48 8d 15 13 4c 02 00 	lea    0x24c13(%rip),%rdx        # 31212 <__func__.5785+0x5aa>
    c5ff:	48 01 df             	add    %rbx,%rdi
	size -= ret;

	if (args_s_el->is_mandatory == false) {
    c602:	41 80 7c 24 01 00    	cmpb   $0x0,0x1(%r12)
    c608:	74 07                	je     c611 <cmd_gen_switch_syntax.part.0.constprop.1+0xd3>
    c60a:	48 8d 15 15 4c 02 00 	lea    0x24c15(%rip),%rdx        # 31226 <__func__.5785+0x5be>
		snprintf(buf, size, "] ");
	} else {
		snprintf(buf, size, " ");
	}
}
    c611:	59                   	pop    %rcx
    c612:	5b                   	pop    %rbx
    c613:	5d                   	pop    %rbp
    c614:	41 5c                	pop    %r12
    c616:	41 5d                	pop    %r13
    c618:	31 c0                	xor    %eax,%eax
    c61a:	e9 21 81 ff ff       	jmpq   4740 <snprintf@plt>
    c61f:	58                   	pop    %rax
    c620:	5b                   	pop    %rbx
    c621:	5d                   	pop    %rbp
    c622:	41 5c                	pop    %r12
    c624:	41 5d                	pop    %r13
    c626:	c3                   	retq   

000000000000c627 <cmd_is_option>:
{
    c627:	41 54                	push   %r12
    c629:	55                   	push   %rbp
    c62a:	49 89 f8             	mov    %rdi,%r8
    c62d:	53                   	push   %rbx
	size_t to_match_len = strlen(option);
    c62e:	31 c0                	xor    %eax,%eax
    c630:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    c634:	48 89 f7             	mov    %rsi,%rdi
{
    c637:	89 d3                	mov    %edx,%ebx
	size_t to_match_len = strlen(option);
    c639:	f2 ae                	repnz scas %es:(%rdi),%al
	if (arg[of] == '-') {
    c63b:	41 80 38 2d          	cmpb   $0x2d,(%r8)
	size_t to_match_len = strlen(option);
    c63f:	48 89 ca             	mov    %rcx,%rdx
    c642:	48 f7 d2             	not    %rdx
    c645:	48 8d 6a ff          	lea    -0x1(%rdx),%rbp
	if (arg[of] == '-') {
    c649:	0f 94 c0             	sete   %al
	int of = 0;
    c64c:	44 0f b6 e0          	movzbl %al,%r12d
	if (arg[of] == '-') {
    c650:	0f b6 c0             	movzbl %al,%eax
    c653:	41 80 3c 00 2d       	cmpb   $0x2d,(%r8,%rax,1)
    c658:	75 03                	jne    c65d <cmd_is_option+0x36>
		of++;
    c65a:	41 ff c4             	inc    %r12d
	if (!with_value) {
    c65d:	85 db                	test   %ebx,%ebx
    c65f:	75 15                	jne    c676 <cmd_is_option+0x4f>
		if (strcmp(&arg[of], option) != 0) {
    c661:	49 63 fc             	movslq %r12d,%rdi
    c664:	4c 01 c7             	add    %r8,%rdi
    c667:	e8 44 80 ff ff       	callq  46b0 <strcmp@plt>
    c66c:	85 c0                	test   %eax,%eax
    c66e:	75 56                	jne    c6c6 <cmd_is_option+0x9f>
			return of + to_match_len;
    c670:	41 8d 1c 2c          	lea    (%r12,%rbp,1),%ebx
    c674:	eb 50                	jmp    c6c6 <cmd_is_option+0x9f>
    c676:	31 d2                	xor    %edx,%edx
    c678:	41 8d 1c 14          	lea    (%r12,%rdx,1),%ebx
    c67c:	8a 0c 16             	mov    (%rsi,%rdx,1),%cl
	while (!(arg[of] == 0 && *option == 0)) {
    c67f:	48 63 c3             	movslq %ebx,%rax
    c682:	41 8a 04 00          	mov    (%r8,%rax,1),%al
    c686:	84 c0                	test   %al,%al
    c688:	74 10                	je     c69a <cmd_is_option+0x73>
		if (*option == 0) {
    c68a:	84 c9                	test   %cl,%cl
    c68c:	75 10                	jne    c69e <cmd_is_option+0x77>
			if ((arg[of] == ':') || (arg[of] == '=')) {
    c68e:	3c 3a                	cmp    $0x3a,%al
    c690:	74 04                	je     c696 <cmd_is_option+0x6f>
    c692:	3c 3d                	cmp    $0x3d,%al
    c694:	75 2e                	jne    c6c4 <cmd_is_option+0x9d>
				of++;
    c696:	ff c3                	inc    %ebx
				break;
    c698:	eb 0d                	jmp    c6a7 <cmd_is_option+0x80>
	while (!(arg[of] == 0 && *option == 0)) {
    c69a:	84 c9                	test   %cl,%cl
    c69c:	74 09                	je     c6a7 <cmd_is_option+0x80>
    c69e:	48 ff c2             	inc    %rdx
		if (arg[of] != *option) {
    c6a1:	38 c8                	cmp    %cl,%al
    c6a3:	74 d3                	je     c678 <cmd_is_option+0x51>
    c6a5:	eb 1d                	jmp    c6c4 <cmd_is_option+0x9d>
	if (arg[of] == 0) { /* we need a value to follow */
    c6a7:	48 63 c3             	movslq %ebx,%rax
    c6aa:	41 80 3c 00 00       	cmpb   $0x0,(%r8,%rax,1)
    c6af:	75 15                	jne    c6c6 <cmd_is_option+0x9f>
		posix_print_error_and_exit("Incorrect option syntax '%s'. The "
    c6b1:	48 8d 3d 61 58 02 00 	lea    0x25861(%rip),%rdi        # 31f19 <__func__.5785+0x12b1>
    c6b8:	4c 89 c6             	mov    %r8,%rsi
    c6bb:	31 c0                	xor    %eax,%eax
    c6bd:	e8 00 fc ff ff       	callq  c2c2 <posix_print_error_and_exit>
    c6c2:	eb 02                	jmp    c6c6 <cmd_is_option+0x9f>
			return 0;
    c6c4:	31 db                	xor    %ebx,%ebx
}
    c6c6:	89 d8                	mov    %ebx,%eax
    c6c8:	5b                   	pop    %rbx
    c6c9:	5d                   	pop    %rbp
    c6ca:	41 5c                	pop    %r12
    c6cc:	c3                   	retq   

000000000000c6cd <cmd_is_help_option>:
{
    c6cd:	55                   	push   %rbp
    c6ce:	53                   	push   %rbx
    c6cf:	48 89 fb             	mov    %rdi,%rbx
    c6d2:	48 83 ec 08          	sub    $0x8,%rsp
	if (arg[0] == '-') {
    c6d6:	80 3f 2d             	cmpb   $0x2d,(%rdi)
    c6d9:	75 03                	jne    c6de <cmd_is_help_option+0x11>
		arg++;
    c6db:	48 ff c3             	inc    %rbx
	if (arg[0] == '-') {
    c6de:	80 3b 2d             	cmpb   $0x2d,(%rbx)
    c6e1:	75 03                	jne    c6e6 <cmd_is_help_option+0x19>
		arg++;
    c6e3:	48 ff c3             	inc    %rbx
	if ((strcasecmp(arg, "?") == 0) ||
    c6e6:	48 8d 35 86 58 02 00 	lea    0x25886(%rip),%rsi        # 31f73 <__func__.5785+0x130b>
    c6ed:	48 89 df             	mov    %rbx,%rdi
		return 1;
    c6f0:	bd 01 00 00 00       	mov    $0x1,%ebp
	if ((strcasecmp(arg, "?") == 0) ||
    c6f5:	e8 26 7f ff ff       	callq  4620 <strcasecmp@plt>
    c6fa:	85 c0                	test   %eax,%eax
    c6fc:	74 2a                	je     c728 <cmd_is_help_option+0x5b>
	    (strcasecmp(arg, "h") == 0) ||
    c6fe:	48 8d 35 28 71 02 00 	lea    0x27128(%rip),%rsi        # 3382d <__func__.5785+0x2bc5>
    c705:	48 89 df             	mov    %rbx,%rdi
    c708:	e8 13 7f ff ff       	callq  4620 <strcasecmp@plt>
	if ((strcasecmp(arg, "?") == 0) ||
    c70d:	85 c0                	test   %eax,%eax
    c70f:	74 17                	je     c728 <cmd_is_help_option+0x5b>
	    (strcasecmp(arg, "help") == 0)) {
    c711:	48 8d 35 f9 58 02 00 	lea    0x258f9(%rip),%rsi        # 32011 <__func__.5785+0x13a9>
    c718:	48 89 df             	mov    %rbx,%rdi
	    (strcasecmp(arg, "h") == 0) ||
    c71b:	31 ed                	xor    %ebp,%ebp
	    (strcasecmp(arg, "help") == 0)) {
    c71d:	e8 fe 7e ff ff       	callq  4620 <strcasecmp@plt>
	    (strcasecmp(arg, "h") == 0) ||
    c722:	85 c0                	test   %eax,%eax
    c724:	40 0f 94 c5          	sete   %bpl
}
    c728:	89 e8                	mov    %ebp,%eax
    c72a:	5a                   	pop    %rdx
    c72b:	5b                   	pop    %rbx
    c72c:	5d                   	pop    %rbp
    c72d:	c3                   	retq   

000000000000c72e <cmd_read_option_value>:
{
    c72e:	41 54                	push   %r12
    c730:	55                   	push   %rbp
    c731:	49 89 cc             	mov    %rcx,%r12
    c734:	53                   	push   %rbx
    c735:	48 89 f5             	mov    %rsi,%rbp
    c738:	48 89 fb             	mov    %rdi,%rbx
    c73b:	48 83 ec 10          	sub    $0x10,%rsp
    c73f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    c746:	00 00 
    c748:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    c74d:	31 c0                	xor    %eax,%eax
	switch (type) {
    c74f:	80 fa 64             	cmp    $0x64,%dl
	char *endptr = NULL;
    c752:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
    c759:	00 
	switch (type) {
    c75a:	0f 84 15 01 00 00    	je     c875 <cmd_read_option_value+0x147>
    c760:	7f 26                	jg     c788 <cmd_read_option_value+0x5a>
    c762:	80 fa 55             	cmp    $0x55,%dl
    c765:	0f 84 f3 00 00 00    	je     c85e <cmd_read_option_value+0x130>
    c76b:	80 fa 62             	cmp    $0x62,%dl
    c76e:	74 42                	je     c7b2 <cmd_read_option_value+0x84>
    c770:	80 fa 49             	cmp    $0x49,%dl
    c773:	0f 85 0b 01 00 00    	jne    c884 <cmd_read_option_value+0x156>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
    c779:	48 89 e6             	mov    %rsp,%rsi
    c77c:	31 d2                	xor    %edx,%edx
    c77e:	e8 2d 7c ff ff       	callq  43b0 <strtoll@plt>
    c783:	e9 e7 00 00 00       	jmpq   c86f <cmd_read_option_value+0x141>
	switch (type) {
    c788:	80 fa 73             	cmp    $0x73,%dl
    c78b:	0f 84 ab 00 00 00    	je     c83c <cmd_read_option_value+0x10e>
    c791:	80 fa 75             	cmp    $0x75,%dl
    c794:	0f 84 b8 00 00 00    	je     c852 <cmd_read_option_value+0x124>
    c79a:	80 fa 69             	cmp    $0x69,%dl
    c79d:	0f 85 e1 00 00 00    	jne    c884 <cmd_read_option_value+0x156>
		*(int32_t *)dest = strtol(str, &endptr, 0);
    c7a3:	48 89 e6             	mov    %rsp,%rsi
    c7a6:	31 d2                	xor    %edx,%edx
    c7a8:	e8 13 7f ff ff       	callq  46c0 <strtol@plt>
    c7ad:	e9 b8 00 00 00       	jmpq   c86a <cmd_read_option_value+0x13c>
		if (strcasecmp(str, "false") == 0) {
    c7b2:	48 8d 35 bc 57 02 00 	lea    0x257bc(%rip),%rsi        # 31f75 <__func__.5785+0x130d>
    c7b9:	e8 62 7e ff ff       	callq  4620 <strcasecmp@plt>
    c7be:	85 c0                	test   %eax,%eax
    c7c0:	75 0a                	jne    c7cc <cmd_read_option_value+0x9e>
			*(bool *)dest = false;
    c7c2:	c6 45 00 00          	movb   $0x0,0x0(%rbp)
			endptr = (char *)str + 5;
    c7c6:	48 8d 43 05          	lea    0x5(%rbx),%rax
    c7ca:	eb 1b                	jmp    c7e7 <cmd_read_option_value+0xb9>
		} else if (strcmp(str, "0") == 0) {
    c7cc:	48 8d 35 65 73 02 00 	lea    0x27365(%rip),%rsi        # 33b38 <_lv_bpp1_opa_table+0x2e3>
    c7d3:	48 89 df             	mov    %rbx,%rdi
    c7d6:	e8 d5 7e ff ff       	callq  46b0 <strcmp@plt>
    c7db:	85 c0                	test   %eax,%eax
    c7dd:	75 11                	jne    c7f0 <cmd_read_option_value+0xc2>
			*(bool *)dest = false;
    c7df:	c6 45 00 00          	movb   $0x0,0x0(%rbp)
			endptr = (char *)str + 1;
    c7e3:	48 8d 43 01          	lea    0x1(%rbx),%rax
    c7e7:	48 89 04 24          	mov    %rax,(%rsp)
    c7eb:	e9 a5 00 00 00       	jmpq   c895 <cmd_read_option_value+0x167>
		} else if (strcasecmp(str, "true") == 0) {
    c7f0:	48 8d 35 84 57 02 00 	lea    0x25784(%rip),%rsi        # 31f7b <__func__.5785+0x1313>
    c7f7:	48 89 df             	mov    %rbx,%rdi
    c7fa:	e8 21 7e ff ff       	callq  4620 <strcasecmp@plt>
    c7ff:	85 c0                	test   %eax,%eax
    c801:	75 0a                	jne    c80d <cmd_read_option_value+0xdf>
			*(bool *)dest = true;
    c803:	c6 45 00 01          	movb   $0x1,0x0(%rbp)
			endptr = (char *)str + 4;
    c807:	48 8d 43 04          	lea    0x4(%rbx),%rax
    c80b:	eb da                	jmp    c7e7 <cmd_read_option_value+0xb9>
		} else if (strcmp(str, "1") == 0) {
    c80d:	48 8d 35 e7 48 02 00 	lea    0x248e7(%rip),%rsi        # 310fb <__func__.5785+0x493>
    c814:	48 89 df             	mov    %rbx,%rdi
    c817:	e8 94 7e ff ff       	callq  46b0 <strcmp@plt>
    c81c:	85 c0                	test   %eax,%eax
    c81e:	74 16                	je     c836 <cmd_read_option_value+0x108>
		posix_print_error_and_exit("Error reading value of %s '%s'. Use"
    c820:	48 8d 3d 59 57 02 00 	lea    0x25759(%rip),%rdi        # 31f80 <__func__.5785+0x1318>
    c827:	48 89 da             	mov    %rbx,%rdx
    c82a:	4c 89 e6             	mov    %r12,%rsi
    c82d:	31 c0                	xor    %eax,%eax
    c82f:	e8 8e fa ff ff       	callq  c2c2 <posix_print_error_and_exit>
    c834:	eb 71                	jmp    c8a7 <cmd_read_option_value+0x179>
			*(bool *)dest = true;
    c836:	c6 45 00 01          	movb   $0x1,0x0(%rbp)
    c83a:	eb a7                	jmp    c7e3 <cmd_read_option_value+0xb5>
		endptr = (char *)str + strlen(str);
    c83c:	31 c0                	xor    %eax,%eax
		*(char **)dest = (char *)str;
    c83e:	48 89 7d 00          	mov    %rdi,0x0(%rbp)
		endptr = (char *)str + strlen(str);
    c842:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    c846:	f2 ae                	repnz scas %es:(%rdi),%al
    c848:	48 f7 d1             	not    %rcx
    c84b:	48 8d 44 0b ff       	lea    -0x1(%rbx,%rcx,1),%rax
    c850:	eb 95                	jmp    c7e7 <cmd_read_option_value+0xb9>
		*(uint32_t *)dest = strtoul(str, &endptr, 0);
    c852:	48 89 e6             	mov    %rsp,%rsi
    c855:	31 d2                	xor    %edx,%edx
    c857:	e8 a4 7b ff ff       	callq  4400 <strtoul@plt>
    c85c:	eb 0c                	jmp    c86a <cmd_read_option_value+0x13c>
		*(uint64_t *)dest = strtoull(str, &endptr, 0);
    c85e:	48 89 e6             	mov    %rsp,%rsi
    c861:	31 d2                	xor    %edx,%edx
    c863:	e8 38 7e ff ff       	callq  46a0 <strtoull@plt>
    c868:	eb 05                	jmp    c86f <cmd_read_option_value+0x141>
		*(int32_t *)dest = strtol(str, &endptr, 0);
    c86a:	89 45 00             	mov    %eax,0x0(%rbp)
    c86d:	eb 26                	jmp    c895 <cmd_read_option_value+0x167>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
    c86f:	48 89 45 00          	mov    %rax,0x0(%rbp)
    c873:	eb 20                	jmp    c895 <cmd_read_option_value+0x167>
		*(double *)dest = strtod(str, &endptr);
    c875:	48 89 e6             	mov    %rsp,%rsi
    c878:	e8 a3 7c ff ff       	callq  4520 <strtod@plt>
    c87d:	f2 0f 11 45 00       	movsd  %xmm0,0x0(%rbp)
    c882:	eb 11                	jmp    c895 <cmd_read_option_value+0x167>
		posix_print_error_and_exit(CMD_TYPE_ERROR, type);
    c884:	48 8d 3d 37 57 02 00 	lea    0x25737(%rip),%rdi        # 31fc2 <__func__.5785+0x135a>
	switch (type) {
    c88b:	0f be f2             	movsbl %dl,%esi
		posix_print_error_and_exit(CMD_TYPE_ERROR, type);
    c88e:	31 c0                	xor    %eax,%eax
    c890:	e8 2d fa ff ff       	callq  c2c2 <posix_print_error_and_exit>
	if (!error && endptr && *endptr != 0) {
    c895:	48 8b 04 24          	mov    (%rsp),%rax
    c899:	48 85 c0             	test   %rax,%rax
    c89c:	74 09                	je     c8a7 <cmd_read_option_value+0x179>
    c89e:	80 38 00             	cmpb   $0x0,(%rax)
    c8a1:	0f 85 79 ff ff ff    	jne    c820 <cmd_read_option_value+0xf2>
}
    c8a7:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    c8ac:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    c8b3:	00 00 
    c8b5:	74 05                	je     c8bc <cmd_read_option_value+0x18e>
    c8b7:	e8 84 7d ff ff       	callq  4640 <__stack_chk_fail@plt>
    c8bc:	48 83 c4 10          	add    $0x10,%rsp
    c8c0:	5b                   	pop    %rbx
    c8c1:	5d                   	pop    %rbp
    c8c2:	41 5c                	pop    %r12
    c8c4:	c3                   	retq   

000000000000c8c5 <cmd_args_set_defaults>:
{
    c8c5:	55                   	push   %rbp
    c8c6:	53                   	push   %rbx
	int count = 0;
    c8c7:	31 ed                	xor    %ebp,%ebp
{
    c8c9:	48 89 fb             	mov    %rdi,%rbx
    c8cc:	48 83 ec 08          	sub    $0x8,%rsp
	while (args_struct[count].option != NULL) {
    c8d0:	48 63 d5             	movslq %ebp,%rdx
    c8d3:	48 6b d2 38          	imul   $0x38,%rdx,%rdx
    c8d7:	48 01 da             	add    %rbx,%rdx
    c8da:	48 83 7a 08 00       	cmpq   $0x0,0x8(%rdx)
    c8df:	0f 84 a2 00 00 00    	je     c987 <cmd_args_set_defaults+0xc2>
		if (args_struct[count].dest == NULL) {
    c8e5:	48 8b 42 20          	mov    0x20(%rdx),%rax
    c8e9:	ff c5                	inc    %ebp
    c8eb:	48 85 c0             	test   %rax,%rax
    c8ee:	74 e0                	je     c8d0 <cmd_args_set_defaults+0xb>
		switch (args_struct[count].type) {
    c8f0:	0f be 72 18          	movsbl 0x18(%rdx),%esi
    c8f4:	40 80 fe 62          	cmp    $0x62,%sil
    c8f8:	74 43                	je     c93d <cmd_args_set_defaults+0x78>
    c8fa:	7f 13                	jg     c90f <cmd_args_set_defaults+0x4a>
    c8fc:	40 80 fe 49          	cmp    $0x49,%sil
    c900:	74 60                	je     c962 <cmd_args_set_defaults+0x9d>
    c902:	40 80 fe 55          	cmp    $0x55,%sil
    c906:	74 43                	je     c94b <cmd_args_set_defaults+0x86>
    c908:	40 84 f6             	test   %sil,%sil
    c90b:	75 67                	jne    c974 <cmd_args_set_defaults+0xaf>
    c90d:	eb c1                	jmp    c8d0 <cmd_args_set_defaults+0xb>
    c90f:	40 80 fe 69          	cmp    $0x69,%sil
    c913:	74 42                	je     c957 <cmd_args_set_defaults+0x92>
    c915:	7f 12                	jg     c929 <cmd_args_set_defaults+0x64>
    c917:	40 80 fe 64          	cmp    $0x64,%sil
    c91b:	75 57                	jne    c974 <cmd_args_set_defaults+0xaf>
			*(double *)args_struct[count].dest = NAN;
    c91d:	48 8b 0d 94 42 02 00 	mov    0x24294(%rip),%rcx        # 30bb8 <__func__.9913+0x38>
    c924:	48 89 08             	mov    %rcx,(%rax)
			break;
    c927:	eb a7                	jmp    c8d0 <cmd_args_set_defaults+0xb>
		switch (args_struct[count].type) {
    c929:	40 80 fe 73          	cmp    $0x73,%sil
    c92d:	74 13                	je     c942 <cmd_args_set_defaults+0x7d>
    c92f:	40 80 fe 75          	cmp    $0x75,%sil
    c933:	75 3f                	jne    c974 <cmd_args_set_defaults+0xaf>
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
    c935:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%rax)
			break;
    c93b:	eb 93                	jmp    c8d0 <cmd_args_set_defaults+0xb>
			*(bool *)args_struct[count].dest = false;
    c93d:	c6 00 00             	movb   $0x0,(%rax)
			break;
    c940:	eb 8e                	jmp    c8d0 <cmd_args_set_defaults+0xb>
			*(char **)args_struct[count].dest = NULL;
    c942:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			break;
    c949:	eb 85                	jmp    c8d0 <cmd_args_set_defaults+0xb>
			*(uint64_t *)args_struct[count].dest = UINT64_MAX;
    c94b:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
			break;
    c952:	e9 79 ff ff ff       	jmpq   c8d0 <cmd_args_set_defaults+0xb>
			*(int32_t *)args_struct[count].dest = INT32_MAX;
    c957:	c7 00 ff ff ff 7f    	movl   $0x7fffffff,(%rax)
			break;
    c95d:	e9 6e ff ff ff       	jmpq   c8d0 <cmd_args_set_defaults+0xb>
			*(int64_t *)args_struct[count].dest = INT64_MAX;
    c962:	48 b9 ff ff ff ff ff 	movabs $0x7fffffffffffffff,%rcx
    c969:	ff ff 7f 
    c96c:	48 89 08             	mov    %rcx,(%rax)
			break;
    c96f:	e9 5c ff ff ff       	jmpq   c8d0 <cmd_args_set_defaults+0xb>
			posix_print_error_and_exit(CMD_TYPE_ERROR,
    c974:	48 8d 3d 47 56 02 00 	lea    0x25647(%rip),%rdi        # 31fc2 <__func__.5785+0x135a>
    c97b:	31 c0                	xor    %eax,%eax
    c97d:	e8 40 f9 ff ff       	callq  c2c2 <posix_print_error_and_exit>
			break;
    c982:	e9 49 ff ff ff       	jmpq   c8d0 <cmd_args_set_defaults+0xb>
}
    c987:	58                   	pop    %rax
    c988:	5b                   	pop    %rbx
    c989:	5d                   	pop    %rbp
    c98a:	c3                   	retq   

000000000000c98b <cmd_print_switches_help>:

/**
 * Print short list of available switches
 */
void cmd_print_switches_help(struct args_struct_t args_struct[])
{
    c98b:	41 56                	push   %r14
    c98d:	41 55                	push   %r13
    c98f:	49 89 fd             	mov    %rdi,%r13
    c992:	41 54                	push   %r12
    c994:	55                   	push   %rbp
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
    c995:	48 8d 0d 4b 56 02 00 	lea    0x2564b(%rip),%rcx        # 31fe7 <__func__.5785+0x137f>
    c99c:	53                   	push   %rbx
    c99d:	48 8d 15 5c 56 02 00 	lea    0x2565c(%rip),%rdx        # 32000 <__func__.5785+0x1398>
    c9a4:	be 01 00 00 00       	mov    $0x1,%esi
	int count = 0;
	int printed_in_line = strlen(_HELP_SWITCH) + 1;
    c9a9:	41 be 19 00 00 00    	mov    $0x19,%r14d
	int count = 0;
    c9af:	45 31 e4             	xor    %r12d,%r12d
{
    c9b2:	48 83 ec 50          	sub    $0x50,%rsp

	fprintf(stdout, "%s ", _HELP_SWITCH);
    c9b6:	48 8b 1d 83 95 22 00 	mov    0x229583(%rip),%rbx        # 235f40 <stdout@GLIBC_2.2.5>
{
    c9bd:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    c9c4:	00 00 
    c9c6:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    c9cb:	31 c0                	xor    %eax,%eax
    c9cd:	48 8d 6c 24 02       	lea    0x2(%rsp),%rbp
    c9d2:	48 8b 3b             	mov    (%rbx),%rdi
    c9d5:	e8 86 7d ff ff       	callq  4760 <__fprintf_chk@plt>

	while (args_struct[count].option != NULL) {
    c9da:	49 63 f4             	movslq %r12d,%rsi
    c9dd:	48 6b f6 38          	imul   $0x38,%rsi,%rsi
    c9e1:	4c 01 ee             	add    %r13,%rsi
    c9e4:	48 83 7e 08 00       	cmpq   $0x0,0x8(%rsi)
    c9e9:	74 77                	je     ca62 <cmd_print_switches_help+0xd7>
    c9eb:	48 89 ef             	mov    %rbp,%rdi
    c9ee:	e8 4b fb ff ff       	callq  c53e <cmd_gen_switch_syntax.part.0.constprop.1>
		char stringy[_MAX_STRINGY_LEN];

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
				      &args_struct[count]);

		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
    c9f3:	31 c0                	xor    %eax,%eax
    c9f5:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    c9f9:	48 89 ef             	mov    %rbp,%rdi
    c9fc:	f2 ae                	repnz scas %es:(%rdi),%al
    c9fe:	49 63 c6             	movslq %r14d,%rax
    ca01:	48 89 ca             	mov    %rcx,%rdx
    ca04:	48 f7 d2             	not    %rdx
    ca07:	48 8d 44 02 ff       	lea    -0x1(%rdx,%rax,1),%rax
    ca0c:	48 83 f8 64          	cmp    $0x64,%rax
    ca10:	76 19                	jbe    ca2b <cmd_print_switches_help+0xa0>
    ca12:	48 8b 3b             	mov    (%rbx),%rdi
    ca15:	48 8d 15 64 56 02 00 	lea    0x25664(%rip),%rdx        # 32080 <__func__.5785+0x1418>
    ca1c:	be 01 00 00 00       	mov    $0x1,%esi
    ca21:	31 c0                	xor    %eax,%eax
			fprintf(stdout, "\n");
			printed_in_line = 0;
    ca23:	45 31 f6             	xor    %r14d,%r14d
    ca26:	e8 35 7d ff ff       	callq  4760 <__fprintf_chk@plt>
    ca2b:	48 8b 3b             	mov    (%rbx),%rdi
    ca2e:	48 8d 15 ee 46 02 00 	lea    0x246ee(%rip),%rdx        # 31123 <__func__.5785+0x4bb>
    ca35:	48 89 e9             	mov    %rbp,%rcx
    ca38:	be 01 00 00 00       	mov    $0x1,%esi
    ca3d:	31 c0                	xor    %eax,%eax
		}

		fprintf(stdout, "%s", stringy);
		printed_in_line += strlen(stringy);
		count++;
    ca3f:	41 ff c4             	inc    %r12d
    ca42:	e8 19 7d ff ff       	callq  4760 <__fprintf_chk@plt>
		printed_in_line += strlen(stringy);
    ca47:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    ca4b:	31 c0                	xor    %eax,%eax
    ca4d:	48 89 ef             	mov    %rbp,%rdi
    ca50:	f2 ae                	repnz scas %es:(%rdi),%al
    ca52:	48 89 ca             	mov    %rcx,%rdx
    ca55:	48 f7 d2             	not    %rdx
    ca58:	45 8d 74 16 ff       	lea    -0x1(%r14,%rdx,1),%r14d
    ca5d:	e9 78 ff ff ff       	jmpq   c9da <cmd_print_switches_help+0x4f>
    ca62:	48 8b 3b             	mov    (%rbx),%rdi
    ca65:	48 8d 15 14 56 02 00 	lea    0x25614(%rip),%rdx        # 32080 <__func__.5785+0x1418>
    ca6c:	31 c0                	xor    %eax,%eax
    ca6e:	be 01 00 00 00       	mov    $0x1,%esi
    ca73:	e8 e8 7c ff ff       	callq  4760 <__fprintf_chk@plt>
	}

	fprintf(stdout, "\n");
}
    ca78:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    ca7d:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    ca84:	00 00 
    ca86:	74 05                	je     ca8d <cmd_print_switches_help+0x102>
    ca88:	e8 b3 7b ff ff       	callq  4640 <__stack_chk_fail@plt>
    ca8d:	48 83 c4 50          	add    $0x50,%rsp
    ca91:	5b                   	pop    %rbx
    ca92:	5d                   	pop    %rbp
    ca93:	41 5c                	pop    %r12
    ca95:	41 5d                	pop    %r13
    ca97:	41 5e                	pop    %r14
    ca99:	c3                   	retq   

000000000000ca9a <cmd_print_long_help>:

/**
 * Print the long help message of the program
 */
void cmd_print_long_help(struct args_struct_t args_struct[])
{
    ca9a:	41 57                	push   %r15
    ca9c:	41 56                	push   %r14
    ca9e:	49 89 fe             	mov    %rdi,%r14
    caa1:	41 55                	push   %r13
    caa3:	41 54                	push   %r12
	int ret;
	int count = 0;
    caa5:	45 31 e4             	xor    %r12d,%r12d
{
    caa8:	55                   	push   %rbp
    caa9:	53                   	push   %rbx
    caaa:	48 83 ec 68          	sub    $0x68,%rsp
    caae:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    cab5:	00 00 
    cab7:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
    cabc:	31 c0                	xor    %eax,%eax
	int printed_in_line = 0;
	char stringy[_MAX_STRINGY_LEN];

	cmd_print_switches_help(args_struct);
    cabe:	e8 c8 fe ff ff       	callq  c98b <cmd_print_switches_help>

	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
    cac3:	48 8b 1d 76 94 22 00 	mov    0x229476(%rip),%rbx        # 235f40 <stdout@GLIBC_2.2.5>
    caca:	4c 8d 0d 33 55 02 00 	lea    0x25533(%rip),%r9        # 32004 <__func__.5785+0x139c>
    cad1:	4c 8d 05 0f 55 02 00 	lea    0x2550f(%rip),%r8        # 31fe7 <__func__.5785+0x137f>
    cad8:	48 8d 15 37 55 02 00 	lea    0x25537(%rip),%rdx        # 32016 <__func__.5785+0x13ae>
    cadf:	b9 1d 00 00 00       	mov    $0x1d,%ecx
    cae4:	be 01 00 00 00       	mov    $0x1,%esi
    cae9:	31 c0                	xor    %eax,%eax
    caeb:	48 8b 3b             	mov    (%rbx),%rdi
    caee:	e8 6d 7c ff ff       	callq  4760 <__fprintf_chk@plt>
		_HELP_SWITCH, _HELP_DESCR);

	while (args_struct[count].option != NULL) {
    caf3:	49 63 ec             	movslq %r12d,%rbp
    caf6:	48 6b ed 38          	imul   $0x38,%rbp,%rbp
    cafa:	4c 01 f5             	add    %r14,%rbp
    cafd:	48 83 7d 08 00       	cmpq   $0x0,0x8(%rbp)
    cb02:	0f 84 c7 00 00 00    	je     cbcf <cmd_print_long_help+0x135>
    cb08:	4c 8d 44 24 12       	lea    0x12(%rsp),%r8
    cb0d:	48 89 ee             	mov    %rbp,%rsi
    cb10:	4c 89 c7             	mov    %r8,%rdi
    cb13:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
    cb18:	e8 21 fa ff ff       	callq  c53e <cmd_gen_switch_syntax.part.0.constprop.1>
    cb1d:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
    cb22:	48 8b 3b             	mov    (%rbx),%rdi
    cb25:	48 8d 15 f5 54 02 00 	lea    0x254f5(%rip),%rdx        # 32021 <__func__.5785+0x13b9>
    cb2c:	b9 1d 00 00 00       	mov    $0x1d,%ecx
    cb31:	be 01 00 00 00       	mov    $0x1,%esi
    cb36:	31 c0                	xor    %eax,%eax
    cb38:	e8 23 7c ff ff       	callq  4760 <__fprintf_chk@plt>
				      &args_struct[count]);

		ret = fprintf(stdout, " %-*s:", _LONG_HELP_ALIGN-1, stringy);
		printed_in_line = ret;
		printed_right = 0;
		toprint = args_struct[count].descript;
    cb3d:	4c 8b 6d 30          	mov    0x30(%rbp),%r13
    cb41:	89 c2                	mov    %eax,%edx
		total_to_print = strlen(toprint);
    cb43:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    cb47:	31 c0                	xor    %eax,%eax
    cb49:	4c 89 ef             	mov    %r13,%rdi
    cb4c:	4d 89 e8             	mov    %r13,%r8
    cb4f:	f2 ae                	repnz scas %es:(%rdi),%al
    cb51:	48 8b 3b             	mov    (%rbx),%rdi
    cb54:	48 89 ce             	mov    %rcx,%rsi
		ret = fprintf(stdout, "%.*s\n",
    cb57:	b9 64 00 00 00       	mov    $0x64,%ecx
		total_to_print = strlen(toprint);
    cb5c:	48 f7 d6             	not    %rsi
		ret = fprintf(stdout, "%.*s\n",
    cb5f:	29 d1                	sub    %edx,%ecx
    cb61:	48 8d 15 c0 54 02 00 	lea    0x254c0(%rip),%rdx        # 32028 <__func__.5785+0x13c0>
		total_to_print = strlen(toprint);
    cb68:	44 8d 7e ff          	lea    -0x1(%rsi),%r15d
    cb6c:	be 01 00 00 00       	mov    $0x1,%esi
    cb71:	e8 ea 7b ff ff       	callq  4760 <__fprintf_chk@plt>
				_MAX_LINE_WIDTH - printed_in_line,
				&toprint[printed_right]);
		printed_right += ret - 1;
    cb76:	8d 68 ff             	lea    -0x1(%rax),%ebp

		while (printed_right < total_to_print) {
    cb79:	44 39 fd             	cmp    %r15d,%ebp
    cb7c:	7d 49                	jge    cbc7 <cmd_print_long_help+0x12d>
    cb7e:	48 8b 3b             	mov    (%rbx),%rdi
    cb81:	4c 8d 05 f9 54 02 00 	lea    0x254f9(%rip),%r8        # 32081 <__func__.5785+0x1419>
    cb88:	48 8d 15 9f 54 02 00 	lea    0x2549f(%rip),%rdx        # 3202e <__func__.5785+0x13c6>
    cb8f:	b9 1e 00 00 00       	mov    $0x1e,%ecx
    cb94:	be 01 00 00 00       	mov    $0x1,%esi
    cb99:	31 c0                	xor    %eax,%eax
    cb9b:	e8 c0 7b ff ff       	callq  4760 <__fprintf_chk@plt>
    cba0:	48 8b 3b             	mov    (%rbx),%rdi
			fprintf(stdout, "%*s", _LONG_HELP_ALIGN, "");
			ret = fprintf(stdout, "%.*s\n",
    cba3:	4c 63 c5             	movslq %ebp,%r8
    cba6:	48 8d 15 7b 54 02 00 	lea    0x2547b(%rip),%rdx        # 32028 <__func__.5785+0x13c0>
    cbad:	4d 01 e8             	add    %r13,%r8
    cbb0:	b9 46 00 00 00       	mov    $0x46,%ecx
    cbb5:	be 01 00 00 00       	mov    $0x1,%esi
    cbba:	31 c0                	xor    %eax,%eax
    cbbc:	e8 9f 7b ff ff       	callq  4760 <__fprintf_chk@plt>
				      _MAX_LINE_WIDTH - _LONG_HELP_ALIGN,
				      &toprint[printed_right]);
			printed_right += ret - 1;
    cbc1:	8d 6c 05 ff          	lea    -0x1(%rbp,%rax,1),%ebp
    cbc5:	eb b2                	jmp    cb79 <cmd_print_long_help+0xdf>
		}
		count++;
    cbc7:	41 ff c4             	inc    %r12d
    cbca:	e9 24 ff ff ff       	jmpq   caf3 <cmd_print_long_help+0x59>
    cbcf:	48 8b 3b             	mov    (%rbx),%rdi
    cbd2:	48 8d 15 a7 54 02 00 	lea    0x254a7(%rip),%rdx        # 32080 <__func__.5785+0x1418>
    cbd9:	be 01 00 00 00       	mov    $0x1,%esi
    cbde:	31 c0                	xor    %eax,%eax
    cbe0:	e8 7b 7b ff ff       	callq  4760 <__fprintf_chk@plt>
    cbe5:	48 8b 3b             	mov    (%rbx),%rdi
    cbe8:	48 8d 15 43 54 02 00 	lea    0x25443(%rip),%rdx        # 32032 <__func__.5785+0x13ca>
    cbef:	31 c0                	xor    %eax,%eax
    cbf1:	be 01 00 00 00       	mov    $0x1,%esi
    cbf6:	e8 65 7b ff ff       	callq  4760 <__fprintf_chk@plt>
	}
	fprintf(stdout, "\n");
	fprintf(stdout, "Note that which options are available depends on the "
		"enabled features/drivers\n\n");
}
    cbfb:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
    cc00:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    cc07:	00 00 
    cc09:	74 05                	je     cc10 <cmd_print_long_help+0x176>
    cc0b:	e8 30 7a ff ff       	callq  4640 <__stack_chk_fail@plt>
    cc10:	48 83 c4 68          	add    $0x68,%rsp
    cc14:	5b                   	pop    %rbx
    cc15:	5d                   	pop    %rbp
    cc16:	41 5c                	pop    %r12
    cc18:	41 5d                	pop    %r13
    cc1a:	41 5e                	pop    %r14
    cc1c:	41 5f                	pop    %r15
    cc1e:	c3                   	retq   

000000000000cc1f <cmd_parse_one_arg>:
 * Try to find if this argument is in the list (and it is not manual)
 * if it does, try to parse it, set its dest accordingly, and return true
 * if it is not found, return false
 */
bool cmd_parse_one_arg(char *argv, struct args_struct_t args_struct[])
{
    cc1f:	41 56                	push   %r14
    cc21:	41 55                	push   %r13
    cc23:	49 89 f5             	mov    %rsi,%r13
    cc26:	41 54                	push   %r12
    cc28:	55                   	push   %rbp
    cc29:	48 89 fd             	mov    %rdi,%rbp
    cc2c:	53                   	push   %rbx
	int count = 0;
	int ret;

	if (cmd_is_help_option(argv)) {
    cc2d:	e8 9b fa ff ff       	callq  c6cd <cmd_is_help_option>
    cc32:	85 c0                	test   %eax,%eax
    cc34:	74 0f                	je     cc45 <cmd_parse_one_arg+0x26>
		cmd_print_long_help(args_struct);
    cc36:	4c 89 ef             	mov    %r13,%rdi
    cc39:	e8 5c fe ff ff       	callq  ca9a <cmd_print_long_help>
		posix_exit(0);
    cc3e:	31 ff                	xor    %edi,%edi
    cc40:	e8 93 f5 ff ff       	callq  c1d8 <posix_exit>
{
    cc45:	45 31 f6             	xor    %r14d,%r14d
	}

	while (args_struct[count].option != NULL) {
    cc48:	49 63 de             	movslq %r14d,%rbx
    cc4b:	48 6b db 38          	imul   $0x38,%rbx,%rbx
    cc4f:	4c 01 eb             	add    %r13,%rbx
    cc52:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    cc56:	48 85 f6             	test   %rsi,%rsi
    cc59:	74 78                	je     ccd3 <cmd_parse_one_arg+0xb4>
		if (args_struct[count].manual) {
    cc5b:	80 3b 00             	cmpb   $0x0,(%rbx)
    cc5e:	75 6b                	jne    cccb <cmd_parse_one_arg+0xac>
			count++;
			continue;
		}
		ret = cmd_is_option(argv, args_struct[count].option,
				    !args_struct[count].is_switch);
    cc60:	8a 53 02             	mov    0x2(%rbx),%dl
		ret = cmd_is_option(argv, args_struct[count].option,
    cc63:	48 89 ef             	mov    %rbp,%rdi
				    !args_struct[count].is_switch);
    cc66:	83 f2 01             	xor    $0x1,%edx
		ret = cmd_is_option(argv, args_struct[count].option,
    cc69:	0f b6 d2             	movzbl %dl,%edx
    cc6c:	e8 b6 f9 ff ff       	callq  c627 <cmd_is_option>
		if (ret) {
    cc71:	85 c0                	test   %eax,%eax
		ret = cmd_is_option(argv, args_struct[count].option,
    cc73:	41 89 c4             	mov    %eax,%r12d
		if (ret) {
    cc76:	74 53                	je     cccb <cmd_parse_one_arg+0xac>
	if (arg_element->dest != NULL) {
    cc78:	48 8b 73 20          	mov    0x20(%rbx),%rsi
    cc7c:	48 85 f6             	test   %rsi,%rsi
    cc7f:	74 33                	je     ccb4 <cmd_parse_one_arg+0x95>
		if (arg_element->is_switch) {
    cc81:	80 7b 02 00          	cmpb   $0x0,0x2(%rbx)
    cc85:	0f be 53 18          	movsbl 0x18(%rbx),%edx
    cc89:	74 1a                	je     cca5 <cmd_parse_one_arg+0x86>
			if (arg_element->type == 'b') {
    cc8b:	80 fa 62             	cmp    $0x62,%dl
    cc8e:	75 05                	jne    cc95 <cmd_parse_one_arg+0x76>
				*(bool *)arg_element->dest = true;
    cc90:	c6 06 01             	movb   $0x1,(%rsi)
    cc93:	eb 1f                	jmp    ccb4 <cmd_parse_one_arg+0x95>
				posix_print_error_and_exit(CMD_ERR_BOOL_SWI);
    cc95:	48 8d 3d e6 53 02 00 	lea    0x253e6(%rip),%rdi        # 32082 <__func__.5785+0x141a>
    cc9c:	31 c0                	xor    %eax,%eax
    cc9e:	e8 1f f6 ff ff       	callq  c2c2 <posix_print_error_and_exit>
    cca3:	eb 0f                	jmp    ccb4 <cmd_parse_one_arg+0x95>
			cmd_read_option_value(&argv[offset],
    cca5:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    cca9:	48 63 f8             	movslq %eax,%rdi
    ccac:	48 01 ef             	add    %rbp,%rdi
    ccaf:	e8 7a fa ff ff       	callq  c72e <cmd_read_option_value>
	if (arg_element->call_when_found) {
    ccb4:	48 8b 53 28          	mov    0x28(%rbx),%rdx
			cmd_handle_this_matched_arg(argv,
						    ret,
						    &args_struct[count]);
			return true;
    ccb8:	b0 01                	mov    $0x1,%al
	if (arg_element->call_when_found) {
    ccba:	48 85 d2             	test   %rdx,%rdx
    ccbd:	74 16                	je     ccd5 <cmd_parse_one_arg+0xb6>
		arg_element->call_when_found(argv, offset);
    ccbf:	44 89 e6             	mov    %r12d,%esi
    ccc2:	48 89 ef             	mov    %rbp,%rdi
    ccc5:	ff d2                	callq  *%rdx
			return true;
    ccc7:	b0 01                	mov    $0x1,%al
    ccc9:	eb 0a                	jmp    ccd5 <cmd_parse_one_arg+0xb6>
    cccb:	49 ff c6             	inc    %r14
    ccce:	e9 75 ff ff ff       	jmpq   cc48 <cmd_parse_one_arg+0x29>
		}
		count++;
	}
	return false;
    ccd3:	31 c0                	xor    %eax,%eax
}
    ccd5:	5b                   	pop    %rbx
    ccd6:	5d                   	pop    %rbp
    ccd7:	41 5c                	pop    %r12
    ccd9:	41 5d                	pop    %r13
    ccdb:	41 5e                	pop    %r14
    ccdd:	c3                   	retq   

000000000000ccde <native_cleanup_cmd_line>:
static int args_aval;
#define ARGS_ALLOC_CHUNK_SIZE 20

void native_cleanup_cmd_line(void)
{
	if (args_struct != NULL) { /* LCOV_EXCL_BR_LINE */
    ccde:	48 8b 3d 73 b2 24 00 	mov    0x24b273(%rip),%rdi        # 257f58 <args_struct>
    cce5:	48 85 ff             	test   %rdi,%rdi
    cce8:	74 16                	je     cd00 <native_cleanup_cmd_line+0x22>
{
    ccea:	48 83 ec 08          	sub    $0x8,%rsp
		free(args_struct);
    ccee:	e8 6d 79 ff ff       	callq  4660 <free@plt>
		args_struct = NULL;
    ccf3:	48 c7 05 5a b2 24 00 	movq   $0x0,0x24b25a(%rip)        # 257f58 <args_struct>
    ccfa:	00 00 00 00 
	}
}
    ccfe:	58                   	pop    %rax
    ccff:	c3                   	retq   
    cd00:	c3                   	retq   

000000000000cd01 <native_add_command_line_opts>:
 *
 * Each option to be added is described in one entry of the input <args>
 * This input must be terminated with an entry containing ARG_TABLE_ENDMARKER.
 */
void native_add_command_line_opts(struct args_struct_t *args)
{
    cd01:	41 55                	push   %r13
    cd03:	41 54                	push   %r12
	int count = 0;
    cd05:	45 31 ed             	xor    %r13d,%r13d
{
    cd08:	55                   	push   %rbp
    cd09:	53                   	push   %rbx
    cd0a:	48 89 fd             	mov    %rdi,%rbp
    cd0d:	48 83 ec 08          	sub    $0x8,%rsp

	while (args[count].option != NULL) {
    cd11:	49 63 c5             	movslq %r13d,%rax
    cd14:	41 8d 5d 01          	lea    0x1(%r13),%ebx
    cd18:	48 6b c0 38          	imul   $0x38,%rax,%rax
    cd1c:	48 83 7c 05 08 00    	cmpq   $0x0,0x8(%rbp,%rax,1)
    cd22:	74 05                	je     cd29 <native_add_command_line_opts+0x28>
    cd24:	41 89 dd             	mov    %ebx,%r13d
    cd27:	eb e8                	jmp    cd11 <native_add_command_line_opts+0x10>
		count++;
	}
	count++; /*for the end marker*/

	if (used_args + count >= args_aval) {
    cd29:	8b 15 59 23 25 00    	mov    0x252359(%rip),%edx        # 25f088 <used_args>
    cd2f:	8b 05 4f 23 25 00    	mov    0x25234f(%rip),%eax        # 25f084 <args_aval>
    cd35:	01 da                	add    %ebx,%edx
    cd37:	39 c2                	cmp    %eax,%edx
    cd39:	7c 44                	jl     cd7f <native_add_command_line_opts+0x7e>
		if (growby < ARGS_ALLOC_CHUNK_SIZE) {
			growby = ARGS_ALLOC_CHUNK_SIZE;
		}

		struct args_struct_t *new_args_struct = realloc(args_struct,
				      (args_aval + growby)*
    cd3b:	83 fb 14             	cmp    $0x14,%ebx
    cd3e:	41 bc 14 00 00 00    	mov    $0x14,%r12d
		struct args_struct_t *new_args_struct = realloc(args_struct,
    cd44:	48 8b 3d 0d b2 24 00 	mov    0x24b20d(%rip),%rdi        # 257f58 <args_struct>
				      (args_aval + growby)*
    cd4b:	44 0f 4d e3          	cmovge %ebx,%r12d
    cd4f:	41 01 c4             	add    %eax,%r12d
    cd52:	49 63 f4             	movslq %r12d,%rsi
		struct args_struct_t *new_args_struct = realloc(args_struct,
    cd55:	48 6b f6 38          	imul   $0x38,%rsi,%rsi
    cd59:	e8 f2 79 ff ff       	callq  4750 <realloc@plt>
				      sizeof(struct args_struct_t));
		args_aval += growby;
		/* LCOV_EXCL_START */
		if (new_args_struct == NULL) {
    cd5e:	48 85 c0             	test   %rax,%rax
		args_aval += growby;
    cd61:	44 89 25 1c 23 25 00 	mov    %r12d,0x25231c(%rip)        # 25f084 <args_aval>
		if (new_args_struct == NULL) {
    cd68:	75 0e                	jne    cd78 <native_add_command_line_opts+0x77>
			posix_print_error_and_exit("Could not allocate memory");
    cd6a:	48 8d 3d 5c 53 02 00 	lea    0x2535c(%rip),%rdi        # 320cd <__func__.5785+0x1465>
    cd71:	e8 4c f5 ff ff       	callq  c2c2 <posix_print_error_and_exit>
    cd76:	eb 07                	jmp    cd7f <native_add_command_line_opts+0x7e>
		} else {
			args_struct = new_args_struct;
    cd78:	48 89 05 d9 b1 24 00 	mov    %rax,0x24b1d9(%rip)        # 257f58 <args_struct>
		}
		/* LCOV_EXCL_STOP */
	}

	memcpy(&args_struct[used_args], args,
    cd7f:	48 63 05 02 23 25 00 	movslq 0x252302(%rip),%rax        # 25f088 <used_args>
    cd86:	48 63 cb             	movslq %ebx,%rcx
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    cd89:	48 89 ee             	mov    %rbp,%rsi
    cd8c:	48 6b c9 38          	imul   $0x38,%rcx,%rcx
    cd90:	48 89 c2             	mov    %rax,%rdx
    cd93:	48 6b c0 38          	imul   $0x38,%rax,%rax
		count*sizeof(struct args_struct_t));

	used_args += count - 1;
    cd97:	41 01 d5             	add    %edx,%r13d
	memcpy(&args_struct[used_args], args,
    cd9a:	48 03 05 b7 b1 24 00 	add    0x24b1b7(%rip),%rax        # 257f58 <args_struct>
	used_args += count - 1;
    cda1:	44 89 2d e0 22 25 00 	mov    %r13d,0x2522e0(%rip)        # 25f088 <used_args>
    cda8:	48 89 c7             	mov    %rax,%rdi
    cdab:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
	/*
	 * -1 as the end marker should be overwritten next time something
	 * is added
	 */
}
    cdad:	58                   	pop    %rax
    cdae:	5b                   	pop    %rbx
    cdaf:	5d                   	pop    %rbp
    cdb0:	41 5c                	pop    %r12
    cdb2:	41 5d                	pop    %r13
    cdb4:	c3                   	retq   

000000000000cdb5 <native_add_testargs_option>:
		(void *)NULL, NULL,
		"Any argument that follows will be ignored by the top level, "
		"and made available for possible tests"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(testargs_options);
    cdb5:	48 8d 3d 84 97 22 00 	lea    0x229784(%rip),%rdi        # 236540 <testargs_options.2492>
    cdbc:	e9 40 ff ff ff       	jmpq   cd01 <native_add_command_line_opts>

000000000000cdc1 <native_handle_cmd_line>:
 * Handle possible command line arguments.
 *
 * We also store them for later use by possible test applications
 */
void native_handle_cmd_line(int argc, char *argv[])
{
    cdc1:	41 57                	push   %r15
    cdc3:	41 56                	push   %r14

	cmd_args_set_defaults(args_struct);

	for (i = 1; i < argc; i++) {

		if ((cmd_is_option(argv[i], "testargs", 0))) {
    cdc5:	4c 8d 3d 1b 53 02 00 	lea    0x2531b(%rip),%r15        # 320e7 <__func__.5785+0x147f>
{
    cdcc:	41 55                	push   %r13
    cdce:	41 54                	push   %r12
    cdd0:	49 89 f4             	mov    %rsi,%r12
    cdd3:	55                   	push   %rbp
    cdd4:	53                   	push   %rbx
    cdd5:	89 fb                	mov    %edi,%ebx
	for (i = 1; i < argc; i++) {
    cdd7:	bd 01 00 00 00       	mov    $0x1,%ebp
{
    cddc:	48 83 ec 08          	sub    $0x8,%rsp
	native_add_tracing_options();
    cde0:	e8 4d f7 ff ff       	callq  c532 <native_add_tracing_options>
	native_add_testargs_option();
    cde5:	e8 cb ff ff ff       	callq  cdb5 <native_add_testargs_option>
	cmd_args_set_defaults(args_struct);
    cdea:	48 8b 3d 67 b1 24 00 	mov    0x24b167(%rip),%rdi        # 257f58 <args_struct>
	s_argv = argv;
    cdf1:	4c 89 25 70 b1 24 00 	mov    %r12,0x24b170(%rip)        # 257f68 <s_argv>
	s_argc = argc;
    cdf8:	89 1d 92 22 25 00    	mov    %ebx,0x252292(%rip)        # 25f090 <s_argc>
	cmd_args_set_defaults(args_struct);
    cdfe:	e8 c2 fa ff ff       	callq  c8c5 <cmd_args_set_defaults>
	for (i = 1; i < argc; i++) {
    ce03:	39 dd                	cmp    %ebx,%ebp
    ce05:	41 89 ee             	mov    %ebp,%r14d
    ce08:	7d 65                	jge    ce6f <native_handle_cmd_line+0xae>
		if ((cmd_is_option(argv[i], "testargs", 0))) {
    ce0a:	49 8b 3c ec          	mov    (%r12,%rbp,8),%rdi
    ce0e:	31 d2                	xor    %edx,%edx
    ce10:	4c 89 fe             	mov    %r15,%rsi
    ce13:	4c 8d 6d 01          	lea    0x1(%rbp),%r13
    ce17:	e8 0b f8 ff ff       	callq  c627 <cmd_is_option>
    ce1c:	85 c0                	test   %eax,%eax
    ce1e:	74 18                	je     ce38 <native_handle_cmd_line+0x77>
			test_argc = argc - i - 1;
    ce20:	44 29 f3             	sub    %r14d,%ebx
			test_argv = &argv[i+1];
    ce23:	4b 8d 04 ec          	lea    (%r12,%r13,8),%rax
			test_argc = argc - i - 1;
    ce27:	ff cb                	dec    %ebx
    ce29:	89 1d 5d 22 25 00    	mov    %ebx,0x25225d(%rip)        # 25f08c <test_argc>
			test_argv = &argv[i+1];
    ce2f:	48 89 05 2a b1 24 00 	mov    %rax,0x24b12a(%rip)        # 257f60 <test_argv>
			break;
    ce36:	eb 37                	jmp    ce6f <native_handle_cmd_line+0xae>
		}

		if (!cmd_parse_one_arg(argv[i], args_struct)) {
    ce38:	49 8b 3c ec          	mov    (%r12,%rbp,8),%rdi
    ce3c:	48 8b 35 15 b1 24 00 	mov    0x24b115(%rip),%rsi        # 257f58 <args_struct>
    ce43:	e8 d7 fd ff ff       	callq  cc1f <cmd_parse_one_arg>
    ce48:	84 c0                	test   %al,%al
    ce4a:	75 1e                	jne    ce6a <native_handle_cmd_line+0xa9>
			cmd_print_switches_help(args_struct);
    ce4c:	48 8b 3d 05 b1 24 00 	mov    0x24b105(%rip),%rdi        # 257f58 <args_struct>
    ce53:	e8 33 fb ff ff       	callq  c98b <cmd_print_switches_help>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
    ce58:	49 8b 34 ec          	mov    (%r12,%rbp,8),%rsi
    ce5c:	48 8d 3d 8d 52 02 00 	lea    0x2528d(%rip),%rdi        # 320f0 <__func__.5785+0x1488>
    ce63:	31 c0                	xor    %eax,%eax
    ce65:	e8 58 f4 ff ff       	callq  c2c2 <posix_print_error_and_exit>
    ce6a:	4c 89 ed             	mov    %r13,%rbp
    ce6d:	eb 94                	jmp    ce03 <native_handle_cmd_line+0x42>
			print_invalid_opt_error(argv[i]);
		}
	}
}
    ce6f:	58                   	pop    %rax
    ce70:	5b                   	pop    %rbx
    ce71:	5d                   	pop    %rbp
    ce72:	41 5c                	pop    %r12
    ce74:	41 5d                	pop    %r13
    ce76:	41 5e                	pop    %r14
    ce78:	41 5f                	pop    %r15
    ce7a:	c3                   	retq   

000000000000ce7b <hw_counter_init>:
/**
 * Initialize the counter with prescaler of HW
 */
void hw_counter_init(void)
{
	hw_counter_timer = NEVER;
    ce7b:	48 8d 15 06 b1 24 00 	lea    0x24b106(%rip),%rdx        # 257f88 <hw_counter_timer>
    ce82:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
	counter_target = NEVER;
	counter_value = 0;
    ce86:	48 c7 05 ef b0 24 00 	movq   $0x0,0x24b0ef(%rip)        # 257f80 <counter_value>
    ce8d:	00 00 00 00 
	counter_target = NEVER;
    ce91:	48 89 05 e0 b0 24 00 	mov    %rax,0x24b0e0(%rip)        # 257f78 <counter_target>
	counter_running = false;
    ce98:	c6 05 4a 22 25 00 00 	movb   $0x0,0x25224a(%rip)        # 25f0e9 <counter_running>
	counter_period = NEVER;
    ce9f:	48 89 05 ca b0 24 00 	mov    %rax,0x24b0ca(%rip)        # 257f70 <counter_period>
	hw_counter_timer = NEVER;
    cea6:	48 89 02             	mov    %rax,(%rdx)
}
    cea9:	c3                   	retq   

000000000000ceaa <hw_counter_triggered>:

void hw_counter_triggered(void)
{
	if (!counter_running) {
    ceaa:	80 3d 38 22 25 00 00 	cmpb   $0x0,0x252238(%rip)        # 25f0e9 <counter_running>
{
    ceb1:	53                   	push   %rbx
    ceb2:	48 8d 1d cf b0 24 00 	lea    0x24b0cf(%rip),%rbx        # 257f88 <hw_counter_timer>
	if (!counter_running) {
    ceb9:	75 09                	jne    cec4 <hw_counter_triggered+0x1a>
		hw_counter_timer = NEVER;
    cebb:	48 c7 03 ff ff ff ff 	movq   $0xffffffffffffffff,(%rbx)
		return;
    cec2:	eb 34                	jmp    cef8 <hw_counter_triggered+0x4e>
	}

	hw_counter_timer = hwm_get_time() + counter_period;
    cec4:	e8 8b ea ff ff       	callq  b954 <hwm_get_time>
    cec9:	48 03 05 a0 b0 24 00 	add    0x24b0a0(%rip),%rax        # 257f70 <counter_period>
    ced0:	48 89 03             	mov    %rax,(%rbx)
	counter_value = counter_value + 1;
    ced3:	48 8b 05 a6 b0 24 00 	mov    0x24b0a6(%rip),%rax        # 257f80 <counter_value>
    ceda:	48 ff c0             	inc    %rax

	if (counter_value == counter_target) {
    cedd:	48 3b 05 94 b0 24 00 	cmp    0x24b094(%rip),%rax        # 257f78 <counter_target>
	counter_value = counter_value + 1;
    cee4:	48 89 05 95 b0 24 00 	mov    %rax,0x24b095(%rip)        # 257f80 <counter_value>
	if (counter_value == counter_target) {
    ceeb:	75 0b                	jne    cef8 <hw_counter_triggered+0x4e>
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
	}
}
    ceed:	5b                   	pop    %rbx
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
    ceee:	bf 02 00 00 00       	mov    $0x2,%edi
    cef3:	e9 5c f2 ff ff       	jmpq   c154 <hw_irq_ctrl_set_irq>
}
    cef8:	5b                   	pop    %rbx
    cef9:	c3                   	retq   

000000000000cefa <sdl_cleanup>:
	}
}

static void sdl_cleanup(void)
{
	SDL_Quit();
    cefa:	e9 91 74 ff ff       	jmpq   4390 <SDL_Quit@plt>

000000000000ceff <sdl_init>:
{
    ceff:	48 83 ec 08          	sub    $0x8,%rsp
	if (SDL_Init(SDL_INIT_VIDEO) != 0) {
    cf03:	bf 20 00 00 00       	mov    $0x20,%edi
    cf08:	e8 93 76 ff ff       	callq  45a0 <SDL_Init@plt>
    cf0d:	85 c0                	test   %eax,%eax
    cf0f:	74 17                	je     cf28 <sdl_init+0x29>
		posix_print_error_and_exit("Error on SDL_Init (%s)\n",
    cf11:	e8 ca 75 ff ff       	callq  44e0 <SDL_GetError@plt>
}
    cf16:	5a                   	pop    %rdx
		posix_print_error_and_exit("Error on SDL_Init (%s)\n",
    cf17:	48 8d 3d 8e 52 02 00 	lea    0x2528e(%rip),%rdi        # 321ac <__func__.5785+0x1544>
    cf1e:	48 89 c6             	mov    %rax,%rsi
    cf21:	31 c0                	xor    %eax,%eax
    cf23:	e9 9a f3 ff ff       	jmpq   c2c2 <posix_print_error_and_exit>
}
    cf28:	58                   	pop    %rax
    cf29:	c3                   	retq   

000000000000cf2a <sdl_handle_events>:
{
    cf2a:	53                   	push   %rbx
    cf2b:	48 83 ec 40          	sub    $0x40,%rsp
    cf2f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    cf36:	00 00 
    cf38:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    cf3d:	31 c0                	xor    %eax,%eax
	sdl_event_timer = hwm_get_time() + 10000;
    cf3f:	e8 10 ea ff ff       	callq  b954 <hwm_get_time>
    cf44:	48 8d 15 45 b0 24 00 	lea    0x24b045(%rip),%rdx        # 257f90 <sdl_event_timer>
    cf4b:	48 05 10 27 00 00    	add    $0x2710,%rax
	while (SDL_PollEvent(&event)) {
    cf51:	48 89 e3             	mov    %rsp,%rbx
	sdl_event_timer = hwm_get_time() + 10000;
    cf54:	48 89 02             	mov    %rax,(%rdx)
	while (SDL_PollEvent(&event)) {
    cf57:	48 89 df             	mov    %rbx,%rdi
    cf5a:	e8 31 75 ff ff       	callq  4490 <SDL_PollEvent@plt>
    cf5f:	85 c0                	test   %eax,%eax
    cf61:	74 46                	je     cfa9 <sdl_handle_events+0x7f>
		switch (event.type) {
    cf63:	8b 04 24             	mov    (%rsp),%eax
    cf66:	3d 00 01 00 00       	cmp    $0x100,%eax
    cf6b:	74 33                	je     cfa0 <sdl_handle_events+0x76>
    cf6d:	3d 00 02 00 00       	cmp    $0x200,%eax
    cf72:	75 e3                	jne    cf57 <sdl_handle_events+0x2d>
	switch (event->window.event) {
    cf74:	80 7c 24 0c 03       	cmpb   $0x3,0xc(%rsp)
    cf79:	75 dc                	jne    cf57 <sdl_handle_events+0x2d>
		window = SDL_GetWindowFromID(event->window.windowID);
    cf7b:	8b 7c 24 08          	mov    0x8(%rsp),%edi
    cf7f:	e8 ac 75 ff ff       	callq  4530 <SDL_GetWindowFromID@plt>
		if (window == NULL) {
    cf84:	48 85 c0             	test   %rax,%rax
    cf87:	74 ce                	je     cf57 <sdl_handle_events+0x2d>
		renderer = SDL_GetRenderer(window);
    cf89:	48 89 c7             	mov    %rax,%rdi
    cf8c:	e8 df 75 ff ff       	callq  4570 <SDL_GetRenderer@plt>
		if (renderer == NULL) {
    cf91:	48 85 c0             	test   %rax,%rax
    cf94:	74 c1                	je     cf57 <sdl_handle_events+0x2d>
		SDL_RenderPresent(renderer);
    cf96:	48 89 c7             	mov    %rax,%rdi
    cf99:	e8 02 74 ff ff       	callq  43a0 <SDL_RenderPresent@plt>
    cf9e:	eb b7                	jmp    cf57 <sdl_handle_events+0x2d>
			posix_exit(0);
    cfa0:	31 ff                	xor    %edi,%edi
    cfa2:	e8 31 f2 ff ff       	callq  c1d8 <posix_exit>
			break;
    cfa7:	eb ae                	jmp    cf57 <sdl_handle_events+0x2d>
}
    cfa9:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    cfae:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    cfb5:	00 00 
    cfb7:	74 05                	je     cfbe <sdl_handle_events+0x94>
    cfb9:	e8 82 76 ff ff       	callq  4640 <__stack_chk_fail@plt>
    cfbe:	48 83 c4 40          	add    $0x40,%rsp
    cfc2:	5b                   	pop    %rbx
    cfc3:	c3                   	retq   

000000000000cfc4 <bt_hex_real>:
#include <bluetooth/bluetooth.h>
#include <bluetooth/uuid.h>
#include <bluetooth/hci.h>

const char *bt_hex_real(const void *buf, size_t len)
{
    cfc4:	48 8d 0d 35 9e 24 00 	lea    0x249e35(%rip),%rcx        # 256e00 <str.6979>
	static const char hex[] = "0123456789abcdef";
	static char str[129];
	const uint8_t *b = buf;
	size_t i;

	len = MIN(len, (sizeof(str) - 1) / 2);
    cfcb:	48 83 fe 40          	cmp    $0x40,%rsi
    cfcf:	b8 40 00 00 00       	mov    $0x40,%eax

	for (i = 0; i < len; i++) {
		str[i * 2]     = hex[b[i] >> 4];
    cfd4:	4c 8d 05 45 38 02 00 	lea    0x23845(%rip),%r8        # 30820 <hex.6978>
	len = MIN(len, (sizeof(str) - 1) / 2);
    cfdb:	48 0f 47 f0          	cmova  %rax,%rsi
	for (i = 0; i < len; i++) {
    cfdf:	31 c0                	xor    %eax,%eax
		str[i * 2 + 1] = hex[b[i] & 0xf];
    cfe1:	4c 8d 51 01          	lea    0x1(%rcx),%r10
	for (i = 0; i < len; i++) {
    cfe5:	48 39 f0             	cmp    %rsi,%rax
    cfe8:	74 28                	je     d012 <bt_hex_real+0x4e>
		str[i * 2]     = hex[b[i] >> 4];
    cfea:	8a 14 07             	mov    (%rdi,%rax,1),%dl
    cfed:	4c 8d 0c 00          	lea    (%rax,%rax,1),%r9
    cff1:	c0 ea 04             	shr    $0x4,%dl
    cff4:	83 e2 0f             	and    $0xf,%edx
    cff7:	41 8a 14 10          	mov    (%r8,%rdx,1),%dl
    cffb:	42 88 14 09          	mov    %dl,(%rcx,%r9,1)
		str[i * 2 + 1] = hex[b[i] & 0xf];
    cfff:	8a 14 07             	mov    (%rdi,%rax,1),%dl
	for (i = 0; i < len; i++) {
    d002:	48 ff c0             	inc    %rax
		str[i * 2 + 1] = hex[b[i] & 0xf];
    d005:	83 e2 0f             	and    $0xf,%edx
    d008:	41 8a 14 10          	mov    (%r8,%rdx,1),%dl
    d00c:	43 88 14 11          	mov    %dl,(%r9,%r10,1)
    d010:	eb d3                	jmp    cfe5 <bt_hex_real+0x21>
	}

	str[i * 2] = '\0';
    d012:	c6 04 41 00          	movb   $0x0,(%rcx,%rax,2)

	return str;
}
    d016:	48 8d 05 e3 9d 24 00 	lea    0x249de3(%rip),%rax        # 256e00 <str.6979>
    d01d:	c3                   	retq   

000000000000d01e <bt_addr_le_str_real>:

	return str;
}

const char *bt_addr_le_str_real(const bt_addr_le_t *addr)
{
    d01e:	55                   	push   %rbp
    d01f:	53                   	push   %rbx
    d020:	48 89 fb             	mov    %rdi,%rbx
    d023:	48 83 ec 28          	sub    $0x28,%rsp
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
				    size_t len)
{
	char type[10];

	switch (addr->type) {
    d027:	0f b6 0f             	movzbl (%rdi),%ecx
    d02a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    d031:	00 00 
    d033:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    d038:	31 c0                	xor    %eax,%eax
    d03a:	48 8d 6c 24 0e       	lea    0xe(%rsp),%rbp
    d03f:	80 f9 01             	cmp    $0x1,%cl
    d042:	74 1e                	je     d062 <bt_addr_le_str_real+0x44>
    d044:	72 13                	jb     d059 <bt_addr_le_str_real+0x3b>
    d046:	80 f9 02             	cmp    $0x2,%cl
    d049:	74 28                	je     d073 <bt_addr_le_str_real+0x55>
    d04b:	80 f9 03             	cmp    $0x3,%cl
    d04e:	75 2c                	jne    d07c <bt_addr_le_str_real+0x5e>
  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
    d050:	48 8d 35 85 51 02 00 	lea    0x25185(%rip),%rsi        # 321dc <__func__.5785+0x1574>
    d057:	eb 10                	jmp    d069 <bt_addr_le_str_real+0x4b>
    d059:	48 8d 35 64 51 02 00 	lea    0x25164(%rip),%rsi        # 321c4 <__func__.5785+0x155c>
    d060:	eb 07                	jmp    d069 <bt_addr_le_str_real+0x4b>
    d062:	48 8d 35 62 51 02 00 	lea    0x25162(%rip),%rsi        # 321cb <__func__.5785+0x1563>
    d069:	48 89 ef             	mov    %rbp,%rdi
    d06c:	e8 5f 75 ff ff       	callq  45d0 <strcpy@plt>
    d071:	eb 1f                	jmp    d092 <bt_addr_le_str_real+0x74>
    d073:	48 8d 35 58 51 02 00 	lea    0x25158(%rip),%rsi        # 321d2 <__func__.5785+0x156a>
    d07a:	eb ed                	jmp    d069 <bt_addr_le_str_real+0x4b>
		break;
	case BT_ADDR_LE_RANDOM_ID:
		strcpy(type, "random-id");
		break;
	default:
		snprintk(type, sizeof(type), "0x%02x", addr->type);
    d07c:	48 8d 15 d6 5d 02 00 	lea    0x25dd6(%rip),%rdx        # 32e59 <__func__.5785+0x21f1>
    d083:	be 0a 00 00 00       	mov    $0xa,%esi
    d088:	48 89 ef             	mov    %rbp,%rdi
    d08b:	31 c0                	xor    %eax,%eax
    d08d:	e8 1a 8a ff ff       	callq  5aac <snprintk>
		break;
	}

	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
    d092:	0f b6 43 01          	movzbl 0x1(%rbx),%eax
    d096:	55                   	push   %rbp
    d097:	48 8d 15 48 51 02 00 	lea    0x25148(%rip),%rdx        # 321e6 <__func__.5785+0x157e>
    d09e:	0f b6 4b 06          	movzbl 0x6(%rbx),%ecx
    d0a2:	44 0f b6 4b 04       	movzbl 0x4(%rbx),%r9d
    d0a7:	48 8d 3d 52 ac 24 00 	lea    0x24ac52(%rip),%rdi        # 257d00 <str.6992>
    d0ae:	44 0f b6 43 05       	movzbl 0x5(%rbx),%r8d
    d0b3:	be 1e 00 00 00       	mov    $0x1e,%esi
    d0b8:	50                   	push   %rax
    d0b9:	0f b6 43 02          	movzbl 0x2(%rbx),%eax
    d0bd:	50                   	push   %rax
    d0be:	0f b6 43 03          	movzbl 0x3(%rbx),%eax
    d0c2:	50                   	push   %rax
    d0c3:	31 c0                	xor    %eax,%eax
    d0c5:	e8 e2 89 ff ff       	callq  5aac <snprintk>
    d0ca:	48 83 c4 20          	add    $0x20,%rsp
	static char str[BT_ADDR_LE_STR_LEN];

	bt_addr_le_to_str(addr, str, sizeof(str));

	return str;
}
    d0ce:	48 8d 05 2b ac 24 00 	lea    0x24ac2b(%rip),%rax        # 257d00 <str.6992>
    d0d5:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
    d0da:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
    d0e1:	00 00 
    d0e3:	74 05                	je     d0ea <bt_addr_le_str_real+0xcc>
    d0e5:	e8 56 75 ff ff       	callq  4640 <__stack_chk_fail@plt>
    d0ea:	48 83 c4 28          	add    $0x28,%rsp
    d0ee:	5b                   	pop    %rbx
    d0ef:	5d                   	pop    %rbp
    d0f0:	c3                   	retq   

000000000000d0f1 <save_id>:
}

#define ID_DATA_LEN(array) (bt_dev.id_count * sizeof(array[0]))

static void save_id(struct k_work *work)
{
    d0f1:	53                   	push   %rbx
    d0f2:	48 8d 1d f7 d2 22 00 	lea    0x22d2f7(%rip),%rbx        # 23a3f0 <log_const_bt_settings>
	int err;
	BT_INFO("Saving ID");
    d0f9:	48 8d 3d 09 51 02 00 	lea    0x25109(%rip),%rdi        # 32209 <__func__.5785+0x15a1>
    d100:	48 2b 1d 49 8e 22 00 	sub    0x228e49(%rip),%rbx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
    d107:	48 c1 eb 04          	shr    $0x4,%rbx
    d10b:	c1 e3 06             	shl    $0x6,%ebx
    d10e:	89 de                	mov    %ebx,%esi
    d110:	83 ce 03             	or     $0x3,%esi
    d113:	e8 ac a1 ff ff       	callq  72c4 <log_0>
	err = settings_save_one("bt/id", &bt_dev.id_addr,
				ID_DATA_LEN(bt_dev.id_addr));
    d118:	48 8d 35 21 95 22 00 	lea    0x229521(%rip),%rsi        # 236640 <bt_dev>
	err = settings_save_one("bt/id", &bt_dev.id_addr,
    d11f:	48 8d 3d ed 50 02 00 	lea    0x250ed(%rip),%rdi        # 32213 <__func__.5785+0x15ab>
				ID_DATA_LEN(bt_dev.id_addr));
    d126:	0f b6 56 07          	movzbl 0x7(%rsi),%edx
	err = settings_save_one("bt/id", &bt_dev.id_addr,
    d12a:	48 6b d2 07          	imul   $0x7,%rdx,%rdx
    d12e:	e8 47 b2 ff ff       	callq  837a <settings_save_one>
	if (err) {
    d133:	85 c0                	test   %eax,%eax
    d135:	74 15                	je     d14c <save_id+0x5b>
		BT_ERR("Failed to save ID (err %d)", err);
    d137:	89 da                	mov    %ebx,%edx
    d139:	48 8d 3d d9 50 02 00 	lea    0x250d9(%rip),%rdi        # 32219 <__func__.5785+0x15b1>
    d140:	48 63 f0             	movslq %eax,%rsi
	err = settings_save_one("bt/irk", bt_dev.irk, ID_DATA_LEN(bt_dev.irk));
	if (err) {
		BT_ERR("Failed to save IRK (err %d)", err);
	}
#endif
}
    d143:	5b                   	pop    %rbx
		BT_ERR("Failed to save ID (err %d)", err);
    d144:	83 ca 01             	or     $0x1,%edx
    d147:	e9 a9 a1 ff ff       	jmpq   72f5 <log_1>
}
    d14c:	5b                   	pop    %rbx
    d14d:	c3                   	retq   

000000000000d14e <set>:
{
    d14e:	41 55                	push   %r13
    d150:	41 54                	push   %r12
    d152:	55                   	push   %rbp
    d153:	53                   	push   %rbx
    d154:	48 83 ec 18          	sub    $0x18,%rsp
    d158:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    d15f:	00 00 
    d161:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    d166:	31 c0                	xor    %eax,%eax
	if (!name) {
    d168:	48 85 ff             	test   %rdi,%rdi
    d16b:	75 29                	jne    d196 <set+0x48>
    d16d:	48 8d 35 7c d2 22 00 	lea    0x22d27c(%rip),%rsi        # 23a3f0 <log_const_bt_settings>
    d174:	48 2b 35 d5 8d 22 00 	sub    0x228dd5(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Insufficient number of arguments");
    d17b:	48 8d 3d b2 50 02 00 	lea    0x250b2(%rip),%rdi        # 32234 <__func__.5785+0x15cc>
    d182:	48 c1 ee 04          	shr    $0x4,%rsi
    d186:	c1 e6 06             	shl    $0x6,%esi
    d189:	83 ce 01             	or     $0x1,%esi
    d18c:	e8 33 a1 ff ff       	callq  72c4 <log_0>
    d191:	e9 47 01 00 00       	jmpq   d2dd <set+0x18f>
	len = settings_name_next(name, &next);
    d196:	48 89 e6             	mov    %rsp,%rsi
    d199:	48 89 fd             	mov    %rdi,%rbp
    d19c:	49 89 d4             	mov    %rdx,%r12
    d19f:	49 89 cd             	mov    %rcx,%r13
    d1a2:	e8 e8 b3 ff ff       	callq  858f <settings_name_next>
	if (!strncmp(name, "id", len)) {
    d1a7:	48 63 d8             	movslq %eax,%rbx
    d1aa:	ba 03 00 00 00       	mov    $0x3,%edx
    d1af:	48 8d 35 23 50 02 00 	lea    0x25023(%rip),%rsi        # 321d9 <__func__.5785+0x1571>
    d1b6:	48 83 fb 03          	cmp    $0x3,%rbx
    d1ba:	48 89 ef             	mov    %rbp,%rdi
    d1bd:	48 0f 4e d3          	cmovle %rbx,%rdx
    d1c1:	e8 8a 72 ff ff       	callq  4450 <strncmp@plt>
    d1c6:	85 c0                	test   %eax,%eax
    d1c8:	0f 85 9c 00 00 00    	jne    d26a <set+0x11c>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    d1ce:	48 8d 2d 6b 94 22 00 	lea    0x22946b(%rip),%rbp        # 236640 <bt_dev>
    d1d5:	8b 9d a0 00 00 00    	mov    0xa0(%rbp),%ebx
 */
static inline bool atomic_test_bit(const atomic_t *target, int bit)
{
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));

	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    d1db:	c1 fb 02             	sar    $0x2,%ebx
		if (atomic_test_bit(bt_dev.flags, BT_DEV_PRESET_ID)) {
    d1de:	83 e3 01             	and    $0x1,%ebx
    d1e1:	74 2b                	je     d20e <set+0xc0>
    d1e3:	48 8d 35 06 d2 22 00 	lea    0x22d206(%rip),%rsi        # 23a3f0 <log_const_bt_settings>
    d1ea:	48 2b 35 5f 8d 22 00 	sub    0x228d5f(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_WARN("Ignoring identities stored in flash");
    d1f1:	48 8d 3d 5d 50 02 00 	lea    0x2505d(%rip),%rdi        # 32255 <__func__.5785+0x15ed>
			return 0;
    d1f8:	31 db                	xor    %ebx,%ebx
    d1fa:	48 c1 ee 04          	shr    $0x4,%rsi
			BT_WARN("Ignoring identities stored in flash");
    d1fe:	c1 e6 06             	shl    $0x6,%esi
    d201:	83 ce 02             	or     $0x2,%esi
    d204:	e8 bb a0 ff ff       	callq  72c4 <log_0>
			return 0;
    d209:	e9 d4 00 00 00       	jmpq   d2e2 <set+0x194>
		len = read_cb(cb_arg, &bt_dev.id_addr, sizeof(bt_dev.id_addr));
    d20e:	ba 07 00 00 00       	mov    $0x7,%edx
    d213:	48 89 ee             	mov    %rbp,%rsi
    d216:	4c 89 ef             	mov    %r13,%rdi
    d219:	41 ff d4             	callq  *%r12
		if (len < sizeof(bt_dev.id_addr[0])) {
    d21c:	48 83 f8 06          	cmp    $0x6,%rax
    d220:	77 39                	ja     d25b <set+0x10d>
    d222:	48 8d 35 c7 d1 22 00 	lea    0x22d1c7(%rip),%rsi        # 23a3f0 <log_const_bt_settings>
    d229:	48 2b 35 20 8d 22 00 	sub    0x228d20(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
				BT_ERR("Invalid length ID address in storage");
    d230:	48 8d 3d 42 50 02 00 	lea    0x25042(%rip),%rdi        # 32279 <__func__.5785+0x1611>
    d237:	48 c1 ee 04          	shr    $0x4,%rsi
    d23b:	c1 e6 06             	shl    $0x6,%esi
    d23e:	83 ce 01             	or     $0x1,%esi
    d241:	e8 7e a0 ff ff       	callq  72c4 <log_0>
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    d246:	b9 07 00 00 00       	mov    $0x7,%ecx
    d24b:	31 c0                	xor    %eax,%eax
    d24d:	48 89 ef             	mov    %rbp,%rdi
    d250:	f3 aa                	rep stos %al,%es:(%rdi)
			bt_dev.id_count = 0U;
    d252:	c6 45 07 00          	movb   $0x0,0x7(%rbp)
    d256:	e9 87 00 00 00       	jmpq   d2e2 <set+0x194>
			bt_dev.id_count = len / sizeof(bt_dev.id_addr[0]);
    d25b:	b9 07 00 00 00       	mov    $0x7,%ecx
    d260:	31 d2                	xor    %edx,%edx
    d262:	48 f7 f1             	div    %rcx
    d265:	88 45 07             	mov    %al,0x7(%rbp)
    d268:	eb 78                	jmp    d2e2 <set+0x194>
	if (!strncmp(name, "name", len)) {
    d26a:	48 83 fb 05          	cmp    $0x5,%rbx
    d26e:	ba 05 00 00 00       	mov    $0x5,%edx
    d273:	48 8d 35 0e 56 02 00 	lea    0x2560e(%rip),%rsi        # 32888 <__func__.5785+0x1c20>
    d27a:	48 0f 4e d3          	cmovle %rbx,%rdx
    d27e:	48 89 ef             	mov    %rbp,%rdi
    d281:	e8 ca 71 ff ff       	callq  4450 <strncmp@plt>
    d286:	85 c0                	test   %eax,%eax
    d288:	89 c3                	mov    %eax,%ebx
    d28a:	75 51                	jne    d2dd <set+0x18f>
		len = read_cb(cb_arg, &bt_dev.name, sizeof(bt_dev.name) - 1);
    d28c:	48 8d 2d ad 93 22 00 	lea    0x2293ad(%rip),%rbp        # 236640 <bt_dev>
    d293:	ba 41 00 00 00       	mov    $0x41,%edx
    d298:	4c 89 ef             	mov    %r13,%rdi
    d29b:	48 8d b5 b0 01 00 00 	lea    0x1b0(%rbp),%rsi
    d2a2:	41 ff d4             	callq  *%r12
		if (len < 0) {
    d2a5:	48 85 c0             	test   %rax,%rax
    d2a8:	79 29                	jns    d2d3 <set+0x185>
    d2aa:	48 8d 15 3f d1 22 00 	lea    0x22d13f(%rip),%rdx        # 23a3f0 <log_const_bt_settings>
    d2b1:	48 2b 15 98 8c 22 00 	sub    0x228c98(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Failed to read device name from storage"
    d2b8:	48 8d 3d df 4f 02 00 	lea    0x24fdf(%rip),%rdi        # 3229e <__func__.5785+0x1636>
    d2bf:	48 89 c6             	mov    %rax,%rsi
    d2c2:	48 c1 ea 04          	shr    $0x4,%rdx
    d2c6:	c1 e2 06             	shl    $0x6,%edx
    d2c9:	83 ca 01             	or     $0x1,%edx
    d2cc:	e8 24 a0 ff ff       	callq  72f5 <log_1>
    d2d1:	eb 0f                	jmp    d2e2 <set+0x194>
			bt_dev.name[len] = '\0';
    d2d3:	c6 84 05 b0 01 00 00 	movb   $0x0,0x1b0(%rbp,%rax,1)
    d2da:	00 
    d2db:	eb 05                	jmp    d2e2 <set+0x194>
	return -ENOENT;
    d2dd:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
}
    d2e2:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    d2e7:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    d2ee:	00 00 
    d2f0:	89 d8                	mov    %ebx,%eax
    d2f2:	74 05                	je     d2f9 <set+0x1ab>
    d2f4:	e8 47 73 ff ff       	callq  4640 <__stack_chk_fail@plt>
    d2f9:	48 83 c4 18          	add    $0x18,%rsp
    d2fd:	5b                   	pop    %rbx
    d2fe:	5d                   	pop    %rbp
    d2ff:	41 5c                	pop    %r12
    d301:	41 5d                	pop    %r13
    d303:	c3                   	retq   

000000000000d304 <bt_settings_encode_key>:
{
    d304:	41 54                	push   %r12
    d306:	4d 89 c4             	mov    %r8,%r12
    d309:	55                   	push   %rbp
	if (key) {
    d30a:	4d 85 e4             	test   %r12,%r12
{
    d30d:	53                   	push   %rbx
    d30e:	0f b6 29             	movzbl (%rcx),%ebp
    d311:	0f b6 59 01          	movzbl 0x1(%rcx),%ebx
    d315:	44 0f b6 59 02       	movzbl 0x2(%rcx),%r11d
    d31a:	44 0f b6 51 03       	movzbl 0x3(%rcx),%r10d
    d31f:	0f b6 41 04          	movzbl 0x4(%rcx),%eax
    d323:	44 0f b6 49 05       	movzbl 0x5(%rcx),%r9d
    d328:	44 0f b6 41 06       	movzbl 0x6(%rcx),%r8d
	if (key) {
    d32d:	74 15                	je     d344 <bt_settings_encode_key+0x40>
		snprintk(path, path_size,
    d32f:	41 54                	push   %r12
    d331:	48 89 d1             	mov    %rdx,%rcx
    d334:	55                   	push   %rbp
    d335:	48 8d 15 94 4f 02 00 	lea    0x24f94(%rip),%rdx        # 322d0 <__func__.5785+0x1668>
    d33c:	53                   	push   %rbx
    d33d:	41 53                	push   %r11
    d33f:	41 52                	push   %r10
    d341:	50                   	push   %rax
    d342:	eb 15                	jmp    d359 <bt_settings_encode_key+0x55>
		snprintk(path, path_size,
    d344:	48 83 ec 08          	sub    $0x8,%rsp
    d348:	48 89 d1             	mov    %rdx,%rcx
    d34b:	48 8d 15 a2 4f 02 00 	lea    0x24fa2(%rip),%rdx        # 322f4 <__func__.5785+0x168c>
    d352:	55                   	push   %rbp
    d353:	53                   	push   %rbx
    d354:	41 53                	push   %r11
    d356:	41 52                	push   %r10
    d358:	50                   	push   %rax
    d359:	31 c0                	xor    %eax,%eax
    d35b:	e8 4c 87 ff ff       	callq  5aac <snprintk>
    d360:	48 83 c4 30          	add    $0x30,%rsp
}
    d364:	5b                   	pop    %rbx
    d365:	5d                   	pop    %rbp
    d366:	41 5c                	pop    %r12
    d368:	c3                   	retq   

000000000000d369 <bt_settings_decode_key>:
{
    d369:	41 54                	push   %r12
    d36b:	55                   	push   %rbp
    d36c:	48 89 f5             	mov    %rsi,%rbp
    d36f:	53                   	push   %rbx
	if (settings_name_next(key, NULL) != 13) {
    d370:	31 f6                	xor    %esi,%esi
{
    d372:	48 89 fb             	mov    %rdi,%rbx
	if (settings_name_next(key, NULL) != 13) {
    d375:	e8 15 b2 ff ff       	callq  858f <settings_name_next>
    d37a:	83 f8 0d             	cmp    $0xd,%eax
		return -EINVAL;
    d37d:	ba ea ff ff ff       	mov    $0xffffffea,%edx
	if (settings_name_next(key, NULL) != 13) {
    d382:	75 47                	jne    d3cb <bt_settings_decode_key+0x62>
	if (key[12] == '0') {
    d384:	8a 43 0c             	mov    0xc(%rbx),%al
    d387:	3c 30                	cmp    $0x30,%al
    d389:	75 0e                	jne    d399 <bt_settings_decode_key+0x30>
		addr->type = BT_ADDR_LE_PUBLIC;
    d38b:	c6 45 00 00          	movb   $0x0,0x0(%rbp)
    d38f:	48 83 c5 06          	add    $0x6,%rbp
    d393:	4c 8d 63 0c          	lea    0xc(%rbx),%r12
    d397:	eb 0f                	jmp    d3a8 <bt_settings_decode_key+0x3f>
	} else if (key[12] == '1') {
    d399:	3c 31                	cmp    $0x31,%al
		return -EINVAL;
    d39b:	ba ea ff ff ff       	mov    $0xffffffea,%edx
	} else if (key[12] == '1') {
    d3a0:	75 29                	jne    d3cb <bt_settings_decode_key+0x62>
		addr->type = BT_ADDR_LE_RANDOM;
    d3a2:	c6 45 00 01          	movb   $0x1,0x0(%rbp)
    d3a6:	eb e7                	jmp    d38f <bt_settings_decode_key+0x26>
		hex2bin(&key[i * 2], 2, &addr->a.val[5 - i], 1);
    d3a8:	48 89 ea             	mov    %rbp,%rdx
    d3ab:	48 89 df             	mov    %rbx,%rdi
    d3ae:	b9 01 00 00 00       	mov    $0x1,%ecx
    d3b3:	be 02 00 00 00       	mov    $0x2,%esi
    d3b8:	48 83 c3 02          	add    $0x2,%rbx
    d3bc:	48 ff cd             	dec    %rbp
    d3bf:	e8 61 84 ff ff       	callq  5825 <hex2bin>
	for (uint8_t i = 0; i < 6; i++) {
    d3c4:	4c 39 e3             	cmp    %r12,%rbx
    d3c7:	75 df                	jne    d3a8 <bt_settings_decode_key+0x3f>
	return 0;
    d3c9:	31 d2                	xor    %edx,%edx
}
    d3cb:	5b                   	pop    %rbx
    d3cc:	89 d0                	mov    %edx,%eax
    d3ce:	5d                   	pop    %rbp
    d3cf:	41 5c                	pop    %r12
    d3d1:	c3                   	retq   

000000000000d3d2 <bt_settings_save_id>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    d3d2:	48 8d 35 b7 95 22 00 	lea    0x2295b7(%rip),%rsi        # 236990 <save_id_work>
    d3d9:	8b 46 10             	mov    0x10(%rsi),%eax
    d3dc:	89 c1                	mov    %eax,%ecx
    d3de:	89 c2                	mov    %eax,%edx
    d3e0:	83 c9 01             	or     $0x1,%ecx
    d3e3:	f0 0f b1 4e 10       	lock cmpxchg %ecx,0x10(%rsi)
    d3e8:	75 f2                	jne    d3dc <bt_settings_save_id+0xa>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    d3ea:	80 e2 01             	and    $0x1,%dl
    d3ed:	75 0c                	jne    d3fb <bt_settings_save_id+0x29>
		k_queue_append(&work_q->queue, work);
    d3ef:	48 8d 3d aa a7 24 00 	lea    0x24a7aa(%rip),%rdi        # 257ba0 <k_sys_work_q>
    d3f6:	e9 30 df 01 00       	jmpq   2b32b <k_queue_append>
K_WORK_DEFINE(save_id_work, save_id);

void bt_settings_save_id(void)
{
	k_work_submit(&save_id_work);
}
    d3fb:	c3                   	retq   

000000000000d3fc <commit>:

static int commit(void)
{
    d3fc:	55                   	push   %rbp
    d3fd:	53                   	push   %rbx
    d3fe:	48 83 ec 08          	sub    $0x8,%rsp
	BT_DBG("");

#if defined(CONFIG_BT_DEVICE_NAME_DYNAMIC)
	if (bt_dev.name[0] == '\0') {
    d402:	48 8d 1d 37 92 22 00 	lea    0x229237(%rip),%rbx        # 236640 <bt_dev>
    d409:	80 bb b0 01 00 00 00 	cmpb   $0x0,0x1b0(%rbx)
    d410:	75 0c                	jne    d41e <commit+0x22>
		bt_set_name(CONFIG_BT_DEVICE_NAME);
    d412:	48 8d 3d b7 3a 02 00 	lea    0x23ab7(%rip),%rdi        # 30ed0 <__func__.5785+0x268>
    d419:	e8 46 2a 00 00       	callq  fe64 <bt_set_name>
	}
#endif
	if (!bt_dev.id_count) {
    d41e:	80 7b 07 00          	cmpb   $0x0,0x7(%rbx)
    d422:	75 05                	jne    d429 <commit+0x2d>
		bt_setup_public_id_addr();
    d424:	e8 35 2e 00 00       	callq  1025e <bt_setup_public_id_addr>
	}

	if (!bt_dev.id_count) {
    d429:	80 7b 07 00          	cmpb   $0x0,0x7(%rbx)
    d42d:	75 31                	jne    d460 <commit+0x64>
		int err;

		err = bt_setup_random_id_addr();
    d42f:	e8 36 2f 00 00       	callq  1036a <bt_setup_random_id_addr>
		if (err) {
    d434:	85 c0                	test   %eax,%eax
		err = bt_setup_random_id_addr();
    d436:	89 c5                	mov    %eax,%ebp
		if (err) {
    d438:	74 26                	je     d460 <commit+0x64>
    d43a:	48 8d 35 af cf 22 00 	lea    0x22cfaf(%rip),%rsi        # 23a3f0 <log_const_bt_settings>
    d441:	48 2b 35 08 8b 22 00 	sub    0x228b08(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Unable to setup an identity address");
    d448:	48 8d 3d c6 4e 02 00 	lea    0x24ec6(%rip),%rdi        # 32315 <__func__.5785+0x16ad>
    d44f:	48 c1 ee 04          	shr    $0x4,%rsi
    d453:	c1 e6 06             	shl    $0x6,%esi
    d456:	83 ce 01             	or     $0x1,%esi
    d459:	e8 66 9e ff ff       	callq  72c4 <log_0>
			return err;
    d45e:	eb 33                	jmp    d493 <commit+0x97>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    d460:	8b 83 a0 00 00 00    	mov    0xa0(%rbx),%eax
		}
	}

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    d466:	a8 02                	test   $0x2,%al
    d468:	75 05                	jne    d46f <commit+0x73>
		bt_finalize_init();
    d46a:	e8 e0 22 00 00       	callq  f74f <bt_finalize_init>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    d46f:	8b 83 a0 00 00 00    	mov    0xa0(%rbx),%eax
    d475:	89 c1                	mov    %eax,%ecx
    d477:	89 c2                	mov    %eax,%edx
    d479:	80 e5 7f             	and    $0x7f,%ch
    d47c:	f0 0f b1 8b a0 00 00 	lock cmpxchg %ecx,0xa0(%rbx)
    d483:	00 
    d484:	75 ef                	jne    d475 <commit+0x79>
	if (atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_STORE_ID)) {
		BT_DBG("Storing Identity Information");
		bt_settings_save_id();
	}

	return 0;
    d486:	31 ed                	xor    %ebp,%ebp
	if (atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_STORE_ID)) {
    d488:	0f ba e2 0f          	bt     $0xf,%edx
    d48c:	73 05                	jae    d493 <commit+0x97>
		bt_settings_save_id();
    d48e:	e8 3f ff ff ff       	callq  d3d2 <bt_settings_save_id>
}
    d493:	89 e8                	mov    %ebp,%eax
    d495:	5a                   	pop    %rdx
    d496:	5b                   	pop    %rbx
    d497:	5d                   	pop    %rbp
    d498:	c3                   	retq   

000000000000d499 <bt_settings_init>:

SETTINGS_STATIC_HANDLER_DEFINE(bt, "bt", NULL, set, commit, NULL);

int bt_settings_init(void)
{
    d499:	48 83 ec 18          	sub    $0x18,%rsp
	int err;

	BT_DBG("");

	err = settings_subsys_init();
    d49d:	e8 c9 b2 ff ff       	callq  876b <settings_subsys_init>
	if (err) {
    d4a2:	85 c0                	test   %eax,%eax
    d4a4:	74 2f                	je     d4d5 <bt_settings_init+0x3c>
    d4a6:	48 8d 15 43 cf 22 00 	lea    0x22cf43(%rip),%rdx        # 23a3f0 <log_const_bt_settings>
    d4ad:	48 2b 15 9c 8a 22 00 	sub    0x228a9c(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("settings_subsys_init failed (err %d)", err);
    d4b4:	48 8d 3d 7e 4e 02 00 	lea    0x24e7e(%rip),%rdi        # 32339 <__func__.5785+0x16d1>
    d4bb:	48 63 f0             	movslq %eax,%rsi
    d4be:	89 44 24 0c          	mov    %eax,0xc(%rsp)
    d4c2:	48 c1 ea 04          	shr    $0x4,%rdx
    d4c6:	c1 e2 06             	shl    $0x6,%edx
    d4c9:	83 ca 01             	or     $0x1,%edx
    d4cc:	e8 24 9e ff ff       	callq  72f5 <log_1>
    d4d1:	8b 44 24 0c          	mov    0xc(%rsp),%eax
		return err;
	}

	return 0;
}
    d4d5:	48 83 c4 18          	add    $0x18,%rsp
    d4d9:	c3                   	retq   

000000000000d4da <uuid_to_uuid128>:
		0x00000000, 0x0000, 0x1000, 0x8000, 0x00805F9B34FB) }
};

static void uuid_to_uuid128(const struct bt_uuid *src, struct bt_uuid_128 *dst)
{
	switch (src->type) {
    d4da:	8a 07                	mov    (%rdi),%al
    d4dc:	3c 01                	cmp    $0x1,%al
    d4de:	74 34                	je     d514 <uuid_to_uuid128+0x3a>
    d4e0:	72 05                	jb     d4e7 <uuid_to_uuid128+0xd>
    d4e2:	3c 02                	cmp    $0x2,%al
    d4e4:	74 5a                	je     d540 <uuid_to_uuid128+0x66>
    d4e6:	c3                   	retq   
	case BT_UUID_TYPE_16:
		*dst = uuid128_base;
    d4e7:	48 b8 02 fb 34 9b 5f 	movabs $0x805f9b34fb02,%rax
    d4ee:	80 00 00 
    d4f1:	c7 46 08 80 00 10 00 	movl   $0x100080,0x8(%rsi)
    d4f8:	c6 46 0c 00          	movb   $0x0,0xc(%rsi)
    d4fc:	48 89 06             	mov    %rax,(%rsi)
    d4ff:	66 c7 46 0f 00 00    	movw   $0x0,0xf(%rsi)
		sys_put_le16(BT_UUID_16(src)->val,
    d505:	66 8b 47 02          	mov    0x2(%rdi),%ax
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val;
    d509:	88 46 0d             	mov    %al,0xd(%rsi)
	dst[1] = val >> 8;
    d50c:	66 c1 e8 08          	shr    $0x8,%ax
    d510:	88 46 0e             	mov    %al,0xe(%rsi)
    d513:	c3                   	retq   
			     &dst->val[UUID_16_BASE_OFFSET]);
		return;
	case BT_UUID_TYPE_32:
		*dst = uuid128_base;
    d514:	48 b8 02 fb 34 9b 5f 	movabs $0x805f9b34fb02,%rax
    d51b:	80 00 00 
    d51e:	c7 46 08 80 00 10 00 	movl   $0x100080,0x8(%rsi)
    d525:	c6 46 0c 00          	movb   $0x0,0xc(%rsi)
    d529:	48 89 06             	mov    %rax,(%rsi)
		sys_put_le32(BT_UUID_32(src)->val,
    d52c:	8b 47 04             	mov    0x4(%rdi),%eax
	dst[0] = val;
    d52f:	88 46 0d             	mov    %al,0xd(%rsi)
	dst[1] = val >> 8;
    d532:	88 66 0e             	mov    %ah,0xe(%rsi)
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le32(uint32_t val, uint8_t dst[4])
{
	sys_put_le16(val, dst);
	sys_put_le16(val >> 16, &dst[2]);
    d535:	c1 e8 10             	shr    $0x10,%eax
	dst[0] = val;
    d538:	88 46 0f             	mov    %al,0xf(%rsi)
	dst[1] = val >> 8;
    d53b:	0f b6 c4             	movzbl %ah,%eax
    d53e:	eb 09                	jmp    d549 <uuid_to_uuid128+0x6f>
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    d540:	0f 10 07             	movups (%rdi),%xmm0
    d543:	0f 11 06             	movups %xmm0,(%rsi)
    d546:	8a 47 10             	mov    0x10(%rdi),%al
    d549:	88 46 10             	mov    %al,0x10(%rsi)
		return;
	case BT_UUID_TYPE_128:
		memcpy(dst, src, sizeof(*dst));
		return;
	}
}
    d54c:	c3                   	retq   

000000000000d54d <bt_uuid_cmp>:

	return memcmp(uuid1.val, uuid2.val, 16);
}

int bt_uuid_cmp(const struct bt_uuid *u1, const struct bt_uuid *u2)
{
    d54d:	48 83 ec 38          	sub    $0x38,%rsp
    d551:	48 89 f2             	mov    %rsi,%rdx
    d554:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    d55b:	00 00 
    d55d:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    d562:	31 c0                	xor    %eax,%eax
	/* Convert to 128 bit if types don't match */
	if (u1->type != u2->type) {
    d564:	8a 07                	mov    (%rdi),%al
    d566:	3a 06                	cmp    (%rsi),%al
    d568:	74 27                	je     d591 <bt_uuid_cmp+0x44>
	uuid_to_uuid128(u1, &uuid1);
    d56a:	48 8d 4c 24 06       	lea    0x6(%rsp),%rcx
    d56f:	48 89 ce             	mov    %rcx,%rsi
    d572:	e8 63 ff ff ff       	callq  d4da <uuid_to_uuid128>
	uuid_to_uuid128(u2, &uuid2);
    d577:	4c 8d 44 24 17       	lea    0x17(%rsp),%r8
    d57c:	48 89 d7             	mov    %rdx,%rdi
    d57f:	4c 89 c6             	mov    %r8,%rsi
    d582:	e8 53 ff ff ff       	callq  d4da <uuid_to_uuid128>
	return memcmp(uuid1.val, uuid2.val, 16);
    d587:	49 8d 70 01          	lea    0x1(%r8),%rsi
    d58b:	48 8d 79 01          	lea    0x1(%rcx),%rdi
    d58f:	eb 27                	jmp    d5b8 <bt_uuid_cmp+0x6b>
		return uuid128_cmp(u1, u2);
	}

	switch (u1->type) {
    d591:	3c 01                	cmp    $0x1,%al
    d593:	74 1b                	je     d5b0 <bt_uuid_cmp+0x63>
    d595:	72 0d                	jb     d5a4 <bt_uuid_cmp+0x57>
    d597:	3c 02                	cmp    $0x2,%al
    d599:	75 29                	jne    d5c4 <bt_uuid_cmp+0x77>
	case BT_UUID_TYPE_16:
		return (int)BT_UUID_16(u1)->val - (int)BT_UUID_16(u2)->val;
	case BT_UUID_TYPE_32:
		return (int)BT_UUID_32(u1)->val - (int)BT_UUID_32(u2)->val;
	case BT_UUID_TYPE_128:
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
    d59b:	48 8d 76 01          	lea    0x1(%rsi),%rsi
    d59f:	48 ff c7             	inc    %rdi
    d5a2:	eb 14                	jmp    d5b8 <bt_uuid_cmp+0x6b>
		return (int)BT_UUID_16(u1)->val - (int)BT_UUID_16(u2)->val;
    d5a4:	0f b7 47 02          	movzwl 0x2(%rdi),%eax
    d5a8:	0f b7 56 02          	movzwl 0x2(%rsi),%edx
    d5ac:	29 d0                	sub    %edx,%eax
    d5ae:	eb 19                	jmp    d5c9 <bt_uuid_cmp+0x7c>
		return (int)BT_UUID_32(u1)->val - (int)BT_UUID_32(u2)->val;
    d5b0:	8b 47 04             	mov    0x4(%rdi),%eax
    d5b3:	2b 46 04             	sub    0x4(%rsi),%eax
    d5b6:	eb 11                	jmp    d5c9 <bt_uuid_cmp+0x7c>
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
    d5b8:	ba 10 00 00 00       	mov    $0x10,%edx
    d5bd:	e8 7e 6e ff ff       	callq  4440 <memcmp@plt>
    d5c2:	eb 05                	jmp    d5c9 <bt_uuid_cmp+0x7c>
	}

	return -EINVAL;
    d5c4:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
    d5c9:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
    d5ce:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    d5d5:	00 00 
    d5d7:	74 05                	je     d5de <bt_uuid_cmp+0x91>
    d5d9:	e8 62 70 ff ff       	callq  4640 <__stack_chk_fail@plt>
    d5de:	48 83 c4 38          	add    $0x38,%rsp
    d5e2:	c3                   	retq   

000000000000d5e3 <bt_uuid_create>:

bool bt_uuid_create(struct bt_uuid *uuid, const uint8_t *data, uint8_t data_len)
{
	/* Copy UUID from packet data/internal variable to internal bt_uuid */
	switch (data_len) {
    d5e3:	80 fa 04             	cmp    $0x4,%dl
    d5e6:	74 21                	je     d609 <bt_uuid_create+0x26>
    d5e8:	80 fa 10             	cmp    $0x10,%dl
    d5eb:	74 4a                	je     d637 <bt_uuid_create+0x54>
    d5ed:	80 fa 02             	cmp    $0x2,%dl
    d5f0:	75 51                	jne    d643 <bt_uuid_create+0x60>
	case 2:
		uuid->type = BT_UUID_TYPE_16;
    d5f2:	c6 07 00             	movb   $0x0,(%rdi)
 *
 *  @return 16-bit integer in host endianness.
 */
static inline uint16_t sys_get_le16(const uint8_t src[2])
{
	return ((uint16_t)src[1] << 8) | src[0];
    d5f5:	0f b6 46 01          	movzbl 0x1(%rsi),%eax
    d5f9:	c1 e0 08             	shl    $0x8,%eax
    d5fc:	89 c2                	mov    %eax,%edx
    d5fe:	0f b6 06             	movzbl (%rsi),%eax
    d601:	09 d0                	or     %edx,%eax
    d603:	66 89 47 02          	mov    %ax,0x2(%rdi)
    d607:	eb 2b                	jmp    d634 <bt_uuid_create+0x51>
		BT_UUID_16(uuid)->val = sys_get_le16(data);
		break;
	case 4:
		uuid->type = BT_UUID_TYPE_32;
    d609:	c6 07 01             	movb   $0x1,(%rdi)
    d60c:	0f b6 46 03          	movzbl 0x3(%rsi),%eax
    d610:	c1 e0 08             	shl    $0x8,%eax
    d613:	89 c2                	mov    %eax,%edx
    d615:	0f b6 46 02          	movzbl 0x2(%rsi),%eax
    d619:	09 d0                	or     %edx,%eax
    d61b:	0f b6 56 01          	movzbl 0x1(%rsi),%edx
 *
 *  @return 32-bit integer in host endianness.
 */
static inline uint32_t sys_get_le32(const uint8_t src[4])
{
	return ((uint32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
    d61f:	c1 e0 10             	shl    $0x10,%eax
	return ((uint16_t)src[1] << 8) | src[0];
    d622:	89 d1                	mov    %edx,%ecx
    d624:	0f b6 16             	movzbl (%rsi),%edx
    d627:	c1 e1 08             	shl    $0x8,%ecx
    d62a:	09 ca                	or     %ecx,%edx
	return ((uint32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
    d62c:	0f b7 d2             	movzwl %dx,%edx
    d62f:	09 d0                	or     %edx,%eax
    d631:	89 47 04             	mov    %eax,0x4(%rdi)
		memcpy(&BT_UUID_128(uuid)->val, data, 16);
		break;
	default:
		return false;
	}
	return true;
    d634:	b0 01                	mov    $0x1,%al
		break;
    d636:	c3                   	retq   
		uuid->type = BT_UUID_TYPE_128;
    d637:	c6 07 02             	movb   $0x2,(%rdi)
    d63a:	0f 10 06             	movups (%rsi),%xmm0
    d63d:	0f 11 47 01          	movups %xmm0,0x1(%rdi)
    d641:	eb f1                	jmp    d634 <bt_uuid_create+0x51>
		return false;
    d643:	31 c0                	xor    %eax,%eax
}
    d645:	c3                   	retq   

000000000000d646 <bt_addr_le_create_static>:

	return 0;
}

int bt_addr_le_create_static(bt_addr_le_t *addr)
{
    d646:	53                   	push   %rbx
	addr->type = BT_ADDR_LE_RANDOM;
    d647:	c6 07 01             	movb   $0x1,(%rdi)
{
    d64a:	48 89 fb             	mov    %rdi,%rbx
	return bt_rand(addr->a.val, 6);
    d64d:	be 06 00 00 00       	mov    $0x6,%esi
    d652:	48 ff c7             	inc    %rdi
    d655:	e8 9f 37 00 00       	callq  10df9 <bt_rand>
	int err;

	err = create_random_addr(addr);
	if (err) {
    d65a:	85 c0                	test   %eax,%eax
    d65c:	75 04                	jne    d662 <bt_addr_le_create_static+0x1c>
		return err;
	}

	BT_ADDR_SET_STATIC(&addr->a);
    d65e:	80 4b 06 c0          	orb    $0xc0,0x6(%rbx)

	return 0;
}
    d662:	5b                   	pop    %rbx
    d663:	c3                   	retq   

000000000000d664 <bt_buf_get_rx>:
NET_BUF_POOL_DEFINE(acl_in_pool, CONFIG_BT_ACL_RX_COUNT, ACL_IN_SIZE,
		    sizeof(struct acl_data), bt_hci_host_num_completed_packets);
#endif /* CONFIG_BT_HCI_ACL_FLOW_CONTROL */

struct net_buf *bt_buf_get_rx(enum bt_buf_type type, k_timeout_t timeout)
{
    d664:	53                   	push   %rbx
    d665:	89 fb                	mov    %edi,%ebx
    d667:	48 83 ec 10          	sub    $0x10,%rsp
	if (IS_ENABLED(CONFIG_BT_ISO) && type == BT_BUF_ISO_IN) {
		return bt_iso_get_rx(timeout);
	}

#if defined(CONFIG_BT_HCI_ACL_FLOW_CONTROL)
	if (type == BT_BUF_EVT) {
    d66b:	ff cf                	dec    %edi
	return net_buf_alloc_fixed(pool, timeout);
    d66d:	48 8d 3d cc d1 22 00 	lea    0x22d1cc(%rip),%rdi        # 23a840 <hci_rx_pool>
    d674:	74 07                	je     d67d <bt_buf_get_rx+0x19>
    d676:	48 8d 3d 83 d0 22 00 	lea    0x22d083(%rip),%rdi        # 23a700 <_k_queue_list_end>
    d67d:	e8 92 b8 00 00       	callq  18f14 <net_buf_alloc_fixed>
	}
#else
	buf = net_buf_alloc(&hci_rx_pool, timeout);
#endif

	if (buf) {
    d682:	48 85 c0             	test   %rax,%rax
    d685:	74 1b                	je     d6a2 <bt_buf_get_rx+0x3e>
	net_buf_simple_reserve(&buf->b, reserve);
    d687:	48 8d 78 10          	lea    0x10(%rax),%rdi
    d68b:	be 01 00 00 00       	mov    $0x1,%esi
    d690:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    d695:	e8 df b8 00 00       	callq  18f79 <net_buf_simple_reserve>
 *  @param buf   Bluetooth buffer
 *  @param type  The BT_* type to set the buffer to
 */
static inline void bt_buf_set_type(struct net_buf *buf, enum bt_buf_type type)
{
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
    d69a:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    d69f:	88 58 28             	mov    %bl,0x28(%rax)
		net_buf_reserve(buf, BT_BUF_RESERVE);
		bt_buf_set_type(buf, type);
	}

	return buf;
}
    d6a2:	48 83 c4 10          	add    $0x10,%rsp
    d6a6:	5b                   	pop    %rbx
    d6a7:	c3                   	retq   

000000000000d6a8 <bt_buf_get_cmd_complete>:

struct net_buf *bt_buf_get_cmd_complete(k_timeout_t timeout)
{
    d6a8:	55                   	push   %rbp
    d6a9:	53                   	push   %rbx
    d6aa:	48 89 fd             	mov    %rdi,%rbp
    d6ad:	48 83 ec 08          	sub    $0x8,%rsp
	return posix_irq_lock();
    d6b1:	e8 dc e8 ff ff       	callq  bf92 <posix_irq_lock>
	struct net_buf *buf;
	unsigned int key;

	key = irq_lock();
	buf = bt_dev.sent_cmd;
    d6b6:	48 8d 15 83 8f 22 00 	lea    0x228f83(%rip),%rdx        # 236640 <bt_dev>
	posix_irq_unlock(key);
    d6bd:	89 c7                	mov    %eax,%edi
    d6bf:	48 8b 9a 40 01 00 00 	mov    0x140(%rdx),%rbx
	bt_dev.sent_cmd = NULL;
    d6c6:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
    d6cd:	00 00 00 00 
    d6d1:	e8 c6 e8 ff ff       	callq  bf9c <posix_irq_unlock>
	irq_unlock(key);

	BT_DBG("sent_cmd %p", buf);

	if (buf) {
    d6d6:	48 85 db             	test   %rbx,%rbx
    d6d9:	75 10                	jne    d6eb <bt_buf_get_cmd_complete+0x43>

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
}
    d6db:	59                   	pop    %rcx
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
    d6dc:	48 89 ee             	mov    %rbp,%rsi
    d6df:	bf 01 00 00 00       	mov    $0x1,%edi
}
    d6e4:	5b                   	pop    %rbx
    d6e5:	5d                   	pop    %rbp
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
    d6e6:	e9 79 ff ff ff       	jmpq   d664 <bt_buf_get_rx>
    d6eb:	48 8d 7b 10          	lea    0x10(%rbx),%rdi
    d6ef:	c6 43 28 01          	movb   $0x1,0x28(%rbx)
		buf->len = 0U;
    d6f3:	66 c7 43 18 00 00    	movw   $0x0,0x18(%rbx)
    d6f9:	be 01 00 00 00       	mov    $0x1,%esi
    d6fe:	e8 76 b8 00 00       	callq  18f79 <net_buf_simple_reserve>
}
    d703:	48 89 d8             	mov    %rbx,%rax
    d706:	5a                   	pop    %rdx
    d707:	5b                   	pop    %rbx
    d708:	5d                   	pop    %rbp
    d709:	c3                   	retq   

000000000000d70a <bt_buf_get_evt>:

struct net_buf *bt_buf_get_evt(uint8_t evt, bool discardable,
			       k_timeout_t timeout)
{
	switch (evt) {
    d70a:	40 80 ff 0e          	cmp    $0xe,%dil
{
    d70e:	48 89 d6             	mov    %rdx,%rsi
	switch (evt) {
    d711:	72 47                	jb     d75a <bt_buf_get_evt+0x50>
    d713:	40 80 ff 0f          	cmp    $0xf,%dil
    d717:	76 39                	jbe    d752 <bt_buf_get_evt+0x48>
    d719:	40 80 ff 13          	cmp    $0x13,%dil
    d71d:	75 3b                	jne    d75a <bt_buf_get_evt+0x50>
	return net_buf_alloc_fixed(pool, timeout);
    d71f:	48 8d 3d 6a d1 22 00 	lea    0x22d16a(%rip),%rdi        # 23a890 <num_complete_pool>
{
    d726:	48 83 ec 18          	sub    $0x18,%rsp
    d72a:	e8 e5 b7 00 00       	callq  18f14 <net_buf_alloc_fixed>
	case BT_HCI_EVT_NUM_COMPLETED_PACKETS:
		{
			struct net_buf *buf;

			buf = net_buf_alloc(&num_complete_pool, timeout);
			if (buf) {
    d72f:	48 85 c0             	test   %rax,%rax
    d732:	74 30                	je     d764 <bt_buf_get_evt+0x5a>
	net_buf_simple_reserve(&buf->b, reserve);
    d734:	48 8d 78 10          	lea    0x10(%rax),%rdi
    d738:	be 01 00 00 00       	mov    $0x1,%esi
    d73d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    d742:	e8 32 b8 00 00       	callq  18f79 <net_buf_simple_reserve>
    d747:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    d74c:	c6 40 28 01          	movb   $0x1,0x28(%rax)
    d750:	eb 12                	jmp    d764 <bt_buf_get_evt+0x5a>
			return buf;
		}
#endif /* CONFIG_BT_CONN */
	case BT_HCI_EVT_CMD_COMPLETE:
	case BT_HCI_EVT_CMD_STATUS:
		return bt_buf_get_cmd_complete(timeout);
    d752:	48 89 d7             	mov    %rdx,%rdi
    d755:	e9 4e ff ff ff       	jmpq   d6a8 <bt_buf_get_cmd_complete>

			return buf;
		}
#endif /* CONFIG_BT_DISCARDABLE_BUF_COUNT */

		return bt_buf_get_rx(BT_BUF_EVT, timeout);
    d75a:	bf 01 00 00 00       	mov    $0x1,%edi
    d75f:	e9 00 ff ff ff       	jmpq   d664 <bt_buf_get_rx>
	}
}
    d764:	48 83 c4 18          	add    $0x18,%rsp
    d768:	c3                   	retq   

000000000000d769 <bt_hci_evt_get_flags>:
 * @param evt HCI event code.
 *
 * @return HCI event flags for the specified event.
 */
static inline uint8_t bt_hci_evt_get_flags(uint8_t evt)
{
    d769:	40 80 ff 1a          	cmp    $0x1a,%dil
#endif /* defined(CONFIG_BT_CONN) */
	case BT_HCI_EVT_CMD_COMPLETE:
	case BT_HCI_EVT_CMD_STATUS:
		return BT_HCI_EVT_FLAG_RECV_PRIO;
	default:
		return BT_HCI_EVT_FLAG_RECV;
    d76d:	b0 02                	mov    $0x2,%al
    d76f:	77 1e                	ja     d78f <bt_hci_evt_get_flags+0x26>
    d771:	ba 01 00 00 00       	mov    $0x1,%edx
    d776:	40 88 f9             	mov    %dil,%cl
		return BT_HCI_EVT_FLAG_RECV_PRIO;
    d779:	b0 01                	mov    $0x1,%al
    d77b:	48 d3 e2             	shl    %cl,%rdx
    d77e:	f7 c2 00 c0 08 04    	test   $0x408c000,%edx
    d784:	75 09                	jne    d78f <bt_hci_evt_get_flags+0x26>
		return BT_HCI_EVT_FLAG_RECV | BT_HCI_EVT_FLAG_RECV_PRIO;
    d786:	80 e2 20             	and    $0x20,%dl
    d789:	0f 95 c0             	setne  %al
    d78c:	83 c0 02             	add    $0x2,%eax
	}
}
    d78f:	c3                   	retq   

000000000000d790 <hci_vendor_event>:
	if (IS_ENABLED(CONFIG_BT_HCI_VS_EXT) && !handled) {
		/* do nothing at present time */
		BT_WARN("Unhandled vendor-specific event: %s",
			bt_hex(buf->data, buf->len));
	}
}
    d790:	c3                   	retq   

000000000000d791 <get_adv_channel_map>:
static uint8_t get_adv_channel_map(uint32_t options)
{
	uint8_t channel_map = 0x07;

	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_37) {
		channel_map &= ~0x01;
    d791:	f7 c7 00 80 00 00    	test   $0x8000,%edi
    d797:	0f 94 c0             	sete   %al
    d79a:	83 c0 06             	add    $0x6,%eax
	}

	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_38) {
    d79d:	0f ba e7 10          	bt     $0x10,%edi
    d7a1:	73 03                	jae    d7a6 <get_adv_channel_map+0x15>
		channel_map &= ~0x02;
    d7a3:	83 e0 fd             	and    $0xfffffffd,%eax
	}

	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_39) {
    d7a6:	0f ba e7 11          	bt     $0x11,%edi
    d7aa:	73 03                	jae    d7af <get_adv_channel_map+0x1e>
		channel_map &= ~0x04;
    d7ac:	83 e0 fb             	and    $0xfffffffb,%eax
	}

	return channel_map;
}
    d7af:	c3                   	retq   

000000000000d7b0 <bt_addr_copy>:
    d7b0:	8b 06                	mov    (%rsi),%eax
    d7b2:	89 07                	mov    %eax,(%rdi)
    d7b4:	66 8b 46 04          	mov    0x4(%rsi),%ax
    d7b8:	66 89 47 04          	mov    %ax,0x4(%rdi)
}
    d7bc:	c3                   	retq   

000000000000d7bd <bt_addr_le_copy>:
    d7bd:	b9 07 00 00 00       	mov    $0x7,%ecx
    d7c2:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
}
    d7c4:	c3                   	retq   

000000000000d7c5 <net_buf_add_u8>:
	return net_buf_simple_add_u8(&buf->b, val);
    d7c5:	40 0f b6 f6          	movzbl %sil,%esi
    d7c9:	48 83 c7 10          	add    $0x10,%rdi
    d7cd:	e9 eb b8 00 00       	jmpq   190bd <net_buf_simple_add_u8>

000000000000d7d2 <atomic_or>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    d7d2:	8b 07                	mov    (%rdi),%eax
    d7d4:	89 c1                	mov    %eax,%ecx
    d7d6:	89 c2                	mov    %eax,%edx
    d7d8:	09 f1                	or     %esi,%ecx
    d7da:	f0 0f b1 0f          	lock cmpxchg %ecx,(%rdi)
    d7de:	75 f4                	jne    d7d4 <atomic_or+0x2>
}
    d7e0:	89 d0                	mov    %edx,%eax
    d7e2:	c3                   	retq   

000000000000d7e3 <hci_data_buf_overflow>:
	struct bt_hci_evt_data_buf_overflow *evt = (void *)buf->data;
    d7e3:	48 8b 47 10          	mov    0x10(%rdi),%rax
    d7e7:	48 8d 15 e2 cb 22 00 	lea    0x22cbe2(%rip),%rdx        # 23a3d0 <log_const_bt_hci_core>
	BT_WARN("Data buffer overflow (link type 0x%02x)", evt->link_type);
    d7ee:	48 8d 3d 7f 4b 02 00 	lea    0x24b7f(%rip),%rdi        # 32374 <__func__.5785+0x170c>
    d7f5:	48 2b 15 54 87 22 00 	sub    0x228754(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
    d7fc:	0f b6 30             	movzbl (%rax),%esi
    d7ff:	48 c1 ea 04          	shr    $0x4,%rdx
    d803:	c1 e2 06             	shl    $0x6,%edx
    d806:	83 ca 02             	or     $0x2,%edx
    d809:	e9 e7 9a ff ff       	jmpq   72f5 <log_1>

000000000000d80e <le_data_len_change>:
{
    d80e:	53                   	push   %rbx
	uint16_t handle = sys_le16_to_cpu(evt->handle);
    d80f:	48 8b 47 10          	mov    0x10(%rdi),%rax
    d813:	0f b7 38             	movzwl (%rax),%edi
    d816:	89 fb                	mov    %edi,%ebx
	conn = bt_conn_lookup_handle(handle);
    d818:	e8 c7 3f 00 00       	callq  117e4 <bt_conn_lookup_handle>
	if (!conn) {
    d81d:	48 85 c0             	test   %rax,%rax
    d820:	75 28                	jne    d84a <le_data_len_change+0x3c>
    d822:	48 8d 15 a7 cb 22 00 	lea    0x22cba7(%rip),%rdx        # 23a3d0 <log_const_bt_hci_core>
    d829:	48 2b 15 20 87 22 00 	sub    0x228720(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    d830:	0f b7 f3             	movzwl %bx,%esi
}
    d833:	5b                   	pop    %rbx
		BT_ERR("Unable to lookup conn for handle %u", handle);
    d834:	48 8d 3d 61 4b 02 00 	lea    0x24b61(%rip),%rdi        # 3239c <__func__.5785+0x1734>
    d83b:	48 c1 ea 04          	shr    $0x4,%rdx
    d83f:	c1 e2 06             	shl    $0x6,%edx
    d842:	83 ca 01             	or     $0x1,%edx
    d845:	e9 ab 9a ff ff       	jmpq   72f5 <log_1>
}
    d84a:	5b                   	pop    %rbx
	bt_conn_unref(conn);
    d84b:	48 89 c7             	mov    %rax,%rdi
    d84e:	e9 11 3f 00 00       	jmpq   11764 <bt_conn_unref>

000000000000d853 <hci_disconn_complete_prio>:
	struct bt_hci_evt_disconn_complete *evt = (void *)buf->data;
    d853:	48 8b 47 10          	mov    0x10(%rdi),%rax
	if (evt->status) {
    d857:	80 38 00             	cmpb   $0x0,(%rax)
    d85a:	75 5b                	jne    d8b7 <hci_disconn_complete_prio+0x64>
{
    d85c:	55                   	push   %rbp
    d85d:	53                   	push   %rbx
    d85e:	48 83 ec 08          	sub    $0x8,%rsp
	uint16_t handle = sys_le16_to_cpu(evt->handle);
    d862:	0f b7 78 01          	movzwl 0x1(%rax),%edi
    d866:	89 fb                	mov    %edi,%ebx
	conn = bt_conn_lookup_handle(handle);
    d868:	e8 77 3f 00 00       	callq  117e4 <bt_conn_lookup_handle>
	if (!conn) {
    d86d:	48 85 c0             	test   %rax,%rax
	conn = bt_conn_lookup_handle(handle);
    d870:	48 89 c5             	mov    %rax,%rbp
	if (!conn) {
    d873:	75 2a                	jne    d89f <hci_disconn_complete_prio+0x4c>
    d875:	48 8d 15 54 cb 22 00 	lea    0x22cb54(%rip),%rdx        # 23a3d0 <log_const_bt_hci_core>
    d87c:	48 2b 15 cd 86 22 00 	sub    0x2286cd(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unable to look up conn with handle %u", handle);
    d883:	0f b7 f3             	movzwl %bx,%esi
}
    d886:	59                   	pop    %rcx
    d887:	5b                   	pop    %rbx
    d888:	5d                   	pop    %rbp
    d889:	48 c1 ea 04          	shr    $0x4,%rdx
		BT_ERR("Unable to look up conn with handle %u", handle);
    d88d:	48 8d 3d 2c 4b 02 00 	lea    0x24b2c(%rip),%rdi        # 323c0 <__func__.5785+0x1758>
    d894:	c1 e2 06             	shl    $0x6,%edx
    d897:	83 ca 01             	or     $0x1,%edx
    d89a:	e9 56 9a ff ff       	jmpq   72f5 <log_1>
	bt_conn_set_state(conn, BT_CONN_DISCONNECT_COMPLETE);
    d89f:	48 89 c7             	mov    %rax,%rdi
    d8a2:	be 01 00 00 00       	mov    $0x1,%esi
    d8a7:	e8 4c 3f 00 00       	callq  117f8 <bt_conn_set_state>
}
    d8ac:	58                   	pop    %rax
	bt_conn_unref(conn);
    d8ad:	48 89 ef             	mov    %rbp,%rdi
}
    d8b0:	5b                   	pop    %rbx
    d8b1:	5d                   	pop    %rbp
	bt_conn_unref(conn);
    d8b2:	e9 ad 3e 00 00       	jmpq   11764 <bt_conn_unref>
    d8b7:	c3                   	retq   

000000000000d8b8 <hci_disconn_complete>:
{
    d8b8:	41 54                	push   %r12
    d8ba:	55                   	push   %rbp
    d8bb:	53                   	push   %rbx
	struct bt_hci_evt_disconn_complete *evt = (void *)buf->data;
    d8bc:	4c 8b 67 10          	mov    0x10(%rdi),%r12
	if (evt->status) {
    d8c0:	41 80 3c 24 00       	cmpb   $0x0,(%r12)
    d8c5:	75 63                	jne    d92a <hci_disconn_complete+0x72>
	uint16_t handle = sys_le16_to_cpu(evt->handle);
    d8c7:	41 0f b7 7c 24 01    	movzwl 0x1(%r12),%edi
    d8cd:	89 fd                	mov    %edi,%ebp
	conn = bt_conn_lookup_handle(handle);
    d8cf:	e8 10 3f 00 00       	callq  117e4 <bt_conn_lookup_handle>
	if (!conn) {
    d8d4:	48 85 c0             	test   %rax,%rax
	conn = bt_conn_lookup_handle(handle);
    d8d7:	48 89 c3             	mov    %rax,%rbx
	if (!conn) {
    d8da:	75 2b                	jne    d907 <hci_disconn_complete+0x4f>
    d8dc:	48 8d 15 ed ca 22 00 	lea    0x22caed(%rip),%rdx        # 23a3d0 <log_const_bt_hci_core>
    d8e3:	48 2b 15 66 86 22 00 	sub    0x228666(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unable to look up conn with handle %u", handle);
    d8ea:	0f b7 f5             	movzwl %bp,%esi
}
    d8ed:	5b                   	pop    %rbx
    d8ee:	5d                   	pop    %rbp
    d8ef:	41 5c                	pop    %r12
    d8f1:	48 c1 ea 04          	shr    $0x4,%rdx
		BT_ERR("Unable to look up conn with handle %u", handle);
    d8f5:	48 8d 3d c4 4a 02 00 	lea    0x24ac4(%rip),%rdi        # 323c0 <__func__.5785+0x1758>
    d8fc:	c1 e2 06             	shl    $0x6,%edx
    d8ff:	83 ca 01             	or     $0x1,%edx
    d902:	e9 ee 99 ff ff       	jmpq   72f5 <log_1>
	conn->err = evt->reason;
    d907:	41 8a 44 24 03       	mov    0x3(%r12),%al
	bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    d90c:	48 89 df             	mov    %rbx,%rdi
    d90f:	31 f6                	xor    %esi,%esi
	conn->err = evt->reason;
    d911:	88 43 09             	mov    %al,0x9(%rbx)
	bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    d914:	e8 df 3e 00 00       	callq  117f8 <bt_conn_set_state>
	conn->handle = 0U;
    d919:	66 c7 03 00 00       	movw   $0x0,(%rbx)
		bt_conn_unref(conn);
    d91e:	48 89 df             	mov    %rbx,%rdi
}
    d921:	5b                   	pop    %rbx
    d922:	5d                   	pop    %rbp
    d923:	41 5c                	pop    %r12
	bt_conn_unref(conn);
    d925:	e9 3a 3e 00 00       	jmpq   11764 <bt_conn_unref>
}
    d92a:	5b                   	pop    %rbx
    d92b:	5d                   	pop    %rbp
    d92c:	41 5c                	pop    %r12
    d92e:	c3                   	retq   

000000000000d92f <hci_hardware_error>:
{
    d92f:	48 83 ec 08          	sub    $0x8,%rsp
 *
 * @return Pointer to the old beginning of the buffer data.
 */
static inline void *net_buf_pull_mem(struct net_buf *buf, size_t len)
{
	return net_buf_simple_pull_mem(&buf->b, len);
    d933:	48 83 c7 10          	add    $0x10,%rdi
    d937:	be 01 00 00 00       	mov    $0x1,%esi
    d93c:	e8 ce b7 00 00       	callq  1910f <net_buf_simple_pull_mem>
    d941:	48 8d 15 88 ca 22 00 	lea    0x22ca88(%rip),%rdx        # 23a3d0 <log_const_bt_hci_core>
    d948:	48 2b 15 01 86 22 00 	sub    0x228601(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
	BT_ERR("Hardware error, hardware code: %d", evt->hardware_code);
    d94f:	48 8d 3d 90 4a 02 00 	lea    0x24a90(%rip),%rdi        # 323e6 <__func__.5785+0x177e>
    d956:	0f b6 30             	movzbl (%rax),%esi
}
    d959:	58                   	pop    %rax
    d95a:	48 c1 ea 04          	shr    $0x4,%rdx
	BT_ERR("Hardware error, hardware code: %d", evt->hardware_code);
    d95e:	c1 e2 06             	shl    $0x6,%edx
    d961:	83 ca 01             	or     $0x1,%edx
    d964:	e9 8c 99 ff ff       	jmpq   72f5 <log_1>

000000000000d969 <le_conn_update_complete>:
{
    d969:	41 54                	push   %r12
    d96b:	55                   	push   %rbp
    d96c:	53                   	push   %rbx
    d96d:	48 83 ec 10          	sub    $0x10,%rsp
	struct bt_hci_evt_le_conn_update_complete *evt = (void *)buf->data;
    d971:	48 8b 6f 10          	mov    0x10(%rdi),%rbp
{
    d975:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    d97c:	00 00 
    d97e:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    d983:	31 c0                	xor    %eax,%eax
	handle = sys_le16_to_cpu(evt->handle);
    d985:	0f b7 7d 01          	movzwl 0x1(%rbp),%edi
    d989:	41 89 fc             	mov    %edi,%r12d
	conn = bt_conn_lookup_handle(handle);
    d98c:	e8 53 3e 00 00       	callq  117e4 <bt_conn_lookup_handle>
	if (!conn) {
    d991:	48 85 c0             	test   %rax,%rax
    d994:	75 2d                	jne    d9c3 <le_conn_update_complete+0x5a>
    d996:	48 8d 15 33 ca 22 00 	lea    0x22ca33(%rip),%rdx        # 23a3d0 <log_const_bt_hci_core>
    d99d:	48 2b 15 ac 85 22 00 	sub    0x2285ac(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    d9a4:	48 8d 3d f1 49 02 00 	lea    0x249f1(%rip),%rdi        # 3239c <__func__.5785+0x1734>
    d9ab:	41 0f b7 f4          	movzwl %r12w,%esi
    d9af:	48 c1 ea 04          	shr    $0x4,%rdx
    d9b3:	c1 e2 06             	shl    $0x6,%edx
    d9b6:	83 ca 01             	or     $0x1,%edx
    d9b9:	e8 37 99 ff ff       	callq  72f5 <log_1>
    d9be:	e9 93 00 00 00       	jmpq   da56 <le_conn_update_complete+0xed>
    d9c3:	48 89 c3             	mov    %rax,%rbx
	if (!evt->status) {
    d9c6:	8a 45 00             	mov    0x0(%rbp),%al
    d9c9:	84 c0                	test   %al,%al
    d9cb:	75 2b                	jne    d9f8 <le_conn_update_complete+0x8f>
		conn->le.interval = sys_le16_to_cpu(evt->interval);
    d9cd:	66 8b 45 03          	mov    0x3(%rbp),%ax
		notify_le_param_updated(conn);
    d9d1:	48 89 df             	mov    %rbx,%rdi
		conn->le.interval = sys_le16_to_cpu(evt->interval);
    d9d4:	66 89 83 ee 00 00 00 	mov    %ax,0xee(%rbx)
		conn->le.latency = sys_le16_to_cpu(evt->latency);
    d9db:	66 8b 45 05          	mov    0x5(%rbp),%ax
    d9df:	66 89 83 f4 00 00 00 	mov    %ax,0xf4(%rbx)
		conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
    d9e6:	66 8b 45 07          	mov    0x7(%rbp),%ax
    d9ea:	66 89 83 f6 00 00 00 	mov    %ax,0xf6(%rbx)
		notify_le_param_updated(conn);
    d9f1:	e8 3d 37 00 00       	callq  11133 <notify_le_param_updated>
    d9f6:	eb 56                	jmp    da4e <le_conn_update_complete+0xe5>
	} else if (evt->status == BT_HCI_ERR_UNSUPP_REMOTE_FEATURE &&
    d9f8:	3c 1a                	cmp    $0x1a,%al
    d9fa:	75 52                	jne    da4e <le_conn_update_complete+0xe5>
    d9fc:	80 7b 03 01          	cmpb   $0x1,0x3(%rbx)
    da00:	75 4c                	jne    da4e <le_conn_update_complete+0xe5>
		   !atomic_test_and_set_bit(conn->flags,
    da02:	48 8d 7b 04          	lea    0x4(%rbx),%rdi
static inline bool atomic_test_and_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
	atomic_val_t old;

	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
    da06:	be 00 04 00 00       	mov    $0x400,%esi
    da0b:	e8 c2 fd ff ff       	callq  d7d2 <atomic_or>
		   conn->role == BT_HCI_ROLE_SLAVE &&
    da10:	0f ba e0 0a          	bt     $0xa,%eax
    da14:	72 38                	jb     da4e <le_conn_update_complete+0xe5>
		param.interval_min = conn->le.interval_min;
    da16:	8b 83 f0 00 00 00    	mov    0xf0(%rbx),%eax
		bt_l2cap_update_conn_param(conn, &param);
    da1c:	48 89 e6             	mov    %rsp,%rsi
    da1f:	48 89 df             	mov    %rbx,%rdi
		param.interval_min = conn->le.interval_min;
    da22:	66 89 04 24          	mov    %ax,(%rsp)
		param.interval_max = conn->le.interval_max;
    da26:	66 8b 83 f2 00 00 00 	mov    0xf2(%rbx),%ax
    da2d:	66 89 44 24 02       	mov    %ax,0x2(%rsp)
		param.latency = conn->le.pending_latency;
    da32:	8b 83 f8 00 00 00    	mov    0xf8(%rbx),%eax
    da38:	66 89 44 24 04       	mov    %ax,0x4(%rsp)
		param.timeout = conn->le.pending_timeout;
    da3d:	66 8b 83 fa 00 00 00 	mov    0xfa(%rbx),%ax
    da44:	66 89 44 24 06       	mov    %ax,0x6(%rsp)
		bt_l2cap_update_conn_param(conn, &param);
    da49:	e8 a7 4b 00 00       	callq  125f5 <bt_l2cap_update_conn_param>
	bt_conn_unref(conn);
    da4e:	48 89 df             	mov    %rbx,%rdi
    da51:	e8 0e 3d 00 00       	callq  11764 <bt_conn_unref>
}
    da56:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    da5b:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    da62:	00 00 
    da64:	74 05                	je     da6b <le_conn_update_complete+0x102>
    da66:	e8 d5 6b ff ff       	callq  4640 <__stack_chk_fail@plt>
    da6b:	48 83 c4 10          	add    $0x10,%rsp
    da6f:	5b                   	pop    %rbx
    da70:	5d                   	pop    %rbp
    da71:	41 5c                	pop    %r12
    da73:	c3                   	retq   

000000000000da74 <bt_addr_le_cmp>:
	return memcmp(a, b, sizeof(*a));
    da74:	ba 07 00 00 00       	mov    $0x7,%edx
    da79:	e9 c2 69 ff ff       	jmpq   4440 <memcmp@plt>

000000000000da7e <id_find>:
{
    da7e:	41 56                	push   %r14
    da80:	41 55                	push   %r13
    da82:	49 89 fd             	mov    %rdi,%r13
    da85:	41 54                	push   %r12
    da87:	55                   	push   %rbp
	for (id = 0U; id < bt_dev.id_count; id++) {
    da88:	48 8d 2d b1 8b 22 00 	lea    0x228bb1(%rip),%rbp        # 236640 <bt_dev>
{
    da8f:	53                   	push   %rbx
	for (id = 0U; id < bt_dev.id_count; id++) {
    da90:	31 db                	xor    %ebx,%ebx
    da92:	44 8a 65 07          	mov    0x7(%rbp),%r12b
    da96:	41 38 dc             	cmp    %bl,%r12b
    da99:	76 1b                	jbe    dab6 <id_find+0x38>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
    da9b:	48 6b f3 07          	imul   $0x7,%rbx,%rsi
    da9f:	4c 89 ef             	mov    %r13,%rdi
    daa2:	41 89 de             	mov    %ebx,%r14d
    daa5:	48 ff c3             	inc    %rbx
    daa8:	48 01 ee             	add    %rbp,%rsi
    daab:	e8 c4 ff ff ff       	callq  da74 <bt_addr_le_cmp>
    dab0:	85 c0                	test   %eax,%eax
    dab2:	75 e2                	jne    da96 <id_find+0x18>
    dab4:	eb 06                	jmp    dabc <id_find+0x3e>
	return -ENOENT;
    dab6:	41 be fe ff ff ff    	mov    $0xfffffffe,%r14d
}
    dabc:	5b                   	pop    %rbx
    dabd:	44 89 f0             	mov    %r14d,%eax
    dac0:	5d                   	pop    %rbp
    dac1:	41 5c                	pop    %r12
    dac3:	41 5d                	pop    %r13
    dac5:	41 5e                	pop    %r14
    dac7:	c3                   	retq   

000000000000dac8 <valid_adv_param>:
{
    dac8:	41 55                	push   %r13
    daca:	41 54                	push   %r12
    dacc:	55                   	push   %rbp
    dacd:	53                   	push   %rbx
    dace:	48 83 ec 18          	sub    $0x18,%rsp
	if (param->options & BT_LE_ADV_OPT_EXT_ADV) {
    dad2:	8b 5f 04             	mov    0x4(%rdi),%ebx
{
    dad5:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    dadc:	00 00 
    dade:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    dae3:	31 c0                	xor    %eax,%eax
	if (param->options & BT_LE_ADV_OPT_EXT_ADV) {
    dae5:	0f ba e3 0a          	bt     $0xa,%ebx
    dae9:	73 07                	jae    daf2 <valid_adv_param+0x2a>
		return false;
    daeb:	31 c0                	xor    %eax,%eax
    daed:	e9 ac 00 00 00       	jmpq   db9e <valid_adv_param+0xd6>
	if (param->peer && !(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
    daf2:	4c 8b 6f 10          	mov    0x10(%rdi),%r13
    daf6:	49 89 fc             	mov    %rdi,%r12
    daf9:	4d 85 ed             	test   %r13,%r13
    dafc:	74 05                	je     db03 <valid_adv_param+0x3b>
    dafe:	f6 c3 01             	test   $0x1,%bl
    db01:	74 e8                	je     daeb <valid_adv_param+0x23>
	if (param->id >= bt_dev.id_count ||
    db03:	48 8d 2d 36 8b 22 00 	lea    0x228b36(%rip),%rbp        # 236640 <bt_dev>
    db0a:	41 8a 14 24          	mov    (%r12),%dl
    db0e:	3a 55 07             	cmp    0x7(%rbp),%dl
    db11:	73 d8                	jae    daeb <valid_adv_param+0x23>
	    !bt_addr_le_cmp(&bt_dev.id_addr[param->id], BT_ADDR_LE_ANY)) {
    db13:	48 8d 7c 24 01       	lea    0x1(%rsp),%rdi
    db18:	31 c0                	xor    %eax,%eax
    db1a:	b9 07 00 00 00       	mov    $0x7,%ecx
    db1f:	48 8d 74 24 01       	lea    0x1(%rsp),%rsi
    db24:	f3 aa                	rep stos %al,%es:(%rdi)
    db26:	0f b6 fa             	movzbl %dl,%edi
    db29:	48 6b ff 07          	imul   $0x7,%rdi,%rdi
    db2d:	48 01 ef             	add    %rbp,%rdi
    db30:	e8 3f ff ff ff       	callq  da74 <bt_addr_le_cmp>
	if (param->id >= bt_dev.id_count ||
    db35:	85 c0                	test   %eax,%eax
    db37:	74 b2                	je     daeb <valid_adv_param+0x23>
	if (!(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
    db39:	f6 c3 01             	test   $0x1,%bl
    db3c:	75 11                	jne    db4f <valid_adv_param+0x87>
		if (bt_dev.hci_version < BT_HCI_VERSION_5_0 &&
    db3e:	80 7d 34 08          	cmpb   $0x8,0x34(%rbp)
    db42:	77 0b                	ja     db4f <valid_adv_param+0x87>
    db44:	41 81 7c 24 08 9f 00 	cmpl   $0x9f,0x8(%r12)
    db4b:	00 00 
    db4d:	76 9c                	jbe    daeb <valid_adv_param+0x23>
			       BT_LE_ADV_OPT_DIR_ADDR_RPA)) &&
    db4f:	4d 85 ed             	test   %r13,%r13
    db52:	0f 94 c0             	sete   %al
    db55:	f6 c3 30             	test   $0x30,%bl
    db58:	74 04                	je     db5e <valid_adv_param+0x96>
    db5a:	84 c0                	test   %al,%al
    db5c:	75 8d                	jne    daeb <valid_adv_param+0x23>
	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) ||
    db5e:	f6 c3 10             	test   $0x10,%bl
    db61:	75 04                	jne    db67 <valid_adv_param+0x9f>
    db63:	84 c0                	test   %al,%al
    db65:	74 28                	je     db8f <valid_adv_param+0xc7>
		if (param->interval_min > param->interval_max ||
    db67:	41 8b 54 24 08       	mov    0x8(%r12),%edx
    db6c:	41 8b 44 24 0c       	mov    0xc(%r12),%eax
    db71:	39 c2                	cmp    %eax,%edx
    db73:	0f 97 c1             	seta   %cl
    db76:	83 fa 1f             	cmp    $0x1f,%edx
    db79:	0f 96 c2             	setbe  %dl
		    param->interval_min < 0x0020 ||
    db7c:	08 d1                	or     %dl,%cl
    db7e:	0f 85 67 ff ff ff    	jne    daeb <valid_adv_param+0x23>
    db84:	3d 00 40 00 00       	cmp    $0x4000,%eax
    db89:	0f 87 5c ff ff ff    	ja     daeb <valid_adv_param+0x23>
	    (param->options & BT_LE_ADV_OPT_DISABLE_CHAN_38) &&
    db8f:	81 e3 00 80 03 00    	and    $0x38000,%ebx
	if ((param->options & BT_LE_ADV_OPT_DISABLE_CHAN_37) &&
    db95:	81 fb 00 80 03 00    	cmp    $0x38000,%ebx
    db9b:	0f 95 c0             	setne  %al
}
    db9e:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    dba3:	64 48 33 34 25 28 00 	xor    %fs:0x28,%rsi
    dbaa:	00 00 
    dbac:	74 05                	je     dbb3 <valid_adv_param+0xeb>
    dbae:	e8 8d 6a ff ff       	callq  4640 <__stack_chk_fail@plt>
    dbb3:	48 83 c4 18          	add    $0x18,%rsp
    dbb7:	5b                   	pop    %rbx
    dbb8:	5d                   	pop    %rbp
    dbb9:	41 5c                	pop    %r12
    dbbb:	41 5d                	pop    %r13
    dbbd:	c3                   	retq   

000000000000dbbe <handle_event>:
{
    dbbe:	55                   	push   %rbp
    dbbf:	53                   	push   %rbx
	for (i = 0; i < num_handlers; i++) {
    dbc0:	31 c0                	xor    %eax,%eax
{
    dbc2:	40 88 fb             	mov    %dil,%bl
    dbc5:	48 83 ec 18          	sub    $0x18,%rsp
		if (handler->event != event) {
    dbc9:	38 1a                	cmp    %bl,(%rdx)
    dbcb:	74 64                	je     dc31 <handle_event+0x73>
	for (i = 0; i < num_handlers; i++) {
    dbcd:	48 ff c0             	inc    %rax
    dbd0:	48 83 c2 10          	add    $0x10,%rdx
    dbd4:	48 39 c8             	cmp    %rcx,%rax
    dbd7:	75 f0                	jne    dbc9 <handle_event+0xb>
    dbd9:	4c 8d 05 f0 c7 22 00 	lea    0x22c7f0(%rip),%r8        # 23a3d0 <log_const_bt_hci_core>
    dbe0:	4c 2b 05 69 83 22 00 	sub    0x228369(%rip),%r8        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
    dbe7:	48 89 f5             	mov    %rsi,%rbp
	BT_WARN("Unhandled event 0x%02x len %u: %s", event,
    dbea:	0f b7 76 18          	movzwl 0x18(%rsi),%esi
    dbee:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
    dbf2:	49 c1 e8 04          	shr    $0x4,%r8
    dbf6:	41 c1 e0 06          	shl    $0x6,%r8d
    dbfa:	41 83 c8 02          	or     $0x2,%r8d
    dbfe:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
    dc03:	e8 bc f3 ff ff       	callq  cfc4 <bt_hex_real>
    dc08:	48 89 c7             	mov    %rax,%rdi
    dc0b:	e8 00 93 ff ff       	callq  6f10 <log_strdup>
    dc10:	0f b7 55 18          	movzwl 0x18(%rbp),%edx
    dc14:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
}
    dc19:	48 83 c4 18          	add    $0x18,%rsp
	BT_WARN("Unhandled event 0x%02x len %u: %s", event,
    dc1d:	0f b6 f3             	movzbl %bl,%esi
    dc20:	48 8d 3d 03 48 02 00 	lea    0x24803(%rip),%rdi        # 3242a <__func__.5785+0x17c2>
    dc27:	48 89 c1             	mov    %rax,%rcx
}
    dc2a:	5b                   	pop    %rbx
    dc2b:	5d                   	pop    %rbp
	BT_WARN("Unhandled event 0x%02x len %u: %s", event,
    dc2c:	e9 53 97 ff ff       	jmpq   7384 <log_3>
		if (buf->len < handler->min_len) {
    dc31:	0f b6 4a 01          	movzbl 0x1(%rdx),%ecx
    dc35:	8b 46 18             	mov    0x18(%rsi),%eax
    dc38:	66 39 c8             	cmp    %cx,%ax
    dc3b:	73 30                	jae    dc6d <handle_event+0xaf>
    dc3d:	48 8d 0d 8c c7 22 00 	lea    0x22c78c(%rip),%rcx        # 23a3d0 <log_const_bt_hci_core>
    dc44:	48 2b 0d 05 83 22 00 	sub    0x228305(%rip),%rcx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
}
    dc4b:	48 83 c4 18          	add    $0x18,%rsp
			BT_ERR("Too small (%u bytes) event 0x%02x",
    dc4f:	0f b6 d3             	movzbl %bl,%edx
    dc52:	48 8d 3d af 47 02 00 	lea    0x247af(%rip),%rdi        # 32408 <__func__.5785+0x17a0>
    dc59:	0f b7 f0             	movzwl %ax,%esi
}
    dc5c:	5b                   	pop    %rbx
    dc5d:	5d                   	pop    %rbp
    dc5e:	48 c1 e9 04          	shr    $0x4,%rcx
			BT_ERR("Too small (%u bytes) event 0x%02x",
    dc62:	c1 e1 06             	shl    $0x6,%ecx
    dc65:	83 c9 01             	or     $0x1,%ecx
    dc68:	e9 c5 96 ff ff       	jmpq   7332 <log_2>
		handler->handler(buf);
    dc6d:	48 8b 42 08          	mov    0x8(%rdx),%rax
}
    dc71:	48 83 c4 18          	add    $0x18,%rsp
		handler->handler(buf);
    dc75:	48 89 f7             	mov    %rsi,%rdi
}
    dc78:	5b                   	pop    %rbx
    dc79:	5d                   	pop    %rbp
		handler->handler(buf);
    dc7a:	ff e0                	jmpq   *%rax

000000000000dc7c <hci_rx_thread>:
{
    dc7c:	41 56                	push   %r14
    dc7e:	41 55                	push   %r13
    dc80:	41 54                	push   %r12
    dc82:	55                   	push   %rbp
    dc83:	48 8d 2d 46 c7 22 00 	lea    0x22c746(%rip),%rbp        # 23a3d0 <log_const_bt_hci_core>
    dc8a:	48 2b 2d bf 82 22 00 	sub    0x2282bf(%rip),%rbp        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		buf = net_buf_get(&bt_dev.rx_queue, K_FOREVER);
    dc91:	48 8d 05 a8 89 22 00 	lea    0x2289a8(%rip),%rax        # 236640 <bt_dev>
{
    dc98:	53                   	push   %rbx
    dc99:	48 c1 ed 04          	shr    $0x4,%rbp
		buf = net_buf_get(&bt_dev.rx_queue, K_FOREVER);
    dc9d:	4c 8d b0 48 01 00 00 	lea    0x148(%rax),%r14
		BT_ERR("Unable to find conn for handle %u", acl(buf)->handle);
    dca4:	66 81 e5 ff 03       	and    $0x3ff,%bp
		buf = net_buf_get(&bt_dev.rx_queue, K_FOREVER);
    dca9:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
    dcad:	4c 89 f7             	mov    %r14,%rdi
    dcb0:	e8 72 b2 00 00       	callq  18f27 <net_buf_get>
 *  @return The BT_* type to of the buffer
 */
static inline enum bt_buf_type bt_buf_get_type(struct net_buf *buf)
{
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
		->type;
    dcb5:	0f b6 70 28          	movzbl 0x28(%rax),%esi
    dcb9:	48 89 c3             	mov    %rax,%rbx
		switch (bt_buf_get_type(buf)) {
    dcbc:	40 80 fe 01          	cmp    $0x1,%sil
    dcc0:	0f 84 f4 00 00 00    	je     ddba <hci_rx_thread+0x13e>
    dcc6:	40 80 fe 03          	cmp    $0x3,%sil
    dcca:	0f 85 b7 01 00 00    	jne    de87 <hci_rx_thread+0x20b>
	BT_ASSERT(buf->len >= sizeof(*hdr));
    dcd0:	66 83 78 18 03       	cmpw   $0x3,0x18(%rax)
    dcd5:	77 47                	ja     dd1e <hci_rx_thread+0xa2>
    dcd7:	48 8d 15 6e 47 02 00 	lea    0x2476e(%rip),%rdx        # 3244c <__func__.5785+0x17e4>
    dcde:	48 8d 35 9a 47 02 00 	lea    0x2479a(%rip),%rsi        # 3247f <__func__.5785+0x1817>
    dce5:	48 8d 3d ac 47 02 00 	lea    0x247ac(%rip),%rdi        # 32498 <__func__.5785+0x1830>
    dcec:	b9 ac 04 00 00       	mov    $0x4ac,%ecx
    dcf1:	31 c0                	xor    %eax,%eax
    dcf3:	e8 98 7c ff ff       	callq  5990 <printk>
    dcf8:	48 8d 35 4d 47 02 00 	lea    0x2474d(%rip),%rsi        # 3244c <__func__.5785+0x17e4>
    dcff:	48 8d 3d a6 47 02 00 	lea    0x247a6(%rip),%rdi        # 324ac <__func__.5785+0x1844>
    dd06:	ba ac 04 00 00       	mov    $0x4ac,%edx
    dd0b:	31 c0                	xor    %eax,%eax
    dd0d:	e8 7e 7c ff ff       	callq  5990 <printk>
    dd12:	31 f6                	xor    %esi,%esi
    dd14:	bf 03 00 00 00       	mov    $0x3,%edi
    dd19:	e8 cc cb 01 00       	callq  2a8ea <z_fatal_error>
    dd1e:	48 8d 7b 10          	lea    0x10(%rbx),%rdi
    dd22:	be 04 00 00 00       	mov    $0x4,%esi
    dd27:	e8 e3 b3 00 00       	callq  1910f <net_buf_simple_pull_mem>
	if (buf->len != len) {
    dd2c:	0f b7 73 18          	movzwl 0x18(%rbx),%esi
	len = sys_le16_to_cpu(hdr->len);
    dd30:	0f b7 50 02          	movzwl 0x2(%rax),%edx
	handle = sys_le16_to_cpu(hdr->handle);
    dd34:	66 44 8b 20          	mov    (%rax),%r12w
	acl(buf)->index = BT_CONN_INDEX_INVALID;
    dd38:	c6 43 29 ff          	movb   $0xff,0x29(%rbx)
	acl(buf)->handle = bt_acl_handle(handle);
    dd3c:	44 89 e7             	mov    %r12d,%edi
    dd3f:	66 81 e7 ff 0f       	and    $0xfff,%di
	if (buf->len != len) {
    dd44:	66 39 f2             	cmp    %si,%dx
	acl(buf)->handle = bt_acl_handle(handle);
    dd47:	66 89 7b 2a          	mov    %di,0x2a(%rbx)
	if (buf->len != len) {
    dd4b:	74 19                	je     dd66 <hci_rx_thread+0xea>
		BT_ERR("ACL data length mismatch (%u != %u)", buf->len, len);
    dd4d:	89 e9                	mov    %ebp,%ecx
    dd4f:	48 8d 3d 5f 47 02 00 	lea    0x2475f(%rip),%rdi        # 324b5 <__func__.5785+0x184d>
    dd56:	c1 e1 06             	shl    $0x6,%ecx
    dd59:	83 c9 01             	or     $0x1,%ecx
    dd5c:	e8 d1 95 ff ff       	callq  7332 <log_2>
    dd61:	e9 35 01 00 00       	jmpq   de9b <hci_rx_thread+0x21f>
	conn = bt_conn_lookup_handle(acl(buf)->handle);
    dd66:	0f b7 ff             	movzwl %di,%edi
    dd69:	e8 76 3a 00 00       	callq  117e4 <bt_conn_lookup_handle>
	if (!conn) {
    dd6e:	48 85 c0             	test   %rax,%rax
	conn = bt_conn_lookup_handle(acl(buf)->handle);
    dd71:	49 89 c5             	mov    %rax,%r13
	if (!conn) {
    dd74:	75 18                	jne    dd8e <hci_rx_thread+0x112>
		BT_ERR("Unable to find conn for handle %u", acl(buf)->handle);
    dd76:	89 ea                	mov    %ebp,%edx
    dd78:	0f b7 73 2a          	movzwl 0x2a(%rbx),%esi
    dd7c:	48 8d 3d 56 47 02 00 	lea    0x24756(%rip),%rdi        # 324d9 <__func__.5785+0x1871>
    dd83:	c1 e2 06             	shl    $0x6,%edx
    dd86:	83 ca 01             	or     $0x1,%edx
    dd89:	e9 08 01 00 00       	jmpq   de96 <hci_rx_thread+0x21a>
	acl(buf)->index = bt_conn_index(conn);
    dd8e:	48 89 c7             	mov    %rax,%rdi
	flags = bt_acl_flags(handle);
    dd91:	66 41 c1 ec 0c       	shr    $0xc,%r12w
	acl(buf)->index = bt_conn_index(conn);
    dd96:	e8 00 42 00 00       	callq  11f9b <bt_conn_index>
	bt_conn_recv(conn, buf, flags);
    dd9b:	4c 89 ef             	mov    %r13,%rdi
	acl(buf)->index = bt_conn_index(conn);
    dd9e:	88 43 29             	mov    %al,0x29(%rbx)
	bt_conn_recv(conn, buf, flags);
    dda1:	41 0f b7 d4          	movzwl %r12w,%edx
    dda5:	48 89 de             	mov    %rbx,%rsi
    dda8:	e8 3f 35 00 00       	callq  112ec <bt_conn_recv>
	bt_conn_unref(conn);
    ddad:	4c 89 ef             	mov    %r13,%rdi
    ddb0:	e8 af 39 00 00       	callq  11764 <bt_conn_unref>
    ddb5:	e9 e9 00 00 00       	jmpq   dea3 <hci_rx_thread+0x227>
	BT_ASSERT(buf->len >= sizeof(*hdr));
    ddba:	66 83 78 18 01       	cmpw   $0x1,0x18(%rax)
    ddbf:	77 47                	ja     de08 <hci_rx_thread+0x18c>
    ddc1:	48 8d 15 84 46 02 00 	lea    0x24684(%rip),%rdx        # 3244c <__func__.5785+0x17e4>
    ddc8:	48 8d 35 b0 46 02 00 	lea    0x246b0(%rip),%rsi        # 3247f <__func__.5785+0x1817>
    ddcf:	48 8d 3d c2 46 02 00 	lea    0x246c2(%rip),%rdi        # 32498 <__func__.5785+0x1830>
    ddd6:	b9 fb 13 00 00       	mov    $0x13fb,%ecx
    dddb:	31 c0                	xor    %eax,%eax
    dddd:	e8 ae 7b ff ff       	callq  5990 <printk>
    dde2:	48 8d 35 63 46 02 00 	lea    0x24663(%rip),%rsi        # 3244c <__func__.5785+0x17e4>
    dde9:	48 8d 3d bc 46 02 00 	lea    0x246bc(%rip),%rdi        # 324ac <__func__.5785+0x1844>
    ddf0:	ba fb 13 00 00       	mov    $0x13fb,%edx
    ddf5:	31 c0                	xor    %eax,%eax
    ddf7:	e8 94 7b ff ff       	callq  5990 <printk>
    ddfc:	31 f6                	xor    %esi,%esi
    ddfe:	bf 03 00 00 00       	mov    $0x3,%edi
    de03:	e8 e2 ca 01 00       	callq  2a8ea <z_fatal_error>
    de08:	48 8d 7b 10          	lea    0x10(%rbx),%rdi
    de0c:	be 02 00 00 00       	mov    $0x2,%esi
    de11:	e8 f9 b2 00 00       	callq  1910f <net_buf_simple_pull_mem>
	BT_ASSERT(bt_hci_evt_get_flags(hdr->evt) & BT_HCI_EVT_FLAG_RECV);
    de16:	0f b6 38             	movzbl (%rax),%edi
    de19:	49 89 c4             	mov    %rax,%r12
    de1c:	e8 48 f9 ff ff       	callq  d769 <bt_hci_evt_get_flags>
    de21:	a8 02                	test   $0x2,%al
    de23:	75 47                	jne    de6c <hci_rx_thread+0x1f0>
    de25:	48 8d 15 20 46 02 00 	lea    0x24620(%rip),%rdx        # 3244c <__func__.5785+0x17e4>
    de2c:	48 8d 35 c8 46 02 00 	lea    0x246c8(%rip),%rsi        # 324fb <__func__.5785+0x1893>
    de33:	48 8d 3d 5e 46 02 00 	lea    0x2465e(%rip),%rdi        # 32498 <__func__.5785+0x1830>
    de3a:	b9 ff 13 00 00       	mov    $0x13ff,%ecx
    de3f:	31 c0                	xor    %eax,%eax
    de41:	e8 4a 7b ff ff       	callq  5990 <printk>
    de46:	48 8d 35 ff 45 02 00 	lea    0x245ff(%rip),%rsi        # 3244c <__func__.5785+0x17e4>
    de4d:	48 8d 3d 58 46 02 00 	lea    0x24658(%rip),%rdi        # 324ac <__func__.5785+0x1844>
    de54:	ba ff 13 00 00       	mov    $0x13ff,%edx
    de59:	31 c0                	xor    %eax,%eax
    de5b:	e8 30 7b ff ff       	callq  5990 <printk>
    de60:	31 f6                	xor    %esi,%esi
    de62:	bf 03 00 00 00       	mov    $0x3,%edi
    de67:	e8 7e ca 01 00       	callq  2a8ea <z_fatal_error>
	handle_event(hdr->evt, buf, normal_events, ARRAY_SIZE(normal_events));
    de6c:	41 0f b6 3c 24       	movzbl (%r12),%edi
    de71:	48 8d 15 e8 74 22 00 	lea    0x2274e8(%rip),%rdx        # 235360 <normal_events>
    de78:	b9 04 00 00 00       	mov    $0x4,%ecx
    de7d:	48 89 de             	mov    %rbx,%rsi
    de80:	e8 39 fd ff ff       	callq  dbbe <handle_event>
    de85:	eb 14                	jmp    de9b <hci_rx_thread+0x21f>
			BT_ERR("Unknown buf type %u", bt_buf_get_type(buf));
    de87:	89 ea                	mov    %ebp,%edx
    de89:	48 8d 3d 99 46 02 00 	lea    0x24699(%rip),%rdi        # 32529 <__func__.5785+0x18c1>
    de90:	c1 e2 06             	shl    $0x6,%edx
    de93:	83 ca 01             	or     $0x1,%edx
    de96:	e8 5a 94 ff ff       	callq  72f5 <log_1>
			net_buf_unref(buf);
    de9b:	48 89 df             	mov    %rbx,%rdi
    de9e:	e8 f7 b0 00 00       	callq  18f9a <net_buf_unref>
	z_impl_k_yield();
    dea3:	31 c0                	xor    %eax,%eax
    dea5:	e8 4c df 01 00       	callq  2bdf6 <z_impl_k_yield>
    deaa:	e9 fa fd ff ff       	jmpq   dca9 <hci_rx_thread+0x2d>

000000000000deaf <hci_le_meta_event>:
{
    deaf:	53                   	push   %rbx
    deb0:	48 89 fb             	mov    %rdi,%rbx
    deb3:	48 8d 7f 10          	lea    0x10(%rdi),%rdi
    deb7:	be 01 00 00 00       	mov    $0x1,%esi
    debc:	e8 4e b2 00 00       	callq  1910f <net_buf_simple_pull_mem>
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    dec1:	48 89 de             	mov    %rbx,%rsi
    dec4:	0f b6 38             	movzbl (%rax),%edi
    dec7:	48 8d 15 d2 74 22 00 	lea    0x2274d2(%rip),%rdx        # 2353a0 <meta_events>
}
    dece:	5b                   	pop    %rbx
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    decf:	b9 07 00 00 00       	mov    $0x7,%ecx
    ded4:	e9 e5 fc ff ff       	jmpq   dbbe <handle_event>

000000000000ded9 <find_pending_connect.part.19>:
static struct bt_conn *find_pending_connect(uint8_t role, bt_addr_le_t *peer_addr)
    ded9:	48 83 ec 18          	sub    $0x18,%rsp
						       BT_ADDR_LE_NONE,
    dedd:	48 8d 35 59 46 02 00 	lea    0x24659(%rip),%rsi        # 3253d <__func__.5785+0x18d5>
    dee4:	b9 07 00 00 00       	mov    $0x7,%ecx
static struct bt_conn *find_pending_connect(uint8_t role, bt_addr_le_t *peer_addr)
    dee9:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    def0:	00 00 
    def2:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    def7:	31 c0                	xor    %eax,%eax
			conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id,
    def9:	48 8d 05 40 87 22 00 	lea    0x228740(%rip),%rax        # 236640 <bt_dev>
						       BT_ADDR_LE_NONE,
    df00:	48 8d 7c 24 01       	lea    0x1(%rsp),%rdi
			conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id,
    df05:	ba 04 00 00 00       	mov    $0x4,%edx
						       BT_ADDR_LE_NONE,
    df0a:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
			conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id,
    df0c:	48 8d 74 24 01       	lea    0x1(%rsp),%rsi
    df11:	0f b6 78 33          	movzbl 0x33(%rax),%edi
    df15:	e8 96 3b 00 00       	callq  11ab0 <bt_conn_lookup_state_le>
}
    df1a:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    df1f:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
    df26:	00 00 
    df28:	74 05                	je     df2f <find_pending_connect.part.19+0x56>
    df2a:	e8 11 67 ff ff       	callq  4640 <__stack_chk_fail@plt>
    df2f:	48 83 c4 18          	add    $0x18,%rsp
    df33:	c3                   	retq   

000000000000df34 <atomic_test_bit>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    df34:	8b 07                	mov    (%rdi),%eax
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    df36:	40 88 f1             	mov    %sil,%cl
    df39:	d3 f8                	sar    %cl,%eax
    df3b:	83 e0 01             	and    $0x1,%eax
}
    df3e:	c3                   	retq   

000000000000df3f <le_adv_start_add_conn>:
	return 0;
}

static int le_adv_start_add_conn(const struct bt_le_ext_adv *adv,
				 struct bt_conn **out_conn)
{
    df3f:	41 55                	push   %r13
    df41:	41 54                	push   %r12
    df43:	49 89 f5             	mov    %rsi,%r13
    df46:	55                   	push   %rbp
    df47:	53                   	push   %rbx
    df48:	48 89 fd             	mov    %rdi,%rbp
	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED) &&
    df4b:	be 06 00 00 00       	mov    $0x6,%esi
{
    df50:	48 83 ec 28          	sub    $0x28,%rsp
	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED) &&
    df54:	48 8d 15 e5 86 22 00 	lea    0x2286e5(%rip),%rdx        # 236640 <bt_dev>
	struct adv_id_check_data check_data = {
		.id = adv->id,
    df5b:	44 8a 07             	mov    (%rdi),%r8b
{
    df5e:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    df65:	00 00 
    df67:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    df6c:	31 c0                	xor    %eax,%eax
	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED) &&
    df6e:	48 8d 7a 28          	lea    0x28(%rdx),%rdi
    df72:	e8 bd ff ff ff       	callq  df34 <atomic_test_bit>
    df77:	84 c0                	test   %al,%al
    df79:	75 04                	jne    df7f <le_adv_start_add_conn+0x40>
	struct adv_id_check_data check_data = {
    df7b:	31 c0                	xor    %eax,%eax
    df7d:	eb 24                	jmp    dfa3 <le_adv_start_add_conn+0x64>
	    atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE) &&
    df7f:	48 8d 7a 28          	lea    0x28(%rdx),%rdi
    df83:	be 08 00 00 00       	mov    $0x8,%esi
    df88:	e8 a7 ff ff ff       	callq  df34 <atomic_test_bit>
	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED) &&
    df8d:	84 c0                	test   %al,%al
    df8f:	74 ea                	je     df7b <le_adv_start_add_conn+0x3c>
	    atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE) &&
    df91:	44 38 42 18          	cmp    %r8b,0x18(%rdx)
	};
	struct bt_conn *conn;

	bt_adv_foreach(adv_id_check_connectable_func, &check_data);
	if (check_data.adv_enabled) {
		return -ENOTSUP;
    df95:	bb a1 ff ff ff       	mov    $0xffffffa1,%ebx
	if (check_data.adv_enabled) {
    df9a:	0f 95 c0             	setne  %al
    df9d:	0f 85 a5 00 00 00    	jne    e048 <le_adv_start_add_conn+0x109>
	}

	bt_dev.adv_conn_id = adv->id;
    dfa3:	8a 4d 00             	mov    0x0(%rbp),%cl

	if (!bt_addr_le_cmp(&adv->target_addr, BT_ADDR_LE_ANY)) {
    dfa6:	48 8d 7c 24 0a       	lea    0xa(%rsp),%rdi
    dfab:	4c 8d 65 09          	lea    0x9(%rbp),%r12
    dfaf:	48 8d 74 24 0a       	lea    0xa(%rsp),%rsi
	bt_dev.adv_conn_id = adv->id;
    dfb4:	88 4a 33             	mov    %cl,0x33(%rdx)
	if (!bt_addr_le_cmp(&adv->target_addr, BT_ADDR_LE_ANY)) {
    dfb7:	b9 07 00 00 00       	mov    $0x7,%ecx
    dfbc:	f3 aa                	rep stos %al,%es:(%rdi)
    dfbe:	4c 89 e7             	mov    %r12,%rdi
    dfc1:	e8 ae fa ff ff       	callq  da74 <bt_addr_le_cmp>
    dfc6:	85 c0                	test   %eax,%eax
    dfc8:	89 c3                	mov    %eax,%ebx
    dfca:	0f b6 7d 00          	movzbl 0x0(%rbp),%edi
    dfce:	75 40                	jne    e010 <le_adv_start_add_conn+0xd1>
		/* Undirected advertising */
		conn = bt_conn_add_le(adv->id, BT_ADDR_LE_NONE);
    dfd0:	48 8d 74 24 11       	lea    0x11(%rsp),%rsi
    dfd5:	c7 44 24 11 00 ff ff 	movl   $0xffffff00,0x11(%rsp)
    dfdc:	ff 
    dfdd:	66 c7 44 24 15 ff ff 	movw   $0xffff,0x15(%rsp)
    dfe4:	c6 44 24 17 ff       	movb   $0xff,0x17(%rsp)
    dfe9:	e8 72 36 00 00       	callq  11660 <bt_conn_add_le>
		if (!conn) {
    dfee:	48 85 c0             	test   %rax,%rax
		conn = bt_conn_add_le(adv->id, BT_ADDR_LE_NONE);
    dff1:	48 89 c5             	mov    %rax,%rbp
		if (!conn) {
    dff4:	75 07                	jne    dffd <le_adv_start_add_conn+0xbe>
			return -ENOMEM;
    dff6:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
    dffb:	eb 4b                	jmp    e048 <le_adv_start_add_conn+0x109>
		}

		bt_conn_set_state(conn, BT_CONN_CONNECT_ADV);
    dffd:	be 04 00 00 00       	mov    $0x4,%esi
    e002:	48 89 c7             	mov    %rax,%rdi
    e005:	e8 ee 37 00 00       	callq  117f8 <bt_conn_set_state>
		*out_conn = conn;
    e00a:	49 89 6d 00          	mov    %rbp,0x0(%r13)
		return 0;
    e00e:	eb 38                	jmp    e048 <le_adv_start_add_conn+0x109>
	}

	if (bt_conn_exists_le(adv->id, &adv->target_addr)) {
    e010:	4c 89 e6             	mov    %r12,%rsi
		return -EINVAL;
    e013:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	if (bt_conn_exists_le(adv->id, &adv->target_addr)) {
    e018:	e8 3e 3a 00 00       	callq  11a5b <bt_conn_exists_le>
    e01d:	84 c0                	test   %al,%al
    e01f:	75 27                	jne    e048 <le_adv_start_add_conn+0x109>
	}

	conn = bt_conn_add_le(adv->id, &adv->target_addr);
    e021:	0f b6 7d 00          	movzbl 0x0(%rbp),%edi
    e025:	4c 89 e6             	mov    %r12,%rsi
    e028:	e8 33 36 00 00       	callq  11660 <bt_conn_add_le>
	if (!conn) {
    e02d:	48 85 c0             	test   %rax,%rax
	conn = bt_conn_add_le(adv->id, &adv->target_addr);
    e030:	48 89 c3             	mov    %rax,%rbx
	if (!conn) {
    e033:	74 c1                	je     dff6 <le_adv_start_add_conn+0xb7>
		return -ENOMEM;
	}

	bt_conn_set_state(conn, BT_CONN_CONNECT_DIR_ADV);
    e035:	be 05 00 00 00       	mov    $0x5,%esi
    e03a:	48 89 c7             	mov    %rax,%rdi
    e03d:	e8 b6 37 00 00       	callq  117f8 <bt_conn_set_state>
	*out_conn = conn;
    e042:	49 89 5d 00          	mov    %rbx,0x0(%r13)
	return 0;
    e046:	31 db                	xor    %ebx,%ebx
}
    e048:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    e04d:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    e054:	00 00 
    e056:	89 d8                	mov    %ebx,%eax
    e058:	74 05                	je     e05f <le_adv_start_add_conn+0x120>
    e05a:	e8 e1 65 ff ff       	callq  4640 <__stack_chk_fail@plt>
    e05f:	48 83 c4 28          	add    $0x28,%rsp
    e063:	5b                   	pop    %rbx
    e064:	5d                   	pop    %rbp
    e065:	41 5c                	pop    %r12
    e067:	41 5d                	pop    %r13
    e069:	c3                   	retq   

000000000000e06a <id_create.constprop.29>:
static void id_create(uint8_t id, bt_addr_le_t *addr, uint8_t *irk)
    e06a:	41 55                	push   %r13
    e06c:	41 54                	push   %r12
    e06e:	55                   	push   %rbp
    e06f:	53                   	push   %rbx
    e070:	40 0f b6 df          	movzbl %dil,%ebx
    e074:	48 6b db 07          	imul   $0x7,%rbx,%rbx
    e078:	48 89 f5             	mov    %rsi,%rbp
    e07b:	48 83 ec 28          	sub    $0x28,%rsp
    e07f:	4c 8d 2d ba 85 22 00 	lea    0x2285ba(%rip),%r13        # 236640 <bt_dev>
    e086:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    e08d:	00 00 
    e08f:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    e094:	31 c0                	xor    %eax,%eax
    e096:	4c 01 eb             	add    %r13,%rbx
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    e099:	48 85 f6             	test   %rsi,%rsi
    e09c:	75 07                	jne    e0a5 <id_create.constprop.29+0x3b>
			bt_addr_le_create_static(&new_addr);
    e09e:	4c 8d 64 24 0a       	lea    0xa(%rsp),%r12
    e0a3:	eb 27                	jmp    e0cc <id_create.constprop.29+0x62>
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    e0a5:	48 8d 7c 24 11       	lea    0x11(%rsp),%rdi
    e0aa:	31 c0                	xor    %eax,%eax
    e0ac:	b9 07 00 00 00       	mov    $0x7,%ecx
    e0b1:	48 8d 74 24 11       	lea    0x11(%rsp),%rsi
    e0b6:	f3 aa                	rep stos %al,%es:(%rdi)
    e0b8:	48 89 ef             	mov    %rbp,%rdi
    e0bb:	e8 b4 f9 ff ff       	callq  da74 <bt_addr_le_cmp>
    e0c0:	85 c0                	test   %eax,%eax
    e0c2:	74 da                	je     e09e <id_create.constprop.29+0x34>
		bt_addr_le_copy(&bt_dev.id_addr[id], addr);
    e0c4:	48 89 ee             	mov    %rbp,%rsi
    e0c7:	48 89 df             	mov    %rbx,%rdi
    e0ca:	eb 2a                	jmp    e0f6 <id_create.constprop.29+0x8c>
			bt_addr_le_create_static(&new_addr);
    e0cc:	4c 89 e7             	mov    %r12,%rdi
    e0cf:	e8 72 f5 ff ff       	callq  d646 <bt_addr_le_create_static>
		} while (id_find(&new_addr) >= 0);
    e0d4:	4c 89 e7             	mov    %r12,%rdi
    e0d7:	e8 a2 f9 ff ff       	callq  da7e <id_find>
    e0dc:	85 c0                	test   %eax,%eax
    e0de:	79 ec                	jns    e0cc <id_create.constprop.29+0x62>
		bt_addr_le_copy(&bt_dev.id_addr[id], &new_addr);
    e0e0:	4c 89 e6             	mov    %r12,%rsi
    e0e3:	48 89 df             	mov    %rbx,%rdi
    e0e6:	e8 d2 f6 ff ff       	callq  d7bd <bt_addr_le_copy>
		if (addr) {
    e0eb:	48 85 ed             	test   %rbp,%rbp
    e0ee:	74 0b                	je     e0fb <id_create.constprop.29+0x91>
			bt_addr_le_copy(addr, &bt_dev.id_addr[id]);
    e0f0:	48 89 de             	mov    %rbx,%rsi
    e0f3:	48 89 ef             	mov    %rbp,%rdi
    e0f6:	e8 c2 f6 ff ff       	callq  d7bd <bt_addr_le_copy>
	    atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    e0fb:	49 8d bd a0 00 00 00 	lea    0xa0(%r13),%rdi
    e102:	be 01 00 00 00       	mov    $0x1,%esi
    e107:	e8 28 fe ff ff       	callq  df34 <atomic_test_bit>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
    e10c:	84 c0                	test   %al,%al
    e10e:	74 05                	je     e115 <id_create.constprop.29+0xab>
		bt_settings_save_id();
    e110:	e8 bd f2 ff ff       	callq  d3d2 <bt_settings_save_id>
}
    e115:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    e11a:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    e121:	00 00 
    e123:	74 05                	je     e12a <id_create.constprop.29+0xc0>
    e125:	e8 16 65 ff ff       	callq  4640 <__stack_chk_fail@plt>
    e12a:	48 83 c4 28          	add    $0x28,%rsp
    e12e:	5b                   	pop    %rbx
    e12f:	5d                   	pop    %rbp
    e130:	41 5c                	pop    %r12
    e132:	41 5d                	pop    %r13
    e134:	c3                   	retq   

000000000000e135 <hci_num_completed_packets>:
{
    e135:	41 57                	push   %r15
    e137:	41 56                	push   %r14
    e139:	41 55                	push   %r13
    e13b:	41 54                	push   %r12
	for (i = 0; i < evt->num_handles; i++) {
    e13d:	45 31 ed             	xor    %r13d,%r13d
{
    e140:	55                   	push   %rbp
    e141:	53                   	push   %rbx
    e142:	48 83 ec 18          	sub    $0x18,%rsp
    e146:	48 8d 2d 83 c2 22 00 	lea    0x22c283(%rip),%rbp        # 23a3d0 <log_const_bt_hci_core>
    e14d:	48 2b 2d fc 7d 22 00 	sub    0x227dfc(%rip),%rbp        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
	struct bt_hci_evt_num_completed_packets *evt = (void *)buf->data;
    e154:	4c 8b 77 10          	mov    0x10(%rdi),%r14
    e158:	48 c1 ed 04          	shr    $0x4,%rbp
			BT_ERR("No connection for handle %u", handle);
    e15c:	c1 e5 06             	shl    $0x6,%ebp
	for (i = 0; i < evt->num_handles; i++) {
    e15f:	41 0f b6 06          	movzbl (%r14),%eax
    e163:	41 39 c5             	cmp    %eax,%r13d
    e166:	0f 8d 2e 01 00 00    	jge    e29a <hci_num_completed_packets+0x165>
    e16c:	49 63 c5             	movslq %r13d,%rax
    e16f:	49 8d 04 86          	lea    (%r14,%rax,4),%rax
		handle = sys_le16_to_cpu(evt->h[i].handle);
    e173:	0f b7 78 01          	movzwl 0x1(%rax),%edi
		count = sys_le16_to_cpu(evt->h[i].count);
    e177:	66 44 8b 60 03       	mov    0x3(%rax),%r12w
		handle = sys_le16_to_cpu(evt->h[i].handle);
    e17c:	41 89 ff             	mov    %edi,%r15d
		conn = bt_conn_lookup_handle(handle);
    e17f:	e8 60 36 00 00       	callq  117e4 <bt_conn_lookup_handle>
		if (!conn) {
    e184:	48 85 c0             	test   %rax,%rax
		conn = bt_conn_lookup_handle(handle);
    e187:	48 89 c3             	mov    %rax,%rbx
		if (!conn) {
    e18a:	74 0e                	je     e19a <hci_num_completed_packets+0x65>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    e18c:	48 8d 40 40          	lea    0x40(%rax),%rax
    e190:	41 ff cc             	dec    %r12d
    e193:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    e198:	eb 45                	jmp    e1df <hci_num_completed_packets+0xaa>
			BT_ERR("No connection for handle %u", handle);
    e19a:	89 ea                	mov    %ebp,%edx
    e19c:	48 8d 3d a1 43 02 00 	lea    0x243a1(%rip),%rdi        # 32544 <__func__.5785+0x18dc>
    e1a3:	41 0f b7 f7          	movzwl %r15w,%esi
    e1a7:	83 ca 01             	or     $0x1,%edx
    e1aa:	e8 46 91 ff ff       	callq  72f5 <log_1>
			continue;
    e1af:	e9 de 00 00 00       	jmpq   e292 <hci_num_completed_packets+0x15d>
	return posix_irq_lock();
    e1b4:	e8 d9 dd ff ff       	callq  bf92 <posix_irq_lock>
			if (conn->pending_no_cb) {
    e1b9:	8b 53 28             	mov    0x28(%rbx),%edx
    e1bc:	89 c7                	mov    %eax,%edi
    e1be:	85 d2                	test   %edx,%edx
    e1c0:	74 29                	je     e1eb <hci_num_completed_packets+0xb6>
				conn->pending_no_cb--;
    e1c2:	ff ca                	dec    %edx
    e1c4:	89 53 28             	mov    %edx,0x28(%rbx)
	posix_irq_unlock(key);
    e1c7:	e8 d0 dd ff ff       	callq  bf9c <posix_irq_unlock>
			k_sem_give(bt_conn_get_pkts(conn));
    e1cc:	48 89 df             	mov    %rbx,%rdi
    e1cf:	e8 a9 2d 00 00       	callq  10f7d <bt_conn_get_pkts>
	z_impl_k_sem_give(sem);
    e1d4:	48 89 c7             	mov    %rax,%rdi
    e1d7:	41 ff cc             	dec    %r12d
    e1da:	e8 57 dd 01 00       	callq  2bf36 <z_impl_k_sem_give>
		while (count--) {
    e1df:	66 41 83 fc ff       	cmp    $0xffff,%r12w
    e1e4:	75 ce                	jne    e1b4 <hci_num_completed_packets+0x7f>
    e1e6:	e9 9f 00 00 00       	jmpq   e28a <hci_num_completed_packets+0x155>
 *
 * @return a boolean, true if it's empty, false otherwise
 */
static inline bool sys_slist_is_empty(sys_slist_t *list);

Z_GENLIST_IS_EMPTY(slist)
    e1eb:	4c 8b 7b 18          	mov    0x18(%rbx),%r15
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    e1ef:	4d 85 ff             	test   %r15,%r15
    e1f2:	74 11                	je     e205 <hci_num_completed_packets+0xd0>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    e1f4:	4c 3b 7b 20          	cmp    0x20(%rbx),%r15
	return node->next;
    e1f8:	49 8b 07             	mov    (%r15),%rax
	list->head = node;
    e1fb:	48 89 43 18          	mov    %rax,0x18(%rbx)
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    e1ff:	75 04                	jne    e205 <hci_num_completed_packets+0xd0>
	list->tail = node;
    e201:	48 89 43 20          	mov    %rax,0x20(%rbx)
    e205:	e8 92 dd ff ff       	callq  bf9c <posix_irq_unlock>
			if (!node) {
    e20a:	4d 85 ff             	test   %r15,%r15
    e20d:	75 13                	jne    e222 <hci_num_completed_packets+0xed>
				BT_ERR("packets count mismatch");
    e20f:	89 ee                	mov    %ebp,%esi
    e211:	48 8d 3d 48 43 02 00 	lea    0x24348(%rip),%rdi        # 32560 <__func__.5785+0x18f8>
    e218:	83 ce 01             	or     $0x1,%esi
    e21b:	e8 a4 90 ff ff       	callq  72c4 <log_0>
    e220:	eb 68                	jmp    e28a <hci_num_completed_packets+0x155>
	return posix_irq_lock();
    e222:	e8 6b dd ff ff       	callq  bf92 <posix_irq_lock>
			conn->pending_no_cb = tx->pending_no_cb;
    e227:	41 8b 4f 18          	mov    0x18(%r15),%ecx
    e22b:	89 4b 28             	mov    %ecx,0x28(%rbx)
	parent->next = child;
    e22e:	49 c7 07 00 00 00 00 	movq   $0x0,(%r15)
Z_GENLIST_APPEND(slist, snode)
    e235:	48 8b 4b 38          	mov    0x38(%rbx),%rcx
			tx->pending_no_cb = 0U;
    e239:	41 c7 47 18 00 00 00 	movl   $0x0,0x18(%r15)
    e240:	00 
    e241:	48 85 c9             	test   %rcx,%rcx
    e244:	75 0a                	jne    e250 <hci_num_completed_packets+0x11b>
	list->tail = node;
    e246:	4c 89 7b 38          	mov    %r15,0x38(%rbx)
	list->head = node;
    e24a:	4c 89 7b 30          	mov    %r15,0x30(%rbx)
    e24e:	eb 07                	jmp    e257 <hci_num_completed_packets+0x122>
	parent->next = child;
    e250:	4c 89 39             	mov    %r15,(%rcx)
	list->tail = node;
    e253:	4c 89 7b 38          	mov    %r15,0x38(%rbx)
	posix_irq_unlock(key);
    e257:	89 c7                	mov    %eax,%edi
    e259:	e8 3e dd ff ff       	callq  bf9c <posix_irq_unlock>
    e25e:	48 8d 7b 50          	lea    0x50(%rbx),%rdi
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
    e262:	be 01 00 00 00       	mov    $0x1,%esi
    e267:	e8 66 f5 ff ff       	callq  d7d2 <atomic_or>
    e26c:	a8 01                	test   $0x1,%al
    e26e:	0f 85 58 ff ff ff    	jne    e1cc <hci_num_completed_packets+0x97>
		k_queue_append(&work_q->queue, work);
    e274:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    e279:	48 8d 3d 20 99 24 00 	lea    0x249920(%rip),%rdi        # 257ba0 <k_sys_work_q>
    e280:	e8 a6 d0 01 00       	callq  2b32b <k_queue_append>
    e285:	e9 42 ff ff ff       	jmpq   e1cc <hci_num_completed_packets+0x97>
		bt_conn_unref(conn);
    e28a:	48 89 df             	mov    %rbx,%rdi
    e28d:	e8 d2 34 00 00       	callq  11764 <bt_conn_unref>
	for (i = 0; i < evt->num_handles; i++) {
    e292:	41 ff c5             	inc    %r13d
    e295:	e9 c5 fe ff ff       	jmpq   e15f <hci_num_completed_packets+0x2a>
}
    e29a:	48 83 c4 18          	add    $0x18,%rsp
    e29e:	5b                   	pop    %rbx
    e29f:	5d                   	pop    %rbp
    e2a0:	41 5c                	pop    %r12
    e2a2:	41 5d                	pop    %r13
    e2a4:	41 5e                	pop    %r14
    e2a6:	41 5f                	pop    %r15
    e2a8:	c3                   	retq   

000000000000e2a9 <sys_put_le64>:
	dst[1] = val >> 8;
    e2a9:	89 f8                	mov    %edi,%eax
	dst[0] = val;
    e2ab:	40 88 3e             	mov    %dil,(%rsi)
    e2ae:	c6 46 02 00          	movb   $0x0,0x2(%rsi)
	dst[1] = val >> 8;
    e2b2:	66 c1 e8 08          	shr    $0x8,%ax
	dst[0] = val;
    e2b6:	66 c7 46 04 00 00    	movw   $0x0,0x4(%rsi)
	dst[1] = val >> 8;
    e2bc:	c6 46 06 00          	movb   $0x0,0x6(%rsi)
    e2c0:	88 46 01             	mov    %al,0x1(%rsi)
	sys_put_le16(val >> 16, &dst[2]);
    e2c3:	89 f8                	mov    %edi,%eax
	dst[1] = val >> 8;
    e2c5:	48 c1 ef 38          	shr    $0x38,%rdi
	sys_put_le16(val >> 16, &dst[2]);
    e2c9:	c1 e8 10             	shr    $0x10,%eax
	dst[1] = val >> 8;
    e2cc:	40 88 7e 07          	mov    %dil,0x7(%rsi)
    e2d0:	88 66 03             	mov    %ah,0x3(%rsi)
}
    e2d3:	c3                   	retq   

000000000000e2d4 <atomic_set_bit_to>:
 * @param val true for 1, false for 0.
 *
 * @return N/A
 */
static inline void atomic_set_bit_to(atomic_t *target, int bit, bool val)
{
    e2d4:	48 63 ce             	movslq %esi,%rcx
	atomic_val_t mask = ATOMIC_MASK(bit);
    e2d7:	be 01 00 00 00       	mov    $0x1,%esi
    e2dc:	d3 e6                	shl    %cl,%esi
    e2de:	48 c1 e9 05          	shr    $0x5,%rcx

	if (val) {
    e2e2:	84 d2                	test   %dl,%dl
    e2e4:	48 8d 3c 8f          	lea    (%rdi,%rcx,4),%rdi
    e2e8:	74 05                	je     e2ef <atomic_set_bit_to+0x1b>
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    e2ea:	e9 e3 f4 ff ff       	jmpq   d7d2 <atomic_or>
	} else {
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    e2ef:	f7 d6                	not    %esi
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    e2f1:	f0 21 37             	lock and %esi,(%rdi)
	}
}
    e2f4:	c3                   	retq   

000000000000e2f5 <hci_cmd_done>:
{
    e2f5:	41 57                	push   %r15
    e2f7:	41 56                	push   %r14
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    e2f9:	4c 8d 3d f0 c4 22 00 	lea    0x22c4f0(%rip),%r15        # 23a7f0 <hci_cmd_pool>
{
    e300:	41 55                	push   %r13
    e302:	41 54                	push   %r12
    e304:	44 0f b7 ef          	movzwl %di,%r13d
    e308:	55                   	push   %rbp
    e309:	53                   	push   %rbx
    e30a:	41 89 fc             	mov    %edi,%r12d
    e30d:	41 89 f6             	mov    %esi,%r14d
    e310:	48 89 d5             	mov    %rdx,%rbp
    e313:	48 83 ec 38          	sub    $0x38,%rsp
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    e317:	0f b6 7a 0a          	movzbl 0xa(%rdx),%edi
{
    e31b:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    e322:	00 00 
    e324:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    e329:	31 c0                	xor    %eax,%eax
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    e32b:	e8 c9 a9 00 00       	callq  18cf9 <net_buf_pool_get>
    e330:	4c 39 f8             	cmp    %r15,%rax
    e333:	74 55                	je     e38a <hci_cmd_done+0x95>
    e335:	48 8d 1d 94 c0 22 00 	lea    0x22c094(%rip),%rbx        # 23a3d0 <log_const_bt_hci_core>
    e33c:	48 2b 1d 0d 7c 22 00 	sub    0x227c0d(%rip),%rbx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("opcode 0x%04x pool id %u pool %p != &hci_cmd_pool %p",
    e343:	0f b6 45 0a          	movzbl 0xa(%rbp),%eax
    e347:	4c 89 6c 24 08       	mov    %r13,0x8(%rsp)
    e34c:	48 c1 eb 04          	shr    $0x4,%rbx
    e350:	c1 e3 06             	shl    $0x6,%ebx
    e353:	48 89 c7             	mov    %rax,%rdi
    e356:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    e35b:	83 cb 02             	or     $0x2,%ebx
    e35e:	e8 96 a9 00 00       	callq  18cf9 <net_buf_pool_get>
    e363:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    e368:	48 8d 3d 08 42 02 00 	lea    0x24208(%rip),%rdi        # 32577 <__func__.5785+0x190f>
    e36f:	89 d9                	mov    %ebx,%ecx
    e371:	ba 04 00 00 00       	mov    $0x4,%edx
    e376:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    e37b:	4c 89 7c 24 20       	mov    %r15,0x20(%rsp)
    e380:	e8 67 90 ff ff       	callq  73ec <log_n>
    e385:	e9 da 00 00 00       	jmpq   e464 <hci_cmd_done+0x16f>
	if (cmd(buf)->opcode != opcode) {
    e38a:	48 89 ef             	mov    %rbp,%rdi
    e38d:	48 8d 1d 0c 8b 24 00 	lea    0x248b0c(%rip),%rbx        # 256ea0 <cmd_data>
    e394:	e8 bf a9 00 00       	callq  18d58 <net_buf_id>
    e399:	48 98                	cltq   
    e39b:	48 6b c0 18          	imul   $0x18,%rax,%rax
    e39f:	66 44 39 64 03 02    	cmp    %r12w,0x2(%rbx,%rax,1)
    e3a5:	74 40                	je     e3e7 <hci_cmd_done+0xf2>
		BT_WARN("OpCode 0x%04x completed instead of expected 0x%04x",
    e3a7:	48 89 ef             	mov    %rbp,%rdi
    e3aa:	4c 8d 25 1f c0 22 00 	lea    0x22c01f(%rip),%r12        # 23a3d0 <log_const_bt_hci_core>
    e3b1:	4c 2b 25 98 7b 22 00 	sub    0x227b98(%rip),%r12        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
    e3b8:	e8 9b a9 00 00       	callq  18d58 <net_buf_id>
    e3bd:	48 98                	cltq   
    e3bf:	48 8d 3d e6 41 02 00 	lea    0x241e6(%rip),%rdi        # 325ac <__func__.5785+0x1944>
    e3c6:	41 0f b7 f5          	movzwl %r13w,%esi
    e3ca:	48 6b c0 18          	imul   $0x18,%rax,%rax
    e3ce:	49 c1 ec 04          	shr    $0x4,%r12
    e3d2:	41 c1 e4 06          	shl    $0x6,%r12d
    e3d6:	41 83 cc 02          	or     $0x2,%r12d
    e3da:	0f b7 54 03 02       	movzwl 0x2(%rbx,%rax,1),%edx
    e3df:	44 89 e1             	mov    %r12d,%ecx
    e3e2:	e8 4b 8f ff ff       	callq  7332 <log_2>
	if (cmd(buf)->state && !status) {
    e3e7:	48 89 ef             	mov    %rbp,%rdi
    e3ea:	e8 69 a9 00 00       	callq  18d58 <net_buf_id>
    e3ef:	48 98                	cltq   
    e3f1:	48 6b c0 18          	imul   $0x18,%rax,%rax
    e3f5:	48 83 7c 03 08 00    	cmpq   $0x0,0x8(%rbx,%rax,1)
    e3fb:	74 27                	je     e424 <hci_cmd_done+0x12f>
    e3fd:	45 84 f6             	test   %r14b,%r14b
    e400:	75 22                	jne    e424 <hci_cmd_done+0x12f>
		struct bt_hci_cmd_state_set *update = cmd(buf)->state;
    e402:	48 89 ef             	mov    %rbp,%rdi
    e405:	e8 4e a9 00 00       	callq  18d58 <net_buf_id>
    e40a:	48 98                	cltq   
    e40c:	48 6b c0 18          	imul   $0x18,%rax,%rax
    e410:	48 8b 44 03 08       	mov    0x8(%rbx,%rax,1),%rax
		atomic_set_bit_to(update->target, update->bit, update->val);
    e415:	0f b6 50 0c          	movzbl 0xc(%rax),%edx
    e419:	8b 70 08             	mov    0x8(%rax),%esi
    e41c:	48 8b 38             	mov    (%rax),%rdi
    e41f:	e8 b0 fe ff ff       	callq  e2d4 <atomic_set_bit_to>
	if (cmd(buf)->sync) {
    e424:	48 89 ef             	mov    %rbp,%rdi
    e427:	e8 2c a9 00 00       	callq  18d58 <net_buf_id>
    e42c:	48 98                	cltq   
    e42e:	48 6b c0 18          	imul   $0x18,%rax,%rax
    e432:	48 83 7c 03 10 00    	cmpq   $0x0,0x10(%rbx,%rax,1)
    e438:	74 2a                	je     e464 <hci_cmd_done+0x16f>
		cmd(buf)->status = status;
    e43a:	48 89 ef             	mov    %rbp,%rdi
    e43d:	e8 16 a9 00 00       	callq  18d58 <net_buf_id>
    e442:	48 98                	cltq   
		k_sem_give(cmd(buf)->sync);
    e444:	48 89 ef             	mov    %rbp,%rdi
		cmd(buf)->status = status;
    e447:	48 6b c0 18          	imul   $0x18,%rax,%rax
    e44b:	44 88 34 03          	mov    %r14b,(%rbx,%rax,1)
		k_sem_give(cmd(buf)->sync);
    e44f:	e8 04 a9 00 00       	callq  18d58 <net_buf_id>
    e454:	48 98                	cltq   
    e456:	48 6b c0 18          	imul   $0x18,%rax,%rax
    e45a:	48 8b 7c 03 10       	mov    0x10(%rbx,%rax,1),%rdi
    e45f:	e8 d2 da 01 00       	callq  2bf36 <z_impl_k_sem_give>
}
    e464:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    e469:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    e470:	00 00 
    e472:	74 05                	je     e479 <hci_cmd_done+0x184>
    e474:	e8 c7 61 ff ff       	callq  4640 <__stack_chk_fail@plt>
    e479:	48 83 c4 38          	add    $0x38,%rsp
    e47d:	5b                   	pop    %rbx
    e47e:	5d                   	pop    %rbp
    e47f:	41 5c                	pop    %r12
    e481:	41 5d                	pop    %r13
    e483:	41 5e                	pop    %r14
    e485:	41 5f                	pop    %r15
    e487:	c3                   	retq   

000000000000e488 <hci_cmd_status>:
{
    e488:	55                   	push   %rbp
    e489:	53                   	push   %rbx
    e48a:	be 04 00 00 00       	mov    $0x4,%esi
    e48f:	48 89 fb             	mov    %rdi,%rbx
    e492:	48 83 c7 10          	add    $0x10,%rdi
    e496:	48 83 ec 08          	sub    $0x8,%rsp
    e49a:	e8 70 ac 00 00       	callq  1910f <net_buf_simple_pull_mem>
	hci_cmd_done(opcode, evt->status, buf);
    e49f:	0f b6 30             	movzbl (%rax),%esi
    e4a2:	0f b7 78 02          	movzwl 0x2(%rax),%edi
    e4a6:	48 89 da             	mov    %rbx,%rdx
	ncmd = evt->ncmd;
    e4a9:	40 8a 68 01          	mov    0x1(%rax),%bpl
	hci_cmd_done(opcode, evt->status, buf);
    e4ad:	e8 43 fe ff ff       	callq  e2f5 <hci_cmd_done>
	if (ncmd) {
    e4b2:	40 84 ed             	test   %bpl,%bpl
    e4b5:	74 16                	je     e4cd <hci_cmd_status+0x45>
    e4b7:	48 8d 05 82 81 22 00 	lea    0x228182(%rip),%rax        # 236640 <bt_dev>
}
    e4be:	5a                   	pop    %rdx
    e4bf:	5b                   	pop    %rbx
    e4c0:	5d                   	pop    %rbp
    e4c1:	48 8d b8 18 01 00 00 	lea    0x118(%rax),%rdi
    e4c8:	e9 69 da 01 00       	jmpq   2bf36 <z_impl_k_sem_give>
    e4cd:	58                   	pop    %rax
    e4ce:	5b                   	pop    %rbx
    e4cf:	5d                   	pop    %rbp
    e4d0:	c3                   	retq   

000000000000e4d1 <hci_cmd_complete>:
{
    e4d1:	55                   	push   %rbp
    e4d2:	53                   	push   %rbx
    e4d3:	be 03 00 00 00       	mov    $0x3,%esi
    e4d8:	48 89 fb             	mov    %rdi,%rbx
    e4db:	48 83 c7 10          	add    $0x10,%rdi
    e4df:	48 83 ec 08          	sub    $0x8,%rsp
    e4e3:	e8 27 ac 00 00       	callq  1910f <net_buf_simple_pull_mem>
	status = buf->data[0];
    e4e8:	48 8b 53 10          	mov    0x10(%rbx),%rdx
	hci_cmd_done(opcode, status, buf);
    e4ec:	0f b7 78 01          	movzwl 0x1(%rax),%edi
	ncmd = evt->ncmd;
    e4f0:	40 8a 28             	mov    (%rax),%bpl
	hci_cmd_done(opcode, status, buf);
    e4f3:	0f b6 32             	movzbl (%rdx),%esi
    e4f6:	48 89 da             	mov    %rbx,%rdx
    e4f9:	e8 f7 fd ff ff       	callq  e2f5 <hci_cmd_done>
	if (ncmd) {
    e4fe:	40 84 ed             	test   %bpl,%bpl
    e501:	74 16                	je     e519 <hci_cmd_complete+0x48>
    e503:	48 8d 05 36 81 22 00 	lea    0x228136(%rip),%rax        # 236640 <bt_dev>
}
    e50a:	5a                   	pop    %rdx
    e50b:	5b                   	pop    %rbx
    e50c:	5d                   	pop    %rbp
    e50d:	48 8d b8 18 01 00 00 	lea    0x118(%rax),%rdi
    e514:	e9 1d da 01 00       	jmpq   2bf36 <z_impl_k_sem_give>
    e519:	58                   	pop    %rax
    e51a:	5b                   	pop    %rbx
    e51b:	5d                   	pop    %rbp
    e51c:	c3                   	retq   

000000000000e51d <bt_hci_cmd_create>:
{
    e51d:	41 56                	push   %r14
    e51f:	41 55                	push   %r13
    e521:	41 89 f5             	mov    %esi,%r13d
    e524:	41 54                	push   %r12
    e526:	55                   	push   %rbp
    e527:	89 fd                	mov    %edi,%ebp
    e529:	53                   	push   %rbx
	return net_buf_alloc_fixed(pool, timeout);
    e52a:	48 8d 3d bf c2 22 00 	lea    0x22c2bf(%rip),%rdi        # 23a7f0 <hci_cmd_pool>
    e531:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
	cmd(buf)->opcode = opcode;
    e535:	4c 8d 35 64 89 24 00 	lea    0x248964(%rip),%r14        # 256ea0 <cmd_data>
    e53c:	e8 d3 a9 00 00       	callq  18f14 <net_buf_alloc_fixed>
	net_buf_simple_reserve(&buf->b, reserve);
    e541:	4c 8d 60 10          	lea    0x10(%rax),%r12
	return net_buf_alloc_fixed(pool, timeout);
    e545:	48 89 c3             	mov    %rax,%rbx
	net_buf_simple_reserve(&buf->b, reserve);
    e548:	be 01 00 00 00       	mov    $0x1,%esi
    e54d:	4c 89 e7             	mov    %r12,%rdi
    e550:	e8 24 aa 00 00       	callq  18f79 <net_buf_simple_reserve>
    e555:	48 89 df             	mov    %rbx,%rdi
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
    e558:	c6 43 28 00          	movb   $0x0,0x28(%rbx)
    e55c:	e8 f7 a7 00 00       	callq  18d58 <net_buf_id>
    e561:	48 98                	cltq   
	cmd(buf)->sync = NULL;
    e563:	48 89 df             	mov    %rbx,%rdi
	cmd(buf)->opcode = opcode;
    e566:	48 6b c0 18          	imul   $0x18,%rax,%rax
    e56a:	66 41 89 6c 06 02    	mov    %bp,0x2(%r14,%rax,1)
	cmd(buf)->sync = NULL;
    e570:	e8 e3 a7 00 00       	callq  18d58 <net_buf_id>
    e575:	48 98                	cltq   
	cmd(buf)->state = NULL;
    e577:	48 89 df             	mov    %rbx,%rdi
	cmd(buf)->sync = NULL;
    e57a:	48 6b c0 18          	imul   $0x18,%rax,%rax
    e57e:	49 c7 44 06 10 00 00 	movq   $0x0,0x10(%r14,%rax,1)
    e585:	00 00 
	cmd(buf)->state = NULL;
    e587:	e8 cc a7 00 00       	callq  18d58 <net_buf_id>
    e58c:	48 98                	cltq   
	return net_buf_simple_add(&buf->b, len);
    e58e:	4c 89 e7             	mov    %r12,%rdi
    e591:	be 03 00 00 00       	mov    $0x3,%esi
    e596:	48 6b c0 18          	imul   $0x18,%rax,%rax
    e59a:	49 c7 44 06 08 00 00 	movq   $0x0,0x8(%r14,%rax,1)
    e5a1:	00 00 
    e5a3:	e8 e1 aa 00 00       	callq  19089 <net_buf_simple_add>
	hdr->opcode = sys_cpu_to_le16(opcode);
    e5a8:	66 89 28             	mov    %bp,(%rax)
	hdr->param_len = param_len;
    e5ab:	44 88 68 02          	mov    %r13b,0x2(%rax)
}
    e5af:	48 89 d8             	mov    %rbx,%rax
    e5b2:	5b                   	pop    %rbx
    e5b3:	5d                   	pop    %rbp
    e5b4:	41 5c                	pop    %r12
    e5b6:	41 5d                	pop    %r13
    e5b8:	41 5e                	pop    %r14
    e5ba:	c3                   	retq   

000000000000e5bb <bt_hci_cmd_send_sync>:
{
    e5bb:	41 56                	push   %r14
    e5bd:	41 55                	push   %r13
    e5bf:	41 54                	push   %r12
    e5c1:	55                   	push   %rbp
    e5c2:	49 89 d4             	mov    %rdx,%r12
    e5c5:	53                   	push   %rbx
    e5c6:	89 fd                	mov    %edi,%ebp
    e5c8:	48 89 f3             	mov    %rsi,%rbx
    e5cb:	48 83 ec 30          	sub    $0x30,%rsp
    e5cf:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    e5d6:	00 00 
    e5d8:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    e5dd:	31 c0                	xor    %eax,%eax
	if (!buf) {
    e5df:	48 85 f6             	test   %rsi,%rsi
    e5e2:	75 1b                	jne    e5ff <bt_hci_cmd_send_sync+0x44>
		buf = bt_hci_cmd_create(opcode, 0);
    e5e4:	31 f6                	xor    %esi,%esi
    e5e6:	0f b7 ff             	movzwl %di,%edi
    e5e9:	e8 2f ff ff ff       	callq  e51d <bt_hci_cmd_create>
    e5ee:	48 89 c3             	mov    %rax,%rbx
			return -ENOBUFS;
    e5f1:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
		if (!buf) {
    e5f6:	48 85 db             	test   %rbx,%rbx
    e5f9:	0f 84 29 01 00 00    	je     e728 <bt_hci_cmd_send_sync+0x16d>
	return z_impl_k_sem_init(sem, initial_count, limit);
    e5ff:	49 89 e6             	mov    %rsp,%r14
    e602:	ba 01 00 00 00       	mov    $0x1,%edx
    e607:	31 f6                	xor    %esi,%esi
    e609:	4c 89 f7             	mov    %r14,%rdi
	cmd(buf)->sync = &sync_sem;
    e60c:	4c 8d 2d 8d 88 24 00 	lea    0x24888d(%rip),%r13        # 256ea0 <cmd_data>
    e613:	e8 f4 d8 01 00       	callq  2bf0c <z_impl_k_sem_init>
    e618:	48 89 df             	mov    %rbx,%rdi
    e61b:	e8 38 a7 00 00       	callq  18d58 <net_buf_id>
    e620:	48 98                	cltq   
	net_buf_ref(buf);
    e622:	48 89 df             	mov    %rbx,%rdi
	cmd(buf)->sync = &sync_sem;
    e625:	48 6b c0 18          	imul   $0x18,%rax,%rax
    e629:	4d 89 74 05 10       	mov    %r14,0x10(%r13,%rax,1)
	net_buf_ref(buf);
    e62e:	e8 e2 a9 00 00       	callq  19015 <net_buf_ref>
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
    e633:	48 8d 05 06 80 22 00 	lea    0x228006(%rip),%rax        # 236640 <bt_dev>
    e63a:	48 89 de             	mov    %rbx,%rsi
    e63d:	48 8d b8 78 01 00 00 	lea    0x178(%rax),%rdi
    e644:	e8 38 a9 00 00       	callq  18f81 <net_buf_put>
	return z_impl_k_sem_take(sem, timeout);
    e649:	be e8 03 00 00       	mov    $0x3e8,%esi
    e64e:	4c 89 f7             	mov    %r14,%rdi
    e651:	e8 3d d9 01 00       	callq  2bf93 <z_impl_k_sem_take>
	BT_ASSERT_MSG(err == 0, "k_sem_take failed with err %d", err);
    e656:	85 c0                	test   %eax,%eax
    e658:	41 89 c6             	mov    %eax,%r14d
    e65b:	74 58                	je     e6b5 <bt_hci_cmd_send_sync+0xfa>
    e65d:	48 8d 15 e8 3d 02 00 	lea    0x23de8(%rip),%rdx        # 3244c <__func__.5785+0x17e4>
    e664:	48 8d 35 74 3f 02 00 	lea    0x23f74(%rip),%rsi        # 325df <__func__.5785+0x1977>
    e66b:	48 8d 3d 26 3e 02 00 	lea    0x23e26(%rip),%rdi        # 32498 <__func__.5785+0x1830>
    e672:	b9 4d 01 00 00       	mov    $0x14d,%ecx
    e677:	31 c0                	xor    %eax,%eax
    e679:	e8 12 73 ff ff       	callq  5990 <printk>
    e67e:	48 8d 3d 63 3f 02 00 	lea    0x23f63(%rip),%rdi        # 325e8 <__func__.5785+0x1980>
    e685:	44 89 f6             	mov    %r14d,%esi
    e688:	31 c0                	xor    %eax,%eax
    e68a:	e8 01 73 ff ff       	callq  5990 <printk>
    e68f:	48 8d 35 b6 3d 02 00 	lea    0x23db6(%rip),%rsi        # 3244c <__func__.5785+0x17e4>
    e696:	48 8d 3d 0f 3e 02 00 	lea    0x23e0f(%rip),%rdi        # 324ac <__func__.5785+0x1844>
    e69d:	ba 4d 01 00 00       	mov    $0x14d,%edx
    e6a2:	31 c0                	xor    %eax,%eax
    e6a4:	e8 e7 72 ff ff       	callq  5990 <printk>
    e6a9:	31 f6                	xor    %esi,%esi
    e6ab:	bf 03 00 00 00       	mov    $0x3,%edi
    e6b0:	e8 35 c2 01 00       	callq  2a8ea <z_fatal_error>
	status = cmd(buf)->status;
    e6b5:	48 89 df             	mov    %rbx,%rdi
    e6b8:	e8 9b a6 00 00       	callq  18d58 <net_buf_id>
    e6bd:	48 98                	cltq   
    e6bf:	48 6b c0 18          	imul   $0x18,%rax,%rax
    e6c3:	45 8a 6c 05 00       	mov    0x0(%r13,%rax,1),%r13b
	if (status) {
    e6c8:	45 84 ed             	test   %r13b,%r13b
    e6cb:	74 46                	je     e713 <bt_hci_cmd_send_sync+0x158>
    e6cd:	48 8d 0d fc bc 22 00 	lea    0x22bcfc(%rip),%rcx        # 23a3d0 <log_const_bt_hci_core>
    e6d4:	48 2b 0d 75 78 22 00 	sub    0x227875(%rip),%rcx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("opcode 0x%04x status 0x%02x", opcode, status);
    e6db:	48 8d 3d 26 3f 02 00 	lea    0x23f26(%rip),%rdi        # 32608 <__func__.5785+0x19a0>
    e6e2:	41 0f b6 d5          	movzbl %r13b,%edx
    e6e6:	0f b7 f5             	movzwl %bp,%esi
    e6e9:	48 c1 e9 04          	shr    $0x4,%rcx
    e6ed:	c1 e1 06             	shl    $0x6,%ecx
    e6f0:	83 c9 02             	or     $0x2,%ecx
    e6f3:	e8 3a 8c ff ff       	callq  7332 <log_2>
		net_buf_unref(buf);
    e6f8:	48 89 df             	mov    %rbx,%rdi
    e6fb:	e8 9a a8 00 00       	callq  18f9a <net_buf_unref>
			return -EIO;
    e700:	41 80 fd 09          	cmp    $0x9,%r13b
    e704:	b8 91 ff ff ff       	mov    $0xffffff91,%eax
    e709:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
    e70e:	0f 45 c2             	cmovne %edx,%eax
    e711:	eb 15                	jmp    e728 <bt_hci_cmd_send_sync+0x16d>
	if (rsp) {
    e713:	4d 85 e4             	test   %r12,%r12
    e716:	74 06                	je     e71e <bt_hci_cmd_send_sync+0x163>
		*rsp = buf;
    e718:	49 89 1c 24          	mov    %rbx,(%r12)
    e71c:	eb 08                	jmp    e726 <bt_hci_cmd_send_sync+0x16b>
		net_buf_unref(buf);
    e71e:	48 89 df             	mov    %rbx,%rdi
    e721:	e8 74 a8 00 00       	callq  18f9a <net_buf_unref>
	return 0;
    e726:	31 c0                	xor    %eax,%eax
}
    e728:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
    e72d:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
    e734:	00 00 
    e736:	74 05                	je     e73d <bt_hci_cmd_send_sync+0x182>
    e738:	e8 03 5f ff ff       	callq  4640 <__stack_chk_fail@plt>
    e73d:	48 83 c4 30          	add    $0x30,%rsp
    e741:	5b                   	pop    %rbx
    e742:	5d                   	pop    %rbp
    e743:	41 5c                	pop    %r12
    e745:	41 5d                	pop    %r13
    e747:	41 5e                	pop    %r14
    e749:	c3                   	retq   

000000000000e74a <hci_le_read_max_data_len>:
{
    e74a:	41 54                	push   %r12
    e74c:	55                   	push   %rbp
    e74d:	49 89 fc             	mov    %rdi,%r12
    e750:	53                   	push   %rbx
    e751:	48 89 f5             	mov    %rsi,%rbp
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_MAX_DATA_LEN, NULL, &rsp);
    e754:	bf 2f 20 00 00       	mov    $0x202f,%edi
    e759:	31 f6                	xor    %esi,%esi
{
    e75b:	48 83 ec 10          	sub    $0x10,%rsp
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_MAX_DATA_LEN, NULL, &rsp);
    e75f:	48 89 e2             	mov    %rsp,%rdx
{
    e762:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    e769:	00 00 
    e76b:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    e770:	31 c0                	xor    %eax,%eax
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_MAX_DATA_LEN, NULL, &rsp);
    e772:	e8 44 fe ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
	if (err) {
    e777:	85 c0                	test   %eax,%eax
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_MAX_DATA_LEN, NULL, &rsp);
    e779:	89 c3                	mov    %eax,%ebx
	if (err) {
    e77b:	74 26                	je     e7a3 <hci_le_read_max_data_len+0x59>
    e77d:	48 8d 35 4c bc 22 00 	lea    0x22bc4c(%rip),%rsi        # 23a3d0 <log_const_bt_hci_core>
    e784:	48 2b 35 c5 77 22 00 	sub    0x2277c5(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Failed to read DLE max data len");
    e78b:	48 8d 3d 92 3e 02 00 	lea    0x23e92(%rip),%rdi        # 32624 <__func__.5785+0x19bc>
    e792:	48 c1 ee 04          	shr    $0x4,%rsi
    e796:	c1 e6 06             	shl    $0x6,%esi
    e799:	83 ce 01             	or     $0x1,%esi
    e79c:	e8 23 8b ff ff       	callq  72c4 <log_0>
		return err;
    e7a1:	eb 1e                	jmp    e7c1 <hci_le_read_max_data_len+0x77>
	rp = (void *)rsp->data;
    e7a3:	48 8b 3c 24          	mov    (%rsp),%rdi
    e7a7:	48 8b 47 10          	mov    0x10(%rdi),%rax
	*tx_octets = sys_le16_to_cpu(rp->max_tx_octets);
    e7ab:	66 8b 50 01          	mov    0x1(%rax),%dx
    e7af:	66 41 89 14 24       	mov    %dx,(%r12)
	*tx_time = sys_le16_to_cpu(rp->max_tx_time);
    e7b4:	66 8b 40 03          	mov    0x3(%rax),%ax
    e7b8:	66 89 45 00          	mov    %ax,0x0(%rbp)
	net_buf_unref(rsp);
    e7bc:	e8 d9 a7 00 00       	callq  18f9a <net_buf_unref>
}
    e7c1:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    e7c6:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    e7cd:	00 00 
    e7cf:	89 d8                	mov    %ebx,%eax
    e7d1:	74 05                	je     e7d8 <hci_le_read_max_data_len+0x8e>
    e7d3:	e8 68 5e ff ff       	callq  4640 <__stack_chk_fail@plt>
    e7d8:	48 83 c4 10          	add    $0x10,%rsp
    e7dc:	5b                   	pop    %rbx
    e7dd:	5d                   	pop    %rbp
    e7de:	41 5c                	pop    %r12
    e7e0:	c3                   	retq   

000000000000e7e1 <hci_set_ad>:
{
    e7e1:	41 57                	push   %r15
    e7e3:	41 56                	push   %r14
    e7e5:	41 55                	push   %r13
    e7e7:	41 54                	push   %r12
    e7e9:	49 89 f5             	mov    %rsi,%r13
    e7ec:	55                   	push   %rbp
    e7ed:	53                   	push   %rbx
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
    e7ee:	0f b7 ef             	movzwl %di,%ebp
    e7f1:	be 20 00 00 00       	mov    $0x20,%esi
    e7f6:	89 ef                	mov    %ebp,%edi
{
    e7f8:	49 89 d4             	mov    %rdx,%r12
    e7fb:	48 83 ec 08          	sub    $0x8,%rsp
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
    e7ff:	e8 19 fd ff ff       	callq  e51d <bt_hci_cmd_create>
	if (!buf) {
    e804:	48 85 c0             	test   %rax,%rax
    e807:	0f 84 07 01 00 00    	je     e914 <hci_set_ad+0x133>
    e80d:	48 8d 78 10          	lea    0x10(%rax),%rdi
    e811:	be 20 00 00 00       	mov    $0x20,%esi
    e816:	48 89 c3             	mov    %rax,%rbx
    e819:	49 c1 e4 04          	shl    $0x4,%r12
				ssize_t shortened_len = set_data_len_max -
    e81d:	41 bf 1f 00 00 00    	mov    $0x1f,%r15d
    e823:	e8 61 a8 00 00       	callq  19089 <net_buf_simple_add>
    e828:	49 89 c2             	mov    %rax,%r10
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    e82b:	b9 08 00 00 00       	mov    $0x8,%ecx
    e830:	31 c0                	xor    %eax,%eax
    e832:	4c 89 d7             	mov    %r10,%rdi
	err = set_data_add(set_data->data, BT_GAP_ADV_MAX_ADV_DATA_LEN,
    e835:	4d 8d 5a 01          	lea    0x1(%r10),%r11
    e839:	4d 8d 45 08          	lea    0x8(%r13),%r8
    e83d:	f3 ab                	rep stos %eax,%es:(%rdi)
    e83f:	4f 8d 74 25 08       	lea    0x8(%r13,%r12,1),%r14
    e844:	4d 8b 48 f8          	mov    -0x8(%r8),%r9
		for (size_t j = 0; j < ad[i].len; j++) {
    e848:	45 31 e4             	xor    %r12d,%r12d
    e84b:	4d 3b 20             	cmp    (%r8),%r12
    e84e:	0f 83 99 00 00 00    	jae    e8ed <hci_set_ad+0x10c>
			size_t len = data[j].data_len;
    e854:	41 0f b6 51 01       	movzbl 0x1(%r9),%edx
			if ((set_data_len + len + 2) > set_data_len_max) {
    e859:	0f b6 f0             	movzbl %al,%esi
			uint8_t type = data[j].type;
    e85c:	41 8a 09             	mov    (%r9),%cl
			if ((set_data_len + len + 2) > set_data_len_max) {
    e85f:	48 8d 7c 32 02       	lea    0x2(%rdx,%rsi,1),%rdi
    e864:	48 83 ff 1f          	cmp    $0x1f,%rdi
    e868:	76 4c                	jbe    e8b6 <hci_set_ad+0xd5>
							(set_data_len + 2);
    e86a:	0f b6 d0             	movzbl %al,%edx
				ssize_t shortened_len = set_data_len_max -
    e86d:	44 89 ff             	mov    %r15d,%edi
							(set_data_len + 2);
    e870:	83 c2 02             	add    $0x2,%edx
				ssize_t shortened_len = set_data_len_max -
    e873:	29 d7                	sub    %edx,%edi
				if (!(type == BT_DATA_NAME_COMPLETE &&
    e875:	80 f9 09             	cmp    $0x9,%cl
				ssize_t shortened_len = set_data_len_max -
    e878:	48 63 d7             	movslq %edi,%rdx
				if (!(type == BT_DATA_NAME_COMPLETE &&
    e87b:	75 04                	jne    e881 <hci_set_ad+0xa0>
    e87d:	85 d2                	test   %edx,%edx
    e87f:	7f 33                	jg     e8b4 <hci_set_ad+0xd3>
    e881:	48 8d 35 48 bb 22 00 	lea    0x22bb48(%rip),%rsi        # 23a3d0 <log_const_bt_hci_core>
    e888:	48 2b 35 c1 76 22 00 	sub    0x2276c1(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
					BT_ERR("Too big advertising data");
    e88f:	48 8d 3d ae 3d 02 00 	lea    0x23dae(%rip),%rdi        # 32644 <__func__.5785+0x19dc>
    e896:	48 c1 ee 04          	shr    $0x4,%rsi
    e89a:	c1 e6 06             	shl    $0x6,%esi
    e89d:	83 ce 01             	or     $0x1,%esi
    e8a0:	e8 1f 8a ff ff       	callq  72c4 <log_0>
		net_buf_unref(buf);
    e8a5:	48 89 df             	mov    %rbx,%rdi
    e8a8:	e8 ed a6 00 00       	callq  18f9a <net_buf_unref>
					return -EINVAL;
    e8ad:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		return err;
    e8b2:	eb 65                	jmp    e919 <hci_set_ad+0x138>
				type = BT_DATA_NAME_SHORTENED;
    e8b4:	b1 08                	mov    $0x8,%cl
			set_data[set_data_len++] = type;
    e8b6:	44 8d 68 02          	lea    0x2(%rax),%r13d
			set_data[set_data_len++] = len + 1;
    e8ba:	8d 7a 01             	lea    0x1(%rdx),%edi
    e8bd:	ff c0                	inc    %eax
			set_data[set_data_len++] = type;
    e8bf:	0f b6 c0             	movzbl %al,%eax
		for (size_t j = 0; j < ad[i].len; j++) {
    e8c2:	49 ff c4             	inc    %r12
    e8c5:	49 83 c1 10          	add    $0x10,%r9
			set_data[set_data_len++] = len + 1;
    e8c9:	41 88 3c 33          	mov    %dil,(%r11,%rsi,1)
			set_data[set_data_len++] = type;
    e8cd:	41 88 0c 03          	mov    %cl,(%r11,%rax,1)
			memcpy(&set_data[set_data_len], data[j].data, len);
    e8d1:	41 0f b6 c5          	movzbl %r13b,%eax
    e8d5:	4c 01 d8             	add    %r11,%rax
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    e8d8:	49 8b 71 f8          	mov    -0x8(%r9),%rsi
    e8dc:	89 d1                	mov    %edx,%ecx
    e8de:	48 89 c7             	mov    %rax,%rdi
			set_data_len += len;
    e8e1:	41 8d 44 15 00       	lea    0x0(%r13,%rdx,1),%eax
    e8e6:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
    e8e8:	e9 5e ff ff ff       	jmpq   e84b <hci_set_ad+0x6a>
    e8ed:	49 83 c0 10          	add    $0x10,%r8
	for (size_t i = 0; i < ad_len; i++) {
    e8f1:	4d 39 c6             	cmp    %r8,%r14
    e8f4:	0f 85 4a ff ff ff    	jne    e844 <hci_set_ad+0x63>
	*data_len = set_data_len;
    e8fa:	41 88 02             	mov    %al,(%r10)
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
    e8fd:	48 89 de             	mov    %rbx,%rsi
    e900:	89 ef                	mov    %ebp,%edi
}
    e902:	59                   	pop    %rcx
    e903:	5b                   	pop    %rbx
    e904:	5d                   	pop    %rbp
    e905:	41 5c                	pop    %r12
    e907:	41 5d                	pop    %r13
    e909:	41 5e                	pop    %r14
    e90b:	41 5f                	pop    %r15
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
    e90d:	31 d2                	xor    %edx,%edx
    e90f:	e9 a7 fc ff ff       	jmpq   e5bb <bt_hci_cmd_send_sync>
		return -ENOBUFS;
    e914:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
}
    e919:	5a                   	pop    %rdx
    e91a:	5b                   	pop    %rbx
    e91b:	5d                   	pop    %rbp
    e91c:	41 5c                	pop    %r12
    e91e:	41 5d                	pop    %r13
    e920:	41 5e                	pop    %r14
    e922:	41 5f                	pop    %r15
    e924:	c3                   	retq   

000000000000e925 <set_random_address>:
{
    e925:	41 54                	push   %r12
    e927:	55                   	push   %rbp
	return memcmp(a, b, sizeof(*a));
    e928:	ba 06 00 00 00       	mov    $0x6,%edx
    e92d:	53                   	push   %rbx
    e92e:	48 89 fd             	mov    %rdi,%rbp
    e931:	48 83 ec 10          	sub    $0x10,%rsp
    e935:	48 8d 1d 04 7d 22 00 	lea    0x227d04(%rip),%rbx        # 236640 <bt_dev>
    e93c:	48 8d 73 2d          	lea    0x2d(%rbx),%rsi
    e940:	e8 fb 5a ff ff       	callq  4440 <memcmp@plt>
	if (!bt_addr_cmp(addr, &bt_dev.random_addr.a)) {
    e945:	85 c0                	test   %eax,%eax
    e947:	74 59                	je     e9a2 <set_random_address+0x7d>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, sizeof(*addr));
    e949:	be 06 00 00 00       	mov    $0x6,%esi
    e94e:	bf 05 20 00 00       	mov    $0x2005,%edi
    e953:	e8 c5 fb ff ff       	callq  e51d <bt_hci_cmd_create>
    e958:	49 89 c4             	mov    %rax,%r12
		return -ENOBUFS;
    e95b:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
	if (!buf) {
    e960:	4d 85 e4             	test   %r12,%r12
    e963:	74 3d                	je     e9a2 <set_random_address+0x7d>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    e965:	49 8d 7c 24 10       	lea    0x10(%r12),%rdi
    e96a:	ba 06 00 00 00       	mov    $0x6,%edx
    e96f:	48 89 ee             	mov    %rbp,%rsi
    e972:	e8 23 a7 00 00       	callq  1909a <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, buf, NULL);
    e977:	31 d2                	xor    %edx,%edx
    e979:	4c 89 e6             	mov    %r12,%rsi
    e97c:	bf 05 20 00 00       	mov    $0x2005,%edi
    e981:	e8 35 fc ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
	if (err) {
    e986:	85 c0                	test   %eax,%eax
    e988:	75 18                	jne    e9a2 <set_random_address+0x7d>
	bt_addr_copy(&bt_dev.random_addr.a, addr);
    e98a:	48 8d 7b 2d          	lea    0x2d(%rbx),%rdi
    e98e:	48 89 ee             	mov    %rbp,%rsi
    e991:	89 44 24 0c          	mov    %eax,0xc(%rsp)
    e995:	e8 16 ee ff ff       	callq  d7b0 <bt_addr_copy>
	bt_dev.random_addr.type = BT_ADDR_LE_RANDOM;
    e99a:	8b 44 24 0c          	mov    0xc(%rsp),%eax
    e99e:	c6 43 2c 01          	movb   $0x1,0x2c(%rbx)
}
    e9a2:	48 83 c4 10          	add    $0x10,%rsp
    e9a6:	5b                   	pop    %rbx
    e9a7:	5d                   	pop    %rbp
    e9a8:	41 5c                	pop    %r12
    e9aa:	c3                   	retq   

000000000000e9ab <le_adv_set_random_addr>:
{
    e9ab:	41 56                	push   %r14
    e9ad:	41 55                	push   %r13
    e9af:	41 54                	push   %r12
    e9b1:	55                   	push   %rbp
    e9b2:	41 89 f4             	mov    %esi,%r12d
    e9b5:	53                   	push   %rbx
    e9b6:	48 89 cd             	mov    %rcx,%rbp
    e9b9:	48 83 ec 10          	sub    $0x10,%rsp
	id_addr = &bt_dev.id_addr[adv->id];
    e9bd:	0f b6 1f             	movzbl (%rdi),%ebx
{
    e9c0:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    e9c7:	00 00 
    e9c9:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    e9ce:	31 c0                	xor    %eax,%eax
	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
    e9d0:	40 80 e6 01          	and    $0x1,%sil
	id_addr = &bt_dev.id_addr[adv->id];
    e9d4:	48 89 d9             	mov    %rbx,%rcx
	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
    e9d7:	74 6a                	je     ea43 <le_adv_set_random_addr+0x98>
		if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA) &&
    e9d9:	84 d2                	test   %dl,%dl
    e9db:	41 89 d6             	mov    %edx,%r14d
    e9de:	4c 8d 2d 5b 7c 22 00 	lea    0x227c5b(%rip),%r13        # 236640 <bt_dev>
    e9e5:	74 19                	je     ea00 <le_adv_set_random_addr+0x55>
    e9e7:	41 f6 c4 20          	test   $0x20,%r12b
    e9eb:	74 13                	je     ea00 <le_adv_set_random_addr+0x55>
    e9ed:	41 f6 85 a8 00 00 00 	testb  $0x40,0xa8(%r13)
    e9f4:	40 
			return -ENOTSUP;
    e9f5:	b8 a1 ff ff ff       	mov    $0xffffffa1,%eax
		if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA) &&
    e9fa:	0f 84 a2 00 00 00    	je     eaa2 <le_adv_set_random_addr+0xf7>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    ea00:	48 63 db             	movslq %ebx,%rbx
    ea03:	48 6b c3 07          	imul   $0x7,%rbx,%rax
    ea07:	41 80 7c 05 00 01    	cmpb   $0x1,0x0(%r13,%rax,1)
    ea0d:	74 10                	je     ea1f <le_adv_set_random_addr+0x74>
			*own_addr_type = id_addr->type;
    ea0f:	48 6b db 07          	imul   $0x7,%rbx,%rbx
			if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA)) {
    ea13:	45 84 f6             	test   %r14b,%r14b
			*own_addr_type = id_addr->type;
    ea16:	41 8a 44 1d 00       	mov    0x0(%r13,%rbx,1),%al
			if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA)) {
    ea1b:	75 16                	jne    ea33 <le_adv_set_random_addr+0x88>
    ea1d:	eb 1d                	jmp    ea3c <le_adv_set_random_addr+0x91>
				err = set_adv_random_address(adv, &id_addr->a);
    ea1f:	48 6b c9 07          	imul   $0x7,%rcx,%rcx
    ea23:	49 8d 7c 0d 01       	lea    0x1(%r13,%rcx,1),%rdi
		return set_random_address(addr);
    ea28:	e8 f8 fe ff ff       	callq  e925 <set_random_address>
				if (err) {
    ea2d:	85 c0                	test   %eax,%eax
    ea2f:	74 de                	je     ea0f <le_adv_set_random_addr+0x64>
    ea31:	eb 6f                	jmp    eaa2 <le_adv_set_random_addr+0xf7>
			if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA)) {
    ea33:	41 80 e4 20          	and    $0x20,%r12b
    ea37:	74 03                	je     ea3c <le_adv_set_random_addr+0x91>
				*own_addr_type |= BT_HCI_OWN_ADDR_RPA_MASK;
    ea39:	83 c8 02             	or     $0x2,%eax
    ea3c:	88 45 00             	mov    %al,0x0(%rbp)
	return 0;
    ea3f:	31 c0                	xor    %eax,%eax
    ea41:	eb 5f                	jmp    eaa2 <le_adv_set_random_addr+0xf7>
		if (options & BT_LE_ADV_OPT_USE_IDENTITY) {
    ea43:	41 80 e4 04          	and    $0x4,%r12b
    ea47:	74 32                	je     ea7b <le_adv_set_random_addr+0xd0>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    ea49:	48 63 db             	movslq %ebx,%rbx
    ea4c:	4c 8d 25 ed 7b 22 00 	lea    0x227bed(%rip),%r12        # 236640 <bt_dev>
	int err = 0;
    ea53:	31 c0                	xor    %eax,%eax
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    ea55:	48 6b d3 07          	imul   $0x7,%rbx,%rdx
    ea59:	41 80 3c 14 01       	cmpb   $0x1,(%r12,%rdx,1)
    ea5e:	75 0e                	jne    ea6e <le_adv_set_random_addr+0xc3>
				err = set_adv_random_address(adv, &id_addr->a);
    ea60:	48 6b c9 07          	imul   $0x7,%rcx,%rcx
    ea64:	49 8d 7c 0c 01       	lea    0x1(%r12,%rcx,1),%rdi
		return set_random_address(addr);
    ea69:	e8 b7 fe ff ff       	callq  e925 <set_random_address>
			*own_addr_type = id_addr->type;
    ea6e:	48 6b db 07          	imul   $0x7,%rbx,%rbx
    ea72:	41 8a 14 1c          	mov    (%r12,%rbx,1),%dl
    ea76:	88 55 00             	mov    %dl,0x0(%rbp)
    ea79:	eb 27                	jmp    eaa2 <le_adv_set_random_addr+0xf7>
	err = bt_rand(nrpa.val, sizeof(nrpa.val));
    ea7b:	48 8d 5c 24 02       	lea    0x2(%rsp),%rbx
    ea80:	be 06 00 00 00       	mov    $0x6,%esi
    ea85:	48 89 df             	mov    %rbx,%rdi
    ea88:	e8 6c 23 00 00       	callq  10df9 <bt_rand>
	if (err) {
    ea8d:	85 c0                	test   %eax,%eax
    ea8f:	75 0d                	jne    ea9e <le_adv_set_random_addr+0xf3>
		return set_random_address(addr);
    ea91:	48 89 df             	mov    %rbx,%rdi
	BT_ADDR_SET_NRPA(&nrpa);
    ea94:	80 64 24 07 3f       	andb   $0x3f,0x7(%rsp)
		return set_random_address(addr);
    ea99:	e8 87 fe ff ff       	callq  e925 <set_random_address>
			*own_addr_type = BT_ADDR_LE_RANDOM;
    ea9e:	c6 45 00 01          	movb   $0x1,0x0(%rbp)
}
    eaa2:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    eaa7:	64 48 33 34 25 28 00 	xor    %fs:0x28,%rsi
    eaae:	00 00 
    eab0:	74 05                	je     eab7 <le_adv_set_random_addr+0x10c>
    eab2:	e8 89 5b ff ff       	callq  4640 <__stack_chk_fail@plt>
    eab7:	48 83 c4 10          	add    $0x10,%rsp
    eabb:	5b                   	pop    %rbx
    eabc:	5d                   	pop    %rbp
    eabd:	41 5c                	pop    %r12
    eabf:	41 5d                	pop    %r13
    eac1:	41 5e                	pop    %r14
    eac3:	c3                   	retq   

000000000000eac4 <set_le_adv_enable_legacy>:
{
    eac4:	41 54                	push   %r12
    eac6:	55                   	push   %rbp
    eac7:	41 89 f4             	mov    %esi,%r12d
    eaca:	53                   	push   %rbx
    eacb:	48 89 fd             	mov    %rdi,%rbp
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
    eace:	be 01 00 00 00       	mov    $0x1,%esi
    ead3:	bf 0a 20 00 00       	mov    $0x200a,%edi
{
    ead8:	48 83 ec 20          	sub    $0x20,%rsp
    eadc:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    eae3:	00 00 
    eae5:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    eaea:	31 c0                	xor    %eax,%eax
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
    eaec:	e8 2c fa ff ff       	callq  e51d <bt_hci_cmd_create>
    eaf1:	48 89 c3             	mov    %rax,%rbx
    eaf4:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
	if (!buf) {
    eaf9:	48 85 db             	test   %rbx,%rbx
    eafc:	74 58                	je     eb56 <set_le_adv_enable_legacy+0x92>
	if (enable) {
    eafe:	45 84 e4             	test   %r12b,%r12b
		net_buf_add_u8(buf, BT_HCI_LE_ADV_ENABLE);
    eb01:	be 01 00 00 00       	mov    $0x1,%esi
	if (enable) {
    eb06:	75 02                	jne    eb0a <set_le_adv_enable_legacy+0x46>
		net_buf_add_u8(buf, BT_HCI_LE_ADV_DISABLE);
    eb08:	31 f6                	xor    %esi,%esi
    eb0a:	48 89 df             	mov    %rbx,%rdi
	bt_hci_cmd_state_set_init(&state, adv->flags, BT_ADV_ENABLED, enable);
    eb0d:	48 83 c5 10          	add    $0x10,%rbp
		net_buf_add_u8(buf, BT_HCI_LE_ADV_DISABLE);
    eb11:	e8 af ec ff ff       	callq  d7c5 <net_buf_add_u8>
	cmd(buf)->state = &state;
    eb16:	48 89 df             	mov    %rbx,%rdi
	bt_hci_cmd_state_set_init(&state, adv->flags, BT_ADV_ENABLED, enable);
    eb19:	48 89 6c 24 08       	mov    %rbp,0x8(%rsp)
static inline void bt_hci_cmd_state_set_init(struct bt_hci_cmd_state_set *state,
					     atomic_t *target, int bit,
					     bool val)
{
	state->target = target;
	state->bit = bit;
    eb1e:	c7 44 24 10 06 00 00 	movl   $0x6,0x10(%rsp)
    eb25:	00 
	state->val = val;
    eb26:	44 88 64 24 14       	mov    %r12b,0x14(%rsp)
	cmd(buf)->state = &state;
    eb2b:	e8 28 a2 00 00       	callq  18d58 <net_buf_id>
    eb30:	48 98                	cltq   
    eb32:	48 8d 15 67 83 24 00 	lea    0x248367(%rip),%rdx        # 256ea0 <cmd_data>
    eb39:	48 8d 4c 24 08       	lea    0x8(%rsp),%rcx
    eb3e:	48 6b c0 18          	imul   $0x18,%rax,%rax
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_ENABLE, buf, NULL);
    eb42:	48 89 de             	mov    %rbx,%rsi
    eb45:	bf 0a 20 00 00       	mov    $0x200a,%edi
	cmd(buf)->state = &state;
    eb4a:	48 89 4c 02 08       	mov    %rcx,0x8(%rdx,%rax,1)
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_ENABLE, buf, NULL);
    eb4f:	31 d2                	xor    %edx,%edx
    eb51:	e8 65 fa ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
}
    eb56:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    eb5b:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    eb62:	00 00 
    eb64:	74 05                	je     eb6b <set_le_adv_enable_legacy+0xa7>
    eb66:	e8 d5 5a ff ff       	callq  4640 <__stack_chk_fail@plt>
    eb6b:	48 83 c4 20          	add    $0x20,%rsp
    eb6f:	5b                   	pop    %rbx
    eb70:	5d                   	pop    %rbp
    eb71:	41 5c                	pop    %r12
    eb73:	c3                   	retq   

000000000000eb74 <bt_lookup_id_addr>:
{
    eb74:	48 89 f0             	mov    %rsi,%rax
}
    eb77:	c3                   	retq   

000000000000eb78 <bt_adv_lookup_legacy>:
	return &bt_dev.adv;
    eb78:	48 8d 05 c1 7a 22 00 	lea    0x227ac1(%rip),%rax        # 236640 <bt_dev>
}
    eb7f:	48 83 c0 18          	add    $0x18,%rax
    eb83:	c3                   	retq   

000000000000eb84 <bt_hci_disconnect>:
{
    eb84:	41 54                	push   %r12
    eb86:	55                   	push   %rbp
    eb87:	41 89 fc             	mov    %edi,%r12d
    eb8a:	53                   	push   %rbx
    eb8b:	89 f5                	mov    %esi,%ebp
	buf = bt_hci_cmd_create(BT_HCI_OP_DISCONNECT, sizeof(*disconn));
    eb8d:	bf 06 04 00 00       	mov    $0x406,%edi
    eb92:	be 03 00 00 00       	mov    $0x3,%esi
    eb97:	e8 81 f9 ff ff       	callq  e51d <bt_hci_cmd_create>
	if (!buf) {
    eb9c:	48 85 c0             	test   %rax,%rax
    eb9f:	74 2c                	je     ebcd <bt_hci_disconnect+0x49>
	return net_buf_simple_add(&buf->b, len);
    eba1:	48 8d 78 10          	lea    0x10(%rax),%rdi
    eba5:	48 89 c3             	mov    %rax,%rbx
    eba8:	be 03 00 00 00       	mov    $0x3,%esi
    ebad:	e8 d7 a4 00 00       	callq  19089 <net_buf_simple_add>
	return bt_hci_cmd_send_sync(BT_HCI_OP_DISCONNECT, buf, NULL);
    ebb2:	48 89 de             	mov    %rbx,%rsi
	disconn->handle = sys_cpu_to_le16(handle);
    ebb5:	66 44 89 20          	mov    %r12w,(%rax)
	disconn->reason = reason;
    ebb9:	40 88 68 02          	mov    %bpl,0x2(%rax)
}
    ebbd:	5b                   	pop    %rbx
    ebbe:	5d                   	pop    %rbp
    ebbf:	41 5c                	pop    %r12
	return bt_hci_cmd_send_sync(BT_HCI_OP_DISCONNECT, buf, NULL);
    ebc1:	31 d2                	xor    %edx,%edx
    ebc3:	bf 06 04 00 00       	mov    $0x406,%edi
    ebc8:	e9 ee f9 ff ff       	jmpq   e5bb <bt_hci_cmd_send_sync>
}
    ebcd:	5b                   	pop    %rbx
    ebce:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
    ebd3:	5d                   	pop    %rbp
    ebd4:	41 5c                	pop    %r12
    ebd6:	c3                   	retq   

000000000000ebd7 <bt_le_conn_params_valid>:
	if (param->interval_min > param->interval_max ||
    ebd7:	0f b7 77 02          	movzwl 0x2(%rdi),%esi
    ebdb:	66 8b 17             	mov    (%rdi),%dx
    ebde:	66 39 f2             	cmp    %si,%dx
    ebe1:	0f 97 c0             	seta   %al
    ebe4:	66 83 fa 05          	cmp    $0x5,%dx
    ebe8:	0f 96 c2             	setbe  %dl
    ebeb:	09 d0                	or     %edx,%eax
	    param->interval_min < 6 || param->interval_max > 3200) {
    ebed:	66 81 fe 80 0c       	cmp    $0xc80,%si
    ebf2:	0f 97 c2             	seta   %dl
    ebf5:	08 d0                	or     %dl,%al
    ebf7:	75 27                	jne    ec20 <bt_le_conn_params_valid+0x49>
	if (param->latency > 499) {
    ebf9:	0f b7 57 04          	movzwl 0x4(%rdi),%edx
    ebfd:	66 81 fa f3 01       	cmp    $0x1f3,%dx
    ec02:	77 1e                	ja     ec22 <bt_le_conn_params_valid+0x4b>
	if (param->timeout < 10 || param->timeout > 3200 ||
    ec04:	0f b7 4f 06          	movzwl 0x6(%rdi),%ecx
    ec08:	8d 79 f6             	lea    -0xa(%rcx),%edi
    ec0b:	66 81 ff 76 0c       	cmp    $0xc76,%di
    ec10:	77 10                	ja     ec22 <bt_le_conn_params_valid+0x4b>
	     ((1U + param->latency) * param->interval_max))) {
    ec12:	ff c2                	inc    %edx
	    ((param->timeout * 4U) <=
    ec14:	c1 e1 02             	shl    $0x2,%ecx
	     ((1U + param->latency) * param->interval_max))) {
    ec17:	0f af d6             	imul   %esi,%edx
	if (param->timeout < 10 || param->timeout > 3200 ||
    ec1a:	39 d1                	cmp    %edx,%ecx
    ec1c:	0f 97 c0             	seta   %al
    ec1f:	c3                   	retq   
		return false;
    ec20:	31 c0                	xor    %eax,%eax
}
    ec22:	c3                   	retq   

000000000000ec23 <bt_send>:
	return bt_dev.drv->send(buf);
    ec23:	48 8d 05 16 7a 22 00 	lea    0x227a16(%rip),%rax        # 236640 <bt_dev>
    ec2a:	48 8b 80 a8 01 00 00 	mov    0x1a8(%rax),%rax
    ec31:	ff 60 18             	jmpq   *0x18(%rax)

000000000000ec34 <bt_hci_cmd_send>:
{
    ec34:	55                   	push   %rbp
    ec35:	53                   	push   %rbx
    ec36:	89 fd                	mov    %edi,%ebp
    ec38:	48 89 f3             	mov    %rsi,%rbx
    ec3b:	48 83 ec 18          	sub    $0x18,%rsp
	if (!buf) {
    ec3f:	48 85 f6             	test   %rsi,%rsi
    ec42:	75 17                	jne    ec5b <bt_hci_cmd_send+0x27>
		buf = bt_hci_cmd_create(opcode, 0);
    ec44:	31 f6                	xor    %esi,%esi
    ec46:	0f b7 ff             	movzwl %di,%edi
    ec49:	e8 cf f8 ff ff       	callq  e51d <bt_hci_cmd_create>
    ec4e:	48 89 c3             	mov    %rax,%rbx
			return -ENOBUFS;
    ec51:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
		if (!buf) {
    ec56:	48 85 db             	test   %rbx,%rbx
    ec59:	74 64                	je     ecbf <bt_hci_cmd_send+0x8b>
	if (opcode == BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS) {
    ec5b:	66 81 fd 35 0c       	cmp    $0xc35,%bp
    ec60:	75 45                	jne    eca7 <bt_hci_cmd_send+0x73>
		err = bt_send(buf);
    ec62:	48 89 df             	mov    %rbx,%rdi
    ec65:	e8 b9 ff ff ff       	callq  ec23 <bt_send>
		if (err) {
    ec6a:	85 c0                	test   %eax,%eax
    ec6c:	74 51                	je     ecbf <bt_hci_cmd_send+0x8b>
    ec6e:	48 8d 15 5b b7 22 00 	lea    0x22b75b(%rip),%rdx        # 23a3d0 <log_const_bt_hci_core>
    ec75:	48 2b 15 d4 72 22 00 	sub    0x2272d4(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Unable to send to driver (err %d)", err);
    ec7c:	48 8d 3d da 39 02 00 	lea    0x239da(%rip),%rdi        # 3265d <__func__.5785+0x19f5>
    ec83:	48 63 f0             	movslq %eax,%rsi
    ec86:	89 44 24 0c          	mov    %eax,0xc(%rsp)
    ec8a:	48 c1 ea 04          	shr    $0x4,%rdx
    ec8e:	c1 e2 06             	shl    $0x6,%edx
    ec91:	83 ca 01             	or     $0x1,%edx
    ec94:	e8 5c 86 ff ff       	callq  72f5 <log_1>
			net_buf_unref(buf);
    ec99:	48 89 df             	mov    %rbx,%rdi
    ec9c:	e8 f9 a2 00 00       	callq  18f9a <net_buf_unref>
    eca1:	8b 44 24 0c          	mov    0xc(%rsp),%eax
    eca5:	eb 18                	jmp    ecbf <bt_hci_cmd_send+0x8b>
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
    eca7:	48 8d 05 92 79 22 00 	lea    0x227992(%rip),%rax        # 236640 <bt_dev>
    ecae:	48 89 de             	mov    %rbx,%rsi
    ecb1:	48 8d b8 78 01 00 00 	lea    0x178(%rax),%rdi
    ecb8:	e8 c4 a2 00 00       	callq  18f81 <net_buf_put>
	return 0;
    ecbd:	31 c0                	xor    %eax,%eax
}
    ecbf:	48 83 c4 18          	add    $0x18,%rsp
    ecc3:	5b                   	pop    %rbx
    ecc4:	5d                   	pop    %rbp
    ecc5:	c3                   	retq   

000000000000ecc6 <bt_hci_host_num_completed_packets>:
{
    ecc6:	41 54                	push   %r12
    ecc8:	55                   	push   %rbp
    ecc9:	53                   	push   %rbx
    ecca:	48 89 fb             	mov    %rdi,%rbx
	uint16_t handle = acl(buf)->handle;
    eccd:	66 44 8b 67 2a       	mov    0x2a(%rdi),%r12w
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    ecd2:	0f b6 7f 0a          	movzbl 0xa(%rdi),%edi
    ecd6:	e8 1e a0 00 00       	callq  18cf9 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
    ecdb:	48 89 de             	mov    %rbx,%rsi
    ecde:	48 89 c7             	mov    %rax,%rdi
    ece1:	e8 57 c6 01 00       	callq  2b33d <k_queue_prepend>
	if (!BT_CMD_TEST(bt_dev.supported_commands, 10, 5)) {
    ece6:	48 8d 05 53 79 22 00 	lea    0x227953(%rip),%rax        # 236640 <bt_dev>
    eced:	f6 40 4e 20          	testb  $0x20,0x4e(%rax)
    ecf1:	0f 84 07 01 00 00    	je     edfe <bt_hci_host_num_completed_packets+0x138>
	conn = bt_conn_lookup_index(acl(buf)->index);
    ecf7:	0f b6 7b 29          	movzbl 0x29(%rbx),%edi
    ecfb:	e8 bb 32 00 00       	callq  11fbb <bt_conn_lookup_index>
	if (!conn) {
    ed00:	48 85 c0             	test   %rax,%rax
	conn = bt_conn_lookup_index(acl(buf)->index);
    ed03:	48 89 c5             	mov    %rax,%rbp
	if (!conn) {
    ed06:	75 2c                	jne    ed34 <bt_hci_host_num_completed_packets+0x6e>
    ed08:	48 8d 15 c1 b6 22 00 	lea    0x22b6c1(%rip),%rdx        # 23a3d0 <log_const_bt_hci_core>
    ed0f:	48 2b 15 3a 72 22 00 	sub    0x22723a(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("Unable to look up conn with index 0x%02x",
    ed16:	48 8d 3d 62 39 02 00 	lea    0x23962(%rip),%rdi        # 3267f <__func__.5785+0x1a17>
    ed1d:	0f b6 73 29          	movzbl 0x29(%rbx),%esi
}
    ed21:	5b                   	pop    %rbx
    ed22:	5d                   	pop    %rbp
    ed23:	41 5c                	pop    %r12
    ed25:	48 c1 ea 04          	shr    $0x4,%rdx
		BT_WARN("Unable to look up conn with index 0x%02x",
    ed29:	c1 e2 06             	shl    $0x6,%edx
    ed2c:	83 ca 02             	or     $0x2,%edx
    ed2f:	e9 c1 85 ff ff       	jmpq   72f5 <log_1>
	if (!bt_conn_is_handle_valid(conn)) {
    ed34:	8a 48 0a             	mov    0xa(%rax),%cl
    ed37:	80 f9 08             	cmp    $0x8,%cl
    ed3a:	77 56                	ja     ed92 <bt_hci_host_num_completed_packets+0xcc>
    ed3c:	b8 01 00 00 00       	mov    $0x1,%eax
    ed41:	48 d3 e0             	shl    %cl,%rax
    ed44:	a9 82 01 00 00       	test   $0x182,%eax
    ed49:	74 47                	je     ed92 <bt_hci_host_num_completed_packets+0xcc>
	bt_conn_unref(conn);
    ed4b:	48 89 ef             	mov    %rbp,%rdi
    ed4e:	e8 11 2a 00 00       	callq  11764 <bt_conn_unref>
	buf = bt_hci_cmd_create(BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS,
    ed53:	be 05 00 00 00       	mov    $0x5,%esi
    ed58:	bf 35 0c 00 00       	mov    $0xc35,%edi
    ed5d:	e8 bb f7 ff ff       	callq  e51d <bt_hci_cmd_create>
	if (!buf) {
    ed62:	48 85 c0             	test   %rax,%rax
	buf = bt_hci_cmd_create(BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS,
    ed65:	48 89 c3             	mov    %rax,%rbx
	if (!buf) {
    ed68:	75 58                	jne    edc2 <bt_hci_host_num_completed_packets+0xfc>
    ed6a:	48 8d 35 5f b6 22 00 	lea    0x22b65f(%rip),%rsi        # 23a3d0 <log_const_bt_hci_core>
    ed71:	48 2b 35 d8 71 22 00 	sub    0x2271d8(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unable to allocate new HCI command");
    ed78:	48 8d 3d 55 39 02 00 	lea    0x23955(%rip),%rdi        # 326d4 <__func__.5785+0x1a6c>
}
    ed7f:	5b                   	pop    %rbx
    ed80:	5d                   	pop    %rbp
    ed81:	41 5c                	pop    %r12
    ed83:	48 c1 ee 04          	shr    $0x4,%rsi
		BT_ERR("Unable to allocate new HCI command");
    ed87:	c1 e6 06             	shl    $0x6,%esi
    ed8a:	83 ce 01             	or     $0x1,%esi
    ed8d:	e9 32 85 ff ff       	jmpq   72c4 <log_0>
    ed92:	48 8d 35 37 b6 22 00 	lea    0x22b637(%rip),%rsi        # 23a3d0 <log_const_bt_hci_core>
    ed99:	48 2b 35 b0 71 22 00 	sub    0x2271b0(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("Not reporting packet for non-connected conn");
    eda0:	48 8d 3d 01 39 02 00 	lea    0x23901(%rip),%rdi        # 326a8 <__func__.5785+0x1a40>
    eda7:	48 c1 ee 04          	shr    $0x4,%rsi
    edab:	c1 e6 06             	shl    $0x6,%esi
    edae:	83 ce 02             	or     $0x2,%esi
    edb1:	e8 0e 85 ff ff       	callq  72c4 <log_0>
}
    edb6:	5b                   	pop    %rbx
		bt_conn_unref(conn);
    edb7:	48 89 ef             	mov    %rbp,%rdi
}
    edba:	5d                   	pop    %rbp
    edbb:	41 5c                	pop    %r12
		bt_conn_unref(conn);
    edbd:	e9 a2 29 00 00       	jmpq   11764 <bt_conn_unref>
	return net_buf_simple_add(&buf->b, len);
    edc2:	48 8d 68 10          	lea    0x10(%rax),%rbp
    edc6:	be 01 00 00 00       	mov    $0x1,%esi
    edcb:	48 89 ef             	mov    %rbp,%rdi
    edce:	e8 b6 a2 00 00       	callq  19089 <net_buf_simple_add>
    edd3:	48 89 ef             	mov    %rbp,%rdi
    edd6:	be 04 00 00 00       	mov    $0x4,%esi
	cp->num_handles = sys_cpu_to_le16(1);
    eddb:	c6 00 01             	movb   $0x1,(%rax)
    edde:	e8 a6 a2 00 00       	callq  19089 <net_buf_simple_add>
	bt_hci_cmd_send(BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS, buf);
    ede3:	48 89 de             	mov    %rbx,%rsi
	hc->handle = sys_cpu_to_le16(handle);
    ede6:	66 44 89 20          	mov    %r12w,(%rax)
	hc->count  = sys_cpu_to_le16(1);
    edea:	66 c7 40 02 01 00    	movw   $0x1,0x2(%rax)
}
    edf0:	5b                   	pop    %rbx
    edf1:	5d                   	pop    %rbp
    edf2:	41 5c                	pop    %r12
	bt_hci_cmd_send(BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS, buf);
    edf4:	bf 35 0c 00 00       	mov    $0xc35,%edi
    edf9:	e9 36 fe ff ff       	jmpq   ec34 <bt_hci_cmd_send>
}
    edfe:	5b                   	pop    %rbx
    edff:	5d                   	pop    %rbp
    ee00:	41 5c                	pop    %r12
    ee02:	c3                   	retq   

000000000000ee03 <bt_le_set_data_len>:
{
    ee03:	41 55                	push   %r13
    ee05:	41 54                	push   %r12
    ee07:	49 89 fd             	mov    %rdi,%r13
    ee0a:	55                   	push   %rbp
    ee0b:	53                   	push   %rbx
    ee0c:	41 89 f4             	mov    %esi,%r12d
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_DATA_LEN, sizeof(*cp));
    ee0f:	bf 22 20 00 00       	mov    $0x2022,%edi
    ee14:	be 06 00 00 00       	mov    $0x6,%esi
{
    ee19:	89 d5                	mov    %edx,%ebp
    ee1b:	48 83 ec 08          	sub    $0x8,%rsp
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_DATA_LEN, sizeof(*cp));
    ee1f:	e8 f9 f6 ff ff       	callq  e51d <bt_hci_cmd_create>
	if (!buf) {
    ee24:	48 85 c0             	test   %rax,%rax
    ee27:	74 35                	je     ee5e <bt_le_set_data_len+0x5b>
    ee29:	48 8d 78 10          	lea    0x10(%rax),%rdi
    ee2d:	be 06 00 00 00       	mov    $0x6,%esi
    ee32:	48 89 c3             	mov    %rax,%rbx
    ee35:	e8 4f a2 00 00       	callq  19089 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
    ee3a:	41 8b 55 00          	mov    0x0(%r13),%edx
	return bt_hci_cmd_send(BT_HCI_OP_LE_SET_DATA_LEN, buf);
    ee3e:	48 89 de             	mov    %rbx,%rsi
	cp->tx_octets = sys_cpu_to_le16(tx_octets);
    ee41:	66 44 89 60 02       	mov    %r12w,0x2(%rax)
	cp->tx_time = sys_cpu_to_le16(tx_time);
    ee46:	66 89 68 04          	mov    %bp,0x4(%rax)
	return bt_hci_cmd_send(BT_HCI_OP_LE_SET_DATA_LEN, buf);
    ee4a:	bf 22 20 00 00       	mov    $0x2022,%edi
	cp->handle = sys_cpu_to_le16(conn->handle);
    ee4f:	66 89 10             	mov    %dx,(%rax)
}
    ee52:	59                   	pop    %rcx
    ee53:	5b                   	pop    %rbx
    ee54:	5d                   	pop    %rbp
    ee55:	41 5c                	pop    %r12
    ee57:	41 5d                	pop    %r13
	return bt_hci_cmd_send(BT_HCI_OP_LE_SET_DATA_LEN, buf);
    ee59:	e9 d6 fd ff ff       	jmpq   ec34 <bt_hci_cmd_send>
}
    ee5e:	5a                   	pop    %rdx
    ee5f:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
    ee64:	5b                   	pop    %rbx
    ee65:	5d                   	pop    %rbp
    ee66:	41 5c                	pop    %r12
    ee68:	41 5d                	pop    %r13
    ee6a:	c3                   	retq   

000000000000ee6b <bt_le_set_phy>:
{
    ee6b:	41 57                	push   %r15
    ee6d:	41 56                	push   %r14
    ee6f:	49 89 fe             	mov    %rdi,%r14
    ee72:	41 55                	push   %r13
    ee74:	41 54                	push   %r12
    ee76:	41 89 f5             	mov    %esi,%r13d
    ee79:	55                   	push   %rbp
    ee7a:	53                   	push   %rbx
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PHY, sizeof(*cp));
    ee7b:	be 07 00 00 00       	mov    $0x7,%esi
    ee80:	bf 32 20 00 00       	mov    $0x2032,%edi
{
    ee85:	41 89 d4             	mov    %edx,%r12d
    ee88:	89 cd                	mov    %ecx,%ebp
    ee8a:	48 83 ec 08          	sub    $0x8,%rsp
    ee8e:	44 89 c3             	mov    %r8d,%ebx
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PHY, sizeof(*cp));
    ee91:	e8 87 f6 ff ff       	callq  e51d <bt_hci_cmd_create>
	if (!buf) {
    ee96:	48 85 c0             	test   %rax,%rax
    ee99:	74 42                	je     eedd <bt_le_set_phy+0x72>
    ee9b:	48 8d 78 10          	lea    0x10(%rax),%rdi
    ee9f:	be 07 00 00 00       	mov    $0x7,%esi
    eea4:	49 89 c7             	mov    %rax,%r15
	cp->phy_opts = phy_opts;
    eea7:	0f b6 db             	movzbl %bl,%ebx
    eeaa:	e8 da a1 00 00       	callq  19089 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
    eeaf:	41 8b 16             	mov    (%r14),%edx
	return bt_hci_cmd_send(BT_HCI_OP_LE_SET_PHY, buf);
    eeb2:	4c 89 fe             	mov    %r15,%rsi
	cp->all_phys = all_phys;
    eeb5:	44 88 68 02          	mov    %r13b,0x2(%rax)
	cp->tx_phys = pref_tx_phy;
    eeb9:	44 88 60 03          	mov    %r12b,0x3(%rax)
	cp->rx_phys = pref_rx_phy;
    eebd:	40 88 68 04          	mov    %bpl,0x4(%rax)
	return bt_hci_cmd_send(BT_HCI_OP_LE_SET_PHY, buf);
    eec1:	bf 32 20 00 00       	mov    $0x2032,%edi
	cp->phy_opts = phy_opts;
    eec6:	66 89 58 05          	mov    %bx,0x5(%rax)
	cp->handle = sys_cpu_to_le16(conn->handle);
    eeca:	66 89 10             	mov    %dx,(%rax)
}
    eecd:	59                   	pop    %rcx
    eece:	5b                   	pop    %rbx
    eecf:	5d                   	pop    %rbp
    eed0:	41 5c                	pop    %r12
    eed2:	41 5d                	pop    %r13
    eed4:	41 5e                	pop    %r14
    eed6:	41 5f                	pop    %r15
	return bt_hci_cmd_send(BT_HCI_OP_LE_SET_PHY, buf);
    eed8:	e9 57 fd ff ff       	jmpq   ec34 <bt_hci_cmd_send>
}
    eedd:	5a                   	pop    %rdx
    eede:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
    eee3:	5b                   	pop    %rbx
    eee4:	5d                   	pop    %rbp
    eee5:	41 5c                	pop    %r12
    eee7:	41 5d                	pop    %r13
    eee9:	41 5e                	pop    %r14
    eeeb:	41 5f                	pop    %r15
    eeed:	c3                   	retq   

000000000000eeee <conn_auto_initiate>:
{
    eeee:	41 54                	push   %r12
    eef0:	55                   	push   %rbp
    eef1:	53                   	push   %rbx
    eef2:	48 83 ec 10          	sub    $0x10,%rsp
    eef6:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    eefd:	00 00 
    eeff:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    ef04:	31 c0                	xor    %eax,%eax
	if (conn->state != BT_CONN_CONNECTED) {
    ef06:	80 7f 0a 07          	cmpb   $0x7,0xa(%rdi)
    ef0a:	0f 85 46 01 00 00    	jne    f056 <conn_auto_initiate+0x168>
	if (!atomic_test_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH) &&
    ef10:	4c 8d 67 04          	lea    0x4(%rdi),%r12
    ef14:	48 89 fb             	mov    %rdi,%rbx
    ef17:	be 0d 00 00 00       	mov    $0xd,%esi
    ef1c:	4c 89 e7             	mov    %r12,%rdi
    ef1f:	e8 10 f0 ff ff       	callq  df34 <atomic_test_bit>
    ef24:	84 c0                	test   %al,%al
    ef26:	75 53                	jne    ef7b <conn_auto_initiate+0x8d>
    ef28:	80 7b 03 00          	cmpb   $0x0,0x3(%rbx)
    ef2c:	74 10                	je     ef3e <conn_auto_initiate+0x50>
	    ((conn->role == BT_HCI_ROLE_MASTER) ||
    ef2e:	48 8d 05 0b 77 22 00 	lea    0x22770b(%rip),%rax        # 236640 <bt_dev>
    ef35:	f6 80 a8 00 00 00 08 	testb  $0x8,0xa8(%rax)
    ef3c:	74 3d                	je     ef7b <conn_auto_initiate+0x8d>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_READ_REMOTE_FEATURES,
    ef3e:	be 02 00 00 00       	mov    $0x2,%esi
    ef43:	bf 16 20 00 00       	mov    $0x2016,%edi
    ef48:	e8 d0 f5 ff ff       	callq  e51d <bt_hci_cmd_create>
	if (!buf) {
    ef4d:	48 85 c0             	test   %rax,%rax
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_READ_REMOTE_FEATURES,
    ef50:	48 89 c5             	mov    %rax,%rbp
	if (!buf) {
    ef53:	74 26                	je     ef7b <conn_auto_initiate+0x8d>
    ef55:	48 8d 78 10          	lea    0x10(%rax),%rdi
    ef59:	be 02 00 00 00       	mov    $0x2,%esi
    ef5e:	e8 26 a1 00 00       	callq  19089 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
    ef63:	66 8b 13             	mov    (%rbx),%dx
	bt_hci_cmd_send(BT_HCI_OP_LE_READ_REMOTE_FEATURES, buf);
    ef66:	48 89 ee             	mov    %rbp,%rsi
    ef69:	bf 16 20 00 00       	mov    $0x2016,%edi
	cp->handle = sys_cpu_to_le16(conn->handle);
    ef6e:	66 89 10             	mov    %dx,(%rax)
	bt_hci_cmd_send(BT_HCI_OP_LE_READ_REMOTE_FEATURES, buf);
    ef71:	e8 be fc ff ff       	callq  ec34 <bt_hci_cmd_send>
    ef76:	e9 db 00 00 00       	jmpq   f056 <conn_auto_initiate+0x168>
	    !atomic_test_bit(conn->flags, BT_CONN_AUTO_PHY_COMPLETE) &&
    ef7b:	be 0c 00 00 00       	mov    $0xc,%esi
    ef80:	4c 89 e7             	mov    %r12,%rdi
    ef83:	e8 ac ef ff ff       	callq  df34 <atomic_test_bit>
	if (IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) &&
    ef88:	84 c0                	test   %al,%al
    ef8a:	48 8d 2d af 76 22 00 	lea    0x2276af(%rip),%rbp        # 236640 <bt_dev>
    ef91:	75 5d                	jne    eff0 <conn_auto_initiate+0x102>
	    !atomic_test_bit(conn->flags, BT_CONN_AUTO_PHY_COMPLETE) &&
    ef93:	f6 85 a9 00 00 00 01 	testb  $0x1,0xa9(%rbp)
    ef9a:	74 54                	je     eff0 <conn_auto_initiate+0x102>
		err = bt_le_set_phy(conn, 0U, BT_HCI_LE_PHY_PREFER_2M,
    ef9c:	45 31 c0             	xor    %r8d,%r8d
    ef9f:	31 f6                	xor    %esi,%esi
    efa1:	b9 02 00 00 00       	mov    $0x2,%ecx
    efa6:	ba 02 00 00 00       	mov    $0x2,%edx
    efab:	48 89 df             	mov    %rbx,%rdi
    efae:	e8 b8 fe ff ff       	callq  ee6b <bt_le_set_phy>
		if (!err) {
    efb3:	85 c0                	test   %eax,%eax
    efb5:	75 12                	jne    efc9 <conn_auto_initiate+0xdb>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    efb7:	be 80 00 00 00       	mov    $0x80,%esi
    efbc:	4c 89 e7             	mov    %r12,%rdi
    efbf:	e8 0e e8 ff ff       	callq  d7d2 <atomic_or>
    efc4:	e9 8d 00 00 00       	jmpq   f056 <conn_auto_initiate+0x168>
    efc9:	48 8d 15 00 b4 22 00 	lea    0x22b400(%rip),%rdx        # 23a3d0 <log_const_bt_hci_core>
    efd0:	48 2b 15 79 6f 22 00 	sub    0x226f79(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Failed to set LE PHY (%d)", err);
    efd7:	48 8d 3d 19 37 02 00 	lea    0x23719(%rip),%rdi        # 326f7 <__func__.5785+0x1a8f>
    efde:	48 63 f0             	movslq %eax,%rsi
    efe1:	48 c1 ea 04          	shr    $0x4,%rdx
    efe5:	c1 e2 06             	shl    $0x6,%edx
    efe8:	83 ca 01             	or     $0x1,%edx
    efeb:	e8 05 83 ff ff       	callq  72f5 <log_1>
	if (IS_ENABLED(CONFIG_BT_AUTO_DATA_LEN_UPDATE) &&
    eff0:	f6 85 a8 00 00 00 20 	testb  $0x20,0xa8(%rbp)
    eff7:	74 5d                	je     f056 <conn_auto_initiate+0x168>
		if (IS_BT_QUIRK_NO_AUTO_DLE(&bt_dev)) {
    eff9:	48 8b 85 a8 01 00 00 	mov    0x1a8(%rbp),%rax
    f000:	f6 40 0c 02          	testb  $0x2,0xc(%rax)
    f004:	74 50                	je     f056 <conn_auto_initiate+0x168>
			err = hci_le_read_max_data_len(&tx_octets, &tx_time);
    f006:	48 8d 74 24 06       	lea    0x6(%rsp),%rsi
    f00b:	48 8d 7c 24 04       	lea    0x4(%rsp),%rdi
    f010:	e8 35 f7 ff ff       	callq  e74a <hci_le_read_max_data_len>
			if (!err) {
    f015:	85 c0                	test   %eax,%eax
    f017:	75 3d                	jne    f056 <conn_auto_initiate+0x168>
				err = bt_le_set_data_len(conn,
    f019:	0f b7 54 24 06       	movzwl 0x6(%rsp),%edx
    f01e:	0f b7 74 24 04       	movzwl 0x4(%rsp),%esi
    f023:	48 89 df             	mov    %rbx,%rdi
    f026:	e8 d8 fd ff ff       	callq  ee03 <bt_le_set_data_len>
				if (err) {
    f02b:	85 c0                	test   %eax,%eax
    f02d:	74 27                	je     f056 <conn_auto_initiate+0x168>
    f02f:	48 8d 15 9a b3 22 00 	lea    0x22b39a(%rip),%rdx        # 23a3d0 <log_const_bt_hci_core>
    f036:	48 2b 15 13 6f 22 00 	sub    0x226f13(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
					BT_ERR("Failed to set data len (%d)", err);
    f03d:	48 8d 3d cd 36 02 00 	lea    0x236cd(%rip),%rdi        # 32711 <__func__.5785+0x1aa9>
    f044:	48 63 f0             	movslq %eax,%rsi
    f047:	48 c1 ea 04          	shr    $0x4,%rdx
    f04b:	c1 e2 06             	shl    $0x6,%edx
    f04e:	83 ca 01             	or     $0x1,%edx
    f051:	e8 9f 82 ff ff       	callq  72f5 <log_1>
}
    f056:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    f05b:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    f062:	00 00 
    f064:	74 05                	je     f06b <conn_auto_initiate+0x17d>
    f066:	e8 d5 55 ff ff       	callq  4640 <__stack_chk_fail@plt>
    f06b:	48 83 c4 10          	add    $0x10,%rsp
    f06f:	5b                   	pop    %rbx
    f070:	5d                   	pop    %rbp
    f071:	41 5c                	pop    %r12
    f073:	c3                   	retq   

000000000000f074 <le_phy_update_complete>:
{
    f074:	55                   	push   %rbp
    f075:	53                   	push   %rbx
    f076:	48 83 ec 08          	sub    $0x8,%rsp
	uint16_t handle = sys_le16_to_cpu(evt->handle);
    f07a:	48 8b 47 10          	mov    0x10(%rdi),%rax
    f07e:	0f b7 78 01          	movzwl 0x1(%rax),%edi
    f082:	89 fd                	mov    %edi,%ebp
	conn = bt_conn_lookup_handle(handle);
    f084:	e8 5b 27 00 00       	callq  117e4 <bt_conn_lookup_handle>
	if (!conn) {
    f089:	48 85 c0             	test   %rax,%rax
    f08c:	75 2a                	jne    f0b8 <le_phy_update_complete+0x44>
    f08e:	48 8d 15 3b b3 22 00 	lea    0x22b33b(%rip),%rdx        # 23a3d0 <log_const_bt_hci_core>
    f095:	48 2b 15 b4 6e 22 00 	sub    0x226eb4(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    f09c:	0f b7 f5             	movzwl %bp,%esi
}
    f09f:	59                   	pop    %rcx
    f0a0:	5b                   	pop    %rbx
    f0a1:	5d                   	pop    %rbp
    f0a2:	48 c1 ea 04          	shr    $0x4,%rdx
		BT_ERR("Unable to lookup conn for handle %u", handle);
    f0a6:	48 8d 3d ef 32 02 00 	lea    0x232ef(%rip),%rdi        # 3239c <__func__.5785+0x1734>
    f0ad:	c1 e2 06             	shl    $0x6,%edx
    f0b0:	83 ca 01             	or     $0x1,%edx
    f0b3:	e9 3d 82 ff ff       	jmpq   72f5 <log_1>
    f0b8:	48 89 c3             	mov    %rax,%rbx
	    atomic_test_and_clear_bit(conn->flags, BT_CONN_AUTO_PHY_UPDATE)) {
    f0bb:	48 8d 78 04          	lea    0x4(%rax),%rdi
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    f0bf:	8b 40 04             	mov    0x4(%rax),%eax
    f0c2:	89 c1                	mov    %eax,%ecx
    f0c4:	89 c2                	mov    %eax,%edx
    f0c6:	80 e1 7f             	and    $0x7f,%cl
    f0c9:	f0 0f b1 0f          	lock cmpxchg %ecx,(%rdi)
    f0cd:	75 f3                	jne    f0c2 <le_phy_update_complete+0x4e>
	if (IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) &&
    f0cf:	80 e2 80             	and    $0x80,%dl
    f0d2:	74 12                	je     f0e6 <le_phy_update_complete+0x72>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    f0d4:	be 00 10 00 00       	mov    $0x1000,%esi
    f0d9:	e8 f4 e6 ff ff       	callq  d7d2 <atomic_or>
		conn_auto_initiate(conn);
    f0de:	48 89 df             	mov    %rbx,%rdi
    f0e1:	e8 08 fe ff ff       	callq  eeee <conn_auto_initiate>
}
    f0e6:	58                   	pop    %rax
	bt_conn_unref(conn);
    f0e7:	48 89 df             	mov    %rbx,%rdi
}
    f0ea:	5b                   	pop    %rbx
    f0eb:	5d                   	pop    %rbp
	bt_conn_unref(conn);
    f0ec:	e9 73 26 00 00       	jmpq   11764 <bt_conn_unref>

000000000000f0f1 <le_remote_feat_complete>:
{
    f0f1:	41 54                	push   %r12
    f0f3:	55                   	push   %rbp
    f0f4:	53                   	push   %rbx
	struct bt_hci_evt_le_remote_feat_complete *evt = (void *)buf->data;
    f0f5:	4c 8b 67 10          	mov    0x10(%rdi),%r12
	uint16_t handle = sys_le16_to_cpu(evt->handle);
    f0f9:	41 0f b7 7c 24 01    	movzwl 0x1(%r12),%edi
    f0ff:	89 fd                	mov    %edi,%ebp
	conn = bt_conn_lookup_handle(handle);
    f101:	e8 de 26 00 00       	callq  117e4 <bt_conn_lookup_handle>
	if (!conn) {
    f106:	48 85 c0             	test   %rax,%rax
    f109:	75 2b                	jne    f136 <le_remote_feat_complete+0x45>
    f10b:	48 8d 15 be b2 22 00 	lea    0x22b2be(%rip),%rdx        # 23a3d0 <log_const_bt_hci_core>
    f112:	48 2b 15 37 6e 22 00 	sub    0x226e37(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    f119:	0f b7 f5             	movzwl %bp,%esi
}
    f11c:	5b                   	pop    %rbx
    f11d:	5d                   	pop    %rbp
    f11e:	41 5c                	pop    %r12
    f120:	48 c1 ea 04          	shr    $0x4,%rdx
		BT_ERR("Unable to lookup conn for handle %u", handle);
    f124:	48 8d 3d 71 32 02 00 	lea    0x23271(%rip),%rdi        # 3239c <__func__.5785+0x1734>
    f12b:	c1 e2 06             	shl    $0x6,%edx
    f12e:	83 ca 01             	or     $0x1,%edx
    f131:	e9 bf 81 ff ff       	jmpq   72f5 <log_1>
	if (!evt->status) {
    f136:	41 80 3c 24 00       	cmpb   $0x0,(%r12)
    f13b:	48 89 c3             	mov    %rax,%rbx
    f13e:	75 0c                	jne    f14c <le_remote_feat_complete+0x5b>
    f140:	49 8b 44 24 03       	mov    0x3(%r12),%rax
    f145:	48 89 83 fc 00 00 00 	mov    %rax,0xfc(%rbx)
	atomic_set_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH);
    f14c:	48 8d 7b 04          	lea    0x4(%rbx),%rdi
    f150:	be 00 20 00 00       	mov    $0x2000,%esi
    f155:	e8 78 e6 ff ff       	callq  d7d2 <atomic_or>
	conn_auto_initiate(conn);
    f15a:	48 89 df             	mov    %rbx,%rdi
    f15d:	e8 8c fd ff ff       	callq  eeee <conn_auto_initiate>
	bt_conn_unref(conn);
    f162:	48 89 df             	mov    %rbx,%rdi
}
    f165:	5b                   	pop    %rbx
    f166:	5d                   	pop    %rbp
    f167:	41 5c                	pop    %r12
	bt_conn_unref(conn);
    f169:	e9 f6 25 00 00       	jmpq   11764 <bt_conn_unref>

000000000000f16e <le_conn_param_neg_reply>:
{
    f16e:	41 54                	push   %r12
    f170:	55                   	push   %rbp
    f171:	41 89 fc             	mov    %edi,%r12d
    f174:	53                   	push   %rbx
    f175:	89 f5                	mov    %esi,%ebp
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY,
    f177:	bf 21 20 00 00       	mov    $0x2021,%edi
    f17c:	be 03 00 00 00       	mov    $0x3,%esi
    f181:	e8 97 f3 ff ff       	callq  e51d <bt_hci_cmd_create>
	if (!buf) {
    f186:	48 85 c0             	test   %rax,%rax
    f189:	75 28                	jne    f1b3 <le_conn_param_neg_reply+0x45>
    f18b:	48 8d 35 3e b2 22 00 	lea    0x22b23e(%rip),%rsi        # 23a3d0 <log_const_bt_hci_core>
    f192:	48 2b 35 b7 6d 22 00 	sub    0x226db7(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unable to allocate buffer");
    f199:	48 8d 3d 8d 35 02 00 	lea    0x2358d(%rip),%rdi        # 3272d <__func__.5785+0x1ac5>
}
    f1a0:	5b                   	pop    %rbx
    f1a1:	5d                   	pop    %rbp
    f1a2:	41 5c                	pop    %r12
    f1a4:	48 c1 ee 04          	shr    $0x4,%rsi
		BT_ERR("Unable to allocate buffer");
    f1a8:	c1 e6 06             	shl    $0x6,%esi
    f1ab:	83 ce 01             	or     $0x1,%esi
    f1ae:	e9 11 81 ff ff       	jmpq   72c4 <log_0>
    f1b3:	48 8d 78 10          	lea    0x10(%rax),%rdi
    f1b7:	48 89 c3             	mov    %rax,%rbx
    f1ba:	be 03 00 00 00       	mov    $0x3,%esi
    f1bf:	e8 c5 9e 00 00       	callq  19089 <net_buf_simple_add>
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
    f1c4:	48 89 de             	mov    %rbx,%rsi
	cp->handle = sys_cpu_to_le16(handle);
    f1c7:	66 44 89 20          	mov    %r12w,(%rax)
	cp->reason = sys_cpu_to_le16(reason);
    f1cb:	40 88 68 02          	mov    %bpl,0x2(%rax)
}
    f1cf:	5b                   	pop    %rbx
    f1d0:	5d                   	pop    %rbp
    f1d1:	41 5c                	pop    %r12
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
    f1d3:	bf 21 20 00 00       	mov    $0x2021,%edi
    f1d8:	e9 57 fa ff ff       	jmpq   ec34 <bt_hci_cmd_send>

000000000000f1dd <le_conn_param_req>:
{
    f1dd:	41 54                	push   %r12
    f1df:	55                   	push   %rbp
    f1e0:	53                   	push   %rbx
    f1e1:	48 83 ec 10          	sub    $0x10,%rsp
    f1e5:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    f1ec:	00 00 
    f1ee:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    f1f3:	31 c0                	xor    %eax,%eax
	struct bt_hci_evt_le_conn_param_req *evt = (void *)buf->data;
    f1f5:	48 8b 47 10          	mov    0x10(%rdi),%rax
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
    f1f9:	66 8b 50 02          	mov    0x2(%rax),%dx
	handle = sys_le16_to_cpu(evt->handle);
    f1fd:	0f b7 28             	movzwl (%rax),%ebp
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
    f200:	66 89 14 24          	mov    %dx,(%rsp)
	param.interval_max = sys_le16_to_cpu(evt->interval_max);
    f204:	66 8b 50 04          	mov    0x4(%rax),%dx
	conn = bt_conn_lookup_handle(handle);
    f208:	89 ef                	mov    %ebp,%edi
	handle = sys_le16_to_cpu(evt->handle);
    f20a:	89 eb                	mov    %ebp,%ebx
	param.interval_max = sys_le16_to_cpu(evt->interval_max);
    f20c:	66 89 54 24 02       	mov    %dx,0x2(%rsp)
	param.latency = sys_le16_to_cpu(evt->latency);
    f211:	66 8b 50 06          	mov    0x6(%rax),%dx
	param.timeout = sys_le16_to_cpu(evt->timeout);
    f215:	66 8b 40 08          	mov    0x8(%rax),%ax
	param.latency = sys_le16_to_cpu(evt->latency);
    f219:	66 89 54 24 04       	mov    %dx,0x4(%rsp)
	param.timeout = sys_le16_to_cpu(evt->timeout);
    f21e:	66 89 44 24 06       	mov    %ax,0x6(%rsp)
	conn = bt_conn_lookup_handle(handle);
    f223:	e8 bc 25 00 00       	callq  117e4 <bt_conn_lookup_handle>
	if (!conn) {
    f228:	48 85 c0             	test   %rax,%rax
    f22b:	75 38                	jne    f265 <le_conn_param_req+0x88>
    f22d:	48 8d 15 9c b1 22 00 	lea    0x22b19c(%rip),%rdx        # 23a3d0 <log_const_bt_hci_core>
    f234:	48 2b 15 15 6d 22 00 	sub    0x226d15(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    f23b:	48 8d 3d 5a 31 02 00 	lea    0x2315a(%rip),%rdi        # 3239c <__func__.5785+0x1734>
    f242:	0f b7 f5             	movzwl %bp,%esi
    f245:	48 c1 ea 04          	shr    $0x4,%rdx
    f249:	c1 e2 06             	shl    $0x6,%edx
    f24c:	83 ca 01             	or     $0x1,%edx
    f24f:	e8 a1 80 ff ff       	callq  72f5 <log_1>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_UNKNOWN_CONN_ID);
    f254:	be 02 00 00 00       	mov    $0x2,%esi
    f259:	89 ef                	mov    %ebp,%edi
    f25b:	e8 0e ff ff ff       	callq  f16e <le_conn_param_neg_reply>
    f260:	e9 91 00 00 00       	jmpq   f2f6 <le_conn_param_req+0x119>
	if (!le_param_req(conn, &param)) {
    f265:	48 89 e6             	mov    %rsp,%rsi
    f268:	48 89 c7             	mov    %rax,%rdi
    f26b:	49 89 c4             	mov    %rax,%r12
    f26e:	e8 45 1f 00 00       	callq  111b8 <le_param_req>
    f273:	84 c0                	test   %al,%al
    f275:	75 0e                	jne    f285 <le_conn_param_req+0xa8>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_INVALID_LL_PARAM);
    f277:	be 1e 00 00 00       	mov    $0x1e,%esi
    f27c:	89 ef                	mov    %ebp,%edi
    f27e:	e8 eb fe ff ff       	callq  f16e <le_conn_param_neg_reply>
    f283:	eb 69                	jmp    f2ee <le_conn_param_req+0x111>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, sizeof(*cp));
    f285:	be 0e 00 00 00       	mov    $0xe,%esi
    f28a:	bf 20 20 00 00       	mov    $0x2020,%edi
    f28f:	e8 89 f2 ff ff       	callq  e51d <bt_hci_cmd_create>
	if (!buf) {
    f294:	48 85 c0             	test   %rax,%rax
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, sizeof(*cp));
    f297:	48 89 c5             	mov    %rax,%rbp
	if (!buf) {
    f29a:	74 52                	je     f2ee <le_conn_param_req+0x111>
    f29c:	48 8d 78 10          	lea    0x10(%rax),%rdi
    f2a0:	be 0e 00 00 00       	mov    $0xe,%esi
    f2a5:	e8 df 9d 00 00       	callq  19089 <net_buf_simple_add>
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    f2aa:	48 8d 70 04          	lea    0x4(%rax),%rsi
    f2ae:	48 89 c2             	mov    %rax,%rdx
    f2b1:	b9 0a 00 00 00       	mov    $0xa,%ecx
    f2b6:	31 c0                	xor    %eax,%eax
    f2b8:	48 89 f7             	mov    %rsi,%rdi
	return bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, buf);
    f2bb:	48 89 ee             	mov    %rbp,%rsi
    f2be:	f3 aa                	rep stos %al,%es:(%rdi)
	cp->interval_min = sys_cpu_to_le16(param->interval_min);
    f2c0:	8b 04 24             	mov    (%rsp),%eax
	cp->handle = sys_cpu_to_le16(handle);
    f2c3:	66 89 1a             	mov    %bx,(%rdx)
	return bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, buf);
    f2c6:	bf 20 20 00 00       	mov    $0x2020,%edi
	cp->interval_min = sys_cpu_to_le16(param->interval_min);
    f2cb:	66 89 42 02          	mov    %ax,0x2(%rdx)
	cp->interval_max = sys_cpu_to_le16(param->interval_max);
    f2cf:	66 8b 44 24 02       	mov    0x2(%rsp),%ax
    f2d4:	66 89 42 04          	mov    %ax,0x4(%rdx)
	cp->latency = sys_cpu_to_le16(param->latency);
    f2d8:	8b 44 24 04          	mov    0x4(%rsp),%eax
    f2dc:	66 89 42 06          	mov    %ax,0x6(%rdx)
	cp->timeout = sys_cpu_to_le16(param->timeout);
    f2e0:	66 8b 44 24 06       	mov    0x6(%rsp),%ax
    f2e5:	66 89 42 08          	mov    %ax,0x8(%rdx)
	return bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, buf);
    f2e9:	e8 46 f9 ff ff       	callq  ec34 <bt_hci_cmd_send>
	bt_conn_unref(conn);
    f2ee:	4c 89 e7             	mov    %r12,%rdi
    f2f1:	e8 6e 24 00 00       	callq  11764 <bt_conn_unref>
}
    f2f6:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    f2fb:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    f302:	00 00 
    f304:	74 05                	je     f30b <le_conn_param_req+0x12e>
    f306:	e8 35 53 ff ff       	callq  4640 <__stack_chk_fail@plt>
    f30b:	48 83 c4 10          	add    $0x10,%rsp
    f30f:	5b                   	pop    %rbx
    f310:	5d                   	pop    %rbp
    f311:	41 5c                	pop    %r12
    f313:	c3                   	retq   

000000000000f314 <hci_tx_thread>:
{
    f314:	41 57                	push   %r15
    f316:	41 56                	push   %r14
    f318:	41 55                	push   %r13
    f31a:	41 54                	push   %r12
		hci_cmd_done(cmd(buf)->opcode, BT_HCI_ERR_UNSPECIFIED, buf);
    f31c:	4c 8d 2d 7d 7b 24 00 	lea    0x247b7d(%rip),%r13        # 256ea0 <cmd_data>
{
    f323:	55                   	push   %rbp
    f324:	53                   	push   %rbx
    f325:	48 83 ec 08          	sub    $0x8,%rsp
    f329:	48 8d 1d a0 b0 22 00 	lea    0x22b0a0(%rip),%rbx        # 23a3d0 <log_const_bt_hci_core>
    f330:	48 2b 1d 19 6c 22 00 	sub    0x226c19(%rip),%rbx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
    f337:	48 c1 eb 04          	shr    $0x4,%rbx
		BT_ERR("Uncleared pending sent_cmd");
    f33b:	66 81 e3 ff 03       	and    $0x3ff,%bx
			ev_count += bt_conn_prepare_events(&events[1]);
    f340:	48 8d 3d a1 72 22 00 	lea    0x2272a1(%rip),%rdi        # 2365e8 <events.10069+0x28>
		events[0].state = K_POLL_STATE_NOT_READY;
    f347:	81 25 87 72 22 00 ff 	andl   $0xfffe0fff,0x227287(%rip)        # 2365d8 <events.10069+0x18>
    f34e:	0f fe ff 
			ev_count += bt_conn_prepare_events(&events[1]);
    f351:	e8 7c 22 00 00       	callq  115d2 <bt_conn_prepare_events>
    f356:	8d 68 01             	lea    0x1(%rax),%ebp
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&events, *(uintptr_t *)&num_events, *(uintptr_t *)&timeout, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
    f359:	48 8d 3d 60 72 22 00 	lea    0x227260(%rip),%rdi        # 2365c0 <events.10069>
    f360:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    f364:	89 ee                	mov    %ebp,%esi
    f366:	e8 4b d9 01 00       	callq  2ccb6 <z_impl_k_poll>
		BT_ASSERT(err == 0);
    f36b:	85 c0                	test   %eax,%eax
    f36d:	74 47                	je     f3b6 <hci_tx_thread+0xa2>
    f36f:	48 8d 15 d6 30 02 00 	lea    0x230d6(%rip),%rdx        # 3244c <__func__.5785+0x17e4>
    f376:	48 8d 35 62 32 02 00 	lea    0x23262(%rip),%rsi        # 325df <__func__.5785+0x1977>
    f37d:	48 8d 3d 14 31 02 00 	lea    0x23114(%rip),%rdi        # 32498 <__func__.5785+0x1830>
    f384:	b9 71 14 00 00       	mov    $0x1471,%ecx
    f389:	31 c0                	xor    %eax,%eax
    f38b:	e8 00 66 ff ff       	callq  5990 <printk>
    f390:	48 8d 35 b5 30 02 00 	lea    0x230b5(%rip),%rsi        # 3244c <__func__.5785+0x17e4>
    f397:	48 8d 3d 0e 31 02 00 	lea    0x2310e(%rip),%rdi        # 324ac <__func__.5785+0x1844>
    f39e:	ba 71 14 00 00       	mov    $0x1471,%edx
    f3a3:	31 c0                	xor    %eax,%eax
    f3a5:	e8 e6 65 ff ff       	callq  5990 <printk>
    f3aa:	31 f6                	xor    %esi,%esi
    f3ac:	bf 03 00 00 00       	mov    $0x3,%edi
    f3b1:	e8 34 b5 01 00       	callq  2a8ea <z_fatal_error>
{
    f3b6:	4c 8d 25 03 72 22 00 	lea    0x227203(%rip),%r12        # 2365c0 <events.10069>
	for (; count; ev++, count--) {
    f3bd:	85 ed                	test   %ebp,%ebp
    f3bf:	0f 84 90 01 00 00    	je     f555 <hci_tx_thread+0x241>
		switch (ev->state) {
    f3c5:	41 8b 74 24 18       	mov    0x18(%r12),%esi
    f3ca:	c1 ee 0c             	shr    $0xc,%esi
    f3cd:	83 e6 1f             	and    $0x1f,%esi
    f3d0:	40 80 fe 01          	cmp    $0x1,%sil
    f3d4:	0f 86 70 01 00 00    	jbe    f54a <hci_tx_thread+0x236>
    f3da:	40 80 fe 04          	cmp    $0x4,%sil
    f3de:	0f 85 4e 01 00 00    	jne    f532 <hci_tx_thread+0x21e>
			if (ev->tag == BT_EVENT_CMD_TX) {
    f3e4:	41 8a 44 24 18       	mov    0x18(%r12),%al
    f3e9:	84 c0                	test   %al,%al
    f3eb:	0f 85 2d 01 00 00    	jne    f51e <hci_tx_thread+0x20a>
	buf = net_buf_get(&bt_dev.cmd_tx_queue, K_NO_WAIT);
    f3f1:	4c 8d 35 48 72 22 00 	lea    0x227248(%rip),%r14        # 236640 <bt_dev>
    f3f8:	31 f6                	xor    %esi,%esi
    f3fa:	49 8d be 78 01 00 00 	lea    0x178(%r14),%rdi
    f401:	e8 21 9b 00 00       	callq  18f27 <net_buf_get>
	BT_ASSERT(buf);
    f406:	48 85 c0             	test   %rax,%rax
	buf = net_buf_get(&bt_dev.cmd_tx_queue, K_NO_WAIT);
    f409:	49 89 c7             	mov    %rax,%r15
	BT_ASSERT(buf);
    f40c:	75 47                	jne    f455 <hci_tx_thread+0x141>
    f40e:	48 8d 15 37 30 02 00 	lea    0x23037(%rip),%rdx        # 3244c <__func__.5785+0x17e4>
    f415:	48 8d 35 54 2f 02 00 	lea    0x22f54(%rip),%rsi        # 32370 <__func__.5785+0x1708>
    f41c:	48 8d 3d 75 30 02 00 	lea    0x23075(%rip),%rdi        # 32498 <__func__.5785+0x1830>
    f423:	b9 0e 14 00 00       	mov    $0x140e,%ecx
    f428:	31 c0                	xor    %eax,%eax
    f42a:	e8 61 65 ff ff       	callq  5990 <printk>
    f42f:	48 8d 35 16 30 02 00 	lea    0x23016(%rip),%rsi        # 3244c <__func__.5785+0x17e4>
    f436:	48 8d 3d 6f 30 02 00 	lea    0x2306f(%rip),%rdi        # 324ac <__func__.5785+0x1844>
    f43d:	ba 0e 14 00 00       	mov    $0x140e,%edx
    f442:	31 c0                	xor    %eax,%eax
    f444:	e8 47 65 ff ff       	callq  5990 <printk>
    f449:	31 f6                	xor    %esi,%esi
    f44b:	bf 03 00 00 00       	mov    $0x3,%edi
    f450:	e8 95 b4 01 00       	callq  2a8ea <z_fatal_error>
	return z_impl_k_sem_take(sem, timeout);
    f455:	49 8d be 18 01 00 00 	lea    0x118(%r14),%rdi
    f45c:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
    f460:	e8 2e cb 01 00       	callq  2bf93 <z_impl_k_sem_take>
	if (bt_dev.sent_cmd) {
    f465:	49 83 be 40 01 00 00 	cmpq   $0x0,0x140(%r14)
    f46c:	00 
    f46d:	74 2b                	je     f49a <hci_tx_thread+0x186>
		BT_ERR("Uncleared pending sent_cmd");
    f46f:	89 de                	mov    %ebx,%esi
    f471:	48 8d 3d cf 32 02 00 	lea    0x232cf(%rip),%rdi        # 32747 <__func__.5785+0x1adf>
    f478:	c1 e6 06             	shl    $0x6,%esi
    f47b:	83 ce 01             	or     $0x1,%esi
    f47e:	e8 41 7e ff ff       	callq  72c4 <log_0>
		net_buf_unref(bt_dev.sent_cmd);
    f483:	49 8b be 40 01 00 00 	mov    0x140(%r14),%rdi
    f48a:	e8 0b 9b 00 00       	callq  18f9a <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    f48f:	49 c7 86 40 01 00 00 	movq   $0x0,0x140(%r14)
    f496:	00 00 00 00 
	bt_dev.sent_cmd = net_buf_ref(buf);
    f49a:	4c 89 ff             	mov    %r15,%rdi
    f49d:	e8 73 9b 00 00       	callq  19015 <net_buf_ref>
	err = bt_send(buf);
    f4a2:	4c 89 ff             	mov    %r15,%rdi
	bt_dev.sent_cmd = net_buf_ref(buf);
    f4a5:	49 89 86 40 01 00 00 	mov    %rax,0x140(%r14)
	err = bt_send(buf);
    f4ac:	e8 72 f7 ff ff       	callq  ec23 <bt_send>
	if (err) {
    f4b1:	85 c0                	test   %eax,%eax
    f4b3:	0f 84 91 00 00 00    	je     f54a <hci_tx_thread+0x236>
		BT_ERR("Unable to send to driver (err %d)", err);
    f4b9:	89 da                	mov    %ebx,%edx
    f4bb:	48 8d 3d 9b 31 02 00 	lea    0x2319b(%rip),%rdi        # 3265d <__func__.5785+0x19f5>
    f4c2:	48 63 f0             	movslq %eax,%rsi
    f4c5:	c1 e2 06             	shl    $0x6,%edx
    f4c8:	83 ca 01             	or     $0x1,%edx
    f4cb:	e8 25 7e ff ff       	callq  72f5 <log_1>
	z_impl_k_sem_give(sem);
    f4d0:	49 8d be 18 01 00 00 	lea    0x118(%r14),%rdi
    f4d7:	e8 5a ca 01 00       	callq  2bf36 <z_impl_k_sem_give>
		hci_cmd_done(cmd(buf)->opcode, BT_HCI_ERR_UNSPECIFIED, buf);
    f4dc:	4c 89 ff             	mov    %r15,%rdi
    f4df:	e8 74 98 00 00       	callq  18d58 <net_buf_id>
    f4e4:	48 98                	cltq   
    f4e6:	4c 89 fa             	mov    %r15,%rdx
    f4e9:	be 1f 00 00 00       	mov    $0x1f,%esi
    f4ee:	48 6b c0 18          	imul   $0x18,%rax,%rax
    f4f2:	41 0f b7 7c 05 02    	movzwl 0x2(%r13,%rax,1),%edi
    f4f8:	e8 f8 ed ff ff       	callq  e2f5 <hci_cmd_done>
		net_buf_unref(bt_dev.sent_cmd);
    f4fd:	49 8b be 40 01 00 00 	mov    0x140(%r14),%rdi
    f504:	e8 91 9a 00 00       	callq  18f9a <net_buf_unref>
		net_buf_unref(buf);
    f509:	4c 89 ff             	mov    %r15,%rdi
		bt_dev.sent_cmd = NULL;
    f50c:	49 c7 86 40 01 00 00 	movq   $0x0,0x140(%r14)
    f513:	00 00 00 00 
		net_buf_unref(buf);
    f517:	e8 7e 9a 00 00       	callq  18f9a <net_buf_unref>
    f51c:	eb 2c                	jmp    f54a <hci_tx_thread+0x236>
				if (ev->tag == BT_EVENT_CONN_TX_QUEUE) {
    f51e:	fe c8                	dec    %al
    f520:	75 28                	jne    f54a <hci_tx_thread+0x236>
					conn = CONTAINER_OF(ev->fifo,
    f522:	49 8b 44 24 20       	mov    0x20(%r12),%rax
    f527:	48 8d 78 a8          	lea    -0x58(%rax),%rdi
					bt_conn_process_tx(conn);
    f52b:	e8 44 29 00 00       	callq  11e74 <bt_conn_process_tx>
    f530:	eb 18                	jmp    f54a <hci_tx_thread+0x236>
			BT_WARN("Unexpected k_poll event state %u", ev->state);
    f532:	89 da                	mov    %ebx,%edx
    f534:	48 8d 3d 27 32 02 00 	lea    0x23227(%rip),%rdi        # 32762 <__func__.5785+0x1afa>
    f53b:	40 0f b6 f6          	movzbl %sil,%esi
    f53f:	c1 e2 06             	shl    $0x6,%edx
    f542:	83 ca 02             	or     $0x2,%edx
    f545:	e8 ab 7d ff ff       	callq  72f5 <log_1>
	for (; count; ev++, count--) {
    f54a:	49 83 c4 28          	add    $0x28,%r12
    f54e:	ff cd                	dec    %ebp
    f550:	e9 68 fe ff ff       	jmpq   f3bd <hci_tx_thread+0xa9>
	z_impl_k_yield();
    f555:	31 c0                	xor    %eax,%eax
    f557:	e8 9a c8 01 00       	callq  2bdf6 <z_impl_k_yield>
    f55c:	e9 df fd ff ff       	jmpq   f340 <hci_tx_thread+0x2c>

000000000000f561 <hci_event_prio>:
{
    f561:	41 56                	push   %r14
    f563:	41 55                	push   %r13
	net_buf_simple_save(&buf->b, &state);
    f565:	4c 8d 6f 10          	lea    0x10(%rdi),%r13
{
    f569:	41 54                	push   %r12
    f56b:	55                   	push   %rbp
    f56c:	53                   	push   %rbx
    f56d:	48 89 fb             	mov    %rdi,%rbx
	state->offset = net_buf_simple_headroom(buf);
    f570:	4c 89 ef             	mov    %r13,%rdi
    f573:	e8 ba 9b 00 00       	callq  19132 <net_buf_simple_headroom>
	state->len = buf->len;
    f578:	44 8b 63 18          	mov    0x18(%rbx),%r12d
	state->offset = net_buf_simple_headroom(buf);
    f57c:	48 89 c5             	mov    %rax,%rbp
	BT_ASSERT(buf->len >= sizeof(*hdr));
    f57f:	66 41 83 fc 01       	cmp    $0x1,%r12w
    f584:	77 47                	ja     f5cd <hci_event_prio+0x6c>
    f586:	48 8d 15 bf 2e 02 00 	lea    0x22ebf(%rip),%rdx        # 3244c <__func__.5785+0x17e4>
    f58d:	48 8d 35 eb 2e 02 00 	lea    0x22eeb(%rip),%rsi        # 3247f <__func__.5785+0x1817>
    f594:	48 8d 3d fd 2e 02 00 	lea    0x22efd(%rip),%rdi        # 32498 <__func__.5785+0x1830>
    f59b:	b9 ae 18 00 00       	mov    $0x18ae,%ecx
    f5a0:	31 c0                	xor    %eax,%eax
    f5a2:	e8 e9 63 ff ff       	callq  5990 <printk>
    f5a7:	48 8d 35 9e 2e 02 00 	lea    0x22e9e(%rip),%rsi        # 3244c <__func__.5785+0x17e4>
    f5ae:	48 8d 3d f7 2e 02 00 	lea    0x22ef7(%rip),%rdi        # 324ac <__func__.5785+0x1844>
    f5b5:	ba ae 18 00 00       	mov    $0x18ae,%edx
    f5ba:	31 c0                	xor    %eax,%eax
    f5bc:	e8 cf 63 ff ff       	callq  5990 <printk>
    f5c1:	31 f6                	xor    %esi,%esi
    f5c3:	bf 03 00 00 00       	mov    $0x3,%edi
    f5c8:	e8 1d b3 01 00       	callq  2a8ea <z_fatal_error>
	return net_buf_simple_pull_mem(&buf->b, len);
    f5cd:	4c 89 ef             	mov    %r13,%rdi
    f5d0:	be 02 00 00 00       	mov    $0x2,%esi
    f5d5:	e8 35 9b 00 00       	callq  1910f <net_buf_simple_pull_mem>
	evt_flags = bt_hci_evt_get_flags(hdr->evt);
    f5da:	0f b6 38             	movzbl (%rax),%edi
    f5dd:	49 89 c6             	mov    %rax,%r14
    f5e0:	e8 84 e1 ff ff       	callq  d769 <bt_hci_evt_get_flags>
	BT_ASSERT(evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO);
    f5e5:	a8 01                	test   $0x1,%al
	evt_flags = bt_hci_evt_get_flags(hdr->evt);
    f5e7:	41 88 c5             	mov    %al,%r13b
	BT_ASSERT(evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO);
    f5ea:	75 47                	jne    f633 <hci_event_prio+0xd2>
    f5ec:	48 8d 15 59 2e 02 00 	lea    0x22e59(%rip),%rdx        # 3244c <__func__.5785+0x17e4>
    f5f3:	48 8d 35 89 31 02 00 	lea    0x23189(%rip),%rsi        # 32783 <__func__.5785+0x1b1b>
    f5fa:	48 8d 3d 97 2e 02 00 	lea    0x22e97(%rip),%rdi        # 32498 <__func__.5785+0x1830>
    f601:	b9 b2 18 00 00       	mov    $0x18b2,%ecx
    f606:	31 c0                	xor    %eax,%eax
    f608:	e8 83 63 ff ff       	callq  5990 <printk>
    f60d:	48 8d 35 38 2e 02 00 	lea    0x22e38(%rip),%rsi        # 3244c <__func__.5785+0x17e4>
    f614:	48 8d 3d 91 2e 02 00 	lea    0x22e91(%rip),%rdi        # 324ac <__func__.5785+0x1844>
    f61b:	ba b2 18 00 00       	mov    $0x18b2,%edx
    f620:	31 c0                	xor    %eax,%eax
    f622:	e8 69 63 ff ff       	callq  5990 <printk>
    f627:	31 f6                	xor    %esi,%esi
    f629:	bf 03 00 00 00       	mov    $0x3,%edi
    f62e:	e8 b7 b2 01 00       	callq  2a8ea <z_fatal_error>
	handle_event(hdr->evt, buf, prio_events, ARRAY_SIZE(prio_events));
    f633:	41 0f b6 3e          	movzbl (%r14),%edi
    f637:	48 8d 15 c2 5c 22 00 	lea    0x225cc2(%rip),%rdx        # 235300 <prio_events>
    f63e:	b9 05 00 00 00       	mov    $0x5,%ecx
    f643:	48 89 de             	mov    %rbx,%rsi
    f646:	e8 73 e5 ff ff       	callq  dbbe <handle_event>
	if (evt_flags & BT_HCI_EVT_FLAG_RECV) {
    f64b:	41 80 e5 02          	and    $0x2,%r13b
    f64f:	74 19                	je     f66a <hci_event_prio+0x109>
	buf->data = buf->__buf + state->offset;
    f651:	0f b7 ed             	movzwl %bp,%ebp
    f654:	48 03 6b 20          	add    0x20(%rbx),%rbp
	buf->len = state->len;
    f658:	66 44 89 63 18       	mov    %r12w,0x18(%rbx)
	buf->data = buf->__buf + state->offset;
    f65d:	48 89 6b 10          	mov    %rbp,0x10(%rbx)
}
    f661:	5b                   	pop    %rbx
    f662:	5d                   	pop    %rbp
    f663:	41 5c                	pop    %r12
    f665:	41 5d                	pop    %r13
    f667:	41 5e                	pop    %r14
    f669:	c3                   	retq   
		net_buf_unref(buf);
    f66a:	48 89 df             	mov    %rbx,%rdi
}
    f66d:	5b                   	pop    %rbx
    f66e:	5d                   	pop    %rbp
    f66f:	41 5c                	pop    %r12
    f671:	41 5d                	pop    %r13
    f673:	41 5e                	pop    %r14
		net_buf_unref(buf);
    f675:	e9 20 99 00 00       	jmpq   18f9a <net_buf_unref>

000000000000f67a <bt_recv>:
{
    f67a:	41 54                	push   %r12
    f67c:	55                   	push   %rbp
    f67d:	53                   	push   %rbx
		->type;
    f67e:	0f b6 77 28          	movzbl 0x28(%rdi),%esi
    f682:	48 89 fb             	mov    %rdi,%rbx
	switch (bt_buf_get_type(buf)) {
    f685:	40 80 fe 01          	cmp    $0x1,%sil
    f689:	74 20                	je     f6ab <bt_recv+0x31>
    f68b:	40 80 fe 03          	cmp    $0x3,%sil
    f68f:	75 55                	jne    f6e6 <bt_recv+0x6c>
		net_buf_put(&bt_dev.rx_queue, buf);
    f691:	48 8d 05 a8 6f 22 00 	lea    0x226fa8(%rip),%rax        # 236640 <bt_dev>
    f698:	48 89 fe             	mov    %rdi,%rsi
		return 0;
    f69b:	31 ed                	xor    %ebp,%ebp
		net_buf_put(&bt_dev.rx_queue, buf);
    f69d:	48 8d b8 48 01 00 00 	lea    0x148(%rax),%rdi
    f6a4:	e8 d8 98 00 00       	callq  18f81 <net_buf_put>
		return 0;
    f6a9:	eb 6c                	jmp    f717 <bt_recv+0x9d>
		uint8_t evt_flags = bt_hci_evt_get_flags(hdr->evt);
    f6ab:	48 8b 47 10          	mov    0x10(%rdi),%rax
    f6af:	0f b6 38             	movzbl (%rax),%edi
    f6b2:	e8 b2 e0 ff ff       	callq  d769 <bt_hci_evt_get_flags>
		if (evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO) {
    f6b7:	a8 01                	test   $0x1,%al
		uint8_t evt_flags = bt_hci_evt_get_flags(hdr->evt);
    f6b9:	41 88 c4             	mov    %al,%r12b
		if (evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO) {
    f6bc:	74 08                	je     f6c6 <bt_recv+0x4c>
			hci_event_prio(buf);
    f6be:	48 89 df             	mov    %rbx,%rdi
    f6c1:	e8 9b fe ff ff       	callq  f561 <hci_event_prio>
		return 0;
    f6c6:	31 ed                	xor    %ebp,%ebp
		if (evt_flags & BT_HCI_EVT_FLAG_RECV) {
    f6c8:	41 80 e4 02          	and    $0x2,%r12b
    f6cc:	74 49                	je     f717 <bt_recv+0x9d>
			net_buf_put(&bt_dev.rx_queue, buf);
    f6ce:	48 8d 05 6b 6f 22 00 	lea    0x226f6b(%rip),%rax        # 236640 <bt_dev>
    f6d5:	48 89 de             	mov    %rbx,%rsi
    f6d8:	48 8d b8 48 01 00 00 	lea    0x148(%rax),%rdi
    f6df:	e8 9d 98 00 00       	callq  18f81 <net_buf_put>
    f6e4:	eb 31                	jmp    f717 <bt_recv+0x9d>
    f6e6:	48 8d 15 e3 ac 22 00 	lea    0x22ace3(%rip),%rdx        # 23a3d0 <log_const_bt_hci_core>
    f6ed:	48 2b 15 5c 68 22 00 	sub    0x22685c(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Invalid buf type %u", bt_buf_get_type(buf));
    f6f4:	48 8d 3d a1 30 02 00 	lea    0x230a1(%rip),%rdi        # 3279c <__func__.5785+0x1b34>
		return -EINVAL;
    f6fb:	bd ea ff ff ff       	mov    $0xffffffea,%ebp
    f700:	48 c1 ea 04          	shr    $0x4,%rdx
		BT_ERR("Invalid buf type %u", bt_buf_get_type(buf));
    f704:	c1 e2 06             	shl    $0x6,%edx
    f707:	83 ca 01             	or     $0x1,%edx
    f70a:	e8 e6 7b ff ff       	callq  72f5 <log_1>
		net_buf_unref(buf);
    f70f:	48 89 df             	mov    %rbx,%rdi
    f712:	e8 83 98 00 00       	callq  18f9a <net_buf_unref>
}
    f717:	89 e8                	mov    %ebp,%eax
    f719:	5b                   	pop    %rbx
    f71a:	5d                   	pop    %rbp
    f71b:	41 5c                	pop    %r12
    f71d:	c3                   	retq   

000000000000f71e <bt_hci_driver_register>:
	if (bt_dev.drv) {
    f71e:	48 8d 15 1b 6f 22 00 	lea    0x226f1b(%rip),%rdx        # 236640 <bt_dev>
		return -EALREADY;
    f725:	b8 8e ff ff ff       	mov    $0xffffff8e,%eax
	if (bt_dev.drv) {
    f72a:	48 83 ba a8 01 00 00 	cmpq   $0x0,0x1a8(%rdx)
    f731:	00 
    f732:	75 1a                	jne    f74e <bt_hci_driver_register+0x30>
		return -EINVAL;
    f734:	83 c0 5c             	add    $0x5c,%eax
	if (!drv->open || !drv->send) {
    f737:	48 83 7f 10 00       	cmpq   $0x0,0x10(%rdi)
    f73c:	74 10                	je     f74e <bt_hci_driver_register+0x30>
    f73e:	48 83 7f 18 00       	cmpq   $0x0,0x18(%rdi)
    f743:	74 09                	je     f74e <bt_hci_driver_register+0x30>
	bt_dev.drv = drv;
    f745:	48 89 ba a8 01 00 00 	mov    %rdi,0x1a8(%rdx)
	return 0;
    f74c:	31 c0                	xor    %eax,%eax
}
    f74e:	c3                   	retq   

000000000000f74f <bt_finalize_init>:
    f74f:	48 8d 05 ea 6e 22 00 	lea    0x226eea(%rip),%rax        # 236640 <bt_dev>
    f756:	be 02 00 00 00       	mov    $0x2,%esi
    f75b:	48 8d b8 a0 00 00 00 	lea    0xa0(%rax),%rdi
    f762:	e9 6b e0 ff ff       	jmpq   d7d2 <atomic_or>

000000000000f767 <bt_init>:
{
    f767:	41 55                	push   %r13
    f769:	41 54                	push   %r12
    f76b:	55                   	push   %rbp
    f76c:	53                   	push   %rbx
    f76d:	48 83 ec 28          	sub    $0x28,%rsp
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
    f771:	48 8d 2d c8 6e 22 00 	lea    0x226ec8(%rip),%rbp        # 236640 <bt_dev>
{
    f778:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    f77f:	00 00 
    f781:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    f786:	31 c0                	xor    %eax,%eax
    f788:	4c 8d 64 24 10       	lea    0x10(%rsp),%r12
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
    f78d:	48 8b 85 a8 01 00 00 	mov    0x1a8(%rbp),%rax
    f794:	f6 40 0c 01          	testb  $0x1,0xc(%rax)
    f798:	75 40                	jne    f7da <bt_init+0x73>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
    f79a:	31 f6                	xor    %esi,%esi
    f79c:	4c 89 e2             	mov    %r12,%rdx
    f79f:	bf 03 0c 00 00       	mov    $0xc03,%edi
    f7a4:	e8 12 ee ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
		if (err) {
    f7a9:	85 c0                	test   %eax,%eax
		err = bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
    f7ab:	89 c3                	mov    %eax,%ebx
		if (err) {
    f7ad:	0f 85 f9 04 00 00    	jne    fcac <bt_init+0x545>
		hci_reset_complete(rsp);
    f7b3:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
	uint8_t status = buf->data[0];
    f7b8:	48 8b 40 10          	mov    0x10(%rax),%rax
	if (status) {
    f7bc:	80 38 00             	cmpb   $0x0,(%rax)
    f7bf:	75 0f                	jne    f7d0 <bt_init+0x69>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    f7c1:	8b 85 a0 00 00 00    	mov    0xa0(%rbp),%eax
	flags = (atomic_get(bt_dev.flags) & BT_DEV_PERSISTENT_FLAGS);
    f7c7:	83 e0 05             	and    $0x5,%eax
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    f7ca:	87 85 a0 00 00 00    	xchg   %eax,0xa0(%rbp)
		net_buf_unref(rsp);
    f7d0:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
    f7d5:	e8 c0 97 00 00       	callq  18f9a <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
    f7da:	31 f6                	xor    %esi,%esi
    f7dc:	4c 89 e2             	mov    %r12,%rdx
    f7df:	bf 03 10 00 00       	mov    $0x1003,%edi
    f7e4:	e8 d2 ed ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
	if (err) {
    f7e9:	85 c0                	test   %eax,%eax
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
    f7eb:	89 c3                	mov    %eax,%ebx
	if (err) {
    f7ed:	0f 85 b9 04 00 00    	jne    fcac <bt_init+0x545>
	read_local_features_complete(rsp);
    f7f3:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
    f7f8:	48 8b 47 10          	mov    0x10(%rdi),%rax
    f7fc:	48 8b 40 01          	mov    0x1(%rax),%rax
    f800:	48 89 45 3c          	mov    %rax,0x3c(%rbp)
	net_buf_unref(rsp);
    f804:	e8 91 97 00 00       	callq  18f9a <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
    f809:	31 f6                	xor    %esi,%esi
    f80b:	4c 89 e2             	mov    %r12,%rdx
    f80e:	bf 01 10 00 00       	mov    $0x1001,%edi
    f813:	e8 a3 ed ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
	if (err) {
    f818:	85 c0                	test   %eax,%eax
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
    f81a:	89 c3                	mov    %eax,%ebx
	if (err) {
    f81c:	0f 85 8a 04 00 00    	jne    fcac <bt_init+0x545>
	read_local_ver_complete(rsp);
    f822:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
    f827:	48 8b 47 10          	mov    0x10(%rdi),%rax
	bt_dev.hci_version = rp->hci_version;
    f82b:	8a 50 01             	mov    0x1(%rax),%dl
    f82e:	88 55 34             	mov    %dl,0x34(%rbp)
	bt_dev.hci_revision = sys_le16_to_cpu(rp->hci_revision);
    f831:	66 8b 50 02          	mov    0x2(%rax),%dx
    f835:	66 89 55 36          	mov    %dx,0x36(%rbp)
	bt_dev.lmp_version = rp->lmp_version;
    f839:	8a 50 04             	mov    0x4(%rax),%dl
    f83c:	88 55 35             	mov    %dl,0x35(%rbp)
	bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
    f83f:	66 8b 50 07          	mov    0x7(%rax),%dx
	bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
    f843:	66 8b 40 05          	mov    0x5(%rax),%ax
	bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
    f847:	66 89 55 38          	mov    %dx,0x38(%rbp)
	bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
    f84b:	66 89 45 3a          	mov    %ax,0x3a(%rbp)
	net_buf_unref(rsp);
    f84f:	e8 46 97 00 00       	callq  18f9a <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
    f854:	31 f6                	xor    %esi,%esi
    f856:	4c 89 e2             	mov    %r12,%rdx
    f859:	bf 02 10 00 00       	mov    $0x1002,%edi
    f85e:	e8 58 ed ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
	if (err) {
    f863:	85 c0                	test   %eax,%eax
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
    f865:	89 c3                	mov    %eax,%ebx
	if (err) {
    f867:	0f 85 3f 04 00 00    	jne    fcac <bt_init+0x545>
	read_supported_commands_complete(rsp);
    f86d:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
    f872:	48 8d 7d 44          	lea    0x44(%rbp),%rdi
    f876:	48 8b 48 10          	mov    0x10(%rax),%rcx
    f87a:	48 8d 71 01          	lea    0x1(%rcx),%rsi
    f87e:	b9 10 00 00 00       	mov    $0x10,%ecx
    f883:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
	net_buf_unref(rsp);
    f885:	48 89 c7             	mov    %rax,%rdi
    f888:	e8 0d 97 00 00       	callq  18f9a <net_buf_unref>
		err = prng_init();
    f88d:	e8 b7 14 00 00       	callq  10d49 <prng_init>
		if (err) {
    f892:	85 c0                	test   %eax,%eax
		err = prng_init();
    f894:	89 c3                	mov    %eax,%ebx
		if (err) {
    f896:	0f 85 10 04 00 00    	jne    fcac <bt_init+0x545>
	if (!BT_CMD_TEST(bt_dev.supported_commands, 10, 5)) {
    f89c:	f6 45 4e 20          	testb  $0x20,0x4e(%rbp)
    f8a0:	75 29                	jne    f8cb <bt_init+0x164>
    f8a2:	48 8d 35 27 ab 22 00 	lea    0x22ab27(%rip),%rsi        # 23a3d0 <log_const_bt_hci_core>
    f8a9:	48 2b 35 a0 66 22 00 	sub    0x2266a0(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("Controller to host flow control not supported");
    f8b0:	48 8d 3d f9 2e 02 00 	lea    0x22ef9(%rip),%rdi        # 327b0 <__func__.5785+0x1b48>
    f8b7:	48 c1 ee 04          	shr    $0x4,%rsi
    f8bb:	c1 e6 06             	shl    $0x6,%esi
    f8be:	83 ce 02             	or     $0x2,%esi
    f8c1:	e8 fe 79 ff ff       	callq  72c4 <log_0>
    f8c6:	e9 a1 00 00 00       	jmpq   f96c <bt_init+0x205>
	buf = bt_hci_cmd_create(BT_HCI_OP_HOST_BUFFER_SIZE,
    f8cb:	be 07 00 00 00       	mov    $0x7,%esi
    f8d0:	bf 33 0c 00 00       	mov    $0xc33,%edi
    f8d5:	e8 43 ec ff ff       	callq  e51d <bt_hci_cmd_create>
	if (!buf) {
    f8da:	48 85 c0             	test   %rax,%rax
	buf = bt_hci_cmd_create(BT_HCI_OP_HOST_BUFFER_SIZE,
    f8dd:	48 89 c3             	mov    %rax,%rbx
	if (!buf) {
    f8e0:	0f 84 63 01 00 00    	je     fa49 <bt_init+0x2e2>
	return net_buf_simple_add(&buf->b, len);
    f8e6:	48 8d 78 10          	lea    0x10(%rax),%rdi
    f8ea:	be 07 00 00 00       	mov    $0x7,%esi
    f8ef:	e8 95 97 00 00       	callq  19089 <net_buf_simple_add>
    f8f4:	48 8d 70 02          	lea    0x2(%rax),%rsi
    f8f8:	48 89 c2             	mov    %rax,%rdx
    f8fb:	b9 05 00 00 00       	mov    $0x5,%ecx
    f900:	31 c0                	xor    %eax,%eax
    f902:	48 89 f7             	mov    %rsi,%rdi
	err = bt_hci_cmd_send_sync(BT_HCI_OP_HOST_BUFFER_SIZE, buf, NULL);
    f905:	48 89 de             	mov    %rbx,%rsi
    f908:	f3 aa                	rep stos %al,%es:(%rdi)
	hbs->acl_mtu = sys_cpu_to_le16(CONFIG_BT_L2CAP_RX_MTU +
    f90a:	66 c7 02 1b 00       	movw   $0x1b,(%rdx)
	hbs->acl_pkts = sys_cpu_to_le16(CONFIG_BT_ACL_RX_COUNT);
    f90f:	66 c7 42 03 06 00    	movw   $0x6,0x3(%rdx)
	err = bt_hci_cmd_send_sync(BT_HCI_OP_HOST_BUFFER_SIZE, buf, NULL);
    f915:	bf 33 0c 00 00       	mov    $0xc33,%edi
    f91a:	31 d2                	xor    %edx,%edx
    f91c:	e8 9a ec ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
	if (err) {
    f921:	85 c0                	test   %eax,%eax
	err = bt_hci_cmd_send_sync(BT_HCI_OP_HOST_BUFFER_SIZE, buf, NULL);
    f923:	89 c3                	mov    %eax,%ebx
	if (err) {
    f925:	0f 85 81 03 00 00    	jne    fcac <bt_init+0x545>
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_CTL_TO_HOST_FLOW, 1);
    f92b:	be 01 00 00 00       	mov    $0x1,%esi
    f930:	bf 31 0c 00 00       	mov    $0xc31,%edi
    f935:	e8 e3 eb ff ff       	callq  e51d <bt_hci_cmd_create>
	if (!buf) {
    f93a:	48 85 c0             	test   %rax,%rax
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_CTL_TO_HOST_FLOW, 1);
    f93d:	48 89 c3             	mov    %rax,%rbx
	if (!buf) {
    f940:	0f 84 03 01 00 00    	je     fa49 <bt_init+0x2e2>
	net_buf_add_u8(buf, BT_HCI_CTL_TO_HOST_FLOW_ENABLE);
    f946:	be 01 00 00 00       	mov    $0x1,%esi
    f94b:	48 89 c7             	mov    %rax,%rdi
    f94e:	e8 72 de ff ff       	callq  d7c5 <net_buf_add_u8>
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_CTL_TO_HOST_FLOW, buf, NULL);
    f953:	31 d2                	xor    %edx,%edx
    f955:	48 89 de             	mov    %rbx,%rsi
    f958:	bf 31 0c 00 00       	mov    $0xc31,%edi
    f95d:	e8 59 ec ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
	if (err) {
    f962:	85 c0                	test   %eax,%eax
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_CTL_TO_HOST_FLOW, buf, NULL);
    f964:	89 c3                	mov    %eax,%ebx
	if (err) {
    f966:	0f 85 40 03 00 00    	jne    fcac <bt_init+0x545>
	if (!BT_FEAT_LE(bt_dev.features)) {
    f96c:	f6 45 40 40          	testb  $0x40,0x40(%rbp)
    f970:	75 2e                	jne    f9a0 <bt_init+0x239>
    f972:	48 8d 35 57 aa 22 00 	lea    0x22aa57(%rip),%rsi        # 23a3d0 <log_const_bt_hci_core>
    f979:	48 2b 35 d0 65 22 00 	sub    0x2265d0(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Non-LE capable controller detected!");
    f980:	48 8d 3d 57 2e 02 00 	lea    0x22e57(%rip),%rdi        # 327de <__func__.5785+0x1b76>
		return -ENODEV;
    f987:	bb ed ff ff ff       	mov    $0xffffffed,%ebx
    f98c:	48 c1 ee 04          	shr    $0x4,%rsi
		BT_ERR("Non-LE capable controller detected!");
    f990:	c1 e6 06             	shl    $0x6,%esi
    f993:	83 ce 01             	or     $0x1,%esi
    f996:	e8 29 79 ff ff       	callq  72c4 <log_0>
    f99b:	e9 0c 03 00 00       	jmpq   fcac <bt_init+0x545>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
    f9a0:	31 f6                	xor    %esi,%esi
    f9a2:	4c 89 e2             	mov    %r12,%rdx
    f9a5:	bf 03 20 00 00       	mov    $0x2003,%edi
    f9aa:	e8 0c ec ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
	if (err) {
    f9af:	85 c0                	test   %eax,%eax
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
    f9b1:	89 c3                	mov    %eax,%ebx
	if (err) {
    f9b3:	0f 85 f3 02 00 00    	jne    fcac <bt_init+0x545>
	read_le_features_complete(rsp);
    f9b9:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
    f9be:	48 8b 47 10          	mov    0x10(%rdi),%rax
    f9c2:	48 8b 40 01          	mov    0x1(%rax),%rax
    f9c6:	48 89 85 a8 00 00 00 	mov    %rax,0xa8(%rbp)
	net_buf_unref(rsp);
    f9cd:	e8 c8 95 00 00       	callq  18f9a <net_buf_unref>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE,
    f9d2:	31 f6                	xor    %esi,%esi
    f9d4:	4c 89 e2             	mov    %r12,%rdx
    f9d7:	bf 02 20 00 00       	mov    $0x2002,%edi
    f9dc:	e8 da eb ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
		if (err) {
    f9e1:	85 c0                	test   %eax,%eax
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE,
    f9e3:	89 c3                	mov    %eax,%ebx
		if (err) {
    f9e5:	0f 85 c1 02 00 00    	jne    fcac <bt_init+0x545>
		le_read_buffer_size_complete(rsp);
    f9eb:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
    f9f0:	48 8b 40 10          	mov    0x10(%rax),%rax
	bt_dev.le.acl_mtu = sys_le16_to_cpu(rp->le_max_len);
    f9f4:	66 8b 50 01          	mov    0x1(%rax),%dx
	if (!bt_dev.le.acl_mtu) {
    f9f8:	66 85 d2             	test   %dx,%dx
	bt_dev.le.acl_mtu = sys_le16_to_cpu(rp->le_max_len);
    f9fb:	66 89 95 e8 00 00 00 	mov    %dx,0xe8(%rbp)
	if (!bt_dev.le.acl_mtu) {
    fa02:	74 12                	je     fa16 <bt_init+0x2af>
	k_sem_init(&bt_dev.le.acl_pkts, rp->le_max_num, rp->le_max_num);
    fa04:	0f b6 70 03          	movzbl 0x3(%rax),%esi
	return z_impl_k_sem_init(sem, initial_count, limit);
    fa08:	48 8d bd f0 00 00 00 	lea    0xf0(%rbp),%rdi
    fa0f:	89 f2                	mov    %esi,%edx
    fa11:	e8 f6 c4 01 00       	callq  2bf0c <z_impl_k_sem_init>
		net_buf_unref(rsp);
    fa16:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
    fa1b:	e8 7a 95 00 00       	callq  18f9a <net_buf_unref>
	if (BT_FEAT_BREDR(bt_dev.features)) {
    fa20:	f6 45 40 20          	testb  $0x20,0x40(%rbp)
    fa24:	74 0c                	je     fa32 <bt_init+0x2cb>
	if (BT_CMD_LE_STATES(bt_dev.supported_commands)) {
    fa26:	f6 45 60 08          	testb  $0x8,0x60(%rbp)
    fa2a:	0f 84 82 00 00 00    	je     fab2 <bt_init+0x34b>
    fa30:	eb 4e                	jmp    fa80 <bt_init+0x319>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP,
    fa32:	be 02 00 00 00       	mov    $0x2,%esi
    fa37:	bf 6d 0c 00 00       	mov    $0xc6d,%edi
    fa3c:	e8 dc ea ff ff       	callq  e51d <bt_hci_cmd_create>
		if (!buf) {
    fa41:	48 85 c0             	test   %rax,%rax
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP,
    fa44:	48 89 c3             	mov    %rax,%rbx
		if (!buf) {
    fa47:	75 0a                	jne    fa53 <bt_init+0x2ec>
			return -ENOBUFS;
    fa49:	bb 97 ff ff ff       	mov    $0xffffff97,%ebx
    fa4e:	e9 59 02 00 00       	jmpq   fcac <bt_init+0x545>
    fa53:	48 8d 78 10          	lea    0x10(%rax),%rdi
    fa57:	be 02 00 00 00       	mov    $0x2,%esi
    fa5c:	e8 28 96 00 00       	callq  19089 <net_buf_simple_add>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
    fa61:	31 d2                	xor    %edx,%edx
    fa63:	48 89 de             	mov    %rbx,%rsi
		cp_le->le = 0x01;
    fa66:	66 c7 00 01 00       	movw   $0x1,(%rax)
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
    fa6b:	bf 6d 0c 00 00       	mov    $0xc6d,%edi
    fa70:	e8 46 eb ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
		if (err) {
    fa75:	85 c0                	test   %eax,%eax
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
    fa77:	89 c3                	mov    %eax,%ebx
		if (err) {
    fa79:	74 ab                	je     fa26 <bt_init+0x2bf>
    fa7b:	e9 2c 02 00 00       	jmpq   fcac <bt_init+0x545>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
    fa80:	31 f6                	xor    %esi,%esi
    fa82:	4c 89 e2             	mov    %r12,%rdx
    fa85:	bf 1c 20 00 00       	mov    $0x201c,%edi
    fa8a:	e8 2c eb ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
		if (err) {
    fa8f:	85 c0                	test   %eax,%eax
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
    fa91:	89 c3                	mov    %eax,%ebx
		if (err) {
    fa93:	0f 85 13 02 00 00    	jne    fcac <bt_init+0x545>
		le_read_supp_states_complete(rsp);
    fa99:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
 *
 *  @return 64-bit integer in host endianness.
 */
static inline uint64_t sys_get_le64(const uint8_t src[8])
{
	return ((uint64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
    fa9e:	48 8b 47 10          	mov    0x10(%rdi),%rax
    faa2:	48 8b 40 01          	mov    0x1(%rax),%rax
	bt_dev.le.states = sys_get_le64(rp->le_states);
    faa6:	48 89 85 b0 00 00 00 	mov    %rax,0xb0(%rbp)
		net_buf_unref(rsp);
    faad:	e8 e8 94 00 00       	callq  18f9a <net_buf_unref>
	if (IS_ENABLED(CONFIG_BT_CONN) &&
    fab2:	f6 85 a8 00 00 00 20 	testb  $0x20,0xa8(%rbp)
    fab9:	74 70                	je     fb2b <bt_init+0x3c4>
		err = hci_le_read_max_data_len(&tx_octets, &tx_time);
    fabb:	48 8d 74 24 0e       	lea    0xe(%rsp),%rsi
    fac0:	48 8d 7c 24 0c       	lea    0xc(%rsp),%rdi
    fac5:	e8 80 ec ff ff       	callq  e74a <hci_le_read_max_data_len>
		if (err) {
    faca:	85 c0                	test   %eax,%eax
		err = hci_le_read_max_data_len(&tx_octets, &tx_time);
    facc:	89 c3                	mov    %eax,%ebx
		if (err) {
    face:	0f 85 d8 01 00 00    	jne    fcac <bt_init+0x545>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
    fad4:	be 04 00 00 00       	mov    $0x4,%esi
    fad9:	bf 24 20 00 00       	mov    $0x2024,%edi
			return -ENOBUFS;
    fade:	bb 97 ff ff ff       	mov    $0xffffff97,%ebx
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
    fae3:	e8 35 ea ff ff       	callq  e51d <bt_hci_cmd_create>
		if (!buf) {
    fae8:	48 85 c0             	test   %rax,%rax
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
    faeb:	49 89 c5             	mov    %rax,%r13
		if (!buf) {
    faee:	0f 84 b8 01 00 00    	je     fcac <bt_init+0x545>
    faf4:	48 8d 78 10          	lea    0x10(%rax),%rdi
    faf8:	be 04 00 00 00       	mov    $0x4,%esi
    fafd:	e8 87 95 00 00       	callq  19089 <net_buf_simple_add>
		cp->max_tx_octets = sys_cpu_to_le16(tx_octets);
    fb02:	8b 54 24 0c          	mov    0xc(%rsp),%edx
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
    fb06:	4c 89 ee             	mov    %r13,%rsi
    fb09:	bf 24 20 00 00       	mov    $0x2024,%edi
		cp->max_tx_octets = sys_cpu_to_le16(tx_octets);
    fb0e:	66 89 10             	mov    %dx,(%rax)
		cp->max_tx_time = sys_cpu_to_le16(tx_time);
    fb11:	66 8b 54 24 0e       	mov    0xe(%rsp),%dx
    fb16:	66 89 50 02          	mov    %dx,0x2(%rax)
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
    fb1a:	31 d2                	xor    %edx,%edx
    fb1c:	e8 9a ea ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
		if (err) {
    fb21:	85 c0                	test   %eax,%eax
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
    fb23:	89 c3                	mov    %eax,%ebx
		if (err) {
    fb25:	0f 85 81 01 00 00    	jne    fcac <bt_init+0x545>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
    fb2b:	be 08 00 00 00       	mov    $0x8,%esi
    fb30:	bf 01 20 00 00       	mov    $0x2001,%edi
    fb35:	e8 e3 e9 ff ff       	callq  e51d <bt_hci_cmd_create>
	if (!buf) {
    fb3a:	48 85 c0             	test   %rax,%rax
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
    fb3d:	48 89 c3             	mov    %rax,%rbx
	if (!buf) {
    fb40:	0f 84 03 ff ff ff    	je     fa49 <bt_init+0x2e2>
    fb46:	48 8d 78 10          	lea    0x10(%rax),%rdi
    fb4a:	be 08 00 00 00       	mov    $0x8,%esi
    fb4f:	e8 35 95 00 00       	callq  19089 <net_buf_simple_add>
		if (BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features)) {
    fb54:	8a 95 a8 00 00 00    	mov    0xa8(%rbp),%dl
    fb5a:	88 d1                	mov    %dl,%cl
    fb5c:	83 e1 02             	and    $0x2,%ecx
			mask |= BT_EVT_MASK_LE_CONN_PARAM_REQ;
    fb5f:	80 f9 01             	cmp    $0x1,%cl
    fb62:	48 19 ff             	sbb    %rdi,%rdi
    fb65:	48 83 e7 e0          	and    $0xffffffffffffffe0,%rdi
    fb69:	48 83 c7 2f          	add    $0x2f,%rdi
		if (IS_ENABLED(CONFIG_BT_DATA_LEN_UPDATE) &&
    fb6d:	80 e2 20             	and    $0x20,%dl
    fb70:	74 04                	je     fb76 <bt_init+0x40f>
			mask |= BT_EVT_MASK_LE_DATA_LEN_CHANGE;
    fb72:	48 83 cf 40          	or     $0x40,%rdi
		if (IS_ENABLED(CONFIG_BT_PHY_UPDATE) &&
    fb76:	f6 85 a9 00 00 00 09 	testb  $0x9,0xa9(%rbp)
    fb7d:	74 07                	je     fb86 <bt_init+0x41f>
			mask |= BT_EVT_MASK_LE_PHY_UPDATE_COMPLETE;
    fb7f:	48 81 cf 00 08 00 00 	or     $0x800,%rdi
	sys_put_le64(mask, cp_mask->events);
    fb86:	48 89 c6             	mov    %rax,%rsi
    fb89:	e8 1b e7 ff ff       	callq  e2a9 <sys_put_le64>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
    fb8e:	31 d2                	xor    %edx,%edx
    fb90:	48 89 de             	mov    %rbx,%rsi
    fb93:	bf 01 20 00 00       	mov    $0x2001,%edi
    fb98:	e8 1e ea ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
	if (err) {
    fb9d:	85 c0                	test   %eax,%eax
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
    fb9f:	89 c3                	mov    %eax,%ebx
	if (err) {
    fba1:	0f 85 05 01 00 00    	jne    fcac <bt_init+0x545>
	if (BT_FEAT_BREDR(bt_dev.features)) {
    fba7:	f6 45 40 20          	testb  $0x20,0x40(%rbp)
    fbab:	75 5d                	jne    fc0a <bt_init+0x4a3>
	if (bt_dev.le.acl_mtu) {
    fbad:	66 83 bd e8 00 00 00 	cmpw   $0x0,0xe8(%rbp)
    fbb4:	00 
    fbb5:	75 53                	jne    fc0a <bt_init+0x4a3>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BUFFER_SIZE, NULL, &rsp);
    fbb7:	31 f6                	xor    %esi,%esi
    fbb9:	4c 89 e2             	mov    %r12,%rdx
    fbbc:	bf 05 10 00 00       	mov    $0x1005,%edi
    fbc1:	e8 f5 e9 ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
	if (err) {
    fbc6:	85 c0                	test   %eax,%eax
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BUFFER_SIZE, NULL, &rsp);
    fbc8:	89 c3                	mov    %eax,%ebx
	if (err) {
    fbca:	0f 85 dc 00 00 00    	jne    fcac <bt_init+0x545>
	if (bt_dev.le.acl_mtu) {
    fbd0:	66 83 bd e8 00 00 00 	cmpw   $0x0,0xe8(%rbp)
    fbd7:	00 
    fbd8:	75 26                	jne    fc00 <bt_init+0x499>
	read_buffer_size_complete(rsp);
    fbda:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
    fbdf:	48 8b 40 10          	mov    0x10(%rax),%rax
	bt_dev.le.acl_mtu = sys_le16_to_cpu(rp->acl_max_len);
    fbe3:	66 8b 50 01          	mov    0x1(%rax),%dx
	k_sem_init(&bt_dev.le.acl_pkts, pkts, pkts);
    fbe7:	0f b7 70 04          	movzwl 0x4(%rax),%esi
	bt_dev.le.acl_mtu = sys_le16_to_cpu(rp->acl_max_len);
    fbeb:	66 89 95 e8 00 00 00 	mov    %dx,0xe8(%rbp)
    fbf2:	48 8d bd f0 00 00 00 	lea    0xf0(%rbp),%rdi
    fbf9:	89 f2                	mov    %esi,%edx
    fbfb:	e8 0c c3 01 00       	callq  2bf0c <z_impl_k_sem_init>
	net_buf_unref(rsp);
    fc00:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
    fc05:	e8 90 93 00 00       	callq  18f9a <net_buf_unref>
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_EVENT_MASK, sizeof(*ev));
    fc0a:	be 08 00 00 00       	mov    $0x8,%esi
    fc0f:	bf 01 0c 00 00       	mov    $0xc01,%edi
		return -ENOBUFS;
    fc14:	bb 97 ff ff ff       	mov    $0xffffff97,%ebx
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_EVENT_MASK, sizeof(*ev));
    fc19:	e8 ff e8 ff ff       	callq  e51d <bt_hci_cmd_create>
	if (!buf) {
    fc1e:	48 85 c0             	test   %rax,%rax
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_EVENT_MASK, sizeof(*ev));
    fc21:	49 89 c4             	mov    %rax,%r12
	if (!buf) {
    fc24:	0f 84 82 00 00 00    	je     fcac <bt_init+0x545>
    fc2a:	48 8d 78 10          	lea    0x10(%rax),%rdi
    fc2e:	be 08 00 00 00       	mov    $0x8,%esi
    fc33:	e8 51 94 00 00       	callq  19089 <net_buf_simple_add>
	sys_put_le64(mask, ev->events);
    fc38:	48 bf 10 88 00 02 00 	movabs $0x2000000002008810,%rdi
    fc3f:	00 00 20 
    fc42:	48 89 c6             	mov    %rax,%rsi
    fc45:	e8 5f e6 ff ff       	callq  e2a9 <sys_put_le64>
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
    fc4a:	31 d2                	xor    %edx,%edx
    fc4c:	4c 89 e6             	mov    %r12,%rsi
    fc4f:	bf 01 0c 00 00       	mov    $0xc01,%edi
    fc54:	e8 62 e9 ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
	if (err) {
    fc59:	85 c0                	test   %eax,%eax
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
    fc5b:	89 c3                	mov    %eax,%ebx
	if (err) {
    fc5d:	75 4d                	jne    fcac <bt_init+0x545>
		err = bt_conn_init();
    fc5f:	e8 6b 23 00 00       	callq  11fcf <bt_conn_init>
		if (err) {
    fc64:	85 c0                	test   %eax,%eax
		err = bt_conn_init();
    fc66:	89 c3                	mov    %eax,%ebx
		if (err) {
    fc68:	75 42                	jne    fcac <bt_init+0x545>
		if (!bt_dev.id_count) {
    fc6a:	80 7d 07 00          	cmpb   $0x0,0x7(%rbp)
    fc6e:	75 26                	jne    fc96 <bt_init+0x52f>
    fc70:	48 8d 35 59 a7 22 00 	lea    0x22a759(%rip),%rsi        # 23a3d0 <log_const_bt_hci_core>
    fc77:	48 2b 35 d2 62 22 00 	sub    0x2262d2(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_INFO("No ID address. App must call settings_load()");
    fc7e:	48 8d 3d 7d 2b 02 00 	lea    0x22b7d(%rip),%rdi        # 32802 <__func__.5785+0x1b9a>
    fc85:	48 c1 ee 04          	shr    $0x4,%rsi
    fc89:	c1 e6 06             	shl    $0x6,%esi
    fc8c:	83 ce 03             	or     $0x3,%esi
    fc8f:	e8 30 76 ff ff       	callq  72c4 <log_0>
    fc94:	eb 16                	jmp    fcac <bt_init+0x545>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    fc96:	48 8d bd a0 00 00 00 	lea    0xa0(%rbp),%rdi
    fc9d:	be 04 00 00 00       	mov    $0x4,%esi
    fca2:	e8 2b db ff ff       	callq  d7d2 <atomic_or>
	bt_finalize_init();
    fca7:	e8 a3 fa ff ff       	callq  f74f <bt_finalize_init>
}
    fcac:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    fcb1:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    fcb8:	00 00 
    fcba:	89 d8                	mov    %ebx,%eax
    fcbc:	74 05                	je     fcc3 <bt_init+0x55c>
    fcbe:	e8 7d 49 ff ff       	callq  4640 <__stack_chk_fail@plt>
    fcc3:	48 83 c4 28          	add    $0x28,%rsp
    fcc7:	5b                   	pop    %rbx
    fcc8:	5d                   	pop    %rbp
    fcc9:	41 5c                	pop    %r12
    fccb:	41 5d                	pop    %r13
    fccd:	c3                   	retq   

000000000000fcce <init_work>:
{
    fcce:	48 83 ec 08          	sub    $0x8,%rsp
	err = bt_init();
    fcd2:	e8 90 fa ff ff       	callq  f767 <bt_init>
	if (ready_cb) {
    fcd7:	48 8b 15 ba 82 24 00 	mov    0x2482ba(%rip),%rdx        # 257f98 <ready_cb>
    fcde:	48 85 d2             	test   %rdx,%rdx
    fce1:	74 05                	je     fce8 <init_work+0x1a>
}
    fce3:	59                   	pop    %rcx
		ready_cb(err);
    fce4:	89 c7                	mov    %eax,%edi
    fce6:	ff e2                	jmpq   *%rdx
}
    fce8:	58                   	pop    %rax
    fce9:	c3                   	retq   

000000000000fcea <bt_enable>:
{
    fcea:	41 54                	push   %r12
    fcec:	55                   	push   %rbp
	if (!bt_dev.drv) {
    fced:	48 8d 2d 4c 69 22 00 	lea    0x22694c(%rip),%rbp        # 236640 <bt_dev>
{
    fcf4:	53                   	push   %rbx
	if (!bt_dev.drv) {
    fcf5:	48 83 bd a8 01 00 00 	cmpq   $0x0,0x1a8(%rbp)
    fcfc:	00 
    fcfd:	75 2e                	jne    fd2d <bt_enable+0x43>
    fcff:	48 8d 35 ca a6 22 00 	lea    0x22a6ca(%rip),%rsi        # 23a3d0 <log_const_bt_hci_core>
    fd06:	48 2b 35 43 62 22 00 	sub    0x226243(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("No HCI driver registered");
    fd0d:	48 8d 3d 1b 2b 02 00 	lea    0x22b1b(%rip),%rdi        # 3282f <__func__.5785+0x1bc7>
		return -ENODEV;
    fd14:	bb ed ff ff ff       	mov    $0xffffffed,%ebx
    fd19:	48 c1 ee 04          	shr    $0x4,%rsi
		BT_ERR("No HCI driver registered");
    fd1d:	c1 e6 06             	shl    $0x6,%esi
    fd20:	83 ce 01             	or     $0x1,%esi
    fd23:	e8 9c 75 ff ff       	callq  72c4 <log_0>
		return -ENODEV;
    fd28:	e9 30 01 00 00       	jmpq   fe5d <bt_enable+0x173>
    fd2d:	49 89 fc             	mov    %rdi,%r12
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
    fd30:	48 8d bd a0 00 00 00 	lea    0xa0(%rbp),%rdi
    fd37:	be 01 00 00 00       	mov    $0x1,%esi
    fd3c:	e8 91 da ff ff       	callq  d7d2 <atomic_or>
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_ENABLE)) {
    fd41:	a8 01                	test   $0x1,%al
    fd43:	0f 85 0f 01 00 00    	jne    fe58 <bt_enable+0x16e>
		err = bt_settings_init();
    fd49:	e8 4b d7 ff ff       	callq  d499 <bt_settings_init>
		if (err) {
    fd4e:	85 c0                	test   %eax,%eax
		err = bt_settings_init();
    fd50:	89 c3                	mov    %eax,%ebx
		if (err) {
    fd52:	0f 85 05 01 00 00    	jne    fe5d <bt_enable+0x173>
	ready_cb = cb;
    fd58:	4c 89 25 39 82 24 00 	mov    %r12,0x248239(%rip)        # 257f98 <ready_cb>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    fd5f:	48 8d 0d ae f5 ff ff 	lea    -0xa52(%rip),%rcx        # f314 <hci_tx_thread>
    fd66:	6a 00                	pushq  $0x0
    fd68:	48 8d 35 71 7e 22 00 	lea    0x227e71(%rip),%rsi        # 237be0 <tx_thread_stack>
    fd6f:	6a 00                	pushq  $0x0
    fd71:	48 8d 3d 68 71 24 00 	lea    0x247168(%rip),%rdi        # 256ee0 <tx_thread_data>
    fd78:	6a f7                	pushq  $0xfffffffffffffff7
    fd7a:	6a 00                	pushq  $0x0
    fd7c:	45 31 c9             	xor    %r9d,%r9d
    fd7f:	45 31 c0             	xor    %r8d,%r8d
    fd82:	ba 00 02 00 00       	mov    $0x200,%edx
    fd87:	e8 84 c3 01 00       	callq  2c110 <z_impl_k_thread_create>
    fd8c:	48 83 c4 20          	add    $0x20,%rsp
	return z_impl_k_thread_name_set(thread_id, value);
    fd90:	48 8d 35 b1 2a 02 00 	lea    0x22ab1(%rip),%rsi        # 32848 <__func__.5785+0x1be0>
    fd97:	48 8d 3d 42 71 24 00 	lea    0x247142(%rip),%rdi        # 256ee0 <tx_thread_data>
    fd9e:	e8 8a c2 01 00       	callq  2c02d <z_impl_k_thread_name_set>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    fda3:	48 8d 0d d2 de ff ff 	lea    -0x212e(%rip),%rcx        # dc7c <hci_rx_thread>
    fdaa:	6a 00                	pushq  $0x0
    fdac:	48 8d 35 2d 80 22 00 	lea    0x22802d(%rip),%rsi        # 237de0 <rx_thread_stack>
    fdb3:	6a 00                	pushq  $0x0
    fdb5:	48 8d 3d c4 71 24 00 	lea    0x2471c4(%rip),%rdi        # 256f80 <rx_thread_data>
    fdbc:	6a f8                	pushq  $0xfffffffffffffff8
    fdbe:	6a 00                	pushq  $0x0
    fdc0:	45 31 c9             	xor    %r9d,%r9d
    fdc3:	45 31 c0             	xor    %r8d,%r8d
    fdc6:	ba 98 08 00 00       	mov    $0x898,%edx
    fdcb:	e8 40 c3 01 00       	callq  2c110 <z_impl_k_thread_create>
    fdd0:	48 83 c4 20          	add    $0x20,%rsp
	return z_impl_k_thread_name_set(thread_id, value);
    fdd4:	48 8d 35 73 2a 02 00 	lea    0x22a73(%rip),%rsi        # 3284e <__func__.5785+0x1be6>
    fddb:	48 8d 3d 9e 71 24 00 	lea    0x24719e(%rip),%rdi        # 256f80 <rx_thread_data>
    fde2:	e8 46 c2 01 00       	callq  2c02d <z_impl_k_thread_name_set>
	err = bt_dev.drv->open();
    fde7:	48 8b 85 a8 01 00 00 	mov    0x1a8(%rbp),%rax
    fdee:	ff 50 10             	callq  *0x10(%rax)
	if (err) {
    fdf1:	85 c0                	test   %eax,%eax
	err = bt_dev.drv->open();
    fdf3:	89 c3                	mov    %eax,%ebx
	if (err) {
    fdf5:	74 29                	je     fe20 <bt_enable+0x136>
    fdf7:	48 8d 15 d2 a5 22 00 	lea    0x22a5d2(%rip),%rdx        # 23a3d0 <log_const_bt_hci_core>
    fdfe:	48 2b 15 4b 61 22 00 	sub    0x22614b(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("HCI driver open failed (%d)", err);
    fe05:	48 8d 3d 48 2a 02 00 	lea    0x22a48(%rip),%rdi        # 32854 <__func__.5785+0x1bec>
    fe0c:	48 63 f0             	movslq %eax,%rsi
    fe0f:	48 c1 ea 04          	shr    $0x4,%rdx
    fe13:	c1 e2 06             	shl    $0x6,%edx
    fe16:	83 ca 01             	or     $0x1,%edx
    fe19:	e8 d7 74 ff ff       	callq  72f5 <log_1>
		return err;
    fe1e:	eb 3d                	jmp    fe5d <bt_enable+0x173>
	if (!cb) {
    fe20:	4d 85 e4             	test   %r12,%r12
    fe23:	75 09                	jne    fe2e <bt_enable+0x144>
}
    fe25:	5b                   	pop    %rbx
    fe26:	5d                   	pop    %rbp
    fe27:	41 5c                	pop    %r12
		return bt_init();
    fe29:	e9 39 f9 ff ff       	jmpq   f767 <bt_init>
    fe2e:	48 8d bd 98 00 00 00 	lea    0x98(%rbp),%rdi
    fe35:	be 01 00 00 00       	mov    $0x1,%esi
    fe3a:	e8 93 d9 ff ff       	callq  d7d2 <atomic_or>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    fe3f:	a8 01                	test   $0x1,%al
    fe41:	75 1a                	jne    fe5d <bt_enable+0x173>
		k_queue_append(&work_q->queue, work);
    fe43:	48 8d 3d 56 7d 24 00 	lea    0x247d56(%rip),%rdi        # 257ba0 <k_sys_work_q>
    fe4a:	48 8d b5 88 00 00 00 	lea    0x88(%rbp),%rsi
    fe51:	e8 d5 b4 01 00       	callq  2b32b <k_queue_append>
    fe56:	eb 05                	jmp    fe5d <bt_enable+0x173>
		return -EALREADY;
    fe58:	bb 8e ff ff ff       	mov    $0xffffff8e,%ebx
}
    fe5d:	89 d8                	mov    %ebx,%eax
    fe5f:	5b                   	pop    %rbx
    fe60:	5d                   	pop    %rbp
    fe61:	41 5c                	pop    %r12
    fe63:	c3                   	retq   

000000000000fe64 <bt_set_name>:
{
    fe64:	41 55                	push   %r13
    fe66:	41 54                	push   %r12
    fe68:	55                   	push   %rbp
    fe69:	53                   	push   %rbx
    fe6a:	48 89 fd             	mov    %rdi,%rbp
    fe6d:	48 83 ec 38          	sub    $0x38,%rsp
    fe71:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    fe78:	00 00 
    fe7a:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    fe7f:	31 c0                	xor    %eax,%eax
	struct bt_le_ext_adv *adv = bt_adv_lookup_legacy();
    fe81:	e8 f2 ec ff ff       	callq  eb78 <bt_adv_lookup_legacy>
	size_t len = strlen(name);
    fe86:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
	struct bt_le_ext_adv *adv = bt_adv_lookup_legacy();
    fe8a:	49 89 c4             	mov    %rax,%r12
	size_t len = strlen(name);
    fe8d:	48 89 ef             	mov    %rbp,%rdi
    fe90:	31 c0                	xor    %eax,%eax
    fe92:	f2 ae                	repnz scas %es:(%rdi),%al
		return -ENOMEM;
    fe94:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	size_t len = strlen(name);
    fe99:	48 89 ca             	mov    %rcx,%rdx
    fe9c:	48 f7 d2             	not    %rdx
    fe9f:	48 8d 5a ff          	lea    -0x1(%rdx),%rbx
	if (len > CONFIG_BT_DEVICE_NAME_MAX) {
    fea3:	48 83 fb 41          	cmp    $0x41,%rbx
    fea7:	0f 87 c8 00 00 00    	ja     ff75 <bt_set_name+0x111>
	if (!strcmp(bt_dev.name, name)) {
    fead:	4c 8d 2d 8c 67 22 00 	lea    0x22678c(%rip),%r13        # 236640 <bt_dev>
    feb4:	48 89 ee             	mov    %rbp,%rsi
    feb7:	49 8d bd b0 01 00 00 	lea    0x1b0(%r13),%rdi
    febe:	e8 ed 47 ff ff       	callq  46b0 <strcmp@plt>
    fec3:	85 c0                	test   %eax,%eax
    fec5:	0f 84 a8 00 00 00    	je     ff73 <bt_set_name+0x10f>
  return __builtin___strncpy_chk (__dest, __src, __len, __bos (__dest));
    fecb:	49 8d bd b0 01 00 00 	lea    0x1b0(%r13),%rdi
    fed2:	b9 42 00 00 00       	mov    $0x42,%ecx
    fed7:	48 89 da             	mov    %rbx,%rdx
    feda:	48 89 ee             	mov    %rbp,%rsi
    fedd:	e8 9e 45 ff ff       	callq  4480 <__strncpy_chk@plt>
	if (adv && atomic_test_bit(adv->flags, BT_ADV_INCLUDE_NAME)) {
    fee2:	4d 85 e4             	test   %r12,%r12
	bt_dev.name[len] = '\0';
    fee5:	41 c6 84 1d b0 01 00 	movb   $0x0,0x1b0(%r13,%rbx,1)
    feec:	00 00 
	if (adv && atomic_test_bit(adv->flags, BT_ADV_INCLUDE_NAME)) {
    feee:	74 45                	je     ff35 <bt_set_name+0xd1>
    fef0:	49 8d 7c 24 10       	lea    0x10(%r12),%rdi
    fef5:	be 07 00 00 00       	mov    $0x7,%esi
    fefa:	e8 35 e0 ff ff       	callq  df34 <atomic_test_bit>
    feff:	84 c0                	test   %al,%al
    ff01:	74 32                	je     ff35 <bt_set_name+0xd1>
		struct bt_ad sd = { data, ARRAY_SIZE(data) };
    ff03:	48 8d 44 24 10       	lea    0x10(%rsp),%rax
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
    ff08:	48 89 e6             	mov    %rsp,%rsi
    ff0b:	ba 01 00 00 00       	mov    $0x1,%edx
    ff10:	bf 09 20 00 00       	mov    $0x2009,%edi
		struct bt_data data[] = { BT_DATA(BT_DATA_NAME_COMPLETE, name,
    ff15:	c6 44 24 10 09       	movb   $0x9,0x10(%rsp)
    ff1a:	88 5c 24 11          	mov    %bl,0x11(%rsp)
    ff1e:	48 89 6c 24 18       	mov    %rbp,0x18(%rsp)
		struct bt_ad sd = { data, ARRAY_SIZE(data) };
    ff23:	48 89 04 24          	mov    %rax,(%rsp)
    ff27:	48 c7 44 24 08 01 00 	movq   $0x1,0x8(%rsp)
    ff2e:	00 00 
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
    ff30:	e8 ac e8 ff ff       	callq  e7e1 <hci_set_ad>
		err = settings_save_one("bt/name", bt_dev.name, len);
    ff35:	49 8d b5 b0 01 00 00 	lea    0x1b0(%r13),%rsi
    ff3c:	48 8d 3d 2d 29 02 00 	lea    0x2292d(%rip),%rdi        # 32870 <__func__.5785+0x1c08>
    ff43:	48 89 da             	mov    %rbx,%rdx
    ff46:	e8 2f 84 ff ff       	callq  837a <settings_save_one>
		if (err) {
    ff4b:	85 c0                	test   %eax,%eax
    ff4d:	74 24                	je     ff73 <bt_set_name+0x10f>
    ff4f:	48 8d 35 7a a4 22 00 	lea    0x22a47a(%rip),%rsi        # 23a3d0 <log_const_bt_hci_core>
    ff56:	48 2b 35 f3 5f 22 00 	sub    0x225ff3(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_WARN("Unable to store name");
    ff5d:	48 8d 3d 14 29 02 00 	lea    0x22914(%rip),%rdi        # 32878 <__func__.5785+0x1c10>
    ff64:	48 c1 ee 04          	shr    $0x4,%rsi
    ff68:	c1 e6 06             	shl    $0x6,%esi
    ff6b:	83 ce 02             	or     $0x2,%esi
    ff6e:	e8 51 73 ff ff       	callq  72c4 <log_0>
	return 0;
    ff73:	31 c0                	xor    %eax,%eax
}
    ff75:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
    ff7a:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
    ff81:	00 00 
    ff83:	74 05                	je     ff8a <bt_set_name+0x126>
    ff85:	e8 b6 46 ff ff       	callq  4640 <__stack_chk_fail@plt>
    ff8a:	48 83 c4 38          	add    $0x38,%rsp
    ff8e:	5b                   	pop    %rbx
    ff8f:	5d                   	pop    %rbp
    ff90:	41 5c                	pop    %r12
    ff92:	41 5d                	pop    %r13
    ff94:	c3                   	retq   

000000000000ff95 <bt_get_name>:
	return bt_dev.name;
    ff95:	48 8d 05 a4 66 22 00 	lea    0x2266a4(%rip),%rax        # 236640 <bt_dev>
}
    ff9c:	48 05 b0 01 00 00    	add    $0x1b0,%rax
    ffa2:	c3                   	retq   

000000000000ffa3 <le_adv_update.constprop.28>:
static int le_adv_update(struct bt_le_ext_adv *adv,
    ffa3:	41 57                	push   %r15
    ffa5:	41 56                	push   %r14
    ffa7:	49 89 cf             	mov    %rcx,%r15
    ffaa:	41 55                	push   %r13
    ffac:	41 54                	push   %r12
	struct bt_ad d[2] = {};
    ffae:	b9 08 00 00 00       	mov    $0x8,%ecx
static int le_adv_update(struct bt_le_ext_adv *adv,
    ffb3:	55                   	push   %rbp
    ffb4:	53                   	push   %rbx
    ffb5:	4d 89 c5             	mov    %r8,%r13
    ffb8:	48 89 d3             	mov    %rdx,%rbx
    ffbb:	45 89 ce             	mov    %r9d,%r14d
    ffbe:	48 83 ec 58          	sub    $0x58,%rsp
    ffc2:	8b ac 24 90 00 00 00 	mov    0x90(%rsp),%ebp
    ffc9:	48 89 3c 24          	mov    %rdi,(%rsp)
	struct bt_ad d[2] = {};
    ffcd:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
static int le_adv_update(struct bt_le_ext_adv *adv,
    ffd2:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    ffd9:	00 00 
    ffdb:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    ffe0:	31 c0                	xor    %eax,%eax
    ffe2:	4c 8d 64 24 20       	lea    0x20(%rsp),%r12
	if (use_name) {
    ffe7:	40 84 ed             	test   %bpl,%bpl
	struct bt_ad d[2] = {};
    ffea:	f3 ab                	rep stos %eax,%es:(%rdi)
	if (use_name) {
    ffec:	0f 84 83 00 00 00    	je     10075 <le_adv_update.constprop.28+0xd2>
    fff2:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
		const char *name = bt_get_name();
    fff7:	e8 99 ff ff ff       	callq  ff95 <bt_get_name>
		if ((ad && ad_has_name(ad, ad_len)) ||
    fffc:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
		const char *name = bt_get_name();
   10001:	49 89 c0             	mov    %rax,%r8
	for (i = 0; i < ad_len; i++) {
   10004:	31 c0                	xor    %eax,%eax
		if ((ad && ad_has_name(ad, ad_len)) ||
   10006:	48 85 f6             	test   %rsi,%rsi
   10009:	74 20                	je     1002b <le_adv_update.constprop.28+0x88>
	for (i = 0; i < ad_len; i++) {
   1000b:	48 39 c3             	cmp    %rax,%rbx
   1000e:	74 1b                	je     1002b <le_adv_update.constprop.28+0x88>
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
   10010:	48 89 c1             	mov    %rax,%rcx
   10013:	48 c1 e1 04          	shl    $0x4,%rcx
   10017:	8a 0c 0e             	mov    (%rsi,%rcx,1),%cl
   1001a:	83 e9 08             	sub    $0x8,%ecx
   1001d:	80 f9 01             	cmp    $0x1,%cl
   10020:	0f 86 f0 00 00 00    	jbe    10116 <le_adv_update.constprop.28+0x173>
	for (i = 0; i < ad_len; i++) {
   10026:	48 ff c0             	inc    %rax
   10029:	eb e0                	jmp    1000b <le_adv_update.constprop.28+0x68>
   1002b:	31 c0                	xor    %eax,%eax
		if ((ad && ad_has_name(ad, ad_len)) ||
   1002d:	4d 85 ff             	test   %r15,%r15
   10030:	74 21                	je     10053 <le_adv_update.constprop.28+0xb0>
	for (i = 0; i < ad_len; i++) {
   10032:	49 39 c5             	cmp    %rax,%r13
   10035:	74 1c                	je     10053 <le_adv_update.constprop.28+0xb0>
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
   10037:	48 89 c1             	mov    %rax,%rcx
   1003a:	48 c1 e1 04          	shl    $0x4,%rcx
   1003e:	41 8a 0c 0f          	mov    (%r15,%rcx,1),%cl
   10042:	83 e9 08             	sub    $0x8,%ecx
   10045:	80 f9 01             	cmp    $0x1,%cl
   10048:	0f 86 c8 00 00 00    	jbe    10116 <le_adv_update.constprop.28+0x173>
	for (i = 0; i < ad_len; i++) {
   1004e:	48 ff c0             	inc    %rax
   10051:	eb df                	jmp    10032 <le_adv_update.constprop.28+0x8f>
		data = (struct bt_data)BT_DATA(
   10053:	31 c0                	xor    %eax,%eax
   10055:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
   10059:	4c 89 c7             	mov    %r8,%rdi
   1005c:	f2 ae                	repnz scas %es:(%rdi),%al
   1005e:	c6 44 24 10 09       	movb   $0x9,0x10(%rsp)
   10063:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
   10068:	48 89 c8             	mov    %rcx,%rax
   1006b:	48 f7 d0             	not    %rax
   1006e:	48 ff c8             	dec    %rax
   10071:	88 44 24 11          	mov    %al,0x11(%rsp)
		if (use_name && !scannable) {
   10075:	41 80 fe 01          	cmp    $0x1,%r14b
		d[0].data = ad;
   10079:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
		d[0].len = ad_len;
   1007e:	48 89 5c 24 28       	mov    %rbx,0x28(%rsp)
		if (use_name && !scannable) {
   10083:	74 1f                	je     100a4 <le_adv_update.constprop.28+0x101>
   10085:	40 84 ed             	test   %bpl,%bpl
   10088:	74 1a                	je     100a4 <le_adv_update.constprop.28+0x101>
			d[1].data = &data;
   1008a:	48 8d 44 24 10       	lea    0x10(%rsp),%rax
			d[1].len = 1;
   1008f:	48 c7 44 24 38 01 00 	movq   $0x1,0x38(%rsp)
   10096:	00 00 
			d_len = 2;
   10098:	ba 02 00 00 00       	mov    $0x2,%edx
			d[1].data = &data;
   1009d:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
   100a2:	eb 05                	jmp    100a9 <le_adv_update.constprop.28+0x106>
		d_len = 1;
   100a4:	ba 01 00 00 00       	mov    $0x1,%edx
	return hci_set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
   100a9:	4c 89 e6             	mov    %r12,%rsi
   100ac:	bf 08 20 00 00       	mov    $0x2008,%edi
   100b1:	e8 2b e7 ff ff       	callq  e7e1 <hci_set_ad>
		if (err) {
   100b6:	85 c0                	test   %eax,%eax
	return hci_set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
   100b8:	89 c3                	mov    %eax,%ebx
		if (err) {
   100ba:	75 5f                	jne    1011b <le_adv_update.constprop.28+0x178>
	if (scannable) {
   100bc:	45 84 f6             	test   %r14b,%r14b
   100bf:	75 14                	jne    100d5 <le_adv_update.constprop.28+0x132>
	atomic_set_bit(adv->flags, BT_ADV_DATA_SET);
   100c1:	48 8b 3c 24          	mov    (%rsp),%rdi
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   100c5:	be 04 00 00 00       	mov    $0x4,%esi
   100ca:	48 83 c7 10          	add    $0x10,%rdi
   100ce:	e8 ff d6 ff ff       	callq  d7d2 <atomic_or>
   100d3:	eb 46                	jmp    1011b <le_adv_update.constprop.28+0x178>
		if (use_name) {
   100d5:	40 84 ed             	test   %bpl,%bpl
		d[0].data = sd;
   100d8:	4c 89 7c 24 20       	mov    %r15,0x20(%rsp)
		d[0].len = sd_len;
   100dd:	4c 89 6c 24 28       	mov    %r13,0x28(%rsp)
		d_len = 1;
   100e2:	ba 01 00 00 00       	mov    $0x1,%edx
		if (use_name) {
   100e7:	74 18                	je     10101 <le_adv_update.constprop.28+0x15e>
			d[1].data = &data;
   100e9:	48 8d 44 24 10       	lea    0x10(%rsp),%rax
			d[1].len = 1;
   100ee:	48 c7 44 24 38 01 00 	movq   $0x1,0x38(%rsp)
   100f5:	00 00 
			d_len = 2;
   100f7:	ba 02 00 00 00       	mov    $0x2,%edx
			d[1].data = &data;
   100fc:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
   10101:	4c 89 e6             	mov    %r12,%rsi
   10104:	bf 09 20 00 00       	mov    $0x2009,%edi
   10109:	e8 d3 e6 ff ff       	callq  e7e1 <hci_set_ad>
		if (err) {
   1010e:	85 c0                	test   %eax,%eax
   10110:	74 af                	je     100c1 <le_adv_update.constprop.28+0x11e>
   10112:	89 c3                	mov    %eax,%ebx
   10114:	eb 05                	jmp    1011b <le_adv_update.constprop.28+0x178>
			return -EINVAL;
   10116:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
}
   1011b:	48 8b 54 24 48       	mov    0x48(%rsp),%rdx
   10120:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
   10127:	00 00 
   10129:	89 d8                	mov    %ebx,%eax
   1012b:	74 05                	je     10132 <le_adv_update.constprop.28+0x18f>
   1012d:	e8 0e 45 ff ff       	callq  4640 <__stack_chk_fail@plt>
   10132:	48 83 c4 58          	add    $0x58,%rsp
   10136:	5b                   	pop    %rbx
   10137:	5d                   	pop    %rbp
   10138:	41 5c                	pop    %r12
   1013a:	41 5d                	pop    %r13
   1013c:	41 5e                	pop    %r14
   1013e:	41 5f                	pop    %r15
   10140:	c3                   	retq   

0000000000010141 <bt_id_create>:
{
   10141:	41 54                	push   %r12
   10143:	55                   	push   %rbp
   10144:	49 89 f4             	mov    %rsi,%r12
   10147:	53                   	push   %rbx
   10148:	48 89 fd             	mov    %rdi,%rbp
   1014b:	48 83 ec 20          	sub    $0x20,%rsp
   1014f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   10156:	00 00 
   10158:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1015d:	31 c0                	xor    %eax,%eax
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
   1015f:	48 85 ff             	test   %rdi,%rdi
   10162:	75 0a                	jne    1016e <bt_id_create+0x2d>
	if (!IS_ENABLED(CONFIG_BT_PRIVACY) && irk) {
   10164:	4d 85 e4             	test   %r12,%r12
   10167:	74 6d                	je     101d6 <bt_id_create+0x95>
   10169:	e9 94 00 00 00       	jmpq   10202 <bt_id_create+0xc1>
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
   1016e:	48 8d 7c 24 0a       	lea    0xa(%rsp),%rdi
   10173:	31 c0                	xor    %eax,%eax
   10175:	b9 07 00 00 00       	mov    $0x7,%ecx
   1017a:	48 8d 74 24 0a       	lea    0xa(%rsp),%rsi
   1017f:	f3 aa                	rep stos %al,%es:(%rdi)
   10181:	48 89 ef             	mov    %rbp,%rdi
   10184:	e8 eb d8 ff ff       	callq  da74 <bt_addr_le_cmp>
   10189:	85 c0                	test   %eax,%eax
   1018b:	74 d7                	je     10164 <bt_id_create+0x23>
		if (addr->type != BT_ADDR_LE_RANDOM ||
   1018d:	80 7d 00 01          	cmpb   $0x1,0x0(%rbp)
   10191:	75 0a                	jne    1019d <bt_id_create+0x5c>
   10193:	8a 45 06             	mov    0x6(%rbp),%al
   10196:	83 e0 c0             	and    $0xffffffc0,%eax
   10199:	3c c0                	cmp    $0xc0,%al
   1019b:	74 26                	je     101c3 <bt_id_create+0x82>
   1019d:	48 8d 35 2c a2 22 00 	lea    0x22a22c(%rip),%rsi        # 23a3d0 <log_const_bt_hci_core>
   101a4:	48 2b 35 a5 5d 22 00 	sub    0x225da5(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Only static random identity address supported");
   101ab:	48 8d 3d db 26 02 00 	lea    0x226db(%rip),%rdi        # 3288d <__func__.5785+0x1c25>
   101b2:	48 c1 ee 04          	shr    $0x4,%rsi
   101b6:	c1 e6 06             	shl    $0x6,%esi
   101b9:	83 ce 01             	or     $0x1,%esi
   101bc:	e8 03 71 ff ff       	callq  72c4 <log_0>
   101c1:	eb 3f                	jmp    10202 <bt_id_create+0xc1>
		if (id_find(addr) >= 0) {
   101c3:	48 89 ef             	mov    %rbp,%rdi
			return -EALREADY;
   101c6:	bb 8e ff ff ff       	mov    $0xffffff8e,%ebx
		if (id_find(addr) >= 0) {
   101cb:	e8 ae d8 ff ff       	callq  da7e <id_find>
   101d0:	85 c0                	test   %eax,%eax
   101d2:	78 90                	js     10164 <bt_id_create+0x23>
   101d4:	eb 68                	jmp    1023e <bt_id_create+0xfd>
	if (bt_dev.id_count == ARRAY_SIZE(bt_dev.id_addr)) {
   101d6:	4c 8d 25 63 64 22 00 	lea    0x226463(%rip),%r12        # 236640 <bt_dev>
		return -ENOMEM;
   101dd:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
	if (bt_dev.id_count == ARRAY_SIZE(bt_dev.id_addr)) {
   101e2:	41 80 7c 24 07 01    	cmpb   $0x1,0x7(%r12)
   101e8:	74 54                	je     1023e <bt_id_create+0xfd>
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_ENABLE)) {
   101ea:	49 8d bc 24 a0 00 00 	lea    0xa0(%r12),%rdi
   101f1:	00 
   101f2:	31 f6                	xor    %esi,%esi
   101f4:	e8 3b dd ff ff       	callq  df34 <atomic_test_bit>
   101f9:	84 c0                	test   %al,%al
   101fb:	75 29                	jne    10226 <bt_id_create+0xe5>
		if (!(addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY))) {
   101fd:	48 85 ed             	test   %rbp,%rbp
   10200:	75 07                	jne    10209 <bt_id_create+0xc8>
		return -EINVAL;
   10202:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
   10207:	eb 35                	jmp    1023e <bt_id_create+0xfd>
		if (!(addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY))) {
   10209:	48 8d 7c 24 11       	lea    0x11(%rsp),%rdi
   1020e:	b9 07 00 00 00       	mov    $0x7,%ecx
   10213:	48 8d 74 24 11       	lea    0x11(%rsp),%rsi
   10218:	f3 aa                	rep stos %al,%es:(%rdi)
   1021a:	48 89 ef             	mov    %rbp,%rdi
   1021d:	e8 52 d8 ff ff       	callq  da74 <bt_addr_le_cmp>
   10222:	85 c0                	test   %eax,%eax
   10224:	74 dc                	je     10202 <bt_id_create+0xc1>
	new_id = bt_dev.id_count++;
   10226:	41 0f b6 5c 24 07    	movzbl 0x7(%r12),%ebx
	id_create(new_id, addr, irk);
   1022c:	48 89 ee             	mov    %rbp,%rsi
	new_id = bt_dev.id_count++;
   1022f:	8d 43 01             	lea    0x1(%rbx),%eax
	id_create(new_id, addr, irk);
   10232:	89 df                	mov    %ebx,%edi
	new_id = bt_dev.id_count++;
   10234:	41 88 44 24 07       	mov    %al,0x7(%r12)
	id_create(new_id, addr, irk);
   10239:	e8 2c de ff ff       	callq  e06a <id_create.constprop.29>
}
   1023e:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
   10243:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
   1024a:	00 00 
   1024c:	89 d8                	mov    %ebx,%eax
   1024e:	74 05                	je     10255 <bt_id_create+0x114>
   10250:	e8 eb 43 ff ff       	callq  4640 <__stack_chk_fail@plt>
   10255:	48 83 c4 20          	add    $0x20,%rsp
   10259:	5b                   	pop    %rbx
   1025a:	5d                   	pop    %rbp
   1025b:	41 5c                	pop    %r12
   1025d:	c3                   	retq   

000000000001025e <bt_setup_public_id_addr>:
{
   1025e:	41 54                	push   %r12
   10260:	55                   	push   %rbp
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
   10261:	31 f6                	xor    %esi,%esi
{
   10263:	53                   	push   %rbx
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
   10264:	bf 09 10 00 00       	mov    $0x1009,%edi
{
   10269:	48 83 ec 30          	sub    $0x30,%rsp
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
   1026d:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
{
   10272:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   10279:	00 00 
   1027b:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
   10280:	31 c0                	xor    %eax,%eax
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
   10282:	e8 34 e3 ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
	if (err) {
   10287:	85 c0                	test   %eax,%eax
   10289:	48 8d 1d b0 63 22 00 	lea    0x2263b0(%rip),%rbx        # 236640 <bt_dev>
   10290:	74 26                	je     102b8 <bt_setup_public_id_addr+0x5a>
   10292:	48 8d 35 37 a1 22 00 	lea    0x22a137(%rip),%rsi        # 23a3d0 <log_const_bt_hci_core>
   10299:	48 2b 35 b0 5c 22 00 	sub    0x225cb0(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("Failed to read public address");
   102a0:	48 8d 3d 14 26 02 00 	lea    0x22614(%rip),%rdi        # 328bb <__func__.5785+0x1c53>
   102a7:	48 c1 ee 04          	shr    $0x4,%rsi
   102ab:	c1 e6 06             	shl    $0x6,%esi
   102ae:	83 ce 02             	or     $0x2,%esi
   102b1:	e8 0e 70 ff ff       	callq  72c4 <log_0>
   102b6:	eb 3a                	jmp    102f2 <bt_setup_public_id_addr+0x94>
	rp = (void *)rsp->data;
   102b8:	4c 8b 64 24 08       	mov    0x8(%rsp),%r12
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
   102bd:	48 8d 7c 24 1b       	lea    0x1b(%rsp),%rdi
   102c2:	31 c0                	xor    %eax,%eax
   102c4:	b9 06 00 00 00       	mov    $0x6,%ecx
   102c9:	48 8d 74 24 1b       	lea    0x1b(%rsp),%rsi
   102ce:	ba 06 00 00 00       	mov    $0x6,%edx
   102d3:	f3 aa                	rep stos %al,%es:(%rdi)
   102d5:	49 8b 44 24 10       	mov    0x10(%r12),%rax
   102da:	48 8d 68 01          	lea    0x1(%rax),%rbp
   102de:	48 89 ef             	mov    %rbp,%rdi
   102e1:	e8 5a 41 ff ff       	callq  4440 <memcmp@plt>
   102e6:	85 c0                	test   %eax,%eax
   102e8:	75 0e                	jne    102f8 <bt_setup_public_id_addr+0x9a>
		net_buf_unref(rsp);
   102ea:	4c 89 e7             	mov    %r12,%rdi
   102ed:	e8 a8 8c 00 00       	callq  18f9a <net_buf_unref>
	bt_dev.id_count = bt_read_public_addr(&addr);
   102f2:	c6 43 07 00          	movb   $0x0,0x7(%rbx)
   102f6:	eb 54                	jmp    1034c <bt_setup_public_id_addr+0xee>
   102f8:	48 8d 74 24 15       	lea    0x15(%rsp),%rsi
   102fd:	ba 06 00 00 00       	mov    $0x6,%edx
   10302:	48 89 ef             	mov    %rbp,%rdi
	    !bt_addr_cmp(&rp->bdaddr, BT_ADDR_NONE)) {
   10305:	c7 44 24 15 ff ff ff 	movl   $0xffffffff,0x15(%rsp)
   1030c:	ff 
   1030d:	66 c7 44 24 19 ff ff 	movw   $0xffff,0x19(%rsp)
   10314:	e8 27 41 ff ff       	callq  4440 <memcmp@plt>
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
   10319:	85 c0                	test   %eax,%eax
   1031b:	74 cd                	je     102ea <bt_setup_public_id_addr+0x8c>
	bt_addr_copy(&addr->a, &rp->bdaddr);
   1031d:	4c 8d 64 24 21       	lea    0x21(%rsp),%r12
   10322:	48 89 ee             	mov    %rbp,%rsi
   10325:	49 8d 7c 24 01       	lea    0x1(%r12),%rdi
   1032a:	e8 81 d4 ff ff       	callq  d7b0 <bt_addr_copy>
	net_buf_unref(rsp);
   1032f:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
	addr->type = BT_ADDR_LE_PUBLIC;
   10334:	c6 44 24 21 00       	movb   $0x0,0x21(%rsp)
	net_buf_unref(rsp);
   10339:	e8 5c 8c 00 00       	callq  18f9a <net_buf_unref>
	id_create(BT_ID_DEFAULT, &addr, irk);
   1033e:	4c 89 e6             	mov    %r12,%rsi
   10341:	31 ff                	xor    %edi,%edi
	bt_dev.id_count = bt_read_public_addr(&addr);
   10343:	c6 43 07 01          	movb   $0x1,0x7(%rbx)
	id_create(BT_ID_DEFAULT, &addr, irk);
   10347:	e8 1e dd ff ff       	callq  e06a <id_create.constprop.29>
}
   1034c:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
   10351:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   10358:	00 00 
   1035a:	74 05                	je     10361 <bt_setup_public_id_addr+0x103>
   1035c:	e8 df 42 ff ff       	callq  4640 <__stack_chk_fail@plt>
   10361:	48 83 c4 30          	add    $0x30,%rsp
   10365:	5b                   	pop    %rbx
   10366:	5d                   	pop    %rbp
   10367:	41 5c                	pop    %r12
   10369:	c3                   	retq   

000000000001036a <bt_setup_random_id_addr>:
	return bt_id_create(NULL, NULL);
   1036a:	31 f6                	xor    %esi,%esi
   1036c:	31 ff                	xor    %edi,%edi
   1036e:	e9 ce fd ff ff       	jmpq   10141 <bt_id_create>

0000000000010373 <bt_addr_le_is_bonded>:
}
   10373:	31 c0                	xor    %eax,%eax
   10375:	c3                   	retq   

0000000000010376 <bt_le_adv_start_legacy>:

int bt_le_adv_start_legacy(struct bt_le_ext_adv *adv,
			   const struct bt_le_adv_param *param,
			   const struct bt_data *ad, size_t ad_len,
			   const struct bt_data *sd, size_t sd_len)
{
   10376:	41 57                	push   %r15
   10378:	41 56                	push   %r14
   1037a:	41 55                	push   %r13
   1037c:	41 54                	push   %r12
   1037e:	55                   	push   %rbp
   1037f:	53                   	push   %rbx
   10380:	48 89 fd             	mov    %rdi,%rbp
   10383:	48 89 f3             	mov    %rsi,%rbx
   10386:	48 83 ec 68          	sub    $0x68,%rsp
	struct bt_hci_cp_le_set_adv_param set_param;
	struct bt_conn *conn = NULL;
	struct net_buf *buf;
	bool dir_adv = (param->peer != NULL), scannable;
   1038a:	4c 8b 6e 10          	mov    0x10(%rsi),%r13
	int err;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   1038e:	be 01 00 00 00       	mov    $0x1,%esi
{
   10393:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1039a:	00 00 
   1039c:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
   103a1:	31 c0                	xor    %eax,%eax
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   103a3:	48 8d 05 96 62 22 00 	lea    0x226296(%rip),%rax        # 236640 <bt_dev>
{
   103aa:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
	bool dir_adv = (param->peer != NULL), scannable;
   103af:	4d 85 ed             	test   %r13,%r13
{
   103b2:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
   103b7:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
	bool dir_adv = (param->peer != NULL), scannable;
   103bc:	0f 95 44 24 10       	setne  0x10(%rsp)
{
   103c1:	4c 89 4c 24 28       	mov    %r9,0x28(%rsp)
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   103c6:	48 8d b8 a0 00 00 00 	lea    0xa0(%rax),%rdi
	struct bt_conn *conn = NULL;
   103cd:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
   103d4:	00 00 
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   103d6:	e8 59 db ff ff       	callq  df34 <atomic_test_bit>
   103db:	88 c2                	mov    %al,%dl
		return -EAGAIN;
   103dd:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   103e2:	84 d2                	test   %dl,%dl
   103e4:	0f 84 eb 02 00 00    	je     106d5 <bt_le_adv_start_legacy+0x35f>
	}

	if (!valid_adv_param(param)) {
   103ea:	48 89 df             	mov    %rbx,%rdi
   103ed:	e8 d6 d6 ff ff       	callq  dac8 <valid_adv_param>
   103f2:	41 88 c4             	mov    %al,%r12b
		return -EINVAL;
   103f5:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (!valid_adv_param(param)) {
   103fa:	45 84 e4             	test   %r12b,%r12b
   103fd:	0f 84 d2 02 00 00    	je     106d5 <bt_le_adv_start_legacy+0x35f>

	if (!bt_le_adv_random_addr_check(param)) {
		return -EINVAL;
	}

	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
   10403:	4c 8d 7d 10          	lea    0x10(%rbp),%r15
   10407:	be 06 00 00 00       	mov    $0x6,%esi
   1040c:	4c 89 ff             	mov    %r15,%rdi
   1040f:	e8 20 db ff ff       	callq  df34 <atomic_test_bit>
   10414:	40 88 c6             	mov    %al,%sil
		return -EALREADY;
   10417:	b8 8e ff ff ff       	mov    $0xffffff8e,%eax
	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
   1041c:	40 84 f6             	test   %sil,%sil
   1041f:	0f 85 b0 02 00 00    	jne    106d5 <bt_le_adv_start_legacy+0x35f>
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
   10425:	4c 8d 74 24 49       	lea    0x49(%rsp),%r14
   1042a:	40 88 f0             	mov    %sil,%al
   1042d:	b9 0b 00 00 00       	mov    $0xb,%ecx
   10432:	49 8d 56 04          	lea    0x4(%r14),%rdx
   10436:	48 89 d7             	mov    %rdx,%rdi
   10439:	f3 aa                	rep stos %al,%es:(%rdi)
	}

	(void)memset(&set_param, 0, sizeof(set_param));

	set_param.min_interval = sys_cpu_to_le16(param->interval_min);
   1043b:	8b 43 08             	mov    0x8(%rbx),%eax
	set_param.max_interval = sys_cpu_to_le16(param->interval_max);
	set_param.channel_map  = get_adv_channel_map(param->options);
   1043e:	8b 7b 04             	mov    0x4(%rbx),%edi
	set_param.min_interval = sys_cpu_to_le16(param->interval_min);
   10441:	66 89 44 24 49       	mov    %ax,0x49(%rsp)
	set_param.max_interval = sys_cpu_to_le16(param->interval_max);
   10446:	8b 43 0c             	mov    0xc(%rbx),%eax
   10449:	66 89 44 24 4b       	mov    %ax,0x4b(%rsp)
	set_param.channel_map  = get_adv_channel_map(param->options);
   1044e:	e8 3e d3 ff ff       	callq  d791 <get_adv_channel_map>
   10453:	88 44 24 56          	mov    %al,0x56(%rsp)
	set_param.filter_policy = get_filter_policy(param->options);

	if (adv->id != param->id) {
   10457:	8a 03                	mov    (%rbx),%al
   10459:	38 45 00             	cmp    %al,0x0(%rbp)
   1045c:	74 12                	je     10470 <bt_le_adv_start_legacy+0xfa>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1045e:	48 8d 05 db 61 22 00 	lea    0x2261db(%rip),%rax        # 236640 <bt_dev>
   10465:	f0 81 a0 a0 00 00 00 	lock andl $0xffffefff,0xa0(%rax)
   1046c:	ff ef ff ff 
		atomic_clear_bit(bt_dev.flags, BT_DEV_RPA_VALID);
	}

	adv->id = param->id;
   10470:	8a 03                	mov    (%rbx),%al
	bt_dev.adv_conn_id = adv->id;
   10472:	48 8d 0d c7 61 22 00 	lea    0x2261c7(%rip),%rcx        # 236640 <bt_dev>

	err = le_adv_set_random_addr(adv, param->options, dir_adv,
   10479:	48 89 ef             	mov    %rbp,%rdi
   1047c:	0f b6 54 24 10       	movzbl 0x10(%rsp),%edx
	adv->id = param->id;
   10481:	88 45 00             	mov    %al,0x0(%rbp)
	bt_dev.adv_conn_id = adv->id;
   10484:	88 41 33             	mov    %al,0x33(%rcx)
	err = le_adv_set_random_addr(adv, param->options, dir_adv,
   10487:	49 8d 4e 05          	lea    0x5(%r14),%rcx
   1048b:	8b 73 04             	mov    0x4(%rbx),%esi
   1048e:	e8 18 e5 ff ff       	callq  e9ab <le_adv_set_random_addr>
				     &set_param.own_addr_type);
	if (err) {
   10493:	85 c0                	test   %eax,%eax
   10495:	0f 85 3a 02 00 00    	jne    106d5 <bt_le_adv_start_legacy+0x35f>
		return err;
	}

	if (dir_adv) {
   1049b:	4d 85 ed             	test   %r13,%r13
   1049e:	48 8d 55 09          	lea    0x9(%rbp),%rdx
   104a2:	74 06                	je     104aa <bt_le_adv_start_legacy+0x134>
		bt_addr_le_copy(&adv->target_addr, param->peer);
   104a4:	48 8b 73 10          	mov    0x10(%rbx),%rsi
   104a8:	eb 13                	jmp    104bd <bt_le_adv_start_legacy+0x147>
	} else {
		bt_addr_le_copy(&adv->target_addr, BT_ADDR_LE_ANY);
   104aa:	48 8d 7c 24 42       	lea    0x42(%rsp),%rdi
   104af:	b9 07 00 00 00       	mov    $0x7,%ecx
   104b4:	31 c0                	xor    %eax,%eax
   104b6:	48 8d 74 24 42       	lea    0x42(%rsp),%rsi
   104bb:	f3 aa                	rep stos %al,%es:(%rdi)
   104bd:	48 89 d7             	mov    %rdx,%rdi
   104c0:	e8 f8 d2 ff ff       	callq  d7bd <bt_addr_le_copy>
	}

	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
   104c5:	8b 53 04             	mov    0x4(%rbx),%edx
   104c8:	f6 c2 01             	test   $0x1,%dl
   104cb:	74 2c                	je     104f9 <bt_le_adv_start_legacy+0x183>
		scannable = true;

		if (dir_adv) {
   104cd:	4d 85 ed             	test   %r13,%r13
   104d0:	74 20                	je     104f2 <bt_le_adv_start_legacy+0x17c>
			if (param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) {
   104d2:	80 e2 10             	and    $0x10,%dl
   104d5:	74 07                	je     104de <bt_le_adv_start_legacy+0x168>
				set_param.type = BT_HCI_ADV_DIRECT_IND_LOW_DUTY;
   104d7:	c6 44 24 4d 04       	movb   $0x4,0x4d(%rsp)
   104dc:	eb 05                	jmp    104e3 <bt_le_adv_start_legacy+0x16d>
			} else {
				set_param.type = BT_HCI_ADV_DIRECT_IND;
   104de:	c6 44 24 4d 01       	movb   $0x1,0x4d(%rsp)
			}

			bt_addr_le_copy(&set_param.direct_addr, param->peer);
   104e3:	48 8b 73 10          	mov    0x10(%rbx),%rsi
   104e7:	49 8d 7e 06          	lea    0x6(%r14),%rdi
   104eb:	e8 cd d2 ff ff       	callq  d7bd <bt_addr_le_copy>
   104f0:	eb 28                	jmp    1051a <bt_le_adv_start_legacy+0x1a4>
		} else {
			set_param.type = BT_HCI_ADV_IND;
   104f2:	c6 44 24 4d 00       	movb   $0x0,0x4d(%rsp)
   104f7:	eb 21                	jmp    1051a <bt_le_adv_start_legacy+0x1a4>
		}
	} else {
		scannable = sd || (param->options & BT_LE_ADV_OPT_USE_NAME);
   104f9:	48 83 7c 24 08 00    	cmpq   $0x0,0x8(%rsp)

		set_param.type = scannable ? BT_HCI_ADV_SCAN_IND :
   104ff:	b0 02                	mov    $0x2,%al
		scannable = sd || (param->options & BT_LE_ADV_OPT_USE_NAME);
   10501:	75 13                	jne    10516 <bt_le_adv_start_legacy+0x1a0>
   10503:	83 e2 08             	and    $0x8,%edx
   10506:	b0 00                	mov    $0x0,%al
   10508:	44 0f 44 e0          	cmove  %eax,%r12d
   1050c:	83 fa 01             	cmp    $0x1,%edx
   1050f:	19 c0                	sbb    %eax,%eax
   10511:	f7 d0                	not    %eax
   10513:	83 c0 03             	add    $0x3,%eax
		set_param.type = scannable ? BT_HCI_ADV_SCAN_IND :
   10516:	88 44 24 4d          	mov    %al,0x4d(%rsp)
					     BT_HCI_ADV_NONCONN_IND;
	}

	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_PARAM, sizeof(set_param));
   1051a:	be 0f 00 00 00       	mov    $0xf,%esi
   1051f:	bf 06 20 00 00       	mov    $0x2006,%edi
   10524:	e8 f4 df ff ff       	callq  e51d <bt_hci_cmd_create>
   10529:	48 89 c1             	mov    %rax,%rcx
	if (!buf) {
		return -ENOBUFS;
   1052c:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
	if (!buf) {
   10531:	48 85 c9             	test   %rcx,%rcx
   10534:	0f 84 9b 01 00 00    	je     106d5 <bt_le_adv_start_legacy+0x35f>
	return net_buf_simple_add_mem(&buf->b, mem, len);
   1053a:	48 8d 79 10          	lea    0x10(%rcx),%rdi
   1053e:	ba 0f 00 00 00       	mov    $0xf,%edx
   10543:	4c 89 f6             	mov    %r14,%rsi
   10546:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
   1054b:	e8 4a 8b 00 00       	callq  1909a <net_buf_simple_add_mem>
	}

	net_buf_add_mem(buf, &set_param, sizeof(set_param));

	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_PARAM, buf, NULL);
   10550:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
   10555:	31 d2                	xor    %edx,%edx
   10557:	bf 06 20 00 00       	mov    $0x2006,%edi
   1055c:	48 89 ce             	mov    %rcx,%rsi
   1055f:	e8 57 e0 ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
	if (err) {
   10564:	85 c0                	test   %eax,%eax
   10566:	0f 85 69 01 00 00    	jne    106d5 <bt_le_adv_start_legacy+0x35f>
		return err;
	}

	if (!dir_adv) {
   1056c:	4d 85 ed             	test   %r13,%r13
   1056f:	74 08                	je     10579 <bt_le_adv_start_legacy+0x203>
		if (err) {
			return err;
		}
	}

	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   10571:	f6 43 04 01          	testb  $0x1,0x4(%rbx)
   10575:	75 3b                	jne    105b2 <bt_le_adv_start_legacy+0x23c>
   10577:	eb 76                	jmp    105ef <bt_le_adv_start_legacy+0x279>
		err = le_adv_update(adv, ad, ad_len, sd, sd_len, false,
   10579:	8b 43 04             	mov    0x4(%rbx),%eax
   1057c:	48 83 ec 08          	sub    $0x8,%rsp
   10580:	45 0f b6 cc          	movzbl %r12b,%r9d
   10584:	48 89 ef             	mov    %rbp,%rdi
   10587:	c1 e8 03             	shr    $0x3,%eax
   1058a:	83 e0 01             	and    $0x1,%eax
   1058d:	50                   	push   %rax
   1058e:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
   10593:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   10598:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
   1059d:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
   105a2:	e8 fc f9 ff ff       	callq  ffa3 <le_adv_update.constprop.28>
		if (err) {
   105a7:	85 c0                	test   %eax,%eax
		err = le_adv_update(adv, ad, ad_len, sd, sd_len, false,
   105a9:	5a                   	pop    %rdx
   105aa:	59                   	pop    %rcx
		if (err) {
   105ab:	74 c4                	je     10571 <bt_le_adv_start_legacy+0x1fb>
   105ad:	e9 23 01 00 00       	jmpq   106d5 <bt_le_adv_start_legacy+0x35f>
	    (param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
		err = le_adv_start_add_conn(adv, &conn);
   105b2:	48 8d 74 24 38       	lea    0x38(%rsp),%rsi
   105b7:	48 89 ef             	mov    %rbp,%rdi
   105ba:	e8 80 d9 ff ff       	callq  df3f <le_adv_start_add_conn>
		if (err) {
   105bf:	85 c0                	test   %eax,%eax
   105c1:	74 2c                	je     105ef <bt_le_adv_start_legacy+0x279>
			if (err == -ENOMEM && !dir_adv &&
   105c3:	83 f8 f4             	cmp    $0xfffffff4,%eax
   105c6:	0f 85 09 01 00 00    	jne    106d5 <bt_le_adv_start_legacy+0x35f>
   105cc:	4d 85 ed             	test   %r13,%r13
   105cf:	0f 85 00 01 00 00    	jne    106d5 <bt_le_adv_start_legacy+0x35f>
   105d5:	f6 43 04 02          	testb  $0x2,0x4(%rbx)
   105d9:	0f 85 f6 00 00 00    	jne    106d5 <bt_le_adv_start_legacy+0x35f>
		 */
		bt_conn_unref(conn);
	}

set_adv_state:
	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
   105df:	8b 43 04             	mov    0x4(%rbx),%eax
   105e2:	d1 e8                	shr    %eax
   105e4:	83 f0 01             	xor    $0x1,%eax
   105e7:	83 e0 01             	and    $0x1,%eax
   105ea:	e9 85 00 00 00       	jmpq   10674 <bt_le_adv_start_legacy+0x2fe>
	return set_le_adv_enable_legacy(adv, enable);
   105ef:	be 01 00 00 00       	mov    $0x1,%esi
   105f4:	48 89 ef             	mov    %rbp,%rdi
   105f7:	e8 c8 e4 ff ff       	callq  eac4 <set_le_adv_enable_legacy>
	if (err) {
   105fc:	85 c0                	test   %eax,%eax
   105fe:	74 54                	je     10654 <bt_le_adv_start_legacy+0x2de>
   10600:	48 8d 35 c9 9d 22 00 	lea    0x229dc9(%rip),%rsi        # 23a3d0 <log_const_bt_hci_core>
   10607:	48 2b 35 42 59 22 00 	sub    0x225942(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Failed to start advertiser");
   1060e:	48 8d 3d c4 22 02 00 	lea    0x222c4(%rip),%rdi        # 328d9 <__func__.5785+0x1c71>
   10615:	89 44 24 08          	mov    %eax,0x8(%rsp)
   10619:	48 c1 ee 04          	shr    $0x4,%rsi
   1061d:	c1 e6 06             	shl    $0x6,%esi
   10620:	83 ce 01             	or     $0x1,%esi
   10623:	e8 9c 6c ff ff       	callq  72c4 <log_0>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
   10628:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
   1062d:	8b 44 24 08          	mov    0x8(%rsp),%eax
   10631:	48 85 ff             	test   %rdi,%rdi
   10634:	0f 84 9b 00 00 00    	je     106d5 <bt_le_adv_start_legacy+0x35f>
			bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   1063a:	31 f6                	xor    %esi,%esi
   1063c:	e8 b7 11 00 00       	callq  117f8 <bt_conn_set_state>
			bt_conn_unref(conn);
   10641:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
   10646:	e8 19 11 00 00       	callq  11764 <bt_conn_unref>
   1064b:	8b 44 24 08          	mov    0x8(%rsp),%eax
   1064f:	e9 81 00 00 00       	jmpq   106d5 <bt_le_adv_start_legacy+0x35f>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
   10654:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
   10659:	48 85 ff             	test   %rdi,%rdi
   1065c:	74 0d                	je     1066b <bt_le_adv_start_legacy+0x2f5>
   1065e:	89 44 24 08          	mov    %eax,0x8(%rsp)
		bt_conn_unref(conn);
   10662:	e8 fd 10 00 00       	callq  11764 <bt_conn_unref>
   10667:	8b 44 24 08          	mov    0x8(%rsp),%eax
	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
   1066b:	4d 85 ed             	test   %r13,%r13
   1066e:	0f 84 6b ff ff ff    	je     105df <bt_le_adv_start_legacy+0x269>
   10674:	89 c2                	mov    %eax,%edx
   10676:	be 0c 00 00 00       	mov    $0xc,%esi
   1067b:	4c 89 ff             	mov    %r15,%rdi
   1067e:	e8 51 dc ff ff       	callq  e2d4 <atomic_set_bit_to>
			  !(param->options & BT_LE_ADV_OPT_ONE_TIME));

	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME,
   10683:	8b 53 04             	mov    0x4(%rbx),%edx
   10686:	be 07 00 00 00       	mov    $0x7,%esi
   1068b:	4c 89 ff             	mov    %r15,%rdi
   1068e:	c1 ea 03             	shr    $0x3,%edx
   10691:	83 e2 01             	and    $0x1,%edx
   10694:	e8 3b dc ff ff       	callq  e2d4 <atomic_set_bit_to>
			  param->options & BT_LE_ADV_OPT_USE_NAME);

	atomic_set_bit_to(adv->flags, BT_ADV_CONNECTABLE,
   10699:	8b 53 04             	mov    0x4(%rbx),%edx
   1069c:	be 08 00 00 00       	mov    $0x8,%esi
   106a1:	4c 89 ff             	mov    %r15,%rdi
   106a4:	83 e2 01             	and    $0x1,%edx
   106a7:	e8 28 dc ff ff       	callq  e2d4 <atomic_set_bit_to>
			  param->options & BT_LE_ADV_OPT_CONNECTABLE);

	atomic_set_bit_to(adv->flags, BT_ADV_SCANNABLE, scannable);
   106ac:	41 0f b6 d4          	movzbl %r12b,%edx
   106b0:	be 09 00 00 00       	mov    $0x9,%esi
   106b5:	4c 89 ff             	mov    %r15,%rdi
   106b8:	e8 17 dc ff ff       	callq  e2d4 <atomic_set_bit_to>

	atomic_set_bit_to(adv->flags, BT_ADV_USE_IDENTITY,
   106bd:	8b 53 04             	mov    0x4(%rbx),%edx
   106c0:	be 0b 00 00 00       	mov    $0xb,%esi
   106c5:	4c 89 ff             	mov    %r15,%rdi
   106c8:	c1 ea 02             	shr    $0x2,%edx
   106cb:	83 e2 01             	and    $0x1,%edx
   106ce:	e8 01 dc ff ff       	callq  e2d4 <atomic_set_bit_to>
			  param->options & BT_LE_ADV_OPT_USE_IDENTITY);

	return 0;
   106d3:	31 c0                	xor    %eax,%eax
}
   106d5:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
   106da:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   106e1:	00 00 
   106e3:	74 05                	je     106ea <bt_le_adv_start_legacy+0x374>
   106e5:	e8 56 3f ff ff       	callq  4640 <__stack_chk_fail@plt>
   106ea:	48 83 c4 68          	add    $0x68,%rsp
   106ee:	5b                   	pop    %rbx
   106ef:	5d                   	pop    %rbp
   106f0:	41 5c                	pop    %r12
   106f2:	41 5d                	pop    %r13
   106f4:	41 5e                	pop    %r14
   106f6:	41 5f                	pop    %r15
   106f8:	c3                   	retq   

00000000000106f9 <bt_le_adv_start>:

	if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
	    BT_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
		err = bt_le_adv_start_ext(adv, param, ad, ad_len, sd, sd_len);
	} else {
		err = bt_le_adv_start_legacy(adv, param, ad, ad_len, sd, sd_len);
   106f9:	48 8d 05 40 5f 22 00 	lea    0x225f40(%rip),%rax        # 236640 <bt_dev>
   10700:	4d 89 c1             	mov    %r8,%r9
   10703:	49 89 c8             	mov    %rcx,%r8
   10706:	48 89 d1             	mov    %rdx,%rcx
   10709:	48 89 f2             	mov    %rsi,%rdx
   1070c:	48 89 fe             	mov    %rdi,%rsi
   1070f:	48 8d 78 18          	lea    0x18(%rax),%rdi
   10713:	e9 5e fc ff ff       	jmpq   10376 <bt_le_adv_start_legacy>

0000000000010718 <bt_le_adv_stop>:

	return err;
}

int bt_le_adv_stop(void)
{
   10718:	55                   	push   %rbp
   10719:	53                   	push   %rbx
   1071a:	48 83 ec 38          	sub    $0x38,%rsp
   1071e:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   10725:	00 00 
   10727:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
   1072c:	31 c0                	xor    %eax,%eax
	struct bt_le_ext_adv *adv = bt_adv_lookup_legacy();
   1072e:	e8 45 e4 ff ff       	callq  eb78 <bt_adv_lookup_legacy>
	int err;

	if (!adv) {
   10733:	48 85 c0             	test   %rax,%rax
   10736:	75 2b                	jne    10763 <bt_le_adv_stop+0x4b>
   10738:	48 8d 35 91 9c 22 00 	lea    0x229c91(%rip),%rsi        # 23a3d0 <log_const_bt_hci_core>
   1073f:	48 2b 35 0a 58 22 00 	sub    0x22580a(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("No valid legacy adv");
   10746:	48 8d 3d a7 21 02 00 	lea    0x221a7(%rip),%rdi        # 328f4 <__func__.5785+0x1c8c>
   1074d:	48 c1 ee 04          	shr    $0x4,%rsi
   10751:	c1 e6 06             	shl    $0x6,%esi
   10754:	83 ce 01             	or     $0x1,%esi
   10757:	e8 68 6b ff ff       	callq  72c4 <log_0>
		return 0;
   1075c:	31 c0                	xor    %eax,%eax
   1075e:	e9 b7 00 00 00       	jmpq   1081a <bt_le_adv_stop+0x102>
	}

	/* Make sure advertising is not re-enabled later even if it's not
	 * currently enabled (i.e. BT_DEV_ADVERTISING is not set).
	 */
	atomic_clear_bit(adv->flags, BT_ADV_PERSIST);
   10763:	48 8d 50 10          	lea    0x10(%rax),%rdx
   10767:	48 89 c3             	mov    %rax,%rbx
   1076a:	f0 81 22 ff ef ff ff 	lock andl $0xffffefff,(%rdx)

	if (!atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
   10771:	be 06 00 00 00       	mov    $0x6,%esi
   10776:	48 89 d7             	mov    %rdx,%rdi
   10779:	e8 b6 d7 ff ff       	callq  df34 <atomic_test_bit>
   1077e:	88 c1                	mov    %al,%cl
		/* Legacy advertiser exists, but is not currently advertising.
		 * This happens when keep advertising behavior is active but
		 * no conn object is available to do connectable advertising.
		 */
		adv_delete_legacy();
		return 0;
   10780:	31 c0                	xor    %eax,%eax
	if (!atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
   10782:	84 c9                	test   %cl,%cl
   10784:	0f 84 90 00 00 00    	je     1081a <bt_le_adv_stop+0x102>
	}

	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
	    atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE)) {
   1078a:	be 08 00 00 00       	mov    $0x8,%esi
   1078f:	e8 a0 d7 ff ff       	callq  df34 <atomic_test_bit>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   10794:	84 c0                	test   %al,%al
   10796:	74 78                	je     10810 <bt_le_adv_stop+0xf8>
	if (!bt_addr_le_cmp(&adv->target_addr, BT_ADDR_LE_ANY)) {
   10798:	48 8d 7c 24 1a       	lea    0x1a(%rsp),%rdi
   1079d:	48 8d 6b 09          	lea    0x9(%rbx),%rbp
   107a1:	31 c0                	xor    %eax,%eax
   107a3:	b9 07 00 00 00       	mov    $0x7,%ecx
   107a8:	48 8d 74 24 1a       	lea    0x1a(%rsp),%rsi
   107ad:	f3 aa                	rep stos %al,%es:(%rdi)
   107af:	48 89 ef             	mov    %rbp,%rdi
   107b2:	e8 bd d2 ff ff       	callq  da74 <bt_addr_le_cmp>
   107b7:	85 c0                	test   %eax,%eax
   107b9:	0f b6 3b             	movzbl (%rbx),%edi
   107bc:	75 20                	jne    107de <bt_le_adv_stop+0xc6>
		conn = bt_conn_lookup_state_le(adv->id, BT_ADDR_LE_NONE,
   107be:	c7 44 24 21 00 ff ff 	movl   $0xffffff00,0x21(%rsp)
   107c5:	ff 
   107c6:	66 c7 44 24 25 ff ff 	movw   $0xffff,0x25(%rsp)
   107cd:	48 8d 74 24 21       	lea    0x21(%rsp),%rsi
   107d2:	c6 44 24 27 ff       	movb   $0xff,0x27(%rsp)
   107d7:	ba 04 00 00 00       	mov    $0x4,%edx
   107dc:	eb 08                	jmp    107e6 <bt_le_adv_stop+0xce>
		conn = bt_conn_lookup_state_le(adv->id, &adv->target_addr,
   107de:	ba 05 00 00 00       	mov    $0x5,%edx
   107e3:	48 89 ee             	mov    %rbp,%rsi
   107e6:	e8 c5 12 00 00       	callq  11ab0 <bt_conn_lookup_state_le>
	if (conn) {
   107eb:	48 85 c0             	test   %rax,%rax
   107ee:	74 20                	je     10810 <bt_le_adv_stop+0xf8>
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   107f0:	48 89 c7             	mov    %rax,%rdi
		conn->err = status;
   107f3:	c6 40 09 00          	movb   $0x0,0x9(%rax)
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   107f7:	31 f6                	xor    %esi,%esi
   107f9:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   107fe:	e8 f5 0f 00 00       	callq  117f8 <bt_conn_set_state>
		bt_conn_unref(conn);
   10803:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   10808:	48 89 c7             	mov    %rax,%rdi
   1080b:	e8 54 0f 00 00       	callq  11764 <bt_conn_unref>
		err = set_le_adv_enable_ext(adv, false, NULL);
		if (err) {
			return err;
		}
	} else {
		err = set_le_adv_enable_legacy(adv, false);
   10810:	31 f6                	xor    %esi,%esi
   10812:	48 89 df             	mov    %rbx,%rdi
   10815:	e8 aa e2 ff ff       	callq  eac4 <set_le_adv_enable_legacy>
		}
	}
#endif /* defined(CONFIG_BT_OBSERVER) */

	return 0;
}
   1081a:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
   1081f:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   10826:	00 00 
   10828:	74 05                	je     1082f <bt_le_adv_stop+0x117>
   1082a:	e8 11 3e ff ff       	callq  4640 <__stack_chk_fail@plt>
   1082f:	48 83 c4 38          	add    $0x38,%rsp
   10833:	5b                   	pop    %rbx
   10834:	5d                   	pop    %rbp
   10835:	c3                   	retq   

0000000000010836 <bt_le_adv_resume>:

#if defined(CONFIG_BT_PERIPHERAL)
void bt_le_adv_resume(void)
{
   10836:	41 54                	push   %r12
   10838:	55                   	push   %rbp
   10839:	53                   	push   %rbx
   1083a:	48 83 ec 10          	sub    $0x10,%rsp
   1083e:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   10845:	00 00 
   10847:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   1084c:	31 c0                	xor    %eax,%eax
	struct bt_le_ext_adv *adv = bt_adv_lookup_legacy();
   1084e:	e8 25 e3 ff ff       	callq  eb78 <bt_adv_lookup_legacy>
	struct bt_conn *conn;
	bool persist_paused = false;
	int err;

	if (!adv) {
   10853:	48 85 c0             	test   %rax,%rax
   10856:	0f 84 94 00 00 00    	je     108f0 <bt_le_adv_resume+0xba>
		BT_DBG("No valid legacy adv");
		return;
	}

	if (!(atomic_test_bit(adv->flags, BT_ADV_PERSIST) &&
   1085c:	48 8d 68 10          	lea    0x10(%rax),%rbp
   10860:	be 0c 00 00 00       	mov    $0xc,%esi
   10865:	49 89 c4             	mov    %rax,%r12
   10868:	48 89 ef             	mov    %rbp,%rdi
   1086b:	e8 c4 d6 ff ff       	callq  df34 <atomic_test_bit>
   10870:	84 c0                	test   %al,%al
   10872:	74 7c                	je     108f0 <bt_le_adv_resume+0xba>
	      !atomic_test_bit(adv->flags, BT_ADV_ENABLED))) {
   10874:	be 06 00 00 00       	mov    $0x6,%esi
   10879:	e8 b6 d6 ff ff       	callq  df34 <atomic_test_bit>
	if (!(atomic_test_bit(adv->flags, BT_ADV_PERSIST) &&
   1087e:	84 c0                	test   %al,%al
	      !atomic_test_bit(adv->flags, BT_ADV_ENABLED))) {
   10880:	88 c3                	mov    %al,%bl
	if (!(atomic_test_bit(adv->flags, BT_ADV_PERSIST) &&
   10882:	75 6c                	jne    108f0 <bt_le_adv_resume+0xba>
		return;
	}

	if (!atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE)) {
   10884:	be 08 00 00 00       	mov    $0x8,%esi
   10889:	e8 a6 d6 ff ff       	callq  df34 <atomic_test_bit>
   1088e:	84 c0                	test   %al,%al
   10890:	74 5e                	je     108f0 <bt_le_adv_resume+0xba>
		return;
	}

	err = le_adv_start_add_conn(adv, &conn);
   10892:	48 89 e6             	mov    %rsp,%rsi
   10895:	4c 89 e7             	mov    %r12,%rdi
   10898:	e8 a2 d6 ff ff       	callq  df3f <le_adv_start_add_conn>
	if (err) {
   1089d:	85 c0                	test   %eax,%eax
   1089f:	75 4f                	jne    108f0 <bt_le_adv_resume+0xba>
	return set_le_adv_enable_legacy(adv, enable);
   108a1:	be 01 00 00 00       	mov    $0x1,%esi
   108a6:	4c 89 e7             	mov    %r12,%rdi
   108a9:	e8 16 e2 ff ff       	callq  eac4 <set_le_adv_enable_legacy>
	    !atomic_test_bit(adv->flags, BT_ADV_USE_IDENTITY)) {
		le_adv_set_private_addr(adv);
	}

	err = set_le_adv_enable(adv, true);
	if (err) {
   108ae:	85 c0                	test   %eax,%eax
   108b0:	74 24                	je     108d6 <bt_le_adv_resume+0xa0>
		BT_DBG("Controller cannot resume connectable advertising (%d)",
		       err);
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   108b2:	48 8b 3c 24          	mov    (%rsp),%rdi
   108b6:	31 f6                	xor    %esi,%esi
   108b8:	e8 3b 0f 00 00       	callq  117f8 <bt_conn_set_state>
   108bd:	41 8b 44 24 10       	mov    0x10(%r12),%eax
   108c2:	89 c2                	mov    %eax,%edx
   108c4:	89 c3                	mov    %eax,%ebx
   108c6:	80 e6 ef             	and    $0xef,%dh
   108c9:	f0 0f b1 55 00       	lock cmpxchg %edx,0x0(%rbp)
   108ce:	75 f2                	jne    108c2 <bt_le_adv_resume+0x8c>
	return (old & mask) != 0;
   108d0:	c1 eb 0c             	shr    $0xc,%ebx
   108d3:	83 e3 01             	and    $0x1,%ebx
	}

	/* Since we don't give the application a reference to manage in
	 * this case, we need to release this reference here.
	 */
	bt_conn_unref(conn);
   108d6:	48 8b 3c 24          	mov    (%rsp),%rdi
   108da:	e8 85 0e 00 00       	callq  11764 <bt_conn_unref>
	if (persist_paused) {
   108df:	84 db                	test   %bl,%bl
   108e1:	74 0d                	je     108f0 <bt_le_adv_resume+0xba>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   108e3:	be 00 10 00 00       	mov    $0x1000,%esi
   108e8:	48 89 ef             	mov    %rbp,%rdi
   108eb:	e8 e2 ce ff ff       	callq  d7d2 <atomic_or>
		atomic_set_bit(adv->flags, BT_ADV_PERSIST);
	}
}
   108f0:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   108f5:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   108fc:	00 00 
   108fe:	74 05                	je     10905 <bt_le_adv_resume+0xcf>
   10900:	e8 3b 3d ff ff       	callq  4640 <__stack_chk_fail@plt>
   10905:	48 83 c4 10          	add    $0x10,%rsp
   10909:	5b                   	pop    %rbx
   1090a:	5d                   	pop    %rbp
   1090b:	41 5c                	pop    %r12
   1090d:	c3                   	retq   

000000000001090e <enh_conn_complete>:
{
   1090e:	41 57                	push   %r15
   10910:	41 56                	push   %r14
   10912:	41 55                	push   %r13
   10914:	41 54                	push   %r12
   10916:	55                   	push   %rbp
   10917:	53                   	push   %rbx
   10918:	48 83 ec 38          	sub    $0x38,%rsp
	if (evt->status) {
   1091c:	0f b6 37             	movzbl (%rdi),%esi
{
   1091f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   10926:	00 00 
   10928:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
   1092d:	31 c0                	xor    %eax,%eax
	if (evt->status) {
   1092f:	40 84 f6             	test   %sil,%sil
   10932:	0f 84 a8 00 00 00    	je     109e0 <enh_conn_complete+0xd2>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   10938:	40 80 fe 3c          	cmp    $0x3c,%sil
   1093c:	75 79                	jne    109b7 <enh_conn_complete+0xa9>
		struct bt_le_ext_adv *adv = bt_adv_lookup_legacy();
   1093e:	e8 35 e2 ff ff       	callq  eb78 <bt_adv_lookup_legacy>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   10943:	f0 83 60 10 bf       	lock andl $0xffffffbf,0x10(%rax)
		conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id, peer_addr,
   10948:	48 8d 05 f1 5c 22 00 	lea    0x225cf1(%rip),%rax        # 236640 <bt_dev>
   1094f:	31 f6                	xor    %esi,%esi
   10951:	ba 05 00 00 00       	mov    $0x5,%edx
   10956:	0f b6 78 33          	movzbl 0x33(%rax),%edi
   1095a:	e8 51 11 00 00       	callq  11ab0 <bt_conn_lookup_state_le>
		if (!conn) {
   1095f:	48 85 c0             	test   %rax,%rax
   10962:	75 33                	jne    10997 <enh_conn_complete+0x89>
   10964:	e8 70 d5 ff ff       	callq  ded9 <find_pending_connect.part.19>
		if (!conn) {
   10969:	48 85 c0             	test   %rax,%rax
   1096c:	75 29                	jne    10997 <enh_conn_complete+0x89>
   1096e:	48 8d 35 5b 9a 22 00 	lea    0x229a5b(%rip),%rsi        # 23a3d0 <log_const_bt_hci_core>
   10975:	48 2b 35 d4 55 22 00 	sub    0x2255d4(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("No pending slave connection");
   1097c:	48 8d 3d 85 1f 02 00 	lea    0x21f85(%rip),%rdi        # 32908 <__func__.5785+0x1ca0>
   10983:	48 c1 ee 04          	shr    $0x4,%rsi
   10987:	c1 e6 06             	shl    $0x6,%esi
   1098a:	83 ce 01             	or     $0x1,%esi
   1098d:	e8 32 69 ff ff       	callq  72c4 <log_0>
   10992:	e9 f0 01 00 00       	jmpq   10b87 <enh_conn_complete+0x279>
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   10997:	48 89 c7             	mov    %rax,%rdi
		conn->err = BT_HCI_ERR_ADV_TIMEOUT;
   1099a:	c6 40 09 3c          	movb   $0x3c,0x9(%rax)
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   1099e:	31 f6                	xor    %esi,%esi
   109a0:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   109a5:	e8 4e 0e 00 00       	callq  117f8 <bt_conn_set_state>
		bt_conn_unref(conn);
   109aa:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   109af:	48 89 c7             	mov    %rax,%rdi
   109b2:	e9 cb 01 00 00       	jmpq   10b82 <enh_conn_complete+0x274>
   109b7:	48 8d 15 12 9a 22 00 	lea    0x229a12(%rip),%rdx        # 23a3d0 <log_const_bt_hci_core>
   109be:	48 2b 15 8b 55 22 00 	sub    0x22558b(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("Unexpected status 0x%02x", evt->status);
   109c5:	48 8d 3d 58 1f 02 00 	lea    0x21f58(%rip),%rdi        # 32924 <__func__.5785+0x1cbc>
   109cc:	48 c1 ea 04          	shr    $0x4,%rdx
   109d0:	c1 e2 06             	shl    $0x6,%edx
   109d3:	83 ca 02             	or     $0x2,%edx
   109d6:	e8 1a 69 ff ff       	callq  72f5 <log_1>
   109db:	e9 a7 01 00 00       	jmpq   10b87 <enh_conn_complete+0x279>
	if (evt->peer_addr.type == BT_ADDR_LE_PUBLIC_ID ||
   109e0:	8a 47 04             	mov    0x4(%rdi),%al
   109e3:	48 89 fd             	mov    %rdi,%rbp
	uint16_t handle = sys_le16_to_cpu(evt->handle);
   109e6:	66 44 8b 67 01       	mov    0x1(%rdi),%r12w
   109eb:	4c 8d 6f 04          	lea    0x4(%rdi),%r13
   109ef:	4c 8d 74 24 21       	lea    0x21(%rsp),%r14
   109f4:	4c 8d 7c 24 1a       	lea    0x1a(%rsp),%r15
	if (evt->peer_addr.type == BT_ADDR_LE_PUBLIC_ID ||
   109f9:	83 e8 02             	sub    $0x2,%eax
   109fc:	3c 01                	cmp    $0x1,%al
   109fe:	77 24                	ja     10a24 <enh_conn_complete+0x116>
		bt_addr_le_copy(&id_addr, &evt->peer_addr);
   10a00:	4c 89 ee             	mov    %r13,%rsi
   10a03:	4c 89 f7             	mov    %r14,%rdi
   10a06:	e8 b2 cd ff ff       	callq  d7bd <bt_addr_le_copy>
		bt_addr_copy(&peer_addr.a, &evt->peer_rpa);
   10a0b:	48 8d 75 11          	lea    0x11(%rbp),%rsi
   10a0f:	49 8d 7f 01          	lea    0x1(%r15),%rdi
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
   10a13:	80 6c 24 21 02       	subb   $0x2,0x21(%rsp)
		bt_addr_copy(&peer_addr.a, &evt->peer_rpa);
   10a18:	e8 93 cd ff ff       	callq  d7b0 <bt_addr_copy>
		peer_addr.type = BT_ADDR_LE_RANDOM;
   10a1d:	c6 44 24 1a 01       	movb   $0x1,0x1a(%rsp)
   10a22:	eb 33                	jmp    10a57 <enh_conn_complete+0x149>
		uint8_t id = evt->role == BT_HCI_ROLE_SLAVE ? bt_dev.adv_conn_id :
   10a24:	80 7f 03 01          	cmpb   $0x1,0x3(%rdi)
   10a28:	75 0b                	jne    10a35 <enh_conn_complete+0x127>
   10a2a:	48 8d 05 0f 5c 22 00 	lea    0x225c0f(%rip),%rax        # 236640 <bt_dev>
   10a31:	40 8a 70 33          	mov    0x33(%rax),%sil
		bt_addr_le_copy(&id_addr,
   10a35:	40 0f b6 fe          	movzbl %sil,%edi
   10a39:	4c 89 ee             	mov    %r13,%rsi
   10a3c:	e8 33 e1 ff ff       	callq  eb74 <bt_lookup_id_addr>
   10a41:	4c 89 f7             	mov    %r14,%rdi
   10a44:	48 89 c6             	mov    %rax,%rsi
   10a47:	e8 71 cd ff ff       	callq  d7bd <bt_addr_le_copy>
		bt_addr_le_copy(&peer_addr, &evt->peer_addr);
   10a4c:	4c 89 ee             	mov    %r13,%rsi
   10a4f:	4c 89 ff             	mov    %r15,%rdi
   10a52:	e8 66 cd ff ff       	callq  d7bd <bt_addr_le_copy>
	return NULL;
   10a57:	31 db                	xor    %ebx,%ebx
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && role == BT_HCI_ROLE_SLAVE) {
   10a59:	80 7d 03 01          	cmpb   $0x1,0x3(%rbp)
   10a5d:	75 28                	jne    10a87 <enh_conn_complete+0x179>
		conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id, peer_addr,
   10a5f:	48 8d 05 da 5b 22 00 	lea    0x225bda(%rip),%rax        # 236640 <bt_dev>
   10a66:	ba 05 00 00 00       	mov    $0x5,%edx
   10a6b:	4c 89 f6             	mov    %r14,%rsi
   10a6e:	0f b6 78 33          	movzbl 0x33(%rax),%edi
   10a72:	e8 39 10 00 00       	callq  11ab0 <bt_conn_lookup_state_le>
		if (!conn) {
   10a77:	48 85 c0             	test   %rax,%rax
		conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id, peer_addr,
   10a7a:	48 89 c3             	mov    %rax,%rbx
		if (!conn) {
   10a7d:	75 08                	jne    10a87 <enh_conn_complete+0x179>
   10a7f:	e8 55 d4 ff ff       	callq  ded9 <find_pending_connect.part.19>
   10a84:	48 89 c3             	mov    %rax,%rbx
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   10a87:	80 7d 03 01          	cmpb   $0x1,0x3(%rbp)
   10a8b:	75 0a                	jne    10a97 <enh_conn_complete+0x189>
		struct bt_le_ext_adv *adv = bt_adv_lookup_legacy();
   10a8d:	e8 e6 e0 ff ff       	callq  eb78 <bt_adv_lookup_legacy>
   10a92:	f0 83 60 10 bf       	lock andl $0xffffffbf,0x10(%rax)
	if (!conn) {
   10a97:	48 85 db             	test   %rbx,%rbx
   10a9a:	75 4c                	jne    10ae8 <enh_conn_complete+0x1da>
   10a9c:	48 8d 1d 2d 99 22 00 	lea    0x22992d(%rip),%rbx        # 23a3d0 <log_const_bt_hci_core>
   10aa3:	48 2b 1d a6 54 22 00 	sub    0x2254a6(%rip),%rbx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("No pending conn for peer %s",
   10aaa:	4c 89 ef             	mov    %r13,%rdi
   10aad:	e8 6c c5 ff ff       	callq  d01e <bt_addr_le_str_real>
   10ab2:	48 89 c7             	mov    %rax,%rdi
   10ab5:	e8 56 64 ff ff       	callq  6f10 <log_strdup>
   10aba:	48 c1 eb 04          	shr    $0x4,%rbx
   10abe:	48 8d 3d 78 1e 02 00 	lea    0x21e78(%rip),%rdi        # 3293d <__func__.5785+0x1cd5>
   10ac5:	48 89 c6             	mov    %rax,%rsi
   10ac8:	c1 e3 06             	shl    $0x6,%ebx
   10acb:	83 cb 01             	or     $0x1,%ebx
   10ace:	89 da                	mov    %ebx,%edx
   10ad0:	e8 20 68 ff ff       	callq  72f5 <log_1>
		bt_hci_disconnect(handle, BT_HCI_ERR_UNSPECIFIED);
   10ad5:	41 0f b7 fc          	movzwl %r12w,%edi
   10ad9:	be 1f 00 00 00       	mov    $0x1f,%esi
   10ade:	e8 a1 e0 ff ff       	callq  eb84 <bt_hci_disconnect>
		return;
   10ae3:	e9 9f 00 00 00       	jmpq   10b87 <enh_conn_complete+0x279>
	bt_addr_le_copy(&conn->le.dst, &id_addr);
   10ae8:	48 8d bb d8 00 00 00 	lea    0xd8(%rbx),%rdi
	conn->handle = handle;
   10aef:	66 44 89 23          	mov    %r12w,(%rbx)
	bt_addr_le_copy(&conn->le.dst, &id_addr);
   10af3:	4c 89 f6             	mov    %r14,%rsi
   10af6:	e8 c2 cc ff ff       	callq  d7bd <bt_addr_le_copy>
	conn->le.interval = sys_le16_to_cpu(evt->interval);
   10afb:	66 8b 45 17          	mov    0x17(%rbp),%ax
   10aff:	66 89 83 ee 00 00 00 	mov    %ax,0xee(%rbx)
	conn->le.latency = sys_le16_to_cpu(evt->latency);
   10b06:	66 8b 45 19          	mov    0x19(%rbp),%ax
   10b0a:	66 89 83 f4 00 00 00 	mov    %ax,0xf4(%rbx)
	conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
   10b11:	66 8b 45 1b          	mov    0x1b(%rbp),%ax
   10b15:	66 89 83 f6 00 00 00 	mov    %ax,0xf6(%rbx)
	conn->role = evt->role;
   10b1c:	8a 45 03             	mov    0x3(%rbp),%al
	conn->err = 0U;
   10b1f:	c6 43 09 00          	movb   $0x0,0x9(%rbx)
	conn->role = evt->role;
   10b23:	88 43 03             	mov    %al,0x3(%rbx)
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   10b26:	fe c8                	dec    %al
   10b28:	75 40                	jne    10b6a <enh_conn_complete+0x25c>
		bt_addr_le_copy(&conn->le.init_addr, &peer_addr);
   10b2a:	48 8d bb df 00 00 00 	lea    0xdf(%rbx),%rdi
   10b31:	4c 89 fe             	mov    %r15,%rsi
   10b34:	e8 84 cc ff ff       	callq  d7bd <bt_addr_le_copy>
			struct bt_le_ext_adv *adv = bt_adv_lookup_legacy();
   10b39:	e8 3a e0 ff ff       	callq  eb78 <bt_adv_lookup_legacy>
						&bt_dev.id_addr[conn->id]);
   10b3e:	0f b6 73 08          	movzbl 0x8(%rbx),%esi
   10b42:	48 8d 05 f7 5a 22 00 	lea    0x225af7(%rip),%rax        # 236640 <bt_dev>
				bt_addr_le_copy(&conn->le.resp_addr,
   10b49:	48 8d bb e6 00 00 00 	lea    0xe6(%rbx),%rdi
						&bt_dev.id_addr[conn->id]);
   10b50:	48 6b f6 07          	imul   $0x7,%rsi,%rsi
   10b54:	48 01 c6             	add    %rax,%rsi
				bt_addr_le_copy(&conn->le.resp_addr,
   10b57:	e8 61 cc ff ff       	callq  d7bd <bt_addr_le_copy>
		if (BT_LE_STATES_SLAVE_CONN_ADV(bt_dev.le.states)) {
   10b5c:	f6 80 b4 00 00 00 40 	testb  $0x40,0xb4(%rax)
   10b63:	74 05                	je     10b6a <enh_conn_complete+0x25c>
			bt_le_adv_resume();
   10b65:	e8 cc fc ff ff       	callq  10836 <bt_le_adv_resume>
	bt_conn_set_state(conn, BT_CONN_CONNECTED);
   10b6a:	be 07 00 00 00       	mov    $0x7,%esi
   10b6f:	48 89 df             	mov    %rbx,%rdi
   10b72:	e8 81 0c 00 00       	callq  117f8 <bt_conn_set_state>
	conn_auto_initiate(conn);
   10b77:	48 89 df             	mov    %rbx,%rdi
   10b7a:	e8 6f e3 ff ff       	callq  eeee <conn_auto_initiate>
	bt_conn_unref(conn);
   10b7f:	48 89 df             	mov    %rbx,%rdi
   10b82:	e8 dd 0b 00 00       	callq  11764 <bt_conn_unref>
}
   10b87:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
   10b8c:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   10b93:	00 00 
   10b95:	74 05                	je     10b9c <enh_conn_complete+0x28e>
   10b97:	e8 a4 3a ff ff       	callq  4640 <__stack_chk_fail@plt>
   10b9c:	48 83 c4 38          	add    $0x38,%rsp
   10ba0:	5b                   	pop    %rbx
   10ba1:	5d                   	pop    %rbp
   10ba2:	41 5c                	pop    %r12
   10ba4:	41 5d                	pop    %r13
   10ba6:	41 5e                	pop    %r14
   10ba8:	41 5f                	pop    %r15
   10baa:	c3                   	retq   

0000000000010bab <le_enh_conn_complete>:
	enh_conn_complete((void *)buf->data);
   10bab:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
   10baf:	e9 5a fd ff ff       	jmpq   1090e <enh_conn_complete>

0000000000010bb4 <le_legacy_conn_complete>:
{
   10bb4:	48 83 ec 58          	sub    $0x58,%rsp
	struct bt_hci_evt_le_conn_complete *evt = (void *)buf->data;
   10bb8:	48 8b 77 10          	mov    0x10(%rdi),%rsi
{
   10bbc:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   10bc3:	00 00 
   10bc5:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
   10bca:	31 c0                	xor    %eax,%eax
	bt_addr_le_copy(&enh.peer_addr, &evt->peer_addr);
   10bcc:	48 8d 7c 24 2e       	lea    0x2e(%rsp),%rdi
   10bd1:	48 8d 54 24 2a       	lea    0x2a(%rsp),%rdx
	enh.status         = evt->status;
   10bd6:	8a 06                	mov    (%rsi),%al
	bt_addr_le_copy(&enh.peer_addr, &evt->peer_addr);
   10bd8:	48 83 c6 04          	add    $0x4,%rsi
	enh.status         = evt->status;
   10bdc:	88 44 24 2a          	mov    %al,0x2a(%rsp)
	enh.handle         = evt->handle;
   10be0:	66 8b 46 fd          	mov    -0x3(%rsi),%ax
   10be4:	66 89 44 24 2b       	mov    %ax,0x2b(%rsp)
	enh.role           = evt->role;
   10be9:	8a 46 ff             	mov    -0x1(%rsi),%al
   10bec:	88 44 24 2d          	mov    %al,0x2d(%rsp)
	enh.interval       = evt->interval;
   10bf0:	66 8b 46 07          	mov    0x7(%rsi),%ax
   10bf4:	66 89 44 24 41       	mov    %ax,0x41(%rsp)
	enh.latency        = evt->latency;
   10bf9:	66 8b 46 09          	mov    0x9(%rsi),%ax
   10bfd:	66 89 44 24 43       	mov    %ax,0x43(%rsp)
	enh.supv_timeout   = evt->supv_timeout;
   10c02:	66 8b 46 0b          	mov    0xb(%rsi),%ax
   10c06:	66 89 44 24 45       	mov    %ax,0x45(%rsp)
	enh.clock_accuracy = evt->clock_accuracy;
   10c0b:	8a 46 0d             	mov    0xd(%rsi),%al
   10c0e:	88 44 24 47          	mov    %al,0x47(%rsp)
	bt_addr_le_copy(&enh.peer_addr, &evt->peer_addr);
   10c12:	e8 a6 cb ff ff       	callq  d7bd <bt_addr_le_copy>
		bt_addr_copy(&enh.local_rpa, BT_ADDR_ANY);
   10c17:	48 8d 7c 24 1e       	lea    0x1e(%rsp),%rdi
   10c1c:	31 c0                	xor    %eax,%eax
   10c1e:	b9 06 00 00 00       	mov    $0x6,%ecx
   10c23:	48 8d 74 24 1e       	lea    0x1e(%rsp),%rsi
   10c28:	88 44 24 0f          	mov    %al,0xf(%rsp)
   10c2c:	f3 aa                	rep stos %al,%es:(%rdi)
   10c2e:	48 8d 7a 0b          	lea    0xb(%rdx),%rdi
   10c32:	e8 79 cb ff ff       	callq  d7b0 <bt_addr_copy>
	bt_addr_copy(&enh.peer_rpa, BT_ADDR_ANY);
   10c37:	8a 44 24 0f          	mov    0xf(%rsp),%al
   10c3b:	48 8d 7c 24 24       	lea    0x24(%rsp),%rdi
   10c40:	b9 06 00 00 00       	mov    $0x6,%ecx
   10c45:	48 8d 74 24 24       	lea    0x24(%rsp),%rsi
   10c4a:	f3 aa                	rep stos %al,%es:(%rdi)
   10c4c:	48 8d 7a 11          	lea    0x11(%rdx),%rdi
   10c50:	e8 5b cb ff ff       	callq  d7b0 <bt_addr_copy>
	enh_conn_complete(&enh);
   10c55:	48 89 d7             	mov    %rdx,%rdi
   10c58:	e8 b1 fc ff ff       	callq  1090e <enh_conn_complete>
}
   10c5d:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
   10c62:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   10c69:	00 00 
   10c6b:	74 05                	je     10c72 <le_legacy_conn_complete+0xbe>
   10c6d:	e8 ce 39 ff ff       	callq  4640 <__stack_chk_fail@plt>
   10c72:	48 83 c4 58          	add    $0x58,%rsp
   10c76:	c3                   	retq   

0000000000010c77 <prng_reseed.constprop.1>:

#include "hci_core.h"

static struct tc_hmac_prng_struct prng;

static int prng_reseed(struct tc_hmac_prng_struct *h)
   10c77:	41 55                	push   %r13
   10c79:	41 54                	push   %r12
   10c7b:	55                   	push   %rbp
   10c7c:	53                   	push   %rbx
	uint8_t seed[32];
	int64_t extra;
	size_t i;
	int ret;

	for (i = 0; i < (sizeof(seed) / 8); i++) {
   10c7d:	31 db                	xor    %ebx,%ebx
static int prng_reseed(struct tc_hmac_prng_struct *h)
   10c7f:	48 83 ec 38          	sub    $0x38,%rsp
   10c83:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   10c8a:	00 00 
   10c8c:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
   10c91:	31 c0                	xor    %eax,%eax
		struct bt_hci_rp_le_rand *rp;
		struct net_buf *rsp;

		ret = bt_hci_cmd_send_sync(BT_HCI_OP_LE_RAND, NULL, &rsp);
   10c93:	49 89 e5             	mov    %rsp,%r13
   10c96:	31 f6                	xor    %esi,%esi
   10c98:	4c 89 ea             	mov    %r13,%rdx
   10c9b:	bf 18 20 00 00       	mov    $0x2018,%edi
   10ca0:	e8 16 d9 ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
		if (ret) {
   10ca5:	85 c0                	test   %eax,%eax
		ret = bt_hci_cmd_send_sync(BT_HCI_OP_LE_RAND, NULL, &rsp);
   10ca7:	89 c5                	mov    %eax,%ebp
		if (ret) {
   10ca9:	75 7c                	jne    10d27 <prng_reseed.constprop.1+0xb0>
			return ret;
		}

		rp = (void *)rsp->data;
   10cab:	48 8b 3c 24          	mov    (%rsp),%rdi
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
   10caf:	4c 8d 64 24 08       	lea    0x8(%rsp),%r12
   10cb4:	48 8b 47 10          	mov    0x10(%rdi),%rax
   10cb8:	48 8b 40 01          	mov    0x1(%rax),%rax
   10cbc:	49 89 04 dc          	mov    %rax,(%r12,%rbx,8)
	for (i = 0; i < (sizeof(seed) / 8); i++) {
   10cc0:	48 ff c3             	inc    %rbx
		memcpy(&seed[i * 8], rp->rand, 8);

		net_buf_unref(rsp);
   10cc3:	e8 d2 82 00 00       	callq  18f9a <net_buf_unref>
	for (i = 0; i < (sizeof(seed) / 8); i++) {
   10cc8:	48 83 fb 04          	cmp    $0x4,%rbx
   10ccc:	75 c8                	jne    10c96 <prng_reseed.constprop.1+0x1f>
	return z_impl_k_uptime_ticks();
   10cce:	31 c0                	xor    %eax,%eax
   10cd0:	e8 de ba 01 00       	callq  2c7b3 <z_impl_k_uptime_ticks>
   10cd5:	48 6b c0 0a          	imul   $0xa,%rax,%rax
	}

	extra = k_uptime_get();

	ret = tc_hmac_prng_reseed(h, seed, sizeof(seed), (uint8_t *)&extra,
   10cd9:	48 8d 3d 40 63 24 00 	lea    0x246340(%rip),%rdi        # 257020 <prng>
   10ce0:	41 b8 08 00 00 00    	mov    $0x8,%r8d
   10ce6:	4c 89 e9             	mov    %r13,%rcx
   10ce9:	ba 20 00 00 00       	mov    $0x20,%edx
   10cee:	4c 89 e6             	mov    %r12,%rsi
	extra = k_uptime_get();
   10cf1:	48 89 04 24          	mov    %rax,(%rsp)
	ret = tc_hmac_prng_reseed(h, seed, sizeof(seed), (uint8_t *)&extra,
   10cf5:	e8 6a 96 ff ff       	callq  a364 <tc_hmac_prng_reseed>
				  sizeof(extra));
	if (ret == TC_CRYPTO_FAIL) {
   10cfa:	85 c0                	test   %eax,%eax
   10cfc:	75 29                	jne    10d27 <prng_reseed.constprop.1+0xb0>
   10cfe:	48 8d 35 9b 96 22 00 	lea    0x22969b(%rip),%rsi        # 23a3a0 <log_const_bt_crypto>
   10d05:	48 2b 35 44 52 22 00 	sub    0x225244(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Failed to re-seed PRNG");
   10d0c:	48 8d 3d 52 1c 02 00 	lea    0x21c52(%rip),%rdi        # 32965 <__func__.5785+0x1cfd>
   10d13:	bd fb ff ff ff       	mov    $0xfffffffb,%ebp
   10d18:	48 c1 ee 04          	shr    $0x4,%rsi
   10d1c:	c1 e6 06             	shl    $0x6,%esi
   10d1f:	83 ce 01             	or     $0x1,%esi
   10d22:	e8 9d 65 ff ff       	callq  72c4 <log_0>
		return -EIO;
	}

	return 0;
}
   10d27:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
   10d2c:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   10d33:	00 00 
   10d35:	89 e8                	mov    %ebp,%eax
   10d37:	74 05                	je     10d3e <prng_reseed.constprop.1+0xc7>
   10d39:	e8 02 39 ff ff       	callq  4640 <__stack_chk_fail@plt>
   10d3e:	48 83 c4 38          	add    $0x38,%rsp
   10d42:	5b                   	pop    %rbx
   10d43:	5d                   	pop    %rbp
   10d44:	41 5c                	pop    %r12
   10d46:	41 5d                	pop    %r13
   10d48:	c3                   	retq   

0000000000010d49 <prng_init>:

int prng_init(void)
{
   10d49:	53                   	push   %rbx
   10d4a:	48 83 ec 10          	sub    $0x10,%rsp
	struct bt_hci_rp_le_rand *rp;
	struct net_buf *rsp;
	int ret;

	/* Check first that HCI_LE_Rand is supported */
	if (!BT_CMD_TEST(bt_dev.supported_commands, 27, 7)) {
   10d4e:	48 8d 15 eb 58 22 00 	lea    0x2258eb(%rip),%rdx        # 236640 <bt_dev>
{
   10d55:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   10d5c:	00 00 
   10d5e:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   10d63:	31 c0                	xor    %eax,%eax
		return -ENOTSUP;
   10d65:	b8 a1 ff ff ff       	mov    $0xffffffa1,%eax
	if (!BT_CMD_TEST(bt_dev.supported_commands, 27, 7)) {
   10d6a:	80 7a 5f 00          	cmpb   $0x0,0x5f(%rdx)
   10d6e:	79 6e                	jns    10dde <prng_init+0x95>
	}

	ret = bt_hci_cmd_send_sync(BT_HCI_OP_LE_RAND, NULL, &rsp);
   10d70:	31 f6                	xor    %esi,%esi
   10d72:	48 89 e2             	mov    %rsp,%rdx
   10d75:	bf 18 20 00 00       	mov    $0x2018,%edi
   10d7a:	e8 3c d8 ff ff       	callq  e5bb <bt_hci_cmd_send_sync>
	if (ret) {
   10d7f:	85 c0                	test   %eax,%eax
   10d81:	75 5b                	jne    10dde <prng_init+0x95>
		return ret;
	}

	rp = (void *)rsp->data;
   10d83:	48 8b 04 24          	mov    (%rsp),%rax

	ret = tc_hmac_prng_init(&prng, rp->rand, sizeof(rp->rand));
   10d87:	48 8d 3d 92 62 24 00 	lea    0x246292(%rip),%rdi        # 257020 <prng>
   10d8e:	ba 08 00 00 00       	mov    $0x8,%edx
   10d93:	48 8b 70 10          	mov    0x10(%rax),%rsi
   10d97:	48 ff c6             	inc    %rsi
   10d9a:	e8 5b 95 ff ff       	callq  a2fa <tc_hmac_prng_init>

	net_buf_unref(rsp);
   10d9f:	48 8b 3c 24          	mov    (%rsp),%rdi
	ret = tc_hmac_prng_init(&prng, rp->rand, sizeof(rp->rand));
   10da3:	89 c3                	mov    %eax,%ebx
	net_buf_unref(rsp);
   10da5:	e8 f0 81 00 00       	callq  18f9a <net_buf_unref>

	if (ret == TC_CRYPTO_FAIL) {
   10daa:	85 db                	test   %ebx,%ebx
   10dac:	75 2b                	jne    10dd9 <prng_init+0x90>
   10dae:	48 8d 35 eb 95 22 00 	lea    0x2295eb(%rip),%rsi        # 23a3a0 <log_const_bt_crypto>
   10db5:	48 2b 35 94 51 22 00 	sub    0x225194(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Failed to initialize PRNG");
   10dbc:	48 8d 3d b9 1b 02 00 	lea    0x21bb9(%rip),%rdi        # 3297c <__func__.5785+0x1d14>
   10dc3:	48 c1 ee 04          	shr    $0x4,%rsi
   10dc7:	c1 e6 06             	shl    $0x6,%esi
   10dca:	83 ce 01             	or     $0x1,%esi
   10dcd:	e8 f2 64 ff ff       	callq  72c4 <log_0>
		return -EIO;
   10dd2:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   10dd7:	eb 05                	jmp    10dde <prng_init+0x95>
	}

	/* re-seed is needed after init */
	return prng_reseed(&prng);
   10dd9:	e8 99 fe ff ff       	callq  10c77 <prng_reseed.constprop.1>
}
   10dde:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
   10de3:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   10dea:	00 00 
   10dec:	74 05                	je     10df3 <prng_init+0xaa>
   10dee:	e8 4d 38 ff ff       	callq  4640 <__stack_chk_fail@plt>
   10df3:	48 83 c4 10          	add    $0x10,%rsp
   10df7:	5b                   	pop    %rbx
   10df8:	c3                   	retq   

0000000000010df9 <bt_rand>:

int bt_rand(void *buf, size_t len)
{
   10df9:	55                   	push   %rbp
   10dfa:	53                   	push   %rbx
	int ret;

	ret = tc_hmac_prng_generate(buf, len, &prng);
   10dfb:	48 8d 15 1e 62 24 00 	lea    0x24621e(%rip),%rdx        # 257020 <prng>
{
   10e02:	48 89 fb             	mov    %rdi,%rbx
   10e05:	48 89 f5             	mov    %rsi,%rbp
   10e08:	48 83 ec 08          	sub    $0x8,%rsp
	ret = tc_hmac_prng_generate(buf, len, &prng);
   10e0c:	e8 9f 95 ff ff       	callq  a3b0 <tc_hmac_prng_generate>
	if (ret == TC_HMAC_PRNG_RESEED_REQ) {
   10e11:	83 f8 ff             	cmp    $0xffffffff,%eax
   10e14:	75 1a                	jne    10e30 <bt_rand+0x37>
		ret = prng_reseed(&prng);
   10e16:	e8 5c fe ff ff       	callq  10c77 <prng_reseed.constprop.1>
		if (ret) {
   10e1b:	85 c0                	test   %eax,%eax
   10e1d:	75 1d                	jne    10e3c <bt_rand+0x43>
			return ret;
		}

		ret = tc_hmac_prng_generate(buf, len, &prng);
   10e1f:	48 8d 15 fa 61 24 00 	lea    0x2461fa(%rip),%rdx        # 257020 <prng>
   10e26:	89 ee                	mov    %ebp,%esi
   10e28:	48 89 df             	mov    %rbx,%rdi
   10e2b:	e8 80 95 ff ff       	callq  a3b0 <tc_hmac_prng_generate>

	if (ret == TC_CRYPTO_SUCCESS) {
		return 0;
	}

	return -EIO;
   10e30:	ff c8                	dec    %eax
   10e32:	0f 94 c0             	sete   %al
   10e35:	0f b6 c0             	movzbl %al,%eax
   10e38:	8d 44 80 fb          	lea    -0x5(%rax,%rax,4),%eax
}
   10e3c:	5a                   	pop    %rdx
   10e3d:	5b                   	pop    %rbx
   10e3e:	5d                   	pop    %rbp
   10e3f:	c3                   	retq   

0000000000010e40 <state2str>:
	return &bt_dev.le.acl_pkts;
}

static inline const char *state2str(bt_conn_state_t state)
{
	switch (state) {
   10e40:	40 80 ff 08          	cmp    $0x8,%dil
{
   10e44:	40 0f b6 d7          	movzbl %dil,%edx
	case BT_CONN_CONNECTED:
		return "connected";
	case BT_CONN_DISCONNECT:
		return "disconnect";
	default:
		return "(unknown)";
   10e48:	48 8d 05 a6 1b 02 00 	lea    0x21ba6(%rip),%rax        # 329f5 <__func__.5785+0x1d8d>
	switch (state) {
   10e4f:	77 57                	ja     10ea8 <state2str+0x68>
   10e51:	48 8d 0d d8 fe 01 00 	lea    0x1fed8(%rip),%rcx        # 30d30 <__func__.5785+0xc8>
   10e58:	48 63 04 91          	movslq (%rcx,%rdx,4),%rax
   10e5c:	48 01 c8             	add    %rcx,%rax
   10e5f:	ff e0                	jmpq   *%rax
		return "disconnect-complete";
   10e61:	48 8d 05 38 1b 02 00 	lea    0x21b38(%rip),%rax        # 329a0 <__func__.5785+0x1d38>
   10e68:	c3                   	retq   
		return "connect-scan";
   10e69:	48 8d 05 44 1b 02 00 	lea    0x21b44(%rip),%rax        # 329b4 <__func__.5785+0x1d4c>
   10e70:	c3                   	retq   
		return "connect-dir-adv";
   10e71:	48 8d 05 49 1b 02 00 	lea    0x21b49(%rip),%rax        # 329c1 <__func__.5785+0x1d59>
   10e78:	c3                   	retq   
		return "connect-adv";
   10e79:	48 8d 05 51 1b 02 00 	lea    0x21b51(%rip),%rax        # 329d1 <__func__.5785+0x1d69>
   10e80:	c3                   	retq   
		return "connect-auto";
   10e81:	48 8d 05 55 1b 02 00 	lea    0x21b55(%rip),%rax        # 329dd <__func__.5785+0x1d75>
   10e88:	c3                   	retq   
		return "connect";
   10e89:	48 8d 05 5d 1b 02 00 	lea    0x21b5d(%rip),%rax        # 329ed <__func__.5785+0x1d85>
   10e90:	c3                   	retq   
		return "connected";
   10e91:	48 8d 05 bc 1e 02 00 	lea    0x21ebc(%rip),%rax        # 32d54 <__func__.5785+0x20ec>
   10e98:	c3                   	retq   
		return "disconnect";
   10e99:	48 8d 05 4a 1b 02 00 	lea    0x21b4a(%rip),%rax        # 329ea <__func__.5785+0x1d82>
   10ea0:	c3                   	retq   
		return "disconnected";
   10ea1:	48 8d 05 e8 1e 02 00 	lea    0x21ee8(%rip),%rax        # 32d90 <__func__.5785+0x2128>
	}
}
   10ea8:	c3                   	retq   

0000000000010ea9 <tx_free>:
	 */
	return bt_l2cap_update_conn_param(conn, param);
}

static void tx_free(struct bt_conn_tx *tx)
{
   10ea9:	48 89 fe             	mov    %rdi,%rsi
	tx->cb = NULL;
   10eac:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
   10eb3:	00 
	tx->user_data = NULL;
   10eb4:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
   10ebb:	00 
	tx->pending_no_cb = 0U;
   10ebc:	c7 47 18 00 00 00 00 	movl   $0x0,0x18(%rdi)
	k_fifo_put(&free_tx, tx);
   10ec3:	48 8d 3d 06 98 22 00 	lea    0x229806(%rip),%rdi        # 23a6d0 <_k_sem_list_end>
   10eca:	e9 5c a4 01 00       	jmpq   2b32b <k_queue_append>

0000000000010ecf <notify_connected>:
{
   10ecf:	55                   	push   %rbp
   10ed0:	53                   	push   %rbx
   10ed1:	48 89 fd             	mov    %rdi,%rbp
   10ed4:	48 83 ec 08          	sub    $0x8,%rsp
	for (cb = callback_list; cb; cb = cb->_next) {
   10ed8:	48 8b 1d c1 70 24 00 	mov    0x2470c1(%rip),%rbx        # 257fa0 <callback_list>
   10edf:	48 85 db             	test   %rbx,%rbx
   10ee2:	0f b6 75 09          	movzbl 0x9(%rbp),%esi
   10ee6:	74 13                	je     10efb <notify_connected+0x2c>
		if (cb->connected) {
   10ee8:	48 8b 03             	mov    (%rbx),%rax
   10eeb:	48 85 c0             	test   %rax,%rax
   10eee:	74 05                	je     10ef5 <notify_connected+0x26>
			cb->connected(conn, conn->err);
   10ef0:	48 89 ef             	mov    %rbp,%rdi
   10ef3:	ff d0                	callq  *%rax
	for (cb = callback_list; cb; cb = cb->_next) {
   10ef5:	48 8b 5b 20          	mov    0x20(%rbx),%rbx
   10ef9:	eb e4                	jmp    10edf <notify_connected+0x10>
	if (!conn->err) {
   10efb:	40 84 f6             	test   %sil,%sil
   10efe:	75 0b                	jne    10f0b <notify_connected+0x3c>
}
   10f00:	5a                   	pop    %rdx
		bt_gatt_connected(conn);
   10f01:	48 89 ef             	mov    %rbp,%rdi
}
   10f04:	5b                   	pop    %rbx
   10f05:	5d                   	pop    %rbp
		bt_gatt_connected(conn);
   10f06:	e9 a7 77 00 00       	jmpq   186b2 <bt_gatt_connected>
}
   10f0b:	58                   	pop    %rax
   10f0c:	5b                   	pop    %rbx
   10f0d:	5d                   	pop    %rbp
   10f0e:	c3                   	retq   

0000000000010f0f <tx_notify>:
}

static void tx_notify(struct bt_conn *conn)
{
   10f0f:	41 55                	push   %r13
   10f11:	41 54                	push   %r12
   10f13:	55                   	push   %rbp
   10f14:	53                   	push   %rbx
   10f15:	48 89 fd             	mov    %rdi,%rbp
   10f18:	48 83 ec 08          	sub    $0x8,%rsp
	return posix_irq_lock();
   10f1c:	e8 71 b0 ff ff       	callq  bf92 <posix_irq_lock>
Z_GENLIST_IS_EMPTY(slist)
   10f21:	48 8b 5d 30          	mov    0x30(%rbp),%rbx
   10f25:	89 c7                	mov    %eax,%edi
		unsigned int key;
		bt_conn_tx_cb_t cb;
		void *user_data;

		key = irq_lock();
		if (sys_slist_is_empty(&conn->tx_complete)) {
   10f27:	48 85 db             	test   %rbx,%rbx
   10f2a:	75 0c                	jne    10f38 <tx_notify+0x29>
		 * allocate new buffers since the TX should have been
		 * unblocked by tx_free.
		 */
		cb(conn, user_data);
	}
}
   10f2c:	58                   	pop    %rax
   10f2d:	5b                   	pop    %rbx
   10f2e:	5d                   	pop    %rbp
   10f2f:	41 5c                	pop    %r12
   10f31:	41 5d                	pop    %r13
	posix_irq_unlock(key);
   10f33:	e9 64 b0 ff ff       	jmpq   bf9c <posix_irq_unlock>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   10f38:	48 3b 5d 38          	cmp    0x38(%rbp),%rbx
	return node->next;
   10f3c:	48 8b 03             	mov    (%rbx),%rax
	list->head = node;
   10f3f:	48 89 45 30          	mov    %rax,0x30(%rbp)
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   10f43:	75 04                	jne    10f49 <tx_notify+0x3a>
	list->tail = node;
   10f45:	48 89 45 38          	mov    %rax,0x38(%rbp)
   10f49:	e8 4e b0 ff ff       	callq  bf9c <posix_irq_unlock>
		user_data = tx->user_data;
   10f4e:	4c 8b 6b 10          	mov    0x10(%rbx),%r13
		tx_free(tx);
   10f52:	48 89 df             	mov    %rbx,%rdi
		cb = tx->cb;
   10f55:	4c 8b 63 08          	mov    0x8(%rbx),%r12
		tx_free(tx);
   10f59:	e8 4b ff ff ff       	callq  10ea9 <tx_free>
		cb(conn, user_data);
   10f5e:	48 89 ef             	mov    %rbp,%rdi
   10f61:	4c 89 ee             	mov    %r13,%rsi
   10f64:	41 ff d4             	callq  *%r12
	while (1) {
   10f67:	eb b3                	jmp    10f1c <tx_notify+0xd>

0000000000010f69 <tx_complete_work>:

static void tx_complete_work(struct k_work *work)
{
	struct bt_conn *conn = CONTAINER_OF(work, struct bt_conn,
   10f69:	48 83 ef 40          	sub    $0x40,%rdi
					   tx_complete_work);

	BT_DBG("conn %p", conn);

	tx_notify(conn);
   10f6d:	e9 9d ff ff ff       	jmpq   10f0f <tx_notify>

0000000000010f72 <atomic_test_bit>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   10f72:	8b 07                	mov    (%rdi),%eax
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   10f74:	40 88 f1             	mov    %sil,%cl
   10f77:	d3 f8                	sar    %cl,%eax
   10f79:	83 e0 01             	and    $0x1,%eax
}
   10f7c:	c3                   	retq   

0000000000010f7d <bt_conn_get_pkts>:
	return &bt_dev.le.acl_pkts;
   10f7d:	48 8d 05 bc 56 22 00 	lea    0x2256bc(%rip),%rax        # 236640 <bt_dev>
}
   10f84:	48 05 f0 00 00 00    	add    $0xf0,%rax
   10f8a:	c3                   	retq   

0000000000010f8b <send_frag>:
	return bt_send(buf);
}

static bool send_frag(struct bt_conn *conn, struct net_buf *buf, uint8_t flags,
		      bool always_consume)
{
   10f8b:	41 57                	push   %r15
   10f8d:	41 56                	push   %r14
   10f8f:	41 89 d7             	mov    %edx,%r15d
   10f92:	41 55                	push   %r13
   10f94:	41 54                	push   %r12
   10f96:	55                   	push   %rbp
   10f97:	53                   	push   %rbx
   10f98:	48 89 f5             	mov    %rsi,%rbp
   10f9b:	48 89 fb             	mov    %rdi,%rbx
   10f9e:	48 83 ec 18          	sub    $0x18,%rsp
	struct bt_conn_tx *tx = tx_data(buf)->tx;
   10fa2:	4c 8b 76 28          	mov    0x28(%rsi),%r14
{
   10fa6:	89 4c 24 0c          	mov    %ecx,0xc(%rsp)
   10faa:	44 8a 6c 24 0c       	mov    0xc(%rsp),%r13b

	BT_DBG("conn %p buf %p len %u flags 0x%02x", conn, buf, buf->len,
	       flags);

	/* Wait until the controller can accept ACL packets */
	k_sem_take(bt_conn_get_pkts(conn), K_FOREVER);
   10faf:	e8 c9 ff ff ff       	callq  10f7d <bt_conn_get_pkts>
	return z_impl_k_sem_take(sem, timeout);
   10fb4:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
   10fb8:	48 89 c7             	mov    %rax,%rdi
   10fbb:	e8 d3 af 01 00       	callq  2bf93 <z_impl_k_sem_take>

	/* Check for disconnection while waiting for pkts_sem */
	if (conn->state != BT_CONN_CONNECTED) {
   10fc0:	80 7b 0a 07          	cmpb   $0x7,0xa(%rbx)
   10fc4:	0f 85 23 01 00 00    	jne    110ed <send_frag+0x162>
	return posix_irq_lock();
   10fca:	e8 c3 af ff ff       	callq  bf92 <posix_irq_lock>
		goto fail;
	}

	/* Add to pending, it must be done before bt_buf_set_type */
	key = irq_lock();
	if (tx) {
   10fcf:	4d 85 f6             	test   %r14,%r14
   10fd2:	74 23                	je     10ff7 <send_frag+0x6c>
	parent->next = child;
   10fd4:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
Z_GENLIST_APPEND(slist, snode)
   10fdb:	48 8b 53 20          	mov    0x20(%rbx),%rdx
   10fdf:	48 85 d2             	test   %rdx,%rdx
   10fe2:	75 0a                	jne    10fee <send_frag+0x63>
	list->tail = node;
   10fe4:	4c 89 73 20          	mov    %r14,0x20(%rbx)
	list->head = node;
   10fe8:	4c 89 73 18          	mov    %r14,0x18(%rbx)
   10fec:	eb 28                	jmp    11016 <send_frag+0x8b>
	parent->next = child;
   10fee:	4c 89 32             	mov    %r14,(%rdx)
	list->tail = node;
   10ff1:	4c 89 73 20          	mov    %r14,0x20(%rbx)
   10ff5:	eb 1f                	jmp    11016 <send_frag+0x8b>
		sys_slist_append(&conn->tx_pending, &tx->node);
	} else {
		struct bt_conn_tx *tail_tx;

		tail_tx = (void *)sys_slist_peek_tail(&conn->tx_pending);
   10ff7:	48 8b 53 20          	mov    0x20(%rbx),%rdx
		if (tail_tx) {
   10ffb:	48 85 d2             	test   %rdx,%rdx
   10ffe:	74 09                	je     11009 <send_frag+0x7e>
			pending_no_cb = &tail_tx->pending_no_cb;
   11000:	4c 8d 62 18          	lea    0x18(%rdx),%r12
   11004:	8b 52 18             	mov    0x18(%rdx),%edx
   11007:	eb 07                	jmp    11010 <send_frag+0x85>
		} else {
			pending_no_cb = &conn->pending_no_cb;
   11009:	8b 53 28             	mov    0x28(%rbx),%edx
   1100c:	4c 8d 63 28          	lea    0x28(%rbx),%r12
		}

		(*pending_no_cb)++;
   11010:	ff c2                	inc    %edx
   11012:	41 89 14 24          	mov    %edx,(%r12)
	posix_irq_unlock(key);
   11016:	89 c7                	mov    %eax,%edi
   11018:	e8 7f af ff ff       	callq  bf9c <posix_irq_unlock>
	switch (flags) {
   1101d:	41 80 ff 01          	cmp    $0x1,%r15b
   11021:	74 0b                	je     1102e <send_frag+0xa3>
   11023:	41 80 ff 03          	cmp    $0x3,%r15b
   11027:	74 05                	je     1102e <send_frag+0xa3>
		flags = BT_ACL_START_NO_FLUSH;
   11029:	45 31 ff             	xor    %r15d,%r15d
   1102c:	eb 06                	jmp    11034 <send_frag+0xa9>
		flags = BT_ACL_CONT;
   1102e:	41 bf 01 00 00 00    	mov    $0x1,%r15d
	return net_buf_simple_push(&buf->b, len);
   11034:	48 8d 7d 10          	lea    0x10(%rbp),%rdi
   11038:	be 04 00 00 00       	mov    $0x4,%esi
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
   1103d:	41 c1 e7 0c          	shl    $0xc,%r15d
   11041:	e8 9c 80 00 00       	callq  190e2 <net_buf_simple_push>
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   11046:	8b 4d 18             	mov    0x18(%rbp),%ecx
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
   11049:	44 0b 3b             	or     (%rbx),%r15d
	return bt_send(buf);
   1104c:	48 89 ef             	mov    %rbp,%rdi
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   1104f:	8d 51 fc             	lea    -0x4(%rcx),%edx
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
   11052:	66 44 89 38          	mov    %r15w,(%rax)
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   11056:	66 89 50 02          	mov    %dx,0x2(%rax)
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
   1105a:	c6 45 28 02          	movb   $0x2,0x28(%rbp)
	return bt_send(buf);
   1105e:	e8 c0 db ff ff       	callq  ec23 <bt_send>
		err = send_iso(conn, buf, flags);
	} else {
		err = send_acl(conn, buf, flags);
	}

	if (err) {
   11063:	85 c0                	test   %eax,%eax
   11065:	0f 84 b3 00 00 00    	je     1111e <send_frag+0x193>
   1106b:	48 8d 15 1e 93 22 00 	lea    0x22931e(%rip),%rdx        # 23a390 <log_const_bt_conn>
   11072:	48 2b 15 d7 4e 22 00 	sub    0x224ed7(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unable to send to driver (err %d)", err);
   11079:	48 8d 3d dd 15 02 00 	lea    0x215dd(%rip),%rdi        # 3265d <__func__.5785+0x19f5>
   11080:	48 63 f0             	movslq %eax,%rsi
   11083:	48 c1 ea 04          	shr    $0x4,%rdx
   11087:	c1 e2 06             	shl    $0x6,%edx
   1108a:	83 ca 01             	or     $0x1,%edx
   1108d:	e8 63 62 ff ff       	callq  72f5 <log_1>
	return posix_irq_lock();
   11092:	e8 fb ae ff ff       	callq  bf92 <posix_irq_lock>
		key = irq_lock();
		/* Roll back the pending TX info */
		if (tx) {
   11097:	4d 85 f6             	test   %r14,%r14
   1109a:	74 46                	je     110e2 <send_frag+0x157>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1109c:	48 8b 53 18          	mov    0x18(%rbx),%rdx
   110a0:	31 f6                	xor    %esi,%esi
   110a2:	48 85 d2             	test   %rdx,%rdx
   110a5:	74 3f                	je     110e6 <send_frag+0x15b>
   110a7:	49 39 d6             	cmp    %rdx,%r14
   110aa:	75 2e                	jne    110da <send_frag+0x14f>
Z_GENLIST_REMOVE(slist, snode)
   110ac:	48 85 f6             	test   %rsi,%rsi
   110af:	49 8b 16             	mov    (%r14),%rdx
   110b2:	75 10                	jne    110c4 <send_frag+0x139>
   110b4:	4c 3b 73 20          	cmp    0x20(%rbx),%r14
	list->head = node;
   110b8:	48 89 53 18          	mov    %rdx,0x18(%rbx)
Z_GENLIST_REMOVE(slist, snode)
   110bc:	75 13                	jne    110d1 <send_frag+0x146>
	list->tail = node;
   110be:	48 89 53 20          	mov    %rdx,0x20(%rbx)
   110c2:	eb 0d                	jmp    110d1 <send_frag+0x146>
	parent->next = child;
   110c4:	48 89 16             	mov    %rdx,(%rsi)
Z_GENLIST_REMOVE(slist, snode)
   110c7:	4c 3b 73 20          	cmp    0x20(%rbx),%r14
   110cb:	75 04                	jne    110d1 <send_frag+0x146>
	list->tail = node;
   110cd:	48 89 73 20          	mov    %rsi,0x20(%rbx)
	parent->next = child;
   110d1:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
   110d8:	eb 0c                	jmp    110e6 <send_frag+0x15b>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   110da:	48 89 d6             	mov    %rdx,%rsi
   110dd:	48 8b 12             	mov    (%rdx),%rdx
   110e0:	eb c0                	jmp    110a2 <send_frag+0x117>
			sys_slist_find_and_remove(&conn->tx_pending, &tx->node);
		} else {
			__ASSERT_NO_MSG(*pending_no_cb > 0);
			(*pending_no_cb)--;
   110e2:	41 ff 0c 24          	decl   (%r12)
	posix_irq_unlock(key);
   110e6:	89 c7                	mov    %eax,%edi
   110e8:	e8 af ae ff ff       	callq  bf9c <posix_irq_unlock>
	}

	return true;

fail:
	k_sem_give(bt_conn_get_pkts(conn));
   110ed:	48 89 df             	mov    %rbx,%rdi
   110f0:	e8 88 fe ff ff       	callq  10f7d <bt_conn_get_pkts>
	z_impl_k_sem_give(sem);
   110f5:	48 89 c7             	mov    %rax,%rdi
   110f8:	e8 39 ae 01 00       	callq  2bf36 <z_impl_k_sem_give>
	if (tx) {
   110fd:	4d 85 f6             	test   %r14,%r14
   11100:	74 08                	je     1110a <send_frag+0x17f>
		tx_free(tx);
   11102:	4c 89 f7             	mov    %r14,%rdi
   11105:	e8 9f fd ff ff       	callq  10ea9 <tx_free>
	}

	if (always_consume) {
   1110a:	80 7c 24 0c 00       	cmpb   $0x0,0xc(%rsp)
   1110f:	74 10                	je     11121 <send_frag+0x196>
		net_buf_unref(buf);
   11111:	48 89 ef             	mov    %rbp,%rdi
	}
	return false;
   11114:	45 31 ed             	xor    %r13d,%r13d
		net_buf_unref(buf);
   11117:	e8 7e 7e 00 00       	callq  18f9a <net_buf_unref>
   1111c:	eb 03                	jmp    11121 <send_frag+0x196>
	return true;
   1111e:	41 b5 01             	mov    $0x1,%r13b
}
   11121:	48 83 c4 18          	add    $0x18,%rsp
   11125:	44 88 e8             	mov    %r13b,%al
   11128:	5b                   	pop    %rbx
   11129:	5d                   	pop    %rbp
   1112a:	41 5c                	pop    %r12
   1112c:	41 5d                	pop    %r13
   1112e:	41 5e                	pop    %r14
   11130:	41 5f                	pop    %r15
   11132:	c3                   	retq   

0000000000011133 <notify_le_param_updated>:
{
   11133:	55                   	push   %rbp
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
   11134:	48 8d 57 04          	lea    0x4(%rdi),%rdx
{
   11138:	53                   	push   %rbx
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
   11139:	be 09 00 00 00       	mov    $0x9,%esi
{
   1113e:	48 89 fb             	mov    %rdi,%rbx
   11141:	48 83 ec 08          	sub    $0x8,%rsp
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
   11145:	48 89 d7             	mov    %rdx,%rdi
   11148:	e8 25 fe ff ff       	callq  10f72 <atomic_test_bit>
   1114d:	84 c0                	test   %al,%al
   1114f:	74 2e                	je     1117f <notify_le_param_updated+0x4c>
	    conn->le.interval >= conn->le.interval_min &&
   11151:	66 8b 83 ee 00 00 00 	mov    0xee(%rbx),%ax
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
   11158:	66 3b 83 f0 00 00 00 	cmp    0xf0(%rbx),%ax
   1115f:	72 1e                	jb     1117f <notify_le_param_updated+0x4c>
	    conn->le.interval >= conn->le.interval_min &&
   11161:	66 3b 83 f2 00 00 00 	cmp    0xf2(%rbx),%ax
   11168:	77 15                	ja     1117f <notify_le_param_updated+0x4c>
	    conn->le.latency == conn->le.pending_latency &&
   1116a:	8b 83 f8 00 00 00    	mov    0xf8(%rbx),%eax
   11170:	39 83 f4 00 00 00    	cmp    %eax,0xf4(%rbx)
   11176:	75 07                	jne    1117f <notify_le_param_updated+0x4c>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   11178:	f0 81 22 ff fd ff ff 	lock andl $0xfffffdff,(%rdx)
	for (cb = callback_list; cb; cb = cb->_next) {
   1117f:	48 8b 2d 1a 6e 24 00 	mov    0x246e1a(%rip),%rbp        # 257fa0 <callback_list>
   11186:	48 85 ed             	test   %rbp,%rbp
   11189:	74 29                	je     111b4 <notify_le_param_updated+0x81>
		if (cb->le_param_updated) {
   1118b:	48 8b 45 18          	mov    0x18(%rbp),%rax
   1118f:	48 85 c0             	test   %rax,%rax
   11192:	74 1a                	je     111ae <notify_le_param_updated+0x7b>
			cb->le_param_updated(conn, conn->le.interval,
   11194:	0f b7 8b f6 00 00 00 	movzwl 0xf6(%rbx),%ecx
   1119b:	0f b7 93 f4 00 00 00 	movzwl 0xf4(%rbx),%edx
   111a2:	48 89 df             	mov    %rbx,%rdi
   111a5:	0f b7 b3 ee 00 00 00 	movzwl 0xee(%rbx),%esi
   111ac:	ff d0                	callq  *%rax
	for (cb = callback_list; cb; cb = cb->_next) {
   111ae:	48 8b 6d 20          	mov    0x20(%rbp),%rbp
   111b2:	eb d2                	jmp    11186 <notify_le_param_updated+0x53>
}
   111b4:	58                   	pop    %rax
   111b5:	5b                   	pop    %rbx
   111b6:	5d                   	pop    %rbp
   111b7:	c3                   	retq   

00000000000111b8 <le_param_req>:
{
   111b8:	41 55                	push   %r13
   111ba:	41 54                	push   %r12
   111bc:	49 89 fd             	mov    %rdi,%r13
   111bf:	55                   	push   %rbp
   111c0:	53                   	push   %rbx
	if (!bt_le_conn_params_valid(param)) {
   111c1:	48 89 f7             	mov    %rsi,%rdi
{
   111c4:	49 89 f4             	mov    %rsi,%r12
   111c7:	48 83 ec 08          	sub    $0x8,%rsp
	if (!bt_le_conn_params_valid(param)) {
   111cb:	e8 07 da ff ff       	callq  ebd7 <bt_le_conn_params_valid>
   111d0:	84 c0                	test   %al,%al
	for (cb = callback_list; cb; cb = cb->_next) {
   111d2:	48 8b 1d c7 6d 24 00 	mov    0x246dc7(%rip),%rbx        # 257fa0 <callback_list>
   111d9:	40 88 c5             	mov    %al,%bpl
	if (!bt_le_conn_params_valid(param)) {
   111dc:	75 11                	jne    111ef <le_param_req+0x37>
		return false;
   111de:	31 ed                	xor    %ebp,%ebp
   111e0:	eb 2e                	jmp    11210 <le_param_req+0x58>
		if (!cb->le_param_req) {
   111e2:	48 8b 43 10          	mov    0x10(%rbx),%rax
   111e6:	48 85 c0             	test   %rax,%rax
   111e9:	75 0b                	jne    111f6 <le_param_req+0x3e>
	for (cb = callback_list; cb; cb = cb->_next) {
   111eb:	48 8b 5b 20          	mov    0x20(%rbx),%rbx
   111ef:	48 85 db             	test   %rbx,%rbx
   111f2:	75 ee                	jne    111e2 <le_param_req+0x2a>
   111f4:	eb 1a                	jmp    11210 <le_param_req+0x58>
		if (!cb->le_param_req(conn, param)) {
   111f6:	4c 89 e6             	mov    %r12,%rsi
   111f9:	4c 89 ef             	mov    %r13,%rdi
   111fc:	ff d0                	callq  *%rax
   111fe:	84 c0                	test   %al,%al
   11200:	74 dc                	je     111de <le_param_req+0x26>
		if (!bt_le_conn_params_valid(param)) {
   11202:	4c 89 e7             	mov    %r12,%rdi
   11205:	e8 cd d9 ff ff       	callq  ebd7 <bt_le_conn_params_valid>
   1120a:	84 c0                	test   %al,%al
   1120c:	75 dd                	jne    111eb <le_param_req+0x33>
   1120e:	eb ce                	jmp    111de <le_param_req+0x26>
}
   11210:	5a                   	pop    %rdx
   11211:	40 88 e8             	mov    %bpl,%al
   11214:	5b                   	pop    %rbx
   11215:	5d                   	pop    %rbp
   11216:	41 5c                	pop    %r12
   11218:	41 5d                	pop    %r13
   1121a:	c3                   	retq   

000000000001121b <bt_conn_new>:
	for (i = 0; i < size; i++) {
   1121b:	31 c9                	xor    %ecx,%ecx
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   1121d:	45 31 c0             	xor    %r8d,%r8d
   11220:	41 b9 01 00 00 00    	mov    $0x1,%r9d
   11226:	48 63 d1             	movslq %ecx,%rdx
   11229:	48 39 f2             	cmp    %rsi,%rdx
   1122c:	73 1c                	jae    1124a <bt_conn_new+0x2f>
		if (atomic_cas(&conns[i].ref, 0, 1)) {
   1122e:	48 69 d2 18 01 00 00 	imul   $0x118,%rdx,%rdx
   11235:	44 89 c0             	mov    %r8d,%eax
   11238:	48 01 fa             	add    %rdi,%rdx
   1123b:	f0 44 0f b1 8a 10 01 	lock cmpxchg %r9d,0x110(%rdx)
   11242:	00 00 
   11244:	74 08                	je     1124e <bt_conn_new+0x33>
	for (i = 0; i < size; i++) {
   11246:	ff c1                	inc    %ecx
   11248:	eb dc                	jmp    11226 <bt_conn_new+0xb>
		return NULL;
   1124a:	31 d2                	xor    %edx,%edx
   1124c:	eb 12                	jmp    11260 <bt_conn_new+0x45>
	if (!conn) {
   1124e:	48 85 d2             	test   %rdx,%rdx
   11251:	74 0d                	je     11260 <bt_conn_new+0x45>
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
   11253:	b9 44 00 00 00       	mov    $0x44,%ecx
   11258:	48 89 d7             	mov    %rdx,%rdi
   1125b:	44 89 c0             	mov    %r8d,%eax
   1125e:	f3 ab                	rep stos %eax,%es:(%rdi)
}
   11260:	48 89 d0             	mov    %rdx,%rax
   11263:	c3                   	retq   

0000000000011264 <bt_conn_get_security>:
}
   11264:	b0 01                	mov    $0x1,%al
   11266:	c3                   	retq   

0000000000011267 <bt_conn_cb_register>:
	cb->_next = callback_list;
   11267:	48 8b 05 32 6d 24 00 	mov    0x246d32(%rip),%rax        # 257fa0 <callback_list>
	callback_list = cb;
   1126e:	48 89 3d 2b 6d 24 00 	mov    %rdi,0x246d2b(%rip)        # 257fa0 <callback_list>
	cb->_next = callback_list;
   11275:	48 89 47 20          	mov    %rax,0x20(%rdi)
}
   11279:	c3                   	retq   

000000000001127a <bt_conn_reset_rx_state>:
{
   1127a:	53                   	push   %rbx
   1127b:	48 89 fb             	mov    %rdi,%rbx
	if (!conn->rx) {
   1127e:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
   11282:	48 85 ff             	test   %rdi,%rdi
   11285:	74 0d                	je     11294 <bt_conn_reset_rx_state+0x1a>
	net_buf_unref(conn->rx);
   11287:	e8 0e 7d 00 00       	callq  18f9a <net_buf_unref>
	conn->rx = NULL;
   1128c:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
   11293:	00 
}
   11294:	5b                   	pop    %rbx
   11295:	c3                   	retq   

0000000000011296 <conn_cleanup>:

static struct k_poll_signal conn_change =
		K_POLL_SIGNAL_INITIALIZER(conn_change);

static void conn_cleanup(struct bt_conn *conn)
{
   11296:	41 54                	push   %r12
	struct net_buf *buf;

	/* Give back any allocated buffers */
	while ((buf = net_buf_get(&conn->tx_queue, K_NO_WAIT))) {
   11298:	4c 8d 67 58          	lea    0x58(%rdi),%r12
{
   1129c:	55                   	push   %rbp
   1129d:	53                   	push   %rbx
   1129e:	48 89 fb             	mov    %rdi,%rbx
	while ((buf = net_buf_get(&conn->tx_queue, K_NO_WAIT))) {
   112a1:	31 f6                	xor    %esi,%esi
   112a3:	4c 89 e7             	mov    %r12,%rdi
   112a6:	e8 7c 7c 00 00       	callq  18f27 <net_buf_get>
   112ab:	48 85 c0             	test   %rax,%rax
   112ae:	48 89 c5             	mov    %rax,%rbp
   112b1:	74 18                	je     112cb <conn_cleanup+0x35>
		if (tx_data(buf)->tx) {
   112b3:	48 8b 7d 28          	mov    0x28(%rbp),%rdi
   112b7:	48 85 ff             	test   %rdi,%rdi
   112ba:	74 05                	je     112c1 <conn_cleanup+0x2b>
			tx_free(tx_data(buf)->tx);
   112bc:	e8 e8 fb ff ff       	callq  10ea9 <tx_free>
		}

		net_buf_unref(buf);
   112c1:	48 89 ef             	mov    %rbp,%rdi
   112c4:	e8 d1 7c 00 00       	callq  18f9a <net_buf_unref>
   112c9:	eb d6                	jmp    112a1 <conn_cleanup+0xb>
	}

	__ASSERT(sys_slist_is_empty(&conn->tx_pending), "Pending TX packets");
	__ASSERT_NO_MSG(conn->pending_no_cb == 0);

	bt_conn_reset_rx_state(conn);
   112cb:	48 89 df             	mov    %rbx,%rdi
   112ce:	e8 a7 ff ff ff       	callq  1127a <bt_conn_reset_rx_state>

	k_delayed_work_submit(&conn->deferred_work, K_NO_WAIT);
   112d3:	48 8d b3 98 00 00 00 	lea    0x98(%rbx),%rsi
 * @retval -EADDRINUSE Work item was submitted to a different workqueue.
 */
static inline int k_delayed_work_submit(struct k_delayed_work *work,
					k_timeout_t delay)
{
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   112da:	48 8d 3d bf 68 24 00 	lea    0x2468bf(%rip),%rdi        # 257ba0 <k_sys_work_q>
   112e1:	31 d2                	xor    %edx,%edx
}
   112e3:	5b                   	pop    %rbx
   112e4:	5d                   	pop    %rbp
   112e5:	41 5c                	pop    %r12
   112e7:	e9 8b b0 01 00       	jmpq   2c377 <k_delayed_work_submit_to_queue>

00000000000112ec <bt_conn_recv>:
{
   112ec:	41 55                	push   %r13
   112ee:	41 54                	push   %r12
   112f0:	41 89 d5             	mov    %edx,%r13d
   112f3:	55                   	push   %rbp
   112f4:	53                   	push   %rbx
   112f5:	48 89 f5             	mov    %rsi,%rbp
   112f8:	48 89 fb             	mov    %rdi,%rbx
   112fb:	48 83 ec 08          	sub    $0x8,%rsp
	tx_notify(conn);
   112ff:	e8 0b fc ff ff       	callq  10f0f <tx_notify>
	switch (flags) {
   11304:	41 80 fd 01          	cmp    $0x1,%r13b
   11308:	74 46                	je     11350 <bt_conn_recv+0x64>
   1130a:	41 80 fd 02          	cmp    $0x2,%r13b
   1130e:	0f 85 d9 00 00 00    	jne    113ed <bt_conn_recv+0x101>
		if (conn->rx) {
   11314:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
   11319:	74 2c                	je     11347 <bt_conn_recv+0x5b>
   1131b:	48 8d 35 6e 90 22 00 	lea    0x22906e(%rip),%rsi        # 23a390 <log_const_bt_conn>
   11322:	48 2b 35 27 4c 22 00 	sub    0x224c27(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Unexpected first L2CAP frame");
   11329:	48 8d 3d cf 16 02 00 	lea    0x216cf(%rip),%rdi        # 329ff <__func__.5785+0x1d97>
   11330:	48 c1 ee 04          	shr    $0x4,%rsi
   11334:	c1 e6 06             	shl    $0x6,%esi
   11337:	83 ce 01             	or     $0x1,%esi
   1133a:	e8 85 5f ff ff       	callq  72c4 <log_0>
			bt_conn_reset_rx_state(conn);
   1133f:	48 89 df             	mov    %rbx,%rdi
   11342:	e8 33 ff ff ff       	callq  1127a <bt_conn_reset_rx_state>
		conn->rx = buf;
   11347:	48 89 6b 10          	mov    %rbp,0x10(%rbx)
		break;
   1134b:	e9 c7 00 00 00       	jmpq   11417 <bt_conn_recv+0x12b>
		if (!conn->rx) {
   11350:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
   11354:	48 85 ff             	test   %rdi,%rdi
   11357:	75 21                	jne    1137a <bt_conn_recv+0x8e>
   11359:	48 8d 35 30 90 22 00 	lea    0x229030(%rip),%rsi        # 23a390 <log_const_bt_conn>
   11360:	48 2b 35 e9 4b 22 00 	sub    0x224be9(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Unexpected L2CAP continuation");
   11367:	48 8d 3d ae 16 02 00 	lea    0x216ae(%rip),%rdi        # 32a1c <__func__.5785+0x1db4>
   1136e:	48 c1 ee 04          	shr    $0x4,%rsi
   11372:	c1 e6 06             	shl    $0x6,%esi
   11375:	83 ce 01             	or     $0x1,%esi
   11378:	eb 38                	jmp    113b2 <bt_conn_recv+0xc6>
		if (!buf->len) {
   1137a:	44 0f b7 65 18       	movzwl 0x18(%rbp),%r12d
   1137f:	66 45 85 e4          	test   %r12w,%r12w
   11383:	74 3a                	je     113bf <bt_conn_recv+0xd3>
 *
 * @return Number of bytes available at the end of the buffer.
 */
static inline size_t net_buf_tailroom(struct net_buf *buf)
{
	return net_buf_simple_tailroom(&buf->b);
   11385:	48 83 c7 10          	add    $0x10,%rdi
   11389:	e8 ac 7d 00 00       	callq  1913a <net_buf_simple_tailroom>
		if (buf->len > net_buf_tailroom(conn->rx)) {
   1138e:	4c 39 e0             	cmp    %r12,%rax
   11391:	73 3b                	jae    113ce <bt_conn_recv+0xe2>
   11393:	48 8d 35 f6 8f 22 00 	lea    0x228ff6(%rip),%rsi        # 23a390 <log_const_bt_conn>
   1139a:	48 2b 35 af 4b 22 00 	sub    0x224baf(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Not enough buffer space for L2CAP data");
   113a1:	48 8d 3d 92 16 02 00 	lea    0x21692(%rip),%rdi        # 32a3a <__func__.5785+0x1dd2>
   113a8:	48 c1 ee 04          	shr    $0x4,%rsi
   113ac:	c1 e6 06             	shl    $0x6,%esi
   113af:	83 ce 01             	or     $0x1,%esi
   113b2:	e8 0d 5f ff ff       	callq  72c4 <log_0>
			bt_conn_reset_rx_state(conn);
   113b7:	48 89 df             	mov    %rbx,%rdi
   113ba:	e8 bb fe ff ff       	callq  1127a <bt_conn_reset_rx_state>
}
   113bf:	5e                   	pop    %rsi
			net_buf_unref(buf);
   113c0:	48 89 ef             	mov    %rbp,%rdi
}
   113c3:	5b                   	pop    %rbx
   113c4:	5d                   	pop    %rbp
   113c5:	41 5c                	pop    %r12
   113c7:	41 5d                	pop    %r13
			net_buf_unref(buf);
   113c9:	e9 cc 7b 00 00       	jmpq   18f9a <net_buf_unref>
	return net_buf_simple_add_mem(&buf->b, mem, len);
   113ce:	48 8b 43 10          	mov    0x10(%rbx),%rax
		net_buf_add_mem(conn->rx, buf->data, buf->len);
   113d2:	0f b7 55 18          	movzwl 0x18(%rbp),%edx
   113d6:	48 8b 75 10          	mov    0x10(%rbp),%rsi
   113da:	48 8d 78 10          	lea    0x10(%rax),%rdi
   113de:	e8 b7 7c 00 00       	callq  1909a <net_buf_simple_add_mem>
		net_buf_unref(buf);
   113e3:	48 89 ef             	mov    %rbp,%rdi
   113e6:	e8 af 7b 00 00       	callq  18f9a <net_buf_unref>
		break;
   113eb:	eb 2a                	jmp    11417 <bt_conn_recv+0x12b>
   113ed:	48 8d 15 9c 8f 22 00 	lea    0x228f9c(%rip),%rdx        # 23a390 <log_const_bt_conn>
   113f4:	48 2b 15 55 4b 22 00 	sub    0x224b55(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unexpected ACL flags (0x%02x)", flags);
   113fb:	48 8d 3d 5f 16 02 00 	lea    0x2165f(%rip),%rdi        # 32a61 <__func__.5785+0x1df9>
   11402:	41 0f b6 f5          	movzbl %r13b,%esi
   11406:	48 c1 ea 04          	shr    $0x4,%rdx
   1140a:	c1 e2 06             	shl    $0x6,%edx
   1140d:	83 ca 01             	or     $0x1,%edx
   11410:	e8 e0 5e ff ff       	callq  72f5 <log_1>
   11415:	eb a0                	jmp    113b7 <bt_conn_recv+0xcb>
	if (conn->rx->len < sizeof(uint16_t)) {
   11417:	48 8b 73 10          	mov    0x10(%rbx),%rsi
   1141b:	8b 46 18             	mov    0x18(%rsi),%eax
   1141e:	66 83 f8 01          	cmp    $0x1,%ax
   11422:	76 6c                	jbe    11490 <bt_conn_recv+0x1a4>
	acl_total_len = sys_get_le16(conn->rx->data) + sizeof(struct bt_l2cap_hdr);
   11424:	48 8b 7e 10          	mov    0x10(%rsi),%rdi
	return ((uint16_t)src[1] << 8) | src[0];
   11428:	0f b6 57 01          	movzbl 0x1(%rdi),%edx
   1142c:	89 d1                	mov    %edx,%ecx
   1142e:	0f b6 17             	movzbl (%rdi),%edx
   11431:	c1 e1 08             	shl    $0x8,%ecx
   11434:	09 ca                	or     %ecx,%edx
   11436:	83 c2 04             	add    $0x4,%edx
	if (conn->rx->len < acl_total_len) {
   11439:	66 39 c2             	cmp    %ax,%dx
   1143c:	77 52                	ja     11490 <bt_conn_recv+0x1a4>
	if (conn->rx->len > acl_total_len) {
   1143e:	73 39                	jae    11479 <bt_conn_recv+0x18d>
   11440:	48 8d 0d 49 8f 22 00 	lea    0x228f49(%rip),%rcx        # 23a390 <log_const_bt_conn>
   11447:	48 2b 0d 02 4b 22 00 	sub    0x224b02(%rip),%rcx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("ACL len mismatch (%u > %u)",
   1144e:	48 8d 3d 2a 16 02 00 	lea    0x2162a(%rip),%rdi        # 32a7f <__func__.5785+0x1e17>
   11455:	0f b7 d2             	movzwl %dx,%edx
   11458:	0f b7 f0             	movzwl %ax,%esi
   1145b:	48 c1 e9 04          	shr    $0x4,%rcx
   1145f:	c1 e1 06             	shl    $0x6,%ecx
   11462:	83 c9 01             	or     $0x1,%ecx
   11465:	e8 c8 5e ff ff       	callq  7332 <log_2>
}
   1146a:	59                   	pop    %rcx
		bt_conn_reset_rx_state(conn);
   1146b:	48 89 df             	mov    %rbx,%rdi
}
   1146e:	5b                   	pop    %rbx
   1146f:	5d                   	pop    %rbp
   11470:	41 5c                	pop    %r12
   11472:	41 5d                	pop    %r13
		bt_conn_reset_rx_state(conn);
   11474:	e9 01 fe ff ff       	jmpq   1127a <bt_conn_reset_rx_state>
	conn->rx = NULL;
   11479:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
   11480:	00 
	bt_l2cap_recv(conn, buf);
   11481:	48 89 df             	mov    %rbx,%rdi
}
   11484:	5a                   	pop    %rdx
   11485:	5b                   	pop    %rbx
   11486:	5d                   	pop    %rbp
   11487:	41 5c                	pop    %r12
   11489:	41 5d                	pop    %r13
	bt_l2cap_recv(conn, buf);
   1148b:	e9 cb 10 00 00       	jmpq   1255b <bt_l2cap_recv>
}
   11490:	58                   	pop    %rax
   11491:	5b                   	pop    %rbx
   11492:	5d                   	pop    %rbp
   11493:	41 5c                	pop    %r12
   11495:	41 5d                	pop    %r13
   11497:	c3                   	retq   

0000000000011498 <bt_conn_send_cb>:
{
   11498:	41 55                	push   %r13
   1149a:	41 54                	push   %r12
   1149c:	55                   	push   %rbp
   1149d:	53                   	push   %rbx
   1149e:	48 89 f3             	mov    %rsi,%rbx
   114a1:	48 83 ec 18          	sub    $0x18,%rsp
	if (conn->state != BT_CONN_CONNECTED) {
   114a5:	80 7f 0a 07          	cmpb   $0x7,0xa(%rdi)
   114a9:	74 31                	je     114dc <bt_conn_send_cb+0x44>
   114ab:	48 8d 35 de 8e 22 00 	lea    0x228ede(%rip),%rsi        # 23a390 <log_const_bt_conn>
   114b2:	48 2b 35 97 4a 22 00 	sub    0x224a97(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("not connected!");
   114b9:	48 8d 3d da 15 02 00 	lea    0x215da(%rip),%rdi        # 32a9a <__func__.5785+0x1e32>
   114c0:	48 c1 ee 04          	shr    $0x4,%rsi
   114c4:	c1 e6 06             	shl    $0x6,%esi
   114c7:	83 ce 01             	or     $0x1,%esi
   114ca:	e8 f5 5d ff ff       	callq  72c4 <log_0>
		net_buf_unref(buf);
   114cf:	48 89 df             	mov    %rbx,%rdi
   114d2:	e8 c3 7a 00 00       	callq  18f9a <net_buf_unref>
   114d7:	e9 b9 00 00 00       	jmpq   11595 <bt_conn_send_cb+0xfd>
	if (cb) {
   114dc:	48 85 d2             	test   %rdx,%rdx
   114df:	48 89 fd             	mov    %rdi,%rbp
   114e2:	49 89 d4             	mov    %rdx,%r12
   114e5:	0f 84 c6 00 00 00    	je     115b1 <bt_conn_send_cb+0x119>
   114eb:	49 89 cd             	mov    %rcx,%r13
	return z_impl_k_current_get();
   114ee:	31 c0                	xor    %eax,%eax
   114f0:	e8 0b aa 01 00       	callq  2bf00 <z_impl_k_current_get>
	if (k_current_get() == &k_sys_work_q.thread) {
   114f5:	48 8d 15 a4 66 24 00 	lea    0x2466a4(%rip),%rdx        # 257ba0 <k_sys_work_q>
   114fc:	48 8d 3d cd 91 22 00 	lea    0x2291cd(%rip),%rdi        # 23a6d0 <_k_sem_list_end>
   11503:	48 83 c2 30          	add    $0x30,%rdx
   11507:	48 39 d0             	cmp    %rdx,%rax
   1150a:	75 04                	jne    11510 <bt_conn_send_cb+0x78>
	return z_impl_k_queue_get(queue, timeout);
   1150c:	31 f6                	xor    %esi,%esi
   1150e:	eb 04                	jmp    11514 <bt_conn_send_cb+0x7c>
   11510:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
   11514:	e8 db 9e 01 00       	callq  2b3f4 <z_impl_k_queue_get>
		if (!tx) {
   11519:	48 85 c0             	test   %rax,%rax
   1151c:	75 33                	jne    11551 <bt_conn_send_cb+0xb9>
   1151e:	48 8d 35 6b 8e 22 00 	lea    0x228e6b(%rip),%rsi        # 23a390 <log_const_bt_conn>
   11525:	48 2b 35 24 4a 22 00 	sub    0x224a24(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Unable to allocate TX context");
   1152c:	48 8d 3d 76 15 02 00 	lea    0x21576(%rip),%rdi        # 32aa9 <__func__.5785+0x1e41>
   11533:	48 c1 ee 04          	shr    $0x4,%rsi
   11537:	c1 e6 06             	shl    $0x6,%esi
   1153a:	83 ce 01             	or     $0x1,%esi
   1153d:	e8 82 5d ff ff       	callq  72c4 <log_0>
			net_buf_unref(buf);
   11542:	48 89 df             	mov    %rbx,%rdi
   11545:	e8 50 7a 00 00       	callq  18f9a <net_buf_unref>
			return -ENOBUFS;
   1154a:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
   1154f:	eb 76                	jmp    115c7 <bt_conn_send_cb+0x12f>
		if (conn->state != BT_CONN_CONNECTED) {
   11551:	80 7d 0a 07          	cmpb   $0x7,0xa(%rbp)
   11555:	74 45                	je     1159c <bt_conn_send_cb+0x104>
   11557:	48 8d 35 32 8e 22 00 	lea    0x228e32(%rip),%rsi        # 23a390 <log_const_bt_conn>
   1155e:	48 2b 35 eb 49 22 00 	sub    0x2249eb(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_WARN("Disconnected while allocating context");
   11565:	48 8d 3d 5b 15 02 00 	lea    0x2155b(%rip),%rdi        # 32ac7 <__func__.5785+0x1e5f>
   1156c:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   11571:	48 c1 ee 04          	shr    $0x4,%rsi
   11575:	c1 e6 06             	shl    $0x6,%esi
   11578:	83 ce 02             	or     $0x2,%esi
   1157b:	e8 44 5d ff ff       	callq  72c4 <log_0>
			net_buf_unref(buf);
   11580:	48 89 df             	mov    %rbx,%rdi
   11583:	e8 12 7a 00 00       	callq  18f9a <net_buf_unref>
			tx_free(tx);
   11588:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   1158d:	48 89 c7             	mov    %rax,%rdi
   11590:	e8 14 f9 ff ff       	callq  10ea9 <tx_free>
			return -ENOTCONN;
   11595:	b8 95 ff ff ff       	mov    $0xffffff95,%eax
   1159a:	eb 2b                	jmp    115c7 <bt_conn_send_cb+0x12f>
		tx->cb = cb;
   1159c:	4c 89 60 08          	mov    %r12,0x8(%rax)
		tx->user_data = user_data;
   115a0:	4c 89 68 10          	mov    %r13,0x10(%rax)
		tx->pending_no_cb = 0U;
   115a4:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
		tx_data(buf)->tx = tx;
   115ab:	48 89 43 28          	mov    %rax,0x28(%rbx)
   115af:	eb 08                	jmp    115b9 <bt_conn_send_cb+0x121>
		tx_data(buf)->tx = NULL;
   115b1:	48 c7 46 28 00 00 00 	movq   $0x0,0x28(%rsi)
   115b8:	00 
	net_buf_put(&conn->tx_queue, buf);
   115b9:	48 8d 7d 58          	lea    0x58(%rbp),%rdi
   115bd:	48 89 de             	mov    %rbx,%rsi
   115c0:	e8 bc 79 00 00       	callq  18f81 <net_buf_put>
	return 0;
   115c5:	31 c0                	xor    %eax,%eax
}
   115c7:	48 83 c4 18          	add    $0x18,%rsp
   115cb:	5b                   	pop    %rbx
   115cc:	5d                   	pop    %rbp
   115cd:	41 5c                	pop    %r12
   115cf:	41 5d                	pop    %r13
   115d1:	c3                   	retq   

00000000000115d2 <bt_conn_prepare_events>:

	return 0;
}

int bt_conn_prepare_events(struct k_poll_event events[])
{
   115d2:	53                   	push   %rbx
	struct bt_conn *conn;

	BT_DBG("");

	conn_change.signaled = 0U;
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
   115d3:	48 8d 0d d6 53 22 00 	lea    0x2253d6(%rip),%rcx        # 2369b0 <conn_change>
   115da:	31 d2                	xor    %edx,%edx
   115dc:	be 01 00 00 00       	mov    $0x1,%esi
{
   115e1:	48 89 fb             	mov    %rdi,%rbx
	conn_change.signaled = 0U;
   115e4:	c7 05 d2 53 22 00 00 	movl   $0x0,0x2253d2(%rip)        # 2369c0 <conn_change+0x10>
   115eb:	00 00 00 
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
   115ee:	e8 86 b6 01 00       	callq  2cc79 <k_poll_event_init>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   115f3:	8b 05 d7 5c 24 00    	mov    0x245cd7(%rip),%eax        # 2572d0 <acl_conns+0x110>
	if (!atomic_get(&conn->ref)) {
   115f9:	85 c0                	test   %eax,%eax
   115fb:	74 35                	je     11632 <bt_conn_prepare_events+0x60>
	if (conn->state == BT_CONN_DISCONNECTED &&
   115fd:	80 3d c6 5b 24 00 00 	cmpb   $0x0,0x245bc6(%rip)        # 2571ca <acl_conns+0xa>
   11604:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
   11608:	75 2f                	jne    11639 <bt_conn_prepare_events+0x67>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1160a:	8b 05 b4 5b 24 00    	mov    0x245bb4(%rip),%eax        # 2571c4 <acl_conns+0x4>
   11610:	89 c1                	mov    %eax,%ecx
   11612:	89 c2                	mov    %eax,%edx
   11614:	83 e1 bf             	and    $0xffffffbf,%ecx
   11617:	f0 0f b1 0d a5 5b 24 	lock cmpxchg %ecx,0x245ba5(%rip)        # 2571c4 <acl_conns+0x4>
   1161e:	00 
   1161f:	75 ef                	jne    11610 <bt_conn_prepare_events+0x3e>
   11621:	80 e2 40             	and    $0x40,%dl
   11624:	74 13                	je     11639 <bt_conn_prepare_events+0x67>
		conn_cleanup(conn);
   11626:	48 8d 3d 93 5b 24 00 	lea    0x245b93(%rip),%rdi        # 2571c0 <acl_conns>
   1162d:	e8 64 fc ff ff       	callq  11296 <conn_cleanup>
   11632:	b8 01 00 00 00       	mov    $0x1,%eax
   11637:	eb 25                	jmp    1165e <bt_conn_prepare_events+0x8c>
	if (conn->state != BT_CONN_CONNECTED) {
   11639:	80 3d 8a 5b 24 00 07 	cmpb   $0x7,0x245b8a(%rip)        # 2571ca <acl_conns+0xa>
   11640:	75 f0                	jne    11632 <bt_conn_prepare_events+0x60>
	k_poll_event_init(&events[0],
   11642:	48 8d 0d cf 5b 24 00 	lea    0x245bcf(%rip),%rcx        # 257218 <acl_conns+0x58>
   11649:	31 d2                	xor    %edx,%edx
   1164b:	be 04 00 00 00       	mov    $0x4,%esi
   11650:	e8 24 b6 01 00       	callq  2cc79 <k_poll_event_init>
	events[0].tag = BT_EVENT_CONN_TX_QUEUE;
   11655:	c6 43 40 01          	movb   $0x1,0x40(%rbx)

	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
		conn = &acl_conns[i];

		if (!conn_prepare_events(conn, &events[ev_count])) {
			ev_count++;
   11659:	b8 02 00 00 00       	mov    $0x2,%eax
		}
	}
#endif

	return ev_count;
}
   1165e:	5b                   	pop    %rbx
   1165f:	c3                   	retq   

0000000000011660 <bt_conn_add_le>:

	return false;
}

struct bt_conn *bt_conn_add_le(uint8_t id, const bt_addr_le_t *peer)
{
   11660:	55                   	push   %rbp
   11661:	53                   	push   %rbx
   11662:	89 fd                	mov    %edi,%ebp
	conn = bt_conn_new(acl_conns, ARRAY_SIZE(acl_conns));
   11664:	48 8d 3d 55 5b 24 00 	lea    0x245b55(%rip),%rdi        # 2571c0 <acl_conns>
{
   1166b:	48 89 f3             	mov    %rsi,%rbx
	conn = bt_conn_new(acl_conns, ARRAY_SIZE(acl_conns));
   1166e:	be 01 00 00 00       	mov    $0x1,%esi
{
   11673:	48 83 ec 08          	sub    $0x8,%rsp
	conn = bt_conn_new(acl_conns, ARRAY_SIZE(acl_conns));
   11677:	e8 9f fb ff ff       	callq  1121b <bt_conn_new>
	if (!conn) {
   1167c:	48 85 c0             	test   %rax,%rax
	conn = bt_conn_new(acl_conns, ARRAY_SIZE(acl_conns));
   1167f:	48 89 c2             	mov    %rax,%rdx
	if (!conn) {
   11682:	74 5e                	je     116e2 <bt_conn_add_le+0x82>
	*work = (struct k_delayed_work)Z_DELAYED_WORK_INITIALIZER(handler);
   11684:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   1168b:	b9 10 00 00 00       	mov    $0x10,%ecx
   11690:	31 c0                	xor    %eax,%eax
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
   11692:	48 89 de             	mov    %rbx,%rsi
   11695:	f3 ab                	rep stos %eax,%es:(%rdi)
   11697:	48 8d 05 da 05 00 00 	lea    0x5da(%rip),%rax        # 11c78 <deferred_work>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   1169e:	48 c7 42 40 00 00 00 	movq   $0x0,0x40(%rdx)
   116a5:	00 
   116a6:	c7 42 50 00 00 00 00 	movl   $0x0,0x50(%rdx)

	if (!conn) {
		return NULL;
	}

	conn->id = id;
   116ad:	40 88 6a 08          	mov    %bpl,0x8(%rdx)
   116b1:	b9 07 00 00 00       	mov    $0x7,%ecx
	*work = (struct k_delayed_work)Z_DELAYED_WORK_INITIALIZER(handler);
   116b6:	48 89 82 a0 00 00 00 	mov    %rax,0xa0(%rdx)
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   116bd:	48 8d 05 a5 f8 ff ff 	lea    -0x75b(%rip),%rax        # 10f69 <tx_complete_work>
   116c4:	48 89 42 48          	mov    %rax,0x48(%rdx)
   116c8:	48 8d 82 d8 00 00 00 	lea    0xd8(%rdx),%rax
   116cf:	48 89 c7             	mov    %rax,%rdi
   116d2:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
	bt_addr_le_copy(&conn->le.dst, peer);
#if defined(CONFIG_BT_SMP)
	conn->sec_level = BT_SECURITY_L1;
	conn->required_sec_level = BT_SECURITY_L1;
#endif /* CONFIG_BT_SMP */
	conn->type = BT_CONN_TYPE_LE;
   116d4:	c6 42 02 01          	movb   $0x1,0x2(%rdx)
	conn->le.interval_min = BT_GAP_INIT_CONN_INT_MIN;
   116d8:	c7 82 f0 00 00 00 18 	movl   $0x280018,0xf0(%rdx)
   116df:	00 28 00 
	conn->le.interval_max = BT_GAP_INIT_CONN_INT_MAX;

	return conn;
}
   116e2:	48 89 d0             	mov    %rdx,%rax
   116e5:	5a                   	pop    %rdx
   116e6:	5b                   	pop    %rbx
   116e7:	5d                   	pop    %rbp
   116e8:	c3                   	retq   

00000000000116e9 <bt_conn_is_peer_addr_le>:

bool bt_conn_is_peer_addr_le(const struct bt_conn *conn, uint8_t id,
			     const bt_addr_le_t *peer)
{
	if (id != conn->id) {
		return false;
   116e9:	31 c9                	xor    %ecx,%ecx
	if (id != conn->id) {
   116eb:	40 38 77 08          	cmp    %sil,0x8(%rdi)
   116ef:	75 52                	jne    11743 <bt_conn_is_peer_addr_le+0x5a>
{
   116f1:	55                   	push   %rbp
   116f2:	53                   	push   %rbx
   116f3:	48 89 d5             	mov    %rdx,%rbp
	return memcmp(a, b, sizeof(*a));
   116f6:	48 8d b7 d8 00 00 00 	lea    0xd8(%rdi),%rsi
   116fd:	48 89 fb             	mov    %rdi,%rbx
   11700:	ba 07 00 00 00       	mov    $0x7,%edx
   11705:	48 83 ec 08          	sub    $0x8,%rsp
   11709:	48 89 ef             	mov    %rbp,%rdi
   1170c:	e8 2f 2d ff ff       	callq  4440 <memcmp@plt>
	}

	/* Check against conn dst address as it may be the identity address */
	if (!bt_addr_le_cmp(peer, &conn->le.dst)) {
   11711:	85 c0                	test   %eax,%eax
		return true;
   11713:	b1 01                	mov    $0x1,%cl
	if (!bt_addr_le_cmp(peer, &conn->le.dst)) {
   11715:	74 26                	je     1173d <bt_conn_is_peer_addr_le+0x54>
	}

	/* Check against initial connection address */
	if (conn->role == BT_HCI_ROLE_MASTER) {
   11717:	80 7b 03 00          	cmpb   $0x0,0x3(%rbx)
   1171b:	48 8d b3 e6 00 00 00 	lea    0xe6(%rbx),%rsi
   11722:	74 07                	je     1172b <bt_conn_is_peer_addr_le+0x42>
   11724:	48 8d b3 df 00 00 00 	lea    0xdf(%rbx),%rsi
   1172b:	ba 07 00 00 00       	mov    $0x7,%edx
   11730:	48 89 ef             	mov    %rbp,%rdi
   11733:	e8 08 2d ff ff       	callq  4440 <memcmp@plt>
		return bt_addr_le_cmp(peer, &conn->le.resp_addr) == 0;
	}

	return bt_addr_le_cmp(peer, &conn->le.init_addr) == 0;
   11738:	85 c0                	test   %eax,%eax
   1173a:	0f 94 c1             	sete   %cl
}
   1173d:	5a                   	pop    %rdx
   1173e:	88 c8                	mov    %cl,%al
   11740:	5b                   	pop    %rbx
   11741:	5d                   	pop    %rbp
   11742:	c3                   	retq   
   11743:	88 c8                	mov    %cl,%al
   11745:	c3                   	retq   

0000000000011746 <bt_conn_ref>:
	 * zero, then we should return NULL instead.
	 * Loop on clear-and-set in case someone has modified the reference
	 * count since the read, and start over again when that happens.
	 */
	do {
		old = atomic_get(&conn->ref);
   11746:	48 8d 97 10 01 00 00 	lea    0x110(%rdi),%rdx
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1174d:	8b 02                	mov    (%rdx),%eax

		if (!old) {
   1174f:	85 c0                	test   %eax,%eax
   11751:	74 0b                	je     1175e <bt_conn_ref+0x18>
			return NULL;
		}
	} while (!atomic_cas(&conn->ref, old, old + 1));
   11753:	8d 48 01             	lea    0x1(%rax),%ecx
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   11756:	f0 0f b1 0a          	lock cmpxchg %ecx,(%rdx)
   1175a:	74 04                	je     11760 <bt_conn_ref+0x1a>
   1175c:	eb ef                	jmp    1174d <bt_conn_ref+0x7>
			return NULL;
   1175e:	31 ff                	xor    %edi,%edi

	BT_DBG("handle %u ref %u -> %u", conn->handle, old, old + 1);

	return conn;
}
   11760:	48 89 f8             	mov    %rdi,%rax
   11763:	c3                   	retq   

0000000000011764 <bt_conn_unref>:

void bt_conn_unref(struct bt_conn *conn)
{
	atomic_val_t old = atomic_dec(&conn->ref);
   11764:	48 8d 87 10 01 00 00 	lea    0x110(%rdi),%rax
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   1176b:	f0 ff 08             	lock decl (%rax)
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1176e:	8b 87 10 01 00 00    	mov    0x110(%rdi),%eax
	BT_DBG("handle %u ref %u -> %u", conn->handle, old,
	       atomic_get(&conn->ref));

	__ASSERT(old > 0, "Conn reference counter is 0");

	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   11774:	85 c0                	test   %eax,%eax
   11776:	75 05                	jne    1177d <bt_conn_unref+0x19>
	    atomic_get(&conn->ref) == 0) {
		bt_le_adv_resume();
   11778:	e9 b9 f0 ff ff       	jmpq   10836 <bt_le_adv_resume>
	}
}
   1177d:	c3                   	retq   

000000000001177e <conn_lookup_handle>:
{
   1177e:	41 56                	push   %r14
   11780:	41 be 01 00 00 00    	mov    $0x1,%r14d
   11786:	41 55                	push   %r13
   11788:	49 89 fd             	mov    %rdi,%r13
   1178b:	41 54                	push   %r12
   1178d:	49 89 f4             	mov    %rsi,%r12
   11790:	55                   	push   %rbp
   11791:	89 d5                	mov    %edx,%ebp
   11793:	53                   	push   %rbx
	for (i = 0; i < size; i++) {
   11794:	31 db                	xor    %ebx,%ebx
   11796:	48 63 fb             	movslq %ebx,%rdi
   11799:	4c 39 e7             	cmp    %r12,%rdi
   1179c:	73 3b                	jae    117d9 <conn_lookup_handle+0x5b>
		struct bt_conn *conn = bt_conn_ref(&conns[i]);
   1179e:	48 69 ff 18 01 00 00 	imul   $0x118,%rdi,%rdi
   117a5:	4c 01 ef             	add    %r13,%rdi
   117a8:	e8 99 ff ff ff       	callq  11746 <bt_conn_ref>
		if (!conn) {
   117ad:	48 85 c0             	test   %rax,%rax
   117b0:	74 23                	je     117d5 <conn_lookup_handle+0x57>
		if (!bt_conn_is_handle_valid(conn)) {
   117b2:	8a 48 0a             	mov    0xa(%rax),%cl
   117b5:	80 f9 08             	cmp    $0x8,%cl
   117b8:	77 13                	ja     117cd <conn_lookup_handle+0x4f>
   117ba:	4c 89 f2             	mov    %r14,%rdx
   117bd:	48 d3 e2             	shl    %cl,%rdx
   117c0:	f7 c2 82 01 00 00    	test   $0x182,%edx
   117c6:	74 05                	je     117cd <conn_lookup_handle+0x4f>
		if (conn->handle != handle) {
   117c8:	66 39 28             	cmp    %bp,(%rax)
   117cb:	74 0e                	je     117db <conn_lookup_handle+0x5d>
			bt_conn_unref(conn);
   117cd:	48 89 c7             	mov    %rax,%rdi
   117d0:	e8 8f ff ff ff       	callq  11764 <bt_conn_unref>
	for (i = 0; i < size; i++) {
   117d5:	ff c3                	inc    %ebx
   117d7:	eb bd                	jmp    11796 <conn_lookup_handle+0x18>
	return NULL;
   117d9:	31 c0                	xor    %eax,%eax
}
   117db:	5b                   	pop    %rbx
   117dc:	5d                   	pop    %rbp
   117dd:	41 5c                	pop    %r12
   117df:	41 5d                	pop    %r13
   117e1:	41 5e                	pop    %r14
   117e3:	c3                   	retq   

00000000000117e4 <bt_conn_lookup_handle>:
	conn = conn_lookup_handle(acl_conns, ARRAY_SIZE(acl_conns), handle);
   117e4:	0f b7 d7             	movzwl %di,%edx
   117e7:	48 8d 3d d2 59 24 00 	lea    0x2459d2(%rip),%rdi        # 2571c0 <acl_conns>
   117ee:	be 01 00 00 00       	mov    $0x1,%esi
   117f3:	e9 86 ff ff ff       	jmpq   1177e <conn_lookup_handle>

00000000000117f8 <bt_conn_set_state>:
{
   117f8:	41 54                	push   %r12
   117fa:	55                   	push   %rbp
   117fb:	53                   	push   %rbx
	if (conn->state == state) {
   117fc:	0f b6 6f 0a          	movzbl 0xa(%rdi),%ebp
   11800:	40 38 f5             	cmp    %sil,%bpl
   11803:	75 35                	jne    1183a <bt_conn_set_state+0x42>
   11805:	4c 8d 05 84 8b 22 00 	lea    0x228b84(%rip),%r8        # 23a390 <log_const_bt_conn>
   1180c:	4c 2b 05 3d 47 22 00 	sub    0x22473d(%rip),%r8        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("no transition %s", state2str(state));
   11813:	40 0f b6 fd          	movzbl %bpl,%edi
   11817:	49 c1 e8 04          	shr    $0x4,%r8
   1181b:	41 c1 e0 06          	shl    $0x6,%r8d
   1181f:	41 83 c8 02          	or     $0x2,%r8d
   11823:	e8 18 f6 ff ff       	callq  10e40 <state2str>
   11828:	48 8d 3d be 12 02 00 	lea    0x212be(%rip),%rdi        # 32aed <__func__.5785+0x1e85>
   1182f:	44 89 c2             	mov    %r8d,%edx
   11832:	48 89 c6             	mov    %rax,%rsi
   11835:	e9 cb 01 00 00       	jmpq   11a05 <bt_conn_set_state+0x20d>
	switch (old_state) {
   1183a:	40 84 ed             	test   %bpl,%bpl
   1183d:	48 89 fb             	mov    %rdi,%rbx
   11840:	41 88 f4             	mov    %sil,%r12b
	conn->state = state;
   11843:	40 88 77 0a          	mov    %sil,0xa(%rdi)
	switch (old_state) {
   11847:	75 05                	jne    1184e <bt_conn_set_state+0x56>
		bt_conn_ref(conn);
   11849:	e8 f8 fe ff ff       	callq  11746 <bt_conn_ref>
	switch (conn->state) {
   1184e:	80 7b 0a 08          	cmpb   $0x8,0xa(%rbx)
   11852:	0f 87 8a 01 00 00    	ja     119e2 <bt_conn_set_state+0x1ea>
   11858:	0f b6 43 0a          	movzbl 0xa(%rbx),%eax
   1185c:	48 8d 15 f1 f4 01 00 	lea    0x1f4f1(%rip),%rdx        # 30d54 <__func__.5785+0xec>
   11863:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
   11867:	48 01 d0             	add    %rdx,%rax
   1186a:	ff e0                	jmpq   *%rax
		if (conn->type == BT_CONN_TYPE_SCO) {
   1186c:	80 7b 02 04          	cmpb   $0x4,0x2(%rbx)
   11870:	0f 84 98 01 00 00    	je     11a0e <bt_conn_set_state+0x216>
		k_fifo_init(&conn->tx_queue);
   11876:	48 8d 7b 58          	lea    0x58(%rbx),%rdi
	z_impl_k_queue_init(queue);
   1187a:	e8 84 9a 01 00       	callq  2b303 <z_impl_k_queue_init>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&signal, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(signal, result);
   1187f:	48 8d 3d 2a 51 22 00 	lea    0x22512a(%rip),%rdi        # 2369b0 <conn_change>
   11886:	31 f6                	xor    %esi,%esi
   11888:	e8 3d b5 01 00       	callq  2cdca <z_impl_k_poll_signal_raise>
		bt_l2cap_connected(conn);
   1188d:	48 89 df             	mov    %rbx,%rdi
	list->head = NULL;
   11890:	48 c7 83 88 00 00 00 	movq   $0x0,0x88(%rbx)
   11897:	00 00 00 00 
	list->tail = NULL;
   1189b:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
   118a2:	00 00 00 00 
   118a6:	e8 11 09 00 00       	callq  121bc <bt_l2cap_connected>
		notify_connected(conn);
   118ab:	48 89 df             	mov    %rbx,%rdi
   118ae:	e8 1c f6 ff ff       	callq  10ecf <notify_connected>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   118b3:	80 7b 03 01          	cmpb   $0x1,0x3(%rbx)
   118b7:	0f 85 51 01 00 00    	jne    11a0e <bt_conn_set_state+0x216>
			k_delayed_work_submit(&conn->deferred_work,
   118bd:	48 8d b3 98 00 00 00 	lea    0x98(%rbx),%rsi
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   118c4:	48 8d 3d d5 62 24 00 	lea    0x2462d5(%rip),%rdi        # 257ba0 <k_sys_work_q>
   118cb:	ba f4 01 00 00       	mov    $0x1f4,%edx
}
   118d0:	5b                   	pop    %rbx
   118d1:	5d                   	pop    %rbp
   118d2:	41 5c                	pop    %r12
   118d4:	e9 9e aa 01 00       	jmpq   2c377 <k_delayed_work_submit_to_queue>
		if (conn->type == BT_CONN_TYPE_SCO) {
   118d9:	80 7b 02 04          	cmpb   $0x4,0x2(%rbx)
   118dd:	74 59                	je     11938 <bt_conn_set_state+0x140>
		switch (old_state) {
   118df:	40 80 fd 08          	cmp    $0x8,%bpl
   118e3:	0f 87 25 01 00 00    	ja     11a0e <bt_conn_set_state+0x216>
   118e9:	48 8d 15 88 f4 01 00 	lea    0x1f488(%rip),%rdx        # 30d78 <__func__.5785+0x110>
   118f0:	48 63 04 aa          	movslq (%rdx,%rbp,4),%rax
   118f4:	48 01 d0             	add    %rdx,%rax
   118f7:	ff e0                	jmpq   *%rax
			tx_notify(conn);
   118f9:	48 89 df             	mov    %rbx,%rdi
   118fc:	e8 0e f6 ff ff       	callq  10f0f <tx_notify>
			if (conn->type == BT_CONN_TYPE_LE) {
   11901:	80 7b 02 01          	cmpb   $0x1,0x2(%rbx)
   11905:	75 0c                	jne    11913 <bt_conn_set_state+0x11b>
				k_delayed_work_cancel(&conn->deferred_work);
   11907:	48 8d bb 98 00 00 00 	lea    0x98(%rbx),%rdi
   1190e:	e8 f4 aa 01 00       	callq  2c407 <k_delayed_work_cancel>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   11913:	f0 83 4b 04 40       	lock orl $0x40,0x4(%rbx)
}
   11918:	5b                   	pop    %rbx
   11919:	5d                   	pop    %rbp
   1191a:	41 5c                	pop    %r12
   1191c:	48 8d 3d 8d 50 22 00 	lea    0x22508d(%rip),%rdi        # 2369b0 <conn_change>
   11923:	31 f6                	xor    %esi,%esi
   11925:	e9 a0 b4 01 00       	jmpq   2cdca <z_impl_k_poll_signal_raise>
			if (conn->err) {
   1192a:	80 7b 09 00          	cmpb   $0x0,0x9(%rbx)
   1192e:	74 08                	je     11938 <bt_conn_set_state+0x140>
				notify_connected(conn);
   11930:	48 89 df             	mov    %rbx,%rdi
   11933:	e8 97 f5 ff ff       	callq  10ecf <notify_connected>
			bt_conn_unref(conn);
   11938:	48 89 df             	mov    %rbx,%rdi
}
   1193b:	5b                   	pop    %rbx
   1193c:	5d                   	pop    %rbp
   1193d:	41 5c                	pop    %r12
			bt_conn_unref(conn);
   1193f:	e9 20 fe ff ff       	jmpq   11764 <bt_conn_unref>
   11944:	48 8d 15 45 8a 22 00 	lea    0x228a45(%rip),%rdx        # 23a390 <log_const_bt_conn>
   1194b:	48 2b 15 fe 45 22 00 	sub    0x2245fe(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_WARN("Invalid (%u) old state", state);
   11952:	41 0f b6 f4          	movzbl %r12b,%esi
   11956:	48 8d 3d a1 11 02 00 	lea    0x211a1(%rip),%rdi        # 32afe <__func__.5785+0x1e96>
   1195d:	48 c1 ea 04          	shr    $0x4,%rdx
   11961:	c1 e2 06             	shl    $0x6,%edx
   11964:	83 ca 02             	or     $0x2,%edx
   11967:	e9 99 00 00 00       	jmpq   11a05 <bt_conn_set_state+0x20d>
Z_GENLIST_IS_EMPTY(slist)
   1196c:	48 8b 6b 18          	mov    0x18(%rbx),%rbp
Z_GENLIST_GET(slist, snode)
   11970:	48 85 ed             	test   %rbp,%rbp
   11973:	75 59                	jne    119ce <bt_conn_set_state+0x1d6>
   11975:	e8 22 a6 ff ff       	callq  bf9c <posix_irq_unlock>
		if (!node) {
   1197a:	48 85 ed             	test   %rbp,%rbp
   1197d:	0f 84 8b 00 00 00    	je     11a0e <bt_conn_set_state+0x216>
	return posix_irq_lock();
   11983:	e8 0a a6 ff ff       	callq  bf92 <posix_irq_lock>
		conn->pending_no_cb = tx->pending_no_cb;
   11988:	8b 55 18             	mov    0x18(%rbp),%edx
	posix_irq_unlock(key);
   1198b:	89 c7                	mov    %eax,%edi
   1198d:	89 53 28             	mov    %edx,0x28(%rbx)
		tx->pending_no_cb = 0U;
   11990:	c7 45 18 00 00 00 00 	movl   $0x0,0x18(%rbp)
   11997:	e8 00 a6 ff ff       	callq  bf9c <posix_irq_unlock>
		tx_free(tx);
   1199c:	48 89 ef             	mov    %rbp,%rdi
   1199f:	e8 05 f5 ff ff       	callq  10ea9 <tx_free>
		k_sem_give(bt_conn_get_pkts(conn));
   119a4:	48 89 df             	mov    %rbx,%rdi
   119a7:	e8 d1 f5 ff ff       	callq  10f7d <bt_conn_get_pkts>
	z_impl_k_sem_give(sem);
   119ac:	48 89 c7             	mov    %rax,%rdi
   119af:	e8 82 a5 01 00       	callq  2bf36 <z_impl_k_sem_give>
	return posix_irq_lock();
   119b4:	e8 d9 a5 ff ff       	callq  bf92 <posix_irq_lock>
		if (conn->pending_no_cb) {
   119b9:	8b 53 28             	mov    0x28(%rbx),%edx
   119bc:	89 c7                	mov    %eax,%edi
   119be:	85 d2                	test   %edx,%edx
   119c0:	74 aa                	je     1196c <bt_conn_set_state+0x174>
			conn->pending_no_cb--;
   119c2:	ff ca                	dec    %edx
   119c4:	89 53 28             	mov    %edx,0x28(%rbx)
	posix_irq_unlock(key);
   119c7:	e8 d0 a5 ff ff       	callq  bf9c <posix_irq_unlock>
   119cc:	eb d6                	jmp    119a4 <bt_conn_set_state+0x1ac>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   119ce:	48 3b 6b 20          	cmp    0x20(%rbx),%rbp
	return node->next;
   119d2:	48 8b 45 00          	mov    0x0(%rbp),%rax
	list->head = node;
   119d6:	48 89 43 18          	mov    %rax,0x18(%rbx)
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   119da:	75 99                	jne    11975 <bt_conn_set_state+0x17d>
	list->tail = node;
   119dc:	48 89 43 20          	mov    %rax,0x20(%rbx)
   119e0:	eb 93                	jmp    11975 <bt_conn_set_state+0x17d>
   119e2:	48 8d 15 a7 89 22 00 	lea    0x2289a7(%rip),%rdx        # 23a390 <log_const_bt_conn>
   119e9:	48 2b 15 60 45 22 00 	sub    0x224560(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("no valid (%u) state was set", state);
   119f0:	48 8d 3d 1e 11 02 00 	lea    0x2111e(%rip),%rdi        # 32b15 <__func__.5785+0x1ead>
   119f7:	41 0f b6 f4          	movzbl %r12b,%esi
   119fb:	48 c1 ea 04          	shr    $0x4,%rdx
   119ff:	c1 e2 06             	shl    $0x6,%edx
   11a02:	83 ca 02             	or     $0x2,%edx
}
   11a05:	5b                   	pop    %rbx
   11a06:	5d                   	pop    %rbp
   11a07:	41 5c                	pop    %r12
		BT_WARN("no valid (%u) state was set", state);
   11a09:	e9 e7 58 ff ff       	jmpq   72f5 <log_1>
}
   11a0e:	5b                   	pop    %rbx
   11a0f:	5d                   	pop    %rbp
   11a10:	41 5c                	pop    %r12
   11a12:	c3                   	retq   

0000000000011a13 <bt_conn_lookup_addr_le>:
{
   11a13:	41 54                	push   %r12
   11a15:	55                   	push   %rbp
   11a16:	89 fd                	mov    %edi,%ebp
   11a18:	53                   	push   %rbx
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
   11a19:	48 8d 3d a0 57 24 00 	lea    0x2457a0(%rip),%rdi        # 2571c0 <acl_conns>
{
   11a20:	49 89 f4             	mov    %rsi,%r12
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
   11a23:	e8 1e fd ff ff       	callq  11746 <bt_conn_ref>
		if (!conn) {
   11a28:	48 85 c0             	test   %rax,%rax
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
   11a2b:	48 89 c3             	mov    %rax,%rbx
		if (!conn) {
   11a2e:	74 23                	je     11a53 <bt_conn_lookup_addr_le+0x40>
		if (conn->type != BT_CONN_TYPE_LE) {
   11a30:	80 78 02 01          	cmpb   $0x1,0x2(%rax)
   11a34:	75 13                	jne    11a49 <bt_conn_lookup_addr_le+0x36>
		if (!bt_conn_is_peer_addr_le(conn, id, peer)) {
   11a36:	40 0f b6 f5          	movzbl %bpl,%esi
   11a3a:	4c 89 e2             	mov    %r12,%rdx
   11a3d:	48 89 c7             	mov    %rax,%rdi
   11a40:	e8 a4 fc ff ff       	callq  116e9 <bt_conn_is_peer_addr_le>
   11a45:	84 c0                	test   %al,%al
   11a47:	75 0a                	jne    11a53 <bt_conn_lookup_addr_le+0x40>
			bt_conn_unref(conn);
   11a49:	48 89 df             	mov    %rbx,%rdi
	return NULL;
   11a4c:	31 db                	xor    %ebx,%ebx
			bt_conn_unref(conn);
   11a4e:	e8 11 fd ff ff       	callq  11764 <bt_conn_unref>
}
   11a53:	48 89 d8             	mov    %rbx,%rax
   11a56:	5b                   	pop    %rbx
   11a57:	5d                   	pop    %rbp
   11a58:	41 5c                	pop    %r12
   11a5a:	c3                   	retq   

0000000000011a5b <bt_conn_exists_le>:
{
   11a5b:	53                   	push   %rbx
	struct bt_conn *conn = bt_conn_lookup_addr_le(id, peer);
   11a5c:	40 0f b6 ff          	movzbl %dil,%edi
   11a60:	e8 ae ff ff ff       	callq  11a13 <bt_conn_lookup_addr_le>
   11a65:	48 89 c3             	mov    %rax,%rbx
   11a68:	31 c0                	xor    %eax,%eax
	if (conn) {
   11a6a:	48 85 db             	test   %rbx,%rbx
   11a6d:	74 3f                	je     11aae <bt_conn_exists_le+0x53>
   11a6f:	4c 8d 05 1a 89 22 00 	lea    0x22891a(%rip),%r8        # 23a390 <log_const_bt_conn>
   11a76:	4c 2b 05 d3 44 22 00 	sub    0x2244d3(%rip),%r8        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("Found valid connection in %s state",
   11a7d:	0f b6 7b 0a          	movzbl 0xa(%rbx),%edi
   11a81:	49 c1 e8 04          	shr    $0x4,%r8
   11a85:	41 c1 e0 06          	shl    $0x6,%r8d
   11a89:	41 83 c8 02          	or     $0x2,%r8d
   11a8d:	e8 ae f3 ff ff       	callq  10e40 <state2str>
   11a92:	48 8d 3d 98 10 02 00 	lea    0x21098(%rip),%rdi        # 32b31 <__func__.5785+0x1ec9>
   11a99:	48 89 c6             	mov    %rax,%rsi
   11a9c:	44 89 c2             	mov    %r8d,%edx
   11a9f:	e8 51 58 ff ff       	callq  72f5 <log_1>
		bt_conn_unref(conn);
   11aa4:	48 89 df             	mov    %rbx,%rdi
   11aa7:	e8 b8 fc ff ff       	callq  11764 <bt_conn_unref>
		return true;
   11aac:	b0 01                	mov    $0x1,%al
}
   11aae:	5b                   	pop    %rbx
   11aaf:	c3                   	retq   

0000000000011ab0 <bt_conn_lookup_state_le>:
{
   11ab0:	41 55                	push   %r13
   11ab2:	41 54                	push   %r12
   11ab4:	41 89 d5             	mov    %edx,%r13d
   11ab7:	55                   	push   %rbp
   11ab8:	53                   	push   %rbx
   11ab9:	89 fd                	mov    %edi,%ebp
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
   11abb:	48 8d 3d fe 56 24 00 	lea    0x2456fe(%rip),%rdi        # 2571c0 <acl_conns>
{
   11ac2:	49 89 f4             	mov    %rsi,%r12
   11ac5:	48 83 ec 08          	sub    $0x8,%rsp
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
   11ac9:	e8 78 fc ff ff       	callq  11746 <bt_conn_ref>
		if (!conn) {
   11ace:	48 85 c0             	test   %rax,%rax
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
   11ad1:	48 89 c3             	mov    %rax,%rbx
		if (!conn) {
   11ad4:	74 3e                	je     11b14 <bt_conn_lookup_state_le+0x64>
		if (conn->type != BT_CONN_TYPE_LE) {
   11ad6:	80 78 02 01          	cmpb   $0x1,0x2(%rax)
   11ada:	74 0a                	je     11ae6 <bt_conn_lookup_state_le+0x36>
			bt_conn_ref(conn);
   11adc:	48 89 c7             	mov    %rax,%rdi
   11adf:	e8 62 fc ff ff       	callq  11746 <bt_conn_ref>
   11ae4:	eb 2c                	jmp    11b12 <bt_conn_lookup_state_le+0x62>
		if (peer && !bt_conn_is_peer_addr_le(conn, id, peer)) {
   11ae6:	4d 85 e4             	test   %r12,%r12
   11ae9:	74 13                	je     11afe <bt_conn_lookup_state_le+0x4e>
   11aeb:	40 0f b6 f5          	movzbl %bpl,%esi
   11aef:	4c 89 e2             	mov    %r12,%rdx
   11af2:	48 89 c7             	mov    %rax,%rdi
   11af5:	e8 ef fb ff ff       	callq  116e9 <bt_conn_is_peer_addr_le>
   11afa:	84 c0                	test   %al,%al
   11afc:	74 0c                	je     11b0a <bt_conn_lookup_state_le+0x5a>
		if (!(conn->state == state && conn->id == id)) {
   11afe:	44 38 6b 0a          	cmp    %r13b,0xa(%rbx)
   11b02:	75 06                	jne    11b0a <bt_conn_lookup_state_le+0x5a>
   11b04:	40 38 6b 08          	cmp    %bpl,0x8(%rbx)
   11b08:	74 0a                	je     11b14 <bt_conn_lookup_state_le+0x64>
			bt_conn_unref(conn);
   11b0a:	48 89 df             	mov    %rbx,%rdi
   11b0d:	e8 52 fc ff ff       	callq  11764 <bt_conn_unref>
	return NULL;
   11b12:	31 db                	xor    %ebx,%ebx
}
   11b14:	5a                   	pop    %rdx
   11b15:	48 89 d8             	mov    %rbx,%rax
   11b18:	5b                   	pop    %rbx
   11b19:	5d                   	pop    %rbp
   11b1a:	41 5c                	pop    %r12
   11b1c:	41 5d                	pop    %r13
   11b1e:	c3                   	retq   

0000000000011b1f <bt_conn_foreach>:
{
   11b1f:	41 55                	push   %r13
   11b21:	41 54                	push   %r12
   11b23:	41 89 fd             	mov    %edi,%r13d
   11b26:	55                   	push   %rbp
   11b27:	53                   	push   %rbx
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
   11b28:	48 8d 3d 91 56 24 00 	lea    0x245691(%rip),%rdi        # 2571c0 <acl_conns>
{
   11b2f:	48 89 f5             	mov    %rsi,%rbp
   11b32:	49 89 d4             	mov    %rdx,%r12
   11b35:	48 83 ec 08          	sub    $0x8,%rsp
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
   11b39:	e8 08 fc ff ff       	callq  11746 <bt_conn_ref>
		if (!conn) {
   11b3e:	48 85 c0             	test   %rax,%rax
   11b41:	74 23                	je     11b66 <bt_conn_foreach+0x47>
   11b43:	48 89 c3             	mov    %rax,%rbx
		if (!(conn->type & type)) {
   11b46:	0f b6 40 02          	movzbl 0x2(%rax),%eax
   11b4a:	44 85 e8             	test   %r13d,%eax
   11b4d:	74 08                	je     11b57 <bt_conn_foreach+0x38>
		func(conn, data);
   11b4f:	4c 89 e6             	mov    %r12,%rsi
   11b52:	48 89 df             	mov    %rbx,%rdi
   11b55:	ff d5                	callq  *%rbp
}
   11b57:	5a                   	pop    %rdx
		bt_conn_unref(conn);
   11b58:	48 89 df             	mov    %rbx,%rdi
}
   11b5b:	5b                   	pop    %rbx
   11b5c:	5d                   	pop    %rbp
   11b5d:	41 5c                	pop    %r12
   11b5f:	41 5d                	pop    %r13
		bt_conn_unref(conn);
   11b61:	e9 fe fb ff ff       	jmpq   11764 <bt_conn_unref>
}
   11b66:	58                   	pop    %rax
   11b67:	5b                   	pop    %rbx
   11b68:	5d                   	pop    %rbp
   11b69:	41 5c                	pop    %r12
   11b6b:	41 5d                	pop    %r13
   11b6d:	c3                   	retq   

0000000000011b6e <bt_conn_le_conn_update>:
#endif /* !defined(CONFIG_BT_WHITELIST) */
#endif /* CONFIG_BT_CENTRAL */

int bt_conn_le_conn_update(struct bt_conn *conn,
			   const struct bt_le_conn_param *param)
{
   11b6e:	41 54                	push   %r12
   11b70:	55                   	push   %rbp
   11b71:	49 89 fc             	mov    %rdi,%r12
   11b74:	53                   	push   %rbx
	struct hci_cp_le_conn_update *conn_update;
	struct net_buf *buf;

	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_UPDATE,
   11b75:	bf 13 20 00 00       	mov    $0x2013,%edi
{
   11b7a:	48 89 f3             	mov    %rsi,%rbx
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_UPDATE,
   11b7d:	be 0e 00 00 00       	mov    $0xe,%esi
   11b82:	e8 96 c9 ff ff       	callq  e51d <bt_hci_cmd_create>
				sizeof(*conn_update));
	if (!buf) {
   11b87:	48 85 c0             	test   %rax,%rax
   11b8a:	74 59                	je     11be5 <bt_conn_le_conn_update+0x77>
	return net_buf_simple_add(&buf->b, len);
   11b8c:	48 8d 78 10          	lea    0x10(%rax),%rdi
   11b90:	be 0e 00 00 00       	mov    $0xe,%esi
   11b95:	48 89 c5             	mov    %rax,%rbp
   11b98:	e8 ec 74 00 00       	callq  19089 <net_buf_simple_add>
   11b9d:	48 89 c2             	mov    %rax,%rdx
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
   11ba0:	b9 0e 00 00 00       	mov    $0xe,%ecx
   11ba5:	31 c0                	xor    %eax,%eax
   11ba7:	48 89 d7             	mov    %rdx,%rdi
	conn_update->conn_interval_min = sys_cpu_to_le16(param->interval_min);
	conn_update->conn_interval_max = sys_cpu_to_le16(param->interval_max);
	conn_update->conn_latency = sys_cpu_to_le16(param->latency);
	conn_update->supervision_timeout = sys_cpu_to_le16(param->timeout);

	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   11baa:	48 89 ee             	mov    %rbp,%rsi
   11bad:	f3 aa                	rep stos %al,%es:(%rdi)
   11baf:	bf 13 20 00 00       	mov    $0x2013,%edi
	conn_update->handle = sys_cpu_to_le16(conn->handle);
   11bb4:	41 8b 04 24          	mov    (%r12),%eax
   11bb8:	66 89 02             	mov    %ax,(%rdx)
	conn_update->conn_interval_min = sys_cpu_to_le16(param->interval_min);
   11bbb:	66 8b 03             	mov    (%rbx),%ax
   11bbe:	66 89 42 02          	mov    %ax,0x2(%rdx)
	conn_update->conn_interval_max = sys_cpu_to_le16(param->interval_max);
   11bc2:	66 8b 43 02          	mov    0x2(%rbx),%ax
   11bc6:	66 89 42 04          	mov    %ax,0x4(%rdx)
	conn_update->conn_latency = sys_cpu_to_le16(param->latency);
   11bca:	66 8b 43 04          	mov    0x4(%rbx),%ax
   11bce:	66 89 42 06          	mov    %ax,0x6(%rdx)
	conn_update->supervision_timeout = sys_cpu_to_le16(param->timeout);
   11bd2:	66 8b 43 06          	mov    0x6(%rbx),%ax
   11bd6:	66 89 42 08          	mov    %ax,0x8(%rdx)
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   11bda:	31 d2                	xor    %edx,%edx
}
   11bdc:	5b                   	pop    %rbx
   11bdd:	5d                   	pop    %rbp
   11bde:	41 5c                	pop    %r12
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   11be0:	e9 d6 c9 ff ff       	jmpq   e5bb <bt_hci_cmd_send_sync>
}
   11be5:	5b                   	pop    %rbx
   11be6:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
   11beb:	5d                   	pop    %rbp
   11bec:	41 5c                	pop    %r12
   11bee:	c3                   	retq   

0000000000011bef <send_conn_le_param_update>:
{
   11bef:	55                   	push   %rbp
   11bf0:	53                   	push   %rbx
   11bf1:	48 89 fb             	mov    %rdi,%rbx
	if (!bt_le_conn_params_valid(param)) {
   11bf4:	48 89 f7             	mov    %rsi,%rdi
{
   11bf7:	48 89 f5             	mov    %rsi,%rbp
   11bfa:	48 83 ec 08          	sub    $0x8,%rsp
	if (!bt_le_conn_params_valid(param)) {
   11bfe:	e8 d4 cf ff ff       	callq  ebd7 <bt_le_conn_params_valid>
   11c03:	84 c0                	test   %al,%al
   11c05:	74 68                	je     11c6f <send_conn_le_param_update+0x80>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
   11c07:	48 8d 05 32 4a 22 00 	lea    0x224a32(%rip),%rax        # 236640 <bt_dev>
   11c0e:	f6 80 a8 00 00 00 02 	testb  $0x2,0xa8(%rax)
   11c15:	75 08                	jne    11c1f <send_conn_le_param_update+0x30>
	     !atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_L2CAP)) ||
   11c17:	80 7b 03 00          	cmpb   $0x0,0x3(%rbx)
   11c1b:	74 1d                	je     11c3a <send_conn_le_param_update+0x4b>
   11c1d:	eb 42                	jmp    11c61 <send_conn_le_param_update+0x72>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
   11c1f:	f6 83 fc 00 00 00 02 	testb  $0x2,0xfc(%rbx)
   11c26:	74 ef                	je     11c17 <send_conn_le_param_update+0x28>
	     !atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_L2CAP)) ||
   11c28:	48 8d 7b 04          	lea    0x4(%rbx),%rdi
   11c2c:	be 0a 00 00 00       	mov    $0xa,%esi
   11c31:	e8 3c f3 ff ff       	callq  10f72 <atomic_test_bit>
	     BT_FEAT_LE_CONN_PARAM_REQ_PROC(conn->le.features) &&
   11c36:	84 c0                	test   %al,%al
   11c38:	75 dd                	jne    11c17 <send_conn_le_param_update+0x28>
		rc = bt_conn_le_conn_update(conn, param);
   11c3a:	48 89 ee             	mov    %rbp,%rsi
   11c3d:	48 89 df             	mov    %rbx,%rdi
   11c40:	e8 29 ff ff ff       	callq  11b6e <bt_conn_le_conn_update>
		if (rc == 0) {
   11c45:	85 c0                	test   %eax,%eax
   11c47:	75 2b                	jne    11c74 <send_conn_le_param_update+0x85>
			conn->le.pending_latency = param->latency;
   11c49:	66 8b 55 04          	mov    0x4(%rbp),%dx
   11c4d:	66 89 93 f8 00 00 00 	mov    %dx,0xf8(%rbx)
			conn->le.pending_timeout = param->timeout;
   11c54:	66 8b 55 06          	mov    0x6(%rbp),%dx
   11c58:	66 89 93 fa 00 00 00 	mov    %dx,0xfa(%rbx)
   11c5f:	eb 13                	jmp    11c74 <send_conn_le_param_update+0x85>
}
   11c61:	59                   	pop    %rcx
	return bt_l2cap_update_conn_param(conn, param);
   11c62:	48 89 ee             	mov    %rbp,%rsi
   11c65:	48 89 df             	mov    %rbx,%rdi
}
   11c68:	5b                   	pop    %rbx
   11c69:	5d                   	pop    %rbp
	return bt_l2cap_update_conn_param(conn, param);
   11c6a:	e9 86 09 00 00       	jmpq   125f5 <bt_l2cap_update_conn_param>
		return -EINVAL;
   11c6f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
   11c74:	5a                   	pop    %rdx
   11c75:	5b                   	pop    %rbx
   11c76:	5d                   	pop    %rbp
   11c77:	c3                   	retq   

0000000000011c78 <deferred_work>:
{
   11c78:	41 54                	push   %r12
   11c7a:	55                   	push   %rbp
	struct bt_conn *conn = CONTAINER_OF(work, struct bt_conn, deferred_work);
   11c7b:	48 8d af 68 ff ff ff 	lea    -0x98(%rdi),%rbp
{
   11c82:	53                   	push   %rbx
   11c83:	48 89 fb             	mov    %rdi,%rbx
   11c86:	48 83 ec 20          	sub    $0x20,%rsp
   11c8a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   11c91:	00 00 
   11c93:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   11c98:	31 c0                	xor    %eax,%eax
	if (conn->state == BT_CONN_DISCONNECTED) {
   11c9a:	80 bf 72 ff ff ff 00 	cmpb   $0x0,-0x8e(%rdi)
   11ca1:	75 3b                	jne    11cde <deferred_work+0x66>
		bt_l2cap_disconnected(conn);
   11ca3:	48 89 ef             	mov    %rbp,%rdi
   11ca6:	e8 d4 05 00 00       	callq  1227f <bt_l2cap_disconnected>
	for (cb = callback_list; cb; cb = cb->_next) {
   11cab:	4c 8b 25 ee 62 24 00 	mov    0x2462ee(%rip),%r12        # 257fa0 <callback_list>
   11cb2:	4d 85 e4             	test   %r12,%r12
   11cb5:	74 1d                	je     11cd4 <deferred_work+0x5c>
		if (cb->disconnected) {
   11cb7:	49 8b 44 24 08       	mov    0x8(%r12),%rax
   11cbc:	48 85 c0             	test   %rax,%rax
   11cbf:	74 0c                	je     11ccd <deferred_work+0x55>
			cb->disconnected(conn, conn->err);
   11cc1:	0f b6 b3 71 ff ff ff 	movzbl -0x8f(%rbx),%esi
   11cc8:	48 89 ef             	mov    %rbp,%rdi
   11ccb:	ff d0                	callq  *%rax
	for (cb = callback_list; cb; cb = cb->_next) {
   11ccd:	4d 8b 64 24 20       	mov    0x20(%r12),%r12
   11cd2:	eb de                	jmp    11cb2 <deferred_work+0x3a>
		bt_conn_unref(conn);
   11cd4:	48 89 ef             	mov    %rbp,%rdi
   11cd7:	e8 88 fa ff ff       	callq  11764 <bt_conn_unref>
		return;
   11cdc:	eb 76                	jmp    11d54 <deferred_work+0xdc>
	if (conn->type != BT_CONN_TYPE_LE) {
   11cde:	80 bf 6a ff ff ff 01 	cmpb   $0x1,-0x96(%rdi)
   11ce5:	75 6d                	jne    11d54 <deferred_work+0xdc>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   11ce7:	8b 87 6c ff ff ff    	mov    -0x94(%rdi),%eax
	if (atomic_test_and_clear_bit(conn->flags,
   11ced:	4c 8d 65 04          	lea    0x4(%rbp),%r12
   11cf1:	89 c1                	mov    %eax,%ecx
   11cf3:	89 c2                	mov    %eax,%edx
   11cf5:	80 e5 fd             	and    $0xfd,%ch
   11cf8:	f0 41 0f b1 0c 24    	lock cmpxchg %ecx,(%r12)
   11cfe:	75 f1                	jne    11cf1 <deferred_work+0x79>
   11d00:	0f ba e2 09          	bt     $0x9,%edx
   11d04:	73 29                	jae    11d2f <deferred_work+0xb7>
		param = BT_LE_CONN_PARAM(conn->le.interval_min,
   11d06:	8b 43 58             	mov    0x58(%rbx),%eax
		send_conn_le_param_update(conn, param);
   11d09:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
		param = BT_LE_CONN_PARAM(conn->le.interval_min,
   11d0e:	66 89 44 24 08       	mov    %ax,0x8(%rsp)
   11d13:	66 8b 43 5a          	mov    0x5a(%rbx),%ax
   11d17:	66 89 44 24 0a       	mov    %ax,0xa(%rsp)
   11d1c:	8b 43 60             	mov    0x60(%rbx),%eax
   11d1f:	66 89 44 24 0c       	mov    %ax,0xc(%rsp)
   11d24:	66 8b 43 62          	mov    0x62(%rbx),%ax
   11d28:	66 89 44 24 0e       	mov    %ax,0xe(%rsp)
   11d2d:	eb 14                	jmp    11d43 <deferred_work+0xcb>
		param = BT_LE_CONN_PARAM(
   11d2f:	48 b8 18 00 28 00 00 	movabs $0x2a000000280018,%rax
   11d36:	00 2a 00 
		send_conn_le_param_update(conn, param);
   11d39:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
		param = BT_LE_CONN_PARAM(
   11d3e:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
		send_conn_le_param_update(conn, param);
   11d43:	48 89 ef             	mov    %rbp,%rdi
   11d46:	e8 a4 fe ff ff       	callq  11bef <send_conn_le_param_update>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   11d4b:	f0 41 81 0c 24 00 01 	lock orl $0x100,(%r12)
   11d52:	00 00 
}
   11d54:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
   11d59:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   11d60:	00 00 
   11d62:	74 05                	je     11d69 <deferred_work+0xf1>
   11d64:	e8 d7 28 ff ff       	callq  4640 <__stack_chk_fail@plt>
   11d69:	48 83 c4 20          	add    $0x20,%rsp
   11d6d:	5b                   	pop    %rbx
   11d6e:	5d                   	pop    %rbp
   11d6f:	41 5c                	pop    %r12
   11d71:	c3                   	retq   

0000000000011d72 <bt_conn_create_pdu_timeout>:
						 const char *func, int line)
#else
struct net_buf *bt_conn_create_pdu_timeout(struct net_buf_pool *pool,
					   size_t reserve, k_timeout_t timeout)
#endif
{
   11d72:	55                   	push   %rbp
   11d73:	53                   	push   %rbx
   11d74:	48 89 f5             	mov    %rsi,%rbp
   11d77:	48 83 ec 08          	sub    $0x8,%rsp
	 * PDU must not be allocated from ISR as we block with 'K_FOREVER'
	 * during the allocation
	 */
	__ASSERT_NO_MSG(!k_is_in_isr());

	if (!pool) {
   11d7b:	48 85 ff             	test   %rdi,%rdi
   11d7e:	75 07                	jne    11d87 <bt_conn_create_pdu_timeout+0x15>
		pool = &acl_tx_pool;
   11d80:	48 8d 3d c9 89 22 00 	lea    0x2289c9(%rip),%rdi        # 23a750 <acl_tx_pool>
	return net_buf_alloc_fixed(pool, timeout);
   11d87:	48 89 d6             	mov    %rdx,%rsi
   11d8a:	e8 85 71 00 00       	callq  18f14 <net_buf_alloc_fixed>
#else
		buf = net_buf_alloc(pool, timeout);
#endif
	}

	if (!buf) {
   11d8f:	48 85 c0             	test   %rax,%rax
   11d92:	48 89 c3             	mov    %rax,%rbx
   11d95:	75 26                	jne    11dbd <bt_conn_create_pdu_timeout+0x4b>
   11d97:	48 8d 35 f2 85 22 00 	lea    0x2285f2(%rip),%rsi        # 23a390 <log_const_bt_conn>
   11d9e:	48 2b 35 ab 41 22 00 	sub    0x2241ab(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("Unable to allocate buffer within timeout");
   11da5:	48 8d 3d a8 0d 02 00 	lea    0x20da8(%rip),%rdi        # 32b54 <__func__.5785+0x1eec>
   11dac:	48 c1 ee 04          	shr    $0x4,%rsi
   11db0:	c1 e6 06             	shl    $0x6,%esi
   11db3:	83 ce 02             	or     $0x2,%esi
   11db6:	e8 09 55 ff ff       	callq  72c4 <log_0>
   11dbb:	eb 0d                	jmp    11dca <bt_conn_create_pdu_timeout+0x58>
		return NULL;
	}

	reserve += sizeof(struct bt_hci_acl_hdr) + BT_BUF_RESERVE;
   11dbd:	48 8d 75 05          	lea    0x5(%rbp),%rsi
	net_buf_simple_reserve(&buf->b, reserve);
   11dc1:	48 8d 78 10          	lea    0x10(%rax),%rdi
   11dc5:	e8 af 71 00 00       	callq  18f79 <net_buf_simple_reserve>
	net_buf_reserve(buf, reserve);

	return buf;
}
   11dca:	48 89 d8             	mov    %rbx,%rax
   11dcd:	5a                   	pop    %rdx
   11dce:	5b                   	pop    %rbx
   11dcf:	5d                   	pop    %rbp
   11dd0:	c3                   	retq   

0000000000011dd1 <bt_conn_create_frag_timeout>:
{
   11dd1:	48 89 f2             	mov    %rsi,%rdx
	return bt_conn_create_pdu_timeout(pool, reserve, timeout);
   11dd4:	48 89 fe             	mov    %rdi,%rsi
   11dd7:	48 8d 3d c2 89 22 00 	lea    0x2289c2(%rip),%rdi        # 23a7a0 <frag_pool>
   11dde:	e9 8f ff ff ff       	jmpq   11d72 <bt_conn_create_pdu_timeout>

0000000000011de3 <create_frag.isra.9>:
static struct net_buf *create_frag(struct bt_conn *conn, struct net_buf *buf)
   11de3:	41 56                	push   %r14
   11de5:	41 55                	push   %r13
   11de7:	41 54                	push   %r12
   11de9:	55                   	push   %rbp
   11dea:	49 89 f4             	mov    %rsi,%r12
   11ded:	53                   	push   %rbx
		frag = bt_conn_create_frag(0);
   11dee:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
static struct net_buf *create_frag(struct bt_conn *conn, struct net_buf *buf)
   11df2:	48 89 fb             	mov    %rdi,%rbx
		frag = bt_conn_create_frag(0);
   11df5:	31 ff                	xor    %edi,%edi
   11df7:	e8 d5 ff ff ff       	callq  11dd1 <bt_conn_create_frag_timeout>
	if (conn->state != BT_CONN_CONNECTED) {
   11dfc:	80 3b 07             	cmpb   $0x7,(%rbx)
		frag = bt_conn_create_frag(0);
   11dff:	48 89 c5             	mov    %rax,%rbp
	if (conn->state != BT_CONN_CONNECTED) {
   11e02:	74 0c                	je     11e10 <create_frag.isra.9+0x2d>
		net_buf_unref(frag);
   11e04:	48 89 c7             	mov    %rax,%rdi
		return NULL;
   11e07:	31 ed                	xor    %ebp,%ebp
		net_buf_unref(frag);
   11e09:	e8 8c 71 00 00       	callq  18f9a <net_buf_unref>
   11e0e:	eb 58                	jmp    11e68 <create_frag.isra.9+0x85>
	return bt_dev.le.acl_mtu;
   11e10:	48 8d 1d 29 48 22 00 	lea    0x224829(%rip),%rbx        # 236640 <bt_dev>
	return net_buf_simple_tailroom(&buf->b);
   11e17:	4c 8d 68 10          	lea    0x10(%rax),%r13
	tx_data(frag)->tx = NULL;
   11e1b:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
   11e22:	00 
   11e23:	4c 89 ef             	mov    %r13,%rdi
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
   11e26:	44 0f b7 b3 e8 00 00 	movzwl 0xe8(%rbx),%r14d
   11e2d:	00 
   11e2e:	e8 07 73 00 00       	callq  1913a <net_buf_simple_tailroom>
   11e33:	49 39 c6             	cmp    %rax,%r14
   11e36:	73 08                	jae    11e40 <create_frag.isra.9+0x5d>
	return bt_dev.le.acl_mtu;
   11e38:	8b 83 e8 00 00 00    	mov    0xe8(%rbx),%eax
   11e3e:	eb 08                	jmp    11e48 <create_frag.isra.9+0x65>
   11e40:	4c 89 ef             	mov    %r13,%rdi
   11e43:	e8 f2 72 00 00       	callq  1913a <net_buf_simple_tailroom>
	return net_buf_simple_add_mem(&buf->b, mem, len);
   11e48:	49 8b 74 24 10       	mov    0x10(%r12),%rsi
	net_buf_add_mem(frag, buf->data, frag_len);
   11e4d:	0f b7 d8             	movzwl %ax,%ebx
   11e50:	4c 89 ef             	mov    %r13,%rdi
   11e53:	48 89 da             	mov    %rbx,%rdx
   11e56:	e8 3f 72 00 00       	callq  1909a <net_buf_simple_add_mem>
	return net_buf_simple_pull(&buf->b, len);
   11e5b:	49 8d 7c 24 10       	lea    0x10(%r12),%rdi
   11e60:	48 89 de             	mov    %rbx,%rsi
   11e63:	e8 99 72 00 00       	callq  19101 <net_buf_simple_pull>
}
   11e68:	5b                   	pop    %rbx
   11e69:	48 89 e8             	mov    %rbp,%rax
   11e6c:	5d                   	pop    %rbp
   11e6d:	41 5c                	pop    %r12
   11e6f:	41 5d                	pop    %r13
   11e71:	41 5e                	pop    %r14
   11e73:	c3                   	retq   

0000000000011e74 <bt_conn_process_tx>:
	if (conn->state == BT_CONN_DISCONNECTED &&
   11e74:	80 7f 0a 00          	cmpb   $0x0,0xa(%rdi)
   11e78:	75 1b                	jne    11e95 <bt_conn_process_tx+0x21>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   11e7a:	8b 47 04             	mov    0x4(%rdi),%eax
   11e7d:	89 c1                	mov    %eax,%ecx
   11e7f:	89 c2                	mov    %eax,%edx
   11e81:	83 e1 bf             	and    $0xffffffbf,%ecx
   11e84:	f0 0f b1 4f 04       	lock cmpxchg %ecx,0x4(%rdi)
   11e89:	75 f2                	jne    11e7d <bt_conn_process_tx+0x9>
   11e8b:	80 e2 40             	and    $0x40,%dl
   11e8e:	74 05                	je     11e95 <bt_conn_process_tx+0x21>
		conn_cleanup(conn);
   11e90:	e9 01 f4 ff ff       	jmpq   11296 <conn_cleanup>
{
   11e95:	41 55                	push   %r13
   11e97:	41 54                	push   %r12
	buf = net_buf_get(&conn->tx_queue, K_NO_WAIT);
   11e99:	31 f6                	xor    %esi,%esi
{
   11e9b:	55                   	push   %rbp
   11e9c:	53                   	push   %rbx
   11e9d:	48 89 fb             	mov    %rdi,%rbx
	buf = net_buf_get(&conn->tx_queue, K_NO_WAIT);
   11ea0:	48 8d 7f 58          	lea    0x58(%rdi),%rdi
{
   11ea4:	48 83 ec 08          	sub    $0x8,%rsp
	buf = net_buf_get(&conn->tx_queue, K_NO_WAIT);
   11ea8:	e8 7a 70 00 00       	callq  18f27 <net_buf_get>
	BT_ASSERT(buf);
   11ead:	48 85 c0             	test   %rax,%rax
	buf = net_buf_get(&conn->tx_queue, K_NO_WAIT);
   11eb0:	48 89 c5             	mov    %rax,%rbp
	BT_ASSERT(buf);
   11eb3:	75 47                	jne    11efc <bt_conn_process_tx+0x88>
   11eb5:	48 8d 15 c1 0c 02 00 	lea    0x20cc1(%rip),%rdx        # 32b7d <__func__.5785+0x1f15>
   11ebc:	48 8d 35 ad 04 02 00 	lea    0x204ad(%rip),%rsi        # 32370 <__func__.5785+0x1708>
   11ec3:	48 8d 3d ce 05 02 00 	lea    0x205ce(%rip),%rdi        # 32498 <__func__.5785+0x1830>
   11eca:	b9 5f 05 00 00       	mov    $0x55f,%ecx
   11ecf:	31 c0                	xor    %eax,%eax
   11ed1:	e8 ba 3a ff ff       	callq  5990 <printk>
   11ed6:	48 8d 35 a0 0c 02 00 	lea    0x20ca0(%rip),%rsi        # 32b7d <__func__.5785+0x1f15>
   11edd:	48 8d 3d c8 05 02 00 	lea    0x205c8(%rip),%rdi        # 324ac <__func__.5785+0x1844>
   11ee4:	ba 5f 05 00 00       	mov    $0x55f,%edx
   11ee9:	31 c0                	xor    %eax,%eax
   11eeb:	e8 a0 3a ff ff       	callq  5990 <printk>
   11ef0:	31 f6                	xor    %esi,%esi
   11ef2:	bf 03 00 00 00       	mov    $0x3,%edi
   11ef7:	e8 ee 89 01 00       	callq  2a8ea <z_fatal_error>
	return bt_dev.le.acl_mtu;
   11efc:	4c 8d 25 3d 47 22 00 	lea    0x22473d(%rip),%r12        # 236640 <bt_dev>
	if (buf->len <= conn_mtu(conn)) {
   11f03:	41 8b 84 24 e8 00 00 	mov    0xe8(%r12),%eax
   11f0a:	00 
   11f0b:	66 39 45 18          	cmp    %ax,0x18(%rbp)
   11f0f:	77 09                	ja     11f1a <bt_conn_process_tx+0xa6>
		return send_frag(conn, buf, FRAG_SINGLE, false);
   11f11:	31 c9                	xor    %ecx,%ecx
   11f13:	ba 02 00 00 00       	mov    $0x2,%edx
   11f18:	eb 6a                	jmp    11f84 <bt_conn_process_tx+0x110>
   11f1a:	4c 8d 6b 0a          	lea    0xa(%rbx),%r13
	frag = create_frag(conn, buf);
   11f1e:	48 89 ee             	mov    %rbp,%rsi
   11f21:	4c 89 ef             	mov    %r13,%rdi
   11f24:	e8 ba fe ff ff       	callq  11de3 <create_frag.isra.9>
	if (!frag) {
   11f29:	48 85 c0             	test   %rax,%rax
   11f2c:	75 0f                	jne    11f3d <bt_conn_process_tx+0xc9>
}
   11f2e:	5a                   	pop    %rdx
		net_buf_unref(buf);
   11f2f:	48 89 ef             	mov    %rbp,%rdi
}
   11f32:	5b                   	pop    %rbx
   11f33:	5d                   	pop    %rbp
   11f34:	41 5c                	pop    %r12
   11f36:	41 5d                	pop    %r13
		net_buf_unref(buf);
   11f38:	e9 5d 70 00 00       	jmpq   18f9a <net_buf_unref>
	if (!send_frag(conn, frag, FRAG_START, true)) {
   11f3d:	b9 01 00 00 00       	mov    $0x1,%ecx
   11f42:	31 d2                	xor    %edx,%edx
		if (!send_frag(conn, frag, FRAG_CONT, true)) {
   11f44:	48 89 c6             	mov    %rax,%rsi
   11f47:	48 89 df             	mov    %rbx,%rdi
   11f4a:	e8 3c f0 ff ff       	callq  10f8b <send_frag>
   11f4f:	84 c0                	test   %al,%al
   11f51:	74 db                	je     11f2e <bt_conn_process_tx+0xba>
	while (buf->len > conn_mtu(conn)) {
   11f53:	41 8b 84 24 e8 00 00 	mov    0xe8(%r12),%eax
   11f5a:	00 
   11f5b:	66 39 45 18          	cmp    %ax,0x18(%rbp)
   11f5f:	76 1c                	jbe    11f7d <bt_conn_process_tx+0x109>
		frag = create_frag(conn, buf);
   11f61:	48 89 ee             	mov    %rbp,%rsi
   11f64:	4c 89 ef             	mov    %r13,%rdi
   11f67:	e8 77 fe ff ff       	callq  11de3 <create_frag.isra.9>
		if (!frag) {
   11f6c:	48 85 c0             	test   %rax,%rax
   11f6f:	74 bd                	je     11f2e <bt_conn_process_tx+0xba>
		if (!send_frag(conn, frag, FRAG_CONT, true)) {
   11f71:	b9 01 00 00 00       	mov    $0x1,%ecx
   11f76:	ba 01 00 00 00       	mov    $0x1,%edx
   11f7b:	eb c7                	jmp    11f44 <bt_conn_process_tx+0xd0>
	return send_frag(conn, buf, FRAG_END, false);
   11f7d:	31 c9                	xor    %ecx,%ecx
   11f7f:	ba 03 00 00 00       	mov    $0x3,%edx
   11f84:	48 89 ee             	mov    %rbp,%rsi
   11f87:	48 89 df             	mov    %rbx,%rdi
   11f8a:	e8 fc ef ff ff       	callq  10f8b <send_frag>
	if (!send_buf(conn, buf)) {
   11f8f:	84 c0                	test   %al,%al
   11f91:	74 9b                	je     11f2e <bt_conn_process_tx+0xba>
}
   11f93:	58                   	pop    %rax
   11f94:	5b                   	pop    %rbx
   11f95:	5d                   	pop    %rbp
   11f96:	41 5c                	pop    %r12
   11f98:	41 5d                	pop    %r13
   11f9a:	c3                   	retq   

0000000000011f9b <bt_conn_index>:
		__ASSERT(0 <= index && index < ARRAY_SIZE(sco_conns),
			"Invalid bt_conn pointer");
		break;
#endif
	default:
		index = conn - acl_conns;
   11f9b:	48 8d 15 1e 52 24 00 	lea    0x24521e(%rip),%rdx        # 2571c0 <acl_conns>
   11fa2:	48 89 f8             	mov    %rdi,%rax
   11fa5:	48 bf 8b af f8 8a af 	movabs $0xaf8af8af8af8af8b,%rdi
   11fac:	f8 8a af 
   11faf:	48 29 d0             	sub    %rdx,%rax
   11fb2:	48 c1 f8 03          	sar    $0x3,%rax
   11fb6:	48 0f af c7          	imul   %rdi,%rax
			 "Invalid bt_conn pointer");
		break;
	}

	return (uint8_t)index;
}
   11fba:	c3                   	retq   

0000000000011fbb <bt_conn_lookup_index>:

struct bt_conn *bt_conn_lookup_index(uint8_t index)
{
	if (index >= ARRAY_SIZE(acl_conns)) {
   11fbb:	40 84 ff             	test   %dil,%dil
   11fbe:	75 0c                	jne    11fcc <bt_conn_lookup_index+0x11>
		return NULL;
	}

	return bt_conn_ref(&acl_conns[index]);
   11fc0:	48 8d 3d f9 51 24 00 	lea    0x2451f9(%rip),%rdi        # 2571c0 <acl_conns>
   11fc7:	e9 7a f7 ff ff       	jmpq   11746 <bt_conn_ref>
}
   11fcc:	31 c0                	xor    %eax,%eax
   11fce:	c3                   	retq   

0000000000011fcf <bt_conn_init>:

int bt_conn_init(void)
{
   11fcf:	53                   	push   %rbx
	int err, i;

	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
		k_fifo_put(&free_tx, &conn_tx[i]);
   11fd0:	48 8d 35 89 51 24 00 	lea    0x245189(%rip),%rsi        # 257160 <conn_tx>
{
   11fd7:	48 83 ec 10          	sub    $0x10,%rsp
		k_fifo_put(&free_tx, &conn_tx[i]);
   11fdb:	48 8d 1d ee 86 22 00 	lea    0x2286ee(%rip),%rbx        # 23a6d0 <_k_sem_list_end>
   11fe2:	48 89 df             	mov    %rbx,%rdi
   11fe5:	e8 41 93 01 00       	callq  2b32b <k_queue_append>
   11fea:	48 8d 35 8f 51 24 00 	lea    0x24518f(%rip),%rsi        # 257180 <conn_tx+0x20>
   11ff1:	48 89 df             	mov    %rbx,%rdi
   11ff4:	e8 32 93 01 00       	callq  2b32b <k_queue_append>
   11ff9:	48 8d 35 a0 51 24 00 	lea    0x2451a0(%rip),%rsi        # 2571a0 <conn_tx+0x40>
   12000:	48 89 df             	mov    %rbx,%rdi
   12003:	e8 23 93 01 00       	callq  2b32b <k_queue_append>
	}

	bt_att_init();
   12008:	e8 ee 27 00 00       	callq  147fb <bt_att_init>

	err = bt_smp_init();
   1200d:	e8 e3 6c 00 00       	callq  18cf5 <bt_smp_init>
	if (err) {
   12012:	85 c0                	test   %eax,%eax
   12014:	75 0d                	jne    12023 <bt_conn_init+0x54>
   12016:	89 44 24 0c          	mov    %eax,0xc(%rsp)
		return err;
	}

	bt_l2cap_init();
   1201a:	e8 5f 06 00 00       	callq  1267e <bt_l2cap_init>
   1201f:	8b 44 24 0c          	mov    0xc(%rsp),%eax
			bt_conn_unref(conn);
		}
	}

	return 0;
}
   12023:	48 83 c4 10          	add    $0x10,%rsp
   12027:	5b                   	pop    %rbx
   12028:	c3                   	retq   

0000000000012029 <l2cap_connected>:

static void l2cap_connected(struct bt_l2cap_chan *chan)
{
	BT_DBG("ch %p cid 0x%04x", BT_L2CAP_LE_CHAN(chan),
	       BT_L2CAP_LE_CHAN(chan)->rx.cid);
}
   12029:	c3                   	retq   

000000000001202a <l2cap_accept>:
	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_l2cap_pool); i++) {
		struct bt_l2cap *l2cap = &bt_l2cap_pool[i];

		if (l2cap->chan.chan.conn) {
   1202a:	48 83 3d ae 52 24 00 	cmpq   $0x0,0x2452ae(%rip)        # 2572e0 <bt_l2cap_pool>
   12031:	00 
   12032:	75 1b                	jne    1204f <l2cap_accept+0x25>
			continue;
		}

		l2cap->chan.chan.ops = &ops;
   12034:	48 8d 05 e5 33 22 00 	lea    0x2233e5(%rip),%rax        # 235420 <ops.8584>
   1203b:	48 89 05 a6 52 24 00 	mov    %rax,0x2452a6(%rip)        # 2572e8 <bt_l2cap_pool+0x8>
		*chan = &l2cap->chan.chan;
   12042:	48 8d 05 97 52 24 00 	lea    0x245297(%rip),%rax        # 2572e0 <bt_l2cap_pool>
   12049:	48 89 06             	mov    %rax,(%rsi)

		return 0;
   1204c:	31 c0                	xor    %eax,%eax
	}

	BT_ERR("No available L2CAP context for conn %p", conn);

	return -ENOMEM;
}
   1204e:	c3                   	retq   
{
   1204f:	48 83 ec 08          	sub    $0x8,%rsp
   12053:	48 8d 15 86 83 22 00 	lea    0x228386(%rip),%rdx        # 23a3e0 <log_const_bt_l2cap>
   1205a:	48 2b 15 ef 3e 22 00 	sub    0x223eef(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
   12061:	48 89 fe             	mov    %rdi,%rsi
	BT_ERR("No available L2CAP context for conn %p", conn);
   12064:	48 8d 3d 49 0b 02 00 	lea    0x20b49(%rip),%rdi        # 32bb4 <__func__.5785+0x1f4c>
   1206b:	48 c1 ea 04          	shr    $0x4,%rdx
   1206f:	c1 e2 06             	shl    $0x6,%edx
   12072:	83 ca 01             	or     $0x1,%edx
   12075:	e8 7b 52 ff ff       	callq  72f5 <log_1>
	return -ENOMEM;
   1207a:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
}
   1207f:	5a                   	pop    %rdx
   12080:	c3                   	retq   

0000000000012081 <l2cap_disconnected>:
   12081:	c3                   	retq   

0000000000012082 <bt_l2cap_chan_remove>:
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   12082:	48 8b 87 88 00 00 00 	mov    0x88(%rdi),%rax
   12089:	48 85 c0             	test   %rax,%rax
   1208c:	74 60                	je     120ee <bt_l2cap_chan_remove+0x6c>
   1208e:	48 83 e8 10          	sub    $0x10,%rax
   12092:	31 c9                	xor    %ecx,%ecx
   12094:	48 85 c0             	test   %rax,%rax
   12097:	74 55                	je     120ee <bt_l2cap_chan_remove+0x6c>
		if (chan == ch) {
   12099:	48 39 f0             	cmp    %rsi,%rax
   1209c:	4c 8d 40 10          	lea    0x10(%rax),%r8
   120a0:	48 8b 50 10          	mov    0x10(%rax),%rdx
   120a4:	75 3a                	jne    120e0 <bt_l2cap_chan_remove+0x5e>
Z_GENLIST_REMOVE(slist, snode)
   120a6:	48 85 c9             	test   %rcx,%rcx
   120a9:	75 19                	jne    120c4 <bt_l2cap_chan_remove+0x42>
   120ab:	4c 3b 87 90 00 00 00 	cmp    0x90(%rdi),%r8
	list->head = node;
   120b2:	48 89 97 88 00 00 00 	mov    %rdx,0x88(%rdi)
Z_GENLIST_REMOVE(slist, snode)
   120b9:	75 1c                	jne    120d7 <bt_l2cap_chan_remove+0x55>
	list->tail = node;
   120bb:	48 89 97 90 00 00 00 	mov    %rdx,0x90(%rdi)
   120c2:	eb 13                	jmp    120d7 <bt_l2cap_chan_remove+0x55>
	parent->next = child;
   120c4:	48 89 11             	mov    %rdx,(%rcx)
Z_GENLIST_REMOVE(slist, snode)
   120c7:	4c 3b 87 90 00 00 00 	cmp    0x90(%rdi),%r8
   120ce:	75 07                	jne    120d7 <bt_l2cap_chan_remove+0x55>
	list->tail = node;
   120d0:	48 89 8f 90 00 00 00 	mov    %rcx,0x90(%rdi)
	parent->next = child;
   120d7:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
   120de:	00 
   120df:	c3                   	retq   
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   120e0:	48 85 d2             	test   %rdx,%rdx
   120e3:	74 09                	je     120ee <bt_l2cap_chan_remove+0x6c>
   120e5:	48 8d 42 f0          	lea    -0x10(%rdx),%rax
   120e9:	4c 89 c1             	mov    %r8,%rcx
   120ec:	eb a6                	jmp    12094 <bt_l2cap_chan_remove+0x12>
}
   120ee:	c3                   	retq   

00000000000120ef <bt_l2cap_chan_del>:
{
   120ef:	55                   	push   %rbp
   120f0:	53                   	push   %rbx
   120f1:	48 89 fb             	mov    %rdi,%rbx
   120f4:	48 83 ec 08          	sub    $0x8,%rsp
	if (!chan->conn) {
   120f8:	48 83 3f 00          	cmpq   $0x0,(%rdi)
	const struct bt_l2cap_chan_ops *ops = chan->ops;
   120fc:	48 8b 6f 08          	mov    0x8(%rdi),%rbp
	if (!chan->conn) {
   12100:	74 12                	je     12114 <bt_l2cap_chan_del+0x25>
	if (ops->disconnected) {
   12102:	48 8b 45 08          	mov    0x8(%rbp),%rax
   12106:	48 85 c0             	test   %rax,%rax
   12109:	74 02                	je     1210d <bt_l2cap_chan_del+0x1e>
		ops->disconnected(chan);
   1210b:	ff d0                	callq  *%rax
	chan->conn = NULL;
   1210d:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
	if (chan->destroy) {
   12114:	48 8b 43 18          	mov    0x18(%rbx),%rax
   12118:	48 85 c0             	test   %rax,%rax
   1211b:	74 05                	je     12122 <bt_l2cap_chan_del+0x33>
		chan->destroy(chan);
   1211d:	48 89 df             	mov    %rbx,%rdi
   12120:	ff d0                	callq  *%rax
	if (ops->released) {
   12122:	48 8b 45 38          	mov    0x38(%rbp),%rax
   12126:	48 85 c0             	test   %rax,%rax
   12129:	74 08                	je     12133 <bt_l2cap_chan_del+0x44>
}
   1212b:	5a                   	pop    %rdx
		ops->released(chan);
   1212c:	48 89 df             	mov    %rbx,%rdi
}
   1212f:	5b                   	pop    %rbx
   12130:	5d                   	pop    %rbp
		ops->released(chan);
   12131:	ff e0                	jmpq   *%rax
}
   12133:	58                   	pop    %rax
   12134:	5b                   	pop    %rbx
   12135:	5d                   	pop    %rbp
   12136:	c3                   	retq   

0000000000012137 <l2cap_rtx_timeout>:
{
   12137:	55                   	push   %rbp
   12138:	53                   	push   %rbx
	struct bt_l2cap_le_chan *chan = LE_CHAN_RTX(work);
   12139:	48 8d 6f e0          	lea    -0x20(%rdi),%rbp
{
   1213d:	48 83 ec 08          	sub    $0x8,%rsp
   12141:	48 8d 15 98 82 22 00 	lea    0x228298(%rip),%rdx        # 23a3e0 <log_const_bt_l2cap>
   12148:	48 2b 15 01 3e 22 00 	sub    0x223e01(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
	struct bt_conn *conn = chan->chan.conn;
   1214f:	48 8b 5f e0          	mov    -0x20(%rdi),%rbx
	BT_ERR("chan %p timeout", chan);
   12153:	48 8d 3d 81 0a 02 00 	lea    0x20a81(%rip),%rdi        # 32bdb <__func__.5785+0x1f73>
   1215a:	48 89 ee             	mov    %rbp,%rsi
   1215d:	48 c1 ea 04          	shr    $0x4,%rdx
   12161:	c1 e2 06             	shl    $0x6,%edx
   12164:	83 ca 01             	or     $0x1,%edx
   12167:	e8 89 51 ff ff       	callq  72f5 <log_1>
	bt_l2cap_chan_remove(conn, &chan->chan);
   1216c:	48 89 df             	mov    %rbx,%rdi
   1216f:	48 89 ee             	mov    %rbp,%rsi
   12172:	e8 0b ff ff ff       	callq  12082 <bt_l2cap_chan_remove>
}
   12177:	58                   	pop    %rax
	bt_l2cap_chan_del(&chan->chan);
   12178:	48 89 ef             	mov    %rbp,%rdi
}
   1217b:	5b                   	pop    %rbx
   1217c:	5d                   	pop    %rbp
	bt_l2cap_chan_del(&chan->chan);
   1217d:	e9 6d ff ff ff       	jmpq   120ef <bt_l2cap_chan_del>

0000000000012182 <bt_l2cap_chan_add>:
   12182:	48 c7 46 10 00 00 00 	movq   $0x0,0x10(%rsi)
   12189:	00 
Z_GENLIST_APPEND(slist, snode)
   1218a:	48 8b 8f 90 00 00 00 	mov    0x90(%rdi),%rcx
	sys_slist_append(&conn->channels, &chan->node);
   12191:	48 8d 46 10          	lea    0x10(%rsi),%rax
   12195:	48 85 c9             	test   %rcx,%rcx
   12198:	75 10                	jne    121aa <bt_l2cap_chan_add+0x28>
	list->tail = node;
   1219a:	48 89 87 90 00 00 00 	mov    %rax,0x90(%rdi)
	list->head = node;
   121a1:	48 89 87 88 00 00 00 	mov    %rax,0x88(%rdi)
   121a8:	eb 0a                	jmp    121b4 <bt_l2cap_chan_add+0x32>
	parent->next = child;
   121aa:	48 89 01             	mov    %rax,(%rcx)
	list->tail = node;
   121ad:	48 89 87 90 00 00 00 	mov    %rax,0x90(%rdi)
	chan->conn = conn;
   121b4:	48 89 3e             	mov    %rdi,(%rsi)
	chan->destroy = destroy;
   121b7:	48 89 56 18          	mov    %rdx,0x18(%rsi)
}
   121bb:	c3                   	retq   

00000000000121bc <bt_l2cap_connected>:
{
   121bc:	41 54                	push   %r12
   121be:	55                   	push   %rbp
	*work = (struct k_delayed_work)Z_DELAYED_WORK_INITIALIZER(handler);
   121bf:	4c 8d 25 71 ff ff ff 	lea    -0x8f(%rip),%r12        # 12137 <l2cap_rtx_timeout>
   121c6:	53                   	push   %rbx
   121c7:	48 89 fd             	mov    %rdi,%rbp
   121ca:	48 83 ec 10          	sub    $0x10,%rsp
	Z_STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
   121ce:	48 8d 1d 5b 80 22 00 	lea    0x22805b(%rip),%rbx        # 23a230 <__init_SMP_start>
{
   121d5:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   121dc:	00 00 
   121de:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   121e3:	31 c0                	xor    %eax,%eax
	Z_STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
   121e5:	48 3b 1d ac 3d 22 00 	cmp    0x223dac(%rip),%rbx        # 235f98 <_GLOBAL_OFFSET_TABLE_+0x2b8>
   121ec:	73 73                	jae    12261 <bt_l2cap_connected+0xa5>
		if (fchan->accept(conn, &chan) < 0) {
   121ee:	48 89 e6             	mov    %rsp,%rsi
   121f1:	48 89 ef             	mov    %rbp,%rdi
   121f4:	ff 53 08             	callq  *0x8(%rbx)
   121f7:	85 c0                	test   %eax,%eax
   121f9:	78 60                	js     1225b <bt_l2cap_connected+0x9f>
		ch = BT_L2CAP_LE_CHAN(chan);
   121fb:	48 8b 34 24          	mov    (%rsp),%rsi
		ch->rx.cid = fchan->cid;
   121ff:	8b 03                	mov    (%rbx),%eax
   12201:	b9 10 00 00 00       	mov    $0x10,%ecx
		if (!l2cap_chan_add(conn, chan, fchan->destroy)) {
   12206:	48 8b 53 10          	mov    0x10(%rbx),%rdx
   1220a:	48 8d 7e 20          	lea    0x20(%rsi),%rdi
		ch->rx.cid = fchan->cid;
   1220e:	66 89 46 68          	mov    %ax,0x68(%rsi)
		ch->tx.cid = fchan->cid;
   12212:	66 89 46 74          	mov    %ax,0x74(%rsi)
   12216:	31 c0                	xor    %eax,%eax
   12218:	f3 ab                	rep stos %eax,%es:(%rdi)
   1221a:	4c 89 66 28          	mov    %r12,0x28(%rsi)
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   1221e:	87 4e 60             	xchg   %ecx,0x60(%rsi)
	bt_l2cap_chan_add(conn, chan, destroy);
   12221:	48 89 ef             	mov    %rbp,%rdi
   12224:	e8 59 ff ff ff       	callq  12182 <bt_l2cap_chan_add>
		if (chan->ops->connected) {
   12229:	48 8b 3c 24          	mov    (%rsp),%rdi
   1222d:	48 8b 47 08          	mov    0x8(%rdi),%rax
   12231:	48 8b 00             	mov    (%rax),%rax
   12234:	48 85 c0             	test   %rax,%rax
   12237:	74 02                	je     1223b <bt_l2cap_connected+0x7f>
			chan->ops->connected(chan);
   12239:	ff d0                	callq  *%rax
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1223b:	48 8b 04 24          	mov    (%rsp),%rax
   1223f:	f0 83 48 60 01       	lock orl $0x1,0x60(%rax)
		if (chan->ops->status) {
   12244:	48 8b 3c 24          	mov    (%rsp),%rdi
   12248:	48 8b 47 08          	mov    0x8(%rdi),%rax
   1224c:	48 8b 40 30          	mov    0x30(%rax),%rax
   12250:	48 85 c0             	test   %rax,%rax
   12253:	74 06                	je     1225b <bt_l2cap_connected+0x9f>
			chan->ops->status(chan, chan->status);
   12255:	48 8d 77 60          	lea    0x60(%rdi),%rsi
   12259:	ff d0                	callq  *%rax
	Z_STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
   1225b:	48 83 c3 18          	add    $0x18,%rbx
   1225f:	eb 84                	jmp    121e5 <bt_l2cap_connected+0x29>
}
   12261:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   12266:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1226d:	00 00 
   1226f:	74 05                	je     12276 <bt_l2cap_connected+0xba>
   12271:	e8 ca 23 ff ff       	callq  4640 <__stack_chk_fail@plt>
   12276:	48 83 c4 10          	add    $0x10,%rsp
   1227a:	5b                   	pop    %rbx
   1227b:	5d                   	pop    %rbp
   1227c:	41 5c                	pop    %r12
   1227e:	c3                   	retq   

000000000001227f <bt_l2cap_disconnected>:
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   1227f:	48 8b 87 88 00 00 00 	mov    0x88(%rdi),%rax
   12286:	48 85 c0             	test   %rax,%rax
   12289:	74 3f                	je     122ca <bt_l2cap_disconnected+0x4b>
   1228b:	48 89 c7             	mov    %rax,%rdi
   1228e:	48 83 ef 10          	sub    $0x10,%rdi
   12292:	74 36                	je     122ca <bt_l2cap_disconnected+0x4b>
{
   12294:	53                   	push   %rbx
	return node->next;
   12295:	48 8b 18             	mov    (%rax),%rbx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   12298:	48 85 db             	test   %rbx,%rbx
   1229b:	74 25                	je     122c2 <bt_l2cap_disconnected+0x43>
   1229d:	48 83 eb 10          	sub    $0x10,%rbx
		bt_l2cap_chan_del(chan);
   122a1:	e8 49 fe ff ff       	callq  120ef <bt_l2cap_chan_del>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   122a6:	48 85 db             	test   %rbx,%rbx
   122a9:	74 1d                	je     122c8 <bt_l2cap_disconnected+0x49>
   122ab:	48 8b 53 10          	mov    0x10(%rbx),%rdx
   122af:	31 c0                	xor    %eax,%eax
   122b1:	48 85 d2             	test   %rdx,%rdx
   122b4:	74 04                	je     122ba <bt_l2cap_disconnected+0x3b>
   122b6:	48 8d 42 f0          	lea    -0x10(%rdx),%rax
{
   122ba:	48 89 df             	mov    %rbx,%rdi
   122bd:	48 89 c3             	mov    %rax,%rbx
   122c0:	eb df                	jmp    122a1 <bt_l2cap_disconnected+0x22>
}
   122c2:	5b                   	pop    %rbx
		bt_l2cap_chan_del(chan);
   122c3:	e9 27 fe ff ff       	jmpq   120ef <bt_l2cap_chan_del>
}
   122c8:	5b                   	pop    %rbx
   122c9:	c3                   	retq   
   122ca:	c3                   	retq   

00000000000122cb <bt_l2cap_create_pdu_timeout>:
	return bt_conn_create_pdu_timeout(pool,
   122cb:	48 83 c6 04          	add    $0x4,%rsi
   122cf:	e9 9e fa ff ff       	jmpq   11d72 <bt_conn_create_pdu_timeout>

00000000000122d4 <l2cap_create_le_sig_pdu.constprop.11>:
static struct net_buf *l2cap_create_le_sig_pdu(struct net_buf *buf,
   122d4:	41 56                	push   %r14
   122d6:	41 55                	push   %r13
   122d8:	41 89 f6             	mov    %esi,%r14d
   122db:	41 54                	push   %r12
   122dd:	55                   	push   %rbp
	buf = bt_l2cap_create_pdu_timeout(pool, 0, L2CAP_RTX_TIMEOUT);
   122de:	31 f6                	xor    %esi,%esi
static struct net_buf *l2cap_create_le_sig_pdu(struct net_buf *buf,
   122e0:	53                   	push   %rbx
   122e1:	41 89 fc             	mov    %edi,%r12d
   122e4:	41 89 d5             	mov    %edx,%r13d
	buf = bt_l2cap_create_pdu_timeout(pool, 0, L2CAP_RTX_TIMEOUT);
   122e7:	31 ff                	xor    %edi,%edi
   122e9:	ba c8 00 00 00       	mov    $0xc8,%edx
   122ee:	e8 d8 ff ff ff       	callq  122cb <bt_l2cap_create_pdu_timeout>
	if (!buf) {
   122f3:	48 85 c0             	test   %rax,%rax
	buf = bt_l2cap_create_pdu_timeout(pool, 0, L2CAP_RTX_TIMEOUT);
   122f6:	48 89 c3             	mov    %rax,%rbx
	if (!buf) {
   122f9:	75 2a                	jne    12325 <l2cap_create_le_sig_pdu.constprop.11+0x51>
   122fb:	48 8d 15 de 80 22 00 	lea    0x2280de(%rip),%rdx        # 23a3e0 <log_const_bt_l2cap>
   12302:	48 2b 15 47 3c 22 00 	sub    0x223c47(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unable to allocate buffer for op 0x%02x", code);
   12309:	48 8d 3d db 08 02 00 	lea    0x208db(%rip),%rdi        # 32beb <__func__.5785+0x1f83>
   12310:	41 0f b6 f4          	movzbl %r12b,%esi
   12314:	48 c1 ea 04          	shr    $0x4,%rdx
   12318:	c1 e2 06             	shl    $0x6,%edx
   1231b:	83 ca 01             	or     $0x1,%edx
   1231e:	e8 d2 4f ff ff       	callq  72f5 <log_1>
   12323:	eb 1a                	jmp    1233f <l2cap_create_le_sig_pdu.constprop.11+0x6b>
	return net_buf_simple_add(&buf->b, len);
   12325:	48 8d 78 10          	lea    0x10(%rax),%rdi
   12329:	be 04 00 00 00       	mov    $0x4,%esi
   1232e:	e8 56 6d 00 00       	callq  19089 <net_buf_simple_add>
	hdr->code = code;
   12333:	44 88 20             	mov    %r12b,(%rax)
	hdr->ident = ident;
   12336:	44 88 70 01          	mov    %r14b,0x1(%rax)
	hdr->len = sys_cpu_to_le16(len);
   1233a:	66 44 89 68 02       	mov    %r13w,0x2(%rax)
}
   1233f:	48 89 d8             	mov    %rbx,%rax
   12342:	5b                   	pop    %rbx
   12343:	5d                   	pop    %rbp
   12344:	41 5c                	pop    %r12
   12346:	41 5d                	pop    %r13
   12348:	41 5e                	pop    %r14
   1234a:	c3                   	retq   

000000000001234b <bt_l2cap_send_cb>:
{
   1234b:	41 55                	push   %r13
   1234d:	41 54                	push   %r12
   1234f:	41 89 f5             	mov    %esi,%r13d
   12352:	55                   	push   %rbp
   12353:	53                   	push   %rbx
   12354:	48 89 fd             	mov    %rdi,%rbp
	return net_buf_simple_push(&buf->b, len);
   12357:	48 8d 7a 10          	lea    0x10(%rdx),%rdi
   1235b:	48 89 d3             	mov    %rdx,%rbx
   1235e:	be 04 00 00 00       	mov    $0x4,%esi
   12363:	48 83 ec 18          	sub    $0x18,%rsp
   12367:	49 89 cc             	mov    %rcx,%r12
   1236a:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
   1236f:	e8 6e 6d 00 00       	callq  190e2 <net_buf_simple_push>
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   12374:	8b 53 18             	mov    0x18(%rbx),%edx
	return bt_conn_send_cb(conn, buf, cb, user_data);
   12377:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
   1237c:	48 89 ef             	mov    %rbp,%rdi
	hdr->cid = sys_cpu_to_le16(cid);
   1237f:	66 44 89 68 02       	mov    %r13w,0x2(%rax)
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   12384:	8d 72 fc             	lea    -0x4(%rdx),%esi
	return bt_conn_send_cb(conn, buf, cb, user_data);
   12387:	4c 89 e2             	mov    %r12,%rdx
   1238a:	4c 89 c1             	mov    %r8,%rcx
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   1238d:	66 89 30             	mov    %si,(%rax)
}
   12390:	48 83 c4 18          	add    $0x18,%rsp
	return bt_conn_send_cb(conn, buf, cb, user_data);
   12394:	48 89 de             	mov    %rbx,%rsi
}
   12397:	5b                   	pop    %rbx
   12398:	5d                   	pop    %rbp
   12399:	41 5c                	pop    %r12
   1239b:	41 5d                	pop    %r13
	return bt_conn_send_cb(conn, buf, cb, user_data);
   1239d:	e9 f6 f0 ff ff       	jmpq   11498 <bt_conn_send_cb>

00000000000123a2 <l2cap_recv>:
{
   123a2:	41 54                	push   %r12
   123a4:	55                   	push   %rbp
   123a5:	53                   	push   %rbx
	if (buf->len < sizeof(*hdr)) {
   123a6:	66 83 7e 18 03       	cmpw   $0x3,0x18(%rsi)
   123ab:	77 21                	ja     123ce <l2cap_recv+0x2c>
   123ad:	48 8d 35 2c 80 22 00 	lea    0x22802c(%rip),%rsi        # 23a3e0 <log_const_bt_l2cap>
   123b4:	48 2b 35 95 3b 22 00 	sub    0x223b95(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Too small L2CAP signaling PDU");
   123bb:	48 8d 3d 51 08 02 00 	lea    0x20851(%rip),%rdi        # 32c13 <__func__.5785+0x1fab>
   123c2:	48 c1 ee 04          	shr    $0x4,%rsi
   123c6:	c1 e6 06             	shl    $0x6,%esi
   123c9:	83 ce 01             	or     $0x1,%esi
   123cc:	eb 74                	jmp    12442 <l2cap_recv+0xa0>
   123ce:	48 89 fb             	mov    %rdi,%rbx
	return net_buf_simple_pull_mem(&buf->b, len);
   123d1:	48 8d 7e 10          	lea    0x10(%rsi),%rdi
   123d5:	49 89 f4             	mov    %rsi,%r12
   123d8:	be 04 00 00 00       	mov    $0x4,%esi
   123dd:	e8 2d 6d 00 00       	callq  1910f <net_buf_simple_pull_mem>
	if (buf->len != len) {
   123e2:	41 0f b7 74 24 18    	movzwl 0x18(%r12),%esi
	len = sys_le16_to_cpu(hdr->len);
   123e8:	0f b7 50 02          	movzwl 0x2(%rax),%edx
   123ec:	48 89 c5             	mov    %rax,%rbp
	if (buf->len != len) {
   123ef:	66 39 f2             	cmp    %si,%dx
   123f2:	74 29                	je     1241d <l2cap_recv+0x7b>
   123f4:	48 8d 0d e5 7f 22 00 	lea    0x227fe5(%rip),%rcx        # 23a3e0 <log_const_bt_l2cap>
   123fb:	48 2b 0d 4e 3b 22 00 	sub    0x223b4e(%rip),%rcx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("L2CAP length mismatch (%u != %u)", buf->len, len);
   12402:	48 8d 3d 28 08 02 00 	lea    0x20828(%rip),%rdi        # 32c31 <__func__.5785+0x1fc9>
   12409:	48 c1 e9 04          	shr    $0x4,%rcx
   1240d:	c1 e1 06             	shl    $0x6,%ecx
   12410:	83 c9 01             	or     $0x1,%ecx
   12413:	e8 1a 4f ff ff       	callq  7332 <log_2>
   12418:	e9 d7 00 00 00       	jmpq   124f4 <l2cap_recv+0x152>
	if (!hdr->ident) {
   1241d:	80 78 01 00          	cmpb   $0x0,0x1(%rax)
   12421:	75 29                	jne    1244c <l2cap_recv+0xaa>
   12423:	48 8d 35 b6 7f 22 00 	lea    0x227fb6(%rip),%rsi        # 23a3e0 <log_const_bt_l2cap>
   1242a:	48 2b 35 1f 3b 22 00 	sub    0x223b1f(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Invalid ident value in L2CAP PDU");
   12431:	48 8d 3d 1a 08 02 00 	lea    0x2081a(%rip),%rdi        # 32c52 <__func__.5785+0x1fea>
   12438:	48 c1 ee 04          	shr    $0x4,%rsi
   1243c:	c1 e6 06             	shl    $0x6,%esi
   1243f:	83 ce 01             	or     $0x1,%esi
   12442:	e8 7d 4e ff ff       	callq  72c4 <log_0>
   12447:	e9 a8 00 00 00       	jmpq   124f4 <l2cap_recv+0x152>
	switch (hdr->code) {
   1244c:	0f b6 30             	movzbl (%rax),%esi
   1244f:	40 80 fe 01          	cmp    $0x1,%sil
   12453:	0f 84 9b 00 00 00    	je     124f4 <l2cap_recv+0x152>
   12459:	40 80 fe 13          	cmp    $0x13,%sil
   1245d:	75 2b                	jne    1248a <l2cap_recv+0xe8>
	if (buf->len < sizeof(*rsp)) {
   1245f:	66 83 fa 01          	cmp    $0x1,%dx
   12463:	0f 87 8b 00 00 00    	ja     124f4 <l2cap_recv+0x152>
   12469:	48 8d 35 70 7f 22 00 	lea    0x227f70(%rip),%rsi        # 23a3e0 <log_const_bt_l2cap>
   12470:	48 2b 35 d9 3a 22 00 	sub    0x223ad9(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Too small LE conn param rsp");
   12477:	48 8d 3d f5 07 02 00 	lea    0x207f5(%rip),%rdi        # 32c73 <__func__.5785+0x200b>
   1247e:	48 c1 ee 04          	shr    $0x4,%rsi
   12482:	c1 e6 06             	shl    $0x6,%esi
   12485:	83 ce 01             	or     $0x1,%esi
   12488:	eb b8                	jmp    12442 <l2cap_recv+0xa0>
   1248a:	48 8d 15 4f 7f 22 00 	lea    0x227f4f(%rip),%rdx        # 23a3e0 <log_const_bt_l2cap>
   12491:	48 2b 15 b8 3a 22 00 	sub    0x223ab8(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("Unknown L2CAP PDU code 0x%02x", hdr->code);
   12498:	48 8d 3d f0 07 02 00 	lea    0x207f0(%rip),%rdi        # 32c8f <__func__.5785+0x2027>
   1249f:	48 c1 ea 04          	shr    $0x4,%rdx
   124a3:	c1 e2 06             	shl    $0x6,%edx
   124a6:	83 ca 02             	or     $0x2,%edx
   124a9:	e8 47 4e ff ff       	callq  72f5 <log_1>
		l2cap_send_reject(chan->conn, hdr->ident,
   124ae:	0f b6 75 01          	movzbl 0x1(%rbp),%esi
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
   124b2:	ba 02 00 00 00       	mov    $0x2,%edx
   124b7:	bf 01 00 00 00       	mov    $0x1,%edi
		l2cap_send_reject(chan->conn, hdr->ident,
   124bc:	4c 8b 23             	mov    (%rbx),%r12
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
   124bf:	e8 10 fe ff ff       	callq  122d4 <l2cap_create_le_sig_pdu.constprop.11>
	if (!buf) {
   124c4:	48 85 c0             	test   %rax,%rax
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
   124c7:	48 89 c3             	mov    %rax,%rbx
	if (!buf) {
   124ca:	74 28                	je     124f4 <l2cap_recv+0x152>
	return net_buf_simple_add(&buf->b, len);
   124cc:	48 8d 78 10          	lea    0x10(%rax),%rdi
   124d0:	be 02 00 00 00       	mov    $0x2,%esi
   124d5:	e8 af 6b 00 00       	callq  19089 <net_buf_simple_add>
		     bt_conn_tx_cb_t cb, void *user_data);

static inline void bt_l2cap_send(struct bt_conn *conn, uint16_t cid,
				 struct net_buf *buf)
{
	bt_l2cap_send_cb(conn, cid, buf, NULL, NULL);
   124da:	45 31 c0             	xor    %r8d,%r8d
	rej->reason = sys_cpu_to_le16(reason);
   124dd:	66 c7 00 00 00       	movw   $0x0,(%rax)
   124e2:	31 c9                	xor    %ecx,%ecx
   124e4:	48 89 da             	mov    %rbx,%rdx
   124e7:	be 05 00 00 00       	mov    $0x5,%esi
   124ec:	4c 89 e7             	mov    %r12,%rdi
   124ef:	e8 57 fe ff ff       	callq  1234b <bt_l2cap_send_cb>
}
   124f4:	5b                   	pop    %rbx
   124f5:	31 c0                	xor    %eax,%eax
   124f7:	5d                   	pop    %rbp
   124f8:	41 5c                	pop    %r12
   124fa:	c3                   	retq   

00000000000124fb <bt_l2cap_le_lookup_tx_cid>:
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   124fb:	48 8b 97 88 00 00 00 	mov    0x88(%rdi),%rdx
	return NULL;
   12502:	31 c0                	xor    %eax,%eax
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   12504:	48 85 d2             	test   %rdx,%rdx
   12507:	74 21                	je     1252a <bt_l2cap_le_lookup_tx_cid+0x2f>
   12509:	48 8d 42 f0          	lea    -0x10(%rdx),%rax
   1250d:	48 85 c0             	test   %rax,%rax
   12510:	74 15                	je     12527 <bt_l2cap_le_lookup_tx_cid+0x2c>
		if (BT_L2CAP_LE_CHAN(chan)->tx.cid == cid) {
   12512:	66 39 70 74          	cmp    %si,0x74(%rax)
   12516:	74 12                	je     1252a <bt_l2cap_le_lookup_tx_cid+0x2f>
   12518:	48 8b 40 10          	mov    0x10(%rax),%rax
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   1251c:	48 85 c0             	test   %rax,%rax
   1251f:	74 07                	je     12528 <bt_l2cap_le_lookup_tx_cid+0x2d>
   12521:	48 83 e8 10          	sub    $0x10,%rax
   12525:	eb e6                	jmp    1250d <bt_l2cap_le_lookup_tx_cid+0x12>
   12527:	c3                   	retq   
	return NULL;
   12528:	31 c0                	xor    %eax,%eax
}
   1252a:	c3                   	retq   

000000000001252b <bt_l2cap_le_lookup_rx_cid>:
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   1252b:	48 8b 97 88 00 00 00 	mov    0x88(%rdi),%rdx
	return NULL;
   12532:	31 c0                	xor    %eax,%eax
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   12534:	48 85 d2             	test   %rdx,%rdx
   12537:	74 21                	je     1255a <bt_l2cap_le_lookup_rx_cid+0x2f>
   12539:	48 8d 42 f0          	lea    -0x10(%rdx),%rax
   1253d:	48 85 c0             	test   %rax,%rax
   12540:	74 15                	je     12557 <bt_l2cap_le_lookup_rx_cid+0x2c>
		if (BT_L2CAP_LE_CHAN(chan)->rx.cid == cid) {
   12542:	66 39 70 68          	cmp    %si,0x68(%rax)
   12546:	74 12                	je     1255a <bt_l2cap_le_lookup_rx_cid+0x2f>
   12548:	48 8b 40 10          	mov    0x10(%rax),%rax
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   1254c:	48 85 c0             	test   %rax,%rax
   1254f:	74 07                	je     12558 <bt_l2cap_le_lookup_rx_cid+0x2d>
   12551:	48 83 e8 10          	sub    $0x10,%rax
   12555:	eb e6                	jmp    1253d <bt_l2cap_le_lookup_rx_cid+0x12>
   12557:	c3                   	retq   
	return NULL;
   12558:	31 c0                	xor    %eax,%eax
}
   1255a:	c3                   	retq   

000000000001255b <bt_l2cap_recv>:
{
   1255b:	41 54                	push   %r12
   1255d:	55                   	push   %rbp
   1255e:	53                   	push   %rbx
	if (buf->len < sizeof(*hdr)) {
   1255f:	66 83 7e 18 03       	cmpw   $0x3,0x18(%rsi)
{
   12564:	48 89 f3             	mov    %rsi,%rbx
	if (buf->len < sizeof(*hdr)) {
   12567:	77 26                	ja     1258f <bt_l2cap_recv+0x34>
   12569:	48 8d 35 70 7e 22 00 	lea    0x227e70(%rip),%rsi        # 23a3e0 <log_const_bt_l2cap>
   12570:	48 2b 35 d9 39 22 00 	sub    0x2239d9(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Too small L2CAP PDU received");
   12577:	48 8d 3d 2f 07 02 00 	lea    0x2072f(%rip),%rdi        # 32cad <__func__.5785+0x2045>
   1257e:	48 c1 ee 04          	shr    $0x4,%rsi
   12582:	c1 e6 06             	shl    $0x6,%esi
   12585:	83 ce 01             	or     $0x1,%esi
   12588:	e8 37 4d ff ff       	callq  72c4 <log_0>
   1258d:	eb 5a                	jmp    125e9 <bt_l2cap_recv+0x8e>
   1258f:	49 89 fc             	mov    %rdi,%r12
	return net_buf_simple_pull_mem(&buf->b, len);
   12592:	48 8d 7e 10          	lea    0x10(%rsi),%rdi
   12596:	be 04 00 00 00       	mov    $0x4,%esi
   1259b:	e8 6f 6b 00 00       	callq  1910f <net_buf_simple_pull_mem>
	cid = sys_le16_to_cpu(hdr->cid);
   125a0:	0f b7 70 02          	movzwl 0x2(%rax),%esi
	chan = bt_l2cap_le_lookup_rx_cid(conn, cid);
   125a4:	4c 89 e7             	mov    %r12,%rdi
	cid = sys_le16_to_cpu(hdr->cid);
   125a7:	89 f5                	mov    %esi,%ebp
	chan = bt_l2cap_le_lookup_rx_cid(conn, cid);
   125a9:	e8 7d ff ff ff       	callq  1252b <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
   125ae:	48 85 c0             	test   %rax,%rax
   125b1:	75 29                	jne    125dc <bt_l2cap_recv+0x81>
   125b3:	48 8d 15 26 7e 22 00 	lea    0x227e26(%rip),%rdx        # 23a3e0 <log_const_bt_l2cap>
   125ba:	48 2b 15 8f 39 22 00 	sub    0x22398f(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("Ignoring data for unknown channel ID 0x%04x", cid);
   125c1:	48 8d 3d 02 07 02 00 	lea    0x20702(%rip),%rdi        # 32cca <__func__.5785+0x2062>
   125c8:	0f b7 f5             	movzwl %bp,%esi
   125cb:	48 c1 ea 04          	shr    $0x4,%rdx
   125cf:	c1 e2 06             	shl    $0x6,%edx
   125d2:	83 ca 02             	or     $0x2,%edx
   125d5:	e8 1b 4d ff ff       	callq  72f5 <log_1>
   125da:	eb 0d                	jmp    125e9 <bt_l2cap_recv+0x8e>
	chan->ops->recv(chan, buf);
   125dc:	48 8b 50 08          	mov    0x8(%rax),%rdx
   125e0:	48 89 de             	mov    %rbx,%rsi
   125e3:	48 89 c7             	mov    %rax,%rdi
   125e6:	ff 52 20             	callq  *0x20(%rdx)
	net_buf_unref(buf);
   125e9:	48 89 df             	mov    %rbx,%rdi
}
   125ec:	5b                   	pop    %rbx
   125ed:	5d                   	pop    %rbp
   125ee:	41 5c                	pop    %r12
	net_buf_unref(buf);
   125f0:	e9 a5 69 00 00       	jmpq   18f9a <net_buf_unref>

00000000000125f5 <bt_l2cap_update_conn_param>:
{
   125f5:	41 54                	push   %r12
   125f7:	55                   	push   %rbp
	ident++;
   125f8:	b0 01                	mov    $0x1,%al
{
   125fa:	53                   	push   %rbx
   125fb:	48 89 f3             	mov    %rsi,%rbx
	ident++;
   125fe:	40 8a 35 e5 ca 24 00 	mov    0x24cae5(%rip),%sil        # 25f0ea <ident.8351>
{
   12605:	48 89 fd             	mov    %rdi,%rbp
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CONN_PARAM_REQ,
   12608:	ba 08 00 00 00       	mov    $0x8,%edx
   1260d:	bf 12 00 00 00       	mov    $0x12,%edi
	ident++;
   12612:	40 fe c6             	inc    %sil
   12615:	0f 44 f0             	cmove  %eax,%esi
   12618:	40 88 35 cb ca 24 00 	mov    %sil,0x24cacb(%rip)        # 25f0ea <ident.8351>
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CONN_PARAM_REQ,
   1261f:	40 0f b6 f6          	movzbl %sil,%esi
   12623:	e8 ac fc ff ff       	callq  122d4 <l2cap_create_le_sig_pdu.constprop.11>
   12628:	49 89 c4             	mov    %rax,%r12
   1262b:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	if (!buf) {
   12630:	4d 85 e4             	test   %r12,%r12
   12633:	74 44                	je     12679 <bt_l2cap_update_conn_param+0x84>
	return net_buf_simple_add(&buf->b, len);
   12635:	49 8d 7c 24 10       	lea    0x10(%r12),%rdi
   1263a:	be 08 00 00 00       	mov    $0x8,%esi
   1263f:	e8 45 6a 00 00       	callq  19089 <net_buf_simple_add>
	req->min_interval = sys_cpu_to_le16(param->interval_min);
   12644:	66 8b 13             	mov    (%rbx),%dx
   12647:	45 31 c0             	xor    %r8d,%r8d
   1264a:	31 c9                	xor    %ecx,%ecx
   1264c:	be 05 00 00 00       	mov    $0x5,%esi
   12651:	48 89 ef             	mov    %rbp,%rdi
   12654:	66 89 10             	mov    %dx,(%rax)
	req->max_interval = sys_cpu_to_le16(param->interval_max);
   12657:	66 8b 53 02          	mov    0x2(%rbx),%dx
   1265b:	66 89 50 02          	mov    %dx,0x2(%rax)
	req->latency = sys_cpu_to_le16(param->latency);
   1265f:	66 8b 53 04          	mov    0x4(%rbx),%dx
   12663:	66 89 50 04          	mov    %dx,0x4(%rax)
	req->timeout = sys_cpu_to_le16(param->timeout);
   12667:	66 8b 53 06          	mov    0x6(%rbx),%dx
   1266b:	66 89 50 06          	mov    %dx,0x6(%rax)
   1266f:	4c 89 e2             	mov    %r12,%rdx
   12672:	e8 d4 fc ff ff       	callq  1234b <bt_l2cap_send_cb>
	return 0;
   12677:	31 c0                	xor    %eax,%eax
}
   12679:	5b                   	pop    %rbx
   1267a:	5d                   	pop    %rbp
   1267b:	41 5c                	pop    %r12
   1267d:	c3                   	retq   

000000000001267e <bt_l2cap_init>:
void bt_l2cap_init(void)
{
	if (IS_ENABLED(CONFIG_BT_BREDR)) {
		bt_l2cap_br_init();
	}
}
   1267e:	c3                   	retq   

000000000001267f <sys_slist_get>:
Z_GENLIST_IS_EMPTY(slist)
   1267f:	48 8b 07             	mov    (%rdi),%rax
Z_GENLIST_GET(slist, snode)
   12682:	48 85 c0             	test   %rax,%rax
   12685:	74 10                	je     12697 <sys_slist_get+0x18>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   12687:	48 3b 47 08          	cmp    0x8(%rdi),%rax
	return node->next;
   1268b:	48 8b 10             	mov    (%rax),%rdx
	list->head = node;
   1268e:	48 89 17             	mov    %rdx,(%rdi)
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   12691:	75 04                	jne    12697 <sys_slist_get+0x18>
	list->tail = node;
   12693:	48 89 57 08          	mov    %rdx,0x8(%rdi)
Z_GENLIST_GET(slist, snode)
   12697:	c3                   	retq   

0000000000012698 <sys_slist_find_and_remove>:
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   12698:	48 8b 07             	mov    (%rdi),%rax
   1269b:	31 d2                	xor    %edx,%edx
   1269d:	48 85 c0             	test   %rax,%rax
   126a0:	74 3b                	je     126dd <sys_slist_find_and_remove+0x45>
   126a2:	48 39 f0             	cmp    %rsi,%rax
   126a5:	48 8b 08             	mov    (%rax),%rcx
   126a8:	75 2b                	jne    126d5 <sys_slist_find_and_remove+0x3d>
Z_GENLIST_REMOVE(slist, snode)
   126aa:	48 85 d2             	test   %rdx,%rdx
   126ad:	75 0f                	jne    126be <sys_slist_find_and_remove+0x26>
   126af:	48 3b 47 08          	cmp    0x8(%rdi),%rax
	list->head = node;
   126b3:	48 89 0f             	mov    %rcx,(%rdi)
Z_GENLIST_REMOVE(slist, snode)
   126b6:	75 13                	jne    126cb <sys_slist_find_and_remove+0x33>
	list->tail = node;
   126b8:	48 89 4f 08          	mov    %rcx,0x8(%rdi)
   126bc:	eb 0d                	jmp    126cb <sys_slist_find_and_remove+0x33>
	parent->next = child;
   126be:	48 89 0a             	mov    %rcx,(%rdx)
Z_GENLIST_REMOVE(slist, snode)
   126c1:	48 3b 47 08          	cmp    0x8(%rdi),%rax
   126c5:	75 04                	jne    126cb <sys_slist_find_and_remove+0x33>
	list->tail = node;
   126c7:	48 89 57 08          	mov    %rdx,0x8(%rdi)
	parent->next = child;
   126cb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   126d2:	b0 01                	mov    $0x1,%al
   126d4:	c3                   	retq   
   126d5:	48 89 c2             	mov    %rax,%rdx
   126d8:	48 89 c8             	mov    %rcx,%rax
   126db:	eb c0                	jmp    1269d <sys_slist_find_and_remove+0x5>
   126dd:	c3                   	retq   

00000000000126de <net_buf_frags_len>:
 *
 * @return Number of bytes in the buffer and its fragments.
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
	size_t bytes = 0;
   126de:	31 c0                	xor    %eax,%eax

	while (buf) {
   126e0:	48 85 ff             	test   %rdi,%rdi
   126e3:	74 0c                	je     126f1 <net_buf_frags_len+0x13>
		bytes += buf->len;
   126e5:	0f b7 57 18          	movzwl 0x18(%rdi),%edx
		buf = buf->frags;
   126e9:	48 8b 3f             	mov    (%rdi),%rdi
		bytes += buf->len;
   126ec:	48 01 d0             	add    %rdx,%rax
   126ef:	eb ef                	jmp    126e0 <net_buf_frags_len+0x2>
	}

	return bytes;
}
   126f1:	c3                   	retq   

00000000000126f2 <att_sent>:
{
	struct bt_l2cap_chan *chan = user_data;

	BT_DBG("conn %p chan %p", conn, chan);

	if (chan->ops->sent) {
   126f2:	48 8b 46 08          	mov    0x8(%rsi),%rax
   126f6:	48 8b 40 28          	mov    0x28(%rax),%rax
   126fa:	48 85 c0             	test   %rax,%rax
   126fd:	74 05                	je     12704 <att_sent+0x12>
		chan->ops->sent(chan);
   126ff:	48 89 f7             	mov    %rsi,%rdi
   12702:	ff e0                	jmpq   *%rax
	}
}
   12704:	c3                   	retq   

0000000000012705 <chan_cfm_sent>:
	BT_DBG("chan %p", chan);

	if (IS_ENABLED(CONFIG_BT_ATT_ENFORCE_FLOW)) {
		atomic_clear_bit(chan->flags, ATT_PENDING_CFM);
	}
}
   12705:	c3                   	retq   

0000000000012706 <att_cfm_sent>:
	struct bt_l2cap_chan *ch = user_data;
	struct bt_att_chan *chan = ATT_CHAN(ch);

	BT_DBG("conn %p chan %p", conn, chan);

	chan->sent = chan_cfm_sent;
   12706:	48 8d 05 f8 ff ff ff 	lea    -0x8(%rip),%rax        # 12705 <chan_cfm_sent>
   1270d:	48 89 86 d0 01 00 00 	mov    %rax,0x1d0(%rsi)

	att_sent(conn, user_data);
   12714:	e9 d9 ff ff ff       	jmpq   126f2 <att_sent>

0000000000012719 <att_rsp_sent>:
	struct bt_l2cap_chan *ch = user_data;
	struct bt_att_chan *chan = ATT_CHAN(ch);

	BT_DBG("conn %p chan %p", conn, chan);

	chan->sent = chan_rsp_sent;
   12719:	48 8d 05 53 09 00 00 	lea    0x953(%rip),%rax        # 13073 <chan_rsp_sent>
   12720:	48 89 86 d0 01 00 00 	mov    %rax,0x1d0(%rsi)

	att_sent(conn, user_data);
   12727:	e9 c6 ff ff ff       	jmpq   126f2 <att_sent>

000000000001272c <att_req_sent>:
	struct bt_l2cap_chan *ch = user_data;
	struct bt_att_chan *chan = ATT_CHAN(ch);

	BT_DBG("conn %p chan %p", conn, chan);

	chan->sent = chan_req_sent;
   1272c:	48 8d 05 bd 07 00 00 	lea    0x7bd(%rip),%rax        # 12ef0 <chan_req_sent>
   12733:	48 89 86 d0 01 00 00 	mov    %rax,0x1d0(%rsi)

	att_sent(conn, user_data);
   1273a:	e9 b3 ff ff ff       	jmpq   126f2 <att_sent>

000000000001273f <attr_read_type_cb>:
static bool attr_read_type_cb(struct net_buf *frag, ssize_t read,
			      void *user_data)
{
	struct read_type_data *data = user_data;

	if (!data->rsp->len) {
   1273f:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
   12743:	8a 01                	mov    (%rcx),%al
   12745:	84 c0                	test   %al,%al
   12747:	75 09                	jne    12752 <attr_read_type_cb+0x13>
		/* Set len to be the first item found */
		data->rsp->len = read + sizeof(*data->item);
   12749:	83 c6 02             	add    $0x2,%esi
		frag->len -= sizeof(*data->item);
		data->item = NULL;
		return false;
	}

	return true;
   1274c:	b0 01                	mov    $0x1,%al
		data->rsp->len = read + sizeof(*data->item);
   1274e:	40 88 31             	mov    %sil,(%rcx)
   12751:	c3                   	retq   
	} else if (data->rsp->len != read + sizeof(*data->item)) {
   12752:	0f b6 c8             	movzbl %al,%ecx
   12755:	48 83 c6 02          	add    $0x2,%rsi
	return true;
   12759:	b0 01                	mov    $0x1,%al
	} else if (data->rsp->len != read + sizeof(*data->item)) {
   1275b:	48 39 f1             	cmp    %rsi,%rcx
   1275e:	74 0f                	je     1276f <attr_read_type_cb+0x30>
		frag->len -= sizeof(*data->item);
   12760:	66 83 6f 18 02       	subw   $0x2,0x18(%rdi)
		return false;
   12765:	31 c0                	xor    %eax,%eax
		data->item = NULL;
   12767:	48 c7 42 20 00 00 00 	movq   $0x0,0x20(%rdx)
   1276e:	00 
}
   1276f:	c3                   	retq   

0000000000012770 <att_op_get_type>:
#endif /* CONFIG_BT_GATT_CLIENT */
};

static att_type_t att_op_get_type(uint8_t op)
{
	switch (op) {
   12770:	40 80 ff 0e          	cmp    $0xe,%dil
   12774:	0f 84 ca 00 00 00    	je     12844 <att_op_get_type+0xd4>
   1277a:	77 59                	ja     127d5 <att_op_get_type+0x65>
   1277c:	40 80 ff 07          	cmp    $0x7,%dil
   12780:	0f 84 ae 00 00 00    	je     12834 <att_op_get_type+0xc4>
   12786:	77 2b                	ja     127b3 <att_op_get_type+0x43>
   12788:	40 80 ff 03          	cmp    $0x3,%dil
   1278c:	0f 84 a2 00 00 00    	je     12834 <att_op_get_type+0xc4>
   12792:	77 10                	ja     127a4 <att_op_get_type+0x34>
   12794:	40 80 ff 01          	cmp    $0x1,%dil
   12798:	0f 84 96 00 00 00    	je     12834 <att_op_get_type+0xc4>
   1279e:	40 80 ff 02          	cmp    $0x2,%dil
   127a2:	eb 59                	jmp    127fd <att_op_get_type+0x8d>
   127a4:	40 80 ff 05          	cmp    $0x5,%dil
   127a8:	0f 85 96 00 00 00    	jne    12844 <att_op_get_type+0xd4>
   127ae:	e9 81 00 00 00       	jmpq   12834 <att_op_get_type+0xc4>
   127b3:	40 80 ff 0a          	cmp    $0xa,%dil
   127b7:	0f 84 87 00 00 00    	je     12844 <att_op_get_type+0xd4>
   127bd:	77 0e                	ja     127cd <att_op_get_type+0x5d>
   127bf:	40 80 ff 08          	cmp    $0x8,%dil
   127c3:	74 7f                	je     12844 <att_op_get_type+0xd4>
   127c5:	40 80 ff 09          	cmp    $0x9,%dil
   127c9:	75 6c                	jne    12837 <att_op_get_type+0xc7>
   127cb:	eb 67                	jmp    12834 <att_op_get_type+0xc4>
   127cd:	40 80 ff 0c          	cmp    $0xc,%dil
   127d1:	75 61                	jne    12834 <att_op_get_type+0xc4>
   127d3:	eb 6f                	jmp    12844 <att_op_get_type+0xd4>
   127d5:	40 80 ff 17          	cmp    $0x17,%dil
   127d9:	74 59                	je     12834 <att_op_get_type+0xc4>
   127db:	77 24                	ja     12801 <att_op_get_type+0x91>
   127dd:	40 80 ff 11          	cmp    $0x11,%dil
   127e1:	74 51                	je     12834 <att_op_get_type+0xc4>
   127e3:	77 0c                	ja     127f1 <att_op_get_type+0x81>
   127e5:	40 80 ff 0f          	cmp    $0xf,%dil
   127e9:	74 49                	je     12834 <att_op_get_type+0xc4>
   127eb:	40 80 ff 10          	cmp    $0x10,%dil
   127ef:	eb 0c                	jmp    127fd <att_op_get_type+0x8d>
   127f1:	40 80 ff 13          	cmp    $0x13,%dil
   127f5:	74 3d                	je     12834 <att_op_get_type+0xc4>
   127f7:	72 4b                	jb     12844 <att_op_get_type+0xd4>
   127f9:	40 80 ff 16          	cmp    $0x16,%dil
   127fd:	75 38                	jne    12837 <att_op_get_type+0xc7>
   127ff:	eb 43                	jmp    12844 <att_op_get_type+0xd4>
   12801:	40 80 ff 1d          	cmp    $0x1d,%dil
	case BT_ATT_OP_EXEC_WRITE_RSP:
		return ATT_RESPONSE;
	case BT_ATT_OP_NOTIFY:
		return ATT_NOTIFICATION;
	case BT_ATT_OP_INDICATE:
		return ATT_INDICATION;
   12805:	b0 05                	mov    $0x5,%al
	switch (op) {
   12807:	74 3d                	je     12846 <att_op_get_type+0xd6>
   12809:	77 10                	ja     1281b <att_op_get_type+0xab>
   1280b:	40 80 ff 19          	cmp    $0x19,%dil
   1280f:	74 23                	je     12834 <att_op_get_type+0xc4>
   12811:	72 31                	jb     12844 <att_op_get_type+0xd4>
		return ATT_NOTIFICATION;
   12813:	b0 03                	mov    $0x3,%al
	switch (op) {
   12815:	40 80 ff 1b          	cmp    $0x1b,%dil
   12819:	eb 12                	jmp    1282d <att_op_get_type+0xbd>
   1281b:	40 80 ff 52          	cmp    $0x52,%dil
   1281f:	74 10                	je     12831 <att_op_get_type+0xc1>
   12821:	40 80 ff d2          	cmp    $0xd2,%dil
   12825:	74 0a                	je     12831 <att_op_get_type+0xc1>
		return ATT_CONFIRMATION;
   12827:	b0 04                	mov    $0x4,%al
	switch (op) {
   12829:	40 80 ff 1e          	cmp    $0x1e,%dil
   1282d:	74 17                	je     12846 <att_op_get_type+0xd6>
   1282f:	eb 06                	jmp    12837 <att_op_get_type+0xc7>
		return ATT_COMMAND;
   12831:	31 c0                	xor    %eax,%eax
   12833:	c3                   	retq   
		return ATT_RESPONSE;
   12834:	b0 02                	mov    $0x2,%al
   12836:	c3                   	retq   
	}

	if (op & ATT_CMD_MASK) {
   12837:	83 e7 40             	and    $0x40,%edi
		return ATT_COMMAND;
	}

	return ATT_UNKNOWN;
   1283a:	40 80 ff 01          	cmp    $0x1,%dil
   1283e:	19 c0                	sbb    %eax,%eax
   12840:	83 e0 06             	and    $0x6,%eax
   12843:	c3                   	retq   
		return ATT_REQUEST;
   12844:	b0 01                	mov    $0x1,%al
}
   12846:	c3                   	retq   

0000000000012847 <atomic_test_bit>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   12847:	8b 07                	mov    (%rdi),%eax
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   12849:	40 88 f1             	mov    %sil,%cl
   1284c:	d3 f8                	sar    %cl,%eax
   1284e:	83 e0 01             	and    $0x1,%eax
}
   12851:	c3                   	retq   

0000000000012852 <bt_att_released>:
	/* Prepend back to the list as it could not be sent */
	sys_slist_prepend(&chan->att->reqs, node);
}

static void bt_att_released(struct bt_l2cap_chan *ch)
{
   12852:	48 83 ec 18          	sub    $0x18,%rsp
	struct bt_att_chan *chan = ATT_CHAN(ch);
   12856:	48 83 ef 08          	sub    $0x8,%rdi
   1285a:	48 89 3c 24          	mov    %rdi,(%rsp)

	BT_DBG("chan %p", chan);

	k_mem_slab_free(&chan_slab, (void **)&chan);
   1285e:	48 8d 3d 43 7d 22 00 	lea    0x227d43(%rip),%rdi        # 23a5a8 <chan_slab>
   12865:	48 89 e6             	mov    %rsp,%rsi
{
   12868:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1286f:	00 00 
   12871:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   12876:	31 c0                	xor    %eax,%eax
	k_mem_slab_free(&chan_slab, (void **)&chan);
   12878:	e8 1e 85 01 00       	callq  2ad9b <k_mem_slab_free>
}
   1287d:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   12882:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   12889:	00 00 
   1288b:	74 05                	je     12892 <bt_att_released+0x40>
   1288d:	e8 ae 1d ff ff       	callq  4640 <__stack_chk_fail@plt>
   12892:	48 83 c4 18          	add    $0x18,%rsp
   12896:	c3                   	retq   

0000000000012897 <att_notify_mult>:
{
   12897:	48 83 ec 08          	sub    $0x8,%rsp
	bt_gatt_mult_notification(chan->att->conn, buf->data, buf->len);
   1289b:	48 8b 07             	mov    (%rdi),%rax
   1289e:	0f b7 56 18          	movzwl 0x18(%rsi),%edx
   128a2:	48 8b 76 10          	mov    0x10(%rsi),%rsi
   128a6:	48 8b 38             	mov    (%rax),%rdi
   128a9:	e8 a2 5c 00 00       	callq  18550 <bt_gatt_mult_notification>
}
   128ae:	31 c0                	xor    %eax,%eax
   128b0:	5a                   	pop    %rdx
   128b1:	c3                   	retq   

00000000000128b2 <att_notify>:
{
   128b2:	55                   	push   %rbp
   128b3:	53                   	push   %rbx
   128b4:	48 89 fd             	mov    %rdi,%rbp
	return net_buf_simple_pull_le16(&buf->b);
   128b7:	48 8d 7e 10          	lea    0x10(%rsi),%rdi
   128bb:	48 89 f3             	mov    %rsi,%rbx
   128be:	48 83 ec 08          	sub    $0x8,%rsp
   128c2:	e8 56 68 00 00       	callq  1911d <net_buf_simple_pull_le16>
	bt_gatt_notification(chan->att->conn, handle, buf->data, buf->len);
   128c7:	0f b7 f0             	movzwl %ax,%esi
   128ca:	48 8b 45 00          	mov    0x0(%rbp),%rax
   128ce:	0f b7 4b 18          	movzwl 0x18(%rbx),%ecx
   128d2:	48 8b 53 10          	mov    0x10(%rbx),%rdx
   128d6:	48 8b 38             	mov    (%rax),%rdi
   128d9:	e8 e0 5b 00 00       	callq  184be <bt_gatt_notification>
}
   128de:	5a                   	pop    %rdx
   128df:	31 c0                	xor    %eax,%eax
   128e1:	5b                   	pop    %rbx
   128e2:	5d                   	pop    %rbp
   128e3:	c3                   	retq   

00000000000128e4 <bt_gatt_foreach_attr>:
 *  @param user_data Data to pass to the callback.
 */
static inline void bt_gatt_foreach_attr(uint16_t start_handle, uint16_t end_handle,
					bt_gatt_attr_func_t func,
					void *user_data)
{
   128e4:	48 83 ec 10          	sub    $0x10,%rsp
   128e8:	49 89 d1             	mov    %rdx,%r9
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
   128eb:	0f b7 f6             	movzwl %si,%esi
   128ee:	51                   	push   %rcx
   128ef:	0f b7 ff             	movzwl %di,%edi
   128f2:	45 31 c0             	xor    %r8d,%r8d
   128f5:	31 c9                	xor    %ecx,%ecx
   128f7:	31 d2                	xor    %edx,%edx
   128f9:	e8 67 42 00 00       	callq  16b65 <bt_gatt_foreach_attr_type>
				  user_data);
}
   128fe:	48 83 c4 18          	add    $0x18,%rsp
   12902:	c3                   	retq   

0000000000012903 <find_info_cb>:
{
   12903:	41 55                	push   %r13
   12905:	41 54                	push   %r12
   12907:	41 89 f5             	mov    %esi,%r13d
   1290a:	55                   	push   %rbp
   1290b:	53                   	push   %rbx
   1290c:	48 89 fd             	mov    %rdi,%rbp
   1290f:	48 89 d3             	mov    %rdx,%rbx
   12912:	48 83 ec 08          	sub    $0x8,%rsp
	if (!data->rsp) {
   12916:	48 83 7a 10 00       	cmpq   $0x0,0x10(%rdx)
	struct bt_att_chan *chan = data->chan;
   1291b:	4c 8b 22             	mov    (%rdx),%r12
	if (!data->rsp) {
   1291e:	75 24                	jne    12944 <find_info_cb+0x41>
	return net_buf_simple_add(&buf->b, len);
   12920:	48 8b 42 08          	mov    0x8(%rdx),%rax
   12924:	be 01 00 00 00       	mov    $0x1,%esi
   12929:	48 8d 78 10          	lea    0x10(%rax),%rdi
   1292d:	e8 57 67 00 00       	callq  19089 <net_buf_simple_add>
		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
   12932:	48 8b 55 00          	mov    0x0(%rbp),%rdx
		data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   12936:	48 89 43 10          	mov    %rax,0x10(%rbx)
		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
   1293a:	80 3a 00             	cmpb   $0x0,(%rdx)
   1293d:	0f 95 c2             	setne  %dl
   12940:	ff c2                	inc    %edx
   12942:	88 10                	mov    %dl,(%rax)
	switch (data->rsp->format) {
   12944:	48 8b 43 10          	mov    0x10(%rbx),%rax
   12948:	8a 00                	mov    (%rax),%al
   1294a:	3c 01                	cmp    $0x1,%al
   1294c:	74 09                	je     12957 <find_info_cb+0x54>
   1294e:	3c 02                	cmp    $0x2,%al
   12950:	74 4f                	je     129a1 <find_info_cb+0x9e>
   12952:	e9 93 00 00 00       	jmpq   129ea <find_info_cb+0xe7>
		if (attr->uuid->type != BT_UUID_TYPE_16) {
   12957:	48 8b 55 00          	mov    0x0(%rbp),%rdx
			return BT_GATT_ITER_STOP;
   1295b:	31 c0                	xor    %eax,%eax
		if (attr->uuid->type != BT_UUID_TYPE_16) {
   1295d:	80 3a 00             	cmpb   $0x0,(%rdx)
   12960:	0f 85 86 00 00 00    	jne    129ec <find_info_cb+0xe9>
   12966:	48 8b 43 08          	mov    0x8(%rbx),%rax
   1296a:	be 04 00 00 00       	mov    $0x4,%esi
   1296f:	48 8d 78 10          	lea    0x10(%rax),%rdi
   12973:	e8 11 67 00 00       	callq  19089 <net_buf_simple_add>
		data->info16->uuid = sys_cpu_to_le16(BT_UUID_16(attr->uuid)->val);
   12978:	48 8b 55 00          	mov    0x0(%rbp),%rdx
		data->info16 = net_buf_add(data->buf, sizeof(*data->info16));
   1297c:	48 89 43 18          	mov    %rax,0x18(%rbx)
		data->info16->handle = sys_cpu_to_le16(handle);
   12980:	66 44 89 28          	mov    %r13w,(%rax)
		data->info16->uuid = sys_cpu_to_le16(BT_UUID_16(attr->uuid)->val);
   12984:	66 8b 52 02          	mov    0x2(%rdx),%dx
   12988:	66 89 50 02          	mov    %dx,0x2(%rax)
		if (chan->chan.tx.mtu - data->buf->len >
   1298c:	48 8b 53 08          	mov    0x8(%rbx),%rdx
   12990:	41 0f b7 44 24 7e    	movzwl 0x7e(%r12),%eax
   12996:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
   1299a:	29 d0                	sub    %edx,%eax
   1299c:	83 f8 04             	cmp    $0x4,%eax
   1299f:	eb 44                	jmp    129e5 <find_info_cb+0xe2>
		if (attr->uuid->type != BT_UUID_TYPE_128) {
   129a1:	48 8b 55 00          	mov    0x0(%rbp),%rdx
			return BT_GATT_ITER_STOP;
   129a5:	31 c0                	xor    %eax,%eax
		if (attr->uuid->type != BT_UUID_TYPE_128) {
   129a7:	80 3a 02             	cmpb   $0x2,(%rdx)
   129aa:	75 40                	jne    129ec <find_info_cb+0xe9>
   129ac:	48 8b 43 08          	mov    0x8(%rbx),%rax
   129b0:	be 12 00 00 00       	mov    $0x12,%esi
   129b5:	48 8d 78 10          	lea    0x10(%rax),%rdi
   129b9:	e8 cb 66 00 00       	callq  19089 <net_buf_simple_add>
   129be:	48 8b 55 00          	mov    0x0(%rbp),%rdx
		data->info128 = net_buf_add(data->buf, sizeof(*data->info128));
   129c2:	48 89 43 18          	mov    %rax,0x18(%rbx)
		data->info128->handle = sys_cpu_to_le16(handle);
   129c6:	66 44 89 28          	mov    %r13w,(%rax)
   129ca:	0f 10 42 01          	movups 0x1(%rdx),%xmm0
   129ce:	0f 11 40 02          	movups %xmm0,0x2(%rax)
		if (chan->chan.tx.mtu - data->buf->len >
   129d2:	48 8b 53 08          	mov    0x8(%rbx),%rdx
   129d6:	41 0f b7 44 24 7e    	movzwl 0x7e(%r12),%eax
   129dc:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
   129e0:	29 d0                	sub    %edx,%eax
   129e2:	83 f8 12             	cmp    $0x12,%eax
   129e5:	0f 97 c0             	seta   %al
   129e8:	eb 02                	jmp    129ec <find_info_cb+0xe9>
	return BT_GATT_ITER_STOP;
   129ea:	31 c0                	xor    %eax,%eax
}
   129ec:	5a                   	pop    %rdx
   129ed:	5b                   	pop    %rbx
   129ee:	5d                   	pop    %rbp
   129ef:	41 5c                	pop    %r12
   129f1:	41 5d                	pop    %r13
   129f3:	c3                   	retq   

00000000000129f4 <find_type_cb>:
{
   129f4:	41 57                	push   %r15
   129f6:	41 56                	push   %r14
   129f8:	41 55                	push   %r13
   129fa:	41 54                	push   %r12
   129fc:	49 89 fd             	mov    %rdi,%r13
   129ff:	55                   	push   %rbp
   12a00:	53                   	push   %rbx
   12a01:	41 89 f4             	mov    %esi,%r12d
   12a04:	48 89 d3             	mov    %rdx,%rbx
   12a07:	48 83 ec 68          	sub    $0x68,%rsp
	struct bt_att_chan *chan = data->chan;
   12a0b:	4c 8b 32             	mov    (%rdx),%r14
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   12a0e:	48 8b 3f             	mov    (%rdi),%rdi
{
   12a11:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   12a18:	00 00 
   12a1a:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
   12a1f:	31 c0                	xor    %eax,%eax
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   12a21:	48 8d 74 24 1e       	lea    0x1e(%rsp),%rsi
   12a26:	c6 44 24 1e 00       	movb   $0x0,0x1e(%rsp)
   12a2b:	66 c7 44 24 20 01 28 	movw   $0x2801,0x20(%rsp)
	struct bt_conn *conn = chan->chan.chan.conn;
   12a32:	49 8b 46 08          	mov    0x8(%r14),%rax
   12a36:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   12a3b:	e8 0d ab ff ff       	callq  d54d <bt_uuid_cmp>
   12a40:	85 c0                	test   %eax,%eax
   12a42:	0f 84 da 01 00 00    	je     12c22 <find_type_cb+0x22e>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY)) {
   12a48:	49 8b 7d 00          	mov    0x0(%r13),%rdi
   12a4c:	48 8d 74 24 22       	lea    0x22(%rsp),%rsi
   12a51:	c6 44 24 22 00       	movb   $0x0,0x22(%rsp)
   12a56:	66 c7 44 24 24 00 28 	movw   $0x2800,0x24(%rsp)
   12a5d:	e8 eb aa ff ff       	callq  d54d <bt_uuid_cmp>
   12a62:	85 c0                	test   %eax,%eax
   12a64:	74 24                	je     12a8a <find_type_cb+0x96>
		if (data->group &&
   12a66:	48 8b 53 10          	mov    0x10(%rbx),%rdx
		return BT_GATT_ITER_CONTINUE;
   12a6a:	b0 01                	mov    $0x1,%al
		if (data->group &&
   12a6c:	48 85 d2             	test   %rdx,%rdx
   12a6f:	0f 84 b7 01 00 00    	je     12c2c <find_type_cb+0x238>
   12a75:	66 44 39 62 02       	cmp    %r12w,0x2(%rdx)
   12a7a:	0f 83 ac 01 00 00    	jae    12c2c <find_type_cb+0x238>
			data->group->end_handle = sys_cpu_to_le16(handle);
   12a80:	66 44 89 62 02       	mov    %r12w,0x2(%rdx)
   12a85:	e9 a2 01 00 00       	jmpq   12c2c <find_type_cb+0x238>
	if (chan->chan.tx.mtu - net_buf_frags_len(data->buf) <
   12a8a:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
   12a8e:	48 89 cf             	mov    %rcx,%rdi
   12a91:	e8 48 fc ff ff       	callq  126de <net_buf_frags_len>
   12a96:	41 0f b7 56 7e       	movzwl 0x7e(%r14),%edx
   12a9b:	48 29 c2             	sub    %rax,%rdx
   12a9e:	48 83 fa 03          	cmp    $0x3,%rdx
   12aa2:	77 07                	ja     12aab <find_type_cb+0xb7>
		return BT_GATT_ITER_STOP;
   12aa4:	31 c0                	xor    %eax,%eax
   12aa6:	e9 81 01 00 00       	jmpq   12c2c <find_type_cb+0x238>
	frag = net_buf_frag_last(data->buf);
   12aab:	48 89 cf             	mov    %rcx,%rdi
   12aae:	e8 69 65 00 00       	callq  1901c <net_buf_frag_last>
	len = MIN(chan->chan.tx.mtu - net_buf_frags_len(data->buf),
   12ab3:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
	frag = net_buf_frag_last(data->buf);
   12ab7:	48 89 c5             	mov    %rax,%rbp
	return net_buf_simple_tailroom(&buf->b);
   12aba:	4c 8d 7d 10          	lea    0x10(%rbp),%r15
	len = MIN(chan->chan.tx.mtu - net_buf_frags_len(data->buf),
   12abe:	e8 1b fc ff ff       	callq  126de <net_buf_frags_len>
   12ac3:	41 0f b7 56 7e       	movzwl 0x7e(%r14),%edx
   12ac8:	4c 89 ff             	mov    %r15,%rdi
   12acb:	48 29 c2             	sub    %rax,%rdx
   12ace:	48 89 14 24          	mov    %rdx,(%rsp)
   12ad2:	e8 63 66 00 00       	callq  1913a <net_buf_simple_tailroom>
   12ad7:	48 39 04 24          	cmp    %rax,(%rsp)
   12adb:	73 16                	jae    12af3 <find_type_cb+0xff>
   12add:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
   12ae1:	e8 f8 fb ff ff       	callq  126de <net_buf_frags_len>
   12ae6:	41 0f b7 56 7e       	movzwl 0x7e(%r14),%edx
   12aeb:	48 29 c2             	sub    %rax,%rdx
   12aee:	48 89 d0             	mov    %rdx,%rax
   12af1:	eb 08                	jmp    12afb <find_type_cb+0x107>
   12af3:	4c 89 ff             	mov    %r15,%rdi
   12af6:	e8 3f 66 00 00       	callq  1913a <net_buf_simple_tailroom>
	if (!len) {
   12afb:	48 85 c0             	test   %rax,%rax
   12afe:	75 2b                	jne    12b2b <find_type_cb+0x137>
		frag = net_buf_alloc(net_buf_pool_get(data->buf->pool_id),
   12b00:	48 8b 43 08          	mov    0x8(%rbx),%rax
   12b04:	0f b6 78 0a          	movzbl 0xa(%rax),%edi
   12b08:	e8 ec 61 00 00       	callq  18cf9 <net_buf_pool_get>
	return net_buf_alloc_fixed(pool, timeout);
   12b0d:	31 f6                	xor    %esi,%esi
   12b0f:	48 89 c7             	mov    %rax,%rdi
   12b12:	e8 fd 63 00 00       	callq  18f14 <net_buf_alloc_fixed>
		if (!frag) {
   12b17:	48 85 c0             	test   %rax,%rax
   12b1a:	48 89 c5             	mov    %rax,%rbp
   12b1d:	74 85                	je     12aa4 <find_type_cb+0xb0>
		net_buf_frag_add(data->buf, frag);
   12b1f:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
   12b23:	48 89 c6             	mov    %rax,%rsi
   12b26:	e8 29 65 00 00       	callq  19054 <net_buf_frag_add>
	read = attr->read(conn, attr, uuid, sizeof(uuid), 0);
   12b2b:	4c 8d 74 24 48       	lea    0x48(%rsp),%r14
   12b30:	45 31 c0             	xor    %r8d,%r8d
   12b33:	4c 89 ee             	mov    %r13,%rsi
   12b36:	b9 10 00 00 00       	mov    $0x10,%ecx
   12b3b:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   12b40:	4c 89 f2             	mov    %r14,%rdx
   12b43:	41 ff 55 08          	callq  *0x8(%r13)
	if (read < 0) {
   12b47:	85 c0                	test   %eax,%eax
	read = attr->read(conn, attr, uuid, sizeof(uuid), 0);
   12b49:	49 89 c5             	mov    %rax,%r13
	if (read < 0) {
   12b4c:	0f 88 d0 00 00 00    	js     12c22 <find_type_cb+0x22e>
	if (read != data->value_len) {
   12b52:	0f b6 53 20          	movzbl 0x20(%rbx),%edx
   12b56:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
   12b5a:	44 39 ea             	cmp    %r13d,%edx
   12b5d:	0f 84 8f 00 00 00    	je     12bf2 <find_type_cb+0x1fe>
		if (!bt_uuid_create(&recvd_uuid.uuid, data->value, data->value_len)) {
   12b63:	4c 8d 7c 24 37       	lea    0x37(%rsp),%r15
   12b68:	48 89 fe             	mov    %rdi,%rsi
   12b6b:	4c 89 ff             	mov    %r15,%rdi
   12b6e:	e8 70 aa ff ff       	callq  d5e3 <bt_uuid_create>
   12b73:	84 c0                	test   %al,%al
   12b75:	75 25                	jne    12b9c <find_type_cb+0x1a8>
   12b77:	48 8d 15 f2 77 22 00 	lea    0x2277f2(%rip),%rdx        # 23a370 <log_const_bt_att>
   12b7e:	48 2b 15 cb 33 22 00 	sub    0x2233cb(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_WARN("Unable to create UUID: size %u", data->value_len);
   12b85:	48 8d 3d 73 01 02 00 	lea    0x20173(%rip),%rdi        # 32cff <__func__.5785+0x2097>
   12b8c:	0f b6 73 20          	movzbl 0x20(%rbx),%esi
   12b90:	48 c1 ea 04          	shr    $0x4,%rdx
   12b94:	c1 e2 06             	shl    $0x6,%edx
   12b97:	83 ca 02             	or     $0x2,%edx
   12b9a:	eb 42                	jmp    12bde <find_type_cb+0x1ea>
		if (!bt_uuid_create(&ref_uuid.uuid, uuid, read)) {
   12b9c:	48 8d 4c 24 26       	lea    0x26(%rsp),%rcx
   12ba1:	41 0f b6 d5          	movzbl %r13b,%edx
   12ba5:	4c 89 f6             	mov    %r14,%rsi
   12ba8:	48 89 cf             	mov    %rcx,%rdi
   12bab:	48 89 0c 24          	mov    %rcx,(%rsp)
   12baf:	e8 2f aa ff ff       	callq  d5e3 <bt_uuid_create>
   12bb4:	84 c0                	test   %al,%al
   12bb6:	48 8b 0c 24          	mov    (%rsp),%rcx
   12bba:	75 29                	jne    12be5 <find_type_cb+0x1f1>
   12bbc:	48 8d 15 ad 77 22 00 	lea    0x2277ad(%rip),%rdx        # 23a370 <log_const_bt_att>
   12bc3:	48 2b 15 86 33 22 00 	sub    0x223386(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_WARN("Unable to create UUID: size %d", read);
   12bca:	48 8d 3d 4d 01 02 00 	lea    0x2014d(%rip),%rdi        # 32d1e <__func__.5785+0x20b6>
   12bd1:	49 63 f5             	movslq %r13d,%rsi
   12bd4:	48 c1 ea 04          	shr    $0x4,%rdx
   12bd8:	c1 e2 06             	shl    $0x6,%edx
   12bdb:	83 ca 02             	or     $0x2,%edx
   12bde:	e8 12 47 ff ff       	callq  72f5 <log_1>
   12be3:	eb 3d                	jmp    12c22 <find_type_cb+0x22e>
		if (bt_uuid_cmp(&recvd_uuid.uuid, &ref_uuid.uuid)) {
   12be5:	48 89 ce             	mov    %rcx,%rsi
   12be8:	4c 89 ff             	mov    %r15,%rdi
   12beb:	e8 5d a9 ff ff       	callq  d54d <bt_uuid_cmp>
   12bf0:	eb 0b                	jmp    12bfd <find_type_cb+0x209>
	} else if (memcmp(data->value, uuid, read)) {
   12bf2:	0f b6 d2             	movzbl %dl,%edx
   12bf5:	4c 89 f6             	mov    %r14,%rsi
   12bf8:	e8 43 18 ff ff       	callq  4440 <memcmp@plt>
   12bfd:	85 c0                	test   %eax,%eax
   12bff:	75 21                	jne    12c22 <find_type_cb+0x22e>
	return net_buf_simple_add(&buf->b, len);
   12c01:	48 8d 7d 10          	lea    0x10(%rbp),%rdi
	data->err = 0x00;
   12c05:	c6 43 21 00          	movb   $0x0,0x21(%rbx)
   12c09:	be 04 00 00 00       	mov    $0x4,%esi
   12c0e:	e8 76 64 00 00       	callq  19089 <net_buf_simple_add>
	data->group = net_buf_add(frag, sizeof(*data->group));
   12c13:	48 89 43 10          	mov    %rax,0x10(%rbx)
	data->group->start_handle = sys_cpu_to_le16(handle);
   12c17:	66 44 89 20          	mov    %r12w,(%rax)
	data->group->end_handle = sys_cpu_to_le16(handle);
   12c1b:	66 44 89 60 02       	mov    %r12w,0x2(%rax)
   12c20:	eb 08                	jmp    12c2a <find_type_cb+0x236>
	data->group = NULL;
   12c22:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
   12c29:	00 
	return BT_GATT_ITER_CONTINUE;
   12c2a:	b0 01                	mov    $0x1,%al
}
   12c2c:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
   12c31:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   12c38:	00 00 
   12c3a:	74 05                	je     12c41 <find_type_cb+0x24d>
   12c3c:	e8 ff 19 ff ff       	callq  4640 <__stack_chk_fail@plt>
   12c41:	48 83 c4 68          	add    $0x68,%rsp
   12c45:	5b                   	pop    %rbx
   12c46:	5d                   	pop    %rbp
   12c47:	41 5c                	pop    %r12
   12c49:	41 5d                	pop    %r13
   12c4b:	41 5e                	pop    %r14
   12c4d:	41 5f                	pop    %r15
   12c4f:	c3                   	retq   

0000000000012c50 <attr_read_group_cb>:
	if (!data->rsp->len) {
   12c50:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
   12c54:	8a 01                	mov    (%rcx),%al
   12c56:	84 c0                	test   %al,%al
   12c58:	75 09                	jne    12c63 <attr_read_group_cb+0x13>
		data->rsp->len = read + sizeof(*data->group);
   12c5a:	83 c6 04             	add    $0x4,%esi
	return true;
   12c5d:	b0 01                	mov    $0x1,%al
		data->rsp->len = read + sizeof(*data->group);
   12c5f:	40 88 31             	mov    %sil,(%rcx)
   12c62:	c3                   	retq   
	} else if (data->rsp->len != read + sizeof(*data->group)) {
   12c63:	0f b6 c8             	movzbl %al,%ecx
   12c66:	48 83 c6 04          	add    $0x4,%rsi
	return true;
   12c6a:	b0 01                	mov    $0x1,%al
	} else if (data->rsp->len != read + sizeof(*data->group)) {
   12c6c:	48 39 f1             	cmp    %rsi,%rcx
   12c6f:	74 13                	je     12c84 <attr_read_group_cb+0x34>
		data->buf->len -= sizeof(*data->group);
   12c71:	48 8b 42 10          	mov    0x10(%rdx),%rax
   12c75:	66 83 68 18 04       	subw   $0x4,0x18(%rax)
		data->group = NULL;
   12c7a:	48 c7 42 20 00 00 00 	movq   $0x0,0x20(%rdx)
   12c81:	00 
   12c82:	31 c0                	xor    %eax,%eax
}
   12c84:	c3                   	retq   

0000000000012c85 <chan_send>:
{
   12c85:	41 57                	push   %r15
   12c87:	41 56                	push   %r14
   12c89:	49 89 fe             	mov    %rdi,%r14
   12c8c:	41 55                	push   %r13
   12c8e:	41 54                	push   %r12
   12c90:	55                   	push   %rbp
   12c91:	53                   	push   %rbx
   12c92:	48 89 d5             	mov    %rdx,%rbp
   12c95:	48 89 f3             	mov    %rsi,%rbx
   12c98:	48 83 ec 18          	sub    $0x18,%rsp
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
   12c9c:	48 8b 46 10          	mov    0x10(%rsi),%rax
   12ca0:	80 38 d2             	cmpb   $0xd2,(%rax)
   12ca3:	75 3c                	jne    12ce1 <chan_send+0x5c>
		err = bt_smp_sign(chan->att->conn, buf);
   12ca5:	48 8b 07             	mov    (%rdi),%rax
   12ca8:	48 8b 38             	mov    (%rax),%rdi
   12cab:	e8 3f 60 00 00       	callq  18cef <bt_smp_sign>
		if (err) {
   12cb0:	85 c0                	test   %eax,%eax
   12cb2:	74 2d                	je     12ce1 <chan_send+0x5c>
   12cb4:	48 8d 35 b5 76 22 00 	lea    0x2276b5(%rip),%rsi        # 23a370 <log_const_bt_att>
   12cbb:	48 2b 35 8e 32 22 00 	sub    0x22328e(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Error signing data");
   12cc2:	48 8d 3d 74 00 02 00 	lea    0x20074(%rip),%rdi        # 32d3d <__func__.5785+0x20d5>
   12cc9:	89 44 24 08          	mov    %eax,0x8(%rsp)
   12ccd:	48 c1 ee 04          	shr    $0x4,%rsi
   12cd1:	c1 e6 06             	shl    $0x6,%esi
   12cd4:	83 ce 01             	or     $0x1,%esi
   12cd7:	e8 e8 45 ff ff       	callq  72c4 <log_0>
   12cdc:	e9 c3 00 00 00       	jmpq   12da4 <chan_send+0x11f>
	net_buf_simple_save(&buf->b, &state);
   12ce1:	48 8d 7b 10          	lea    0x10(%rbx),%rdi
	state->offset = net_buf_simple_headroom(buf);
   12ce5:	e8 48 64 00 00       	callq  19132 <net_buf_simple_headroom>
	chan->sent = cb ? cb : chan_cb(buf);
   12cea:	48 85 ed             	test   %rbp,%rbp
   12ced:	49 89 c4             	mov    %rax,%r12
	state->len = buf->len;
   12cf0:	44 8b 6b 18          	mov    0x18(%rbx),%r13d
   12cf4:	48 8d 15 78 03 00 00 	lea    0x378(%rip),%rdx        # 13073 <chan_rsp_sent>
   12cfb:	75 33                	jne    12d30 <chan_send+0xab>
	switch (att_op_get_type(buf->data[0])) {
   12cfd:	48 8b 43 10          	mov    0x10(%rbx),%rax
   12d01:	0f b6 38             	movzbl (%rax),%edi
   12d04:	e8 67 fa ff ff       	callq  12770 <att_op_get_type>
   12d09:	3c 02                	cmp    $0x2,%al
   12d0b:	74 17                	je     12d24 <chan_send+0x9f>
   12d0d:	77 04                	ja     12d13 <chan_send+0x8e>
   12d0f:	fe c8                	dec    %al
   12d11:	eb 06                	jmp    12d19 <chan_send+0x94>
   12d13:	3c 04                	cmp    $0x4,%al
   12d15:	74 12                	je     12d29 <chan_send+0xa4>
   12d17:	3c 05                	cmp    $0x5,%al
   12d19:	75 15                	jne    12d30 <chan_send+0xab>
		return chan_req_sent;
   12d1b:	48 8d 2d ce 01 00 00 	lea    0x1ce(%rip),%rbp        # 12ef0 <chan_req_sent>
   12d22:	eb 0c                	jmp    12d30 <chan_send+0xab>
		return chan_rsp_sent;
   12d24:	48 89 d5             	mov    %rdx,%rbp
   12d27:	eb 07                	jmp    12d30 <chan_send+0xab>
		return chan_cfm_sent;
   12d29:	48 8d 2d d5 f9 ff ff 	lea    -0x62b(%rip),%rbp        # 12705 <chan_cfm_sent>
	if (cb == chan_rsp_sent) {
   12d30:	48 39 d5             	cmp    %rdx,%rbp
	chan->sent = cb ? cb : chan_cb(buf);
   12d33:	49 89 ae d8 01 00 00 	mov    %rbp,0x1d8(%r14)
				&chan->chan.chan);
   12d3a:	4d 8d 46 08          	lea    0x8(%r14),%r8
		return att_rsp_sent;
   12d3e:	4c 8d 3d d4 f9 ff ff 	lea    -0x62c(%rip),%r15        # 12719 <att_rsp_sent>
	if (cb == chan_rsp_sent) {
   12d45:	74 2d                	je     12d74 <chan_send+0xef>
	} else if (cb == chan_cfm_sent) {
   12d47:	48 8d 05 b7 f9 ff ff 	lea    -0x649(%rip),%rax        # 12705 <chan_cfm_sent>
		return att_cfm_sent;
   12d4e:	4c 8d 3d b1 f9 ff ff 	lea    -0x64f(%rip),%r15        # 12706 <att_cfm_sent>
	} else if (cb == chan_cfm_sent) {
   12d55:	48 39 c5             	cmp    %rax,%rbp
   12d58:	74 1a                	je     12d74 <chan_send+0xef>
	} else if (cb == chan_req_sent) {
   12d5a:	48 8d 05 8f 01 00 00 	lea    0x18f(%rip),%rax        # 12ef0 <chan_req_sent>
		return att_req_sent;
   12d61:	4c 8d 3d c4 f9 ff ff 	lea    -0x63c(%rip),%r15        # 1272c <att_req_sent>
	} else if (cb == chan_req_sent) {
   12d68:	48 39 c5             	cmp    %rax,%rbp
   12d6b:	74 07                	je     12d74 <chan_send+0xef>
		return att_sent;
   12d6d:	4c 8d 3d 7e f9 ff ff 	lea    -0x682(%rip),%r15        # 126f2 <att_sent>
	err = bt_l2cap_send_cb(chan->att->conn, BT_L2CAP_CID_ATT,
   12d74:	48 89 df             	mov    %rbx,%rdi
   12d77:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
   12d7c:	e8 94 62 00 00       	callq  19015 <net_buf_ref>
   12d81:	49 8b 3e             	mov    (%r14),%rdi
   12d84:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
   12d89:	4c 89 f9             	mov    %r15,%rcx
   12d8c:	48 89 c2             	mov    %rax,%rdx
   12d8f:	be 04 00 00 00       	mov    $0x4,%esi
   12d94:	48 8b 3f             	mov    (%rdi),%rdi
   12d97:	e8 af f5 ff ff       	callq  1234b <bt_l2cap_send_cb>
	if (!err) {
   12d9c:	85 c0                	test   %eax,%eax
   12d9e:	75 12                	jne    12db2 <chan_send+0x12d>
   12da0:	89 44 24 08          	mov    %eax,0x8(%rsp)
		net_buf_unref(buf);
   12da4:	48 89 df             	mov    %rbx,%rdi
   12da7:	e8 ee 61 00 00       	callq  18f9a <net_buf_unref>
		return 0;
   12dac:	8b 44 24 08          	mov    0x8(%rsp),%eax
   12db0:	eb 11                	jmp    12dc3 <chan_send+0x13e>
	buf->data = buf->__buf + state->offset;
   12db2:	45 0f b7 e4          	movzwl %r12w,%r12d
   12db6:	4c 03 63 20          	add    0x20(%rbx),%r12
	buf->len = state->len;
   12dba:	66 44 89 6b 18       	mov    %r13w,0x18(%rbx)
	buf->data = buf->__buf + state->offset;
   12dbf:	4c 89 63 10          	mov    %r12,0x10(%rbx)
}
   12dc3:	48 83 c4 18          	add    $0x18,%rsp
   12dc7:	5b                   	pop    %rbx
   12dc8:	5d                   	pop    %rbp
   12dc9:	41 5c                	pop    %r12
   12dcb:	41 5d                	pop    %r13
   12dcd:	41 5e                	pop    %r14
   12dcf:	41 5f                	pop    %r15
   12dd1:	c3                   	retq   

0000000000012dd2 <bt_att_chan_send_rsp>:
{
   12dd2:	55                   	push   %rbp
   12dd3:	53                   	push   %rbx
   12dd4:	48 89 f5             	mov    %rsi,%rbp
   12dd7:	48 89 fb             	mov    %rdi,%rbx
   12dda:	48 83 ec 08          	sub    $0x8,%rsp
	return chan_send(chan, buf, cb);
   12dde:	e8 a2 fe ff ff       	callq  12c85 <chan_send>
	if (err) {
   12de3:	85 c0                	test   %eax,%eax
   12de5:	74 12                	je     12df9 <bt_att_chan_send_rsp+0x27>
}
   12de7:	5a                   	pop    %rdx
		net_buf_put(&chan->tx_queue, buf);
   12de8:	48 8d bb 40 01 00 00 	lea    0x140(%rbx),%rdi
   12def:	48 89 ee             	mov    %rbp,%rsi
}
   12df2:	5b                   	pop    %rbx
   12df3:	5d                   	pop    %rbp
		net_buf_put(&chan->tx_queue, buf);
   12df4:	e9 88 61 00 00       	jmpq   18f81 <net_buf_put>
}
   12df9:	58                   	pop    %rax
   12dfa:	5b                   	pop    %rbx
   12dfb:	5d                   	pop    %rbp
   12dfc:	c3                   	retq   

0000000000012dfd <process_queue>:
{
   12dfd:	41 54                	push   %r12
   12dff:	55                   	push   %rbp
   12e00:	48 89 f5             	mov    %rsi,%rbp
   12e03:	53                   	push   %rbx
	buf = net_buf_get(queue, K_NO_WAIT);
   12e04:	31 f6                	xor    %esi,%esi
{
   12e06:	49 89 fc             	mov    %rdi,%r12
	buf = net_buf_get(queue, K_NO_WAIT);
   12e09:	48 89 ef             	mov    %rbp,%rdi
{
   12e0c:	48 83 ec 10          	sub    $0x10,%rsp
	buf = net_buf_get(queue, K_NO_WAIT);
   12e10:	e8 12 61 00 00       	callq  18f27 <net_buf_get>
   12e15:	48 89 c3             	mov    %rax,%rbx
	return -ENOENT;
   12e18:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (buf) {
   12e1d:	48 85 db             	test   %rbx,%rbx
   12e20:	74 24                	je     12e46 <process_queue+0x49>
		err = chan_send(chan, buf, NULL);
   12e22:	31 d2                	xor    %edx,%edx
   12e24:	48 89 de             	mov    %rbx,%rsi
   12e27:	4c 89 e7             	mov    %r12,%rdi
   12e2a:	e8 56 fe ff ff       	callq  12c85 <chan_send>
		if (err) {
   12e2f:	85 c0                	test   %eax,%eax
   12e31:	74 13                	je     12e46 <process_queue+0x49>
			k_queue_prepend(&queue->_queue, buf);
   12e33:	48 89 de             	mov    %rbx,%rsi
   12e36:	48 89 ef             	mov    %rbp,%rdi
   12e39:	89 44 24 0c          	mov    %eax,0xc(%rsp)
   12e3d:	e8 fb 84 01 00       	callq  2b33d <k_queue_prepend>
   12e42:	8b 44 24 0c          	mov    0xc(%rsp),%eax
}
   12e46:	48 83 c4 10          	add    $0x10,%rsp
   12e4a:	5b                   	pop    %rbx
   12e4b:	5d                   	pop    %rbp
   12e4c:	41 5c                	pop    %r12
   12e4e:	c3                   	retq   

0000000000012e4f <att_get>:
{
   12e4f:	48 83 ec 08          	sub    $0x8,%rsp
	if (conn->state != BT_CONN_CONNECTED) {
   12e53:	80 7f 0a 07          	cmpb   $0x7,0xa(%rdi)
   12e57:	74 21                	je     12e7a <att_get+0x2b>
   12e59:	48 8d 35 10 75 22 00 	lea    0x227510(%rip),%rsi        # 23a370 <log_const_bt_att>
   12e60:	48 2b 35 e9 30 22 00 	sub    0x2230e9(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("Not connected");
   12e67:	48 8d 3d e2 fe 01 00 	lea    0x1fee2(%rip),%rdi        # 32d50 <__func__.5785+0x20e8>
   12e6e:	48 c1 ee 04          	shr    $0x4,%rsi
   12e72:	c1 e6 06             	shl    $0x6,%esi
   12e75:	83 ce 02             	or     $0x2,%esi
   12e78:	eb 67                	jmp    12ee1 <att_get+0x92>
	chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_ATT);
   12e7a:	be 04 00 00 00       	mov    $0x4,%esi
   12e7f:	e8 a7 f6 ff ff       	callq  1252b <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
   12e84:	48 85 c0             	test   %rax,%rax
	chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_ATT);
   12e87:	48 89 c2             	mov    %rax,%rdx
	if (!chan) {
   12e8a:	75 21                	jne    12ead <att_get+0x5e>
   12e8c:	48 8d 35 dd 74 22 00 	lea    0x2274dd(%rip),%rsi        # 23a370 <log_const_bt_att>
   12e93:	48 2b 35 b6 30 22 00 	sub    0x2230b6(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unable to find ATT channel");
   12e9a:	48 8d 3d bd fe 01 00 	lea    0x1febd(%rip),%rdi        # 32d5e <__func__.5785+0x20f6>
   12ea1:	48 c1 ee 04          	shr    $0x4,%rsi
   12ea5:	c1 e6 06             	shl    $0x6,%esi
   12ea8:	83 ce 01             	or     $0x1,%esi
   12eab:	eb 34                	jmp    12ee1 <att_get+0x92>
	if (atomic_test_bit(att_chan->flags, ATT_DISCONNECTED)) {
   12ead:	48 8d b8 28 01 00 00 	lea    0x128(%rax),%rdi
   12eb4:	be 02 00 00 00       	mov    $0x2,%esi
   12eb9:	e8 89 f9 ff ff       	callq  12847 <atomic_test_bit>
   12ebe:	84 c0                	test   %al,%al
   12ec0:	74 28                	je     12eea <att_get+0x9b>
   12ec2:	48 8d 35 a7 74 22 00 	lea    0x2274a7(%rip),%rsi        # 23a370 <log_const_bt_att>
   12ec9:	48 2b 35 80 30 22 00 	sub    0x223080(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("ATT channel flagged as disconnected");
   12ed0:	48 8d 3d a2 fe 01 00 	lea    0x1fea2(%rip),%rdi        # 32d79 <__func__.5785+0x2111>
   12ed7:	48 c1 ee 04          	shr    $0x4,%rsi
   12edb:	c1 e6 06             	shl    $0x6,%esi
   12ede:	83 ce 02             	or     $0x2,%esi
   12ee1:	e8 de 43 ff ff       	callq  72c4 <log_0>
		return NULL;
   12ee6:	31 c0                	xor    %eax,%eax
   12ee8:	eb 04                	jmp    12eee <att_get+0x9f>
	return att_chan->att;
   12eea:	48 8b 42 f8          	mov    -0x8(%rdx),%rax
}
   12eee:	5a                   	pop    %rdx
   12eef:	c3                   	retq   

0000000000012ef0 <chan_req_sent>:
	if (chan->req) {
   12ef0:	48 83 bf 38 01 00 00 	cmpq   $0x0,0x138(%rdi)
   12ef7:	00 
   12ef8:	74 18                	je     12f12 <chan_req_sent+0x22>
		k_delayed_work_submit(&chan->timeout_work, BT_ATT_TIMEOUT);
   12efa:	48 8d b7 70 01 00 00 	lea    0x170(%rdi),%rsi
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   12f01:	48 8d 3d 98 4c 24 00 	lea    0x244c98(%rip),%rdi        # 257ba0 <k_sys_work_q>
   12f08:	ba b8 0b 00 00       	mov    $0xbb8,%edx
   12f0d:	e9 65 94 01 00       	jmpq   2c377 <k_delayed_work_submit_to_queue>
}
   12f12:	c3                   	retq   

0000000000012f13 <bt_att_accept>:

	return chan;
}

static int bt_att_accept(struct bt_conn *conn, struct bt_l2cap_chan **ch)
{
   12f13:	41 54                	push   %r12
   12f15:	55                   	push   %rbp
   12f16:	48 89 fd             	mov    %rdi,%rbp
   12f19:	53                   	push   %rbx
   12f1a:	49 89 f4             	mov    %rsi,%r12
	struct bt_att *att;
	struct bt_att_chan *chan;

	BT_DBG("conn %p handle %u", conn, conn->handle);

	if (k_mem_slab_alloc(&att_slab, (void **)&att, K_NO_WAIT)) {
   12f1d:	31 d2                	xor    %edx,%edx
{
   12f1f:	48 83 ec 20          	sub    $0x20,%rsp
	if (k_mem_slab_alloc(&att_slab, (void **)&att, K_NO_WAIT)) {
   12f23:	48 8d 3d 46 76 22 00 	lea    0x227646(%rip),%rdi        # 23a570 <_k_timer_list_end>
   12f2a:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
{
   12f2f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   12f36:	00 00 
   12f38:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   12f3d:	31 c0                	xor    %eax,%eax
	if (k_mem_slab_alloc(&att_slab, (void **)&att, K_NO_WAIT)) {
   12f3f:	e8 d5 7d 01 00       	callq  2ad19 <k_mem_slab_alloc>
   12f44:	85 c0                	test   %eax,%eax
   12f46:	74 24                	je     12f6c <bt_att_accept+0x59>
   12f48:	48 8d 15 21 74 22 00 	lea    0x227421(%rip),%rdx        # 23a370 <log_const_bt_att>
   12f4f:	48 2b 15 fa 2f 22 00 	sub    0x222ffa(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("No available ATT context for conn %p", conn);
   12f56:	48 89 ee             	mov    %rbp,%rsi
   12f59:	48 8d 3d 3d fe 01 00 	lea    0x1fe3d(%rip),%rdi        # 32d9d <__func__.5785+0x2135>
   12f60:	48 c1 ea 04          	shr    $0x4,%rdx
   12f64:	c1 e2 06             	shl    $0x6,%edx
   12f67:	83 ca 01             	or     $0x1,%edx
   12f6a:	eb 7b                	jmp    12fe7 <bt_att_accept+0xd4>
   12f6c:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   12f71:	b9 22 00 00 00       	mov    $0x22,%ecx
	if (k_mem_slab_alloc(&chan_slab, (void **)&chan, K_NO_WAIT)) {
   12f76:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
   12f7b:	31 d2                	xor    %edx,%edx
   12f7d:	f3 ab                	rep stos %eax,%es:(%rdi)
   12f7f:	48 8d 3d 22 76 22 00 	lea    0x227622(%rip),%rdi        # 23a5a8 <chan_slab>
		return -ENOMEM;
	}

	(void)memset(att, 0, sizeof(*att));
	att->conn = conn;
   12f86:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
   12f8b:	48 89 2b             	mov    %rbp,(%rbx)
	list->head = NULL;
   12f8e:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
   12f95:	00 
	list->tail = NULL;
   12f96:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
   12f9d:	00 
	list->head = NULL;
   12f9e:	48 c7 43 78 00 00 00 	movq   $0x0,0x78(%rbx)
   12fa5:	00 
	list->tail = NULL;
   12fa6:	48 c7 83 80 00 00 00 	movq   $0x0,0x80(%rbx)
   12fad:	00 00 00 00 
	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
   12fb1:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
   12fb8:	00 00 
	if (k_mem_slab_alloc(&chan_slab, (void **)&chan, K_NO_WAIT)) {
   12fba:	e8 5a 7d 01 00       	callq  2ad19 <k_mem_slab_alloc>
   12fbf:	85 c0                	test   %eax,%eax
   12fc1:	89 c5                	mov    %eax,%ebp
   12fc3:	74 2e                	je     12ff3 <bt_att_accept+0xe0>
   12fc5:	48 8d 15 a4 73 22 00 	lea    0x2273a4(%rip),%rdx        # 23a370 <log_const_bt_att>
   12fcc:	48 2b 15 7d 2f 22 00 	sub    0x222f7d(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("No available ATT channel for conn %p", att->conn);
   12fd3:	48 8d 3d e8 fd 01 00 	lea    0x1fde8(%rip),%rdi        # 32dc2 <__func__.5785+0x215a>
   12fda:	48 8b 33             	mov    (%rbx),%rsi
   12fdd:	48 c1 ea 04          	shr    $0x4,%rdx
   12fe1:	c1 e2 06             	shl    $0x6,%edx
   12fe4:	83 ca 01             	or     $0x1,%edx
   12fe7:	e8 09 43 ff ff       	callq  72f5 <log_1>
	sys_slist_init(&att->reqs);
	sys_slist_init(&att->chans);

	chan = att_chan_new(att, 0);
	if (!chan) {
		return -ENOMEM;
   12fec:	bd f4 ff ff ff       	mov    $0xfffffff4,%ebp
   12ff1:	eb 60                	jmp    13053 <bt_att_accept+0x140>
   12ff3:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   12ff8:	b9 7a 00 00 00       	mov    $0x7a,%ecx
   12ffd:	f3 ab                	rep stos %eax,%es:(%rdi)
	chan->chan.chan.ops = &ops;
   12fff:	48 8d 05 3a 38 22 00 	lea    0x22383a(%rip),%rax        # 236840 <ops.10039>
   13006:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   1300b:	48 89 47 10          	mov    %rax,0x10(%rdi)
	k_fifo_init(&chan->tx_queue);
   1300f:	48 81 c7 40 01 00 00 	add    $0x140,%rdi
	z_impl_k_queue_init(queue);
   13016:	e8 e8 82 01 00       	callq  2b303 <z_impl_k_queue_init>
	k_sem_init(&chan->tx_sem, CONFIG_BT_ATT_TX_MAX, CONFIG_BT_ATT_TX_MAX);
   1301b:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
   13020:	48 8d b8 b0 01 00 00 	lea    0x1b0(%rax),%rdi
	return z_impl_k_sem_init(sem, initial_count, limit);
   13027:	ba 03 00 00 00       	mov    $0x3,%edx
   1302c:	be 03 00 00 00       	mov    $0x3,%esi
   13031:	e8 d6 8e 01 00       	callq  2bf0c <z_impl_k_sem_init>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   13036:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
   1303b:	31 c0                	xor    %eax,%eax
   1303d:	87 82 30 01 00 00    	xchg   %eax,0x130(%rdx)
	chan->att = att;
   13043:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
   13048:	48 89 18             	mov    %rbx,(%rax)
	}

	*ch = &chan->chan.chan;
   1304b:	48 83 c0 08          	add    $0x8,%rax
   1304f:	49 89 04 24          	mov    %rax,(%r12)

	return 0;
}
   13053:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   13058:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1305f:	00 00 
   13061:	89 e8                	mov    %ebp,%eax
   13063:	74 05                	je     1306a <bt_att_accept+0x157>
   13065:	e8 d6 15 ff ff       	callq  4640 <__stack_chk_fail@plt>
   1306a:	48 83 c4 20          	add    $0x20,%rsp
   1306e:	5b                   	pop    %rbx
   1306f:	5d                   	pop    %rbp
   13070:	41 5c                	pop    %r12
   13072:	c3                   	retq   

0000000000013073 <chan_rsp_sent>:
   13073:	c3                   	retq   

0000000000013074 <bt_att_connected>:
{
   13074:	55                   	push   %rbp
   13075:	53                   	push   %rbx
   13076:	48 89 fb             	mov    %rdi,%rbx
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   13079:	be 04 00 00 00       	mov    $0x4,%esi
{
   1307e:	48 83 ec 08          	sub    $0x8,%rsp
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   13082:	48 8b 3f             	mov    (%rdi),%rdi
   13085:	e8 71 f4 ff ff       	callq  124fb <bt_l2cap_le_lookup_tx_cid>
	struct bt_att *att = att_chan->att;
   1308a:	48 8b 68 f8          	mov    -0x8(%rax),%rbp
	if (sys_slist_is_empty(&att->chans)) {
   1308e:	48 83 7d 78 00       	cmpq   $0x0,0x78(%rbp)
   13093:	75 12                	jne    130a7 <bt_att_connected+0x33>
		k_fifo_init(&att->tx_queue);
   13095:	48 8d 7d 18          	lea    0x18(%rbp),%rdi
	z_impl_k_queue_init(queue);
   13099:	e8 65 82 01 00       	callq  2b303 <z_impl_k_queue_init>
		k_fifo_init(&att->prep_queue);
   1309e:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
   130a2:	e8 5c 82 01 00       	callq  2b303 <z_impl_k_queue_init>
Z_GENLIST_PREPEND(slist, snode)
   130a7:	48 8b 55 78          	mov    0x78(%rbp),%rdx
	sys_slist_prepend(&att->chans, &chan->node);
   130ab:	48 8d 83 d8 01 00 00 	lea    0x1d8(%rbx),%rax
	parent->next = child;
   130b2:	48 89 93 d8 01 00 00 	mov    %rdx,0x1d8(%rbx)
Z_GENLIST_PREPEND(slist, snode)
   130b9:	48 83 bd 80 00 00 00 	cmpq   $0x0,0x80(%rbp)
   130c0:	00 
	list->head = node;
   130c1:	48 89 45 78          	mov    %rax,0x78(%rbp)
Z_GENLIST_PREPEND(slist, snode)
   130c5:	75 07                	jne    130ce <bt_att_connected+0x5a>
	list->tail = node;
   130c7:	48 89 85 80 00 00 00 	mov    %rax,0x80(%rbp)
	if (!atomic_test_bit(att_chan->flags, ATT_ENHANCED)) {
   130ce:	48 8d bb 28 01 00 00 	lea    0x128(%rbx),%rdi
   130d5:	be 03 00 00 00       	mov    $0x3,%esi
   130da:	e8 68 f7 ff ff       	callq  12847 <atomic_test_bit>
   130df:	84 c0                	test   %al,%al
   130e1:	75 0c                	jne    130ef <bt_att_connected+0x7b>
		ch->tx.mtu = BT_ATT_DEFAULT_LE_MTU;
   130e3:	66 c7 43 76 17 00    	movw   $0x17,0x76(%rbx)
		ch->rx.mtu = BT_ATT_DEFAULT_LE_MTU;
   130e9:	66 c7 43 6a 17 00    	movw   $0x17,0x6a(%rbx)
	*work = (struct k_delayed_work)Z_DELAYED_WORK_INITIALIZER(handler);
   130ef:	48 8d bb 68 01 00 00 	lea    0x168(%rbx),%rdi
   130f6:	31 c0                	xor    %eax,%eax
   130f8:	b9 10 00 00 00       	mov    $0x10,%ecx
   130fd:	f3 ab                	rep stos %eax,%es:(%rdi)
   130ff:	48 8d 05 a5 1b 00 00 	lea    0x1ba5(%rip),%rax        # 14cab <att_timeout>
   13106:	48 89 83 70 01 00 00 	mov    %rax,0x170(%rbx)
}
   1310d:	58                   	pop    %rax
   1310e:	5b                   	pop    %rbx
   1310f:	5d                   	pop    %rbp
   13110:	c3                   	retq   

0000000000013111 <att_chan_read>:
{
   13111:	41 57                	push   %r15
   13113:	41 56                	push   %r14
		return 0;
   13115:	45 31 ff             	xor    %r15d,%r15d
{
   13118:	41 55                	push   %r13
   1311a:	41 54                	push   %r12
   1311c:	49 89 fd             	mov    %rdi,%r13
   1311f:	55                   	push   %rbp
   13120:	53                   	push   %rbx
	if (chan->chan.tx.mtu <= net_buf_frags_len(buf)) {
   13121:	48 89 d7             	mov    %rdx,%rdi
{
   13124:	49 89 d4             	mov    %rdx,%r12
   13127:	48 83 ec 38          	sub    $0x38,%rsp
   1312b:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
   13130:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
   13135:	4c 89 4c 24 28       	mov    %r9,0x28(%rsp)
   1313a:	66 89 4c 24 16       	mov    %cx,0x16(%rsp)
	if (chan->chan.tx.mtu <= net_buf_frags_len(buf)) {
   1313f:	e8 9a f5 ff ff       	callq  126de <net_buf_frags_len>
   13144:	41 0f b7 55 7e       	movzwl 0x7e(%r13),%edx
   13149:	48 39 c2             	cmp    %rax,%rdx
   1314c:	0f 86 46 01 00 00    	jbe    13298 <att_chan_read+0x187>
	struct bt_conn *conn = chan->chan.chan.conn;
   13152:	49 8b 45 08          	mov    0x8(%r13),%rax
	frag = net_buf_frag_last(buf);
   13156:	4c 89 e7             	mov    %r12,%rdi
	size_t len, total = 0;
   13159:	45 31 f6             	xor    %r14d,%r14d
	struct bt_conn *conn = chan->chan.chan.conn;
   1315c:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
	frag = net_buf_frag_last(buf);
   13161:	e8 b6 5e 00 00       	callq  1901c <net_buf_frag_last>
   13166:	48 89 c5             	mov    %rax,%rbp
		len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
   13169:	4c 89 e7             	mov    %r12,%rdi
	return net_buf_simple_tailroom(&buf->b);
   1316c:	4c 8d 7d 10          	lea    0x10(%rbp),%r15
   13170:	e8 69 f5 ff ff       	callq  126de <net_buf_frags_len>
   13175:	41 0f b7 5d 7e       	movzwl 0x7e(%r13),%ebx
   1317a:	4c 89 ff             	mov    %r15,%rdi
   1317d:	48 29 c3             	sub    %rax,%rbx
   13180:	e8 b5 5f 00 00       	callq  1913a <net_buf_simple_tailroom>
   13185:	48 39 c3             	cmp    %rax,%rbx
   13188:	73 12                	jae    1319c <att_chan_read+0x8b>
   1318a:	4c 89 e7             	mov    %r12,%rdi
   1318d:	e8 4c f5 ff ff       	callq  126de <net_buf_frags_len>
   13192:	41 0f b7 5d 7e       	movzwl 0x7e(%r13),%ebx
   13197:	48 29 c3             	sub    %rax,%rbx
   1319a:	eb 0b                	jmp    131a7 <att_chan_read+0x96>
   1319c:	4c 89 ff             	mov    %r15,%rdi
   1319f:	e8 96 5f 00 00       	callq  1913a <net_buf_simple_tailroom>
   131a4:	48 89 c3             	mov    %rax,%rbx
		if (!len) {
   131a7:	48 85 db             	test   %rbx,%rbx
   131aa:	75 6a                	jne    13216 <att_chan_read+0x105>
			frag = net_buf_alloc(net_buf_pool_get(buf->pool_id),
   131ac:	41 0f b6 7c 24 0a    	movzbl 0xa(%r12),%edi
   131b2:	e8 42 5b 00 00       	callq  18cf9 <net_buf_pool_get>
	return net_buf_alloc_fixed(pool, timeout);
   131b7:	31 f6                	xor    %esi,%esi
   131b9:	48 89 c7             	mov    %rax,%rdi
   131bc:	e8 53 5d 00 00       	callq  18f14 <net_buf_alloc_fixed>
			if (!frag) {
   131c1:	48 85 c0             	test   %rax,%rax
   131c4:	48 89 c5             	mov    %rax,%rbp
   131c7:	0f 84 c8 00 00 00    	je     13295 <att_chan_read+0x184>
			net_buf_frag_add(buf, frag);
   131cd:	48 89 c6             	mov    %rax,%rsi
   131d0:	4c 89 e7             	mov    %r12,%rdi
	return net_buf_simple_tailroom(&buf->b);
   131d3:	4c 8d 7d 10          	lea    0x10(%rbp),%r15
   131d7:	e8 78 5e 00 00       	callq  19054 <net_buf_frag_add>
			len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
   131dc:	4c 89 e7             	mov    %r12,%rdi
   131df:	e8 fa f4 ff ff       	callq  126de <net_buf_frags_len>
   131e4:	41 0f b7 5d 7e       	movzwl 0x7e(%r13),%ebx
   131e9:	4c 89 ff             	mov    %r15,%rdi
   131ec:	48 29 c3             	sub    %rax,%rbx
   131ef:	e8 46 5f 00 00       	callq  1913a <net_buf_simple_tailroom>
   131f4:	48 39 c3             	cmp    %rax,%rbx
   131f7:	73 12                	jae    1320b <att_chan_read+0xfa>
   131f9:	4c 89 e7             	mov    %r12,%rdi
   131fc:	e8 dd f4 ff ff       	callq  126de <net_buf_frags_len>
   13201:	41 0f b7 5d 7e       	movzwl 0x7e(%r13),%ebx
   13206:	48 29 c3             	sub    %rax,%rbx
   13209:	eb 0b                	jmp    13216 <att_chan_read+0x105>
   1320b:	4c 89 ff             	mov    %r15,%rdi
   1320e:	e8 27 5f 00 00       	callq  1913a <net_buf_simple_tailroom>
   13213:	48 89 c3             	mov    %rax,%rbx
		read = attr->read(conn, attr, frag->data + frag->len, len,
   13216:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   1321b:	0f b7 55 18          	movzwl 0x18(%rbp),%edx
   1321f:	0f b7 cb             	movzwl %bx,%ecx
   13222:	48 03 55 10          	add    0x10(%rbp),%rdx
   13226:	44 0f b7 44 24 16    	movzwl 0x16(%rsp),%r8d
   1322c:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
   13231:	ff 56 08             	callq  *0x8(%rsi)
		if (read < 0) {
   13234:	48 85 c0             	test   %rax,%rax
		read = attr->read(conn, attr, frag->data + frag->len, len,
   13237:	49 89 c7             	mov    %rax,%r15
		if (read < 0) {
   1323a:	79 09                	jns    13245 <att_chan_read+0x134>
				return total;
   1323c:	4d 85 f6             	test   %r14,%r14
   1323f:	4d 0f 45 fe          	cmovne %r14,%r15
   13243:	eb 53                	jmp    13298 <att_chan_read+0x187>
		if (cb && !cb(frag, read, user_data)) {
   13245:	48 83 7c 24 18 00    	cmpq   $0x0,0x18(%rsp)
   1324b:	75 32                	jne    1327f <att_chan_read+0x16e>
	return net_buf_simple_add(&buf->b, len);
   1324d:	48 8d 7d 10          	lea    0x10(%rbp),%rdi
   13251:	4c 89 fe             	mov    %r15,%rsi
		total += read;
   13254:	4d 01 fe             	add    %r15,%r14
   13257:	e8 2d 5e 00 00       	callq  19089 <net_buf_simple_add>
	} while (chan->chan.tx.mtu > net_buf_frags_len(buf) && read == len);
   1325c:	4c 89 e7             	mov    %r12,%rdi
		offset += read;
   1325f:	66 44 01 7c 24 16    	add    %r15w,0x16(%rsp)
	} while (chan->chan.tx.mtu > net_buf_frags_len(buf) && read == len);
   13265:	e8 74 f4 ff ff       	callq  126de <net_buf_frags_len>
   1326a:	41 0f b7 55 7e       	movzwl 0x7e(%r13),%edx
   1326f:	48 39 c2             	cmp    %rax,%rdx
   13272:	76 21                	jbe    13295 <att_chan_read+0x184>
   13274:	49 39 df             	cmp    %rbx,%r15
   13277:	0f 84 ec fe ff ff    	je     13169 <att_chan_read+0x58>
   1327d:	eb 16                	jmp    13295 <att_chan_read+0x184>
		if (cb && !cb(frag, read, user_data)) {
   1327f:	48 89 c6             	mov    %rax,%rsi
   13282:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
   13287:	48 89 ef             	mov    %rbp,%rdi
   1328a:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
   1328f:	ff d0                	callq  *%rax
   13291:	84 c0                	test   %al,%al
   13293:	75 b8                	jne    1324d <att_chan_read+0x13c>
	return total;
   13295:	4d 89 f7             	mov    %r14,%r15
}
   13298:	48 83 c4 38          	add    $0x38,%rsp
   1329c:	4c 89 f8             	mov    %r15,%rax
   1329f:	5b                   	pop    %rbx
   132a0:	5d                   	pop    %rbp
   132a1:	41 5c                	pop    %r12
   132a3:	41 5d                	pop    %r13
   132a5:	41 5e                	pop    %r14
   132a7:	41 5f                	pop    %r15
   132a9:	c3                   	retq   

00000000000132aa <read_group_cb>:
{
   132aa:	41 55                	push   %r13
   132ac:	41 54                	push   %r12
   132ae:	41 89 f4             	mov    %esi,%r12d
   132b1:	55                   	push   %rbp
   132b2:	53                   	push   %rbx
   132b3:	48 89 fd             	mov    %rdi,%rbp
   132b6:	48 89 d3             	mov    %rdx,%rbx
   132b9:	48 83 ec 18          	sub    $0x18,%rsp
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   132bd:	48 8b 3f             	mov    (%rdi),%rdi
	struct bt_att_chan *chan = data->chan;
   132c0:	4c 8b 2a             	mov    (%rdx),%r13
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   132c3:	48 89 e6             	mov    %rsp,%rsi
   132c6:	c6 04 24 00          	movb   $0x0,(%rsp)
   132ca:	66 c7 44 24 02 00 28 	movw   $0x2800,0x2(%rsp)
{
   132d1:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   132d8:	00 00 
   132da:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   132df:	31 c0                	xor    %eax,%eax
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   132e1:	e8 67 a2 ff ff       	callq  d54d <bt_uuid_cmp>
   132e6:	85 c0                	test   %eax,%eax
   132e8:	74 42                	je     1332c <read_group_cb+0x82>
	    bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   132ea:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
   132ee:	48 8d 74 24 04       	lea    0x4(%rsp),%rsi
   132f3:	c6 44 24 04 00       	movb   $0x0,0x4(%rsp)
   132f8:	66 c7 44 24 06 01 28 	movw   $0x2801,0x6(%rsp)
   132ff:	e8 49 a2 ff ff       	callq  d54d <bt_uuid_cmp>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   13304:	85 c0                	test   %eax,%eax
   13306:	74 24                	je     1332c <read_group_cb+0x82>
		if (data->group &&
   13308:	48 8b 53 20          	mov    0x20(%rbx),%rdx
		return BT_GATT_ITER_CONTINUE;
   1330c:	b0 01                	mov    $0x1,%al
		if (data->group &&
   1330e:	48 85 d2             	test   %rdx,%rdx
   13311:	0f 84 96 00 00 00    	je     133ad <read_group_cb+0x103>
   13317:	66 44 39 62 02       	cmp    %r12w,0x2(%rdx)
   1331c:	0f 83 8b 00 00 00    	jae    133ad <read_group_cb+0x103>
			data->group->end_handle = sys_cpu_to_le16(handle);
   13322:	66 44 89 62 02       	mov    %r12w,0x2(%rdx)
   13327:	e9 81 00 00 00       	jmpq   133ad <read_group_cb+0x103>
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   1332c:	48 8b 73 08          	mov    0x8(%rbx),%rsi
   13330:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
   13334:	e8 14 a2 ff ff       	callq  d54d <bt_uuid_cmp>
   13339:	85 c0                	test   %eax,%eax
   1333b:	74 0c                	je     13349 <read_group_cb+0x9f>
		data->group = NULL;
   1333d:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
   13344:	00 
		return BT_GATT_ITER_CONTINUE;
   13345:	b0 01                	mov    $0x1,%al
   13347:	eb 64                	jmp    133ad <read_group_cb+0x103>
	if (data->rsp->len &&
   13349:	48 8b 43 18          	mov    0x18(%rbx),%rax
   1334d:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
   13351:	0f b6 00             	movzbl (%rax),%eax
   13354:	84 c0                	test   %al,%al
   13356:	74 13                	je     1336b <read_group_cb+0xc1>
	    chan->chan.tx.mtu - data->buf->len < data->rsp->len) {
   13358:	41 0f b7 55 7e       	movzwl 0x7e(%r13),%edx
   1335d:	0f b7 4f 18          	movzwl 0x18(%rdi),%ecx
   13361:	29 ca                	sub    %ecx,%edx
	if (data->rsp->len &&
   13363:	39 c2                	cmp    %eax,%edx
   13365:	7d 04                	jge    1336b <read_group_cb+0xc1>
		return BT_GATT_ITER_STOP;
   13367:	31 c0                	xor    %eax,%eax
   13369:	eb 42                	jmp    133ad <read_group_cb+0x103>
   1336b:	48 83 c7 10          	add    $0x10,%rdi
   1336f:	be 04 00 00 00       	mov    $0x4,%esi
   13374:	e8 10 5d 00 00       	callq  19089 <net_buf_simple_add>
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_group_cb,
   13379:	48 8b 53 10          	mov    0x10(%rbx),%rdx
   1337d:	4c 8d 05 cc f8 ff ff 	lea    -0x734(%rip),%r8        # 12c50 <attr_read_group_cb>
	data->group = net_buf_add(data->buf, sizeof(*data->group));
   13384:	48 89 43 20          	mov    %rax,0x20(%rbx)
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_group_cb,
   13388:	31 c9                	xor    %ecx,%ecx
	data->group->start_handle = sys_cpu_to_le16(handle);
   1338a:	66 44 89 20          	mov    %r12w,(%rax)
	data->group->end_handle = sys_cpu_to_le16(handle);
   1338e:	66 44 89 60 02       	mov    %r12w,0x2(%rax)
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_group_cb,
   13393:	49 89 d9             	mov    %rbx,%r9
   13396:	48 89 ee             	mov    %rbp,%rsi
   13399:	4c 89 ef             	mov    %r13,%rdi
   1339c:	e8 70 fd ff ff       	callq  13111 <att_chan_read>
	if (read < 0) {
   133a1:	85 c0                	test   %eax,%eax
   133a3:	78 c2                	js     13367 <read_group_cb+0xbd>
	if (!data->group) {
   133a5:	48 83 7b 20 00       	cmpq   $0x0,0x20(%rbx)
   133aa:	0f 95 c0             	setne  %al
}
   133ad:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
   133b2:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   133b9:	00 00 
   133bb:	74 05                	je     133c2 <read_group_cb+0x118>
   133bd:	e8 7e 12 ff ff       	callq  4640 <__stack_chk_fail@plt>
   133c2:	48 83 c4 18          	add    $0x18,%rsp
   133c6:	5b                   	pop    %rbx
   133c7:	5d                   	pop    %rbp
   133c8:	41 5c                	pop    %r12
   133ca:	41 5d                	pop    %r13
   133cc:	c3                   	retq   

00000000000133cd <read_type_cb>:
{
   133cd:	41 57                	push   %r15
   133cf:	41 56                	push   %r14
   133d1:	41 89 f6             	mov    %esi,%r14d
   133d4:	41 55                	push   %r13
   133d6:	41 54                	push   %r12
   133d8:	49 89 fd             	mov    %rdi,%r13
   133db:	55                   	push   %rbp
   133dc:	53                   	push   %rbx
   133dd:	48 89 d3             	mov    %rdx,%rbx
		return BT_GATT_ITER_CONTINUE;
   133e0:	40 b5 01             	mov    $0x1,%bpl
{
   133e3:	48 83 ec 08          	sub    $0x8,%rsp
	struct bt_att_chan *chan = data->chan;
   133e7:	4c 8b 22             	mov    (%rdx),%r12
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   133ea:	48 8b 72 08          	mov    0x8(%rdx),%rsi
   133ee:	48 8b 3f             	mov    (%rdi),%rdi
	struct bt_conn *conn = chan->chan.chan.conn;
   133f1:	4d 8b 7c 24 08       	mov    0x8(%r12),%r15
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   133f6:	e8 52 a1 ff ff       	callq  d54d <bt_uuid_cmp>
   133fb:	85 c0                	test   %eax,%eax
   133fd:	0f 85 a6 00 00 00    	jne    134a9 <read_type_cb+0xdc>
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   13403:	ba 15 00 00 00       	mov    $0x15,%edx
   13408:	4c 89 ee             	mov    %r13,%rsi
   1340b:	4c 89 ff             	mov    %r15,%rdi
   1340e:	e8 6e 3e 00 00       	callq  17281 <bt_gatt_check_perm>
	if (data->err) {
   13413:	84 c0                	test   %al,%al
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   13415:	40 88 c5             	mov    %al,%bpl
   13418:	88 43 28             	mov    %al,0x28(%rbx)
	if (data->err) {
   1341b:	74 11                	je     1342e <read_type_cb+0x61>
		if (data->rsp->len) {
   1341d:	48 8b 43 18          	mov    0x18(%rbx),%rax
   13421:	80 38 00             	cmpb   $0x0,(%rax)
   13424:	74 04                	je     1342a <read_type_cb+0x5d>
			data->err = 0x00;
   13426:	c6 43 28 00          	movb   $0x0,0x28(%rbx)
		return BT_GATT_ITER_STOP;
   1342a:	31 ed                	xor    %ebp,%ebp
   1342c:	eb 7b                	jmp    134a9 <read_type_cb+0xdc>
	data->item = net_buf_add(net_buf_frag_last(data->buf),
   1342e:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
   13432:	e8 e5 5b 00 00       	callq  1901c <net_buf_frag_last>
   13437:	48 8d 78 10          	lea    0x10(%rax),%rdi
   1343b:	be 02 00 00 00       	mov    $0x2,%esi
   13440:	e8 44 5c 00 00       	callq  19089 <net_buf_simple_add>
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_type_cb, data);
   13445:	48 8b 53 10          	mov    0x10(%rbx),%rdx
   13449:	4c 8d 05 ef f2 ff ff 	lea    -0xd11(%rip),%r8        # 1273f <attr_read_type_cb>
	data->item = net_buf_add(net_buf_frag_last(data->buf),
   13450:	48 89 43 20          	mov    %rax,0x20(%rbx)
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_type_cb, data);
   13454:	31 c9                	xor    %ecx,%ecx
	data->item->handle = sys_cpu_to_le16(handle);
   13456:	66 44 89 30          	mov    %r14w,(%rax)
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_type_cb, data);
   1345a:	49 89 d9             	mov    %rbx,%r9
   1345d:	4c 89 ee             	mov    %r13,%rsi
   13460:	4c 89 e7             	mov    %r12,%rdi
   13463:	e8 a9 fc ff ff       	callq  13111 <att_chan_read>
	if (read < 0) {
   13468:	48 85 c0             	test   %rax,%rax
   1346b:	79 12                	jns    1347f <read_type_cb+0xb2>
	if (err < 0 && err >= -0xff) {
   1346d:	3d 01 ff ff ff       	cmp    $0xffffff01,%eax
	return BT_ATT_ERR_UNLIKELY;
   13472:	b2 0e                	mov    $0xe,%dl
	if (err < 0 && err >= -0xff) {
   13474:	72 04                	jb     1347a <read_type_cb+0xad>
		return -err;
   13476:	88 c2                	mov    %al,%dl
   13478:	f7 da                	neg    %edx
		data->err = err_to_att(read);
   1347a:	88 53 28             	mov    %dl,0x28(%rbx)
		return BT_GATT_ITER_STOP;
   1347d:	eb 2a                	jmp    134a9 <read_type_cb+0xdc>
	if (!data->item) {
   1347f:	48 83 7b 20 00       	cmpq   $0x0,0x20(%rbx)
   13484:	74 a4                	je     1342a <read_type_cb+0x5d>
	return chan->chan.tx.mtu - net_buf_frags_len(data->buf) >
   13486:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
   1348a:	e8 4f f2 ff ff       	callq  126de <net_buf_frags_len>
   1348f:	41 0f b7 54 24 7e    	movzwl 0x7e(%r12),%edx
   13495:	48 29 c2             	sub    %rax,%rdx
   13498:	48 89 d0             	mov    %rdx,%rax
	       data->rsp->len ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
   1349b:	48 8b 53 18          	mov    0x18(%rbx),%rdx
   1349f:	0f b6 12             	movzbl (%rdx),%edx
   134a2:	48 39 d0             	cmp    %rdx,%rax
   134a5:	40 0f 97 c5          	seta   %bpl
}
   134a9:	5a                   	pop    %rdx
   134aa:	40 88 e8             	mov    %bpl,%al
   134ad:	5b                   	pop    %rbx
   134ae:	5d                   	pop    %rbp
   134af:	41 5c                	pop    %r12
   134b1:	41 5d                	pop    %r13
   134b3:	41 5e                	pop    %r14
   134b5:	41 5f                	pop    %r15
   134b7:	c3                   	retq   

00000000000134b8 <chan_req_send>:
{
   134b8:	41 55                	push   %r13
   134ba:	41 54                	push   %r12
   134bc:	49 89 fc             	mov    %rdi,%r12
   134bf:	55                   	push   %rbp
   134c0:	53                   	push   %rbx
		return -EMSGSIZE;
   134c1:	bd a6 ff ff ff       	mov    $0xffffffa6,%ebp
{
   134c6:	48 83 ec 08          	sub    $0x8,%rsp
	if (chan->chan.tx.mtu < net_buf_frags_len(req->buf)) {
   134ca:	4c 8b 6e 20          	mov    0x20(%rsi),%r13
   134ce:	4c 89 ef             	mov    %r13,%rdi
   134d1:	e8 08 f2 ff ff       	callq  126de <net_buf_frags_len>
   134d6:	41 0f b7 54 24 7e    	movzwl 0x7e(%r12),%edx
   134dc:	48 39 c2             	cmp    %rax,%rdx
   134df:	72 45                	jb     13526 <chan_req_send+0x6e>
	net_buf_simple_save(&req->buf->b, &req->state);
   134e1:	49 8d 7d 10          	lea    0x10(%r13),%rdi
   134e5:	48 89 f3             	mov    %rsi,%rbx
	chan->req = req;
   134e8:	49 89 b4 24 38 01 00 	mov    %rsi,0x138(%r12)
   134ef:	00 
	state->offset = net_buf_simple_headroom(buf);
   134f0:	e8 3d 5c 00 00       	callq  19132 <net_buf_simple_headroom>
   134f5:	66 89 43 18          	mov    %ax,0x18(%rbx)
	state->len = buf->len;
   134f9:	41 8b 45 18          	mov    0x18(%r13),%eax
	err = chan_send(chan, net_buf_ref(req->buf), NULL);
   134fd:	48 8b 7b 20          	mov    0x20(%rbx),%rdi
   13501:	66 89 43 1a          	mov    %ax,0x1a(%rbx)
   13505:	e8 0b 5b 00 00       	callq  19015 <net_buf_ref>
   1350a:	31 d2                	xor    %edx,%edx
   1350c:	48 89 c6             	mov    %rax,%rsi
   1350f:	4c 89 e7             	mov    %r12,%rdi
   13512:	e8 6e f7 ff ff       	callq  12c85 <chan_send>
	if (err) {
   13517:	85 c0                	test   %eax,%eax
	err = chan_send(chan, net_buf_ref(req->buf), NULL);
   13519:	89 c5                	mov    %eax,%ebp
	if (err) {
   1351b:	74 09                	je     13526 <chan_req_send+0x6e>
		net_buf_unref(req->buf);
   1351d:	48 8b 7b 20          	mov    0x20(%rbx),%rdi
   13521:	e8 74 5a 00 00       	callq  18f9a <net_buf_unref>
}
   13526:	5a                   	pop    %rdx
   13527:	89 e8                	mov    %ebp,%eax
   13529:	5b                   	pop    %rbx
   1352a:	5d                   	pop    %rbp
   1352b:	41 5c                	pop    %r12
   1352d:	41 5d                	pop    %r13
   1352f:	c3                   	retq   

0000000000013530 <bt_att_chan_req_send>:
{
   13530:	41 55                	push   %r13
   13532:	41 54                	push   %r12
   13534:	49 89 f5             	mov    %rsi,%r13
   13537:	55                   	push   %rbp
   13538:	53                   	push   %rbx
   13539:	49 89 fc             	mov    %rdi,%r12
	if (k_sem_take(&chan->tx_sem, K_NO_WAIT) < 0) {
   1353c:	48 8d af b0 01 00 00 	lea    0x1b0(%rdi),%rbp
{
   13543:	48 83 ec 08          	sub    $0x8,%rsp
	return z_impl_k_sem_take(sem, timeout);
   13547:	31 f6                	xor    %esi,%esi
   13549:	48 89 ef             	mov    %rbp,%rdi
		return -EAGAIN;
   1354c:	bb f5 ff ff ff       	mov    $0xfffffff5,%ebx
   13551:	e8 3d 8a 01 00       	callq  2bf93 <z_impl_k_sem_take>
	if (k_sem_take(&chan->tx_sem, K_NO_WAIT) < 0) {
   13556:	85 c0                	test   %eax,%eax
   13558:	78 19                	js     13573 <bt_att_chan_req_send+0x43>
	err = chan_req_send(chan, req);
   1355a:	4c 89 ee             	mov    %r13,%rsi
   1355d:	4c 89 e7             	mov    %r12,%rdi
   13560:	e8 53 ff ff ff       	callq  134b8 <chan_req_send>
	if (err < 0) {
   13565:	85 c0                	test   %eax,%eax
	err = chan_req_send(chan, req);
   13567:	89 c3                	mov    %eax,%ebx
	if (err < 0) {
   13569:	79 08                	jns    13573 <bt_att_chan_req_send+0x43>
	z_impl_k_sem_give(sem);
   1356b:	48 89 ef             	mov    %rbp,%rdi
   1356e:	e8 c3 89 01 00       	callq  2bf36 <z_impl_k_sem_give>
}
   13573:	5a                   	pop    %rdx
   13574:	89 d8                	mov    %ebx,%eax
   13576:	5b                   	pop    %rbx
   13577:	5d                   	pop    %rbp
   13578:	41 5c                	pop    %r12
   1357a:	41 5d                	pop    %r13
   1357c:	c3                   	retq   

000000000001357d <bt_att_status>:
{
   1357d:	55                   	push   %rbp
   1357e:	53                   	push   %rbx
   1357f:	48 89 fd             	mov    %rdi,%rbp
   13582:	48 89 f7             	mov    %rsi,%rdi
	if (!atomic_test_bit(status, BT_L2CAP_STATUS_OUT)) {
   13585:	31 f6                	xor    %esi,%esi
{
   13587:	48 83 ec 08          	sub    $0x8,%rsp
	if (!atomic_test_bit(status, BT_L2CAP_STATUS_OUT)) {
   1358b:	e8 b7 f2 ff ff       	callq  12847 <atomic_test_bit>
   13590:	84 c0                	test   %al,%al
   13592:	74 4e                	je     135e2 <bt_att_status+0x65>
	if (!chan->att) {
   13594:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
   13598:	48 85 ff             	test   %rdi,%rdi
   1359b:	74 45                	je     135e2 <bt_att_status+0x65>
	if (chan->req) {
   1359d:	48 83 bd 30 01 00 00 	cmpq   $0x0,0x130(%rbp)
   135a4:	00 
   135a5:	75 3b                	jne    135e2 <bt_att_status+0x65>
	node = sys_slist_get(&chan->att->reqs);
   135a7:	48 83 c7 08          	add    $0x8,%rdi
   135ab:	e8 cf f0 ff ff       	callq  1267f <sys_slist_get>
	if (!node) {
   135b0:	48 85 c0             	test   %rax,%rax
	node = sys_slist_get(&chan->att->reqs);
   135b3:	48 89 c3             	mov    %rax,%rbx
	if (!node) {
   135b6:	74 2a                	je     135e2 <bt_att_status+0x65>
	struct bt_att_chan *chan = ATT_CHAN(ch);
   135b8:	48 8d 7d f8          	lea    -0x8(%rbp),%rdi
	if (bt_att_chan_req_send(chan, ATT_REQ(node)) >= 0) {
   135bc:	48 89 c6             	mov    %rax,%rsi
   135bf:	e8 6c ff ff ff       	callq  13530 <bt_att_chan_req_send>
   135c4:	85 c0                	test   %eax,%eax
   135c6:	79 1a                	jns    135e2 <bt_att_status+0x65>
	sys_slist_prepend(&chan->att->reqs, node);
   135c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
Z_GENLIST_PREPEND(slist, snode)
   135cc:	48 8b 50 08          	mov    0x8(%rax),%rdx
	parent->next = child;
   135d0:	48 89 13             	mov    %rdx,(%rbx)
Z_GENLIST_PREPEND(slist, snode)
   135d3:	48 83 78 10 00       	cmpq   $0x0,0x10(%rax)
	list->head = node;
   135d8:	48 89 58 08          	mov    %rbx,0x8(%rax)
Z_GENLIST_PREPEND(slist, snode)
   135dc:	75 04                	jne    135e2 <bt_att_status+0x65>
	list->tail = node;
   135de:	48 89 58 10          	mov    %rbx,0x10(%rax)
}
   135e2:	58                   	pop    %rax
   135e3:	5b                   	pop    %rbx
   135e4:	5d                   	pop    %rbp
   135e5:	c3                   	retq   

00000000000135e6 <write_cb>:
{
   135e6:	41 54                	push   %r12
   135e8:	55                   	push   %rbp
	data->err = bt_gatt_check_perm(data->conn, attr,
   135e9:	48 89 fe             	mov    %rdi,%rsi
{
   135ec:	53                   	push   %rbx
   135ed:	48 89 d3             	mov    %rdx,%rbx
   135f0:	49 89 fc             	mov    %rdi,%r12
	data->err = bt_gatt_check_perm(data->conn, attr,
   135f3:	48 8b 3b             	mov    (%rbx),%rdi
   135f6:	ba 2a 00 00 00       	mov    $0x2a,%edx
		return BT_GATT_ITER_STOP;
   135fb:	31 ed                	xor    %ebp,%ebp
	data->err = bt_gatt_check_perm(data->conn, attr,
   135fd:	e8 7f 3c 00 00       	callq  17281 <bt_gatt_check_perm>
	if (data->err) {
   13602:	84 c0                	test   %al,%al
	data->err = bt_gatt_check_perm(data->conn, attr,
   13604:	88 43 24             	mov    %al,0x24(%rbx)
	if (data->err) {
   13607:	75 4f                	jne    13658 <write_cb+0x72>
		flags |= BT_GATT_WRITE_FLAG_CMD;
   13609:	80 7b 10 01          	cmpb   $0x1,0x10(%rbx)
	write = attr->write(data->conn, attr, data->value, data->len,
   1360d:	0f b7 4b 20          	movzwl 0x20(%rbx),%ecx
   13611:	40 88 c5             	mov    %al,%bpl
   13614:	44 0f b7 43 22       	movzwl 0x22(%rbx),%r8d
   13619:	48 8b 53 18          	mov    0x18(%rbx),%rdx
   1361d:	4c 89 e6             	mov    %r12,%rsi
   13620:	48 8b 3b             	mov    (%rbx),%rdi
		flags |= BT_GATT_WRITE_FLAG_CMD;
   13623:	45 19 c9             	sbb    %r9d,%r9d
   13626:	41 83 e1 02          	and    $0x2,%r9d
	write = attr->write(data->conn, attr, data->value, data->len,
   1362a:	45 0f b6 c9          	movzbl %r9b,%r9d
   1362e:	41 ff 54 24 10       	callq  *0x10(%r12)
	if (write < 0 || write != data->len) {
   13633:	85 c0                	test   %eax,%eax
   13635:	78 08                	js     1363f <write_cb+0x59>
   13637:	0f b7 53 20          	movzwl 0x20(%rbx),%edx
   1363b:	39 d0                	cmp    %edx,%eax
   1363d:	74 12                	je     13651 <write_cb+0x6b>
	if (err < 0 && err >= -0xff) {
   1363f:	3d 01 ff ff ff       	cmp    $0xffffff01,%eax
	return BT_ATT_ERR_UNLIKELY;
   13644:	b2 0e                	mov    $0xe,%dl
	if (err < 0 && err >= -0xff) {
   13646:	72 04                	jb     1364c <write_cb+0x66>
		return -err;
   13648:	88 c2                	mov    %al,%dl
   1364a:	f7 da                	neg    %edx
		data->err = err_to_att(write);
   1364c:	88 53 24             	mov    %dl,0x24(%rbx)
   1364f:	eb 07                	jmp    13658 <write_cb+0x72>
	data->err = 0U;
   13651:	c6 43 24 00          	movb   $0x0,0x24(%rbx)
	return BT_GATT_ITER_CONTINUE;
   13655:	40 b5 01             	mov    $0x1,%bpl
}
   13658:	40 88 e8             	mov    %bpl,%al
   1365b:	5b                   	pop    %rbx
   1365c:	5d                   	pop    %rbp
   1365d:	41 5c                	pop    %r12
   1365f:	c3                   	retq   

0000000000013660 <prep_write_cb>:
{
   13660:	41 55                	push   %r13
   13662:	41 54                	push   %r12
   13664:	41 89 f5             	mov    %esi,%r13d
   13667:	55                   	push   %rbp
   13668:	53                   	push   %rbx
   13669:	48 89 d3             	mov    %rdx,%rbx
	data->err = bt_gatt_check_perm(data->conn, attr,
   1366c:	48 89 fe             	mov    %rdi,%rsi
{
   1366f:	49 89 fc             	mov    %rdi,%r12
	data->err = bt_gatt_check_perm(data->conn, attr,
   13672:	ba 2a 00 00 00       	mov    $0x2a,%edx
{
   13677:	48 83 ec 08          	sub    $0x8,%rsp
	data->err = bt_gatt_check_perm(data->conn, attr,
   1367b:	48 8b 3b             	mov    (%rbx),%rdi
		return BT_GATT_ITER_STOP;
   1367e:	31 ed                	xor    %ebp,%ebp
	data->err = bt_gatt_check_perm(data->conn, attr,
   13680:	e8 fc 3b 00 00       	callq  17281 <bt_gatt_check_perm>
	if (data->err) {
   13685:	84 c0                	test   %al,%al
	data->err = bt_gatt_check_perm(data->conn, attr,
   13687:	88 43 1c             	mov    %al,0x1c(%rbx)
	if (data->err) {
   1368a:	0f 85 81 00 00 00    	jne    13711 <prep_write_cb+0xb1>
	if (!(attr->perm & BT_GATT_PERM_PREPARE_WRITE)) {
   13690:	41 f6 44 24 22 40    	testb  $0x40,0x22(%r12)
   13696:	40 88 c5             	mov    %al,%bpl
   13699:	74 34                	je     136cf <prep_write_cb+0x6f>
	write = attr->write(data->conn, attr, data->value, data->len,
   1369b:	0f b7 4b 18          	movzwl 0x18(%rbx),%ecx
   1369f:	44 0f b7 43 1a       	movzwl 0x1a(%rbx),%r8d
   136a4:	41 b9 01 00 00 00    	mov    $0x1,%r9d
   136aa:	48 8b 53 10          	mov    0x10(%rbx),%rdx
   136ae:	4c 89 e6             	mov    %r12,%rsi
   136b1:	48 8b 3b             	mov    (%rbx),%rdi
   136b4:	41 ff 54 24 10       	callq  *0x10(%r12)
	if (write != 0) {
   136b9:	85 c0                	test   %eax,%eax
   136bb:	74 12                	je     136cf <prep_write_cb+0x6f>
	if (err < 0 && err >= -0xff) {
   136bd:	3d 01 ff ff ff       	cmp    $0xffffff01,%eax
	return BT_ATT_ERR_UNLIKELY;
   136c2:	b2 0e                	mov    $0xe,%dl
	if (err < 0 && err >= -0xff) {
   136c4:	72 04                	jb     136ca <prep_write_cb+0x6a>
		return -err;
   136c6:	88 c2                	mov    %al,%dl
   136c8:	f7 da                	neg    %edx
		data->err = err_to_att(write);
   136ca:	88 53 1c             	mov    %dl,0x1c(%rbx)
		return BT_GATT_ITER_STOP;
   136cd:	eb 42                	jmp    13711 <prep_write_cb+0xb1>
	return net_buf_alloc_fixed(pool, timeout);
   136cf:	48 8d 3d 0a 72 22 00 	lea    0x22720a(%rip),%rdi        # 23a8e0 <prep_pool>
   136d6:	31 f6                	xor    %esi,%esi
   136d8:	e8 37 58 00 00       	callq  18f14 <net_buf_alloc_fixed>
	if (!data->buf) {
   136dd:	48 85 c0             	test   %rax,%rax
	data->buf = net_buf_alloc(&prep_pool, K_NO_WAIT);
   136e0:	48 89 43 08          	mov    %rax,0x8(%rbx)
	if (!data->buf) {
   136e4:	75 06                	jne    136ec <prep_write_cb+0x8c>
		data->err = BT_ATT_ERR_PREPARE_QUEUE_FULL;
   136e6:	c6 43 1c 09          	movb   $0x9,0x1c(%rbx)
   136ea:	eb 25                	jmp    13711 <prep_write_cb+0xb1>
	attr_data->offset = data->offset;
   136ec:	66 8b 53 1a          	mov    0x1a(%rbx),%dx
	return net_buf_simple_add_mem(&buf->b, mem, len);
   136f0:	48 8b 73 10          	mov    0x10(%rbx),%rsi
   136f4:	48 8d 78 10          	lea    0x10(%rax),%rdi
	attr_data->handle = handle;
   136f8:	66 44 89 68 28       	mov    %r13w,0x28(%rax)
	return BT_GATT_ITER_CONTINUE;
   136fd:	40 b5 01             	mov    $0x1,%bpl
	attr_data->offset = data->offset;
   13700:	66 89 50 2a          	mov    %dx,0x2a(%rax)
	net_buf_add_mem(data->buf, data->value, data->len);
   13704:	0f b7 53 18          	movzwl 0x18(%rbx),%edx
   13708:	e8 8d 59 00 00       	callq  1909a <net_buf_simple_add_mem>
	data->err = 0U;
   1370d:	c6 43 1c 00          	movb   $0x0,0x1c(%rbx)
}
   13711:	5a                   	pop    %rdx
   13712:	40 88 e8             	mov    %bpl,%al
   13715:	5b                   	pop    %rbx
   13716:	5d                   	pop    %rbp
   13717:	41 5c                	pop    %r12
   13719:	41 5d                	pop    %r13
   1371b:	c3                   	retq   

000000000001371c <read_cb>:
{
   1371c:	41 55                	push   %r13
   1371e:	41 54                	push   %r12
   13720:	49 89 fd             	mov    %rdi,%r13
   13723:	55                   	push   %rbp
   13724:	53                   	push   %rbx
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   13725:	4c 89 ee             	mov    %r13,%rsi
{
   13728:	48 89 d3             	mov    %rdx,%rbx
		return BT_GATT_ITER_STOP;
   1372b:	31 ed                	xor    %ebp,%ebp
{
   1372d:	48 83 ec 08          	sub    $0x8,%rsp
	struct bt_att_chan *chan = data->chan;
   13731:	4c 8b 22             	mov    (%rdx),%r12
	struct bt_conn *conn = chan->chan.chan.conn;
   13734:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
	data->err = 0x00;
   13739:	c6 42 18 00          	movb   $0x0,0x18(%rdx)
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   1373d:	ba 15 00 00 00       	mov    $0x15,%edx
   13742:	e8 3a 3b 00 00       	callq  17281 <bt_gatt_check_perm>
	if (data->err) {
   13747:	84 c0                	test   %al,%al
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   13749:	88 43 18             	mov    %al,0x18(%rbx)
	if (data->err) {
   1374c:	75 35                	jne    13783 <read_cb+0x67>
	ret = att_chan_read(chan, attr, data->buf, data->offset, NULL, NULL);
   1374e:	0f b7 4b 08          	movzwl 0x8(%rbx),%ecx
   13752:	48 8b 53 10          	mov    0x10(%rbx),%rdx
   13756:	45 31 c9             	xor    %r9d,%r9d
   13759:	45 31 c0             	xor    %r8d,%r8d
   1375c:	4c 89 ee             	mov    %r13,%rsi
   1375f:	4c 89 e7             	mov    %r12,%rdi
   13762:	40 88 c5             	mov    %al,%bpl
   13765:	e8 a7 f9 ff ff       	callq  13111 <att_chan_read>
	if (ret < 0) {
   1376a:	85 c0                	test   %eax,%eax
   1376c:	79 12                	jns    13780 <read_cb+0x64>
	if (err < 0 && err >= -0xff) {
   1376e:	3d 01 ff ff ff       	cmp    $0xffffff01,%eax
	return BT_ATT_ERR_UNLIKELY;
   13773:	b2 0e                	mov    $0xe,%dl
	if (err < 0 && err >= -0xff) {
   13775:	72 04                	jb     1377b <read_cb+0x5f>
		return -err;
   13777:	88 c2                	mov    %al,%dl
   13779:	f7 da                	neg    %edx
		data->err = err_to_att(ret);
   1377b:	88 53 18             	mov    %dl,0x18(%rbx)
		return BT_GATT_ITER_STOP;
   1377e:	eb 03                	jmp    13783 <read_cb+0x67>
	return BT_GATT_ITER_CONTINUE;
   13780:	40 b5 01             	mov    $0x1,%bpl
}
   13783:	5a                   	pop    %rdx
   13784:	40 88 e8             	mov    %bpl,%al
   13787:	5b                   	pop    %rbx
   13788:	5d                   	pop    %rbp
   13789:	41 5c                	pop    %r12
   1378b:	41 5d                	pop    %r13
   1378d:	c3                   	retq   

000000000001378e <bt_att_sent>:
{
   1378e:	41 55                	push   %r13
   13790:	41 54                	push   %r12
	struct bt_att_chan *chan = ATT_CHAN(ch);
   13792:	4c 8d 67 f8          	lea    -0x8(%rdi),%r12
{
   13796:	55                   	push   %rbp
   13797:	53                   	push   %rbx
   13798:	48 89 fb             	mov    %rdi,%rbx
   1379b:	48 83 ec 08          	sub    $0x8,%rsp
	if (chan->sent) {
   1379f:	48 8b 87 d0 01 00 00 	mov    0x1d0(%rdi),%rax
	struct bt_att *att = chan->att;
   137a6:	48 8b 6f f8          	mov    -0x8(%rdi),%rbp
	if (chan->sent) {
   137aa:	48 85 c0             	test   %rax,%rax
   137ad:	74 05                	je     137b4 <bt_att_sent+0x26>
		chan->sent(chan);
   137af:	4c 89 e7             	mov    %r12,%rdi
   137b2:	ff d0                	callq  *%rax
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   137b4:	f0 83 a3 28 01 00 00 	lock andl $0xffffffef,0x128(%rbx)
   137bb:	ef 
	if (!att) {
   137bc:	48 85 ed             	test   %rbp,%rbp
   137bf:	74 79                	je     1383a <bt_att_sent+0xac>
	if (!chan->req && !sys_slist_is_empty(&att->reqs)) {
   137c1:	48 83 bb 30 01 00 00 	cmpq   $0x0,0x130(%rbx)
   137c8:	00 
   137c9:	75 39                	jne    13804 <bt_att_sent+0x76>
   137cb:	48 83 7d 08 00       	cmpq   $0x0,0x8(%rbp)
   137d0:	74 32                	je     13804 <bt_att_sent+0x76>
		sys_snode_t *node = sys_slist_get(&att->reqs);
   137d2:	48 8d 7d 08          	lea    0x8(%rbp),%rdi
   137d6:	e8 a4 ee ff ff       	callq  1267f <sys_slist_get>
		if (chan_req_send(chan, ATT_REQ(node)) >= 0) {
   137db:	4c 89 e7             	mov    %r12,%rdi
   137de:	48 89 c6             	mov    %rax,%rsi
		sys_snode_t *node = sys_slist_get(&att->reqs);
   137e1:	49 89 c5             	mov    %rax,%r13
		if (chan_req_send(chan, ATT_REQ(node)) >= 0) {
   137e4:	e8 cf fc ff ff       	callq  134b8 <chan_req_send>
   137e9:	85 c0                	test   %eax,%eax
   137eb:	79 4d                	jns    1383a <bt_att_sent+0xac>
Z_GENLIST_PREPEND(slist, snode)
   137ed:	48 8b 45 08          	mov    0x8(%rbp),%rax
	parent->next = child;
   137f1:	49 89 45 00          	mov    %rax,0x0(%r13)
Z_GENLIST_PREPEND(slist, snode)
   137f5:	48 83 7d 10 00       	cmpq   $0x0,0x10(%rbp)
	list->head = node;
   137fa:	4c 89 6d 08          	mov    %r13,0x8(%rbp)
Z_GENLIST_PREPEND(slist, snode)
   137fe:	75 04                	jne    13804 <bt_att_sent+0x76>
	list->tail = node;
   13800:	4c 89 6d 10          	mov    %r13,0x10(%rbp)
	err = process_queue(chan, &chan->tx_queue);
   13804:	48 8d b3 38 01 00 00 	lea    0x138(%rbx),%rsi
   1380b:	4c 89 e7             	mov    %r12,%rdi
   1380e:	e8 ea f5 ff ff       	callq  12dfd <process_queue>
	if (!err) {
   13813:	85 c0                	test   %eax,%eax
   13815:	74 23                	je     1383a <bt_att_sent+0xac>
	err = process_queue(chan, &att->tx_queue);
   13817:	48 8d 75 18          	lea    0x18(%rbp),%rsi
   1381b:	4c 89 e7             	mov    %r12,%rdi
   1381e:	e8 da f5 ff ff       	callq  12dfd <process_queue>
	if (!err) {
   13823:	85 c0                	test   %eax,%eax
   13825:	74 13                	je     1383a <bt_att_sent+0xac>
}
   13827:	5a                   	pop    %rdx
	k_sem_give(&chan->tx_sem);
   13828:	48 8d bb a8 01 00 00 	lea    0x1a8(%rbx),%rdi
}
   1382f:	5b                   	pop    %rbx
   13830:	5d                   	pop    %rbp
   13831:	41 5c                	pop    %r12
   13833:	41 5d                	pop    %r13
   13835:	e9 fc 86 01 00       	jmpq   2bf36 <z_impl_k_sem_give>
   1383a:	58                   	pop    %rax
   1383b:	5b                   	pop    %rbx
   1383c:	5d                   	pop    %rbp
   1383d:	41 5c                	pop    %r12
   1383f:	41 5d                	pop    %r13
   13841:	c3                   	retq   

0000000000013842 <bt_att_chan_create_pdu>:
{
   13842:	41 54                	push   %r12
   13844:	41 89 f4             	mov    %esi,%r12d
   13847:	55                   	push   %rbp
   13848:	53                   	push   %rbx
   13849:	40 88 f3             	mov    %sil,%bl
	if (len + sizeof(op) > chan->chan.tx.mtu) {
   1384c:	0f b7 77 7e          	movzwl 0x7e(%rdi),%esi
   13850:	48 ff c2             	inc    %rdx
   13853:	48 39 f2             	cmp    %rsi,%rdx
   13856:	76 28                	jbe    13880 <bt_att_chan_create_pdu+0x3e>
   13858:	48 8d 0d 11 6b 22 00 	lea    0x226b11(%rip),%rcx        # 23a370 <log_const_bt_att>
   1385f:	48 2b 0d ea 26 22 00 	sub    0x2226ea(%rip),%rcx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("ATT MTU exceeded, max %u, wanted %zu",
   13866:	48 8d 3d 7a f5 01 00 	lea    0x1f57a(%rip),%rdi        # 32de7 <__func__.5785+0x217f>
		return NULL;
   1386d:	31 ed                	xor    %ebp,%ebp
   1386f:	48 c1 e9 04          	shr    $0x4,%rcx
		BT_WARN("ATT MTU exceeded, max %u, wanted %zu",
   13873:	c1 e1 06             	shl    $0x6,%ecx
   13876:	83 c9 02             	or     $0x2,%ecx
   13879:	e8 b4 3a ff ff       	callq  7332 <log_2>
		return NULL;
   1387e:	eb 65                	jmp    138e5 <bt_att_chan_create_pdu+0xa3>
	switch (att_op_get_type(op)) {
   13880:	41 0f b6 fc          	movzbl %r12b,%edi
   13884:	e8 e7 ee ff ff       	callq  12770 <att_op_get_type>
   13889:	3c 02                	cmp    $0x2,%al
   1388b:	74 08                	je     13895 <bt_att_chan_create_pdu+0x53>
		buf = bt_l2cap_create_pdu(NULL, 0);
   1388d:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
	switch (att_op_get_type(op)) {
   13891:	3c 04                	cmp    $0x4,%al
   13893:	75 05                	jne    1389a <bt_att_chan_create_pdu+0x58>
		buf = bt_l2cap_create_pdu_timeout(NULL, 0, BT_ATT_TIMEOUT);
   13895:	ba b8 0b 00 00       	mov    $0xbb8,%edx
		buf = bt_l2cap_create_pdu(NULL, 0);
   1389a:	31 f6                	xor    %esi,%esi
   1389c:	31 ff                	xor    %edi,%edi
   1389e:	e8 28 ea ff ff       	callq  122cb <bt_l2cap_create_pdu_timeout>
	if (!buf) {
   138a3:	48 85 c0             	test   %rax,%rax
		buf = bt_l2cap_create_pdu(NULL, 0);
   138a6:	48 89 c5             	mov    %rax,%rbp
	if (!buf) {
   138a9:	75 29                	jne    138d4 <bt_att_chan_create_pdu+0x92>
   138ab:	48 8d 15 be 6a 22 00 	lea    0x226abe(%rip),%rdx        # 23a370 <log_const_bt_att>
   138b2:	48 2b 15 97 26 22 00 	sub    0x222697(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unable to allocate buffer for op 0x%02x", op);
   138b9:	48 8d 3d 2b f3 01 00 	lea    0x1f32b(%rip),%rdi        # 32beb <__func__.5785+0x1f83>
   138c0:	0f b6 f3             	movzbl %bl,%esi
   138c3:	48 c1 ea 04          	shr    $0x4,%rdx
   138c7:	c1 e2 06             	shl    $0x6,%edx
   138ca:	83 ca 01             	or     $0x1,%edx
   138cd:	e8 23 3a ff ff       	callq  72f5 <log_1>
		return NULL;
   138d2:	eb 11                	jmp    138e5 <bt_att_chan_create_pdu+0xa3>
	return net_buf_simple_add(&buf->b, len);
   138d4:	48 8d 78 10          	lea    0x10(%rax),%rdi
   138d8:	be 01 00 00 00       	mov    $0x1,%esi
   138dd:	e8 a7 57 00 00       	callq  19089 <net_buf_simple_add>
	hdr->code = op;
   138e2:	44 88 20             	mov    %r12b,(%rax)
}
   138e5:	48 89 e8             	mov    %rbp,%rax
   138e8:	5b                   	pop    %rbx
   138e9:	5d                   	pop    %rbp
   138ea:	41 5c                	pop    %r12
   138ec:	c3                   	retq   

00000000000138ed <att_indicate>:
{
   138ed:	55                   	push   %rbp
   138ee:	53                   	push   %rbx
   138ef:	48 89 fb             	mov    %rdi,%rbx
	return net_buf_simple_pull_le16(&buf->b);
   138f2:	48 8d 7e 10          	lea    0x10(%rsi),%rdi
   138f6:	48 89 f5             	mov    %rsi,%rbp
   138f9:	48 83 ec 08          	sub    $0x8,%rsp
   138fd:	e8 1b 58 00 00       	callq  1911d <net_buf_simple_pull_le16>
	bt_gatt_notification(chan->att->conn, handle, buf->data, buf->len);
   13902:	0f b7 f0             	movzwl %ax,%esi
   13905:	48 8b 03             	mov    (%rbx),%rax
   13908:	0f b7 4d 18          	movzwl 0x18(%rbp),%ecx
   1390c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
   13910:	48 8b 38             	mov    (%rax),%rdi
   13913:	e8 a6 4b 00 00       	callq  184be <bt_gatt_notification>
	buf = bt_att_chan_create_pdu(chan, BT_ATT_OP_CONFIRM, 0);
   13918:	31 d2                	xor    %edx,%edx
   1391a:	be 1e 00 00 00       	mov    $0x1e,%esi
   1391f:	48 89 df             	mov    %rbx,%rdi
   13922:	e8 1b ff ff ff       	callq  13842 <bt_att_chan_create_pdu>
	if (!buf) {
   13927:	48 85 c0             	test   %rax,%rax
   1392a:	74 12                	je     1393e <att_indicate+0x51>
	bt_att_chan_send_rsp(chan, buf, chan_cfm_sent);
   1392c:	48 8d 15 d2 ed ff ff 	lea    -0x122e(%rip),%rdx        # 12705 <chan_cfm_sent>
   13933:	48 89 c6             	mov    %rax,%rsi
   13936:	48 89 df             	mov    %rbx,%rdi
   13939:	e8 94 f4 ff ff       	callq  12dd2 <bt_att_chan_send_rsp>
}
   1393e:	5a                   	pop    %rdx
   1393f:	31 c0                	xor    %eax,%eax
   13941:	5b                   	pop    %rbx
   13942:	5d                   	pop    %rbp
   13943:	c3                   	retq   

0000000000013944 <send_err_rsp.part.11>:
static void send_err_rsp(struct bt_att_chan *chan, uint8_t req, uint16_t handle,
   13944:	41 56                	push   %r14
   13946:	41 55                	push   %r13
   13948:	41 89 f6             	mov    %esi,%r14d
   1394b:	41 54                	push   %r12
   1394d:	55                   	push   %rbp
   1394e:	41 89 d5             	mov    %edx,%r13d
   13951:	53                   	push   %rbx
	buf = bt_att_chan_create_pdu(chan, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
   13952:	ba 04 00 00 00       	mov    $0x4,%edx
   13957:	be 01 00 00 00       	mov    $0x1,%esi
static void send_err_rsp(struct bt_att_chan *chan, uint8_t req, uint16_t handle,
   1395c:	48 89 fd             	mov    %rdi,%rbp
   1395f:	41 89 cc             	mov    %ecx,%r12d
	buf = bt_att_chan_create_pdu(chan, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
   13962:	e8 db fe ff ff       	callq  13842 <bt_att_chan_create_pdu>
	if (!buf) {
   13967:	48 85 c0             	test   %rax,%rax
   1396a:	74 37                	je     139a3 <send_err_rsp.part.11+0x5f>
	return net_buf_simple_add(&buf->b, len);
   1396c:	48 8d 78 10          	lea    0x10(%rax),%rdi
   13970:	48 89 c3             	mov    %rax,%rbx
   13973:	be 04 00 00 00       	mov    $0x4,%esi
   13978:	e8 0c 57 00 00       	callq  19089 <net_buf_simple_add>
	bt_att_chan_send_rsp(chan, buf, chan_rsp_sent);
   1397d:	48 89 de             	mov    %rbx,%rsi
	rsp->request = req;
   13980:	44 88 30             	mov    %r14b,(%rax)
	rsp->handle = sys_cpu_to_le16(handle);
   13983:	66 44 89 68 01       	mov    %r13w,0x1(%rax)
	rsp->error = err;
   13988:	44 88 60 03          	mov    %r12b,0x3(%rax)
	bt_att_chan_send_rsp(chan, buf, chan_rsp_sent);
   1398c:	48 89 ef             	mov    %rbp,%rdi
   1398f:	48 8d 15 dd f6 ff ff 	lea    -0x923(%rip),%rdx        # 13073 <chan_rsp_sent>
}
   13996:	5b                   	pop    %rbx
   13997:	5d                   	pop    %rbp
   13998:	41 5c                	pop    %r12
   1399a:	41 5d                	pop    %r13
   1399c:	41 5e                	pop    %r14
	bt_att_chan_send_rsp(chan, buf, chan_rsp_sent);
   1399e:	e9 2f f4 ff ff       	jmpq   12dd2 <bt_att_chan_send_rsp>
}
   139a3:	5b                   	pop    %rbx
   139a4:	5d                   	pop    %rbp
   139a5:	41 5c                	pop    %r12
   139a7:	41 5d                	pop    %r13
   139a9:	41 5e                	pop    %r14
   139ab:	c3                   	retq   

00000000000139ac <bt_att_recv>:
{
   139ac:	41 56                	push   %r14
   139ae:	41 55                	push   %r13
   139b0:	41 54                	push   %r12
   139b2:	55                   	push   %rbp
   139b3:	53                   	push   %rbx
	if (buf->len < sizeof(*hdr)) {
   139b4:	66 83 7e 18 00       	cmpw   $0x0,0x18(%rsi)
   139b9:	75 29                	jne    139e4 <bt_att_recv+0x38>
   139bb:	48 8d 35 ae 69 22 00 	lea    0x2269ae(%rip),%rsi        # 23a370 <log_const_bt_att>
   139c2:	48 2b 35 87 25 22 00 	sub    0x222587(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Too small ATT PDU received");
   139c9:	48 8d 3d 3c f4 01 00 	lea    0x1f43c(%rip),%rdi        # 32e0c <__func__.5785+0x21a4>
   139d0:	48 c1 ee 04          	shr    $0x4,%rsi
   139d4:	c1 e6 06             	shl    $0x6,%esi
   139d7:	83 ce 01             	or     $0x1,%esi
   139da:	e8 e5 38 ff ff       	callq  72c4 <log_0>
		return 0;
   139df:	e9 fd 00 00 00       	jmpq   13ae1 <bt_att_recv+0x135>
   139e4:	48 89 fb             	mov    %rdi,%rbx
	return net_buf_simple_pull_mem(&buf->b, len);
   139e7:	48 8d 7e 10          	lea    0x10(%rsi),%rdi
   139eb:	49 89 f6             	mov    %rsi,%r14
   139ee:	be 01 00 00 00       	mov    $0x1,%esi
   139f3:	e8 17 57 00 00       	callq  1910f <net_buf_simple_pull_mem>
	if (!att_chan->att) {
   139f8:	48 83 7b f8 00       	cmpq   $0x0,-0x8(%rbx)
   139fd:	48 89 c5             	mov    %rax,%rbp
   13a00:	0f 84 db 00 00 00    	je     13ae1 <bt_att_recv+0x135>
		if (hdr->code == handlers[i].op) {
   13a06:	0f b6 30             	movzbl (%rax),%esi
   13a09:	48 8d 05 50 1a 22 00 	lea    0x221a50(%rip),%rax        # 235460 <handlers>
	struct bt_att_chan *att_chan = ATT_CHAN(chan);
   13a10:	48 83 eb 08          	sub    $0x8,%rbx
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
   13a14:	45 31 e4             	xor    %r12d,%r12d
   13a17:	49 89 c5             	mov    %rax,%r13
		if (hdr->code == handlers[i].op) {
   13a1a:	4c 89 e2             	mov    %r12,%rdx
   13a1d:	48 c1 e2 04          	shl    $0x4,%rdx
   13a21:	40 3a 34 10          	cmp    (%rax,%rdx,1),%sil
   13a25:	75 3f                	jne    13a66 <bt_att_recv+0xba>
	if (buf->len < handler->expect_len) {
   13a27:	48 01 d0             	add    %rdx,%rax
   13a2a:	41 8b 7e 18          	mov    0x18(%r14),%edi
   13a2e:	0f b6 50 01          	movzbl 0x1(%rax),%edx
   13a32:	66 39 d7             	cmp    %dx,%di
   13a35:	73 3a                	jae    13a71 <bt_att_recv+0xc5>
   13a37:	48 8d 0d 32 69 22 00 	lea    0x226932(%rip),%rcx        # 23a370 <log_const_bt_att>
   13a3e:	48 2b 0d 0b 25 22 00 	sub    0x22250b(%rip),%rcx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Invalid len %u for code 0x%02x", buf->len, hdr->code);
   13a45:	40 0f b6 d6          	movzbl %sil,%edx
   13a49:	0f b7 f7             	movzwl %di,%esi
   13a4c:	48 8d 3d d4 f3 01 00 	lea    0x1f3d4(%rip),%rdi        # 32e27 <__func__.5785+0x21bf>
   13a53:	48 c1 e9 04          	shr    $0x4,%rcx
   13a57:	c1 e1 06             	shl    $0x6,%ecx
   13a5a:	83 c9 01             	or     $0x1,%ecx
   13a5d:	e8 d0 38 ff ff       	callq  7332 <log_2>
		err = BT_ATT_ERR_INVALID_PDU;
   13a62:	b0 04                	mov    $0x4,%al
   13a64:	eb 14                	jmp    13a7a <bt_att_recv+0xce>
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
   13a66:	49 ff c4             	inc    %r12
   13a69:	49 83 fc 1c          	cmp    $0x1c,%r12
   13a6d:	75 ab                	jne    13a1a <bt_att_recv+0x6e>
   13a6f:	eb 31                	jmp    13aa2 <bt_att_recv+0xf6>
		err = handler->func(att_chan, buf);
   13a71:	4c 89 f6             	mov    %r14,%rsi
   13a74:	48 89 df             	mov    %rbx,%rdi
   13a77:	ff 50 08             	callq  *0x8(%rax)
	if (handler->type == ATT_REQUEST && err) {
   13a7a:	49 c1 e4 04          	shl    $0x4,%r12
   13a7e:	43 80 7c 25 02 01    	cmpb   $0x1,0x2(%r13,%r12,1)
   13a84:	75 5b                	jne    13ae1 <bt_att_recv+0x135>
   13a86:	84 c0                	test   %al,%al
   13a88:	74 57                	je     13ae1 <bt_att_recv+0x135>
		send_err_rsp(att_chan, hdr->code, 0, err);
   13a8a:	0f b6 75 00          	movzbl 0x0(%rbp),%esi
	if (!req) {
   13a8e:	40 84 f6             	test   %sil,%sil
   13a91:	74 4e                	je     13ae1 <bt_att_recv+0x135>
		send_err_rsp(att_chan, hdr->code, 0, err);
   13a93:	0f b6 c8             	movzbl %al,%ecx
   13a96:	31 d2                	xor    %edx,%edx
   13a98:	48 89 df             	mov    %rbx,%rdi
   13a9b:	e8 a4 fe ff ff       	callq  13944 <send_err_rsp.part.11>
   13aa0:	eb 3f                	jmp    13ae1 <bt_att_recv+0x135>
   13aa2:	48 8d 15 c7 68 22 00 	lea    0x2268c7(%rip),%rdx        # 23a370 <log_const_bt_att>
   13aa9:	48 2b 15 a0 24 22 00 	sub    0x2224a0(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("Unhandled ATT code 0x%02x", hdr->code);
   13ab0:	48 8d 3d 8f f3 01 00 	lea    0x1f38f(%rip),%rdi        # 32e46 <__func__.5785+0x21de>
   13ab7:	48 c1 ea 04          	shr    $0x4,%rdx
   13abb:	c1 e2 06             	shl    $0x6,%edx
   13abe:	83 ca 02             	or     $0x2,%edx
   13ac1:	e8 2f 38 ff ff       	callq  72f5 <log_1>
		if (att_op_get_type(hdr->code) != ATT_COMMAND) {
   13ac6:	0f b6 75 00          	movzbl 0x0(%rbp),%esi
   13aca:	89 f7                	mov    %esi,%edi
   13acc:	e8 9f ec ff ff       	callq  12770 <att_op_get_type>
	if (!req) {
   13ad1:	40 84 f6             	test   %sil,%sil
   13ad4:	74 0b                	je     13ae1 <bt_att_recv+0x135>
   13ad6:	84 c0                	test   %al,%al
   13ad8:	74 07                	je     13ae1 <bt_att_recv+0x135>
   13ada:	b9 06 00 00 00       	mov    $0x6,%ecx
   13adf:	eb b5                	jmp    13a96 <bt_att_recv+0xea>
}
   13ae1:	5b                   	pop    %rbx
   13ae2:	31 c0                	xor    %eax,%eax
   13ae4:	5d                   	pop    %rbp
   13ae5:	41 5c                	pop    %r12
   13ae7:	41 5d                	pop    %r13
   13ae9:	41 5e                	pop    %r14
   13aeb:	c3                   	retq   

0000000000013aec <att_write_rsp>:
{
   13aec:	41 57                	push   %r15
   13aee:	41 56                	push   %r14
   13af0:	45 89 c6             	mov    %r8d,%r14d
   13af3:	41 55                	push   %r13
   13af5:	41 54                	push   %r12
   13af7:	41 89 f4             	mov    %esi,%r12d
   13afa:	55                   	push   %rbp
   13afb:	53                   	push   %rbx
   13afc:	48 89 fd             	mov    %rdi,%rbp
   13aff:	41 89 d5             	mov    %edx,%r13d
   13b02:	89 cb                	mov    %ecx,%ebx
   13b04:	48 83 ec 48          	sub    $0x48,%rsp
   13b08:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   13b0f:	00 00 
   13b11:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
   13b16:	31 c0                	xor    %eax,%eax
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
   13b18:	48 8b 07             	mov    (%rdi),%rax
   13b1b:	40 84 f6             	test   %sil,%sil
{
   13b1e:	4c 89 0c 24          	mov    %r9,(%rsp)
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
   13b22:	40 0f 95 c6          	setne  %sil
{
   13b26:	44 8b bc 24 80 00 00 	mov    0x80(%rsp),%r15d
   13b2d:	00 
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
   13b2e:	40 0f b6 f6          	movzbl %sil,%esi
   13b32:	48 8b 38             	mov    (%rax),%rdi
   13b35:	e8 9c 4c 00 00       	callq  187d6 <bt_gatt_change_aware>
   13b3a:	84 c0                	test   %al,%al
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
   13b3c:	41 b0 12             	mov    $0x12,%r8b
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
   13b3f:	0f 84 f6 00 00 00    	je     13c3b <att_write_rsp+0x14f>
	if (!handle) {
   13b45:	66 85 db             	test   %bx,%bx
		return BT_ATT_ERR_INVALID_HANDLE;
   13b48:	41 b0 01             	mov    $0x1,%r8b
	if (!handle) {
   13b4b:	4c 8b 0c 24          	mov    (%rsp),%r9
   13b4f:	0f 84 e6 00 00 00    	je     13c3b <att_write_rsp+0x14f>
   13b55:	48 8d 44 24 10       	lea    0x10(%rsp),%rax
   13b5a:	b9 0a 00 00 00       	mov    $0xa,%ecx
   13b5f:	0f b7 db             	movzwl %bx,%ebx
   13b62:	48 89 04 24          	mov    %rax,(%rsp)
   13b66:	48 8b 3c 24          	mov    (%rsp),%rdi
   13b6a:	31 c0                	xor    %eax,%eax
	if (rsp) {
   13b6c:	45 84 ed             	test   %r13b,%r13b
   13b6f:	f3 ab                	rep stos %eax,%es:(%rdi)
   13b71:	75 47                	jne    13bba <att_write_rsp+0xce>
	data.conn = chan->att->conn;
   13b73:	48 8b 45 00          	mov    0x0(%rbp),%rax
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
   13b77:	48 8b 0c 24          	mov    (%rsp),%rcx
   13b7b:	48 8d 15 64 fa ff ff 	lea    -0x59c(%rip),%rdx        # 135e6 <write_cb>
   13b82:	89 de                	mov    %ebx,%esi
   13b84:	89 df                	mov    %ebx,%edi
	data.conn = chan->att->conn;
   13b86:	48 8b 00             	mov    (%rax),%rax
	data.req = req;
   13b89:	44 88 64 24 20       	mov    %r12b,0x20(%rsp)
	data.offset = offset;
   13b8e:	66 44 89 74 24 32    	mov    %r14w,0x32(%rsp)
	data.value = value;
   13b94:	4c 89 4c 24 28       	mov    %r9,0x28(%rsp)
	data.len = len;
   13b99:	66 44 89 7c 24 30    	mov    %r15w,0x30(%rsp)
	data.err = BT_ATT_ERR_INVALID_HANDLE;
   13b9f:	c6 44 24 34 01       	movb   $0x1,0x34(%rsp)
	data.conn = chan->att->conn;
   13ba4:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
   13ba9:	e8 36 ed ff ff       	callq  128e4 <bt_gatt_foreach_attr>
	if (data.err) {
   13bae:	44 8a 44 24 34       	mov    0x34(%rsp),%r8b
   13bb3:	45 84 c0             	test   %r8b,%r8b
   13bb6:	75 29                	jne    13be1 <att_write_rsp+0xf5>
   13bb8:	eb 60                	jmp    13c1a <att_write_rsp+0x12e>
		data.buf = bt_att_chan_create_pdu(chan, rsp, 0);
   13bba:	31 d2                	xor    %edx,%edx
   13bbc:	41 0f b6 f5          	movzbl %r13b,%esi
   13bc0:	48 89 ef             	mov    %rbp,%rdi
   13bc3:	4c 89 4c 24 08       	mov    %r9,0x8(%rsp)
   13bc8:	e8 75 fc ff ff       	callq  13842 <bt_att_chan_create_pdu>
		if (!data.buf) {
   13bcd:	48 85 c0             	test   %rax,%rax
		data.buf = bt_att_chan_create_pdu(chan, rsp, 0);
   13bd0:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
			return BT_ATT_ERR_UNLIKELY;
   13bd5:	41 b0 0e             	mov    $0xe,%r8b
		if (!data.buf) {
   13bd8:	4c 8b 4c 24 08       	mov    0x8(%rsp),%r9
   13bdd:	75 94                	jne    13b73 <att_write_rsp+0x87>
   13bdf:	eb 5a                	jmp    13c3b <att_write_rsp+0x14f>
		if (rsp) {
   13be1:	45 84 ed             	test   %r13b,%r13b
   13be4:	74 27                	je     13c0d <att_write_rsp+0x121>
			net_buf_unref(data.buf);
   13be6:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
   13beb:	e8 aa 53 00 00       	callq  18f9a <net_buf_unref>
	if (!req) {
   13bf0:	45 84 e4             	test   %r12b,%r12b
   13bf3:	75 05                	jne    13bfa <att_write_rsp+0x10e>
		return req == BT_ATT_OP_EXEC_WRITE_REQ ? data.err : 0;
   13bf5:	45 31 c0             	xor    %r8d,%r8d
   13bf8:	eb 41                	jmp    13c3b <att_write_rsp+0x14f>
			send_err_rsp(chan, req, handle, data.err);
   13bfa:	0f b6 4c 24 34       	movzbl 0x34(%rsp),%ecx
   13bff:	41 0f b6 f4          	movzbl %r12b,%esi
   13c03:	89 da                	mov    %ebx,%edx
   13c05:	48 89 ef             	mov    %rbp,%rdi
   13c08:	e8 37 fd ff ff       	callq  13944 <send_err_rsp.part.11>
		return req == BT_ATT_OP_EXEC_WRITE_REQ ? data.err : 0;
   13c0d:	41 80 fc 18          	cmp    $0x18,%r12b
   13c11:	75 e2                	jne    13bf5 <att_write_rsp+0x109>
   13c13:	44 8a 44 24 34       	mov    0x34(%rsp),%r8b
   13c18:	eb 21                	jmp    13c3b <att_write_rsp+0x14f>
	if (data.buf) {
   13c1a:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
   13c1f:	44 88 04 24          	mov    %r8b,(%rsp)
   13c23:	48 85 f6             	test   %rsi,%rsi
   13c26:	74 cd                	je     13bf5 <att_write_rsp+0x109>
		bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
   13c28:	48 8d 15 44 f4 ff ff 	lea    -0xbbc(%rip),%rdx        # 13073 <chan_rsp_sent>
   13c2f:	48 89 ef             	mov    %rbp,%rdi
   13c32:	e8 9b f1 ff ff       	callq  12dd2 <bt_att_chan_send_rsp>
   13c37:	44 8a 04 24          	mov    (%rsp),%r8b
}
   13c3b:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
   13c40:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
   13c47:	00 00 
   13c49:	44 88 c0             	mov    %r8b,%al
   13c4c:	74 05                	je     13c53 <att_write_rsp+0x167>
   13c4e:	e8 ed 09 ff ff       	callq  4640 <__stack_chk_fail@plt>
   13c53:	48 83 c4 48          	add    $0x48,%rsp
   13c57:	5b                   	pop    %rbx
   13c58:	5d                   	pop    %rbp
   13c59:	41 5c                	pop    %r12
   13c5b:	41 5d                	pop    %r13
   13c5d:	41 5e                	pop    %r14
   13c5f:	41 5f                	pop    %r15
   13c61:	c3                   	retq   

0000000000013c62 <att_write_cmd>:
{
   13c62:	55                   	push   %rbp
   13c63:	53                   	push   %rbx
   13c64:	48 89 fd             	mov    %rdi,%rbp
	return net_buf_simple_pull_le16(&buf->b);
   13c67:	48 8d 7e 10          	lea    0x10(%rsi),%rdi
   13c6b:	48 89 f3             	mov    %rsi,%rbx
   13c6e:	48 83 ec 08          	sub    $0x8,%rsp
   13c72:	e8 a6 54 00 00       	callq  1911d <net_buf_simple_pull_le16>
	return att_write_rsp(chan, 0, 0, handle, 0, buf->data, buf->len);
   13c77:	0f b7 c8             	movzwl %ax,%ecx
   13c7a:	0f b7 43 18          	movzwl 0x18(%rbx),%eax
   13c7e:	48 83 ec 08          	sub    $0x8,%rsp
   13c82:	4c 8b 4b 10          	mov    0x10(%rbx),%r9
   13c86:	48 89 ef             	mov    %rbp,%rdi
   13c89:	45 31 c0             	xor    %r8d,%r8d
   13c8c:	31 d2                	xor    %edx,%edx
   13c8e:	31 f6                	xor    %esi,%esi
   13c90:	50                   	push   %rax
   13c91:	e8 56 fe ff ff       	callq  13aec <att_write_rsp>
}
   13c96:	48 83 c4 18          	add    $0x18,%rsp
   13c9a:	5b                   	pop    %rbx
   13c9b:	5d                   	pop    %rbp
   13c9c:	c3                   	retq   

0000000000013c9d <att_write_req>:
{
   13c9d:	55                   	push   %rbp
   13c9e:	53                   	push   %rbx
   13c9f:	48 89 fd             	mov    %rdi,%rbp
   13ca2:	48 8d 7e 10          	lea    0x10(%rsi),%rdi
   13ca6:	48 89 f3             	mov    %rsi,%rbx
   13ca9:	48 83 ec 08          	sub    $0x8,%rsp
   13cad:	e8 6b 54 00 00       	callq  1911d <net_buf_simple_pull_le16>
	return att_write_rsp(chan, BT_ATT_OP_WRITE_REQ, BT_ATT_OP_WRITE_RSP,
   13cb2:	0f b7 c8             	movzwl %ax,%ecx
   13cb5:	0f b7 43 18          	movzwl 0x18(%rbx),%eax
   13cb9:	48 83 ec 08          	sub    $0x8,%rsp
   13cbd:	4c 8b 4b 10          	mov    0x10(%rbx),%r9
   13cc1:	48 89 ef             	mov    %rbp,%rdi
   13cc4:	45 31 c0             	xor    %r8d,%r8d
   13cc7:	ba 13 00 00 00       	mov    $0x13,%edx
   13ccc:	be 12 00 00 00       	mov    $0x12,%esi
   13cd1:	50                   	push   %rax
   13cd2:	e8 15 fe ff ff       	callq  13aec <att_write_rsp>
}
   13cd7:	48 83 c4 18          	add    $0x18,%rsp
   13cdb:	5b                   	pop    %rbx
   13cdc:	5d                   	pop    %rbp
   13cdd:	c3                   	retq   

0000000000013cde <bt_att_create_pdu>:
{
   13cde:	53                   	push   %rbx
   13cdf:	89 f3                	mov    %esi,%ebx
   13ce1:	48 83 ec 10          	sub    $0x10,%rsp
   13ce5:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
	att = att_get(conn);
   13cea:	e8 60 f1 ff ff       	callq  12e4f <att_get>
	if (!att) {
   13cef:	48 85 c0             	test   %rax,%rax
   13cf2:	0f 84 8d 00 00 00    	je     13d85 <bt_att_create_pdu+0xa7>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   13cf8:	48 8b 40 78          	mov    0x78(%rax),%rax
   13cfc:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   13d01:	48 85 c0             	test   %rax,%rax
   13d04:	48 8d 72 01          	lea    0x1(%rdx),%rsi
   13d08:	75 26                	jne    13d30 <bt_att_create_pdu+0x52>
   13d0a:	48 8d 15 5f 66 22 00 	lea    0x22665f(%rip),%rdx        # 23a370 <log_const_bt_att>
   13d11:	48 2b 15 38 22 22 00 	sub    0x222238(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
	BT_WARN("No ATT channel for MTU %zu", len + sizeof(op));
   13d18:	48 8d 3d 41 f1 01 00 	lea    0x1f141(%rip),%rdi        # 32e60 <__func__.5785+0x21f8>
   13d1f:	48 c1 ea 04          	shr    $0x4,%rdx
   13d23:	c1 e2 06             	shl    $0x6,%edx
   13d26:	83 ca 02             	or     $0x2,%edx
   13d29:	e8 c7 35 ff ff       	callq  72f5 <log_1>
   13d2e:	eb 55                	jmp    13d85 <bt_att_create_pdu+0xa7>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   13d30:	48 89 c7             	mov    %rax,%rdi
   13d33:	48 81 ef e0 01 00 00 	sub    $0x1e0,%rdi
   13d3a:	74 ce                	je     13d0a <bt_att_create_pdu+0x2c>
	return node->next;
   13d3c:	48 8b 08             	mov    (%rax),%rcx
   13d3f:	31 c0                	xor    %eax,%eax
   13d41:	48 85 c9             	test   %rcx,%rcx
   13d44:	74 29                	je     13d6f <bt_att_create_pdu+0x91>
   13d46:	48 8d 81 20 fe ff ff 	lea    -0x1e0(%rcx),%rax
   13d4d:	eb 20                	jmp    13d6f <bt_att_create_pdu+0x91>
   13d4f:	48 85 c0             	test   %rax,%rax
   13d52:	74 b6                	je     13d0a <bt_att_create_pdu+0x2c>
   13d54:	48 8b b8 e0 01 00 00 	mov    0x1e0(%rax),%rdi
   13d5b:	31 c9                	xor    %ecx,%ecx
   13d5d:	48 85 ff             	test   %rdi,%rdi
   13d60:	74 07                	je     13d69 <bt_att_create_pdu+0x8b>
   13d62:	48 8d 8f 20 fe ff ff 	lea    -0x1e0(%rdi),%rcx
   13d69:	48 89 c7             	mov    %rax,%rdi
   13d6c:	48 89 c8             	mov    %rcx,%rax
		if (len + sizeof(op) > chan->chan.tx.mtu) {
   13d6f:	0f b7 4f 7e          	movzwl 0x7e(%rdi),%ecx
   13d73:	48 39 f1             	cmp    %rsi,%rcx
   13d76:	72 d7                	jb     13d4f <bt_att_create_pdu+0x71>
}
   13d78:	48 83 c4 10          	add    $0x10,%rsp
		return bt_att_chan_create_pdu(chan, op, len);
   13d7c:	0f b6 f3             	movzbl %bl,%esi
}
   13d7f:	5b                   	pop    %rbx
		return bt_att_chan_create_pdu(chan, op, len);
   13d80:	e9 bd fa ff ff       	jmpq   13842 <bt_att_chan_create_pdu>
}
   13d85:	48 83 c4 10          	add    $0x10,%rsp
   13d89:	31 c0                	xor    %eax,%eax
   13d8b:	5b                   	pop    %rbx
   13d8c:	c3                   	retq   

0000000000013d8d <att_exec_write_req>:
{
   13d8d:	41 56                	push   %r14
   13d8f:	41 55                	push   %r13
   13d91:	41 54                	push   %r12
   13d93:	55                   	push   %rbp
   13d94:	49 89 fc             	mov    %rdi,%r12
   13d97:	53                   	push   %rbx
	return att_exec_write_rsp(chan, req->flags);
   13d98:	48 8b 46 10          	mov    0x10(%rsi),%rax
	uint8_t err = 0U;
   13d9c:	31 db                	xor    %ebx,%ebx
	struct bt_conn *conn = chan->chan.chan.conn;
   13d9e:	4c 8b 6f 08          	mov    0x8(%rdi),%r13
	return att_exec_write_rsp(chan, req->flags);
   13da2:	44 8a 30             	mov    (%rax),%r14b
	while ((buf = net_buf_get(&chan->att->prep_queue, K_NO_WAIT))) {
   13da5:	49 8b 04 24          	mov    (%r12),%rax
   13da9:	31 f6                	xor    %esi,%esi
   13dab:	48 8d 78 48          	lea    0x48(%rax),%rdi
   13daf:	e8 73 51 00 00       	callq  18f27 <net_buf_get>
   13db4:	48 85 c0             	test   %rax,%rax
   13db7:	48 89 c5             	mov    %rax,%rbp
   13dba:	74 55                	je     13e11 <att_exec_write_req+0x84>
		if (!err && flags == BT_ATT_FLAG_EXEC) {
   13dbc:	84 db                	test   %bl,%bl
   13dbe:	75 47                	jne    13e07 <att_exec_write_req+0x7a>
   13dc0:	41 80 fe 01          	cmp    $0x1,%r14b
   13dc4:	75 41                	jne    13e07 <att_exec_write_req+0x7a>
			err = att_write_rsp(chan, BT_ATT_OP_EXEC_WRITE_REQ, 0,
   13dc6:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
   13dca:	0f b7 4d 28          	movzwl 0x28(%rbp),%ecx
   13dce:	48 83 ec 08          	sub    $0x8,%rsp
   13dd2:	44 0f b7 45 2a       	movzwl 0x2a(%rbp),%r8d
   13dd7:	4c 8b 4d 10          	mov    0x10(%rbp),%r9
   13ddb:	31 d2                	xor    %edx,%edx
   13ddd:	be 18 00 00 00       	mov    $0x18,%esi
   13de2:	4c 89 e7             	mov    %r12,%rdi
   13de5:	50                   	push   %rax
   13de6:	e8 01 fd ff ff       	callq  13aec <att_write_rsp>
			if (err) {
   13deb:	84 c0                	test   %al,%al
			err = att_write_rsp(chan, BT_ATT_OP_EXEC_WRITE_REQ, 0,
   13ded:	88 c3                	mov    %al,%bl
   13def:	5a                   	pop    %rdx
   13df0:	59                   	pop    %rcx
			if (err) {
   13df1:	74 14                	je     13e07 <att_exec_write_req+0x7a>
				send_err_rsp(chan, BT_ATT_OP_EXEC_WRITE_REQ,
   13df3:	0f b7 55 28          	movzwl 0x28(%rbp),%edx
   13df7:	0f b6 c8             	movzbl %al,%ecx
   13dfa:	be 18 00 00 00       	mov    $0x18,%esi
   13dff:	4c 89 e7             	mov    %r12,%rdi
   13e02:	e8 3d fb ff ff       	callq  13944 <send_err_rsp.part.11>
		net_buf_unref(buf);
   13e07:	48 89 ef             	mov    %rbp,%rdi
   13e0a:	e8 8b 51 00 00       	callq  18f9a <net_buf_unref>
   13e0f:	eb 94                	jmp    13da5 <att_exec_write_req+0x18>
	if (err) {
   13e11:	84 db                	test   %bl,%bl
   13e13:	75 28                	jne    13e3d <att_exec_write_req+0xb0>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_EXEC_WRITE_RSP, 0);
   13e15:	31 d2                	xor    %edx,%edx
   13e17:	be 19 00 00 00       	mov    $0x19,%esi
   13e1c:	4c 89 ef             	mov    %r13,%rdi
   13e1f:	e8 ba fe ff ff       	callq  13cde <bt_att_create_pdu>
	if (!buf) {
   13e24:	48 85 c0             	test   %rax,%rax
   13e27:	74 18                	je     13e41 <att_exec_write_req+0xb4>
	bt_att_chan_send_rsp(chan, buf, chan_rsp_sent);
   13e29:	48 8d 15 43 f2 ff ff 	lea    -0xdbd(%rip),%rdx        # 13073 <chan_rsp_sent>
   13e30:	48 89 c6             	mov    %rax,%rsi
   13e33:	4c 89 e7             	mov    %r12,%rdi
   13e36:	e8 97 ef ff ff       	callq  12dd2 <bt_att_chan_send_rsp>
   13e3b:	eb 06                	jmp    13e43 <att_exec_write_req+0xb6>
		return 0;
   13e3d:	31 db                	xor    %ebx,%ebx
   13e3f:	eb 02                	jmp    13e43 <att_exec_write_req+0xb6>
		return BT_ATT_ERR_UNLIKELY;
   13e41:	b3 0e                	mov    $0xe,%bl
}
   13e43:	88 d8                	mov    %bl,%al
   13e45:	5b                   	pop    %rbx
   13e46:	5d                   	pop    %rbp
   13e47:	41 5c                	pop    %r12
   13e49:	41 5d                	pop    %r13
   13e4b:	41 5e                	pop    %r14
   13e4d:	c3                   	retq   

0000000000013e4e <att_prepare_write_req>:
{
   13e4e:	41 57                	push   %r15
   13e50:	41 56                	push   %r14
   13e52:	41 55                	push   %r13
   13e54:	41 54                	push   %r12
   13e56:	49 89 f4             	mov    %rsi,%r12
   13e59:	55                   	push   %rbp
   13e5a:	53                   	push   %rbx
   13e5b:	48 89 fd             	mov    %rdi,%rbp
	return net_buf_simple_pull_mem(&buf->b, len);
   13e5e:	48 8d 7e 10          	lea    0x10(%rsi),%rdi
   13e62:	be 04 00 00 00       	mov    $0x4,%esi
   13e67:	48 83 ec 48          	sub    $0x48,%rsp
   13e6b:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   13e72:	00 00 
   13e74:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
   13e79:	31 c0                	xor    %eax,%eax
   13e7b:	e8 8f 52 00 00       	callq  1910f <net_buf_simple_pull_mem>
	struct bt_conn *conn = chan->chan.chan.conn;
   13e80:	4c 8b 75 08          	mov    0x8(%rbp),%r14
	handle = sys_le16_to_cpu(req->handle);
   13e84:	66 44 8b 28          	mov    (%rax),%r13w
	if (!bt_gatt_change_aware(conn, true)) {
   13e88:	be 01 00 00 00       	mov    $0x1,%esi
	offset = sys_le16_to_cpu(req->offset);
   13e8d:	66 44 8b 78 02       	mov    0x2(%rax),%r15w
	return att_prep_write_rsp(chan, handle, offset, buf->data, buf->len);
   13e92:	49 8b 44 24 10       	mov    0x10(%r12),%rax
   13e97:	41 8b 5c 24 18       	mov    0x18(%r12),%ebx
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
   13e9c:	41 b4 12             	mov    $0x12,%r12b
	if (!bt_gatt_change_aware(conn, true)) {
   13e9f:	4c 89 f7             	mov    %r14,%rdi
	return att_prep_write_rsp(chan, handle, offset, buf->data, buf->len);
   13ea2:	48 89 04 24          	mov    %rax,(%rsp)
	if (!bt_gatt_change_aware(conn, true)) {
   13ea6:	e8 2b 49 00 00       	callq  187d6 <bt_gatt_change_aware>
   13eab:	84 c0                	test   %al,%al
   13ead:	0f 84 0f 01 00 00    	je     13fc2 <att_prepare_write_req+0x174>
	if (!handle) {
   13eb3:	66 45 85 ed          	test   %r13w,%r13w
		return BT_ATT_ERR_INVALID_HANDLE;
   13eb7:	41 b4 01             	mov    $0x1,%r12b
	if (!handle) {
   13eba:	0f 84 02 01 00 00    	je     13fc2 <att_prepare_write_req+0x174>
   13ec0:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
   13ec5:	31 c0                	xor    %eax,%eax
   13ec7:	b9 06 00 00 00       	mov    $0x6,%ecx
   13ecc:	48 8d 54 24 18       	lea    0x18(%rsp),%rdx
	return att_prep_write_rsp(chan, handle, offset, buf->data, buf->len);
   13ed1:	45 0f b7 cd          	movzwl %r13w,%r9d
	data.conn = conn;
   13ed5:	4c 89 74 24 18       	mov    %r14,0x18(%rsp)
   13eda:	48 89 f7             	mov    %rsi,%rdi
	bt_gatt_foreach_attr(handle, handle, prep_write_cb, &data);
   13edd:	44 89 ce             	mov    %r9d,%esi
   13ee0:	44 89 4c 24 0c       	mov    %r9d,0xc(%rsp)
   13ee5:	f3 ab                	rep stos %eax,%es:(%rdi)
	data.value = value;
   13ee7:	48 8b 04 24          	mov    (%rsp),%rax
	bt_gatt_foreach_attr(handle, handle, prep_write_cb, &data);
   13eeb:	48 89 d1             	mov    %rdx,%rcx
   13eee:	48 8d 15 6b f7 ff ff 	lea    -0x895(%rip),%rdx        # 13660 <prep_write_cb>
   13ef5:	44 89 cf             	mov    %r9d,%edi
	data.offset = offset;
   13ef8:	66 44 89 7c 24 32    	mov    %r15w,0x32(%rsp)
	data.err = BT_ATT_ERR_INVALID_HANDLE;
   13efe:	c6 44 24 34 01       	movb   $0x1,0x34(%rsp)
	data.value = value;
   13f03:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
	data.len = len;
   13f08:	0f b6 c3             	movzbl %bl,%eax
   13f0b:	66 89 44 24 30       	mov    %ax,0x30(%rsp)
	bt_gatt_foreach_attr(handle, handle, prep_write_cb, &data);
   13f10:	e8 cf e9 ff ff       	callq  128e4 <bt_gatt_foreach_attr>
	if (data.err) {
   13f15:	44 8a 64 24 34       	mov    0x34(%rsp),%r12b
   13f1a:	45 84 e4             	test   %r12b,%r12b
   13f1d:	74 21                	je     13f40 <att_prepare_write_req+0xf2>
   13f1f:	44 8b 4c 24 0c       	mov    0xc(%rsp),%r9d
		send_err_rsp(chan, BT_ATT_OP_PREPARE_WRITE_REQ, handle,
   13f24:	41 0f b6 cc          	movzbl %r12b,%ecx
   13f28:	be 16 00 00 00       	mov    $0x16,%esi
   13f2d:	48 89 ef             	mov    %rbp,%rdi
		return 0;
   13f30:	45 31 e4             	xor    %r12d,%r12d
   13f33:	44 89 ca             	mov    %r9d,%edx
   13f36:	e8 09 fa ff ff       	callq  13944 <send_err_rsp.part.11>
   13f3b:	e9 82 00 00 00       	jmpq   13fc2 <att_prepare_write_req+0x174>
	net_buf_put(&chan->att->prep_queue, data.buf);
   13f40:	48 8b 45 00          	mov    0x0(%rbp),%rax
   13f44:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
   13f49:	48 8d 78 48          	lea    0x48(%rax),%rdi
   13f4d:	e8 2f 50 00 00       	callq  18f81 <net_buf_put>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_PREPARE_WRITE_RSP, 0);
   13f52:	31 d2                	xor    %edx,%edx
   13f54:	be 17 00 00 00       	mov    $0x17,%esi
   13f59:	4c 89 f7             	mov    %r14,%rdi
   13f5c:	e8 7d fd ff ff       	callq  13cde <bt_att_create_pdu>
	if (!data.buf) {
   13f61:	48 85 c0             	test   %rax,%rax
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_PREPARE_WRITE_RSP, 0);
   13f64:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
	if (!data.buf) {
   13f69:	74 54                	je     13fbf <att_prepare_write_req+0x171>
	return net_buf_simple_add(&buf->b, len);
   13f6b:	48 8d 78 10          	lea    0x10(%rax),%rdi
   13f6f:	be 04 00 00 00       	mov    $0x4,%esi
	net_buf_add(data.buf, len);
   13f74:	0f b6 db             	movzbl %bl,%ebx
   13f77:	e8 0d 51 00 00       	callq  19089 <net_buf_simple_add>
	rsp->handle = sys_cpu_to_le16(handle);
   13f7c:	66 44 89 28          	mov    %r13w,(%rax)
	rsp->offset = sys_cpu_to_le16(offset);
   13f80:	66 44 89 78 02       	mov    %r15w,0x2(%rax)
   13f85:	49 89 c6             	mov    %rax,%r14
   13f88:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
   13f8d:	48 89 de             	mov    %rbx,%rsi
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
   13f90:	49 83 c6 04          	add    $0x4,%r14
   13f94:	48 8d 78 10          	lea    0x10(%rax),%rdi
   13f98:	e8 ec 50 00 00       	callq  19089 <net_buf_simple_add>
   13f9d:	4c 89 f7             	mov    %r14,%rdi
   13fa0:	48 8b 34 24          	mov    (%rsp),%rsi
   13fa4:	48 89 d9             	mov    %rbx,%rcx
   13fa7:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
   13fa9:	48 8d 15 c3 f0 ff ff 	lea    -0xf3d(%rip),%rdx        # 13073 <chan_rsp_sent>
   13fb0:	48 89 ef             	mov    %rbp,%rdi
   13fb3:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
   13fb8:	e8 15 ee ff ff       	callq  12dd2 <bt_att_chan_send_rsp>
   13fbd:	eb 03                	jmp    13fc2 <att_prepare_write_req+0x174>
		return BT_ATT_ERR_UNLIKELY;
   13fbf:	41 b4 0e             	mov    $0xe,%r12b
}
   13fc2:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
   13fc7:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
   13fce:	00 00 
   13fd0:	44 88 e0             	mov    %r12b,%al
   13fd3:	74 05                	je     13fda <att_prepare_write_req+0x18c>
   13fd5:	e8 66 06 ff ff       	callq  4640 <__stack_chk_fail@plt>
   13fda:	48 83 c4 48          	add    $0x48,%rsp
   13fde:	5b                   	pop    %rbx
   13fdf:	5d                   	pop    %rbp
   13fe0:	41 5c                	pop    %r12
   13fe2:	41 5d                	pop    %r13
   13fe4:	41 5e                	pop    %r14
   13fe6:	41 5f                	pop    %r15
   13fe8:	c3                   	retq   

0000000000013fe9 <att_read_group_req>:
{
   13fe9:	41 57                	push   %r15
   13feb:	41 56                	push   %r14
   13fed:	41 55                	push   %r13
   13fef:	41 54                	push   %r12
   13ff1:	49 89 fd             	mov    %rdi,%r13
   13ff4:	55                   	push   %rbp
   13ff5:	53                   	push   %rbx
   13ff6:	48 83 ec 58          	sub    $0x58,%rsp
   13ffa:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   14001:	00 00 
   14003:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
   14008:	31 c0                	xor    %eax,%eax
	uint8_t uuid_len = buf->len - sizeof(*req);
   1400a:	8a 46 18             	mov    0x18(%rsi),%al
   1400d:	44 8d 60 fc          	lea    -0x4(%rax),%r12d
	if (uuid_len != 2 && uuid_len != 16) {
   14011:	41 80 fc 02          	cmp    $0x2,%r12b
   14015:	74 0c                	je     14023 <att_read_group_req+0x3a>
   14017:	41 80 fc 10          	cmp    $0x10,%r12b
		return BT_ATT_ERR_INVALID_PDU;
   1401b:	b3 04                	mov    $0x4,%bl
	if (uuid_len != 2 && uuid_len != 16) {
   1401d:	0f 85 51 01 00 00    	jne    14174 <att_read_group_req+0x18b>
	return net_buf_simple_pull_mem(&buf->b, len);
   14023:	48 8d 7e 10          	lea    0x10(%rsi),%rdi
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
   14027:	4c 8d 7c 24 36       	lea    0x36(%rsp),%r15
   1402c:	be 04 00 00 00       	mov    $0x4,%esi
		return BT_ATT_ERR_UNLIKELY;
   14031:	b3 0e                	mov    $0xe,%bl
   14033:	e8 d7 50 00 00       	callq  1910f <net_buf_simple_pull_mem>
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
   14038:	48 8d 70 04          	lea    0x4(%rax),%rsi
   1403c:	41 0f b6 d4          	movzbl %r12b,%edx
   14040:	4c 89 ff             	mov    %r15,%rdi
	start_handle = sys_le16_to_cpu(req->start_handle);
   14043:	0f b7 28             	movzwl (%rax),%ebp
	end_handle = sys_le16_to_cpu(req->end_handle);
   14046:	66 44 8b 70 02       	mov    0x2(%rax),%r14w
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
   1404b:	e8 93 95 ff ff       	callq  d5e3 <bt_uuid_create>
   14050:	84 c0                	test   %al,%al
   14052:	0f 84 1c 01 00 00    	je     14174 <att_read_group_req+0x18b>
	if (!start || !end) {
   14058:	66 85 ed             	test   %bp,%bp
   1405b:	74 2b                	je     14088 <att_read_group_req+0x9f>
   1405d:	66 45 85 f6          	test   %r14w,%r14w
   14061:	74 25                	je     14088 <att_read_group_req+0x9f>
	if (start > end) {
   14063:	66 44 39 f5          	cmp    %r14w,%bp
   14067:	77 21                	ja     1408a <att_read_group_req+0xa1>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
   14069:	48 8d 74 24 2e       	lea    0x2e(%rsp),%rsi
   1406e:	4c 89 ff             	mov    %r15,%rdi
   14071:	c6 44 24 2e 00       	movb   $0x0,0x2e(%rsp)
   14076:	66 c7 44 24 30 00 28 	movw   $0x2800,0x30(%rsp)
   1407d:	e8 cb 94 ff ff       	callq  d54d <bt_uuid_cmp>
   14082:	85 c0                	test   %eax,%eax
   14084:	75 0e                	jne    14094 <att_read_group_req+0xab>
   14086:	eb 42                	jmp    140ca <att_read_group_req+0xe1>
			*err = 0U;
   14088:	31 ed                	xor    %ebp,%ebp
		send_err_rsp(chan, BT_ATT_OP_READ_GROUP_REQ, err_handle,
   1408a:	0f b7 d5             	movzwl %bp,%edx
   1408d:	b9 01 00 00 00       	mov    $0x1,%ecx
   14092:	eb 24                	jmp    140b8 <att_read_group_req+0xcf>
	    bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY)) {
   14094:	48 8d 74 24 32       	lea    0x32(%rsp),%rsi
   14099:	4c 89 ff             	mov    %r15,%rdi
   1409c:	c6 44 24 32 00       	movb   $0x0,0x32(%rsp)
   140a1:	66 c7 44 24 34 01 28 	movw   $0x2801,0x34(%rsp)
   140a8:	e8 a0 94 ff ff       	callq  d54d <bt_uuid_cmp>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
   140ad:	85 c0                	test   %eax,%eax
   140af:	74 19                	je     140ca <att_read_group_req+0xe1>
   140b1:	b9 10 00 00 00       	mov    $0x10,%ecx
   140b6:	89 ea                	mov    %ebp,%edx
   140b8:	be 10 00 00 00       	mov    $0x10,%esi
   140bd:	4c 89 ef             	mov    %r13,%rdi
   140c0:	e8 7f f8 ff ff       	callq  13944 <send_err_rsp.part.11>
   140c5:	e9 a8 00 00 00       	jmpq   14172 <att_read_group_req+0x189>
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
   140ca:	49 89 e4             	mov    %rsp,%r12
   140cd:	31 c0                	xor    %eax,%eax
   140cf:	b9 0a 00 00 00       	mov    $0xa,%ecx
   140d4:	4c 89 e7             	mov    %r12,%rdi
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_GROUP_RSP,
   140d7:	ba 01 00 00 00       	mov    $0x1,%edx
   140dc:	be 11 00 00 00       	mov    $0x11,%esi
   140e1:	f3 ab                	rep stos %eax,%es:(%rdi)
   140e3:	49 8b 7d 08          	mov    0x8(%r13),%rdi
		return BT_ATT_ERR_UNLIKELY;
   140e7:	b3 0e                	mov    $0xe,%bl
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_GROUP_RSP,
   140e9:	e8 f0 fb ff ff       	callq  13cde <bt_att_create_pdu>
	if (!data.buf) {
   140ee:	48 85 c0             	test   %rax,%rax
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_GROUP_RSP,
   140f1:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
	if (!data.buf) {
   140f6:	74 7c                	je     14174 <att_read_group_req+0x18b>
	return net_buf_simple_add(&buf->b, len);
   140f8:	48 8d 78 10          	lea    0x10(%rax),%rdi
   140fc:	be 01 00 00 00       	mov    $0x1,%esi
	data.chan = chan;
   14101:	4c 89 2c 24          	mov    %r13,(%rsp)
	data.uuid = uuid;
   14105:	4c 89 7c 24 08       	mov    %r15,0x8(%rsp)
   1410a:	e8 7a 4f 00 00       	callq  19089 <net_buf_simple_add>
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
   1410f:	48 8d 15 94 f1 ff ff 	lea    -0xe6c(%rip),%rdx        # 132aa <read_group_cb>
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
   14116:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
	if (!range_is_valid(start_handle, end_handle, &err_handle)) {
   1411b:	41 0f b7 f6          	movzwl %r14w,%esi
	data.rsp->len = 0U;
   1411f:	c6 00 00             	movb   $0x0,(%rax)
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
   14122:	4c 89 e1             	mov    %r12,%rcx
   14125:	89 ef                	mov    %ebp,%edi
	data.group = NULL;
   14127:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
   1412e:	00 00 
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
   14130:	e8 af e7 ff ff       	callq  128e4 <bt_gatt_foreach_attr>
	if (!data.rsp->len) {
   14135:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
   1413a:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
   1413f:	8a 18                	mov    (%rax),%bl
   14141:	84 db                	test   %bl,%bl
   14143:	75 1e                	jne    14163 <att_read_group_req+0x17a>
		net_buf_unref(data.buf);
   14145:	48 89 f7             	mov    %rsi,%rdi
   14148:	e8 4d 4e 00 00       	callq  18f9a <net_buf_unref>
   1414d:	b9 0a 00 00 00       	mov    $0xa,%ecx
   14152:	89 ea                	mov    %ebp,%edx
   14154:	be 10 00 00 00       	mov    $0x10,%esi
   14159:	4c 89 ef             	mov    %r13,%rdi
   1415c:	e8 e3 f7 ff ff       	callq  13944 <send_err_rsp.part.11>
   14161:	eb 11                	jmp    14174 <att_read_group_req+0x18b>
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
   14163:	48 8d 15 09 ef ff ff 	lea    -0x10f7(%rip),%rdx        # 13073 <chan_rsp_sent>
   1416a:	4c 89 ef             	mov    %r13,%rdi
   1416d:	e8 60 ec ff ff       	callq  12dd2 <bt_att_chan_send_rsp>
	return 0;
   14172:	31 db                	xor    %ebx,%ebx
}
   14174:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
   14179:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   14180:	00 00 
   14182:	88 d8                	mov    %bl,%al
   14184:	74 05                	je     1418b <att_read_group_req+0x1a2>
   14186:	e8 b5 04 ff ff       	callq  4640 <__stack_chk_fail@plt>
   1418b:	48 83 c4 58          	add    $0x58,%rsp
   1418f:	5b                   	pop    %rbx
   14190:	5d                   	pop    %rbp
   14191:	41 5c                	pop    %r12
   14193:	41 5d                	pop    %r13
   14195:	41 5e                	pop    %r14
   14197:	41 5f                	pop    %r15
   14199:	c3                   	retq   

000000000001419a <att_read_mult_req>:
{
   1419a:	41 56                	push   %r14
   1419c:	41 55                	push   %r13
   1419e:	b9 08 00 00 00       	mov    $0x8,%ecx
   141a3:	41 54                	push   %r12
   141a5:	55                   	push   %rbp
   141a6:	48 89 fd             	mov    %rdi,%rbp
   141a9:	53                   	push   %rbx
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_RSP, 0);
   141aa:	31 d2                	xor    %edx,%edx
{
   141ac:	49 89 f5             	mov    %rsi,%r13
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_RSP, 0);
   141af:	be 0f 00 00 00       	mov    $0xf,%esi
{
   141b4:	48 83 ec 30          	sub    $0x30,%rsp
   141b8:	4c 8d 64 24 08       	lea    0x8(%rsp),%r12
   141bd:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   141c4:	00 00 
   141c6:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
   141cb:	31 c0                	xor    %eax,%eax
   141cd:	4c 89 e7             	mov    %r12,%rdi
   141d0:	f3 ab                	rep stos %eax,%es:(%rdi)
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_RSP, 0);
   141d2:	48 8b 7d 08          	mov    0x8(%rbp),%rdi
   141d6:	e8 03 fb ff ff       	callq  13cde <bt_att_create_pdu>
	if (!data.buf) {
   141db:	48 85 c0             	test   %rax,%rax
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_RSP, 0);
   141de:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
		return BT_ATT_ERR_UNLIKELY;
   141e3:	b2 0e                	mov    $0xe,%dl
	if (!data.buf) {
   141e5:	74 71                	je     14258 <att_read_mult_req+0xbe>
	return net_buf_simple_pull_le16(&buf->b);
   141e7:	4d 8d 75 10          	lea    0x10(%r13),%r14
	data.chan = chan;
   141eb:	48 89 6c 24 08       	mov    %rbp,0x8(%rsp)
	while (buf->len >= sizeof(uint16_t)) {
   141f0:	66 41 83 7d 18 01    	cmpw   $0x1,0x18(%r13)
   141f6:	76 4a                	jbe    14242 <att_read_mult_req+0xa8>
   141f8:	4c 89 f7             	mov    %r14,%rdi
   141fb:	e8 1d 4f 00 00       	callq  1911d <net_buf_simple_pull_le16>
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
   14200:	48 8d 15 15 f5 ff ff 	lea    -0xaeb(%rip),%rdx        # 1371c <read_cb>
   14207:	0f b7 d8             	movzwl %ax,%ebx
   1420a:	4c 89 e1             	mov    %r12,%rcx
   1420d:	89 de                	mov    %ebx,%esi
   1420f:	89 df                	mov    %ebx,%edi
		data.err = BT_ATT_ERR_INVALID_HANDLE;
   14211:	c6 44 24 20 01       	movb   $0x1,0x20(%rsp)
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
   14216:	e8 c9 e6 ff ff       	callq  128e4 <bt_gatt_foreach_attr>
		if (data.err) {
   1421b:	80 7c 24 20 00       	cmpb   $0x0,0x20(%rsp)
   14220:	74 ce                	je     141f0 <att_read_mult_req+0x56>
			net_buf_unref(data.buf);
   14222:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
   14227:	e8 6e 4d 00 00       	callq  18f9a <net_buf_unref>
			send_err_rsp(chan, BT_ATT_OP_READ_MULT_REQ, handle,
   1422c:	0f b6 4c 24 20       	movzbl 0x20(%rsp),%ecx
   14231:	89 da                	mov    %ebx,%edx
   14233:	be 0e 00 00 00       	mov    $0xe,%esi
   14238:	48 89 ef             	mov    %rbp,%rdi
   1423b:	e8 04 f7 ff ff       	callq  13944 <send_err_rsp.part.11>
   14240:	eb 14                	jmp    14256 <att_read_mult_req+0xbc>
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
   14242:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
   14247:	48 8d 15 25 ee ff ff 	lea    -0x11db(%rip),%rdx        # 13073 <chan_rsp_sent>
   1424e:	48 89 ef             	mov    %rbp,%rdi
   14251:	e8 7c eb ff ff       	callq  12dd2 <bt_att_chan_send_rsp>
	return 0;
   14256:	31 d2                	xor    %edx,%edx
}
   14258:	48 8b 5c 24 28       	mov    0x28(%rsp),%rbx
   1425d:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
   14264:	00 00 
   14266:	88 d0                	mov    %dl,%al
   14268:	74 05                	je     1426f <att_read_mult_req+0xd5>
   1426a:	e8 d1 03 ff ff       	callq  4640 <__stack_chk_fail@plt>
   1426f:	48 83 c4 30          	add    $0x30,%rsp
   14273:	5b                   	pop    %rbx
   14274:	5d                   	pop    %rbp
   14275:	41 5c                	pop    %r12
   14277:	41 5d                	pop    %r13
   14279:	41 5e                	pop    %r14
   1427b:	c3                   	retq   

000000000001427c <att_read_rsp>:
{
   1427c:	41 57                	push   %r15
   1427e:	41 56                	push   %r14
   14280:	41 89 d7             	mov    %edx,%r15d
   14283:	41 55                	push   %r13
   14285:	41 54                	push   %r12
   14287:	49 89 fc             	mov    %rdi,%r12
   1428a:	55                   	push   %rbp
   1428b:	53                   	push   %rbx
   1428c:	89 cd                	mov    %ecx,%ebp
   1428e:	45 89 c5             	mov    %r8d,%r13d
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
   14291:	b3 12                	mov    $0x12,%bl
{
   14293:	48 83 ec 48          	sub    $0x48,%rsp
	struct bt_conn *conn = chan->chan.chan.conn;
   14297:	4c 8b 77 08          	mov    0x8(%rdi),%r14
{
   1429b:	89 74 24 0c          	mov    %esi,0xc(%rsp)
	if (!bt_gatt_change_aware(conn, true)) {
   1429f:	be 01 00 00 00       	mov    $0x1,%esi
{
   142a4:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   142ab:	00 00 
   142ad:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
   142b2:	31 c0                	xor    %eax,%eax
	if (!bt_gatt_change_aware(conn, true)) {
   142b4:	4c 89 f7             	mov    %r14,%rdi
   142b7:	e8 1a 45 00 00       	callq  187d6 <bt_gatt_change_aware>
   142bc:	84 c0                	test   %al,%al
   142be:	0f 84 9e 00 00 00    	je     14362 <att_read_rsp+0xe6>
	if (!handle) {
   142c4:	66 85 ed             	test   %bp,%bp
		return BT_ATT_ERR_INVALID_HANDLE;
   142c7:	b3 01                	mov    $0x1,%bl
	if (!handle) {
   142c9:	0f 84 93 00 00 00    	je     14362 <att_read_rsp+0xe6>
   142cf:	48 8d 44 24 18       	lea    0x18(%rsp),%rax
   142d4:	b9 08 00 00 00       	mov    $0x8,%ecx
	data.buf = bt_att_create_pdu(conn, rsp, 0);
   142d9:	31 d2                	xor    %edx,%edx
   142db:	41 0f b6 f7          	movzbl %r15b,%esi
		return BT_ATT_ERR_UNLIKELY;
   142df:	b3 0e                	mov    $0xe,%bl
   142e1:	48 89 04 24          	mov    %rax,(%rsp)
   142e5:	48 8b 3c 24          	mov    (%rsp),%rdi
   142e9:	31 c0                	xor    %eax,%eax
   142eb:	f3 ab                	rep stos %eax,%es:(%rdi)
	data.buf = bt_att_create_pdu(conn, rsp, 0);
   142ed:	4c 89 f7             	mov    %r14,%rdi
   142f0:	e8 e9 f9 ff ff       	callq  13cde <bt_att_create_pdu>
	if (!data.buf) {
   142f5:	48 85 c0             	test   %rax,%rax
	data.buf = bt_att_create_pdu(conn, rsp, 0);
   142f8:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
	if (!data.buf) {
   142fd:	74 63                	je     14362 <att_read_rsp+0xe6>
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
   142ff:	48 8b 0c 24          	mov    (%rsp),%rcx
   14303:	0f b7 ed             	movzwl %bp,%ebp
   14306:	48 8d 15 0f f4 ff ff 	lea    -0xbf1(%rip),%rdx        # 1371c <read_cb>
   1430d:	89 ee                	mov    %ebp,%esi
   1430f:	89 ef                	mov    %ebp,%edi
	data.chan = chan;
   14311:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
	data.offset = offset;
   14316:	66 44 89 6c 24 20    	mov    %r13w,0x20(%rsp)
	data.err = BT_ATT_ERR_INVALID_HANDLE;
   1431c:	c6 44 24 30 01       	movb   $0x1,0x30(%rsp)
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
   14321:	e8 be e5 ff ff       	callq  128e4 <bt_gatt_foreach_attr>
	if (data.err) {
   14326:	8a 5c 24 30          	mov    0x30(%rsp),%bl
   1432a:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
   1432f:	84 db                	test   %bl,%bl
   14331:	74 20                	je     14353 <att_read_rsp+0xd7>
		net_buf_unref(data.buf);
   14333:	48 89 f7             	mov    %rsi,%rdi
		return 0;
   14336:	31 db                	xor    %ebx,%ebx
		net_buf_unref(data.buf);
   14338:	e8 5d 4c 00 00       	callq  18f9a <net_buf_unref>
		send_err_rsp(chan, op, handle, data.err);
   1433d:	0f b6 4c 24 30       	movzbl 0x30(%rsp),%ecx
   14342:	0f b6 74 24 0c       	movzbl 0xc(%rsp),%esi
   14347:	89 ea                	mov    %ebp,%edx
   14349:	4c 89 e7             	mov    %r12,%rdi
   1434c:	e8 f3 f5 ff ff       	callq  13944 <send_err_rsp.part.11>
   14351:	eb 0f                	jmp    14362 <att_read_rsp+0xe6>
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
   14353:	48 8d 15 19 ed ff ff 	lea    -0x12e7(%rip),%rdx        # 13073 <chan_rsp_sent>
   1435a:	4c 89 e7             	mov    %r12,%rdi
   1435d:	e8 70 ea ff ff       	callq  12dd2 <bt_att_chan_send_rsp>
}
   14362:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
   14367:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
   1436e:	00 00 
   14370:	88 d8                	mov    %bl,%al
   14372:	74 05                	je     14379 <att_read_rsp+0xfd>
   14374:	e8 c7 02 ff ff       	callq  4640 <__stack_chk_fail@plt>
   14379:	48 83 c4 48          	add    $0x48,%rsp
   1437d:	5b                   	pop    %rbx
   1437e:	5d                   	pop    %rbp
   1437f:	41 5c                	pop    %r12
   14381:	41 5d                	pop    %r13
   14383:	41 5e                	pop    %r14
   14385:	41 5f                	pop    %r15
   14387:	c3                   	retq   

0000000000014388 <att_read_blob_req>:
	req = (void *)buf->data;
   14388:	48 8b 46 10          	mov    0x10(%rsi),%rax
	return att_read_rsp(chan, BT_ATT_OP_READ_BLOB_REQ,
   1438c:	ba 0d 00 00 00       	mov    $0xd,%edx
   14391:	be 0c 00 00 00       	mov    $0xc,%esi
   14396:	0f b7 08             	movzwl (%rax),%ecx
   14399:	44 0f b7 40 02       	movzwl 0x2(%rax),%r8d
   1439e:	e9 d9 fe ff ff       	jmpq   1427c <att_read_rsp>

00000000000143a3 <att_read_req>:
	handle = sys_le16_to_cpu(req->handle);
   143a3:	48 8b 46 10          	mov    0x10(%rsi),%rax
	return att_read_rsp(chan, BT_ATT_OP_READ_REQ, BT_ATT_OP_READ_RSP,
   143a7:	45 31 c0             	xor    %r8d,%r8d
   143aa:	ba 0b 00 00 00       	mov    $0xb,%edx
   143af:	be 0a 00 00 00       	mov    $0xa,%esi
   143b4:	0f b7 08             	movzwl (%rax),%ecx
   143b7:	e9 c0 fe ff ff       	jmpq   1427c <att_read_rsp>

00000000000143bc <att_read_type_req>:
{
   143bc:	41 57                	push   %r15
   143be:	41 56                	push   %r14
   143c0:	41 55                	push   %r13
   143c2:	41 54                	push   %r12
   143c4:	49 89 fc             	mov    %rdi,%r12
   143c7:	55                   	push   %rbp
   143c8:	53                   	push   %rbx
   143c9:	48 83 ec 58          	sub    $0x58,%rsp
   143cd:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   143d4:	00 00 
   143d6:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
   143db:	31 c0                	xor    %eax,%eax
	uint8_t uuid_len = buf->len - sizeof(*req);
   143dd:	8a 46 18             	mov    0x18(%rsi),%al
   143e0:	8d 68 fc             	lea    -0x4(%rax),%ebp
	if (uuid_len != 2 && uuid_len != 16) {
   143e3:	40 80 fd 02          	cmp    $0x2,%bpl
   143e7:	74 0d                	je     143f6 <att_read_type_req+0x3a>
   143e9:	40 80 fd 10          	cmp    $0x10,%bpl
		return BT_ATT_ERR_INVALID_PDU;
   143ed:	41 b7 04             	mov    $0x4,%r15b
	if (uuid_len != 2 && uuid_len != 16) {
   143f0:	0f 85 fd 00 00 00    	jne    144f3 <att_read_type_req+0x137>
	return net_buf_simple_pull_mem(&buf->b, len);
   143f6:	48 8d 7e 10          	lea    0x10(%rsi),%rdi
   143fa:	be 04 00 00 00       	mov    $0x4,%esi
		return BT_ATT_ERR_UNLIKELY;
   143ff:	41 b7 0e             	mov    $0xe,%r15b
   14402:	e8 08 4d 00 00       	callq  1910f <net_buf_simple_pull_mem>
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
   14407:	40 0f b6 d5          	movzbl %bpl,%edx
   1440b:	48 8d 6c 24 36       	lea    0x36(%rsp),%rbp
   14410:	48 8d 70 04          	lea    0x4(%rax),%rsi
	start_handle = sys_le16_to_cpu(req->start_handle);
   14414:	0f b7 18             	movzwl (%rax),%ebx
	end_handle = sys_le16_to_cpu(req->end_handle);
   14417:	66 44 8b 68 02       	mov    0x2(%rax),%r13w
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
   1441c:	48 89 ef             	mov    %rbp,%rdi
   1441f:	e8 bf 91 ff ff       	callq  d5e3 <bt_uuid_create>
   14424:	84 c0                	test   %al,%al
   14426:	0f 84 c7 00 00 00    	je     144f3 <att_read_type_req+0x137>
	if (!start || !end) {
   1442c:	66 85 db             	test   %bx,%bx
   1442f:	74 3e                	je     1446f <att_read_type_req+0xb3>
   14431:	66 45 85 ed          	test   %r13w,%r13w
   14435:	74 38                	je     1446f <att_read_type_req+0xb3>
	if (start > end) {
   14437:	66 44 39 eb          	cmp    %r13w,%bx
   1443b:	77 34                	ja     14471 <att_read_type_req+0xb5>
   1443d:	49 89 e6             	mov    %rsp,%r14
   14440:	31 c0                	xor    %eax,%eax
   14442:	b9 0c 00 00 00       	mov    $0xc,%ecx
   14447:	4c 89 f7             	mov    %r14,%rdi
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_RSP,
   1444a:	ba 01 00 00 00       	mov    $0x1,%edx
   1444f:	be 09 00 00 00       	mov    $0x9,%esi
   14454:	f3 ab                	rep stos %eax,%es:(%rdi)
   14456:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
   1445b:	e8 7e f8 ff ff       	callq  13cde <bt_att_create_pdu>
	if (!data.buf) {
   14460:	48 85 c0             	test   %rax,%rax
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_RSP,
   14463:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
	if (!data.buf) {
   14468:	75 11                	jne    1447b <att_read_type_req+0xbf>
   1446a:	e9 84 00 00 00       	jmpq   144f3 <att_read_type_req+0x137>
			*err = 0U;
   1446f:	31 db                	xor    %ebx,%ebx
		send_err_rsp(chan, BT_ATT_OP_READ_TYPE_REQ, err_handle,
   14471:	0f b7 d3             	movzwl %bx,%edx
   14474:	b9 01 00 00 00       	mov    $0x1,%ecx
   14479:	eb 57                	jmp    144d2 <att_read_type_req+0x116>
	return net_buf_simple_add(&buf->b, len);
   1447b:	48 8d 78 10          	lea    0x10(%rax),%rdi
   1447f:	be 01 00 00 00       	mov    $0x1,%esi
	data.chan = chan;
   14484:	4c 89 24 24          	mov    %r12,(%rsp)
	data.uuid = uuid;
   14488:	48 89 6c 24 08       	mov    %rbp,0x8(%rsp)
   1448d:	e8 f7 4b 00 00       	callq  19089 <net_buf_simple_add>
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
   14492:	48 8d 15 34 ef ff ff 	lea    -0x10cc(%rip),%rdx        # 133cd <read_type_cb>
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
   14499:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
	if (!range_is_valid(start_handle, end_handle, &err_handle)) {
   1449e:	41 0f b7 f5          	movzwl %r13w,%esi
	data.rsp->len = 0U;
   144a2:	c6 00 00             	movb   $0x0,(%rax)
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
   144a5:	4c 89 f1             	mov    %r14,%rcx
   144a8:	89 df                	mov    %ebx,%edi
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
   144aa:	c6 44 24 28 0a       	movb   $0xa,0x28(%rsp)
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
   144af:	e8 30 e4 ff ff       	callq  128e4 <bt_gatt_foreach_attr>
	if (data.err) {
   144b4:	44 8a 7c 24 28       	mov    0x28(%rsp),%r15b
   144b9:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
   144be:	45 84 ff             	test   %r15b,%r15b
   144c1:	74 21                	je     144e4 <att_read_type_req+0x128>
		net_buf_unref(data.buf);
   144c3:	48 89 f7             	mov    %rsi,%rdi
   144c6:	e8 cf 4a 00 00       	callq  18f9a <net_buf_unref>
		send_err_rsp(chan, BT_ATT_OP_READ_TYPE_REQ, start_handle,
   144cb:	0f b6 4c 24 28       	movzbl 0x28(%rsp),%ecx
   144d0:	89 da                	mov    %ebx,%edx
   144d2:	be 08 00 00 00       	mov    $0x8,%esi
   144d7:	4c 89 e7             	mov    %r12,%rdi
		return 0;
   144da:	45 31 ff             	xor    %r15d,%r15d
   144dd:	e8 62 f4 ff ff       	callq  13944 <send_err_rsp.part.11>
   144e2:	eb 0f                	jmp    144f3 <att_read_type_req+0x137>
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
   144e4:	48 8d 15 88 eb ff ff 	lea    -0x1478(%rip),%rdx        # 13073 <chan_rsp_sent>
   144eb:	4c 89 e7             	mov    %r12,%rdi
   144ee:	e8 df e8 ff ff       	callq  12dd2 <bt_att_chan_send_rsp>
}
   144f3:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
   144f8:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   144ff:	00 00 
   14501:	44 88 f8             	mov    %r15b,%al
   14504:	74 05                	je     1450b <att_read_type_req+0x14f>
   14506:	e8 35 01 ff ff       	callq  4640 <__stack_chk_fail@plt>
   1450b:	48 83 c4 58          	add    $0x58,%rsp
   1450f:	5b                   	pop    %rbx
   14510:	5d                   	pop    %rbp
   14511:	41 5c                	pop    %r12
   14513:	41 5d                	pop    %r13
   14515:	41 5e                	pop    %r14
   14517:	41 5f                	pop    %r15
   14519:	c3                   	retq   

000000000001451a <att_find_type_req>:
{
   1451a:	41 57                	push   %r15
   1451c:	41 56                	push   %r14
   1451e:	41 55                	push   %r13
   14520:	41 54                	push   %r12
   14522:	49 89 fc             	mov    %rdi,%r12
   14525:	55                   	push   %rbp
   14526:	53                   	push   %rbx
	return net_buf_simple_pull_mem(&buf->b, len);
   14527:	48 8d 7e 10          	lea    0x10(%rsi),%rdi
   1452b:	48 89 f5             	mov    %rsi,%rbp
   1452e:	be 06 00 00 00       	mov    $0x6,%esi
   14533:	48 83 ec 58          	sub    $0x58,%rsp
   14537:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1453e:	00 00 
   14540:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
   14545:	31 c0                	xor    %eax,%eax
   14547:	e8 c3 4b 00 00       	callq  1910f <net_buf_simple_pull_mem>
	start_handle = sys_le16_to_cpu(req->start_handle);
   1454c:	0f b7 10             	movzwl (%rax),%edx
	end_handle = sys_le16_to_cpu(req->end_handle);
   1454f:	66 44 8b 68 02       	mov    0x2(%rax),%r13w
	if (!start || !end) {
   14554:	66 85 d2             	test   %dx,%dx
   14557:	74 4a                	je     145a3 <att_find_type_req+0x89>
   14559:	66 45 85 ed          	test   %r13w,%r13w
   1455d:	74 44                	je     145a3 <att_find_type_req+0x89>
	if (start > end) {
   1455f:	66 44 39 ea          	cmp    %r13w,%dx
   14563:	77 40                	ja     145a5 <att_find_type_req+0x8b>
	type = sys_le16_to_cpu(req->type);
   14565:	66 8b 40 04          	mov    0x4(%rax),%ax
	if (bt_uuid_cmp(BT_UUID_DECLARE_16(type), BT_UUID_GATT_PRIMARY)) {
   14569:	48 8d 74 24 44       	lea    0x44(%rsp),%rsi
   1456e:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
	value = buf->data;
   14573:	4c 8b 75 10          	mov    0x10(%rbp),%r14
	if (!range_is_valid(start_handle, end_handle, &err_handle)) {
   14577:	0f b7 da             	movzwl %dx,%ebx
	if (bt_uuid_cmp(BT_UUID_DECLARE_16(type), BT_UUID_GATT_PRIMARY)) {
   1457a:	c6 44 24 44 00       	movb   $0x0,0x44(%rsp)
   1457f:	66 c7 44 24 46 00 28 	movw   $0x2800,0x46(%rsp)
   14586:	c6 44 24 40 00       	movb   $0x0,0x40(%rsp)
   1458b:	66 89 44 24 42       	mov    %ax,0x42(%rsp)
   14590:	e8 b8 8f ff ff       	callq  d54d <bt_uuid_cmp>
   14595:	85 c0                	test   %eax,%eax
   14597:	74 16                	je     145af <att_find_type_req+0x95>
   14599:	b9 0a 00 00 00       	mov    $0xa,%ecx
   1459e:	e9 94 00 00 00       	jmpq   14637 <att_find_type_req+0x11d>
			*err = 0U;
   145a3:	31 d2                	xor    %edx,%edx
   145a5:	b9 01 00 00 00       	mov    $0x1,%ecx
   145aa:	e9 8a 00 00 00       	jmpq   14639 <att_find_type_req+0x11f>
   145af:	48 8d 4c 24 18       	lea    0x18(%rsp),%rcx
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_TYPE_RSP, 0);
   145b4:	31 d2                	xor    %edx,%edx
   145b6:	be 07 00 00 00       	mov    $0x7,%esi
				 buf->len);
   145bb:	44 8b 7d 18          	mov    0x18(%rbp),%r15d
		return BT_ATT_ERR_UNLIKELY;
   145bf:	40 b5 0e             	mov    $0xe,%bpl
   145c2:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
   145c7:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   145cc:	b9 0a 00 00 00       	mov    $0xa,%ecx
   145d1:	f3 ab                	rep stos %eax,%es:(%rdi)
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_TYPE_RSP, 0);
   145d3:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
   145d8:	e8 01 f7 ff ff       	callq  13cde <bt_att_create_pdu>
	if (!data.buf) {
   145dd:	48 85 c0             	test   %rax,%rax
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_TYPE_RSP, 0);
   145e0:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
	if (!data.buf) {
   145e5:	74 72                	je     14659 <att_find_type_req+0x13f>
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
   145e7:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
   145ec:	48 8d 15 01 e4 ff ff 	lea    -0x1bff(%rip),%rdx        # 129f4 <find_type_cb>
	if (!range_is_valid(start_handle, end_handle, &err_handle)) {
   145f3:	41 0f b7 f5          	movzwl %r13w,%esi
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
   145f7:	89 df                	mov    %ebx,%edi
	data.chan = chan;
   145f9:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
	data.group = NULL;
   145fe:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
   14605:	00 00 
	data.value = value;
   14607:	4c 89 74 24 30       	mov    %r14,0x30(%rsp)
	return att_find_type_rsp(chan, start_handle, end_handle, value,
   1460c:	44 88 7c 24 38       	mov    %r15b,0x38(%rsp)
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
   14611:	c6 44 24 39 0a       	movb   $0xa,0x39(%rsp)
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
   14616:	e8 c9 e2 ff ff       	callq  128e4 <bt_gatt_foreach_attr>
	if (data.err) {
   1461b:	40 8a 6c 24 39       	mov    0x39(%rsp),%bpl
   14620:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
   14625:	40 84 ed             	test   %bpl,%bpl
   14628:	74 20                	je     1464a <att_find_type_req+0x130>
		net_buf_unref(data.buf);
   1462a:	48 89 f7             	mov    %rsi,%rdi
   1462d:	e8 68 49 00 00       	callq  18f9a <net_buf_unref>
		send_err_rsp(chan, BT_ATT_OP_FIND_TYPE_REQ, start_handle,
   14632:	0f b6 4c 24 39       	movzbl 0x39(%rsp),%ecx
   14637:	89 da                	mov    %ebx,%edx
   14639:	be 06 00 00 00       	mov    $0x6,%esi
   1463e:	4c 89 e7             	mov    %r12,%rdi
		return 0;
   14641:	31 ed                	xor    %ebp,%ebp
   14643:	e8 fc f2 ff ff       	callq  13944 <send_err_rsp.part.11>
   14648:	eb 0f                	jmp    14659 <att_find_type_req+0x13f>
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
   1464a:	48 8d 15 22 ea ff ff 	lea    -0x15de(%rip),%rdx        # 13073 <chan_rsp_sent>
   14651:	4c 89 e7             	mov    %r12,%rdi
   14654:	e8 79 e7 ff ff       	callq  12dd2 <bt_att_chan_send_rsp>
}
   14659:	48 8b 5c 24 48       	mov    0x48(%rsp),%rbx
   1465e:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
   14665:	00 00 
   14667:	40 88 e8             	mov    %bpl,%al
   1466a:	74 05                	je     14671 <att_find_type_req+0x157>
   1466c:	e8 cf ff fe ff       	callq  4640 <__stack_chk_fail@plt>
   14671:	48 83 c4 58          	add    $0x58,%rsp
   14675:	5b                   	pop    %rbx
   14676:	5d                   	pop    %rbp
   14677:	41 5c                	pop    %r12
   14679:	41 5d                	pop    %r13
   1467b:	41 5e                	pop    %r14
   1467d:	41 5f                	pop    %r15
   1467f:	c3                   	retq   

0000000000014680 <att_find_info_req>:
{
   14680:	41 55                	push   %r13
   14682:	41 54                	push   %r12
   14684:	55                   	push   %rbp
   14685:	53                   	push   %rbx
   14686:	48 89 fd             	mov    %rdi,%rbp
   14689:	48 83 ec 38          	sub    $0x38,%rsp
   1468d:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   14694:	00 00 
   14696:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
   1469b:	31 c0                	xor    %eax,%eax
	req = (void *)buf->data;
   1469d:	48 8b 46 10          	mov    0x10(%rsi),%rax
	start_handle = sys_le16_to_cpu(req->start_handle);
   146a1:	0f b7 18             	movzwl (%rax),%ebx
	end_handle = sys_le16_to_cpu(req->end_handle);
   146a4:	66 44 8b 60 02       	mov    0x2(%rax),%r12w
	if (!start || !end) {
   146a9:	66 85 db             	test   %bx,%bx
   146ac:	74 3b                	je     146e9 <att_find_info_req+0x69>
   146ae:	66 45 85 e4          	test   %r12w,%r12w
   146b2:	74 35                	je     146e9 <att_find_info_req+0x69>
	if (start > end) {
   146b4:	66 44 39 e3          	cmp    %r12w,%bx
   146b8:	77 31                	ja     146eb <att_find_info_req+0x6b>
   146ba:	4c 8d 6c 24 08       	lea    0x8(%rsp),%r13
   146bf:	31 c0                	xor    %eax,%eax
   146c1:	b9 08 00 00 00       	mov    $0x8,%ecx
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_INFO_RSP, 0);
   146c6:	31 d2                	xor    %edx,%edx
   146c8:	be 05 00 00 00       	mov    $0x5,%esi
   146cd:	4c 89 ef             	mov    %r13,%rdi
   146d0:	f3 ab                	rep stos %eax,%es:(%rdi)
   146d2:	48 8b 7d 08          	mov    0x8(%rbp),%rdi
   146d6:	e8 03 f6 ff ff       	callq  13cde <bt_att_create_pdu>
	if (!data.buf) {
   146db:	48 85 c0             	test   %rax,%rax
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_INFO_RSP, 0);
   146de:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
		return BT_ATT_ERR_UNLIKELY;
   146e3:	b2 0e                	mov    $0xe,%dl
	if (!data.buf) {
   146e5:	75 0e                	jne    146f5 <att_find_info_req+0x75>
   146e7:	eb 62                	jmp    1474b <att_find_info_req+0xcb>
			*err = 0U;
   146e9:	31 db                	xor    %ebx,%ebx
		send_err_rsp(chan, BT_ATT_OP_FIND_INFO_REQ, err_handle,
   146eb:	0f b7 d3             	movzwl %bx,%edx
   146ee:	b9 01 00 00 00       	mov    $0x1,%ecx
   146f3:	eb 36                	jmp    1472b <att_find_info_req+0xab>
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
   146f5:	48 8d 15 07 e2 ff ff 	lea    -0x1df9(%rip),%rdx        # 12903 <find_info_cb>
	if (!range_is_valid(start_handle, end_handle, &err_handle)) {
   146fc:	41 0f b7 f4          	movzwl %r12w,%esi
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
   14700:	4c 89 e9             	mov    %r13,%rcx
   14703:	89 df                	mov    %ebx,%edi
	data.chan = chan;
   14705:	48 89 6c 24 08       	mov    %rbp,0x8(%rsp)
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
   1470a:	e8 d5 e1 ff ff       	callq  128e4 <bt_gatt_foreach_attr>
	if (!data.rsp) {
   1470f:	48 83 7c 24 18 00    	cmpq   $0x0,0x18(%rsp)
   14715:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
   1471a:	75 1e                	jne    1473a <att_find_info_req+0xba>
		net_buf_unref(data.buf);
   1471c:	48 89 f7             	mov    %rsi,%rdi
   1471f:	e8 76 48 00 00       	callq  18f9a <net_buf_unref>
   14724:	b9 0a 00 00 00       	mov    $0xa,%ecx
   14729:	89 da                	mov    %ebx,%edx
   1472b:	be 04 00 00 00       	mov    $0x4,%esi
   14730:	48 89 ef             	mov    %rbp,%rdi
   14733:	e8 0c f2 ff ff       	callq  13944 <send_err_rsp.part.11>
   14738:	eb 0f                	jmp    14749 <att_find_info_req+0xc9>
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
   1473a:	48 8d 15 32 e9 ff ff 	lea    -0x16ce(%rip),%rdx        # 13073 <chan_rsp_sent>
   14741:	48 89 ef             	mov    %rbp,%rdi
   14744:	e8 89 e6 ff ff       	callq  12dd2 <bt_att_chan_send_rsp>
	return 0;
   14749:	31 d2                	xor    %edx,%edx
}
   1474b:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
   14750:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   14757:	00 00 
   14759:	88 d0                	mov    %dl,%al
   1475b:	74 05                	je     14762 <att_find_info_req+0xe2>
   1475d:	e8 de fe fe ff       	callq  4640 <__stack_chk_fail@plt>
   14762:	48 83 c4 38          	add    $0x38,%rsp
   14766:	5b                   	pop    %rbx
   14767:	5d                   	pop    %rbp
   14768:	41 5c                	pop    %r12
   1476a:	41 5d                	pop    %r13
   1476c:	c3                   	retq   

000000000001476d <att_mtu_req>:
{
   1476d:	55                   	push   %rbp
   1476e:	53                   	push   %rbx
   1476f:	49 89 f1             	mov    %rsi,%r9
   14772:	48 89 fb             	mov    %rdi,%rbx
	if (atomic_test_bit(chan->flags, ATT_ENHANCED)) {
   14775:	be 03 00 00 00       	mov    $0x3,%esi
   1477a:	48 81 c7 30 01 00 00 	add    $0x130,%rdi
{
   14781:	48 83 ec 08          	sub    $0x8,%rsp
	struct bt_conn *conn = chan->att->conn;
   14785:	48 8b 87 d0 fe ff ff 	mov    -0x130(%rdi),%rax
   1478c:	4c 8b 00             	mov    (%rax),%r8
	if (atomic_test_bit(chan->flags, ATT_ENHANCED)) {
   1478f:	e8 b3 e0 ff ff       	callq  12847 <atomic_test_bit>
   14794:	84 c0                	test   %al,%al
		return BT_ATT_ERR_NOT_SUPPORTED;
   14796:	b2 06                	mov    $0x6,%dl
	if (atomic_test_bit(chan->flags, ATT_ENHANCED)) {
   14798:	75 5b                	jne    147f5 <att_mtu_req+0x88>
	mtu_client = sys_le16_to_cpu(req->mtu);
   1479a:	49 8b 41 10          	mov    0x10(%r9),%rax
		return BT_ATT_ERR_INVALID_PDU;
   1479e:	b2 04                	mov    $0x4,%dl
	if (mtu_client < BT_ATT_DEFAULT_LE_MTU) {
   147a0:	66 83 38 16          	cmpw   $0x16,(%rax)
   147a4:	76 4f                	jbe    147f5 <att_mtu_req+0x88>
	pdu = bt_att_create_pdu(conn, BT_ATT_OP_MTU_RSP, sizeof(*rsp));
   147a6:	ba 02 00 00 00       	mov    $0x2,%edx
   147ab:	be 03 00 00 00       	mov    $0x3,%esi
   147b0:	4c 89 c7             	mov    %r8,%rdi
   147b3:	e8 26 f5 ff ff       	callq  13cde <bt_att_create_pdu>
	if (!pdu) {
   147b8:	48 85 c0             	test   %rax,%rax
	pdu = bt_att_create_pdu(conn, BT_ATT_OP_MTU_RSP, sizeof(*rsp));
   147bb:	48 89 c5             	mov    %rax,%rbp
		return BT_ATT_ERR_UNLIKELY;
   147be:	b2 0e                	mov    $0xe,%dl
	if (!pdu) {
   147c0:	74 33                	je     147f5 <att_mtu_req+0x88>
	return net_buf_simple_add(&buf->b, len);
   147c2:	48 8d 78 10          	lea    0x10(%rax),%rdi
   147c6:	be 02 00 00 00       	mov    $0x2,%esi
   147cb:	e8 b9 48 00 00       	callq  19089 <net_buf_simple_add>
	bt_att_chan_send_rsp(chan, pdu, chan_rsp_sent);
   147d0:	48 8d 15 9c e8 ff ff 	lea    -0x1764(%rip),%rdx        # 13073 <chan_rsp_sent>
	rsp->mtu = sys_cpu_to_le16(mtu_server);
   147d7:	66 c7 00 17 00       	movw   $0x17,(%rax)
	bt_att_chan_send_rsp(chan, pdu, chan_rsp_sent);
   147dc:	48 89 ee             	mov    %rbp,%rsi
   147df:	48 89 df             	mov    %rbx,%rdi
   147e2:	e8 eb e5 ff ff       	callq  12dd2 <bt_att_chan_send_rsp>
	chan->chan.rx.mtu = MIN(mtu_client, mtu_server);
   147e7:	66 c7 43 72 17 00    	movw   $0x17,0x72(%rbx)
	chan->chan.tx.mtu = chan->chan.rx.mtu;
   147ed:	66 c7 43 7e 17 00    	movw   $0x17,0x7e(%rbx)
	return 0;
   147f3:	31 d2                	xor    %edx,%edx
}
   147f5:	88 d0                	mov    %dl,%al
   147f7:	5a                   	pop    %rdx
   147f8:	5b                   	pop    %rbx
   147f9:	5d                   	pop    %rbp
   147fa:	c3                   	retq   

00000000000147fb <bt_att_init>:
	}
}

void bt_att_init(void)
{
	bt_gatt_init();
   147fb:	e9 7a 1e 00 00       	jmpq   1667a <bt_gatt_init>

0000000000014800 <bt_att_get_mtu>:
		bt_eatt_init();
	}
}

uint16_t bt_att_get_mtu(struct bt_conn *conn)
{
   14800:	48 83 ec 08          	sub    $0x8,%rsp
	struct bt_att_chan *chan, *tmp;
	struct bt_att *att;
	uint16_t mtu = 0;

	att = att_get(conn);
   14804:	e8 46 e6 ff ff       	callq  12e4f <att_get>
	if (!att) {
		return 0;
   14809:	31 d2                	xor    %edx,%edx
	if (!att) {
   1480b:	48 85 c0             	test   %rax,%rax
   1480e:	74 56                	je     14866 <bt_att_get_mtu+0x66>
	}

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   14810:	48 8b 48 78          	mov    0x78(%rax),%rcx
   14814:	48 85 c9             	test   %rcx,%rcx
   14817:	74 4d                	je     14866 <bt_att_get_mtu+0x66>
   14819:	48 89 ce             	mov    %rcx,%rsi
   1481c:	48 81 ee e0 01 00 00 	sub    $0x1e0,%rsi
   14823:	74 41                	je     14866 <bt_att_get_mtu+0x66>
   14825:	48 8b 01             	mov    (%rcx),%rax
   14828:	48 85 c0             	test   %rax,%rax
   1482b:	74 32                	je     1485f <bt_att_get_mtu+0x5f>
   1482d:	48 2d e0 01 00 00    	sub    $0x1e0,%rax
   14833:	66 8b 4e 7e          	mov    0x7e(%rsi),%cx
   14837:	66 39 ca             	cmp    %cx,%dx
   1483a:	0f 42 d1             	cmovb  %ecx,%edx
   1483d:	48 85 c0             	test   %rax,%rax
   14840:	74 24                	je     14866 <bt_att_get_mtu+0x66>
   14842:	48 8b b0 e0 01 00 00 	mov    0x1e0(%rax),%rsi
   14849:	31 c9                	xor    %ecx,%ecx
   1484b:	48 85 f6             	test   %rsi,%rsi
   1484e:	74 07                	je     14857 <bt_att_get_mtu+0x57>
   14850:	48 8d 8e 20 fe ff ff 	lea    -0x1e0(%rsi),%rcx
{
   14857:	48 89 c6             	mov    %rax,%rsi
   1485a:	48 89 c8             	mov    %rcx,%rax
   1485d:	eb d4                	jmp    14833 <bt_att_get_mtu+0x33>
		if (chan->chan.tx.mtu > mtu) {
   1485f:	66 8b 91 9e fe ff ff 	mov    -0x162(%rcx),%dx
			mtu = chan->chan.tx.mtu;
		}
	}

	return mtu;
}
   14866:	89 d0                	mov    %edx,%eax
   14868:	5a                   	pop    %rdx
   14869:	c3                   	retq   

000000000001486a <bt_att_req_alloc>:

struct bt_att_req *bt_att_req_alloc(k_timeout_t timeout)
{
   1486a:	48 83 ec 18          	sub    $0x18,%rsp
   1486e:	48 89 fa             	mov    %rdi,%rdx
	struct bt_att_req *req = NULL;

	/* Reserve space for request */
	if (k_mem_slab_alloc(&req_slab, (void **)&req, timeout)) {
   14871:	48 8d 3d 68 5d 22 00 	lea    0x225d68(%rip),%rdi        # 23a5e0 <req_slab>
   14878:	48 89 e6             	mov    %rsp,%rsi
	struct bt_att_req *req = NULL;
   1487b:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
   14882:	00 
{
   14883:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1488a:	00 00 
   1488c:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   14891:	31 c0                	xor    %eax,%eax
	if (k_mem_slab_alloc(&req_slab, (void **)&req, timeout)) {
   14893:	e8 81 64 01 00       	callq  2ad19 <k_mem_slab_alloc>
   14898:	31 d2                	xor    %edx,%edx
   1489a:	85 c0                	test   %eax,%eax
   1489c:	75 0f                	jne    148ad <bt_att_req_alloc+0x43>
   1489e:	48 8b 3c 24          	mov    (%rsp),%rdi
   148a2:	b9 0c 00 00 00       	mov    $0xc,%ecx
   148a7:	f3 ab                	rep stos %eax,%es:(%rdi)

	BT_DBG("req %p", req);

	memset(req, 0, sizeof(*req));

	return req;
   148a9:	48 8b 14 24          	mov    (%rsp),%rdx
}
   148ad:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
   148b2:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   148b9:	00 00 
   148bb:	48 89 d0             	mov    %rdx,%rax
   148be:	74 05                	je     148c5 <bt_att_req_alloc+0x5b>
   148c0:	e8 7b fd fe ff       	callq  4640 <__stack_chk_fail@plt>
   148c5:	48 83 c4 18          	add    $0x18,%rsp
   148c9:	c3                   	retq   

00000000000148ca <bt_att_req_free>:

void bt_att_req_free(struct bt_att_req *req)
{
   148ca:	48 83 ec 18          	sub    $0x18,%rsp
   148ce:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	BT_DBG("req %p", req);

	k_mem_slab_free(&req_slab, (void **)&req);
   148d3:	48 8d 3d 06 5d 22 00 	lea    0x225d06(%rip),%rdi        # 23a5e0 <req_slab>
   148da:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
   148df:	e8 b7 64 01 00       	callq  2ad9b <k_mem_slab_free>
}
   148e4:	48 83 c4 18          	add    $0x18,%rsp
   148e8:	c3                   	retq   

00000000000148e9 <att_req_destroy>:
{
   148e9:	53                   	push   %rbx
   148ea:	48 89 fb             	mov    %rdi,%rbx
	if (req->buf) {
   148ed:	48 8b 7f 20          	mov    0x20(%rdi),%rdi
   148f1:	48 85 ff             	test   %rdi,%rdi
   148f4:	74 05                	je     148fb <att_req_destroy+0x12>
		net_buf_unref(req->buf);
   148f6:	e8 9f 46 00 00       	callq  18f9a <net_buf_unref>
	if (req->destroy) {
   148fb:	48 8b 43 10          	mov    0x10(%rbx),%rax
   148ff:	48 85 c0             	test   %rax,%rax
   14902:	74 05                	je     14909 <att_req_destroy+0x20>
		req->destroy(req);
   14904:	48 89 df             	mov    %rbx,%rdi
   14907:	ff d0                	callq  *%rax
	bt_att_req_free(req);
   14909:	48 89 df             	mov    %rbx,%rdi
}
   1490c:	5b                   	pop    %rbx
	bt_att_req_free(req);
   1490d:	e9 b8 ff ff ff       	jmpq   148ca <bt_att_req_free>

0000000000014912 <att_handle_rsp>:
{
   14912:	41 57                	push   %r15
   14914:	41 56                	push   %r14
   14916:	41 55                	push   %r13
   14918:	41 54                	push   %r12
   1491a:	55                   	push   %rbp
   1491b:	53                   	push   %rbx
   1491c:	48 89 fb             	mov    %rdi,%rbx
	k_delayed_work_cancel(&chan->timeout_work);
   1491f:	48 81 c7 70 01 00 00 	add    $0x170,%rdi
{
   14926:	48 83 ec 18          	sub    $0x18,%rsp
   1492a:	48 89 34 24          	mov    %rsi,(%rsp)
   1492e:	89 54 24 08          	mov    %edx,0x8(%rsp)
   14932:	89 4c 24 0c          	mov    %ecx,0xc(%rsp)
	k_delayed_work_cancel(&chan->timeout_work);
   14936:	e8 cc 7a 01 00       	callq  2c407 <k_delayed_work_cancel>
	if (!chan->req) {
   1493b:	48 8b 83 38 01 00 00 	mov    0x138(%rbx),%rax
   14942:	48 85 c0             	test   %rax,%rax
   14945:	75 26                	jne    1496d <att_handle_rsp+0x5b>
   14947:	48 8d 35 22 5a 22 00 	lea    0x225a22(%rip),%rsi        # 23a370 <log_const_bt_att>
   1494e:	48 2b 35 fb 15 22 00 	sub    0x2215fb(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("No pending ATT request");
   14955:	48 8d 3d 1f e5 01 00 	lea    0x1e51f(%rip),%rdi        # 32e7b <__func__.5785+0x2213>
   1495c:	48 c1 ee 04          	shr    $0x4,%rsi
   14960:	c1 e6 06             	shl    $0x6,%esi
   14963:	83 ce 02             	or     $0x2,%esi
   14966:	e8 59 29 ff ff       	callq  72c4 <log_0>
   1496b:	eb 17                	jmp    14984 <att_handle_rsp+0x72>
	if (chan->req == &cancel) {
   1496d:	48 8d 15 ac 2a 24 00 	lea    0x242aac(%rip),%rdx        # 257420 <cancel>
   14974:	48 39 d0             	cmp    %rdx,%rax
   14977:	75 10                	jne    14989 <att_handle_rsp+0x77>
		chan->req = NULL;
   14979:	48 c7 83 38 01 00 00 	movq   $0x0,0x138(%rbx)
   14980:	00 00 00 00 
	bt_att_func_t func = NULL;
   14984:	45 31 ff             	xor    %r15d,%r15d
		goto process;
   14987:	eb 44                	jmp    149cd <att_handle_rsp+0xbb>
	if (chan->req->buf) {
   14989:	48 8b 78 20          	mov    0x20(%rax),%rdi
   1498d:	48 85 ff             	test   %rdi,%rdi
   14990:	74 14                	je     149a6 <att_handle_rsp+0x94>
		net_buf_unref(chan->req->buf);
   14992:	e8 03 46 00 00       	callq  18f9a <net_buf_unref>
		chan->req->buf = NULL;
   14997:	48 8b 83 38 01 00 00 	mov    0x138(%rbx),%rax
   1499e:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
   149a5:	00 
	func = chan->req->func;
   149a6:	48 8b bb 38 01 00 00 	mov    0x138(%rbx),%rdi
   149ad:	4c 8b 7f 08          	mov    0x8(%rdi),%r15
	chan->req->func = NULL;
   149b1:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
   149b8:	00 
	params = chan->req->user_data;
   149b9:	4c 8b 77 28          	mov    0x28(%rdi),%r14
	att_req_destroy(chan->req);
   149bd:	e8 27 ff ff ff       	callq  148e9 <att_req_destroy>
	chan->req = NULL;
   149c2:	48 c7 83 38 01 00 00 	movq   $0x0,0x138(%rbx)
   149c9:	00 00 00 00 
	att_process(chan->att);
   149cd:	48 8b 2b             	mov    (%rbx),%rbp
	node = sys_slist_get(&att->reqs);
   149d0:	48 8d 7d 08          	lea    0x8(%rbp),%rdi
   149d4:	e8 a6 dc ff ff       	callq  1267f <sys_slist_get>
	if (!node) {
   149d9:	48 85 c0             	test   %rax,%rax
	node = sys_slist_get(&att->reqs);
   149dc:	49 89 c4             	mov    %rax,%r12
	if (!node) {
   149df:	74 7a                	je     14a5b <att_handle_rsp+0x149>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   149e1:	48 8b 45 78          	mov    0x78(%rbp),%rax
   149e5:	48 85 c0             	test   %rax,%rax
   149e8:	74 5a                	je     14a44 <att_handle_rsp+0x132>
   149ea:	48 89 c7             	mov    %rax,%rdi
   149ed:	48 81 ef e0 01 00 00 	sub    $0x1e0,%rdi
   149f4:	74 4e                	je     14a44 <att_handle_rsp+0x132>
   149f6:	48 8b 00             	mov    (%rax),%rax
   149f9:	45 31 ed             	xor    %r13d,%r13d
   149fc:	48 85 c0             	test   %rax,%rax
   149ff:	74 07                	je     14a08 <att_handle_rsp+0xf6>
   14a01:	4c 8d a8 20 fe ff ff 	lea    -0x1e0(%rax),%r13
		if (!chan->req) {
   14a08:	48 83 bf 38 01 00 00 	cmpq   $0x0,0x138(%rdi)
   14a0f:	00 
   14a10:	74 07                	je     14a19 <att_handle_rsp+0x107>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   14a12:	4d 85 ed             	test   %r13,%r13
   14a15:	75 10                	jne    14a27 <att_handle_rsp+0x115>
   14a17:	eb 2b                	jmp    14a44 <att_handle_rsp+0x132>
			if (bt_att_chan_req_send(chan, ATT_REQ(node)) >= 0) {
   14a19:	4c 89 e6             	mov    %r12,%rsi
   14a1c:	e8 0f eb ff ff       	callq  13530 <bt_att_chan_req_send>
   14a21:	85 c0                	test   %eax,%eax
   14a23:	78 ed                	js     14a12 <att_handle_rsp+0x100>
   14a25:	eb 34                	jmp    14a5b <att_handle_rsp+0x149>
   14a27:	49 8b b5 e0 01 00 00 	mov    0x1e0(%r13),%rsi
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   14a2e:	31 c0                	xor    %eax,%eax
   14a30:	48 85 f6             	test   %rsi,%rsi
   14a33:	74 07                	je     14a3c <att_handle_rsp+0x12a>
   14a35:	48 8d 86 20 fe ff ff 	lea    -0x1e0(%rsi),%rax
   14a3c:	4c 89 ef             	mov    %r13,%rdi
   14a3f:	49 89 c5             	mov    %rax,%r13
   14a42:	eb c4                	jmp    14a08 <att_handle_rsp+0xf6>
Z_GENLIST_PREPEND(slist, snode)
   14a44:	48 8b 45 08          	mov    0x8(%rbp),%rax
	parent->next = child;
   14a48:	49 89 04 24          	mov    %rax,(%r12)
Z_GENLIST_PREPEND(slist, snode)
   14a4c:	48 83 7d 10 00       	cmpq   $0x0,0x10(%rbp)
	list->head = node;
   14a51:	4c 89 65 08          	mov    %r12,0x8(%rbp)
Z_GENLIST_PREPEND(slist, snode)
   14a55:	75 04                	jne    14a5b <att_handle_rsp+0x149>
	list->tail = node;
   14a57:	4c 89 65 10          	mov    %r12,0x10(%rbp)
	if (func) {
   14a5b:	4d 85 ff             	test   %r15,%r15
   14a5e:	74 1a                	je     14a7a <att_handle_rsp+0x168>
		func(chan->att->conn, err, pdu, len, params);
   14a60:	48 8b 03             	mov    (%rbx),%rax
   14a63:	0f b7 4c 24 08       	movzwl 0x8(%rsp),%ecx
   14a68:	4d 89 f0             	mov    %r14,%r8
   14a6b:	0f b6 74 24 0c       	movzbl 0xc(%rsp),%esi
   14a70:	48 8b 14 24          	mov    (%rsp),%rdx
   14a74:	48 8b 38             	mov    (%rax),%rdi
   14a77:	41 ff d7             	callq  *%r15
}
   14a7a:	48 83 c4 18          	add    $0x18,%rsp
   14a7e:	31 c0                	xor    %eax,%eax
   14a80:	5b                   	pop    %rbx
   14a81:	5d                   	pop    %rbp
   14a82:	41 5c                	pop    %r12
   14a84:	41 5d                	pop    %r13
   14a86:	41 5e                	pop    %r14
   14a88:	41 5f                	pop    %r15
   14a8a:	c3                   	retq   

0000000000014a8b <att_handle_find_info_rsp>:
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   14a8b:	0f b7 56 18          	movzwl 0x18(%rsi),%edx
   14a8f:	48 8b 76 10          	mov    0x10(%rsi),%rsi
   14a93:	31 c9                	xor    %ecx,%ecx
   14a95:	e9 78 fe ff ff       	jmpq   14912 <att_handle_rsp>

0000000000014a9a <att_handle_find_type_rsp>:
   14a9a:	e9 ec ff ff ff       	jmpq   14a8b <att_handle_find_info_rsp>

0000000000014a9f <att_handle_read_type_rsp>:
   14a9f:	e9 e7 ff ff ff       	jmpq   14a8b <att_handle_find_info_rsp>

0000000000014aa4 <att_handle_read_rsp>:
   14aa4:	e9 e2 ff ff ff       	jmpq   14a8b <att_handle_find_info_rsp>

0000000000014aa9 <att_handle_read_blob_rsp>:
   14aa9:	e9 dd ff ff ff       	jmpq   14a8b <att_handle_find_info_rsp>

0000000000014aae <att_handle_read_mult_rsp>:
   14aae:	e9 d8 ff ff ff       	jmpq   14a8b <att_handle_find_info_rsp>

0000000000014ab3 <att_handle_read_group_rsp>:
   14ab3:	e9 d3 ff ff ff       	jmpq   14a8b <att_handle_find_info_rsp>

0000000000014ab8 <att_handle_write_rsp>:
   14ab8:	e9 ce ff ff ff       	jmpq   14a8b <att_handle_find_info_rsp>

0000000000014abd <att_handle_prepare_write_rsp>:
   14abd:	e9 c9 ff ff ff       	jmpq   14a8b <att_handle_find_info_rsp>

0000000000014ac2 <att_handle_exec_write_rsp>:
   14ac2:	e9 c4 ff ff ff       	jmpq   14a8b <att_handle_find_info_rsp>

0000000000014ac7 <att_confirm>:
   14ac7:	e9 bf ff ff ff       	jmpq   14a8b <att_handle_find_info_rsp>

0000000000014acc <att_mtu_rsp>:
	rsp = (void *)buf->data;
   14acc:	48 8b 46 10          	mov    0x10(%rsi),%rax
	if (mtu < BT_ATT_DEFAULT_LE_MTU) {
   14ad0:	66 83 38 16          	cmpw   $0x16,(%rax)
   14ad4:	77 0b                	ja     14ae1 <att_mtu_rsp+0x15>
		return att_handle_rsp(chan, NULL, 0, BT_ATT_ERR_INVALID_PDU);
   14ad6:	b9 04 00 00 00       	mov    $0x4,%ecx
   14adb:	31 d2                	xor    %edx,%edx
   14add:	31 f6                	xor    %esi,%esi
   14adf:	eb 15                	jmp    14af6 <att_mtu_rsp+0x2a>
	return att_handle_rsp(chan, rsp, buf->len, 0);
   14ae1:	0f b7 56 18          	movzwl 0x18(%rsi),%edx
	chan->chan.rx.mtu = MIN(mtu, BT_ATT_MTU);
   14ae5:	66 c7 47 72 17 00    	movw   $0x17,0x72(%rdi)
	return att_handle_rsp(chan, rsp, buf->len, 0);
   14aeb:	31 c9                	xor    %ecx,%ecx
	chan->chan.tx.mtu = chan->chan.rx.mtu;
   14aed:	66 c7 47 7e 17 00    	movw   $0x17,0x7e(%rdi)
	return att_handle_rsp(chan, rsp, buf->len, 0);
   14af3:	48 89 c6             	mov    %rax,%rsi
   14af6:	e9 17 fe ff ff       	jmpq   14912 <att_handle_rsp>

0000000000014afb <att_error_rsp>:
	if (!chan->req || chan->req == &cancel) {
   14afb:	48 8b 87 38 01 00 00 	mov    0x138(%rdi),%rax
   14b02:	48 8d 15 17 29 24 00 	lea    0x242917(%rip),%rdx        # 257420 <cancel>
   14b09:	48 39 d0             	cmp    %rdx,%rax
   14b0c:	74 2c                	je     14b3a <att_error_rsp+0x3f>
   14b0e:	48 85 c0             	test   %rax,%rax
   14b11:	74 27                	je     14b3a <att_error_rsp+0x3f>
	if (chan->req->buf) {
   14b13:	48 8b 50 20          	mov    0x20(%rax),%rdx
	rsp = (void *)buf->data;
   14b17:	48 8b 76 10          	mov    0x10(%rsi),%rsi
	if (chan->req->buf) {
   14b1b:	48 85 d2             	test   %rdx,%rdx
   14b1e:	74 14                	je     14b34 <att_error_rsp+0x39>
	buf->data = buf->__buf + state->offset;
   14b20:	0f b7 48 18          	movzwl 0x18(%rax),%ecx
	buf->len = state->len;
   14b24:	66 8b 40 1a          	mov    0x1a(%rax),%ax
	buf->data = buf->__buf + state->offset;
   14b28:	48 03 4a 20          	add    0x20(%rdx),%rcx
	buf->len = state->len;
   14b2c:	66 89 42 18          	mov    %ax,0x18(%rdx)
	buf->data = buf->__buf + state->offset;
   14b30:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
	err = rsp->error;
   14b34:	0f b6 4e 03          	movzbl 0x3(%rsi),%ecx
   14b38:	eb 05                	jmp    14b3f <att_error_rsp+0x44>
		err = BT_ATT_ERR_UNLIKELY;
   14b3a:	b9 0e 00 00 00       	mov    $0xe,%ecx
	return att_handle_rsp(chan, NULL, 0, err);
   14b3f:	31 d2                	xor    %edx,%edx
   14b41:	31 f6                	xor    %esi,%esi
   14b43:	e9 ca fd ff ff       	jmpq   14912 <att_handle_rsp>

0000000000014b48 <bt_att_disconnected>:
{
   14b48:	41 54                	push   %r12
   14b4a:	55                   	push   %rbp
   14b4b:	53                   	push   %rbx
   14b4c:	48 83 ec 10          	sub    $0x10,%rsp
	struct bt_att *att = att_chan->att;
   14b50:	48 8b 6f f8          	mov    -0x8(%rdi),%rbp
{
   14b54:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   14b5b:	00 00 
   14b5d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   14b62:	31 c0                	xor    %eax,%eax
	if (!att_chan->att) {
   14b64:	48 85 ed             	test   %rbp,%rbp
   14b67:	0f 84 20 01 00 00    	je     14c8d <bt_att_disconnected+0x145>
   14b6d:	48 89 fb             	mov    %rdi,%rbx
	sys_slist_find_and_remove(&chan->att->chans, &chan->node);
   14b70:	48 8d b7 d8 01 00 00 	lea    0x1d8(%rdi),%rsi
   14b77:	48 8d 7d 78          	lea    0x78(%rbp),%rdi
		k_sem_give(&chan->tx_sem);
   14b7b:	4c 8d a3 a8 01 00 00 	lea    0x1a8(%rbx),%r12
	sys_slist_find_and_remove(&chan->att->chans, &chan->node);
   14b82:	e8 11 db ff ff       	callq  12698 <sys_slist_find_and_remove>
   14b87:	4c 89 e7             	mov    %r12,%rdi
   14b8a:	e8 a7 73 01 00       	callq  2bf36 <z_impl_k_sem_give>
   14b8f:	4c 89 e7             	mov    %r12,%rdi
   14b92:	e8 9f 73 01 00       	callq  2bf36 <z_impl_k_sem_give>
   14b97:	4c 89 e7             	mov    %r12,%rdi
	while ((buf = net_buf_get(&chan->tx_queue, K_NO_WAIT))) {
   14b9a:	4c 8d 63 f8          	lea    -0x8(%rbx),%r12
   14b9e:	e8 93 73 01 00       	callq  2bf36 <z_impl_k_sem_give>
   14ba3:	48 8d bb 38 01 00 00 	lea    0x138(%rbx),%rdi
   14baa:	31 f6                	xor    %esi,%esi
   14bac:	e8 76 43 00 00       	callq  18f27 <net_buf_get>
   14bb1:	48 85 c0             	test   %rax,%rax
   14bb4:	74 0a                	je     14bc0 <bt_att_disconnected+0x78>
		net_buf_unref(buf);
   14bb6:	48 89 c7             	mov    %rax,%rdi
   14bb9:	e8 dc 43 00 00       	callq  18f9a <net_buf_unref>
   14bbe:	eb e3                	jmp    14ba3 <bt_att_disconnected+0x5b>
	if (chan->req) {
   14bc0:	48 83 bb 30 01 00 00 	cmpq   $0x0,0x130(%rbx)
   14bc7:	00 
   14bc8:	74 11                	je     14bdb <bt_att_disconnected+0x93>
		att_handle_rsp(chan, NULL, 0, BT_ATT_ERR_UNLIKELY);
   14bca:	b9 0e 00 00 00       	mov    $0xe,%ecx
   14bcf:	31 d2                	xor    %edx,%edx
   14bd1:	31 f6                	xor    %esi,%esi
   14bd3:	4c 89 e7             	mov    %r12,%rdi
   14bd6:	e8 37 fd ff ff       	callq  14912 <att_handle_rsp>
	if (!sys_slist_is_empty(&att->chans)) {
   14bdb:	48 83 7d 78 00       	cmpq   $0x0,0x78(%rbp)
	chan->att = NULL;
   14be0:	48 c7 43 f8 00 00 00 	movq   $0x0,-0x8(%rbx)
   14be7:	00 
	if (!sys_slist_is_empty(&att->chans)) {
   14be8:	0f 85 9f 00 00 00    	jne    14c8d <bt_att_disconnected+0x145>
   14bee:	48 89 2c 24          	mov    %rbp,(%rsp)
	while ((buf = net_buf_get(&att->prep_queue, K_NO_WAIT))) {
   14bf2:	48 8b 04 24          	mov    (%rsp),%rax
   14bf6:	31 f6                	xor    %esi,%esi
   14bf8:	48 8d 78 48          	lea    0x48(%rax),%rdi
   14bfc:	e8 26 43 00 00       	callq  18f27 <net_buf_get>
   14c01:	48 85 c0             	test   %rax,%rax
   14c04:	74 0a                	je     14c10 <bt_att_disconnected+0xc8>
		net_buf_unref(buf);
   14c06:	48 89 c7             	mov    %rax,%rdi
   14c09:	e8 8c 43 00 00       	callq  18f9a <net_buf_unref>
   14c0e:	eb e2                	jmp    14bf2 <bt_att_disconnected+0xaa>
	while ((buf = net_buf_get(&att->tx_queue, K_NO_WAIT))) {
   14c10:	48 8b 04 24          	mov    (%rsp),%rax
   14c14:	31 f6                	xor    %esi,%esi
   14c16:	48 8d 78 18          	lea    0x18(%rax),%rdi
   14c1a:	e8 08 43 00 00       	callq  18f27 <net_buf_get>
   14c1f:	48 85 c0             	test   %rax,%rax
   14c22:	74 0a                	je     14c2e <bt_att_disconnected+0xe6>
		net_buf_unref(buf);
   14c24:	48 89 c7             	mov    %rax,%rdi
   14c27:	e8 6e 43 00 00       	callq  18f9a <net_buf_unref>
   14c2c:	eb e2                	jmp    14c10 <bt_att_disconnected+0xc8>
	att->conn = NULL;
   14c2e:	48 8b 04 24          	mov    (%rsp),%rax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->reqs, req, tmp, node) {
   14c32:	48 8b 68 08          	mov    0x8(%rax),%rbp
	att->conn = NULL;
   14c36:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->reqs, req, tmp, node) {
   14c3d:	48 85 ed             	test   %rbp,%rbp
   14c40:	74 34                	je     14c76 <bt_att_disconnected+0x12e>
	return node->next;
   14c42:	4c 8b 65 00          	mov    0x0(%rbp),%r12
		if (req->func) {
   14c46:	48 8b 45 08          	mov    0x8(%rbp),%rax
   14c4a:	48 85 c0             	test   %rax,%rax
   14c4d:	74 11                	je     14c60 <bt_att_disconnected+0x118>
			req->func(NULL, BT_ATT_ERR_UNLIKELY, NULL, 0,
   14c4f:	4c 8b 45 28          	mov    0x28(%rbp),%r8
   14c53:	31 c9                	xor    %ecx,%ecx
   14c55:	31 d2                	xor    %edx,%edx
   14c57:	be 0e 00 00 00       	mov    $0xe,%esi
   14c5c:	31 ff                	xor    %edi,%edi
   14c5e:	ff d0                	callq  *%rax
		att_req_destroy(req);
   14c60:	48 89 ef             	mov    %rbp,%rdi
   14c63:	e8 81 fc ff ff       	callq  148e9 <att_req_destroy>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->reqs, req, tmp, node) {
   14c68:	4d 85 e4             	test   %r12,%r12
   14c6b:	74 09                	je     14c76 <bt_att_disconnected+0x12e>
   14c6d:	4c 89 e5             	mov    %r12,%rbp
   14c70:	4d 8b 24 24          	mov    (%r12),%r12
   14c74:	eb d0                	jmp    14c46 <bt_att_disconnected+0xfe>
	k_mem_slab_free(&att_slab, (void **)&att);
   14c76:	48 8d 3d f3 58 22 00 	lea    0x2258f3(%rip),%rdi        # 23a570 <_k_timer_list_end>
   14c7d:	48 89 e6             	mov    %rsp,%rsi
   14c80:	e8 16 61 01 00       	callq  2ad9b <k_mem_slab_free>
	bt_gatt_disconnected(ch->chan.conn);
   14c85:	48 8b 3b             	mov    (%rbx),%rdi
   14c88:	e8 31 3d 00 00       	callq  189be <bt_gatt_disconnected>
}
   14c8d:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   14c92:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   14c99:	00 00 
   14c9b:	74 05                	je     14ca2 <bt_att_disconnected+0x15a>
   14c9d:	e8 9e f9 fe ff       	callq  4640 <__stack_chk_fail@plt>
   14ca2:	48 83 c4 10          	add    $0x10,%rsp
   14ca6:	5b                   	pop    %rbx
   14ca7:	5d                   	pop    %rbp
   14ca8:	41 5c                	pop    %r12
   14caa:	c3                   	retq   

0000000000014cab <att_timeout>:
   14cab:	48 8d 35 be 56 22 00 	lea    0x2256be(%rip),%rsi        # 23a370 <log_const_bt_att>
   14cb2:	48 2b 35 97 12 22 00 	sub    0x221297(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
{
   14cb9:	53                   	push   %rbx
   14cba:	48 89 fb             	mov    %rdi,%rbx
	BT_ERR("ATT Timeout");
   14cbd:	48 8d 3d ce e1 01 00 	lea    0x1e1ce(%rip),%rdi        # 32e92 <__func__.5785+0x222a>
   14cc4:	48 c1 ee 04          	shr    $0x4,%rsi
   14cc8:	c1 e6 06             	shl    $0x6,%esi
   14ccb:	83 ce 01             	or     $0x1,%esi
   14cce:	e8 f1 25 ff ff       	callq  72c4 <log_0>
	bt_att_disconnected(&chan->chan.chan);
   14cd3:	48 8d bb 98 fe ff ff 	lea    -0x168(%rbx),%rdi
}
   14cda:	5b                   	pop    %rbx
	bt_att_disconnected(&chan->chan.chan);
   14cdb:	e9 68 fe ff ff       	jmpq   14b48 <bt_att_disconnected>

0000000000014ce0 <bt_att_send>:

int bt_att_send(struct bt_conn *conn, struct net_buf *buf, bt_conn_tx_cb_t cb,
		void *user_data)
{
   14ce0:	41 56                	push   %r14
   14ce2:	41 55                	push   %r13
   14ce4:	49 89 f5             	mov    %rsi,%r13
   14ce7:	41 54                	push   %r12
   14ce9:	55                   	push   %rbp
   14cea:	49 89 d4             	mov    %rdx,%r12
   14ced:	53                   	push   %rbx
   14cee:	48 89 fb             	mov    %rdi,%rbx
   14cf1:	48 83 ec 10          	sub    $0x10,%rsp
   14cf5:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
	int ret;

	__ASSERT_NO_MSG(conn);
	__ASSERT_NO_MSG(buf);

	att = att_get(conn);
   14cfa:	e8 50 e1 ff ff       	callq  12e4f <att_get>
	if (!att) {
   14cff:	48 85 c0             	test   %rax,%rax
   14d02:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
   14d07:	75 12                	jne    14d1b <bt_att_send+0x3b>
		net_buf_unref(buf);
   14d09:	4c 89 ef             	mov    %r13,%rdi
   14d0c:	e8 89 42 00 00       	callq  18f9a <net_buf_unref>
		return -ENOTCONN;
   14d11:	b8 95 ff ff ff       	mov    $0xffffff95,%eax
   14d16:	e9 ba 00 00 00       	jmpq   14dd5 <bt_att_send+0xf5>
	}

	/* If callback is set use the fixed channel since bt_l2cap_chan_send
	 * cannot be used with a custom user_data.
	 */
	if (cb) {
   14d1b:	4d 85 e4             	test   %r12,%r12
   14d1e:	74 1f                	je     14d3f <bt_att_send+0x5f>
		BT_DBG("Queueing buffer %p", buf);
		net_buf_put(&att->tx_queue, buf);
	}

	return 0;
}
   14d20:	48 83 c4 10          	add    $0x10,%rsp
		return bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf, cb,
   14d24:	4c 89 e1             	mov    %r12,%rcx
   14d27:	4c 89 ea             	mov    %r13,%rdx
   14d2a:	48 89 df             	mov    %rbx,%rdi
   14d2d:	be 04 00 00 00       	mov    $0x4,%esi
}
   14d32:	5b                   	pop    %rbx
   14d33:	5d                   	pop    %rbp
   14d34:	41 5c                	pop    %r12
   14d36:	41 5d                	pop    %r13
   14d38:	41 5e                	pop    %r14
		return bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf, cb,
   14d3a:	e9 0c d6 ff ff       	jmpq   1234b <bt_l2cap_send_cb>
   14d3f:	48 89 c5             	mov    %rax,%rbp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   14d42:	48 8b 40 78          	mov    0x78(%rax),%rax
   14d46:	31 db                	xor    %ebx,%ebx
   14d48:	45 31 e4             	xor    %r12d,%r12d
   14d4b:	48 85 c0             	test   %rax,%rax
   14d4e:	74 1b                	je     14d6b <bt_att_send+0x8b>
   14d50:	49 89 c4             	mov    %rax,%r12
   14d53:	49 81 ec e0 01 00 00 	sub    $0x1e0,%r12
   14d5a:	74 0f                	je     14d6b <bt_att_send+0x8b>
   14d5c:	48 8b 00             	mov    (%rax),%rax
   14d5f:	48 85 c0             	test   %rax,%rax
   14d62:	74 07                	je     14d6b <bt_att_send+0x8b>
   14d64:	48 8d 98 20 fe ff ff 	lea    -0x1e0(%rax),%rbx
   14d6b:	31 c0                	xor    %eax,%eax
			return -EAGAIN;
   14d6d:	41 be f5 ff ff ff    	mov    $0xfffffff5,%r14d
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   14d73:	4d 85 e4             	test   %r12,%r12
   14d76:	74 4b                	je     14dc3 <bt_att_send+0xe3>
		if (k_sem_take(&chan->tx_sem, K_NO_WAIT) < 0) {
   14d78:	49 8d bc 24 b0 01 00 	lea    0x1b0(%r12),%rdi
   14d7f:	00 
	return z_impl_k_sem_take(sem, timeout);
   14d80:	31 f6                	xor    %esi,%esi
   14d82:	e8 0c 72 01 00       	callq  2bf93 <z_impl_k_sem_take>
   14d87:	85 c0                	test   %eax,%eax
   14d89:	78 13                	js     14d9e <bt_att_send+0xbe>
	return chan_send(chan, buf, cb);
   14d8b:	31 d2                	xor    %edx,%edx
   14d8d:	4c 89 ee             	mov    %r13,%rsi
   14d90:	4c 89 e7             	mov    %r12,%rdi
   14d93:	e8 ed de ff ff       	callq  12c85 <chan_send>
		if (ret >= 0) {
   14d98:	85 c0                	test   %eax,%eax
   14d9a:	78 05                	js     14da1 <bt_att_send+0xc1>
   14d9c:	eb 35                	jmp    14dd3 <bt_att_send+0xf3>
			return -EAGAIN;
   14d9e:	44 89 f0             	mov    %r14d,%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   14da1:	31 d2                	xor    %edx,%edx
   14da3:	48 85 db             	test   %rbx,%rbx
   14da6:	74 13                	je     14dbb <bt_att_send+0xdb>
   14da8:	48 8b 8b e0 01 00 00 	mov    0x1e0(%rbx),%rcx
   14daf:	48 85 c9             	test   %rcx,%rcx
   14db2:	74 07                	je     14dbb <bt_att_send+0xdb>
   14db4:	48 8d 91 20 fe ff ff 	lea    -0x1e0(%rcx),%rdx
   14dbb:	49 89 dc             	mov    %rbx,%r12
   14dbe:	48 89 d3             	mov    %rdx,%rbx
   14dc1:	eb b0                	jmp    14d73 <bt_att_send+0x93>
	if (ret < 0) {
   14dc3:	85 c0                	test   %eax,%eax
   14dc5:	74 0c                	je     14dd3 <bt_att_send+0xf3>
		net_buf_put(&att->tx_queue, buf);
   14dc7:	48 8d 7d 18          	lea    0x18(%rbp),%rdi
   14dcb:	4c 89 ee             	mov    %r13,%rsi
   14dce:	e8 ae 41 00 00       	callq  18f81 <net_buf_put>
	return 0;
   14dd3:	31 c0                	xor    %eax,%eax
}
   14dd5:	48 83 c4 10          	add    $0x10,%rsp
   14dd9:	5b                   	pop    %rbx
   14dda:	5d                   	pop    %rbp
   14ddb:	41 5c                	pop    %r12
   14ddd:	41 5d                	pop    %r13
   14ddf:	41 5e                	pop    %r14
   14de1:	c3                   	retq   

0000000000014de2 <bt_att_req_send>:

int bt_att_req_send(struct bt_conn *conn, struct bt_att_req *req)
{
   14de2:	41 54                	push   %r12
   14de4:	55                   	push   %rbp
   14de5:	53                   	push   %rbx
   14de6:	48 89 f3             	mov    %rsi,%rbx
	BT_DBG("conn %p req %p", conn, req);

	__ASSERT_NO_MSG(conn);
	__ASSERT_NO_MSG(req);

	att = att_get(conn);
   14de9:	e8 61 e0 ff ff       	callq  12e4f <att_get>
	if (!att) {
   14dee:	48 85 c0             	test   %rax,%rax
   14df1:	75 1b                	jne    14e0e <bt_att_req_send+0x2c>
		net_buf_unref(req->buf);
   14df3:	48 8b 7b 20          	mov    0x20(%rbx),%rdi
   14df7:	e8 9e 41 00 00       	callq  18f9a <net_buf_unref>
		req->buf = NULL;
   14dfc:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
   14e03:	00 
		return -ENOTCONN;
   14e04:	b8 95 ff ff ff       	mov    $0xffffff95,%eax
   14e09:	e9 8a 00 00 00       	jmpq   14e98 <bt_att_req_send+0xb6>
   14e0e:	48 89 c5             	mov    %rax,%rbp
	}

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   14e11:	48 8b 40 78          	mov    0x78(%rax),%rax
   14e15:	48 85 c0             	test   %rax,%rax
   14e18:	74 5b                	je     14e75 <bt_att_req_send+0x93>
   14e1a:	48 89 c7             	mov    %rax,%rdi
   14e1d:	48 81 ef e0 01 00 00 	sub    $0x1e0,%rdi
   14e24:	74 4f                	je     14e75 <bt_att_req_send+0x93>
   14e26:	48 8b 00             	mov    (%rax),%rax
   14e29:	45 31 e4             	xor    %r12d,%r12d
   14e2c:	48 85 c0             	test   %rax,%rax
   14e2f:	74 07                	je     14e38 <bt_att_req_send+0x56>
   14e31:	4c 8d a0 20 fe ff ff 	lea    -0x1e0(%rax),%r12
		/* If there is nothing pending use the channel */
		if (!chan->req) {
   14e38:	48 83 bf 38 01 00 00 	cmpq   $0x0,0x138(%rdi)
   14e3f:	00 
   14e40:	74 07                	je     14e49 <bt_att_req_send+0x67>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   14e42:	4d 85 e4             	test   %r12,%r12
   14e45:	75 10                	jne    14e57 <bt_att_req_send+0x75>
   14e47:	eb 2c                	jmp    14e75 <bt_att_req_send+0x93>
			int ret;

			ret = bt_att_chan_req_send(chan, req);
   14e49:	48 89 de             	mov    %rbx,%rsi
   14e4c:	e8 df e6 ff ff       	callq  13530 <bt_att_chan_req_send>
			if (ret >= 0) {
   14e51:	85 c0                	test   %eax,%eax
   14e53:	78 ed                	js     14e42 <bt_att_req_send+0x60>
   14e55:	eb 41                	jmp    14e98 <bt_att_req_send+0xb6>
   14e57:	49 8b 94 24 e0 01 00 	mov    0x1e0(%r12),%rdx
   14e5e:	00 
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   14e5f:	31 c0                	xor    %eax,%eax
   14e61:	48 85 d2             	test   %rdx,%rdx
   14e64:	74 07                	je     14e6d <bt_att_req_send+0x8b>
   14e66:	48 8d 82 20 fe ff ff 	lea    -0x1e0(%rdx),%rax
   14e6d:	4c 89 e7             	mov    %r12,%rdi
   14e70:	49 89 c4             	mov    %rax,%r12
   14e73:	eb c3                	jmp    14e38 <bt_att_req_send+0x56>
	parent->next = child;
   14e75:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
Z_GENLIST_APPEND(slist, snode)
   14e7c:	48 8b 45 10          	mov    0x10(%rbp),%rax
   14e80:	48 85 c0             	test   %rax,%rax
   14e83:	75 0a                	jne    14e8f <bt_att_req_send+0xad>
	list->tail = node;
   14e85:	48 89 5d 10          	mov    %rbx,0x10(%rbp)
	list->head = node;
   14e89:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
   14e8d:	eb 09                	jmp    14e98 <bt_att_req_send+0xb6>
	parent->next = child;
   14e8f:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
   14e92:	48 89 5d 10          	mov    %rbx,0x10(%rbp)
	/* Queue the request to be send later */
	sys_slist_append(&att->reqs, &req->node);

	BT_DBG("req %p queued", req);

	return 0;
   14e96:	31 c0                	xor    %eax,%eax
}
   14e98:	5b                   	pop    %rbx
   14e99:	5d                   	pop    %rbp
   14e9a:	41 5c                	pop    %r12
   14e9c:	c3                   	retq   

0000000000014e9d <bt_att_req_cancel>:
	struct bt_att *att;
	struct bt_att_chan *chan, *tmp;

	BT_DBG("req %p", req);

	if (!conn || !req) {
   14e9d:	48 85 ff             	test   %rdi,%rdi
   14ea0:	0f 84 91 00 00 00    	je     14f37 <bt_att_req_cancel+0x9a>
   14ea6:	48 85 f6             	test   %rsi,%rsi
   14ea9:	0f 84 88 00 00 00    	je     14f37 <bt_att_req_cancel+0x9a>
{
   14eaf:	53                   	push   %rbx
   14eb0:	48 89 f3             	mov    %rsi,%rbx
		return;
	}

	att = att_get(conn);
   14eb3:	e8 97 df ff ff       	callq  12e4f <att_get>
	if (!att) {
   14eb8:	48 85 c0             	test   %rax,%rax
   14ebb:	74 78                	je     14f35 <bt_att_req_cancel+0x98>
		return;
	}

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   14ebd:	48 8b 50 78          	mov    0x78(%rax),%rdx
   14ec1:	48 85 d2             	test   %rdx,%rdx
   14ec4:	75 0e                	jne    14ed4 <bt_att_req_cancel+0x37>
			return;
		}
	}

	/* Remove request from the list */
	sys_slist_find_and_remove(&att->reqs, &req->node);
   14ec6:	48 8d 78 08          	lea    0x8(%rax),%rdi
   14eca:	48 89 de             	mov    %rbx,%rsi
   14ecd:	e8 c6 d7 ff ff       	callq  12698 <sys_slist_find_and_remove>
   14ed2:	eb 3b                	jmp    14f0f <bt_att_req_cancel+0x72>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   14ed4:	48 89 d1             	mov    %rdx,%rcx
   14ed7:	48 81 e9 e0 01 00 00 	sub    $0x1e0,%rcx
   14ede:	74 e6                	je     14ec6 <bt_att_req_cancel+0x29>
	return node->next;
   14ee0:	48 8b 32             	mov    (%rdx),%rsi
   14ee3:	31 d2                	xor    %edx,%edx
   14ee5:	48 85 f6             	test   %rsi,%rsi
   14ee8:	74 07                	je     14ef1 <bt_att_req_cancel+0x54>
   14eea:	48 8d 96 20 fe ff ff 	lea    -0x1e0(%rsi),%rdx
	if (chan->req != req) {
   14ef1:	48 3b 99 38 01 00 00 	cmp    0x138(%rcx),%rbx
   14ef8:	74 07                	je     14f01 <bt_att_req_cancel+0x64>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   14efa:	48 85 d2             	test   %rdx,%rdx
   14efd:	75 19                	jne    14f18 <bt_att_req_cancel+0x7b>
   14eff:	eb c5                	jmp    14ec6 <bt_att_req_cancel+0x29>
	chan->req = &cancel;
   14f01:	48 8d 05 18 25 24 00 	lea    0x242518(%rip),%rax        # 257420 <cancel>
   14f08:	48 89 81 38 01 00 00 	mov    %rax,0x138(%rcx)
	att_req_destroy(req);
   14f0f:	48 89 df             	mov    %rbx,%rdi

	att_req_destroy(req);
}
   14f12:	5b                   	pop    %rbx
	att_req_destroy(req);
   14f13:	e9 d1 f9 ff ff       	jmpq   148e9 <att_req_destroy>
   14f18:	48 8b 8a e0 01 00 00 	mov    0x1e0(%rdx),%rcx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   14f1f:	31 f6                	xor    %esi,%esi
   14f21:	48 85 c9             	test   %rcx,%rcx
   14f24:	74 07                	je     14f2d <bt_att_req_cancel+0x90>
   14f26:	48 8d b1 20 fe ff ff 	lea    -0x1e0(%rcx),%rsi
   14f2d:	48 89 d1             	mov    %rdx,%rcx
   14f30:	48 89 f2             	mov    %rsi,%rdx
   14f33:	eb bc                	jmp    14ef1 <bt_att_req_cancel+0x54>
}
   14f35:	5b                   	pop    %rbx
   14f36:	c3                   	retq   
   14f37:	c3                   	retq   

0000000000014f38 <gatt_ccc_changed>:
{
	int i;
	uint16_t value = 0x0000;

	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
		if (ccc->cfg[i].value > value) {
   14f38:	8b 46 08             	mov    0x8(%rsi),%eax
		}
	}

	BT_DBG("ccc %p value 0x%04x", ccc, value);

	if (value != ccc->value) {
   14f3b:	66 3b 46 0a          	cmp    0xa(%rsi),%ax
   14f3f:	74 12                	je     14f53 <gatt_ccc_changed+0x1b>
		ccc->value = value;
		if (ccc->cfg_changed) {
   14f41:	48 8b 56 10          	mov    0x10(%rsi),%rdx
		ccc->value = value;
   14f45:	66 89 46 0a          	mov    %ax,0xa(%rsi)
		if (ccc->cfg_changed) {
   14f49:	48 85 d2             	test   %rdx,%rdx
   14f4c:	74 05                	je     14f53 <gatt_ccc_changed+0x1b>
			ccc->cfg_changed(attr, value);
   14f4e:	0f b7 f0             	movzwl %ax,%esi
   14f51:	ff e2                	jmpq   *%rdx
		}
	}
}
   14f53:	c3                   	retq   

0000000000014f54 <gatt_indicate_rsp>:
	return bt_att_send(conn, buf, params->func, params->user_data);
}

static void gatt_indicate_rsp(struct bt_conn *conn, uint8_t err,
			      const void *pdu, uint16_t length, void *user_data)
{
   14f54:	48 83 ec 18          	sub    $0x18,%rsp
	struct bt_gatt_indicate_params *params = user_data;

	params->_ref--;
   14f58:	41 fe 48 2a          	decb   0x2a(%r8)
	params->func(conn, params, err);
   14f5c:	40 0f b6 d6          	movzbl %sil,%edx
   14f60:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
   14f65:	4c 89 c6             	mov    %r8,%rsi
   14f68:	41 ff 50 10          	callq  *0x10(%r8)
	if (params->destroy && (params->_ref == 0)) {
   14f6c:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
   14f71:	49 8b 40 18          	mov    0x18(%r8),%rax
   14f75:	48 85 c0             	test   %rax,%rax
   14f78:	74 10                	je     14f8a <gatt_indicate_rsp+0x36>
   14f7a:	41 80 78 2a 00       	cmpb   $0x0,0x2a(%r8)
   14f7f:	75 09                	jne    14f8a <gatt_indicate_rsp+0x36>
		params->destroy(params);
   14f81:	4c 89 c7             	mov    %r8,%rdi
	}
}
   14f84:	48 83 c4 18          	add    $0x18,%rsp
		params->destroy(params);
   14f88:	ff e0                	jmpq   *%rax
}
   14f8a:	48 83 c4 18          	add    $0x18,%rsp
   14f8e:	c3                   	retq   

0000000000014f8f <match_uuid>:
static uint8_t match_uuid(const struct bt_gatt_attr *attr, uint16_t handle,
			  void *user_data)
{
	struct notify_data *data = user_data;

	data->attr = attr;
   14f8f:	48 89 3a             	mov    %rdi,(%rdx)
	data->handle = handle;
   14f92:	66 89 72 08          	mov    %si,0x8(%rdx)

	return BT_GATT_ITER_STOP;
}
   14f96:	31 c0                	xor    %eax,%eax
   14f98:	c3                   	retq   

0000000000014f99 <ccc_set_cb>:
		/* Only load CCCs on demand */
		return 0;
	}

	return ccc_set(name, len_rd, read_cb, cb_arg);
}
   14f99:	31 c0                	xor    %eax,%eax
   14f9b:	c3                   	retq   

0000000000014f9c <bt_addr_le_copy>:
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
   14f9c:	b9 07 00 00 00       	mov    $0x7,%ecx
   14fa1:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
}
   14fa3:	c3                   	retq   

0000000000014fa4 <write_name>:
{
   14fa4:	53                   	push   %rbx
   14fa5:	48 89 d6             	mov    %rdx,%rsi
   14fa8:	0f b7 d9             	movzwl %cx,%ebx
   14fab:	89 ca                	mov    %ecx,%edx
	char value[CONFIG_BT_DEVICE_NAME_MAX] = {};
   14fad:	b9 41 00 00 00       	mov    $0x41,%ecx
{
   14fb2:	48 83 ec 50          	sub    $0x50,%rsp
   14fb6:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   14fbd:	00 00 
   14fbf:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
   14fc4:	31 c0                	xor    %eax,%eax
	char value[CONFIG_BT_DEVICE_NAME_MAX] = {};
   14fc6:	48 8d 7c 24 07       	lea    0x7(%rsp),%rdi
	if (offset) {
   14fcb:	66 45 85 c0          	test   %r8w,%r8w
	char value[CONFIG_BT_DEVICE_NAME_MAX] = {};
   14fcf:	f3 aa                	rep stos %al,%es:(%rdi)
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   14fd1:	48 c7 c0 f9 ff ff ff 	mov    $0xfffffffffffffff9,%rax
	if (offset) {
   14fd8:	75 2d                	jne    15007 <write_name+0x63>
	if (len >= sizeof(value)) {
   14fda:	66 83 fa 40          	cmp    $0x40,%dx
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
   14fde:	48 c7 c0 f3 ff ff ff 	mov    $0xfffffffffffffff3,%rax
	if (len >= sizeof(value)) {
   14fe5:	77 20                	ja     15007 <write_name+0x63>
   14fe7:	4c 8d 44 24 07       	lea    0x7(%rsp),%r8
   14fec:	b9 41 00 00 00       	mov    $0x41,%ecx
   14ff1:	48 89 da             	mov    %rbx,%rdx
   14ff4:	4c 89 c7             	mov    %r8,%rdi
   14ff7:	e8 74 f7 fe ff       	callq  4770 <__memcpy_chk@plt>
	bt_set_name(value);
   14ffc:	48 89 c7             	mov    %rax,%rdi
   14fff:	e8 60 ae ff ff       	callq  fe64 <bt_set_name>
	return len;
   15004:	48 89 d8             	mov    %rbx,%rax
}
   15007:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
   1500c:	64 48 33 34 25 28 00 	xor    %fs:0x28,%rsi
   15013:	00 00 
   15015:	74 05                	je     1501c <write_name+0x78>
   15017:	e8 24 f6 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1501c:	48 83 c4 50          	add    $0x50,%rsp
   15020:	5b                   	pop    %rbx
   15021:	c3                   	retq   

0000000000015022 <gen_hash_m>:
{
   15022:	41 55                	push   %r13
   15024:	41 54                	push   %r12
   15026:	55                   	push   %rbp
   15027:	53                   	push   %rbx
   15028:	48 83 ec 28          	sub    $0x28,%rsp
	if (attr->uuid->type != BT_UUID_TYPE_16)
   1502c:	48 8b 2f             	mov    (%rdi),%rbp
{
   1502f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   15036:	00 00 
   15038:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1503d:	31 c0                	xor    %eax,%eax
	if (attr->uuid->type != BT_UUID_TYPE_16)
   1503f:	80 7d 00 00          	cmpb   $0x0,0x0(%rbp)
   15043:	0f 85 de 00 00 00    	jne    15127 <gen_hash_m+0x105>
	switch (u16->val) {
   15049:	66 8b 45 02          	mov    0x2(%rbp),%ax
   1504d:	49 89 fc             	mov    %rdi,%r12
   15050:	48 89 d3             	mov    %rdx,%rbx
   15053:	66 3d 00 29          	cmp    $0x2900,%ax
   15057:	74 1d                	je     15076 <gen_hash_m+0x54>
   15059:	77 10                	ja     1506b <gen_hash_m+0x49>
   1505b:	66 2d 00 28          	sub    $0x2800,%ax
   1505f:	66 83 f8 03          	cmp    $0x3,%ax
   15063:	0f 87 be 00 00 00    	ja     15127 <gen_hash_m+0x105>
   15069:	eb 0b                	jmp    15076 <gen_hash_m+0x54>
   1506b:	66 3d 05 29          	cmp    $0x2905,%ax
   1506f:	76 77                	jbe    150e8 <gen_hash_m+0xc6>
   15071:	e9 b1 00 00 00       	jmpq   15127 <gen_hash_m+0x105>
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   15076:	4c 8d 6c 24 06       	lea    0x6(%rsp),%r13
		value = sys_cpu_to_le16(handle);
   1507b:	66 89 74 24 06       	mov    %si,0x6(%rsp)
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   15080:	ba 02 00 00 00       	mov    $0x2,%edx
   15085:	48 89 df             	mov    %rbx,%rdi
   15088:	4c 89 ee             	mov    %r13,%rsi
   1508b:	e8 94 48 ff ff       	callq  9924 <tc_cmac_update>
   15090:	85 c0                	test   %eax,%eax
   15092:	75 09                	jne    1509d <gen_hash_m+0x7b>
			state->err = -EINVAL;
   15094:	c7 43 58 ea ff ff ff 	movl   $0xffffffea,0x58(%rbx)
   1509b:	eb 3f                	jmp    150dc <gen_hash_m+0xba>
		value = sys_cpu_to_le16(u16->val);
   1509d:	66 8b 45 02          	mov    0x2(%rbp),%ax
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   150a1:	ba 02 00 00 00       	mov    $0x2,%edx
   150a6:	4c 89 ee             	mov    %r13,%rsi
   150a9:	48 89 df             	mov    %rbx,%rdi
		value = sys_cpu_to_le16(u16->val);
   150ac:	66 89 44 24 06       	mov    %ax,0x6(%rsp)
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   150b1:	e8 6e 48 ff ff       	callq  9924 <tc_cmac_update>
   150b6:	85 c0                	test   %eax,%eax
   150b8:	74 da                	je     15094 <gen_hash_m+0x72>
		len = attr->read(NULL, attr, data, sizeof(data), 0);
   150ba:	48 8d 6c 24 08       	lea    0x8(%rsp),%rbp
   150bf:	45 31 c0             	xor    %r8d,%r8d
   150c2:	31 ff                	xor    %edi,%edi
   150c4:	b9 10 00 00 00       	mov    $0x10,%ecx
   150c9:	4c 89 e6             	mov    %r12,%rsi
   150cc:	48 89 ea             	mov    %rbp,%rdx
   150cf:	41 ff 54 24 08       	callq  *0x8(%r12)
		if (len < 0) {
   150d4:	48 85 c0             	test   %rax,%rax
   150d7:	79 07                	jns    150e0 <gen_hash_m+0xbe>
			state->err = len;
   150d9:	89 43 58             	mov    %eax,0x58(%rbx)
			return BT_GATT_ITER_STOP;
   150dc:	31 c0                	xor    %eax,%eax
   150de:	eb 49                	jmp    15129 <gen_hash_m+0x107>
		if (tc_cmac_update(&state->state, data, len) ==
   150e0:	48 89 c2             	mov    %rax,%rdx
   150e3:	48 89 ee             	mov    %rbp,%rsi
   150e6:	eb 2f                	jmp    15117 <gen_hash_m+0xf5>
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   150e8:	4c 8d 64 24 06       	lea    0x6(%rsp),%r12
		value = sys_cpu_to_le16(handle);
   150ed:	66 89 74 24 06       	mov    %si,0x6(%rsp)
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   150f2:	ba 02 00 00 00       	mov    $0x2,%edx
   150f7:	48 89 df             	mov    %rbx,%rdi
   150fa:	4c 89 e6             	mov    %r12,%rsi
   150fd:	e8 22 48 ff ff       	callq  9924 <tc_cmac_update>
   15102:	85 c0                	test   %eax,%eax
   15104:	74 8e                	je     15094 <gen_hash_m+0x72>
		value = sys_cpu_to_le16(u16->val);
   15106:	66 8b 45 02          	mov    0x2(%rbp),%ax
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   1510a:	ba 02 00 00 00       	mov    $0x2,%edx
   1510f:	4c 89 e6             	mov    %r12,%rsi
		value = sys_cpu_to_le16(u16->val);
   15112:	66 89 44 24 06       	mov    %ax,0x6(%rsp)
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   15117:	48 89 df             	mov    %rbx,%rdi
   1511a:	e8 05 48 ff ff       	callq  9924 <tc_cmac_update>
   1511f:	85 c0                	test   %eax,%eax
   15121:	0f 84 6d ff ff ff    	je     15094 <gen_hash_m+0x72>
		return BT_GATT_ITER_CONTINUE;
   15127:	b0 01                	mov    $0x1,%al
}
   15129:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   1512e:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   15135:	00 00 
   15137:	74 05                	je     1513e <gen_hash_m+0x11c>
   15139:	e8 02 f5 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1513e:	48 83 c4 28          	add    $0x28,%rsp
   15142:	5b                   	pop    %rbx
   15143:	5d                   	pop    %rbp
   15144:	41 5c                	pop    %r12
   15146:	41 5d                	pop    %r13
   15148:	c3                   	retq   

0000000000015149 <db_hash_store>:
	err = settings_save_one("bt/hash", &db_hash, sizeof(db_hash));
   15149:	48 8d 35 e0 2b 24 00 	lea    0x242be0(%rip),%rsi        # 257d30 <db_hash>
   15150:	48 8d 3d 4e dd 01 00 	lea    0x1dd4e(%rip),%rdi        # 32ea5 <__func__.5785+0x223d>
{
   15157:	48 83 ec 08          	sub    $0x8,%rsp
	err = settings_save_one("bt/hash", &db_hash, sizeof(db_hash));
   1515b:	ba 10 00 00 00       	mov    $0x10,%edx
   15160:	e8 15 32 ff ff       	callq  837a <settings_save_one>
	if (err) {
   15165:	85 c0                	test   %eax,%eax
   15167:	74 28                	je     15191 <db_hash_store+0x48>
   15169:	48 8d 15 50 52 22 00 	lea    0x225250(%rip),%rdx        # 23a3c0 <log_const_bt_gatt>
   15170:	48 2b 15 d9 0d 22 00 	sub    0x220dd9(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Failed to save Database Hash (err %d)", err);
   15177:	48 8d 3d 2f dd 01 00 	lea    0x1dd2f(%rip),%rdi        # 32ead <__func__.5785+0x2245>
}
   1517e:	59                   	pop    %rcx
		BT_ERR("Failed to save Database Hash (err %d)", err);
   1517f:	48 63 f0             	movslq %eax,%rsi
   15182:	48 c1 ea 04          	shr    $0x4,%rdx
   15186:	c1 e2 06             	shl    $0x6,%edx
   15189:	83 ca 01             	or     $0x1,%edx
   1518c:	e9 64 21 ff ff       	jmpq   72f5 <log_1>
}
   15191:	58                   	pop    %rax
   15192:	c3                   	retq   

0000000000015193 <db_hash_set>:

static uint8_t stored_hash[16];

static int db_hash_set(const char *name, size_t len_rd,
		       settings_read_cb read_cb, void *cb_arg)
{
   15193:	53                   	push   %rbx
   15194:	48 89 d0             	mov    %rdx,%rax
	ssize_t len;

	len = read_cb(cb_arg, stored_hash, sizeof(stored_hash));
   15197:	48 8d 35 82 2b 24 00 	lea    0x242b82(%rip),%rsi        # 257d20 <stored_hash>
   1519e:	ba 10 00 00 00       	mov    $0x10,%edx
   151a3:	48 89 cf             	mov    %rcx,%rdi
   151a6:	ff d0                	callq  *%rax
   151a8:	48 89 c3             	mov    %rax,%rbx
   151ab:	31 c0                	xor    %eax,%eax
	if (len < 0) {
   151ad:	48 85 db             	test   %rbx,%rbx
   151b0:	79 29                	jns    151db <db_hash_set+0x48>
   151b2:	48 8d 15 07 52 22 00 	lea    0x225207(%rip),%rdx        # 23a3c0 <log_const_bt_gatt>
   151b9:	48 2b 15 90 0d 22 00 	sub    0x220d90(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Failed to decode value (err %zd)", len);
   151c0:	48 8d 3d 0c dd 01 00 	lea    0x1dd0c(%rip),%rdi        # 32ed3 <__func__.5785+0x226b>
   151c7:	48 89 de             	mov    %rbx,%rsi
   151ca:	48 c1 ea 04          	shr    $0x4,%rdx
   151ce:	c1 e2 06             	shl    $0x6,%edx
   151d1:	83 ca 01             	or     $0x1,%edx
   151d4:	e8 1c 21 ff ff       	callq  72f5 <log_1>
		return len;
   151d9:	89 d8                	mov    %ebx,%eax
	}

	BT_HEXDUMP_DBG(stored_hash, sizeof(stored_hash), "Stored Hash: ");

	return 0;
}
   151db:	5b                   	pop    %rbx
   151dc:	c3                   	retq   

00000000000151dd <bt_addr_le_cmp>:
	return memcmp(a, b, sizeof(*a));
   151dd:	ba 07 00 00 00       	mov    $0x7,%edx
   151e2:	e9 59 f2 fe ff       	jmpq   4440 <memcmp@plt>

00000000000151e7 <find_cf_cfg>:
{
   151e7:	48 83 ec 18          	sub    $0x18,%rsp
   151eb:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   151f2:	00 00 
   151f4:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   151f9:	31 c0                	xor    %eax,%eax
		if (!conn) {
   151fb:	48 85 ff             	test   %rdi,%rdi
   151fe:	75 2a                	jne    1522a <find_cf_cfg+0x43>
			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   15200:	48 8d 7c 24 01       	lea    0x1(%rsp),%rdi
   15205:	b9 07 00 00 00       	mov    $0x7,%ecx
   1520a:	48 8d 74 24 01       	lea    0x1(%rsp),%rsi
   1520f:	f3 aa                	rep stos %al,%es:(%rdi)
   15211:	48 8d 3d 29 2b 24 00 	lea    0x242b29(%rip),%rdi        # 257d41 <cf_cfg+0x1>
   15218:	e8 c0 ff ff ff       	callq  151dd <bt_addr_le_cmp>
   1521d:	85 c0                	test   %eax,%eax
   1521f:	75 20                	jne    15241 <find_cf_cfg+0x5a>
				return cfg;
   15221:	48 8d 05 18 2b 24 00 	lea    0x242b18(%rip),%rax        # 257d40 <cf_cfg>
   15228:	eb 19                	jmp    15243 <find_cf_cfg+0x5c>
		} else if (bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
   1522a:	0f b6 35 0f 2b 24 00 	movzbl 0x242b0f(%rip),%esi        # 257d40 <cf_cfg>
   15231:	48 8d 15 09 2b 24 00 	lea    0x242b09(%rip),%rdx        # 257d41 <cf_cfg+0x1>
   15238:	e8 ac c4 ff ff       	callq  116e9 <bt_conn_is_peer_addr_le>
   1523d:	84 c0                	test   %al,%al
   1523f:	75 e0                	jne    15221 <find_cf_cfg+0x3a>
	return NULL;
   15241:	31 c0                	xor    %eax,%eax
}
   15243:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   15248:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
   1524f:	00 00 
   15251:	74 05                	je     15258 <find_cf_cfg+0x71>
   15253:	e8 e8 f3 fe ff       	callq  4640 <__stack_chk_fail@plt>
   15258:	48 83 c4 18          	add    $0x18,%rsp
   1525c:	c3                   	retq   

000000000001525d <find_sc_cfg>:
		if (id == sc_cfg[i].id &&
   1525d:	40 3a 3d 44 2d 24 00 	cmp    0x242d44(%rip),%dil        # 257fa8 <sc_cfg>
   15264:	75 24                	jne    1528a <find_sc_cfg+0x2d>
		    !bt_addr_le_cmp(&sc_cfg[i].peer, addr)) {
   15266:	48 8d 3d 3c 2d 24 00 	lea    0x242d3c(%rip),%rdi        # 257fa9 <sc_cfg+0x1>
{
   1526d:	48 83 ec 08          	sub    $0x8,%rsp
		    !bt_addr_le_cmp(&sc_cfg[i].peer, addr)) {
   15271:	e8 67 ff ff ff       	callq  151dd <bt_addr_le_cmp>
			return &sc_cfg[i];
   15276:	85 c0                	test   %eax,%eax
   15278:	48 8d 05 29 2d 24 00 	lea    0x242d29(%rip),%rax        # 257fa8 <sc_cfg>
   1527f:	ba 00 00 00 00       	mov    $0x0,%edx
   15284:	48 0f 45 c2          	cmovne %rdx,%rax
}
   15288:	5a                   	pop    %rdx
   15289:	c3                   	retq   
   1528a:	31 c0                	xor    %eax,%eax
   1528c:	c3                   	retq   

000000000001528d <find_ccc_cfg>:
{
   1528d:	53                   	push   %rbx
   1528e:	48 8d 56 01          	lea    0x1(%rsi),%rdx
		struct bt_gatt_ccc_cfg *cfg = &ccc->cfg[i];
   15292:	48 89 f3             	mov    %rsi,%rbx
{
   15295:	48 83 ec 10          	sub    $0x10,%rsp
   15299:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   152a0:	00 00 
   152a2:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   152a7:	31 c0                	xor    %eax,%eax
		if (conn) {
   152a9:	48 85 ff             	test   %rdi,%rdi
   152ac:	74 0e                	je     152bc <find_ccc_cfg+0x2f>
			if (bt_conn_is_peer_addr_le(conn, cfg->id,
   152ae:	0f b6 36             	movzbl (%rsi),%esi
   152b1:	e8 33 c4 ff ff       	callq  116e9 <bt_conn_is_peer_addr_le>
   152b6:	84 c0                	test   %al,%al
   152b8:	74 21                	je     152db <find_ccc_cfg+0x4e>
   152ba:	eb 21                	jmp    152dd <find_ccc_cfg+0x50>
		} else if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   152bc:	48 8d 7c 24 01       	lea    0x1(%rsp),%rdi
   152c1:	31 c0                	xor    %eax,%eax
   152c3:	b9 07 00 00 00       	mov    $0x7,%ecx
   152c8:	48 8d 74 24 01       	lea    0x1(%rsp),%rsi
   152cd:	f3 aa                	rep stos %al,%es:(%rdi)
   152cf:	48 89 d7             	mov    %rdx,%rdi
   152d2:	e8 06 ff ff ff       	callq  151dd <bt_addr_le_cmp>
   152d7:	85 c0                	test   %eax,%eax
   152d9:	74 02                	je     152dd <find_ccc_cfg+0x50>
	return NULL;
   152db:	31 db                	xor    %ebx,%ebx
}
   152dd:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
   152e2:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   152e9:	00 00 
   152eb:	48 89 d8             	mov    %rbx,%rax
   152ee:	74 05                	je     152f5 <find_ccc_cfg+0x68>
   152f0:	e8 4b f3 fe ff       	callq  4640 <__stack_chk_fail@plt>
   152f5:	48 83 c4 10          	add    $0x10,%rsp
   152f9:	5b                   	pop    %rbx
   152fa:	c3                   	retq   

00000000000152fb <bt_gatt_attr_write_ccc>:
{
   152fb:	41 57                	push   %r15
   152fd:	41 56                	push   %r14
   152ff:	41 55                	push   %r13
   15301:	41 54                	push   %r12
   15303:	55                   	push   %rbp
   15304:	53                   	push   %rbx
   15305:	48 83 ec 18          	sub    $0x18,%rsp
	struct _bt_gatt_ccc *ccc = attr->user_data;
   15309:	4c 8b 66 18          	mov    0x18(%rsi),%r12
{
   1530d:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   15314:	00 00 
   15316:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   1531b:	31 c0                	xor    %eax,%eax
	if (offset) {
   1531d:	66 45 85 c0          	test   %r8w,%r8w
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   15321:	48 c7 c0 f9 ff ff ff 	mov    $0xfffffffffffffff9,%rax
	if (offset) {
   15328:	0f 85 20 01 00 00    	jne    1544e <bt_gatt_attr_write_ccc+0x153>
   1532e:	49 89 f6             	mov    %rsi,%r14
	if (!len || len > sizeof(uint16_t)) {
   15331:	8d 71 ff             	lea    -0x1(%rcx),%esi
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
   15334:	48 c7 c0 f3 ff ff ff 	mov    $0xfffffffffffffff3,%rax
	if (!len || len > sizeof(uint16_t)) {
   1533b:	66 83 fe 01          	cmp    $0x1,%si
   1533f:	0f 87 09 01 00 00    	ja     1544e <bt_gatt_attr_write_ccc+0x153>
   15345:	41 89 cf             	mov    %ecx,%r15d
	if (len < sizeof(uint16_t)) {
   15348:	66 ff c9             	dec    %cx
   1534b:	49 89 fd             	mov    %rdi,%r13
   1534e:	0f b6 2a             	movzbl (%rdx),%ebp
   15351:	74 09                	je     1535c <bt_gatt_attr_write_ccc+0x61>
   15353:	0f b6 42 01          	movzbl 0x1(%rdx),%eax
   15357:	c1 e0 08             	shl    $0x8,%eax
   1535a:	09 c5                	or     %eax,%ebp
	cfg = find_ccc_cfg(conn, ccc);
   1535c:	4c 89 e6             	mov    %r12,%rsi
   1535f:	4c 89 ef             	mov    %r13,%rdi
   15362:	e8 26 ff ff ff       	callq  1528d <find_ccc_cfg>
	if (!cfg) {
   15367:	48 85 c0             	test   %rax,%rax
	cfg = find_ccc_cfg(conn, ccc);
   1536a:	48 89 c3             	mov    %rax,%rbx
	if (!cfg) {
   1536d:	75 66                	jne    153d5 <bt_gatt_attr_write_ccc+0xda>
		if (!value) {
   1536f:	66 85 ed             	test   %bp,%bp
   15372:	75 09                	jne    1537d <bt_gatt_attr_write_ccc+0x82>
			return len;
   15374:	41 0f b7 c7          	movzwl %r15w,%eax
   15378:	e9 d1 00 00 00       	jmpq   1544e <bt_gatt_attr_write_ccc+0x153>
		cfg = find_ccc_cfg(NULL, ccc);
   1537d:	31 ff                	xor    %edi,%edi
   1537f:	4c 89 e6             	mov    %r12,%rsi
   15382:	e8 06 ff ff ff       	callq  1528d <find_ccc_cfg>
		if (!cfg) {
   15387:	48 85 c0             	test   %rax,%rax
		cfg = find_ccc_cfg(NULL, ccc);
   1538a:	48 89 c3             	mov    %rax,%rbx
		if (!cfg) {
   1538d:	75 30                	jne    153bf <bt_gatt_attr_write_ccc+0xc4>
   1538f:	48 8d 35 2a 50 22 00 	lea    0x22502a(%rip),%rsi        # 23a3c0 <log_const_bt_gatt>
   15396:	48 2b 35 b3 0b 22 00 	sub    0x220bb3(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_WARN("No space to store CCC cfg");
   1539d:	48 8d 3d 50 db 01 00 	lea    0x1db50(%rip),%rdi        # 32ef4 <__func__.5785+0x228c>
   153a4:	48 c1 ee 04          	shr    $0x4,%rsi
   153a8:	c1 e6 06             	shl    $0x6,%esi
   153ab:	83 ce 02             	or     $0x2,%esi
   153ae:	e8 11 1f ff ff       	callq  72c4 <log_0>
			return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
   153b3:	48 c7 c0 ef ff ff ff 	mov    $0xffffffffffffffef,%rax
   153ba:	e9 8f 00 00 00       	jmpq   1544e <bt_gatt_attr_write_ccc+0x153>
		bt_addr_le_copy(&cfg->peer, &conn->le.dst);
   153bf:	48 8d 78 01          	lea    0x1(%rax),%rdi
   153c3:	49 8d b5 d8 00 00 00 	lea    0xd8(%r13),%rsi
   153ca:	e8 cd fb ff ff       	callq  14f9c <bt_addr_le_copy>
		cfg->id = conn->id;
   153cf:	41 8a 45 08          	mov    0x8(%r13),%al
   153d3:	88 03                	mov    %al,(%rbx)
	if (ccc->cfg_write) {
   153d5:	49 8b 44 24 18       	mov    0x18(%r12),%rax
   153da:	48 85 c0             	test   %rax,%rax
   153dd:	75 19                	jne    153f8 <bt_gatt_attr_write_ccc+0xfd>
	if (cfg->value != ccc->value) {
   153df:	66 41 3b 6c 24 0a    	cmp    0xa(%r12),%bp
	cfg->value = value;
   153e5:	66 89 6b 08          	mov    %bp,0x8(%rbx)
	if (cfg->value != ccc->value) {
   153e9:	74 30                	je     1541b <bt_gatt_attr_write_ccc+0x120>
		gatt_ccc_changed(attr, ccc);
   153eb:	4c 89 e6             	mov    %r12,%rsi
   153ee:	4c 89 f7             	mov    %r14,%rdi
   153f1:	e8 42 fb ff ff       	callq  14f38 <gatt_ccc_changed>
   153f6:	eb 23                	jmp    1541b <bt_gatt_attr_write_ccc+0x120>
		ssize_t write = ccc->cfg_write(conn, attr, value);
   153f8:	0f b7 d5             	movzwl %bp,%edx
   153fb:	4c 89 f6             	mov    %r14,%rsi
   153fe:	4c 89 ef             	mov    %r13,%rdi
   15401:	ff d0                	callq  *%rax
		if (write < 0) {
   15403:	48 85 c0             	test   %rax,%rax
   15406:	78 46                	js     1544e <bt_gatt_attr_write_ccc+0x153>
		if (write != sizeof(value) && write != 1) {
   15408:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
			return BT_GATT_ERR(BT_ATT_ERR_UNLIKELY);
   1540c:	48 c7 c0 f2 ff ff ff 	mov    $0xfffffffffffffff2,%rax
		if (write != sizeof(value) && write != 1) {
   15413:	48 83 fa 01          	cmp    $0x1,%rdx
   15417:	76 c6                	jbe    153df <bt_gatt_attr_write_ccc+0xe4>
   15419:	eb 33                	jmp    1544e <bt_gatt_attr_write_ccc+0x153>
	if (!value) {
   1541b:	66 85 ed             	test   %bp,%bp
   1541e:	0f 85 50 ff ff ff    	jne    15374 <bt_gatt_attr_write_ccc+0x79>
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   15424:	48 8d 7c 24 01       	lea    0x1(%rsp),%rdi
   15429:	31 c0                	xor    %eax,%eax
   1542b:	b9 07 00 00 00       	mov    $0x7,%ecx
   15430:	48 8d 74 24 01       	lea    0x1(%rsp),%rsi
   15435:	f3 aa                	rep stos %al,%es:(%rdi)
   15437:	48 8d 7b 01          	lea    0x1(%rbx),%rdi
   1543b:	e8 5c fb ff ff       	callq  14f9c <bt_addr_le_copy>
	cfg->id = 0U;
   15440:	c6 03 00             	movb   $0x0,(%rbx)
	cfg->value = 0U;
   15443:	66 c7 43 08 00 00    	movw   $0x0,0x8(%rbx)
   15449:	e9 26 ff ff ff       	jmpq   15374 <bt_gatt_attr_write_ccc+0x79>
}
   1544e:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
   15453:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1545a:	00 00 
   1545c:	74 05                	je     15463 <bt_gatt_attr_write_ccc+0x168>
   1545e:	e8 dd f1 fe ff       	callq  4640 <__stack_chk_fail@plt>
   15463:	48 83 c4 18          	add    $0x18,%rsp
   15467:	5b                   	pop    %rbx
   15468:	5d                   	pop    %rbp
   15469:	41 5c                	pop    %r12
   1546b:	41 5d                	pop    %r13
   1546d:	41 5e                	pop    %r14
   1546f:	41 5f                	pop    %r15
   15471:	c3                   	retq   

0000000000015472 <gatt_sub_find>:
{
   15472:	48 83 ec 18          	sub    $0x18,%rsp
   15476:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1547d:	00 00 
   1547f:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   15484:	31 c0                	xor    %eax,%eax
		if (!conn) {
   15486:	48 85 ff             	test   %rdi,%rdi
   15489:	75 2a                	jne    154b5 <gatt_sub_find+0x43>
			if (!bt_addr_le_cmp(&sub->peer, BT_ADDR_LE_ANY)) {
   1548b:	48 8d 7c 24 01       	lea    0x1(%rsp),%rdi
   15490:	b9 07 00 00 00       	mov    $0x7,%ecx
   15495:	48 8d 74 24 01       	lea    0x1(%rsp),%rsi
   1549a:	f3 aa                	rep stos %al,%es:(%rdi)
   1549c:	48 8d 3d ae 28 24 00 	lea    0x2428ae(%rip),%rdi        # 257d51 <subscriptions+0x1>
   154a3:	e8 35 fd ff ff       	callq  151dd <bt_addr_le_cmp>
   154a8:	85 c0                	test   %eax,%eax
   154aa:	75 20                	jne    154cc <gatt_sub_find+0x5a>
				return sub;
   154ac:	48 8d 05 9d 28 24 00 	lea    0x24289d(%rip),%rax        # 257d50 <subscriptions>
   154b3:	eb 19                	jmp    154ce <gatt_sub_find+0x5c>
		} else if (bt_conn_is_peer_addr_le(conn, sub->id, &sub->peer)) {
   154b5:	0f b6 35 94 28 24 00 	movzbl 0x242894(%rip),%esi        # 257d50 <subscriptions>
   154bc:	48 8d 15 8e 28 24 00 	lea    0x24288e(%rip),%rdx        # 257d51 <subscriptions+0x1>
   154c3:	e8 21 c2 ff ff       	callq  116e9 <bt_conn_is_peer_addr_le>
   154c8:	84 c0                	test   %al,%al
   154ca:	75 e0                	jne    154ac <gatt_sub_find+0x3a>
	return NULL;
   154cc:	31 c0                	xor    %eax,%eax
}
   154ce:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   154d3:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
   154da:	00 00 
   154dc:	74 05                	je     154e3 <gatt_sub_find+0x71>
   154de:	e8 5d f1 fe ff       	callq  4640 <__stack_chk_fail@plt>
   154e3:	48 83 c4 18          	add    $0x18,%rsp
   154e7:	c3                   	retq   

00000000000154e8 <ccc_find_cfg>:
		if (id == ccc->cfg[i].id &&
   154e8:	38 17                	cmp    %dl,(%rdi)
   154ea:	75 1a                	jne    15506 <ccc_find_cfg+0x1e>
{
   154ec:	53                   	push   %rbx
   154ed:	48 89 fb             	mov    %rdi,%rbx
		    !bt_addr_le_cmp(&ccc->cfg[i].peer, addr)) {
   154f0:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
   154f4:	e8 e4 fc ff ff       	callq  151dd <bt_addr_le_cmp>
			return &ccc->cfg[i];
   154f9:	85 c0                	test   %eax,%eax
   154fb:	b8 00 00 00 00       	mov    $0x0,%eax
   15500:	48 0f 44 c3          	cmove  %rbx,%rax
}
   15504:	5b                   	pop    %rbx
   15505:	c3                   	retq   
   15506:	31 c0                	xor    %eax,%eax
   15508:	c3                   	retq   

0000000000015509 <sc_store>:
{
   15509:	55                   	push   %rbp
   1550a:	53                   	push   %rbx
		bt_settings_encode_key(key, sizeof(key), "sc",
   1550b:	45 31 c0             	xor    %r8d,%r8d
{
   1550e:	48 89 fb             	mov    %rdi,%rbx
   15511:	48 8d 4f 01          	lea    0x1(%rdi),%rcx
   15515:	48 83 ec 48          	sub    $0x48,%rsp
	if (cfg->id) {
   15519:	0f b6 17             	movzbl (%rdi),%edx
{
   1551c:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   15523:	00 00 
   15525:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
   1552a:	31 c0                	xor    %eax,%eax
   1552c:	48 8d 6c 24 14       	lea    0x14(%rsp),%rbp
	if (cfg->id) {
   15531:	84 d2                	test   %dl,%dl
   15533:	74 24                	je     15559 <sc_store+0x50>
		u8_to_dec(id_str, sizeof(id_str), cfg->id);
   15535:	4c 8d 44 24 10       	lea    0x10(%rsp),%r8
   1553a:	be 04 00 00 00       	mov    $0x4,%esi
   1553f:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
   15544:	4c 89 c7             	mov    %r8,%rdi
   15547:	4c 89 04 24          	mov    %r8,(%rsp)
   1554b:	e8 3b 02 ff ff       	callq  578b <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "sc",
   15550:	4c 8b 04 24          	mov    (%rsp),%r8
   15554:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
		bt_settings_encode_key(key, sizeof(key), "sc",
   15559:	48 8d 15 56 dc 01 00 	lea    0x1dc56(%rip),%rdx        # 331b6 <__func__.5785+0x254e>
   15560:	be 24 00 00 00       	mov    $0x24,%esi
   15565:	48 89 ef             	mov    %rbp,%rdi
   15568:	e8 97 7d ff ff       	callq  d304 <bt_settings_encode_key>
	err = settings_save_one(key, (char *)&cfg->data, sizeof(cfg->data));
   1556d:	48 8d 73 08          	lea    0x8(%rbx),%rsi
   15571:	ba 04 00 00 00       	mov    $0x4,%edx
   15576:	48 89 ef             	mov    %rbp,%rdi
   15579:	e8 fc 2d ff ff       	callq  837a <settings_save_one>
	if (err) {
   1557e:	85 c0                	test   %eax,%eax
   15580:	74 27                	je     155a9 <sc_store+0xa0>
   15582:	48 8d 15 37 4e 22 00 	lea    0x224e37(%rip),%rdx        # 23a3c0 <log_const_bt_gatt>
   15589:	48 2b 15 c0 09 22 00 	sub    0x2209c0(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("failed to store SC (err %d)", err);
   15590:	48 8d 3d 77 d9 01 00 	lea    0x1d977(%rip),%rdi        # 32f0e <__func__.5785+0x22a6>
   15597:	48 63 f0             	movslq %eax,%rsi
   1559a:	48 c1 ea 04          	shr    $0x4,%rdx
   1559e:	c1 e2 06             	shl    $0x6,%edx
   155a1:	83 ca 01             	or     $0x1,%edx
   155a4:	e8 4c 1d ff ff       	callq  72f5 <log_1>
}
   155a9:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
   155ae:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   155b5:	00 00 
   155b7:	74 05                	je     155be <sc_store+0xb5>
   155b9:	e8 82 f0 fe ff       	callq  4640 <__stack_chk_fail@plt>
   155be:	48 83 c4 48          	add    $0x48,%rsp
   155c2:	5b                   	pop    %rbx
   155c3:	5d                   	pop    %rbp
   155c4:	c3                   	retq   

00000000000155c5 <atomic_test_bit>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   155c5:	8b 07                	mov    (%rdi),%eax
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   155c7:	40 88 f1             	mov    %sil,%cl
   155ca:	d3 f8                	sar    %cl,%eax
   155cc:	83 e0 01             	and    $0x1,%eax
}
   155cf:	c3                   	retq   

00000000000155d0 <atomic_and>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   155d0:	8b 07                	mov    (%rdi),%eax
   155d2:	89 c1                	mov    %eax,%ecx
   155d4:	89 c2                	mov    %eax,%edx
   155d6:	21 f1                	and    %esi,%ecx
   155d8:	f0 0f b1 0f          	lock cmpxchg %ecx,(%rdi)
   155dc:	75 f4                	jne    155d2 <atomic_and+0x2>
}
   155de:	89 d0                	mov    %edx,%eax
   155e0:	c3                   	retq   

00000000000155e1 <sc_set>:
{
   155e1:	41 57                	push   %r15
   155e3:	41 56                	push   %r14
   155e5:	41 55                	push   %r13
   155e7:	41 54                	push   %r12
   155e9:	55                   	push   %rbp
   155ea:	53                   	push   %rbx
   155eb:	48 83 ec 28          	sub    $0x28,%rsp
   155ef:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   155f6:	00 00 
   155f8:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   155fd:	31 c0                	xor    %eax,%eax
	if (!name) {
   155ff:	48 85 ff             	test   %rdi,%rdi
   15602:	75 26                	jne    1562a <sc_set+0x49>
   15604:	48 8d 35 b5 4d 22 00 	lea    0x224db5(%rip),%rsi        # 23a3c0 <log_const_bt_gatt>
   1560b:	48 2b 35 3e 09 22 00 	sub    0x22093e(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Insufficient number of arguments");
   15612:	48 8d 3d 1b cc 01 00 	lea    0x1cc1b(%rip),%rdi        # 32234 <__func__.5785+0x15cc>
   15619:	48 c1 ee 04          	shr    $0x4,%rsi
   1561d:	c1 e6 06             	shl    $0x6,%esi
   15620:	83 ce 01             	or     $0x1,%esi
   15623:	e8 9c 1c ff ff       	callq  72c4 <log_0>
   15628:	eb 50                	jmp    1567a <sc_set+0x99>
	err = bt_settings_decode_key(name, &addr);
   1562a:	4c 8d 64 24 0a       	lea    0xa(%rsp),%r12
   1562f:	49 89 f5             	mov    %rsi,%r13
   15632:	48 89 fd             	mov    %rdi,%rbp
   15635:	49 89 d6             	mov    %rdx,%r14
   15638:	49 89 cf             	mov    %rcx,%r15
   1563b:	4c 89 e6             	mov    %r12,%rsi
   1563e:	e8 26 7d ff ff       	callq  d369 <bt_settings_decode_key>
	if (err) {
   15643:	85 c0                	test   %eax,%eax
	err = bt_settings_decode_key(name, &addr);
   15645:	89 c3                	mov    %eax,%ebx
	if (err) {
   15647:	74 3b                	je     15684 <sc_set+0xa3>
   15649:	48 8d 1d 70 4d 22 00 	lea    0x224d70(%rip),%rbx        # 23a3c0 <log_const_bt_gatt>
   15650:	48 2b 1d f9 08 22 00 	sub    0x2208f9(%rip),%rbx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unable to decode address %s", log_strdup(name));
   15657:	48 89 ef             	mov    %rbp,%rdi
   1565a:	e8 b1 18 ff ff       	callq  6f10 <log_strdup>
   1565f:	48 8d 3d c4 d8 01 00 	lea    0x1d8c4(%rip),%rdi        # 32f2a <__func__.5785+0x22c2>
   15666:	48 89 c6             	mov    %rax,%rsi
   15669:	48 c1 eb 04          	shr    $0x4,%rbx
   1566d:	c1 e3 06             	shl    $0x6,%ebx
   15670:	83 cb 01             	or     $0x1,%ebx
   15673:	89 da                	mov    %ebx,%edx
   15675:	e8 7b 1c ff ff       	callq  72f5 <log_1>
		return -EINVAL;
   1567a:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
   1567f:	e9 f4 00 00 00       	jmpq   15778 <sc_set+0x197>
	settings_name_next(name, &next);
   15684:	48 89 ef             	mov    %rbp,%rdi
   15687:	48 89 e6             	mov    %rsp,%rsi
		id = BT_ID_DEFAULT;
   1568a:	31 ed                	xor    %ebp,%ebp
	settings_name_next(name, &next);
   1568c:	e8 fe 2e ff ff       	callq  858f <settings_name_next>
	if (!next) {
   15691:	48 8b 3c 24          	mov    (%rsp),%rdi
   15695:	48 85 ff             	test   %rdi,%rdi
   15698:	74 0f                	je     156a9 <sc_set+0xc8>
		id = strtol(next, NULL, 10);
   1569a:	ba 0a 00 00 00       	mov    $0xa,%edx
   1569f:	31 f6                	xor    %esi,%esi
   156a1:	e8 1a f0 fe ff       	callq  46c0 <strtol@plt>
   156a6:	40 88 c5             	mov    %al,%bpl
	cfg = find_sc_cfg(id, &addr);
   156a9:	40 0f b6 fd          	movzbl %bpl,%edi
   156ad:	4c 89 e6             	mov    %r12,%rsi
   156b0:	e8 a8 fb ff ff       	callq  1525d <find_sc_cfg>
	if (!cfg && len_rd) {
   156b5:	48 85 c0             	test   %rax,%rax
	cfg = find_sc_cfg(id, &addr);
   156b8:	48 89 c2             	mov    %rax,%rdx
	if (!cfg && len_rd) {
   156bb:	75 63                	jne    15720 <sc_set+0x13f>
   156bd:	4d 85 ed             	test   %r13,%r13
   156c0:	74 5e                	je     15720 <sc_set+0x13f>
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
   156c2:	48 8d 7c 24 11       	lea    0x11(%rsp),%rdi
   156c7:	31 c0                	xor    %eax,%eax
   156c9:	b9 07 00 00 00       	mov    $0x7,%ecx
   156ce:	48 8d 74 24 11       	lea    0x11(%rsp),%rsi
   156d3:	f3 aa                	rep stos %al,%es:(%rdi)
   156d5:	31 ff                	xor    %edi,%edi
   156d7:	e8 81 fb ff ff       	callq  1525d <find_sc_cfg>
		if (!cfg) {
   156dc:	48 85 c0             	test   %rax,%rax
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
   156df:	48 89 c2             	mov    %rax,%rdx
		if (!cfg) {
   156e2:	75 2b                	jne    1570f <sc_set+0x12e>
   156e4:	48 8d 35 d5 4c 22 00 	lea    0x224cd5(%rip),%rsi        # 23a3c0 <log_const_bt_gatt>
   156eb:	48 2b 35 5e 08 22 00 	sub    0x22085e(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Unable to restore SC: no cfg left");
   156f2:	48 8d 3d 4d d8 01 00 	lea    0x1d84d(%rip),%rdi        # 32f46 <__func__.5785+0x22de>
			return -ENOMEM;
   156f9:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
   156fe:	48 c1 ee 04          	shr    $0x4,%rsi
			BT_ERR("Unable to restore SC: no cfg left");
   15702:	c1 e6 06             	shl    $0x6,%esi
   15705:	83 ce 01             	or     $0x1,%esi
   15708:	e8 b7 1b ff ff       	callq  72c4 <log_0>
			return -ENOMEM;
   1570d:	eb 69                	jmp    15778 <sc_set+0x197>
		bt_addr_le_copy(&cfg->peer, &addr);
   1570f:	48 8d 78 01          	lea    0x1(%rax),%rdi
		cfg->id = id;
   15713:	40 88 28             	mov    %bpl,(%rax)
		bt_addr_le_copy(&cfg->peer, &addr);
   15716:	4c 89 e6             	mov    %r12,%rsi
   15719:	e8 7e f8 ff ff       	callq  14f9c <bt_addr_le_copy>
   1571e:	eb 05                	jmp    15725 <sc_set+0x144>
	if (len_rd) {
   15720:	4d 85 ed             	test   %r13,%r13
   15723:	74 42                	je     15767 <sc_set+0x186>
		len = read_cb(cb_arg, &cfg->data, sizeof(cfg->data));
   15725:	48 8d 72 08          	lea    0x8(%rdx),%rsi
   15729:	4c 89 ff             	mov    %r15,%rdi
   1572c:	ba 04 00 00 00       	mov    $0x4,%edx
   15731:	41 ff d6             	callq  *%r14
		if (len < 0) {
   15734:	48 85 c0             	test   %rax,%rax
		len = read_cb(cb_arg, &cfg->data, sizeof(cfg->data));
   15737:	48 89 c5             	mov    %rax,%rbp
		if (len < 0) {
   1573a:	79 3c                	jns    15778 <sc_set+0x197>
   1573c:	48 8d 15 7d 4c 22 00 	lea    0x224c7d(%rip),%rdx        # 23a3c0 <log_const_bt_gatt>
   15743:	48 2b 15 06 08 22 00 	sub    0x220806(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Failed to decode value (err %zd)", len);
   1574a:	48 8d 3d 82 d7 01 00 	lea    0x1d782(%rip),%rdi        # 32ed3 <__func__.5785+0x226b>
   15751:	48 89 c6             	mov    %rax,%rsi
			return len;
   15754:	89 eb                	mov    %ebp,%ebx
   15756:	48 c1 ea 04          	shr    $0x4,%rdx
			BT_ERR("Failed to decode value (err %zd)", len);
   1575a:	c1 e2 06             	shl    $0x6,%edx
   1575d:	83 ca 01             	or     $0x1,%edx
   15760:	e8 90 1b ff ff       	callq  72f5 <log_1>
			return len;
   15765:	eb 11                	jmp    15778 <sc_set+0x197>
	} else if (cfg) {
   15767:	48 85 d2             	test   %rdx,%rdx
   1576a:	74 0c                	je     15778 <sc_set+0x197>
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
   1576c:	b9 03 00 00 00       	mov    $0x3,%ecx
   15771:	31 c0                	xor    %eax,%eax
   15773:	48 89 d7             	mov    %rdx,%rdi
   15776:	f3 ab                	rep stos %eax,%es:(%rdi)
}
   15778:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   1577d:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   15784:	00 00 
   15786:	89 d8                	mov    %ebx,%eax
   15788:	74 05                	je     1578f <sc_set+0x1ae>
   1578a:	e8 b1 ee fe ff       	callq  4640 <__stack_chk_fail@plt>
   1578f:	48 83 c4 28          	add    $0x28,%rsp
   15793:	5b                   	pop    %rbx
   15794:	5d                   	pop    %rbp
   15795:	41 5c                	pop    %r12
   15797:	41 5d                	pop    %r13
   15799:	41 5e                	pop    %r14
   1579b:	41 5f                	pop    %r15
   1579d:	c3                   	retq   

000000000001579e <gatt_sub_remove.part.4>:
static void gatt_sub_remove(struct bt_conn *conn, struct gatt_sub *sub,
   1579e:	48 83 ec 18          	sub    $0x18,%rsp
   157a2:	48 89 fa             	mov    %rdi,%rdx
		bt_addr_le_copy(&sub->peer, BT_ADDR_LE_ANY);
   157a5:	b9 07 00 00 00       	mov    $0x7,%ecx
static void gatt_sub_remove(struct bt_conn *conn, struct gatt_sub *sub,
   157aa:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   157b1:	00 00 
   157b3:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   157b8:	31 c0                	xor    %eax,%eax
		bt_addr_le_copy(&sub->peer, BT_ADDR_LE_ANY);
   157ba:	48 8d 7c 24 01       	lea    0x1(%rsp),%rdi
   157bf:	48 8d 74 24 01       	lea    0x1(%rsp),%rsi
   157c4:	f3 aa                	rep stos %al,%es:(%rdi)
   157c6:	48 8d 7a 01          	lea    0x1(%rdx),%rdi
   157ca:	e8 cd f7 ff ff       	callq  14f9c <bt_addr_le_copy>
}
   157cf:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   157d4:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   157db:	00 00 
   157dd:	74 05                	je     157e4 <gatt_sub_remove.part.4+0x46>
   157df:	e8 5c ee fe ff       	callq  4640 <__stack_chk_fail@plt>
   157e4:	48 83 c4 18          	add    $0x18,%rsp
   157e8:	c3                   	retq   

00000000000157e9 <gatt_read_mult_rsp>:
{
   157e9:	55                   	push   %rbp
   157ea:	53                   	push   %rbx
   157eb:	4c 89 c3             	mov    %r8,%rbx
   157ee:	48 83 ec 08          	sub    $0x8,%rsp
	if (err || !length) {
   157f2:	40 84 f6             	test   %sil,%sil
   157f5:	49 8b 00             	mov    (%r8),%rax
   157f8:	75 05                	jne    157ff <gatt_read_mult_rsp+0x16>
   157fa:	66 85 c9             	test   %cx,%cx
   157fd:	75 0e                	jne    1580d <gatt_read_mult_rsp+0x24>
		params->func(conn, err, params, NULL, 0);
   157ff:	40 0f b6 f6          	movzbl %sil,%esi
   15803:	45 31 c0             	xor    %r8d,%r8d
   15806:	31 c9                	xor    %ecx,%ecx
   15808:	48 89 da             	mov    %rbx,%rdx
   1580b:	eb 24                	jmp    15831 <gatt_read_mult_rsp+0x48>
   1580d:	41 89 c8             	mov    %ecx,%r8d
   15810:	48 89 fd             	mov    %rdi,%rbp
   15813:	48 89 d1             	mov    %rdx,%rcx
	params->func(conn, 0, params, pdu, length);
   15816:	45 0f b7 c0          	movzwl %r8w,%r8d
   1581a:	48 89 da             	mov    %rbx,%rdx
   1581d:	31 f6                	xor    %esi,%esi
   1581f:	ff d0                	callq  *%rax
	params->func(conn, 0, params, NULL, 0);
   15821:	48 8b 03             	mov    (%rbx),%rax
   15824:	45 31 c0             	xor    %r8d,%r8d
   15827:	31 c9                	xor    %ecx,%ecx
   15829:	48 89 da             	mov    %rbx,%rdx
   1582c:	31 f6                	xor    %esi,%esi
   1582e:	48 89 ef             	mov    %rbp,%rdi
}
   15831:	41 59                	pop    %r9
   15833:	5b                   	pop    %rbx
   15834:	5d                   	pop    %rbp
	params->func(conn, 0, params, NULL, 0);
   15835:	ff e0                	jmpq   *%rax

0000000000015837 <ccc_save>:
	if (attr->write != bt_gatt_attr_write_ccc) {
   15837:	48 8d 05 bd fa ff ff 	lea    -0x543(%rip),%rax        # 152fb <bt_gatt_attr_write_ccc>
   1583e:	48 39 47 10          	cmp    %rax,0x10(%rdi)
   15842:	75 47                	jne    1588b <ccc_save+0x54>
{
   15844:	55                   	push   %rbp
   15845:	53                   	push   %rbx
   15846:	48 89 d3             	mov    %rdx,%rbx
   15849:	89 f5                	mov    %esi,%ebp
   1584b:	48 83 ec 08          	sub    $0x8,%rsp
	cfg = ccc_find_cfg(ccc, save->addr_with_id.addr, save->addr_with_id.id);
   1584f:	0f b6 52 08          	movzbl 0x8(%rdx),%edx
   15853:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
   15857:	48 8b 33             	mov    (%rbx),%rsi
   1585a:	e8 89 fc ff ff       	callq  154e8 <ccc_find_cfg>
	if (!cfg) {
   1585f:	48 85 c0             	test   %rax,%rax
   15862:	74 21                	je     15885 <ccc_save+0x4e>
	save->store[save->count].handle = handle;
   15864:	48 8b 93 d0 00 00 00 	mov    0xd0(%rbx),%rdx
	save->store[save->count].value = cfg->value;
   1586b:	66 8b 40 08          	mov    0x8(%rax),%ax
   1586f:	48 8d 0c 93          	lea    (%rbx,%rdx,4),%rcx
	save->count++;
   15873:	48 ff c2             	inc    %rdx
	save->store[save->count].handle = handle;
   15876:	66 89 69 10          	mov    %bp,0x10(%rcx)
	save->store[save->count].value = cfg->value;
   1587a:	66 89 41 12          	mov    %ax,0x12(%rcx)
	save->count++;
   1587e:	48 89 93 d0 00 00 00 	mov    %rdx,0xd0(%rbx)
}
   15885:	5a                   	pop    %rdx
   15886:	b0 01                	mov    $0x1,%al
   15888:	5b                   	pop    %rbx
   15889:	5d                   	pop    %rbp
   1588a:	c3                   	retq   
   1588b:	b0 01                	mov    $0x1,%al
   1588d:	c3                   	retq   

000000000001588e <remove_peer_from_attr>:
	const struct addr_with_id *addr_with_id = user_data;
	struct _bt_gatt_ccc *ccc;
	struct bt_gatt_ccc_cfg *cfg;

	/* Check if attribute is a CCC */
	if (attr->write != bt_gatt_attr_write_ccc) {
   1588e:	48 8d 05 66 fa ff ff 	lea    -0x59a(%rip),%rax        # 152fb <bt_gatt_attr_write_ccc>
   15895:	48 39 47 10          	cmp    %rax,0x10(%rdi)
   15899:	75 2f                	jne    158ca <remove_peer_from_attr+0x3c>
{
   1589b:	48 83 ec 08          	sub    $0x8,%rsp
   1589f:	48 89 d0             	mov    %rdx,%rax
	}

	ccc = attr->user_data;

	/* Check if there is a cfg for the peer */
	cfg = ccc_find_cfg(ccc, addr_with_id->addr, addr_with_id->id);
   158a2:	0f b6 52 08          	movzbl 0x8(%rdx),%edx
   158a6:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
   158aa:	48 8b 30             	mov    (%rax),%rsi
   158ad:	e8 36 fc ff ff       	callq  154e8 <ccc_find_cfg>
	if (cfg) {
   158b2:	48 85 c0             	test   %rax,%rax
	cfg = ccc_find_cfg(ccc, addr_with_id->addr, addr_with_id->id);
   158b5:	48 89 c2             	mov    %rax,%rdx
	if (cfg) {
   158b8:	74 0c                	je     158c6 <remove_peer_from_attr+0x38>
   158ba:	b9 0a 00 00 00       	mov    $0xa,%ecx
   158bf:	31 c0                	xor    %eax,%eax
   158c1:	48 89 d7             	mov    %rdx,%rdi
   158c4:	f3 aa                	rep stos %al,%es:(%rdi)
		memset(cfg, 0, sizeof(*cfg));
	}

	return BT_GATT_ITER_CONTINUE;
}
   158c6:	b0 01                	mov    $0x1,%al
   158c8:	5a                   	pop    %rdx
   158c9:	c3                   	retq   
   158ca:	b0 01                	mov    $0x1,%al
   158cc:	c3                   	retq   

00000000000158cd <clear_cf_cfg>:
{
   158cd:	48 83 ec 28          	sub    $0x28,%rsp
   158d1:	48 89 fa             	mov    %rdi,%rdx
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   158d4:	b9 07 00 00 00       	mov    $0x7,%ecx
{
   158d9:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   158e0:	00 00 
   158e2:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   158e7:	31 c0                	xor    %eax,%eax
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   158e9:	48 8d 7c 24 11       	lea    0x11(%rsp),%rdi
   158ee:	48 8d 74 24 11       	lea    0x11(%rsp),%rsi
   158f3:	f3 aa                	rep stos %al,%es:(%rdi)
   158f5:	48 8d 7a 01          	lea    0x1(%rdx),%rdi
   158f9:	48 89 0c 24          	mov    %rcx,(%rsp)
   158fd:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
   15902:	e8 95 f6 ff ff       	callq  14f9c <bt_addr_le_copy>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   15907:	48 8b 0c 24          	mov    (%rsp),%rcx
   1590b:	c6 42 08 00          	movb   $0x0,0x8(%rdx)
   1590f:	87 4a 0c             	xchg   %ecx,0xc(%rdx)
}
   15912:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
   15917:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1591e:	00 00 
   15920:	74 05                	je     15927 <clear_cf_cfg+0x5a>
   15922:	e8 19 ed fe ff       	callq  4640 <__stack_chk_fail@plt>
   15927:	48 83 c4 28          	add    $0x28,%rsp
   1592b:	c3                   	retq   

000000000001592c <cf_set>:
{
   1592c:	41 57                	push   %r15
   1592e:	41 56                	push   %r14
   15930:	41 55                	push   %r13
   15932:	41 54                	push   %r12
   15934:	55                   	push   %rbp
   15935:	53                   	push   %rbx
   15936:	48 83 ec 28          	sub    $0x28,%rsp
   1593a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   15941:	00 00 
   15943:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   15948:	31 c0                	xor    %eax,%eax
	if (!name) {
   1594a:	48 85 ff             	test   %rdi,%rdi
   1594d:	75 26                	jne    15975 <cf_set+0x49>
   1594f:	48 8d 35 6a 4a 22 00 	lea    0x224a6a(%rip),%rsi        # 23a3c0 <log_const_bt_gatt>
   15956:	48 2b 35 f3 05 22 00 	sub    0x2205f3(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Insufficient number of arguments");
   1595d:	48 8d 3d d0 c8 01 00 	lea    0x1c8d0(%rip),%rdi        # 32234 <__func__.5785+0x15cc>
   15964:	48 c1 ee 04          	shr    $0x4,%rsi
   15968:	c1 e6 06             	shl    $0x6,%esi
   1596b:	83 ce 01             	or     $0x1,%esi
   1596e:	e8 51 19 ff ff       	callq  72c4 <log_0>
   15973:	eb 50                	jmp    159c5 <cf_set+0x99>
	err = bt_settings_decode_key(name, &addr);
   15975:	4c 8d 64 24 11       	lea    0x11(%rsp),%r12
   1597a:	49 89 f5             	mov    %rsi,%r13
   1597d:	48 89 fd             	mov    %rdi,%rbp
   15980:	49 89 d6             	mov    %rdx,%r14
   15983:	49 89 cf             	mov    %rcx,%r15
   15986:	4c 89 e6             	mov    %r12,%rsi
   15989:	e8 db 79 ff ff       	callq  d369 <bt_settings_decode_key>
	if (err) {
   1598e:	85 c0                	test   %eax,%eax
	err = bt_settings_decode_key(name, &addr);
   15990:	89 c3                	mov    %eax,%ebx
	if (err) {
   15992:	74 3b                	je     159cf <cf_set+0xa3>
   15994:	48 8d 1d 25 4a 22 00 	lea    0x224a25(%rip),%rbx        # 23a3c0 <log_const_bt_gatt>
   1599b:	48 2b 1d ae 05 22 00 	sub    0x2205ae(%rip),%rbx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unable to decode address %s", log_strdup(name));
   159a2:	48 89 ef             	mov    %rbp,%rdi
   159a5:	e8 66 15 ff ff       	callq  6f10 <log_strdup>
   159aa:	48 8d 3d 79 d5 01 00 	lea    0x1d579(%rip),%rdi        # 32f2a <__func__.5785+0x22c2>
   159b1:	48 89 c6             	mov    %rax,%rsi
   159b4:	48 c1 eb 04          	shr    $0x4,%rbx
   159b8:	c1 e3 06             	shl    $0x6,%ebx
   159bb:	83 cb 01             	or     $0x1,%ebx
   159be:	89 da                	mov    %ebx,%edx
   159c0:	e8 30 19 ff ff       	callq  72f5 <log_1>
		return -EINVAL;
   159c5:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
   159ca:	e9 eb 00 00 00       	jmpq   15aba <cf_set+0x18e>
	settings_name_next(name, &next);
   159cf:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
   159d4:	48 89 ef             	mov    %rbp,%rdi
		id = BT_ID_DEFAULT;
   159d7:	31 ed                	xor    %ebp,%ebp
	settings_name_next(name, &next);
   159d9:	e8 b1 2b ff ff       	callq  858f <settings_name_next>
	if (!next) {
   159de:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   159e3:	48 85 ff             	test   %rdi,%rdi
   159e6:	74 0f                	je     159f7 <cf_set+0xcb>
		id = strtol(next, NULL, 10);
   159e8:	ba 0a 00 00 00       	mov    $0xa,%edx
   159ed:	31 f6                	xor    %esi,%esi
   159ef:	e8 cc ec fe ff       	callq  46c0 <strtol@plt>
   159f4:	40 88 c5             	mov    %al,%bpl
			if (id == cf_cfg[i].id &&
   159f7:	40 3a 2d 42 23 24 00 	cmp    0x242342(%rip),%bpl        # 257d40 <cf_cfg>
   159fe:	75 6f                	jne    15a6f <cf_set+0x143>
			    !bt_addr_le_cmp(addr, &cf_cfg[i].peer)) {
   15a00:	48 8d 35 3a 23 24 00 	lea    0x24233a(%rip),%rsi        # 257d41 <cf_cfg+0x1>
   15a07:	4c 89 e7             	mov    %r12,%rdi
   15a0a:	e8 ce f7 ff ff       	callq  151dd <bt_addr_le_cmp>
			if (id == cf_cfg[i].id &&
   15a0f:	85 c0                	test   %eax,%eax
   15a11:	75 5c                	jne    15a6f <cf_set+0x143>
				return &cf_cfg[i];
   15a13:	48 8d 05 26 23 24 00 	lea    0x242326(%rip),%rax        # 257d40 <cf_cfg>
	if (len_rd) {
   15a1a:	4d 85 ed             	test   %r13,%r13
   15a1d:	74 46                	je     15a65 <cf_set+0x139>
		len = read_cb(cb_arg, cfg->data, sizeof(cfg->data));
   15a1f:	48 8d 70 08          	lea    0x8(%rax),%rsi
   15a23:	ba 01 00 00 00       	mov    $0x1,%edx
   15a28:	4c 89 ff             	mov    %r15,%rdi
   15a2b:	41 ff d6             	callq  *%r14
		if (len < 0) {
   15a2e:	48 85 c0             	test   %rax,%rax
		len = read_cb(cb_arg, cfg->data, sizeof(cfg->data));
   15a31:	48 89 c5             	mov    %rax,%rbp
		if (len < 0) {
   15a34:	0f 89 80 00 00 00    	jns    15aba <cf_set+0x18e>
   15a3a:	48 8d 15 7f 49 22 00 	lea    0x22497f(%rip),%rdx        # 23a3c0 <log_const_bt_gatt>
   15a41:	48 2b 15 08 05 22 00 	sub    0x220508(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Failed to decode value (err %zd)", len);
   15a48:	48 8d 3d 84 d4 01 00 	lea    0x1d484(%rip),%rdi        # 32ed3 <__func__.5785+0x226b>
   15a4f:	48 89 c6             	mov    %rax,%rsi
			return len;
   15a52:	89 eb                	mov    %ebp,%ebx
   15a54:	48 c1 ea 04          	shr    $0x4,%rdx
			BT_ERR("Failed to decode value (err %zd)", len);
   15a58:	c1 e2 06             	shl    $0x6,%edx
   15a5b:	83 ca 01             	or     $0x1,%edx
   15a5e:	e8 92 18 ff ff       	callq  72f5 <log_1>
			return len;
   15a63:	eb 55                	jmp    15aba <cf_set+0x18e>
		clear_cf_cfg(cfg);
   15a65:	48 89 c7             	mov    %rax,%rdi
   15a68:	e8 60 fe ff ff       	callq  158cd <clear_cf_cfg>
   15a6d:	eb 4b                	jmp    15aba <cf_set+0x18e>
		cfg = find_cf_cfg(NULL);
   15a6f:	31 ff                	xor    %edi,%edi
   15a71:	e8 71 f7 ff ff       	callq  151e7 <find_cf_cfg>
		if (!cfg) {
   15a76:	48 85 c0             	test   %rax,%rax
   15a79:	75 2b                	jne    15aa6 <cf_set+0x17a>
   15a7b:	48 8d 35 3e 49 22 00 	lea    0x22493e(%rip),%rsi        # 23a3c0 <log_const_bt_gatt>
   15a82:	48 2b 35 c7 04 22 00 	sub    0x2204c7(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Unable to restore CF: no cfg left");
   15a89:	48 8d 3d d8 d4 01 00 	lea    0x1d4d8(%rip),%rdi        # 32f68 <__func__.5785+0x2300>
			return -ENOMEM;
   15a90:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
   15a95:	48 c1 ee 04          	shr    $0x4,%rsi
			BT_ERR("Unable to restore CF: no cfg left");
   15a99:	c1 e6 06             	shl    $0x6,%esi
   15a9c:	83 ce 01             	or     $0x1,%esi
   15a9f:	e8 20 18 ff ff       	callq  72c4 <log_0>
			return -ENOMEM;
   15aa4:	eb 14                	jmp    15aba <cf_set+0x18e>
		bt_addr_le_copy(&cfg->peer, &addr);
   15aa6:	48 8d 78 01          	lea    0x1(%rax),%rdi
		cfg->id = id;
   15aaa:	40 88 28             	mov    %bpl,(%rax)
		bt_addr_le_copy(&cfg->peer, &addr);
   15aad:	4c 89 e6             	mov    %r12,%rsi
   15ab0:	e8 e7 f4 ff ff       	callq  14f9c <bt_addr_le_copy>
   15ab5:	e9 60 ff ff ff       	jmpq   15a1a <cf_set+0xee>
}
   15aba:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   15abf:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   15ac6:	00 00 
   15ac8:	89 d8                	mov    %ebx,%eax
   15aca:	74 05                	je     15ad1 <cf_set+0x1a5>
   15acc:	e8 6f eb fe ff       	callq  4640 <__stack_chk_fail@plt>
   15ad1:	48 83 c4 28          	add    $0x28,%rsp
   15ad5:	5b                   	pop    %rbx
   15ad6:	5d                   	pop    %rbp
   15ad7:	41 5c                	pop    %r12
   15ad9:	41 5d                	pop    %r13
   15adb:	41 5e                	pop    %r14
   15add:	41 5f                	pop    %r15
   15adf:	c3                   	retq   

0000000000015ae0 <gatt_send.constprop.35>:
static int gatt_send(struct bt_conn *conn, struct net_buf *buf,
   15ae0:	41 55                	push   %r13
   15ae2:	41 54                	push   %r12
   15ae4:	55                   	push   %rbp
   15ae5:	53                   	push   %rbx
   15ae6:	48 89 fd             	mov    %rdi,%rbp
   15ae9:	48 83 ec 18          	sub    $0x18,%rsp
	if (params) {
   15aed:	48 85 c9             	test   %rcx,%rcx
   15af0:	74 60                	je     15b52 <gatt_send.constprop.35+0x72>
		req = bt_att_req_alloc(BT_ATT_TIMEOUT);
   15af2:	bf b8 0b 00 00       	mov    $0xbb8,%edi
   15af7:	49 89 d5             	mov    %rdx,%r13
   15afa:	49 89 cc             	mov    %rcx,%r12
   15afd:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
   15b02:	e8 63 ed ff ff       	callq  1486a <bt_att_req_alloc>
   15b07:	48 89 c3             	mov    %rax,%rbx
			return -ENOMEM;
   15b0a:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
		if (!req) {
   15b0f:	48 85 db             	test   %rbx,%rbx
   15b12:	74 7a                	je     15b8e <gatt_send.constprop.35+0xae>
		req->buf = buf;
   15b14:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
		req->func = func;
   15b19:	4c 89 6b 08          	mov    %r13,0x8(%rbx)
		err = bt_att_req_send(conn, req);
   15b1d:	48 89 ef             	mov    %rbp,%rdi
		req->destroy = destroy;
   15b20:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
   15b27:	00 
		req->user_data = params;
   15b28:	4c 89 63 28          	mov    %r12,0x28(%rbx)
		req->buf = buf;
   15b2c:	48 89 73 20          	mov    %rsi,0x20(%rbx)
		err = bt_att_req_send(conn, req);
   15b30:	48 89 de             	mov    %rbx,%rsi
   15b33:	e8 aa f2 ff ff       	callq  14de2 <bt_att_req_send>
		if (err) {
   15b38:	85 c0                	test   %eax,%eax
   15b3a:	75 04                	jne    15b40 <gatt_send.constprop.35+0x60>
			return -ENOMEM;
   15b3c:	31 c0                	xor    %eax,%eax
   15b3e:	eb 4e                	jmp    15b8e <gatt_send.constprop.35+0xae>
			bt_att_req_free(req);
   15b40:	48 89 df             	mov    %rbx,%rdi
   15b43:	89 44 24 08          	mov    %eax,0x8(%rsp)
   15b47:	e8 7e ed ff ff       	callq  148ca <bt_att_req_free>
   15b4c:	8b 44 24 08          	mov    0x8(%rsp),%eax
   15b50:	eb 0d                	jmp    15b5f <gatt_send.constprop.35+0x7f>
		err = bt_att_send(conn, buf, NULL, NULL);
   15b52:	31 c9                	xor    %ecx,%ecx
   15b54:	31 d2                	xor    %edx,%edx
   15b56:	e8 85 f1 ff ff       	callq  14ce0 <bt_att_send>
	if (err) {
   15b5b:	85 c0                	test   %eax,%eax
   15b5d:	74 dd                	je     15b3c <gatt_send.constprop.35+0x5c>
   15b5f:	48 8d 15 5a 48 22 00 	lea    0x22485a(%rip),%rdx        # 23a3c0 <log_const_bt_gatt>
   15b66:	48 2b 15 e3 03 22 00 	sub    0x2203e3(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Error sending ATT PDU: %d", err);
   15b6d:	48 8d 3d 16 d4 01 00 	lea    0x1d416(%rip),%rdi        # 32f8a <__func__.5785+0x2322>
   15b74:	48 63 f0             	movslq %eax,%rsi
   15b77:	89 44 24 08          	mov    %eax,0x8(%rsp)
   15b7b:	48 c1 ea 04          	shr    $0x4,%rdx
   15b7f:	c1 e2 06             	shl    $0x6,%edx
   15b82:	83 ca 01             	or     $0x1,%edx
   15b85:	e8 6b 17 ff ff       	callq  72f5 <log_1>
   15b8a:	8b 44 24 08          	mov    0x8(%rsp),%eax
}
   15b8e:	48 83 c4 18          	add    $0x18,%rsp
   15b92:	5b                   	pop    %rbx
   15b93:	5d                   	pop    %rbp
   15b94:	41 5c                	pop    %r12
   15b96:	41 5d                	pop    %r13
   15b98:	c3                   	retq   

0000000000015b99 <gatt_indicate>:
{
   15b99:	41 57                	push   %r15
   15b9b:	41 56                	push   %r14
   15b9d:	41 89 f6             	mov    %esi,%r14d
   15ba0:	41 55                	push   %r13
   15ba2:	41 54                	push   %r12
	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE,
   15ba4:	be 1d 00 00 00       	mov    $0x1d,%esi
{
   15ba9:	55                   	push   %rbp
   15baa:	53                   	push   %rbx
   15bab:	48 89 d3             	mov    %rdx,%rbx
   15bae:	49 89 fd             	mov    %rdi,%r13
   15bb1:	48 83 ec 08          	sub    $0x8,%rsp
				sizeof(*ind) + params->len);
   15bb5:	0f b7 52 28          	movzwl 0x28(%rdx),%edx
	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE,
   15bb9:	48 83 c2 02          	add    $0x2,%rdx
   15bbd:	e8 1c e1 ff ff       	callq  13cde <bt_att_create_pdu>
	if (!buf) {
   15bc2:	48 85 c0             	test   %rax,%rax
   15bc5:	74 62                	je     15c29 <gatt_indicate+0x90>
	return net_buf_simple_add(&buf->b, len);
   15bc7:	4c 8d 78 10          	lea    0x10(%rax),%r15
   15bcb:	be 02 00 00 00       	mov    $0x2,%esi
   15bd0:	49 89 c4             	mov    %rax,%r12
   15bd3:	4c 89 ff             	mov    %r15,%rdi
   15bd6:	e8 ae 34 00 00       	callq  19089 <net_buf_simple_add>
	net_buf_add(buf, params->len);
   15bdb:	0f b7 73 28          	movzwl 0x28(%rbx),%esi
   15bdf:	48 89 c5             	mov    %rax,%rbp
   15be2:	4c 89 ff             	mov    %r15,%rdi
	ind->handle = sys_cpu_to_le16(handle);
   15be5:	66 44 89 30          	mov    %r14w,(%rax)
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
   15be9:	48 83 c5 02          	add    $0x2,%rbp
   15bed:	e8 97 34 00 00       	callq  19089 <net_buf_simple_add>
   15bf2:	0f b7 4b 28          	movzwl 0x28(%rbx),%ecx
   15bf6:	48 8b 73 20          	mov    0x20(%rbx),%rsi
   15bfa:	48 89 ef             	mov    %rbp,%rdi
   15bfd:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		return gatt_send(conn, buf, NULL, NULL, NULL);
   15bff:	31 d2                	xor    %edx,%edx
	if (!params->func) {
   15c01:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
   15c06:	74 0a                	je     15c12 <gatt_indicate+0x79>
	return gatt_send(conn, buf, gatt_indicate_rsp, params, NULL);
   15c08:	48 8d 15 45 f3 ff ff 	lea    -0xcbb(%rip),%rdx        # 14f54 <gatt_indicate_rsp>
   15c0f:	48 89 d9             	mov    %rbx,%rcx
}
   15c12:	41 58                	pop    %r8
	return gatt_send(conn, buf, gatt_indicate_rsp, params, NULL);
   15c14:	4c 89 e6             	mov    %r12,%rsi
   15c17:	4c 89 ef             	mov    %r13,%rdi
}
   15c1a:	5b                   	pop    %rbx
   15c1b:	5d                   	pop    %rbp
   15c1c:	41 5c                	pop    %r12
   15c1e:	41 5d                	pop    %r13
   15c20:	41 5e                	pop    %r14
   15c22:	41 5f                	pop    %r15
	return gatt_send(conn, buf, gatt_indicate_rsp, params, NULL);
   15c24:	e9 b7 fe ff ff       	jmpq   15ae0 <gatt_send.constprop.35>
   15c29:	48 8d 35 90 47 22 00 	lea    0x224790(%rip),%rsi        # 23a3c0 <log_const_bt_gatt>
   15c30:	48 2b 35 19 03 22 00 	sub    0x220319(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("No buffer available to send indication");
   15c37:	48 8d 3d 66 d3 01 00 	lea    0x1d366(%rip),%rdi        # 32fa4 <__func__.5785+0x233c>
   15c3e:	48 c1 ee 04          	shr    $0x4,%rsi
   15c42:	c1 e6 06             	shl    $0x6,%esi
   15c45:	83 ce 02             	or     $0x2,%esi
   15c48:	e8 77 16 ff ff       	callq  72c4 <log_0>
}
   15c4d:	5a                   	pop    %rdx
   15c4e:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
   15c53:	5b                   	pop    %rbx
   15c54:	5d                   	pop    %rbp
   15c55:	41 5c                	pop    %r12
   15c57:	41 5d                	pop    %r13
   15c59:	41 5e                	pop    %r14
   15c5b:	41 5f                	pop    %r15
   15c5d:	c3                   	retq   

0000000000015c5e <sc_commit>:
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   15c5e:	48 8d 3d b3 18 24 00 	lea    0x2418b3(%rip),%rdi        # 257518 <gatt_sc+0x78>
{
   15c65:	48 83 ec 08          	sub    $0x8,%rsp
   15c69:	be fd ff ff ff       	mov    $0xfffffffd,%esi
   15c6e:	e8 5d f9 ff ff       	callq  155d0 <atomic_and>
	if (atomic_test_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
   15c73:	48 8d 3d 9e 18 24 00 	lea    0x24189e(%rip),%rdi        # 257518 <gatt_sc+0x78>
   15c7a:	31 f6                	xor    %esi,%esi
   15c7c:	e8 44 f9 ff ff       	callq  155c5 <atomic_test_bit>
   15c81:	84 c0                	test   %al,%al
   15c83:	74 18                	je     15c9d <sc_commit+0x3f>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   15c85:	48 8d 3d 14 1f 24 00 	lea    0x241f14(%rip),%rdi        # 257ba0 <k_sys_work_q>
   15c8c:	48 8d 35 45 18 24 00 	lea    0x241845(%rip),%rsi        # 2574d8 <gatt_sc+0x38>
   15c93:	ba 01 00 00 00       	mov    $0x1,%edx
   15c98:	e8 da 66 01 00       	callq  2c377 <k_delayed_work_submit_to_queue>
}
   15c9d:	31 c0                	xor    %eax,%eax
   15c9f:	5a                   	pop    %rdx
   15ca0:	c3                   	retq   

0000000000015ca1 <gatt_write_ccc.constprop.29>:
static int gatt_write_ccc(struct bt_conn *conn, uint16_t handle, uint16_t value,
   15ca1:	41 57                	push   %r15
   15ca3:	41 56                	push   %r14
   15ca5:	41 89 f7             	mov    %esi,%r15d
   15ca8:	41 55                	push   %r13
   15caa:	41 54                	push   %r12
	buf = bt_att_create_pdu(conn, BT_ATT_OP_WRITE_REQ,
   15cac:	be 12 00 00 00       	mov    $0x12,%esi
static int gatt_write_ccc(struct bt_conn *conn, uint16_t handle, uint16_t value,
   15cb1:	55                   	push   %rbp
   15cb2:	53                   	push   %rbx
   15cb3:	41 89 d4             	mov    %edx,%r12d
	buf = bt_att_create_pdu(conn, BT_ATT_OP_WRITE_REQ,
   15cb6:	ba 04 00 00 00       	mov    $0x4,%edx
static int gatt_write_ccc(struct bt_conn *conn, uint16_t handle, uint16_t value,
   15cbb:	49 89 fd             	mov    %rdi,%r13
   15cbe:	48 89 cd             	mov    %rcx,%rbp
   15cc1:	48 83 ec 08          	sub    $0x8,%rsp
	buf = bt_att_create_pdu(conn, BT_ATT_OP_WRITE_REQ,
   15cc5:	e8 14 e0 ff ff       	callq  13cde <bt_att_create_pdu>
	if (!buf) {
   15cca:	48 85 c0             	test   %rax,%rax
   15ccd:	74 4a                	je     15d19 <gatt_write_ccc.constprop.29+0x78>
   15ccf:	4c 8d 70 10          	lea    0x10(%rax),%r14
   15cd3:	be 02 00 00 00       	mov    $0x2,%esi
   15cd8:	48 89 c3             	mov    %rax,%rbx
   15cdb:	4c 89 f7             	mov    %r14,%rdi
   15cde:	e8 a6 33 00 00       	callq  19089 <net_buf_simple_add>
	net_buf_add_le16(buf, value);
   15ce3:	41 0f b7 f4          	movzwl %r12w,%esi
	req->handle = sys_cpu_to_le16(handle);
   15ce7:	66 44 89 38          	mov    %r15w,(%rax)
	net_buf_simple_add_le16(&buf->b, val);
   15ceb:	4c 89 f7             	mov    %r14,%rdi
   15cee:	e8 db 33 00 00       	callq  190ce <net_buf_simple_add_le16>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   15cf3:	f0 83 4d 18 04       	lock orl $0x4,0x18(%rbp)
}
   15cf8:	41 58                	pop    %r8
	return gatt_send(conn, buf, func, params, NULL);
   15cfa:	48 89 e9             	mov    %rbp,%rcx
   15cfd:	48 89 de             	mov    %rbx,%rsi
   15d00:	4c 89 ef             	mov    %r13,%rdi
}
   15d03:	5b                   	pop    %rbx
   15d04:	5d                   	pop    %rbp
   15d05:	41 5c                	pop    %r12
   15d07:	41 5d                	pop    %r13
   15d09:	41 5e                	pop    %r14
   15d0b:	41 5f                	pop    %r15
	return gatt_send(conn, buf, func, params, NULL);
   15d0d:	48 8d 15 b0 02 00 00 	lea    0x2b0(%rip),%rdx        # 15fc4 <gatt_write_ccc_rsp>
   15d14:	e9 c7 fd ff ff       	jmpq   15ae0 <gatt_send.constprop.35>
}
   15d19:	5a                   	pop    %rdx
   15d1a:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
   15d1f:	5b                   	pop    %rbx
   15d20:	5d                   	pop    %rbp
   15d21:	41 5c                	pop    %r12
   15d23:	41 5d                	pop    %r13
   15d25:	41 5e                	pop    %r14
   15d27:	41 5f                	pop    %r15
   15d29:	c3                   	retq   

0000000000015d2a <atomic_set_bit>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   15d2a:	40 88 f1             	mov    %sil,%cl
   15d2d:	b8 01 00 00 00       	mov    $0x1,%eax
   15d32:	d3 e0                	shl    %cl,%eax
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   15d34:	f0 09 07             	lock or %eax,(%rdi)
}
   15d37:	c3                   	retq   

0000000000015d38 <cf_write>:
	if (offset > sizeof(cfg->data)) {
   15d38:	66 41 83 f8 01       	cmp    $0x1,%r8w
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   15d3d:	48 c7 c0 f9 ff ff ff 	mov    $0xfffffffffffffff9,%rax
	if (offset > sizeof(cfg->data)) {
   15d44:	0f 87 e7 00 00 00    	ja     15e31 <cf_write+0xf9>
	if (offset + len > sizeof(cfg->data)) {
   15d4a:	0f b7 c1             	movzwl %cx,%eax
   15d4d:	45 0f b7 c0          	movzwl %r8w,%r8d
   15d51:	41 01 c0             	add    %eax,%r8d
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
   15d54:	48 c7 c0 f3 ff ff ff 	mov    $0xfffffffffffffff3,%rax
	if (offset + len > sizeof(cfg->data)) {
   15d5b:	41 ff c8             	dec    %r8d
   15d5e:	0f 8f cd 00 00 00    	jg     15e31 <cf_write+0xf9>
{
   15d64:	41 55                	push   %r13
   15d66:	41 54                	push   %r12
   15d68:	49 89 d5             	mov    %rdx,%r13
   15d6b:	55                   	push   %rbp
   15d6c:	53                   	push   %rbx
   15d6d:	41 89 cc             	mov    %ecx,%r12d
   15d70:	89 cb                	mov    %ecx,%ebx
   15d72:	48 89 fd             	mov    %rdi,%rbp
   15d75:	48 83 ec 08          	sub    $0x8,%rsp
	cfg = find_cf_cfg(conn);
   15d79:	e8 69 f4 ff ff       	callq  151e7 <find_cf_cfg>
	if (!cfg) {
   15d7e:	48 85 c0             	test   %rax,%rax
   15d81:	75 39                	jne    15dbc <cf_write+0x84>
		cfg = find_cf_cfg(NULL);
   15d83:	31 ff                	xor    %edi,%edi
   15d85:	e8 5d f4 ff ff       	callq  151e7 <find_cf_cfg>
	if (!cfg) {
   15d8a:	48 85 c0             	test   %rax,%rax
   15d8d:	75 2d                	jne    15dbc <cf_write+0x84>
   15d8f:	48 8d 35 2a 46 22 00 	lea    0x22462a(%rip),%rsi        # 23a3c0 <log_const_bt_gatt>
   15d96:	48 2b 35 b3 01 22 00 	sub    0x2201b3(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("No space to store Client Supported Features");
   15d9d:	48 8d 3d 27 d2 01 00 	lea    0x1d227(%rip),%rdi        # 32fcb <__func__.5785+0x2363>
   15da4:	48 c1 ee 04          	shr    $0x4,%rsi
   15da8:	c1 e6 06             	shl    $0x6,%esi
   15dab:	83 ce 02             	or     $0x2,%esi
   15dae:	e8 11 15 ff ff       	callq  72c4 <log_0>
   15db3:	48 c7 c0 ef ff ff ff 	mov    $0xffffffffffffffef,%rax
   15dba:	eb 6d                	jmp    15e29 <cf_write+0xf1>
		uint8_t chg_bits = value[i] ^ cfg->data[i];
   15dbc:	31 c9                	xor    %ecx,%ecx
	for (i = 0U; i < len && i <= last_byte; i++) {
   15dbe:	66 39 cb             	cmp    %cx,%bx
   15dc1:	76 2a                	jbe    15ded <cf_write+0xb5>
		uint8_t chg_bits = value[i] ^ cfg->data[i];
   15dc3:	0f b6 74 08 08       	movzbl 0x8(%rax,%rcx,1),%esi
   15dc8:	41 8a 7c 0d 00       	mov    0x0(%r13,%rcx,1),%dil
   15dcd:	31 d2                	xor    %edx,%edx
   15dcf:	31 f7                	xor    %esi,%edi
			if ((BIT(bit) & chg_bits) &&
   15dd1:	40 0f b6 ff          	movzbl %dil,%edi
   15dd5:	48 0f a3 d7          	bt     %rdx,%rdi
   15dd9:	73 06                	jae    15de1 <cf_write+0xa9>
   15ddb:	48 0f a3 d6          	bt     %rdx,%rsi
   15ddf:	72 41                	jb     15e22 <cf_write+0xea>
   15de1:	ff c2                	inc    %edx
		for (bit = 0U; bit <= last_bit; bit++) {
   15de3:	83 fa 03             	cmp    $0x3,%edx
   15de6:	75 ed                	jne    15dd5 <cf_write+0x9d>
   15de8:	48 ff c1             	inc    %rcx
   15deb:	eb d1                	jmp    15dbe <cf_write+0x86>
	for (i = 0U; i < len && i < last_byte; i++) {
   15ded:	66 45 85 e4          	test   %r12w,%r12w
   15df1:	74 0a                	je     15dfd <cf_write+0xc5>
		cfg->data[i] |= value[i] & (BIT(last_bit + 1) - 1);
   15df3:	41 8a 55 00          	mov    0x0(%r13),%dl
   15df7:	83 e2 07             	and    $0x7,%edx
   15dfa:	08 50 08             	or     %dl,0x8(%rax)
	bt_addr_le_copy(&cfg->peer, &conn->le.dst);
   15dfd:	48 8d 78 01          	lea    0x1(%rax),%rdi
   15e01:	48 8d b5 d8 00 00 00 	lea    0xd8(%rbp),%rsi
   15e08:	e8 8f f1 ff ff       	callq  14f9c <bt_addr_le_copy>
	cfg->id = conn->id;
   15e0d:	8a 55 08             	mov    0x8(%rbp),%dl
	atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   15e10:	48 8d 78 0c          	lea    0xc(%rax),%rdi
   15e14:	31 f6                	xor    %esi,%esi
	cfg->id = conn->id;
   15e16:	88 10                	mov    %dl,(%rax)
	atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   15e18:	e8 0d ff ff ff       	callq  15d2a <atomic_set_bit>
	return len;
   15e1d:	0f b7 c3             	movzwl %bx,%eax
   15e20:	eb 07                	jmp    15e29 <cf_write+0xf1>
		return BT_GATT_ERR(BT_ATT_ERR_VALUE_NOT_ALLOWED);
   15e22:	48 c7 c0 ed ff ff ff 	mov    $0xffffffffffffffed,%rax
}
   15e29:	5a                   	pop    %rdx
   15e2a:	5b                   	pop    %rbx
   15e2b:	5d                   	pop    %rbp
   15e2c:	41 5c                	pop    %r12
   15e2e:	41 5d                	pop    %r13
   15e30:	c3                   	retq   
   15e31:	c3                   	retq   

0000000000015e32 <sc_restore_rsp>:
{
   15e32:	48 83 ec 08          	sub    $0x8,%rsp
	cfg = find_cf_cfg(conn);
   15e36:	e8 ac f3 ff ff       	callq  151e7 <find_cf_cfg>
	if (cfg && CF_ROBUST_CACHING(cfg)) {
   15e3b:	48 85 c0             	test   %rax,%rax
   15e3e:	74 12                	je     15e52 <sc_restore_rsp+0x20>
   15e40:	f6 40 08 01          	testb  $0x1,0x8(%rax)
   15e44:	74 0c                	je     15e52 <sc_restore_rsp+0x20>
}
   15e46:	5a                   	pop    %rdx
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   15e47:	48 8d 78 0c          	lea    0xc(%rax),%rdi
   15e4b:	31 f6                	xor    %esi,%esi
   15e4d:	e9 d8 fe ff ff       	jmpq   15d2a <atomic_set_bit>
}
   15e52:	58                   	pop    %rax
   15e53:	c3                   	retq   

0000000000015e54 <gatt_notify>:
{
   15e54:	41 57                	push   %r15
   15e56:	41 56                	push   %r14
   15e58:	41 89 f6             	mov    %esi,%r14d
   15e5b:	41 55                	push   %r13
   15e5d:	41 54                	push   %r12
	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
   15e5f:	be 1b 00 00 00       	mov    $0x1b,%esi
{
   15e64:	55                   	push   %rbp
   15e65:	53                   	push   %rbx
   15e66:	48 89 d3             	mov    %rdx,%rbx
   15e69:	49 89 fd             	mov    %rdi,%r13
   15e6c:	48 83 ec 08          	sub    $0x8,%rsp
				sizeof(*nfy) + params->len);
   15e70:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
   15e74:	48 83 c2 02          	add    $0x2,%rdx
   15e78:	e8 61 de ff ff       	callq  13cde <bt_att_create_pdu>
	if (!buf) {
   15e7d:	48 85 c0             	test   %rax,%rax
   15e80:	74 57                	je     15ed9 <gatt_notify+0x85>
	return net_buf_simple_add(&buf->b, len);
   15e82:	4c 8d 78 10          	lea    0x10(%rax),%r15
   15e86:	be 02 00 00 00       	mov    $0x2,%esi
   15e8b:	49 89 c4             	mov    %rax,%r12
   15e8e:	4c 89 ff             	mov    %r15,%rdi
   15e91:	e8 f3 31 00 00       	callq  19089 <net_buf_simple_add>
	net_buf_add(buf, params->len);
   15e96:	0f b7 73 18          	movzwl 0x18(%rbx),%esi
   15e9a:	4c 89 ff             	mov    %r15,%rdi
   15e9d:	48 89 c5             	mov    %rax,%rbp
	nfy->handle = sys_cpu_to_le16(handle);
   15ea0:	66 44 89 30          	mov    %r14w,(%rax)
   15ea4:	48 83 c5 02          	add    $0x2,%rbp
   15ea8:	e8 dc 31 00 00       	callq  19089 <net_buf_simple_add>
   15ead:	0f b7 4b 18          	movzwl 0x18(%rbx),%ecx
   15eb1:	48 8b 73 10          	mov    0x10(%rbx),%rsi
   15eb5:	48 89 ef             	mov    %rbp,%rdi
   15eb8:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
	return bt_att_send(conn, buf, params->func, params->user_data);
   15eba:	4c 89 e6             	mov    %r12,%rsi
   15ebd:	4c 89 ef             	mov    %r13,%rdi
   15ec0:	48 8b 4b 28          	mov    0x28(%rbx),%rcx
   15ec4:	48 8b 53 20          	mov    0x20(%rbx),%rdx
}
   15ec8:	41 58                	pop    %r8
   15eca:	5b                   	pop    %rbx
   15ecb:	5d                   	pop    %rbp
   15ecc:	41 5c                	pop    %r12
   15ece:	41 5d                	pop    %r13
   15ed0:	41 5e                	pop    %r14
   15ed2:	41 5f                	pop    %r15
	return bt_att_send(conn, buf, params->func, params->user_data);
   15ed4:	e9 07 ee ff ff       	jmpq   14ce0 <bt_att_send>
   15ed9:	48 8d 35 e0 44 22 00 	lea    0x2244e0(%rip),%rsi        # 23a3c0 <log_const_bt_gatt>
   15ee0:	48 2b 35 69 00 22 00 	sub    0x220069(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_WARN("No buffer available to send notification");
   15ee7:	48 8d 3d 09 d1 01 00 	lea    0x1d109(%rip),%rdi        # 32ff7 <__func__.5785+0x238f>
   15eee:	48 c1 ee 04          	shr    $0x4,%rsi
   15ef2:	c1 e6 06             	shl    $0x6,%esi
   15ef5:	83 ce 02             	or     $0x2,%esi
   15ef8:	e8 c7 13 ff ff       	callq  72c4 <log_0>
}
   15efd:	5a                   	pop    %rdx
   15efe:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
   15f03:	5b                   	pop    %rbx
   15f04:	5d                   	pop    %rbp
   15f05:	41 5c                	pop    %r12
   15f07:	41 5d                	pop    %r13
   15f09:	41 5e                	pop    %r14
   15f0b:	41 5f                	pop    %r15
   15f0d:	c3                   	retq   

0000000000015f0e <sc_indicate_rsp>:
{
   15f0e:	53                   	push   %rbx
   15f0f:	48 89 fb             	mov    %rdi,%rbx
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   15f12:	48 8d 3d ff 15 24 00 	lea    0x2415ff(%rip),%rdi        # 257518 <gatt_sc+0x78>
   15f19:	be fd ff ff ff       	mov    $0xfffffffd,%esi
   15f1e:	e8 ad f6 ff ff       	callq  155d0 <atomic_and>
	if (atomic_test_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
   15f23:	48 8d 3d ee 15 24 00 	lea    0x2415ee(%rip),%rdi        # 257518 <gatt_sc+0x78>
   15f2a:	31 f6                	xor    %esi,%esi
   15f2c:	e8 94 f6 ff ff       	callq  155c5 <atomic_test_bit>
   15f31:	84 c0                	test   %al,%al
   15f33:	74 15                	je     15f4a <sc_indicate_rsp+0x3c>
   15f35:	48 8d 3d 64 1c 24 00 	lea    0x241c64(%rip),%rdi        # 257ba0 <k_sys_work_q>
   15f3c:	48 8d 35 95 15 24 00 	lea    0x241595(%rip),%rsi        # 2574d8 <gatt_sc+0x38>
   15f43:	31 d2                	xor    %edx,%edx
   15f45:	e8 2d 64 01 00       	callq  2c377 <k_delayed_work_submit_to_queue>
	cfg = find_cf_cfg(conn);
   15f4a:	48 89 df             	mov    %rbx,%rdi
   15f4d:	e8 95 f2 ff ff       	callq  151e7 <find_cf_cfg>
	if (cfg && CF_ROBUST_CACHING(cfg)) {
   15f52:	48 85 c0             	test   %rax,%rax
   15f55:	74 12                	je     15f69 <sc_indicate_rsp+0x5b>
   15f57:	f6 40 08 01          	testb  $0x1,0x8(%rax)
   15f5b:	74 0c                	je     15f69 <sc_indicate_rsp+0x5b>
}
   15f5d:	5b                   	pop    %rbx
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   15f5e:	48 8d 78 0c          	lea    0xc(%rax),%rdi
   15f62:	31 f6                	xor    %esi,%esi
   15f64:	e9 c1 fd ff ff       	jmpq   15d2a <atomic_set_bit>
}
   15f69:	5b                   	pop    %rbx
   15f6a:	c3                   	retq   

0000000000015f6b <gatt_sub_remove>:
	if (params) {
   15f6b:	48 85 c9             	test   %rcx,%rcx
{
   15f6e:	53                   	push   %rbx
   15f6f:	48 89 f3             	mov    %rsi,%rbx
	if (params) {
   15f72:	74 3e                	je     15fb2 <gatt_sub_remove+0x47>
Z_GENLIST_REMOVE(slist, snode)
   15f74:	48 85 d2             	test   %rdx,%rdx
   15f77:	48 89 c8             	mov    %rcx,%rax
		sys_slist_remove(&sub->list, prev, &params->node);
   15f7a:	48 8d 71 20          	lea    0x20(%rcx),%rsi
   15f7e:	48 8b 49 20          	mov    0x20(%rcx),%rcx
   15f82:	75 10                	jne    15f94 <gatt_sub_remove+0x29>
   15f84:	48 3b 73 10          	cmp    0x10(%rbx),%rsi
	list->head = node;
   15f88:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
Z_GENLIST_REMOVE(slist, snode)
   15f8c:	75 13                	jne    15fa1 <gatt_sub_remove+0x36>
	list->tail = node;
   15f8e:	48 89 4b 10          	mov    %rcx,0x10(%rbx)
   15f92:	eb 0d                	jmp    15fa1 <gatt_sub_remove+0x36>
	parent->next = child;
   15f94:	48 89 0a             	mov    %rcx,(%rdx)
Z_GENLIST_REMOVE(slist, snode)
   15f97:	48 3b 73 10          	cmp    0x10(%rbx),%rsi
   15f9b:	75 04                	jne    15fa1 <gatt_sub_remove+0x36>
	list->tail = node;
   15f9d:	48 89 53 10          	mov    %rdx,0x10(%rbx)
	parent->next = child;
   15fa1:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
   15fa8:	00 
		params->notify(conn, params, NULL, 0);
   15fa9:	31 c9                	xor    %ecx,%ecx
   15fab:	31 d2                	xor    %edx,%edx
   15fad:	48 89 c6             	mov    %rax,%rsi
   15fb0:	ff 10                	callq  *(%rax)
	if (sys_slist_is_empty(&sub->list)) {
   15fb2:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
   15fb7:	75 09                	jne    15fc2 <gatt_sub_remove+0x57>
   15fb9:	48 89 df             	mov    %rbx,%rdi
}
   15fbc:	5b                   	pop    %rbx
   15fbd:	e9 dc f7 ff ff       	jmpq   1579e <gatt_sub_remove.part.4>
   15fc2:	5b                   	pop    %rbx
   15fc3:	c3                   	retq   

0000000000015fc4 <gatt_write_ccc_rsp>:
{
   15fc4:	41 54                	push   %r12
   15fc6:	55                   	push   %rbp
   15fc7:	48 89 fd             	mov    %rdi,%rbp
   15fca:	53                   	push   %rbx
	atomic_clear_bit(params->flags, BT_GATT_SUBSCRIBE_FLAG_WRITE_PENDING);
   15fcb:	49 8d 78 18          	lea    0x18(%r8),%rdi
{
   15fcf:	41 89 f4             	mov    %esi,%r12d
   15fd2:	be fb ff ff ff       	mov    $0xfffffffb,%esi
   15fd7:	4c 89 c3             	mov    %r8,%rbx
   15fda:	e8 f1 f5 ff ff       	callq  155d0 <atomic_and>
	if (err) {
   15fdf:	45 84 e4             	test   %r12b,%r12b
   15fe2:	74 3f                	je     16023 <gatt_write_ccc_rsp+0x5f>
		sub = gatt_sub_find(conn);
   15fe4:	48 89 ef             	mov    %rbp,%rdi
   15fe7:	e8 86 f4 ff ff       	callq  15472 <gatt_sub_find>
		if (!sub) {
   15fec:	48 85 c0             	test   %rax,%rax
   15fef:	74 5f                	je     16050 <gatt_write_ccc_rsp+0x8c>
		SYS_SLIST_FOR_EACH_NODE_SAFE(&sub->list, node, tmp) {
   15ff1:	48 8b 48 08          	mov    0x8(%rax),%rcx
Z_GENLIST_PEEK_NEXT(slist, snode)
   15ff5:	48 85 c9             	test   %rcx,%rcx
   15ff8:	74 3e                	je     16038 <gatt_write_ccc_rsp+0x74>
	return node->next;
   15ffa:	48 8b 11             	mov    (%rcx),%rdx
			if (node == &params->node) {
   15ffd:	48 8d 73 20          	lea    0x20(%rbx),%rsi
   16001:	48 39 f1             	cmp    %rsi,%rcx
   16004:	75 10                	jne    16016 <gatt_write_ccc_rsp+0x52>
				gatt_sub_remove(conn, sub, tmp, params);
   16006:	48 89 d9             	mov    %rbx,%rcx
   16009:	48 89 c6             	mov    %rax,%rsi
   1600c:	48 89 ef             	mov    %rbp,%rdi
   1600f:	e8 57 ff ff ff       	callq  15f6b <gatt_sub_remove>
				break;
   16014:	eb 22                	jmp    16038 <gatt_write_ccc_rsp+0x74>
Z_GENLIST_PEEK_NEXT(slist, snode)
   16016:	48 85 d2             	test   %rdx,%rdx
   16019:	74 1d                	je     16038 <gatt_write_ccc_rsp+0x74>
   1601b:	48 89 d1             	mov    %rdx,%rcx
   1601e:	48 8b 12             	mov    (%rdx),%rdx
   16021:	eb de                	jmp    16001 <gatt_write_ccc_rsp+0x3d>
	} else if (!params->value) {
   16023:	66 41 83 78 14 00    	cmpw   $0x0,0x14(%r8)
   16029:	75 0d                	jne    16038 <gatt_write_ccc_rsp+0x74>
		params->notify(conn, params, NULL, 0);
   1602b:	31 c9                	xor    %ecx,%ecx
   1602d:	31 d2                	xor    %edx,%edx
   1602f:	4c 89 c6             	mov    %r8,%rsi
   16032:	48 89 ef             	mov    %rbp,%rdi
   16035:	41 ff 10             	callq  *(%r8)
	if (params->write) {
   16038:	48 8b 43 08          	mov    0x8(%rbx),%rax
   1603c:	48 85 c0             	test   %rax,%rax
   1603f:	74 0f                	je     16050 <gatt_write_ccc_rsp+0x8c>
}
   16041:	5b                   	pop    %rbx
		params->write(conn, err, NULL);
   16042:	41 0f b6 f4          	movzbl %r12b,%esi
   16046:	48 89 ef             	mov    %rbp,%rdi
   16049:	31 d2                	xor    %edx,%edx
}
   1604b:	5d                   	pop    %rbp
   1604c:	41 5c                	pop    %r12
		params->write(conn, err, NULL);
   1604e:	ff e0                	jmpq   *%rax
}
   16050:	5b                   	pop    %rbx
   16051:	5d                   	pop    %rbp
   16052:	41 5c                	pop    %r12
   16054:	c3                   	retq   

0000000000016055 <ccc_load>:
{
   16055:	41 55                	push   %r13
   16057:	41 54                	push   %r12
   16059:	55                   	push   %rbp
   1605a:	53                   	push   %rbx
		return BT_GATT_ITER_CONTINUE;
   1605b:	40 b5 01             	mov    $0x1,%bpl
{
   1605e:	48 83 ec 28          	sub    $0x28,%rsp
   16062:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   16069:	00 00 
   1606b:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   16070:	31 c0                	xor    %eax,%eax
	if (attr->write != bt_gatt_attr_write_ccc) {
   16072:	48 8d 05 82 f2 ff ff 	lea    -0xd7e(%rip),%rax        # 152fb <bt_gatt_attr_write_ccc>
   16079:	48 39 47 10          	cmp    %rax,0x10(%rdi)
   1607d:	0f 85 cb 00 00 00    	jne    1614e <ccc_load+0xf9>
	if (!load->entry) {
   16083:	48 8b 42 10          	mov    0x10(%rdx),%rax
   16087:	48 89 d3             	mov    %rdx,%rbx
	ccc = attr->user_data;
   1608a:	4c 8b 67 18          	mov    0x18(%rdi),%r12
	if (!load->entry) {
   1608e:	48 85 c0             	test   %rax,%rax
   16091:	75 42                	jne    160d5 <ccc_load+0x80>
		ccc_clear(ccc, load->addr_with_id.addr, load->addr_with_id.id);
   16093:	0f b6 52 08          	movzbl 0x8(%rdx),%edx
	cfg = ccc_find_cfg(ccc, addr, id);
   16097:	48 8b 33             	mov    (%rbx),%rsi
   1609a:	4c 89 e7             	mov    %r12,%rdi
   1609d:	e8 46 f4 ff ff       	callq  154e8 <ccc_find_cfg>
	if (!cfg) {
   160a2:	48 85 c0             	test   %rax,%rax
	cfg = ccc_find_cfg(ccc, addr, id);
   160a5:	48 89 c2             	mov    %rax,%rdx
	if (!cfg) {
   160a8:	0f 84 a0 00 00 00    	je     1614e <ccc_load+0xf9>
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   160ae:	48 8d 7c 24 11       	lea    0x11(%rsp),%rdi
   160b3:	31 c0                	xor    %eax,%eax
   160b5:	b9 07 00 00 00       	mov    $0x7,%ecx
   160ba:	48 8d 74 24 11       	lea    0x11(%rsp),%rsi
   160bf:	f3 aa                	rep stos %al,%es:(%rdi)
   160c1:	48 8d 7a 01          	lea    0x1(%rdx),%rdi
   160c5:	e8 d2 ee ff ff       	callq  14f9c <bt_addr_le_copy>
	cfg->id = 0U;
   160ca:	c6 02 00             	movb   $0x0,(%rdx)
	cfg->value = 0U;
   160cd:	66 c7 42 08 00 00    	movw   $0x0,0x8(%rdx)
   160d3:	eb 79                	jmp    1614e <ccc_load+0xf9>
		return BT_GATT_ITER_STOP;
   160d5:	31 ed                	xor    %ebp,%ebp
	} else if (!load->count) {
   160d7:	48 83 7a 18 00       	cmpq   $0x0,0x18(%rdx)
   160dc:	74 70                	je     1614e <ccc_load+0xf9>
	if (load->entry->handle != handle) {
   160de:	66 3b 30             	cmp    (%rax),%si
   160e1:	74 07                	je     160ea <ccc_load+0x95>
		return BT_GATT_ITER_CONTINUE;
   160e3:	40 b5 01             	mov    $0x1,%bpl
		if (load->entry->handle < handle) {
   160e6:	77 59                	ja     16141 <ccc_load+0xec>
   160e8:	eb 64                	jmp    1614e <ccc_load+0xf9>
	cfg = ccc_find_cfg(ccc, load->addr_with_id.addr, load->addr_with_id.id);
   160ea:	4c 8b 2a             	mov    (%rdx),%r13
   160ed:	0f b6 52 08          	movzbl 0x8(%rdx),%edx
   160f1:	4c 89 e7             	mov    %r12,%rdi
   160f4:	4c 89 ee             	mov    %r13,%rsi
   160f7:	e8 ec f3 ff ff       	callq  154e8 <ccc_find_cfg>
	if (!cfg) {
   160fc:	48 85 c0             	test   %rax,%rax
   160ff:	75 34                	jne    16135 <ccc_load+0xe0>
		cfg = ccc_find_cfg(ccc, BT_ADDR_LE_ANY, 0);
   16101:	48 8d 7c 24 0a       	lea    0xa(%rsp),%rdi
   16106:	40 88 e8             	mov    %bpl,%al
   16109:	b9 07 00 00 00       	mov    $0x7,%ecx
   1610e:	48 8d 74 24 0a       	lea    0xa(%rsp),%rsi
   16113:	31 d2                	xor    %edx,%edx
   16115:	f3 aa                	rep stos %al,%es:(%rdi)
   16117:	4c 89 e7             	mov    %r12,%rdi
   1611a:	e8 c9 f3 ff ff       	callq  154e8 <ccc_find_cfg>
		if (!cfg) {
   1611f:	48 85 c0             	test   %rax,%rax
   16122:	74 1d                	je     16141 <ccc_load+0xec>
		bt_addr_le_copy(&cfg->peer, load->addr_with_id.addr);
   16124:	48 8d 78 01          	lea    0x1(%rax),%rdi
   16128:	4c 89 ee             	mov    %r13,%rsi
   1612b:	e8 6c ee ff ff       	callq  14f9c <bt_addr_le_copy>
		cfg->id = load->addr_with_id.id;
   16130:	8a 53 08             	mov    0x8(%rbx),%dl
   16133:	88 10                	mov    %dl,(%rax)
	cfg->value = load->entry->value;
   16135:	48 8b 53 10          	mov    0x10(%rbx),%rdx
   16139:	66 8b 52 02          	mov    0x2(%rdx),%dx
   1613d:	66 89 50 08          	mov    %dx,0x8(%rax)
	load->entry++;
   16141:	48 83 43 10 04       	addq   $0x4,0x10(%rbx)
	return load->count ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
   16146:	48 ff 4b 18          	decq   0x18(%rbx)
   1614a:	40 0f 95 c5          	setne  %bpl
}
   1614e:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   16153:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1615a:	00 00 
   1615c:	40 88 e8             	mov    %bpl,%al
   1615f:	74 05                	je     16166 <ccc_load+0x111>
   16161:	e8 da e4 fe ff       	callq  4640 <__stack_chk_fail@plt>
   16166:	48 83 c4 28          	add    $0x28,%rsp
   1616a:	5b                   	pop    %rbx
   1616b:	5d                   	pop    %rbp
   1616c:	41 5c                	pop    %r12
   1616e:	41 5d                	pop    %r13
   16170:	c3                   	retq   

0000000000016171 <bt_gatt_clear_sc>:
{
   16171:	55                   	push   %rbp
   16172:	53                   	push   %rbx
	cfg = find_sc_cfg(id, (bt_addr_le_t *)addr);
   16173:	40 0f b6 ff          	movzbl %dil,%edi
{
   16177:	48 83 ec 48          	sub    $0x48,%rsp
   1617b:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   16182:	00 00 
   16184:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
   16189:	31 c0                	xor    %eax,%eax
	cfg = find_sc_cfg(id, (bt_addr_le_t *)addr);
   1618b:	e8 cd f0 ff ff       	callq  1525d <find_sc_cfg>
	if (!cfg) {
   16190:	48 85 c0             	test   %rax,%rax
   16193:	0f 84 8d 00 00 00    	je     16226 <bt_gatt_clear_sc+0xb5>
		if (cfg->id) {
   16199:	0f b6 10             	movzbl (%rax),%edx
			bt_settings_encode_key(key, sizeof(key), "sc",
   1619c:	45 31 c0             	xor    %r8d,%r8d
   1619f:	48 89 c3             	mov    %rax,%rbx
   161a2:	48 8d 48 01          	lea    0x1(%rax),%rcx
   161a6:	48 8d 6c 24 14       	lea    0x14(%rsp),%rbp
		if (cfg->id) {
   161ab:	84 d2                	test   %dl,%dl
   161ad:	74 24                	je     161d3 <bt_gatt_clear_sc+0x62>
			u8_to_dec(id_str, sizeof(id_str), cfg->id);
   161af:	4c 8d 44 24 10       	lea    0x10(%rsp),%r8
   161b4:	be 04 00 00 00       	mov    $0x4,%esi
   161b9:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
   161be:	4c 89 c7             	mov    %r8,%rdi
   161c1:	4c 89 04 24          	mov    %r8,(%rsp)
   161c5:	e8 c1 f5 fe ff       	callq  578b <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "sc",
   161ca:	4c 8b 04 24          	mov    (%rsp),%r8
   161ce:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
			bt_settings_encode_key(key, sizeof(key), "sc",
   161d3:	48 8d 15 dc cf 01 00 	lea    0x1cfdc(%rip),%rdx        # 331b6 <__func__.5785+0x254e>
   161da:	be 24 00 00 00       	mov    $0x24,%esi
   161df:	48 89 ef             	mov    %rbp,%rdi
   161e2:	e8 1d 71 ff ff       	callq  d304 <bt_settings_encode_key>
		err = settings_delete(key);
   161e7:	48 89 ef             	mov    %rbp,%rdi
   161ea:	e8 0b 23 ff ff       	callq  84fa <settings_delete>
		if (err) {
   161ef:	85 c0                	test   %eax,%eax
   161f1:	74 27                	je     1621a <bt_gatt_clear_sc+0xa9>
   161f3:	48 8d 15 c6 41 22 00 	lea    0x2241c6(%rip),%rdx        # 23a3c0 <log_const_bt_gatt>
   161fa:	48 2b 15 4f fd 21 00 	sub    0x21fd4f(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("failed to delete SC (err %d)", err);
   16201:	48 8d 3d 18 ce 01 00 	lea    0x1ce18(%rip),%rdi        # 33020 <__func__.5785+0x23b8>
   16208:	48 63 f0             	movslq %eax,%rsi
   1620b:	48 c1 ea 04          	shr    $0x4,%rdx
   1620f:	c1 e2 06             	shl    $0x6,%edx
   16212:	83 ca 01             	or     $0x1,%edx
   16215:	e8 db 10 ff ff       	callq  72f5 <log_1>
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
   1621a:	b9 03 00 00 00       	mov    $0x3,%ecx
   1621f:	31 c0                	xor    %eax,%eax
   16221:	48 89 df             	mov    %rbx,%rdi
   16224:	f3 ab                	rep stos %eax,%es:(%rdi)
}
   16226:	31 c0                	xor    %eax,%eax
   16228:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
   1622d:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
   16234:	00 00 
   16236:	74 05                	je     1623d <bt_gatt_clear_sc+0xcc>
   16238:	e8 03 e4 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1623d:	48 83 c4 48          	add    $0x48,%rsp
   16241:	5b                   	pop    %rbx
   16242:	5d                   	pop    %rbp
   16243:	c3                   	retq   

0000000000016244 <sc_clear>:
{
   16244:	55                   	push   %rbp
   16245:	53                   	push   %rbx
   16246:	48 89 fd             	mov    %rdi,%rbp
	if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   16249:	48 8d 9f d8 00 00 00 	lea    0xd8(%rdi),%rbx
{
   16250:	48 83 ec 08          	sub    $0x8,%rsp
	if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   16254:	0f b6 7f 08          	movzbl 0x8(%rdi),%edi
   16258:	48 89 de             	mov    %rbx,%rsi
   1625b:	e8 13 a1 ff ff       	callq  10373 <bt_addr_le_is_bonded>
   16260:	84 c0                	test   %al,%al
		err = bt_gatt_clear_sc(conn->id, &conn->le.dst);
   16262:	48 89 de             	mov    %rbx,%rsi
   16265:	0f b6 7d 08          	movzbl 0x8(%rbp),%edi
	if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   16269:	74 33                	je     1629e <sc_clear+0x5a>
		err = bt_gatt_clear_sc(conn->id, &conn->le.dst);
   1626b:	e8 01 ff ff ff       	callq  16171 <bt_gatt_clear_sc>
		if (err) {
   16270:	85 c0                	test   %eax,%eax
   16272:	74 43                	je     162b7 <sc_clear+0x73>
   16274:	48 8d 15 45 41 22 00 	lea    0x224145(%rip),%rdx        # 23a3c0 <log_const_bt_gatt>
   1627b:	48 2b 15 ce fc 21 00 	sub    0x21fcce(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Failed to clear SC %d", err);
   16282:	48 8d 3d b4 cd 01 00 	lea    0x1cdb4(%rip),%rdi        # 3303d <__func__.5785+0x23d5>
}
   16289:	59                   	pop    %rcx
   1628a:	5b                   	pop    %rbx
   1628b:	5d                   	pop    %rbp
   1628c:	48 c1 ea 04          	shr    $0x4,%rdx
			BT_ERR("Failed to clear SC %d", err);
   16290:	48 63 f0             	movslq %eax,%rsi
   16293:	c1 e2 06             	shl    $0x6,%edx
   16296:	83 ca 01             	or     $0x1,%edx
   16299:	e9 57 10 ff ff       	jmpq   72f5 <log_1>
		cfg = find_sc_cfg(conn->id, &conn->le.dst);
   1629e:	e8 ba ef ff ff       	callq  1525d <find_sc_cfg>
		if (cfg) {
   162a3:	48 85 c0             	test   %rax,%rax
		cfg = find_sc_cfg(conn->id, &conn->le.dst);
   162a6:	48 89 c2             	mov    %rax,%rdx
		if (cfg) {
   162a9:	74 0c                	je     162b7 <sc_clear+0x73>
   162ab:	b9 03 00 00 00       	mov    $0x3,%ecx
   162b0:	31 c0                	xor    %eax,%eax
   162b2:	48 89 d7             	mov    %rdx,%rdi
   162b5:	f3 ab                	rep stos %eax,%es:(%rdi)
}
   162b7:	58                   	pop    %rax
   162b8:	5b                   	pop    %rbx
   162b9:	5d                   	pop    %rbp
   162ba:	c3                   	retq   

00000000000162bb <sc_save>:
{
   162bb:	41 56                	push   %r14
   162bd:	41 55                	push   %r13
   162bf:	41 89 fe             	mov    %edi,%r14d
   162c2:	41 54                	push   %r12
   162c4:	55                   	push   %rbp
	cfg = find_sc_cfg(id, peer);
   162c5:	40 0f b6 ff          	movzbl %dil,%edi
{
   162c9:	53                   	push   %rbx
   162ca:	49 89 f5             	mov    %rsi,%r13
   162cd:	41 89 d4             	mov    %edx,%r12d
   162d0:	89 cd                	mov    %ecx,%ebp
   162d2:	48 83 ec 10          	sub    $0x10,%rsp
   162d6:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   162dd:	00 00 
   162df:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   162e4:	31 c0                	xor    %eax,%eax
	cfg = find_sc_cfg(id, peer);
   162e6:	e8 72 ef ff ff       	callq  1525d <find_sc_cfg>
	if (!cfg) {
   162eb:	48 85 c0             	test   %rax,%rax
   162ee:	48 89 c3             	mov    %rax,%rbx
   162f1:	75 57                	jne    1634a <sc_save+0x8f>
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
   162f3:	48 8d 7c 24 01       	lea    0x1(%rsp),%rdi
   162f8:	31 c0                	xor    %eax,%eax
   162fa:	b9 07 00 00 00       	mov    $0x7,%ecx
   162ff:	48 8d 74 24 01       	lea    0x1(%rsp),%rsi
   16304:	f3 aa                	rep stos %al,%es:(%rdi)
   16306:	31 ff                	xor    %edi,%edi
   16308:	e8 50 ef ff ff       	callq  1525d <find_sc_cfg>
		if (!cfg) {
   1630d:	48 85 c0             	test   %rax,%rax
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
   16310:	48 89 c3             	mov    %rax,%rbx
		if (!cfg) {
   16313:	75 26                	jne    1633b <sc_save+0x80>
   16315:	48 8d 35 a4 40 22 00 	lea    0x2240a4(%rip),%rsi        # 23a3c0 <log_const_bt_gatt>
   1631c:	48 2b 35 2d fc 21 00 	sub    0x21fc2d(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("unable to save SC: no cfg left");
   16323:	48 8d 3d 29 cd 01 00 	lea    0x1cd29(%rip),%rdi        # 33053 <__func__.5785+0x23eb>
   1632a:	48 c1 ee 04          	shr    $0x4,%rsi
   1632e:	c1 e6 06             	shl    $0x6,%esi
   16331:	83 ce 01             	or     $0x1,%esi
   16334:	e8 8b 0f ff ff       	callq  72c4 <log_0>
   16339:	eb 5b                	jmp    16396 <sc_save+0xdb>
		bt_addr_le_copy(&cfg->peer, peer);
   1633b:	48 8d 78 01          	lea    0x1(%rax),%rdi
		cfg->id = id;
   1633f:	44 88 30             	mov    %r14b,(%rax)
		bt_addr_le_copy(&cfg->peer, peer);
   16342:	4c 89 ee             	mov    %r13,%rsi
   16345:	e8 52 ec ff ff       	callq  14f9c <bt_addr_le_copy>
	if (!(cfg->data.start || cfg->data.end)) {
   1634a:	66 8b 53 08          	mov    0x8(%rbx),%dx
   1634e:	66 8b 43 0a          	mov    0xa(%rbx),%ax
   16352:	66 85 d2             	test   %dx,%dx
   16355:	75 0c                	jne    16363 <sc_save+0xa8>
   16357:	66 85 c0             	test   %ax,%ax
   1635a:	75 0d                	jne    16369 <sc_save+0xae>
		cfg->data.start = start;
   1635c:	66 44 89 63 08       	mov    %r12w,0x8(%rbx)
   16361:	eb 17                	jmp    1637a <sc_save+0xbf>
	if (new_start >= *start && new_end <= *end) {
   16363:	66 41 39 d4          	cmp    %dx,%r12w
   16367:	72 07                	jb     16370 <sc_save+0xb5>
   16369:	66 39 c5             	cmp    %ax,%bp
   1636c:	77 0c                	ja     1637a <sc_save+0xbf>
   1636e:	eb 26                	jmp    16396 <sc_save+0xdb>
	if (*end < new_end) {
   16370:	66 39 c5             	cmp    %ax,%bp
		*start = new_start;
   16373:	66 44 89 63 08       	mov    %r12w,0x8(%rbx)
	if (*end < new_end) {
   16378:	76 04                	jbe    1637e <sc_save+0xc3>
		*end = new_end;
   1637a:	66 89 6b 0a          	mov    %bp,0xa(%rbx)
	    modified && bt_addr_le_is_bonded(cfg->id, &cfg->peer)) {
   1637e:	0f b6 3b             	movzbl (%rbx),%edi
   16381:	48 8d 73 01          	lea    0x1(%rbx),%rsi
   16385:	e8 e9 9f ff ff       	callq  10373 <bt_addr_le_is_bonded>
   1638a:	84 c0                	test   %al,%al
   1638c:	74 08                	je     16396 <sc_save+0xdb>
		sc_store(cfg);
   1638e:	48 89 df             	mov    %rbx,%rdi
   16391:	e8 73 f1 ff ff       	callq  15509 <sc_store>
}
   16396:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   1639b:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   163a2:	00 00 
   163a4:	74 05                	je     163ab <sc_save+0xf0>
   163a6:	e8 95 e2 fe ff       	callq  4640 <__stack_chk_fail@plt>
   163ab:	48 83 c4 10          	add    $0x10,%rsp
   163af:	5b                   	pop    %rbx
   163b0:	5d                   	pop    %rbp
   163b1:	41 5c                	pop    %r12
   163b3:	41 5d                	pop    %r13
   163b5:	41 5e                	pop    %r14
   163b7:	c3                   	retq   

00000000000163b8 <sc_ccc_cfg_write>:
{
   163b8:	48 83 ec 08          	sub    $0x8,%rsp
	if (value == BT_GATT_CCC_INDICATE) {
   163bc:	66 83 fa 02          	cmp    $0x2,%dx
   163c0:	75 16                	jne    163d8 <sc_ccc_cfg_write+0x20>
		sc_save(conn->id, &conn->le.dst, 0, 0);
   163c2:	48 8d b7 d8 00 00 00 	lea    0xd8(%rdi),%rsi
   163c9:	0f b6 7f 08          	movzbl 0x8(%rdi),%edi
   163cd:	31 c9                	xor    %ecx,%ecx
   163cf:	31 d2                	xor    %edx,%edx
   163d1:	e8 e5 fe ff ff       	callq  162bb <sc_save>
   163d6:	eb 05                	jmp    163dd <sc_ccc_cfg_write+0x25>
		sc_clear(conn);
   163d8:	e8 67 fe ff ff       	callq  16244 <sc_clear>
}
   163dd:	b8 02 00 00 00       	mov    $0x2,%eax
   163e2:	5a                   	pop    %rdx
   163e3:	c3                   	retq   

00000000000163e4 <notify_cb>:
{
   163e4:	41 55                	push   %r13
   163e6:	41 54                	push   %r12
   163e8:	55                   	push   %rbp
   163e9:	53                   	push   %rbx
   163ea:	48 83 ec 18          	sub    $0x18,%rsp
   163ee:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   163f5:	00 00 
   163f7:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   163fc:	31 c0                	xor    %eax,%eax
	if (attr->write != bt_gatt_attr_write_ccc) {
   163fe:	48 8d 05 f6 ee ff ff 	lea    -0x110a(%rip),%rax        # 152fb <bt_gatt_attr_write_ccc>
   16405:	48 39 47 10          	cmp    %rax,0x10(%rdi)
   16409:	74 07                	je     16412 <notify_cb+0x2e>
		return BT_GATT_ITER_CONTINUE;
   1640b:	b0 01                	mov    $0x1,%al
   1640d:	e9 2b 01 00 00       	jmpq   1653d <notify_cb+0x159>
	ccc = attr->user_data;
   16412:	4c 8b 67 18          	mov    0x18(%rdi),%r12
	if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) && ccc == &sc_ccc) {
   16416:	48 8d 05 63 04 22 00 	lea    0x220463(%rip),%rax        # 236880 <sc_ccc>
   1641d:	49 89 fd             	mov    %rdi,%r13
   16420:	48 89 d5             	mov    %rdx,%rbp
   16423:	49 39 c4             	cmp    %rax,%r12
   16426:	0f 84 99 00 00 00    	je     164c5 <notify_cb+0xe1>
		if (cfg->value != data->type) {
   1642c:	8b 45 10             	mov    0x10(%rbp),%eax
   1642f:	66 41 39 44 24 08    	cmp    %ax,0x8(%r12)
   16435:	75 d4                	jne    1640b <notify_cb+0x27>
		conn = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
   16437:	41 0f b6 3c 24       	movzbl (%r12),%edi
   1643c:	49 8d 74 24 01       	lea    0x1(%r12),%rsi
   16441:	e8 cd b5 ff ff       	callq  11a13 <bt_conn_lookup_addr_le>
		if (!conn) {
   16446:	48 85 c0             	test   %rax,%rax
		conn = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
   16449:	48 89 c3             	mov    %rax,%rbx
		if (!conn) {
   1644c:	74 bd                	je     1640b <notify_cb+0x27>
		if (conn->state != BT_CONN_CONNECTED) {
   1644e:	80 78 0a 07          	cmpb   $0x7,0xa(%rax)
   16452:	75 64                	jne    164b8 <notify_cb+0xd4>
		if (ccc->cfg_match && !ccc->cfg_match(conn, attr)) {
   16454:	49 8b 44 24 20       	mov    0x20(%r12),%rax
   16459:	48 85 c0             	test   %rax,%rax
   1645c:	75 4e                	jne    164ac <notify_cb+0xc8>
		if (data->type == BT_GATT_CCC_INDICATE) {
   1645e:	66 83 7d 10 02       	cmpw   $0x2,0x10(%rbp)
   16463:	48 8b 55 18          	mov    0x18(%rbp),%rdx
			err = gatt_indicate(conn, data->handle,
   16467:	48 89 df             	mov    %rbx,%rdi
   1646a:	0f b7 75 08          	movzwl 0x8(%rbp),%esi
		if (data->type == BT_GATT_CCC_INDICATE) {
   1646e:	75 15                	jne    16485 <notify_cb+0xa1>
			err = gatt_indicate(conn, data->handle,
   16470:	e8 24 f7 ff ff       	callq  15b99 <gatt_indicate>
			if (err == 0) {
   16475:	85 c0                	test   %eax,%eax
			err = gatt_indicate(conn, data->handle,
   16477:	41 89 c4             	mov    %eax,%r12d
			if (err == 0) {
   1647a:	75 11                	jne    1648d <notify_cb+0xa9>
				data->ind_params->_ref++;
   1647c:	48 8b 45 18          	mov    0x18(%rbp),%rax
   16480:	fe 40 2a             	incb   0x2a(%rax)
   16483:	eb 08                	jmp    1648d <notify_cb+0xa9>
			err = gatt_notify(conn, data->handle, data->nfy_params);
   16485:	e8 ca f9 ff ff       	callq  15e54 <gatt_notify>
   1648a:	41 89 c4             	mov    %eax,%r12d
		bt_conn_unref(conn);
   1648d:	48 89 df             	mov    %rbx,%rdi
   16490:	e8 cf b2 ff ff       	callq  11764 <bt_conn_unref>
			return BT_GATT_ITER_STOP;
   16495:	31 c0                	xor    %eax,%eax
		if (err < 0) {
   16497:	45 85 e4             	test   %r12d,%r12d
   1649a:	0f 88 9d 00 00 00    	js     1653d <notify_cb+0x159>
		data->err = 0;
   164a0:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%rbp)
   164a7:	e9 5f ff ff ff       	jmpq   1640b <notify_cb+0x27>
		if (ccc->cfg_match && !ccc->cfg_match(conn, attr)) {
   164ac:	4c 89 ee             	mov    %r13,%rsi
   164af:	48 89 df             	mov    %rbx,%rdi
   164b2:	ff d0                	callq  *%rax
   164b4:	84 c0                	test   %al,%al
   164b6:	75 a6                	jne    1645e <notify_cb+0x7a>
			bt_conn_unref(conn);
   164b8:	48 89 df             	mov    %rbx,%rdi
   164bb:	e8 a4 b2 ff ff       	callq  11764 <bt_conn_unref>
   164c0:	e9 46 ff ff ff       	jmpq   1640b <notify_cb+0x27>
			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   164c5:	48 8d 7c 24 01       	lea    0x1(%rsp),%rdi
   164ca:	31 c0                	xor    %eax,%eax
   164cc:	b9 07 00 00 00       	mov    $0x7,%ecx
   164d1:	48 8d 74 24 01       	lea    0x1(%rsp),%rsi
   164d6:	f3 aa                	rep stos %al,%es:(%rdi)
   164d8:	48 8d 3d ca 1a 24 00 	lea    0x241aca(%rip),%rdi        # 257fa9 <sc_cfg+0x1>
   164df:	e8 f9 ec ff ff       	callq  151dd <bt_addr_le_cmp>
   164e4:	85 c0                	test   %eax,%eax
   164e6:	0f 84 40 ff ff ff    	je     1642c <notify_cb+0x48>
			conn = bt_conn_lookup_state_le(cfg->id, &cfg->peer,
   164ec:	0f b6 3d b5 1a 24 00 	movzbl 0x241ab5(%rip),%edi        # 257fa8 <sc_cfg>
   164f3:	48 8d 35 af 1a 24 00 	lea    0x241aaf(%rip),%rsi        # 257fa9 <sc_cfg+0x1>
   164fa:	ba 07 00 00 00       	mov    $0x7,%edx
   164ff:	e8 ac b5 ff ff       	callq  11ab0 <bt_conn_lookup_state_le>
			if (!conn) {
   16504:	48 85 c0             	test   %rax,%rax
   16507:	75 27                	jne    16530 <notify_cb+0x14c>
				sc = (struct sc_data *)data->ind_params->data;
   16509:	48 8b 45 18          	mov    0x18(%rbp),%rax
				sc_save(cfg->id, &cfg->peer,
   1650d:	0f b6 3d 94 1a 24 00 	movzbl 0x241a94(%rip),%edi        # 257fa8 <sc_cfg>
   16514:	48 8d 35 8e 1a 24 00 	lea    0x241a8e(%rip),%rsi        # 257fa9 <sc_cfg+0x1>
				sc = (struct sc_data *)data->ind_params->data;
   1651b:	48 8b 40 20          	mov    0x20(%rax),%rax
				sc_save(cfg->id, &cfg->peer,
   1651f:	0f b7 48 02          	movzwl 0x2(%rax),%ecx
   16523:	0f b7 10             	movzwl (%rax),%edx
   16526:	e8 90 fd ff ff       	callq  162bb <sc_save>
   1652b:	e9 fc fe ff ff       	jmpq   1642c <notify_cb+0x48>
			bt_conn_unref(conn);
   16530:	48 89 c7             	mov    %rax,%rdi
   16533:	e8 2c b2 ff ff       	callq  11764 <bt_conn_unref>
   16538:	e9 ef fe ff ff       	jmpq   1642c <notify_cb+0x48>
}
   1653d:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
   16542:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   16549:	00 00 
   1654b:	74 05                	je     16552 <notify_cb+0x16e>
   1654d:	e8 ee e0 fe ff       	callq  4640 <__stack_chk_fail@plt>
   16552:	48 83 c4 18          	add    $0x18,%rsp
   16556:	5b                   	pop    %rbx
   16557:	5d                   	pop    %rbp
   16558:	41 5c                	pop    %r12
   1655a:	41 5d                	pop    %r13
   1655c:	c3                   	retq   

000000000001655d <disconnected_cb>:
{
   1655d:	41 56                	push   %r14
   1655f:	41 55                	push   %r13
   16561:	41 54                	push   %r12
   16563:	55                   	push   %rbp
   16564:	53                   	push   %rbx
   16565:	48 83 ec 10          	sub    $0x10,%rsp
   16569:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   16570:	00 00 
   16572:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   16577:	31 c0                	xor    %eax,%eax
	if (attr->write != bt_gatt_attr_write_ccc) {
   16579:	48 8d 05 7b ed ff ff 	lea    -0x1285(%rip),%rax        # 152fb <bt_gatt_attr_write_ccc>
   16580:	48 39 47 10          	cmp    %rax,0x10(%rdi)
   16584:	0f 85 cc 00 00 00    	jne    16656 <disconnected_cb+0xf9>
	ccc = attr->user_data;
   1658a:	48 8b 5f 18          	mov    0x18(%rdi),%rbx
   1658e:	49 89 fd             	mov    %rdi,%r13
	if (!ccc->value) {
   16591:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%rbx)
   16596:	0f 84 ba 00 00 00    	je     16656 <disconnected_cb+0xf9>
		if (!cfg->value) {
   1659c:	66 83 7b 08 00       	cmpw   $0x0,0x8(%rbx)
   165a1:	0f 84 99 00 00 00    	je     16640 <disconnected_cb+0xe3>
		if (!bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
   165a7:	0f b6 33             	movzbl (%rbx),%esi
   165aa:	4c 8d 63 01          	lea    0x1(%rbx),%r12
   165ae:	48 89 d5             	mov    %rdx,%rbp
   165b1:	48 89 ef             	mov    %rbp,%rdi
   165b4:	4c 89 e2             	mov    %r12,%rdx
   165b7:	e8 2d b1 ff ff       	callq  116e9 <bt_conn_is_peer_addr_le>
   165bc:	84 c0                	test   %al,%al
   165be:	75 24                	jne    165e4 <disconnected_cb+0x87>
			tmp = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
   165c0:	0f b6 3b             	movzbl (%rbx),%edi
   165c3:	4c 89 e6             	mov    %r12,%rsi
   165c6:	e8 48 b4 ff ff       	callq  11a13 <bt_conn_lookup_addr_le>
			if (tmp) {
   165cb:	48 85 c0             	test   %rax,%rax
   165ce:	74 70                	je     16640 <disconnected_cb+0xe3>
				if (tmp->state == BT_CONN_CONNECTED) {
   165d0:	40 8a 68 0a          	mov    0xa(%rax),%bpl
				bt_conn_unref(tmp);
   165d4:	48 89 c7             	mov    %rax,%rdi
   165d7:	e8 88 b1 ff ff       	callq  11764 <bt_conn_unref>
	if (!value_used) {
   165dc:	40 80 fd 07          	cmp    $0x7,%bpl
   165e0:	74 74                	je     16656 <disconnected_cb+0xf9>
   165e2:	eb 5c                	jmp    16640 <disconnected_cb+0xe3>
			if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   165e4:	0f b6 7d 08          	movzbl 0x8(%rbp),%edi
   165e8:	4c 8d b5 d8 00 00 00 	lea    0xd8(%rbp),%r14
   165ef:	4c 89 f6             	mov    %r14,%rsi
   165f2:	e8 7c 9d ff ff       	callq  10373 <bt_addr_le_is_bonded>
   165f7:	84 c0                	test   %al,%al
   165f9:	75 3a                	jne    16635 <disconnected_cb+0xd8>
				if (ccc == &sc_ccc) {
   165fb:	48 8d 05 7e 02 22 00 	lea    0x22027e(%rip),%rax        # 236880 <sc_ccc>
   16602:	48 39 c3             	cmp    %rax,%rbx
   16605:	75 08                	jne    1660f <disconnected_cb+0xb2>
					sc_clear(conn);
   16607:	48 89 ef             	mov    %rbp,%rdi
   1660a:	e8 35 fc ff ff       	callq  16244 <sc_clear>
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   1660f:	48 8d 7c 24 01       	lea    0x1(%rsp),%rdi
   16614:	31 c0                	xor    %eax,%eax
   16616:	b9 07 00 00 00       	mov    $0x7,%ecx
   1661b:	48 8d 74 24 01       	lea    0x1(%rsp),%rsi
   16620:	f3 aa                	rep stos %al,%es:(%rdi)
   16622:	4c 89 e7             	mov    %r12,%rdi
   16625:	e8 72 e9 ff ff       	callq  14f9c <bt_addr_le_copy>
	cfg->id = 0U;
   1662a:	c6 03 00             	movb   $0x0,(%rbx)
	cfg->value = 0U;
   1662d:	66 c7 43 08 00 00    	movw   $0x0,0x8(%rbx)
   16633:	eb 0b                	jmp    16640 <disconnected_cb+0xe3>
				bt_addr_le_copy(&cfg->peer, &conn->le.dst);
   16635:	4c 89 f6             	mov    %r14,%rsi
   16638:	4c 89 e7             	mov    %r12,%rdi
   1663b:	e8 5c e9 ff ff       	callq  14f9c <bt_addr_le_copy>
		if (ccc->cfg_changed) {
   16640:	48 8b 43 10          	mov    0x10(%rbx),%rax
		ccc->value = 0U;
   16644:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%rbx)
		if (ccc->cfg_changed) {
   1664a:	48 85 c0             	test   %rax,%rax
   1664d:	74 07                	je     16656 <disconnected_cb+0xf9>
			ccc->cfg_changed(attr, ccc->value);
   1664f:	31 f6                	xor    %esi,%esi
   16651:	4c 89 ef             	mov    %r13,%rdi
   16654:	ff d0                	callq  *%rax
}
   16656:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   1665b:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
   16662:	00 00 
   16664:	b0 01                	mov    $0x1,%al
   16666:	74 05                	je     1666d <disconnected_cb+0x110>
   16668:	e8 d3 df fe ff       	callq  4640 <__stack_chk_fail@plt>
   1666d:	48 83 c4 10          	add    $0x10,%rsp
   16671:	5b                   	pop    %rbx
   16672:	5d                   	pop    %rbp
   16673:	41 5c                	pop    %r12
   16675:	41 5d                	pop    %r13
   16677:	41 5e                	pop    %r14
   16679:	c3                   	retq   

000000000001667a <bt_gatt_init>:
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   1667a:	31 d2                	xor    %edx,%edx
   1667c:	b9 01 00 00 00       	mov    $0x1,%ecx
   16681:	89 d0                	mov    %edx,%eax
   16683:	f0 0f b1 0d 0d 8a 24 	lock cmpxchg %ecx,0x248a0d(%rip)        # 25f098 <init>
   1668a:	00 
	if (!atomic_cas(&init, 0, 1)) {
   1668b:	0f 85 95 00 00 00    	jne    16726 <bt_gatt_init+0xac>
{
   16691:	53                   	push   %rbx
   16692:	89 d0                	mov    %edx,%eax
   16694:	f0 0f b1 0d f8 89 24 	lock cmpxchg %ecx,0x2489f8(%rip)        # 25f094 <service_init>
   1669b:	00 
	if (!atomic_cas(&service_init, 0, 1)) {
   1669c:	75 2f                	jne    166cd <bt_gatt_init+0x53>
   1669e:	66 8b 15 37 8a 24 00 	mov    0x248a37(%rip),%dx        # 25f0dc <last_static_handle>
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
   166a5:	48 8d 05 cc 3b 22 00 	lea    0x223bcc(%rip),%rax        # 23a278 <_bt_l2cap_fixed_chan_list_end>
	if (!atomic_cas(&service_init, 0, 1)) {
   166ac:	31 c9                	xor    %ecx,%ecx
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
   166ae:	48 3b 05 03 f9 21 00 	cmp    0x21f903(%rip),%rax        # 235fb8 <_GLOBAL_OFFSET_TABLE_+0x2d8>
   166b5:	73 0b                	jae    166c2 <bt_gatt_init+0x48>
		last_static_handle += svc->attr_count;
   166b7:	03 50 08             	add    0x8(%rax),%edx
   166ba:	b1 01                	mov    $0x1,%cl
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
   166bc:	48 83 c0 10          	add    $0x10,%rax
   166c0:	eb ec                	jmp    166ae <bt_gatt_init+0x34>
   166c2:	84 c9                	test   %cl,%cl
   166c4:	74 07                	je     166cd <bt_gatt_init+0x53>
   166c6:	66 89 15 0f 8a 24 00 	mov    %dx,0x248a0f(%rip)        # 25f0dc <last_static_handle>
	*work = (struct k_delayed_work)Z_DELAYED_WORK_INITIALIZER(handler);
   166cd:	48 8d 35 4c 0e 24 00 	lea    0x240e4c(%rip),%rsi        # 257520 <db_hash_work>
   166d4:	31 db                	xor    %ebx,%ebx
   166d6:	b9 10 00 00 00       	mov    $0x10,%ecx
   166db:	89 d8                	mov    %ebx,%eax
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   166dd:	ba 01 00 00 00       	mov    $0x1,%edx
	*work = (struct k_delayed_work)Z_DELAYED_WORK_INITIALIZER(handler);
   166e2:	48 89 f7             	mov    %rsi,%rdi
   166e5:	f3 ab                	rep stos %eax,%es:(%rdi)
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   166e7:	48 8d 3d b2 14 24 00 	lea    0x2414b2(%rip),%rdi        # 257ba0 <k_sys_work_q>
	*work = (struct k_delayed_work)Z_DELAYED_WORK_INITIALIZER(handler);
   166ee:	48 8d 05 a1 06 00 00 	lea    0x6a1(%rip),%rax        # 16d96 <db_hash_process>
   166f5:	48 89 46 08          	mov    %rax,0x8(%rsi)
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   166f9:	e8 79 5c 01 00       	callq  2c377 <k_delayed_work_submit_to_queue>
	*work = (struct k_delayed_work)Z_DELAYED_WORK_INITIALIZER(handler);
   166fe:	48 8d 3d d3 0d 24 00 	lea    0x240dd3(%rip),%rdi        # 2574d8 <gatt_sc+0x38>
   16705:	89 d8                	mov    %ebx,%eax
   16707:	b9 10 00 00 00       	mov    $0x10,%ecx
   1670c:	f3 ab                	rep stos %eax,%es:(%rdi)
   1670e:	48 8d 05 c0 0a 00 00 	lea    0xac0(%rip),%rax        # 171d5 <sc_process>
   16715:	48 89 05 c4 0d 24 00 	mov    %rax,0x240dc4(%rip)        # 2574e0 <gatt_sc+0x40>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1671c:	f0 83 0d f4 0d 24 00 	lock orl $0x2,0x240df4(%rip)        # 257518 <gatt_sc+0x78>
   16723:	02 
}
   16724:	5b                   	pop    %rbx
   16725:	c3                   	retq   
   16726:	c3                   	retq   

0000000000016727 <bt_gatt_attr_read>:
{
   16727:	8b 7c 24 08          	mov    0x8(%rsp),%edi
   1672b:	41 0f b7 f0          	movzwl %r8w,%esi
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   1672f:	48 c7 c0 f9 ff ff ff 	mov    $0xfffffffffffffff9,%rax
	if (offset > value_len) {
   16736:	66 41 39 f8          	cmp    %di,%r8w
   1673a:	77 20                	ja     1675c <bt_gatt_attr_read+0x35>
	len = MIN(buf_len, value_len - offset);
   1673c:	0f b7 c7             	movzwl %di,%eax
   1673f:	45 0f b7 c0          	movzwl %r8w,%r8d
   16743:	0f b7 c9             	movzwl %cx,%ecx
   16746:	44 29 c0             	sub    %r8d,%eax
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
   16749:	48 89 d7             	mov    %rdx,%rdi
   1674c:	39 c8                	cmp    %ecx,%eax
   1674e:	0f 4f c1             	cmovg  %ecx,%eax
	memcpy(buf, (uint8_t *)value + offset, len);
   16751:	4c 01 ce             	add    %r9,%rsi
   16754:	0f b7 c0             	movzwl %ax,%eax
   16757:	48 89 c1             	mov    %rax,%rcx
   1675a:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
}
   1675c:	c3                   	retq   

000000000001675d <read_ppcp>:
{
   1675d:	48 83 ec 20          	sub    $0x20,%rsp
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &ppcp,
   16761:	0f b7 c9             	movzwl %cx,%ecx
   16764:	45 0f b7 c0          	movzwl %r8w,%r8d
{
   16768:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1676f:	00 00 
   16771:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
   16776:	31 c0                	xor    %eax,%eax
	ppcp.min_int = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_MIN_INT);
   16778:	48 b8 18 00 28 00 00 	movabs $0x2a000000280018,%rax
   1677f:	00 2a 00 
   16782:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &ppcp,
   16787:	6a 08                	pushq  $0x8
   16789:	4c 8d 4c 24 10       	lea    0x10(%rsp),%r9
   1678e:	e8 94 ff ff ff       	callq  16727 <bt_gatt_attr_read>
   16793:	5a                   	pop    %rdx
   16794:	59                   	pop    %rcx
}
   16795:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   1679a:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
   167a1:	00 00 
   167a3:	74 05                	je     167aa <read_ppcp+0x4d>
   167a5:	e8 96 de fe ff       	callq  4640 <__stack_chk_fail@plt>
   167aa:	48 83 c4 18          	add    $0x18,%rsp
   167ae:	c3                   	retq   

00000000000167af <read_appearance>:
{
   167af:	48 83 ec 20          	sub    $0x20,%rsp
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &appearance,
   167b3:	0f b7 c9             	movzwl %cx,%ecx
   167b6:	45 0f b7 c0          	movzwl %r8w,%r8d
{
   167ba:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   167c1:	00 00 
   167c3:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
   167c8:	31 c0                	xor    %eax,%eax
	uint16_t appearance = sys_cpu_to_le16(gap_appearance);
   167ca:	66 c7 44 24 0e 41 03 	movw   $0x341,0xe(%rsp)
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &appearance,
   167d1:	6a 02                	pushq  $0x2
   167d3:	4c 8d 4c 24 16       	lea    0x16(%rsp),%r9
   167d8:	e8 4a ff ff ff       	callq  16727 <bt_gatt_attr_read>
   167dd:	5a                   	pop    %rdx
   167de:	59                   	pop    %rcx
}
   167df:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   167e4:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
   167eb:	00 00 
   167ed:	74 05                	je     167f4 <read_appearance+0x45>
   167ef:	e8 4c de fe ff       	callq  4640 <__stack_chk_fail@plt>
   167f4:	48 83 c4 18          	add    $0x18,%rsp
   167f8:	c3                   	retq   

00000000000167f9 <read_name>:
{
   167f9:	55                   	push   %rbp
   167fa:	53                   	push   %rbx
   167fb:	48 89 fd             	mov    %rdi,%rbp
   167fe:	89 cb                	mov    %ecx,%ebx
   16800:	48 83 ec 28          	sub    $0x28,%rsp
   16804:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
   16809:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
   1680e:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
	const char *name = bt_get_name();
   16813:	e8 7d 97 ff ff       	callq  ff95 <bt_get_name>
   16818:	49 89 c1             	mov    %rax,%r9
				 strlen(name));
   1681b:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
   1681f:	31 c0                	xor    %eax,%eax
   16821:	4c 89 cf             	mov    %r9,%rdi
	return bt_gatt_attr_read(conn, attr, buf, len, offset, name,
   16824:	48 83 ec 08          	sub    $0x8,%rsp
				 strlen(name));
   16828:	f2 ae                	repnz scas %es:(%rdi),%al
	return bt_gatt_attr_read(conn, attr, buf, len, offset, name,
   1682a:	48 89 ef             	mov    %rbp,%rdi
				 strlen(name));
   1682d:	48 89 c8             	mov    %rcx,%rax
	return bt_gatt_attr_read(conn, attr, buf, len, offset, name,
   16830:	0f b7 cb             	movzwl %bx,%ecx
				 strlen(name));
   16833:	48 f7 d0             	not    %rax
   16836:	48 ff c8             	dec    %rax
	return bt_gatt_attr_read(conn, attr, buf, len, offset, name,
   16839:	0f b7 c0             	movzwl %ax,%eax
   1683c:	50                   	push   %rax
   1683d:	44 8b 44 24 1c       	mov    0x1c(%rsp),%r8d
   16842:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
   16847:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
   1684c:	45 0f b7 c0          	movzwl %r8w,%r8d
   16850:	e8 d2 fe ff ff       	callq  16727 <bt_gatt_attr_read>
}
   16855:	48 83 c4 38          	add    $0x38,%rsp
   16859:	5b                   	pop    %rbx
   1685a:	5d                   	pop    %rbp
   1685b:	c3                   	retq   

000000000001685c <cf_read>:
{
   1685c:	55                   	push   %rbp
   1685d:	53                   	push   %rbx
   1685e:	48 89 fd             	mov    %rdi,%rbp
   16861:	89 cb                	mov    %ecx,%ebx
   16863:	48 83 ec 38          	sub    $0x38,%rsp
   16867:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
   1686c:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
   16871:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
	uint8_t data[1] = {};
   16876:	c6 44 24 27 00       	movb   $0x0,0x27(%rsp)
{
   1687b:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   16882:	00 00 
   16884:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
   16889:	31 c0                	xor    %eax,%eax
	cfg = find_cf_cfg(conn);
   1688b:	e8 57 e9 ff ff       	callq  151e7 <find_cf_cfg>
	if (cfg) {
   16890:	48 85 c0             	test   %rax,%rax
   16893:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
   16898:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
   1689d:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
   168a2:	74 07                	je     168ab <cf_read+0x4f>
   168a4:	8a 40 08             	mov    0x8(%rax),%al
   168a7:	88 44 24 27          	mov    %al,0x27(%rsp)
	return bt_gatt_attr_read(conn, attr, buf, len, offset, data,
   168ab:	48 83 ec 08          	sub    $0x8,%rsp
   168af:	0f b7 cb             	movzwl %bx,%ecx
   168b2:	45 0f b7 c0          	movzwl %r8w,%r8d
   168b6:	6a 01                	pushq  $0x1
   168b8:	48 89 ef             	mov    %rbp,%rdi
   168bb:	4c 8d 4c 24 37       	lea    0x37(%rsp),%r9
   168c0:	e8 62 fe ff ff       	callq  16727 <bt_gatt_attr_read>
   168c5:	5a                   	pop    %rdx
   168c6:	59                   	pop    %rcx
}
   168c7:	48 8b 5c 24 28       	mov    0x28(%rsp),%rbx
   168cc:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
   168d3:	00 00 
   168d5:	74 05                	je     168dc <cf_read+0x80>
   168d7:	e8 64 dd fe ff       	callq  4640 <__stack_chk_fail@plt>
   168dc:	48 83 c4 38          	add    $0x38,%rsp
   168e0:	5b                   	pop    %rbx
   168e1:	5d                   	pop    %rbp
   168e2:	c3                   	retq   

00000000000168e3 <bt_gatt_attr_read_service>:
{
   168e3:	48 83 ec 18          	sub    $0x18,%rsp
   168e7:	45 0f b7 c0          	movzwl %r8w,%r8d
   168eb:	0f b7 c9             	movzwl %cx,%ecx
   168ee:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   168f5:	00 00 
   168f7:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   168fc:	31 c0                	xor    %eax,%eax
	struct bt_uuid *uuid = attr->user_data;
   168fe:	48 8b 46 18          	mov    0x18(%rsi),%rax
	if (uuid->type == BT_UUID_TYPE_16) {
   16902:	80 38 00             	cmpb   $0x0,(%rax)
   16905:	75 16                	jne    1691d <bt_gatt_attr_read_service+0x3a>
		uint16_t uuid16 = sys_cpu_to_le16(BT_UUID_16(uuid)->val);
   16907:	66 8b 40 02          	mov    0x2(%rax),%ax
		return bt_gatt_attr_read(conn, attr, buf, len, offset,
   1690b:	48 83 ec 08          	sub    $0x8,%rsp
		uint16_t uuid16 = sys_cpu_to_le16(BT_UUID_16(uuid)->val);
   1690f:	66 89 44 24 0e       	mov    %ax,0xe(%rsp)
		return bt_gatt_attr_read(conn, attr, buf, len, offset,
   16914:	6a 02                	pushq  $0x2
   16916:	4c 8d 4c 24 16       	lea    0x16(%rsp),%r9
   1691b:	eb 0a                	jmp    16927 <bt_gatt_attr_read_service+0x44>
	return bt_gatt_attr_read(conn, attr, buf, len, offset,
   1691d:	48 83 ec 08          	sub    $0x8,%rsp
   16921:	4c 8d 48 01          	lea    0x1(%rax),%r9
   16925:	6a 10                	pushq  $0x10
   16927:	e8 fb fd ff ff       	callq  16727 <bt_gatt_attr_read>
   1692c:	5a                   	pop    %rdx
   1692d:	59                   	pop    %rcx
}
   1692e:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   16933:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
   1693a:	00 00 
   1693c:	74 05                	je     16943 <bt_gatt_attr_read_service+0x60>
   1693e:	e8 fd dc fe ff       	callq  4640 <__stack_chk_fail@plt>
   16943:	48 83 c4 18          	add    $0x18,%rsp
   16947:	c3                   	retq   

0000000000016948 <bt_gatt_attr_read_ccc>:
{
   16948:	41 54                	push   %r12
   1694a:	55                   	push   %rbp
   1694b:	49 89 f4             	mov    %rsi,%r12
   1694e:	53                   	push   %rbx
   1694f:	48 89 fd             	mov    %rdi,%rbp
   16952:	89 cb                	mov    %ecx,%ebx
   16954:	48 83 ec 20          	sub    $0x20,%rsp
	cfg = find_ccc_cfg(conn, ccc);
   16958:	48 8b 76 18          	mov    0x18(%rsi),%rsi
{
   1695c:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
   16961:	44 89 44 24 04       	mov    %r8d,0x4(%rsp)
   16966:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1696d:	00 00 
   1696f:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   16974:	31 c0                	xor    %eax,%eax
	cfg = find_ccc_cfg(conn, ccc);
   16976:	e8 12 e9 ff ff       	callq  1528d <find_ccc_cfg>
	if (cfg) {
   1697b:	48 85 c0             	test   %rax,%rax
   1697e:	44 8b 44 24 04       	mov    0x4(%rsp),%r8d
   16983:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   16988:	74 0b                	je     16995 <bt_gatt_attr_read_ccc+0x4d>
		value = sys_cpu_to_le16(cfg->value);
   1698a:	66 8b 40 08          	mov    0x8(%rax),%ax
   1698e:	66 89 44 24 16       	mov    %ax,0x16(%rsp)
   16993:	eb 07                	jmp    1699c <bt_gatt_attr_read_ccc+0x54>
		value = 0x0000;
   16995:	66 c7 44 24 16 00 00 	movw   $0x0,0x16(%rsp)
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &value,
   1699c:	48 83 ec 08          	sub    $0x8,%rsp
   169a0:	0f b7 cb             	movzwl %bx,%ecx
   169a3:	45 0f b7 c0          	movzwl %r8w,%r8d
   169a7:	6a 02                	pushq  $0x2
   169a9:	4c 89 e6             	mov    %r12,%rsi
   169ac:	48 89 ef             	mov    %rbp,%rdi
   169af:	4c 8d 4c 24 26       	lea    0x26(%rsp),%r9
   169b4:	e8 6e fd ff ff       	callq  16727 <bt_gatt_attr_read>
   169b9:	5a                   	pop    %rdx
   169ba:	59                   	pop    %rcx
}
   169bb:	48 8b 5c 24 18       	mov    0x18(%rsp),%rbx
   169c0:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
   169c7:	00 00 
   169c9:	74 05                	je     169d0 <bt_gatt_attr_read_ccc+0x88>
   169cb:	e8 70 dc fe ff       	callq  4640 <__stack_chk_fail@plt>
   169d0:	48 83 c4 20          	add    $0x20,%rsp
   169d4:	5b                   	pop    %rbx
   169d5:	5d                   	pop    %rbp
   169d6:	41 5c                	pop    %r12
   169d8:	c3                   	retq   

00000000000169d9 <bt_gatt_attr_get_handle>:
		return 0;
   169d9:	31 c0                	xor    %eax,%eax
	if (!attr) {
   169db:	48 85 ff             	test   %rdi,%rdi
   169de:	74 60                	je     16a40 <bt_gatt_attr_get_handle+0x67>
	if (attr->handle) {
   169e0:	8b 47 20             	mov    0x20(%rdi),%eax
   169e3:	66 85 c0             	test   %ax,%ax
   169e6:	75 58                	jne    16a40 <bt_gatt_attr_get_handle+0x67>
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   169e8:	48 8d 15 89 38 22 00 	lea    0x223889(%rip),%rdx        # 23a278 <_bt_l2cap_fixed_chan_list_end>
	uint16_t handle = 1;
   169ef:	be 01 00 00 00       	mov    $0x1,%esi
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   169f4:	48 3b 15 bd f5 21 00 	cmp    0x21f5bd(%rip),%rdx        # 235fb8 <_GLOBAL_OFFSET_TABLE_+0x2d8>
   169fb:	73 41                	jae    16a3e <bt_gatt_attr_get_handle+0x65>
		if ((attr < &static_svc->attrs[0]) ||
   169fd:	4c 8b 0a             	mov    (%rdx),%r9
   16a00:	4c 8b 42 08          	mov    0x8(%rdx),%r8
   16a04:	4c 39 cf             	cmp    %r9,%rdi
   16a07:	72 10                	jb     16a19 <bt_gatt_attr_get_handle+0x40>
		    (attr > &static_svc->attrs[static_svc->attr_count - 1])) {
   16a09:	49 6b c0 28          	imul   $0x28,%r8,%rax
		for (size_t i = 0; i < static_svc->attr_count; i++, handle++) {
   16a0d:	31 c9                	xor    %ecx,%ecx
		    (attr > &static_svc->attrs[static_svc->attr_count - 1])) {
   16a0f:	49 8d 44 01 d8       	lea    -0x28(%r9,%rax,1),%rax
		if ((attr < &static_svc->attrs[0]) ||
   16a14:	48 39 c7             	cmp    %rax,%rdi
   16a17:	76 15                	jbe    16a2e <bt_gatt_attr_get_handle+0x55>
			handle += static_svc->attr_count;
   16a19:	42 8d 04 06          	lea    (%rsi,%r8,1),%eax
   16a1d:	eb 17                	jmp    16a36 <bt_gatt_attr_get_handle+0x5d>
			if (attr == &static_svc->attrs[i]) {
   16a1f:	4c 6b d1 28          	imul   $0x28,%rcx,%r10
   16a23:	4d 01 ca             	add    %r9,%r10
   16a26:	4c 39 d7             	cmp    %r10,%rdi
   16a29:	74 15                	je     16a40 <bt_gatt_attr_get_handle+0x67>
		for (size_t i = 0; i < static_svc->attr_count; i++, handle++) {
   16a2b:	48 ff c1             	inc    %rcx
   16a2e:	49 39 c8             	cmp    %rcx,%r8
   16a31:	8d 04 0e             	lea    (%rsi,%rcx,1),%eax
   16a34:	75 e9                	jne    16a1f <bt_gatt_attr_get_handle+0x46>
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   16a36:	48 83 c2 10          	add    $0x10,%rdx
   16a3a:	89 c6                	mov    %eax,%esi
   16a3c:	eb b6                	jmp    169f4 <bt_gatt_attr_get_handle+0x1b>
		return 0;
   16a3e:	31 c0                	xor    %eax,%eax
}
   16a40:	c3                   	retq   

0000000000016a41 <bt_gatt_attr_value_handle>:
{
   16a41:	53                   	push   %rbx
   16a42:	48 83 ec 10          	sub    $0x10,%rsp
   16a46:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   16a4d:	00 00 
   16a4f:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   16a54:	31 c0                	xor    %eax,%eax
	if (attr != NULL && bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) == 0) {
   16a56:	48 85 ff             	test   %rdi,%rdi
   16a59:	75 04                	jne    16a5f <bt_gatt_attr_value_handle+0x1e>
	uint16_t handle = 0;
   16a5b:	31 c0                	xor    %eax,%eax
   16a5d:	eb 36                	jmp    16a95 <bt_gatt_attr_value_handle+0x54>
   16a5f:	48 89 fb             	mov    %rdi,%rbx
	if (attr != NULL && bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) == 0) {
   16a62:	48 8b 3f             	mov    (%rdi),%rdi
   16a65:	48 8d 74 24 04       	lea    0x4(%rsp),%rsi
   16a6a:	c6 44 24 04 00       	movb   $0x0,0x4(%rsp)
   16a6f:	66 c7 44 24 06 03 28 	movw   $0x2803,0x6(%rsp)
   16a76:	e8 d2 6a ff ff       	callq  d54d <bt_uuid_cmp>
   16a7b:	85 c0                	test   %eax,%eax
   16a7d:	75 dc                	jne    16a5b <bt_gatt_attr_value_handle+0x1a>
		handle = chrc->value_handle;
   16a7f:	48 8b 43 18          	mov    0x18(%rbx),%rax
   16a83:	8b 40 08             	mov    0x8(%rax),%eax
		if (handle == 0) {
   16a86:	66 85 c0             	test   %ax,%ax
   16a89:	75 0a                	jne    16a95 <bt_gatt_attr_value_handle+0x54>
			handle = bt_gatt_attr_get_handle(attr) + 1U;
   16a8b:	48 89 df             	mov    %rbx,%rdi
   16a8e:	e8 46 ff ff ff       	callq  169d9 <bt_gatt_attr_get_handle>
   16a93:	ff c0                	inc    %eax
}
   16a95:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   16a9a:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
   16aa1:	00 00 
   16aa3:	74 05                	je     16aaa <bt_gatt_attr_value_handle+0x69>
   16aa5:	e8 96 db fe ff       	callq  4640 <__stack_chk_fail@plt>
   16aaa:	48 83 c4 10          	add    $0x10,%rsp
   16aae:	5b                   	pop    %rbx
   16aaf:	c3                   	retq   

0000000000016ab0 <bt_gatt_attr_read_chrc>:
{
   16ab0:	41 54                	push   %r12
   16ab2:	55                   	push   %rbp
   16ab3:	48 89 fd             	mov    %rdi,%rbp
   16ab6:	53                   	push   %rbx
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   16ab7:	48 89 f7             	mov    %rsi,%rdi
{
   16aba:	89 cb                	mov    %ecx,%ebx
   16abc:	48 83 ec 40          	sub    $0x40,%rsp
	struct bt_gatt_chrc *chrc = attr->user_data;
   16ac0:	4c 8b 66 18          	mov    0x18(%rsi),%r12
{
   16ac4:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   16acb:	00 00 
   16acd:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
   16ad2:	31 c0                	xor    %eax,%eax
   16ad4:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
   16ad9:	44 89 44 24 14       	mov    %r8d,0x14(%rsp)
	pdu.properties = chrc->properties;
   16ade:	41 8a 44 24 0a       	mov    0xa(%r12),%al
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   16ae3:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	pdu.properties = chrc->properties;
   16ae8:	88 44 24 25          	mov    %al,0x25(%rsp)
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   16aec:	e8 50 ff ff ff       	callq  16a41 <bt_gatt_attr_value_handle>
   16af1:	66 89 44 24 26       	mov    %ax,0x26(%rsp)
	if (chrc->uuid->type == BT_UUID_TYPE_16) {
   16af6:	49 8b 04 24          	mov    (%r12),%rax
   16afa:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   16aff:	44 8b 44 24 14       	mov    0x14(%rsp),%r8d
   16b04:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
   16b09:	80 38 00             	cmpb   $0x0,(%rax)
   16b0c:	75 10                	jne    16b1e <bt_gatt_attr_read_chrc+0x6e>
		pdu.uuid16 = sys_cpu_to_le16(BT_UUID_16(chrc->uuid)->val);
   16b0e:	66 8b 40 02          	mov    0x2(%rax),%ax
   16b12:	66 89 44 24 28       	mov    %ax,0x28(%rsp)
		value_len += 2U;
   16b17:	b8 05 00 00 00       	mov    $0x5,%eax
   16b1c:	eb 0e                	jmp    16b2c <bt_gatt_attr_read_chrc+0x7c>
   16b1e:	0f 10 40 01          	movups 0x1(%rax),%xmm0
		value_len += 16U;
   16b22:	b8 13 00 00 00       	mov    $0x13,%eax
   16b27:	0f 11 44 24 28       	movups %xmm0,0x28(%rsp)
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &pdu, value_len);
   16b2c:	48 83 ec 08          	sub    $0x8,%rsp
   16b30:	0f b7 cb             	movzwl %bx,%ecx
   16b33:	45 0f b7 c0          	movzwl %r8w,%r8d
   16b37:	48 89 ef             	mov    %rbp,%rdi
   16b3a:	50                   	push   %rax
   16b3b:	4c 8d 4c 24 35       	lea    0x35(%rsp),%r9
   16b40:	e8 e2 fb ff ff       	callq  16727 <bt_gatt_attr_read>
   16b45:	5a                   	pop    %rdx
   16b46:	59                   	pop    %rcx
}
   16b47:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
   16b4c:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
   16b53:	00 00 
   16b55:	74 05                	je     16b5c <bt_gatt_attr_read_chrc+0xac>
   16b57:	e8 e4 da fe ff       	callq  4640 <__stack_chk_fail@plt>
   16b5c:	48 83 c4 40          	add    $0x40,%rsp
   16b60:	5b                   	pop    %rbx
   16b61:	5d                   	pop    %rbp
   16b62:	41 5c                	pop    %r12
   16b64:	c3                   	retq   

0000000000016b65 <bt_gatt_foreach_attr_type>:
{
   16b65:	41 57                	push   %r15
   16b67:	41 56                	push   %r14
   16b69:	41 55                	push   %r13
   16b6b:	41 54                	push   %r12
   16b6d:	55                   	push   %rbp
   16b6e:	53                   	push   %rbx
		num_matches = UINT16_MAX;
   16b6f:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
{
   16b74:	48 83 ec 28          	sub    $0x28,%rsp
		num_matches = UINT16_MAX;
   16b78:	66 45 85 c0          	test   %r8w,%r8w
   16b7c:	41 0f 45 d8          	cmovne %r8d,%ebx
	if (start_handle <= last_static_handle) {
   16b80:	66 39 3d 55 85 24 00 	cmp    %di,0x248555(%rip)        # 25f0dc <last_static_handle>
{
   16b87:	66 89 7c 24 18       	mov    %di,0x18(%rsp)
   16b8c:	66 89 74 24 1a       	mov    %si,0x1a(%rsp)
	if (start_handle <= last_static_handle) {
   16b91:	0f 82 c3 00 00 00    	jb     16c5a <bt_gatt_foreach_attr_type+0xf5>
		Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   16b97:	4c 8d 2d da 36 22 00 	lea    0x2236da(%rip),%r13        # 23a278 <_bt_l2cap_fixed_chan_list_end>
   16b9e:	4c 89 4c 24 08       	mov    %r9,0x8(%rsp)
   16ba3:	49 89 cc             	mov    %rcx,%r12
   16ba6:	48 89 d5             	mov    %rdx,%rbp
		uint16_t handle = 1;
   16ba9:	41 be 01 00 00 00    	mov    $0x1,%r14d
		Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   16baf:	4c 3b 2d 02 f4 21 00 	cmp    0x21f402(%rip),%r13        # 235fb8 <_GLOBAL_OFFSET_TABLE_+0x2d8>
   16bb6:	0f 83 9e 00 00 00    	jae    16c5a <bt_gatt_foreach_attr_type+0xf5>
			if (handle + static_svc->attr_count < start_handle) {
   16bbc:	49 8b 55 08          	mov    0x8(%r13),%rdx
   16bc0:	0f b7 44 24 18       	movzwl 0x18(%rsp),%eax
   16bc5:	41 0f b7 fe          	movzwl %r14w,%edi
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
   16bc9:	45 31 ff             	xor    %r15d,%r15d
			if (handle + static_svc->attr_count < start_handle) {
   16bcc:	48 01 d7             	add    %rdx,%rdi
				handle += static_svc->attr_count;
   16bcf:	44 01 f2             	add    %r14d,%edx
			if (handle + static_svc->attr_count < start_handle) {
   16bd2:	48 39 c7             	cmp    %rax,%rdi
   16bd5:	72 77                	jb     16c4e <bt_gatt_foreach_attr_type+0xe9>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
   16bd7:	4d 39 7d 08          	cmp    %r15,0x8(%r13)
   16bdb:	43 8d 14 3e          	lea    (%r14,%r15,1),%edx
   16bdf:	76 6d                	jbe    16c4e <bt_gatt_foreach_attr_type+0xe9>
	if (handle > end_handle) {
   16be1:	66 39 54 24 1a       	cmp    %dx,0x1a(%rsp)
   16be6:	72 72                	jb     16c5a <bt_gatt_foreach_attr_type+0xf5>
	if (handle < start_handle) {
   16be8:	66 39 54 24 18       	cmp    %dx,0x18(%rsp)
   16bed:	77 5a                	ja     16c49 <bt_gatt_foreach_attr_type+0xe4>
				if (gatt_foreach_iter(&static_svc->attrs[i],
   16bef:	4d 6b d7 28          	imul   $0x28,%r15,%r10
   16bf3:	4d 03 55 00          	add    0x0(%r13),%r10
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
   16bf7:	48 85 ed             	test   %rbp,%rbp
   16bfa:	75 07                	jne    16c03 <bt_gatt_foreach_attr_type+0x9e>
	if (attr_data && attr_data != attr->user_data) {
   16bfc:	4d 85 e4             	test   %r12,%r12
   16bff:	74 2b                	je     16c2c <bt_gatt_foreach_attr_type+0xc7>
   16c01:	eb 23                	jmp    16c26 <bt_gatt_foreach_attr_type+0xc1>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
   16c03:	49 8b 32             	mov    (%r10),%rsi
   16c06:	48 89 ef             	mov    %rbp,%rdi
   16c09:	89 54 24 1c          	mov    %edx,0x1c(%rsp)
   16c0d:	4c 89 54 24 10       	mov    %r10,0x10(%rsp)
   16c12:	e8 36 69 ff ff       	callq  d54d <bt_uuid_cmp>
   16c17:	85 c0                	test   %eax,%eax
   16c19:	4c 8b 54 24 10       	mov    0x10(%rsp),%r10
   16c1e:	8b 54 24 1c          	mov    0x1c(%rsp),%edx
   16c22:	74 d8                	je     16bfc <bt_gatt_foreach_attr_type+0x97>
   16c24:	eb 23                	jmp    16c49 <bt_gatt_foreach_attr_type+0xe4>
	if (attr_data && attr_data != attr->user_data) {
   16c26:	4d 3b 62 18          	cmp    0x18(%r10),%r12
   16c2a:	75 1d                	jne    16c49 <bt_gatt_foreach_attr_type+0xe4>
				if (gatt_foreach_iter(&static_svc->attrs[i],
   16c2c:	0f b7 f2             	movzwl %dx,%esi
	*num_matches -= 1;
   16c2f:	ff cb                	dec    %ebx
	result = func(attr, handle, user_data);
   16c31:	48 8b 54 24 60       	mov    0x60(%rsp),%rdx
   16c36:	4c 89 d7             	mov    %r10,%rdi
   16c39:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   16c3e:	ff d0                	callq  *%rax
				if (gatt_foreach_iter(&static_svc->attrs[i],
   16c40:	84 c0                	test   %al,%al
   16c42:	74 16                	je     16c5a <bt_gatt_foreach_attr_type+0xf5>
   16c44:	66 85 db             	test   %bx,%bx
   16c47:	74 11                	je     16c5a <bt_gatt_foreach_attr_type+0xf5>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
   16c49:	49 ff c7             	inc    %r15
   16c4c:	eb 89                	jmp    16bd7 <bt_gatt_foreach_attr_type+0x72>
		Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   16c4e:	49 83 c5 10          	add    $0x10,%r13
   16c52:	41 89 d6             	mov    %edx,%r14d
   16c55:	e9 55 ff ff ff       	jmpq   16baf <bt_gatt_foreach_attr_type+0x4a>
}
   16c5a:	48 83 c4 28          	add    $0x28,%rsp
   16c5e:	5b                   	pop    %rbx
   16c5f:	5d                   	pop    %rbp
   16c60:	41 5c                	pop    %r12
   16c62:	41 5d                	pop    %r13
   16c64:	41 5e                	pop    %r14
   16c66:	41 5f                	pop    %r15
   16c68:	c3                   	retq   

0000000000016c69 <bt_gatt_foreach_attr>:
{
   16c69:	48 83 ec 10          	sub    $0x10,%rsp
   16c6d:	49 89 d1             	mov    %rdx,%r9
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
   16c70:	0f b7 f6             	movzwl %si,%esi
   16c73:	51                   	push   %rcx
   16c74:	0f b7 ff             	movzwl %di,%edi
   16c77:	45 31 c0             	xor    %r8d,%r8d
   16c7a:	31 c9                	xor    %ecx,%ecx
   16c7c:	31 d2                	xor    %edx,%edx
   16c7e:	e8 e2 fe ff ff       	callq  16b65 <bt_gatt_foreach_attr_type>
}
   16c83:	48 83 c4 18          	add    $0x18,%rsp
   16c87:	c3                   	retq   

0000000000016c88 <db_hash_gen>:
{
   16c88:	55                   	push   %rbp
   16c89:	53                   	push   %rbx
   16c8a:	89 fd                	mov    %edi,%ebp
	uint8_t key[16] = {};
   16c8c:	0f 57 c0             	xorps  %xmm0,%xmm0
{
   16c8f:	48 81 ec 38 01 00 00 	sub    $0x138,%rsp
	if (tc_cmac_setup(&state.state, key, &sched) == TC_CRYPTO_FAIL) {
   16c96:	48 8d 5c 24 08       	lea    0x8(%rsp),%rbx
   16c9b:	48 8d 54 24 68       	lea    0x68(%rsp),%rdx
   16ca0:	48 8d b4 24 18 01 00 	lea    0x118(%rsp),%rsi
   16ca7:	00 
{
   16ca8:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   16caf:	00 00 
   16cb1:	48 89 84 24 28 01 00 	mov    %rax,0x128(%rsp)
   16cb8:	00 
   16cb9:	31 c0                	xor    %eax,%eax
	if (tc_cmac_setup(&state.state, key, &sched) == TC_CRYPTO_FAIL) {
   16cbb:	48 89 df             	mov    %rbx,%rdi
	uint8_t key[16] = {};
   16cbe:	0f 11 84 24 18 01 00 	movups %xmm0,0x118(%rsp)
   16cc5:	00 
	if (tc_cmac_setup(&state.state, key, &sched) == TC_CRYPTO_FAIL) {
   16cc6:	e8 d9 2b ff ff       	callq  98a4 <tc_cmac_setup>
   16ccb:	85 c0                	test   %eax,%eax
   16ccd:	75 21                	jne    16cf0 <db_hash_gen+0x68>
   16ccf:	48 8d 35 ea 36 22 00 	lea    0x2236ea(%rip),%rsi        # 23a3c0 <log_const_bt_gatt>
   16cd6:	48 2b 35 73 f2 21 00 	sub    0x21f273(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unable to setup AES CMAC");
   16cdd:	48 8d 3d 8e c3 01 00 	lea    0x1c38e(%rip),%rdi        # 33072 <__func__.5785+0x240a>
   16ce4:	48 c1 ee 04          	shr    $0x4,%rsi
   16ce8:	c1 e6 06             	shl    $0x6,%esi
   16ceb:	83 ce 01             	or     $0x1,%esi
   16cee:	eb 4b                	jmp    16d3b <db_hash_gen+0xb3>
	bt_gatt_foreach_attr(0x0001, 0xffff, gen_hash_m, &state);
   16cf0:	48 8d 15 2b e3 ff ff 	lea    -0x1cd5(%rip),%rdx        # 15022 <gen_hash_m>
   16cf7:	48 89 d9             	mov    %rbx,%rcx
   16cfa:	be ff ff 00 00       	mov    $0xffff,%esi
   16cff:	bf 01 00 00 00       	mov    $0x1,%edi
   16d04:	e8 60 ff ff ff       	callq  16c69 <bt_gatt_foreach_attr>
	if (tc_cmac_final(db_hash, &state.state) == TC_CRYPTO_FAIL) {
   16d09:	48 8d 3d 20 10 24 00 	lea    0x241020(%rip),%rdi        # 257d30 <db_hash>
   16d10:	48 89 de             	mov    %rbx,%rsi
   16d13:	e8 11 2d ff ff       	callq  9a29 <tc_cmac_final>
   16d18:	85 c0                	test   %eax,%eax
   16d1a:	75 26                	jne    16d42 <db_hash_gen+0xba>
   16d1c:	48 8d 35 9d 36 22 00 	lea    0x22369d(%rip),%rsi        # 23a3c0 <log_const_bt_gatt>
   16d23:	48 2b 35 26 f2 21 00 	sub    0x21f226(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unable to calculate hash");
   16d2a:	48 8d 3d 5a c3 01 00 	lea    0x1c35a(%rip),%rdi        # 3308b <__func__.5785+0x2423>
   16d31:	48 c1 ee 04          	shr    $0x4,%rsi
   16d35:	c1 e6 06             	shl    $0x6,%esi
   16d38:	83 ce 01             	or     $0x1,%esi
   16d3b:	e8 84 05 ff ff       	callq  72c4 <log_0>
   16d40:	eb 32                	jmp    16d74 <db_hash_gen+0xec>
   16d42:	48 8d 15 e7 0f 24 00 	lea    0x240fe7(%rip),%rdx        # 257d30 <db_hash>
 */
static inline void sys_mem_swap(void *buf, size_t length)
{
	size_t i;

	for (i = 0; i < (length/2); i++) {
   16d49:	31 c0                	xor    %eax,%eax
   16d4b:	48 89 d1             	mov    %rdx,%rcx
		uint8_t tmp = ((uint8_t *)buf)[i];

		((uint8_t *)buf)[i] = ((uint8_t *)buf)[length - 1 - i];
   16d4e:	40 8a 7a 0f          	mov    0xf(%rdx),%dil
		uint8_t tmp = ((uint8_t *)buf)[i];
   16d52:	40 8a 34 01          	mov    (%rcx,%rax,1),%sil
   16d56:	48 ff ca             	dec    %rdx
		((uint8_t *)buf)[i] = ((uint8_t *)buf)[length - 1 - i];
   16d59:	40 88 3c 01          	mov    %dil,(%rcx,%rax,1)
	for (i = 0; i < (length/2); i++) {
   16d5d:	48 ff c0             	inc    %rax
		((uint8_t *)buf)[length - 1 - i] = tmp;
   16d60:	40 88 72 10          	mov    %sil,0x10(%rdx)
	for (i = 0; i < (length/2); i++) {
   16d64:	48 83 f8 08          	cmp    $0x8,%rax
   16d68:	75 e4                	jne    16d4e <db_hash_gen+0xc6>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) && store) {
   16d6a:	40 84 ed             	test   %bpl,%bpl
   16d6d:	74 05                	je     16d74 <db_hash_gen+0xec>
		db_hash_store();
   16d6f:	e8 d5 e3 ff ff       	callq  15149 <db_hash_store>
}
   16d74:	48 8b 84 24 28 01 00 	mov    0x128(%rsp),%rax
   16d7b:	00 
   16d7c:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   16d83:	00 00 
   16d85:	74 05                	je     16d8c <db_hash_gen+0x104>
   16d87:	e8 b4 d8 fe ff       	callq  4640 <__stack_chk_fail@plt>
   16d8c:	48 81 c4 38 01 00 00 	add    $0x138,%rsp
   16d93:	5b                   	pop    %rbx
   16d94:	5d                   	pop    %rbp
   16d95:	c3                   	retq   

0000000000016d96 <db_hash_process>:
	db_hash_gen(true);
   16d96:	bf 01 00 00 00       	mov    $0x1,%edi
   16d9b:	e9 e8 fe ff ff       	jmpq   16c88 <db_hash_gen>

0000000000016da0 <db_hash_commit>:
{
   16da0:	48 83 ec 08          	sub    $0x8,%rsp
	err = k_delayed_work_cancel(&db_hash_work);
   16da4:	48 8d 3d 75 07 24 00 	lea    0x240775(%rip),%rdi        # 257520 <db_hash_work>
   16dab:	e8 57 56 01 00       	callq  2c407 <k_delayed_work_cancel>
	if (!err) {
   16db0:	85 c0                	test   %eax,%eax
   16db2:	75 07                	jne    16dbb <db_hash_commit+0x1b>
		db_hash_gen(false);
   16db4:	31 ff                	xor    %edi,%edi
   16db6:	e8 cd fe ff ff       	callq  16c88 <db_hash_gen>
	if (!memcmp(stored_hash, db_hash, sizeof(stored_hash))) {
   16dbb:	48 8d 35 6e 0f 24 00 	lea    0x240f6e(%rip),%rsi        # 257d30 <db_hash>
   16dc2:	48 8d 3d 57 0f 24 00 	lea    0x240f57(%rip),%rdi        # 257d20 <stored_hash>
   16dc9:	ba 10 00 00 00       	mov    $0x10,%edx
   16dce:	e8 6d d6 fe ff       	callq  4440 <memcmp@plt>
   16dd3:	85 c0                	test   %eax,%eax
   16dd5:	75 22                	jne    16df9 <db_hash_commit+0x59>
		k_delayed_work_cancel(&gatt_sc.work);
   16dd7:	48 8d 3d fa 06 24 00 	lea    0x2406fa(%rip),%rdi        # 2574d8 <gatt_sc+0x38>
   16dde:	e8 24 56 01 00       	callq  2c407 <k_delayed_work_cancel>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   16de3:	48 8d 3d 2e 07 24 00 	lea    0x24072e(%rip),%rdi        # 257518 <gatt_sc+0x78>
   16dea:	be fe ff ff ff       	mov    $0xfffffffe,%esi
   16def:	e8 dc e7 ff ff       	callq  155d0 <atomic_and>
   16df4:	e9 89 00 00 00       	jmpq   16e82 <db_hash_commit+0xe2>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   16df9:	8b 05 19 07 24 00    	mov    0x240719(%rip),%eax        # 257518 <gatt_sc+0x78>
   16dff:	89 c1                	mov    %eax,%ecx
   16e01:	89 c2                	mov    %eax,%edx
   16e03:	83 c9 01             	or     $0x1,%ecx
   16e06:	f0 0f b1 0d 0a 07 24 	lock cmpxchg %ecx,0x24070a(%rip)        # 257518 <gatt_sc+0x78>
   16e0d:	00 
   16e0e:	75 ef                	jne    16dff <db_hash_commit+0x5f>
	if (!atomic_test_and_set_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
   16e10:	80 e2 01             	and    $0x1,%dl
   16e13:	75 0c                	jne    16e21 <db_hash_commit+0x81>
		gatt_sc.start = start;
   16e15:	c7 05 b1 06 24 00 01 	movl   $0xffff0001,0x2406b1(%rip)        # 2574d0 <gatt_sc+0x30>
   16e1c:	00 ff ff 
   16e1f:	eb 2f                	jmp    16e50 <db_hash_commit+0xb0>
	if (new_start >= *start && new_end <= *end) {
   16e21:	66 83 3d a7 06 24 00 	cmpw   $0x1,0x2406a7(%rip)        # 2574d0 <gatt_sc+0x30>
   16e28:	01 
   16e29:	66 8b 05 a2 06 24 00 	mov    0x2406a2(%rip),%ax        # 2574d2 <gatt_sc+0x32>
   16e30:	77 07                	ja     16e39 <db_hash_commit+0x99>
   16e32:	66 ff c0             	inc    %ax
   16e35:	75 10                	jne    16e47 <db_hash_commit+0xa7>
   16e37:	eb 44                	jmp    16e7d <db_hash_commit+0xdd>
	if (*end < new_end) {
   16e39:	66 ff c0             	inc    %ax
		*start = new_start;
   16e3c:	66 c7 05 8b 06 24 00 	movw   $0x1,0x24068b(%rip)        # 2574d0 <gatt_sc+0x30>
   16e43:	01 00 
	if (*end < new_end) {
   16e45:	74 09                	je     16e50 <db_hash_commit+0xb0>
		*end = new_end;
   16e47:	66 c7 05 82 06 24 00 	movw   $0xffff,0x240682(%rip)        # 2574d2 <gatt_sc+0x32>
   16e4e:	ff ff 
	if (atomic_test_bit(gatt_sc.flags, SC_INDICATE_PENDING)) {
   16e50:	48 8d 3d c1 06 24 00 	lea    0x2406c1(%rip),%rdi        # 257518 <gatt_sc+0x78>
   16e57:	be 01 00 00 00       	mov    $0x1,%esi
   16e5c:	e8 64 e7 ff ff       	callq  155c5 <atomic_test_bit>
   16e61:	84 c0                	test   %al,%al
   16e63:	75 18                	jne    16e7d <db_hash_commit+0xdd>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   16e65:	48 8d 3d 34 0d 24 00 	lea    0x240d34(%rip),%rdi        # 257ba0 <k_sys_work_q>
   16e6c:	48 8d 35 65 06 24 00 	lea    0x240665(%rip),%rsi        # 2574d8 <gatt_sc+0x38>
   16e73:	ba 01 00 00 00       	mov    $0x1,%edx
   16e78:	e8 fa 54 01 00       	callq  2c377 <k_delayed_work_submit_to_queue>
	db_hash_store();
   16e7d:	e8 c7 e2 ff ff       	callq  15149 <db_hash_store>
}
   16e82:	31 c0                	xor    %eax,%eax
   16e84:	5a                   	pop    %rdx
   16e85:	c3                   	retq   

0000000000016e86 <ccc_set_direct>:
{
   16e86:	41 57                	push   %r15
   16e88:	41 56                	push   %r14
   16e8a:	49 89 f7             	mov    %rsi,%r15
   16e8d:	41 55                	push   %r13
   16e8f:	41 54                	push   %r12
		if (!settings_name_steq((const char *)param, "bt/ccc", &name)) {
   16e91:	48 8d 35 0c c2 01 00 	lea    0x1c20c(%rip),%rsi        # 330a4 <__func__.5785+0x243c>
{
   16e98:	55                   	push   %rbp
   16e99:	53                   	push   %rbx
   16e9a:	49 89 d5             	mov    %rdx,%r13
		if (!settings_name_steq((const char *)param, "bt/ccc", &name)) {
   16e9d:	4c 89 c7             	mov    %r8,%rdi
{
   16ea0:	49 89 ce             	mov    %rcx,%r14
   16ea3:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
		if (!settings_name_steq((const char *)param, "bt/ccc", &name)) {
   16eaa:	48 89 e2             	mov    %rsp,%rdx
{
   16ead:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   16eb4:	00 00 
   16eb6:	48 89 84 24 f8 00 00 	mov    %rax,0xf8(%rsp)
   16ebd:	00 
   16ebe:	31 c0                	xor    %eax,%eax
		if (!settings_name_steq((const char *)param, "bt/ccc", &name)) {
   16ec0:	e8 70 16 ff ff       	callq  8535 <settings_name_steq>
   16ec5:	85 c0                	test   %eax,%eax
   16ec7:	75 21                	jne    16eea <ccc_set_direct+0x64>
   16ec9:	48 8d 35 f0 34 22 00 	lea    0x2234f0(%rip),%rsi        # 23a3c0 <log_const_bt_gatt>
   16ed0:	48 2b 35 79 f0 21 00 	sub    0x21f079(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Invalid key");
   16ed7:	48 8d 3d cd c1 01 00 	lea    0x1c1cd(%rip),%rdi        # 330ab <__func__.5785+0x2443>
   16ede:	48 c1 ee 04          	shr    $0x4,%rsi
   16ee2:	c1 e6 06             	shl    $0x6,%esi
   16ee5:	83 ce 01             	or     $0x1,%esi
   16ee8:	eb 35                	jmp    16f1f <ccc_set_direct+0x99>
		return ccc_set(name, len, read_cb, cb_arg);
   16eea:	48 8b 2c 24          	mov    (%rsp),%rbp
		settings_name_next(name, &next);
   16eee:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
   16ef3:	48 89 ef             	mov    %rbp,%rdi
   16ef6:	e8 94 16 ff ff       	callq  858f <settings_name_next>
		if (!name) {
   16efb:	48 85 ed             	test   %rbp,%rbp
   16efe:	75 26                	jne    16f26 <ccc_set_direct+0xa0>
   16f00:	48 8d 35 b9 34 22 00 	lea    0x2234b9(%rip),%rsi        # 23a3c0 <log_const_bt_gatt>
   16f07:	48 2b 35 42 f0 21 00 	sub    0x21f042(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Insufficient number of arguments");
   16f0e:	48 8d 3d 1f b3 01 00 	lea    0x1b31f(%rip),%rdi        # 32234 <__func__.5785+0x15cc>
   16f15:	48 c1 ee 04          	shr    $0x4,%rsi
   16f19:	c1 e6 06             	shl    $0x6,%esi
   16f1c:	83 ce 01             	or     $0x1,%esi
   16f1f:	e8 a0 03 ff ff       	callq  72c4 <log_0>
   16f24:	eb 68                	jmp    16f8e <ccc_set_direct+0x108>
		} else if (!next) {
   16f26:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   16f2b:	48 85 ff             	test   %rdi,%rdi
   16f2e:	75 07                	jne    16f37 <ccc_set_direct+0xb1>
			load.addr_with_id.id = BT_ID_DEFAULT;
   16f30:	c6 44 24 18 00       	movb   $0x0,0x18(%rsp)
   16f35:	eb 10                	jmp    16f47 <ccc_set_direct+0xc1>
			load.addr_with_id.id = strtol(next, NULL, 10);
   16f37:	ba 0a 00 00 00       	mov    $0xa,%edx
   16f3c:	31 f6                	xor    %esi,%esi
   16f3e:	e8 7d d7 fe ff       	callq  46c0 <strtol@plt>
   16f43:	88 44 24 18          	mov    %al,0x18(%rsp)
		err = bt_settings_decode_key(name, &addr);
   16f47:	4c 8d 64 24 31       	lea    0x31(%rsp),%r12
   16f4c:	48 89 ef             	mov    %rbp,%rdi
   16f4f:	4c 89 e6             	mov    %r12,%rsi
   16f52:	e8 12 64 ff ff       	callq  d369 <bt_settings_decode_key>
		if (err) {
   16f57:	85 c0                	test   %eax,%eax
		err = bt_settings_decode_key(name, &addr);
   16f59:	89 c3                	mov    %eax,%ebx
		if (err) {
   16f5b:	74 3b                	je     16f98 <ccc_set_direct+0x112>
   16f5d:	48 8d 1d 5c 34 22 00 	lea    0x22345c(%rip),%rbx        # 23a3c0 <log_const_bt_gatt>
   16f64:	48 2b 1d e5 ef 21 00 	sub    0x21efe5(%rip),%rbx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Unable to decode address %s", log_strdup(name));
   16f6b:	48 89 ef             	mov    %rbp,%rdi
   16f6e:	e8 9d ff fe ff       	callq  6f10 <log_strdup>
   16f73:	48 8d 3d b0 bf 01 00 	lea    0x1bfb0(%rip),%rdi        # 32f2a <__func__.5785+0x22c2>
   16f7a:	48 89 c6             	mov    %rax,%rsi
   16f7d:	48 c1 eb 04          	shr    $0x4,%rbx
   16f81:	c1 e3 06             	shl    $0x6,%ebx
   16f84:	83 cb 01             	or     $0x1,%ebx
   16f87:	89 da                	mov    %ebx,%edx
   16f89:	e8 67 03 ff ff       	callq  72f5 <log_1>
			return -EINVAL;
   16f8e:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
   16f93:	e9 8d 00 00 00       	jmpq   17025 <ccc_set_direct+0x19f>
		if (len_rd) {
   16f98:	4d 85 ff             	test   %r15,%r15
		load.addr_with_id.addr = &addr;
   16f9b:	4c 89 64 24 10       	mov    %r12,0x10(%rsp)
		if (len_rd) {
   16fa0:	74 56                	je     16ff8 <ccc_set_direct+0x172>
			len = read_cb(cb_arg, ccc_store, sizeof(ccc_store));
   16fa2:	4c 8d 64 24 38       	lea    0x38(%rsp),%r12
   16fa7:	ba c0 00 00 00       	mov    $0xc0,%edx
   16fac:	4c 89 f7             	mov    %r14,%rdi
   16faf:	4c 89 e6             	mov    %r12,%rsi
   16fb2:	41 ff d5             	callq  *%r13
			if (len < 0) {
   16fb5:	48 85 c0             	test   %rax,%rax
			len = read_cb(cb_arg, ccc_store, sizeof(ccc_store));
   16fb8:	48 89 c5             	mov    %rax,%rbp
			if (len < 0) {
   16fbb:	79 2b                	jns    16fe8 <ccc_set_direct+0x162>
   16fbd:	48 8d 15 fc 33 22 00 	lea    0x2233fc(%rip),%rdx        # 23a3c0 <log_const_bt_gatt>
   16fc4:	48 2b 15 85 ef 21 00 	sub    0x21ef85(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
				BT_ERR("Failed to decode value (err %zd)", len);
   16fcb:	48 8d 3d 01 bf 01 00 	lea    0x1bf01(%rip),%rdi        # 32ed3 <__func__.5785+0x226b>
   16fd2:	48 89 c6             	mov    %rax,%rsi
				return len;
   16fd5:	89 eb                	mov    %ebp,%ebx
   16fd7:	48 c1 ea 04          	shr    $0x4,%rdx
				BT_ERR("Failed to decode value (err %zd)", len);
   16fdb:	c1 e2 06             	shl    $0x6,%edx
   16fde:	83 ca 01             	or     $0x1,%edx
   16fe1:	e8 0f 03 ff ff       	callq  72f5 <log_1>
   16fe6:	eb 3d                	jmp    17025 <ccc_set_direct+0x19f>
			load.count = len / sizeof(*ccc_store);
   16fe8:	48 c1 ed 02          	shr    $0x2,%rbp
			load.entry = ccc_store;
   16fec:	4c 89 64 24 20       	mov    %r12,0x20(%rsp)
			load.count = len / sizeof(*ccc_store);
   16ff1:	48 89 6c 24 28       	mov    %rbp,0x28(%rsp)
   16ff6:	eb 12                	jmp    1700a <ccc_set_direct+0x184>
			load.entry = NULL;
   16ff8:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
   16fff:	00 00 
			load.count = 0;
   17001:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
   17008:	00 00 
		bt_gatt_foreach_attr(0x0001, 0xffff, ccc_load, &load);
   1700a:	48 8d 4c 24 10       	lea    0x10(%rsp),%rcx
   1700f:	48 8d 15 3f f0 ff ff 	lea    -0xfc1(%rip),%rdx        # 16055 <ccc_load>
   17016:	be ff ff 00 00       	mov    $0xffff,%esi
   1701b:	bf 01 00 00 00       	mov    $0x1,%edi
   17020:	e8 44 fc ff ff       	callq  16c69 <bt_gatt_foreach_attr>
}
   17025:	48 8b 8c 24 f8 00 00 	mov    0xf8(%rsp),%rcx
   1702c:	00 
   1702d:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   17034:	00 00 
   17036:	89 d8                	mov    %ebx,%eax
   17038:	74 05                	je     1703f <ccc_set_direct+0x1b9>
   1703a:	e8 01 d6 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1703f:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
   17046:	5b                   	pop    %rbx
   17047:	5d                   	pop    %rbp
   17048:	41 5c                	pop    %r12
   1704a:	41 5d                	pop    %r13
   1704c:	41 5e                	pop    %r14
   1704e:	41 5f                	pop    %r15
   17050:	c3                   	retq   

0000000000017051 <bt_gatt_indicate>:
{
   17051:	55                   	push   %rbp
   17052:	53                   	push   %rbx
   17053:	48 89 fd             	mov    %rdi,%rbp
   17056:	48 89 f3             	mov    %rsi,%rbx
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   17059:	be 01 00 00 00       	mov    $0x1,%esi
{
   1705e:	48 83 ec 38          	sub    $0x38,%rsp
   17062:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   17069:	00 00 
   1706b:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
   17070:	31 c0                	xor    %eax,%eax
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   17072:	48 8d 05 c7 f5 21 00 	lea    0x21f5c7(%rip),%rax        # 236640 <bt_dev>
   17079:	48 8d b8 a0 00 00 00 	lea    0xa0(%rax),%rdi
   17080:	e8 40 e5 ff ff       	callq  155c5 <atomic_test_bit>
   17085:	88 c2                	mov    %al,%dl
		return -EAGAIN;
   17087:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   1708c:	84 d2                	test   %dl,%dl
   1708e:	0f 84 25 01 00 00    	je     171b9 <bt_gatt_indicate+0x168>
	data.attr = params->attr;
   17094:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
	if (conn && conn->state != BT_CONN_CONNECTED) {
   17098:	48 85 ed             	test   %rbp,%rbp
	data.attr = params->attr;
   1709b:	48 89 3c 24          	mov    %rdi,(%rsp)
	if (conn && conn->state != BT_CONN_CONNECTED) {
   1709f:	74 0f                	je     170b0 <bt_gatt_indicate+0x5f>
   170a1:	80 7d 0a 07          	cmpb   $0x7,0xa(%rbp)
		return -ENOTCONN;
   170a5:	b8 95 ff ff ff       	mov    $0xffffff95,%eax
	if (conn && conn->state != BT_CONN_CONNECTED) {
   170aa:	0f 85 09 01 00 00    	jne    171b9 <bt_gatt_indicate+0x168>
	data.handle = bt_gatt_attr_get_handle(data.attr);
   170b0:	e8 24 f9 ff ff       	callq  169d9 <bt_gatt_attr_get_handle>
	if (!data.handle) {
   170b5:	66 85 c0             	test   %ax,%ax
	data.handle = bt_gatt_attr_get_handle(data.attr);
   170b8:	66 89 44 24 08       	mov    %ax,0x8(%rsp)
	if (!data.handle) {
   170bd:	75 0a                	jne    170c9 <bt_gatt_indicate+0x78>
		return -ENOENT;
   170bf:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   170c4:	e9 f0 00 00 00       	jmpq   171b9 <bt_gatt_indicate+0x168>
	if (params->uuid) {
   170c9:	48 8b 13             	mov    (%rbx),%rdx
   170cc:	48 85 d2             	test   %rdx,%rdx
   170cf:	75 23                	jne    170f4 <bt_gatt_indicate+0xa3>
	if (!bt_uuid_cmp(data.attr->uuid, BT_UUID_GATT_CHRC)) {
   170d1:	48 8b 04 24          	mov    (%rsp),%rax
   170d5:	c6 44 24 20 00       	movb   $0x0,0x20(%rsp)
   170da:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
   170df:	66 c7 44 24 22 03 28 	movw   $0x2803,0x22(%rsp)
   170e6:	48 8b 38             	mov    (%rax),%rdi
   170e9:	e8 5f 64 ff ff       	callq  d54d <bt_uuid_cmp>
   170ee:	85 c0                	test   %eax,%eax
   170f0:	74 3b                	je     1712d <bt_gatt_indicate+0xdc>
   170f2:	eb 56                	jmp    1714a <bt_gatt_indicate+0xf9>
	found->attr = NULL;
   170f4:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
   170fb:	00 
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
   170fc:	48 83 ec 08          	sub    $0x8,%rsp
   17100:	0f b7 f8             	movzwl %ax,%edi
   17103:	48 8d 44 24 08       	lea    0x8(%rsp),%rax
   17108:	4c 8d 0d 80 de ff ff 	lea    -0x2180(%rip),%r9        # 14f8f <match_uuid>
   1710f:	31 c9                	xor    %ecx,%ecx
   17111:	be ff ff 00 00       	mov    $0xffff,%esi
   17116:	41 b8 01 00 00 00    	mov    $0x1,%r8d
   1711c:	50                   	push   %rax
   1711d:	e8 43 fa ff ff       	callq  16b65 <bt_gatt_foreach_attr_type>
   17122:	59                   	pop    %rcx
   17123:	5e                   	pop    %rsi
		if (!gatt_find_by_uuid(&data, params->uuid)) {
   17124:	48 83 3c 24 00       	cmpq   $0x0,(%rsp)
   17129:	75 a6                	jne    170d1 <bt_gatt_indicate+0x80>
   1712b:	eb 92                	jmp    170bf <bt_gatt_indicate+0x6e>
		struct bt_gatt_chrc *chrc = data.attr->user_data;
   1712d:	48 8b 3c 24          	mov    (%rsp),%rdi
			return -EINVAL;
   17131:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		if (!(chrc->properties & BT_GATT_CHRC_INDICATE)) {
   17136:	48 8b 57 18          	mov    0x18(%rdi),%rdx
   1713a:	f6 42 0a 20          	testb  $0x20,0xa(%rdx)
   1713e:	74 79                	je     171b9 <bt_gatt_indicate+0x168>
		data.handle = bt_gatt_attr_value_handle(data.attr);
   17140:	e8 fc f8 ff ff       	callq  16a41 <bt_gatt_attr_value_handle>
   17145:	66 89 44 24 08       	mov    %ax,0x8(%rsp)
	if (conn) {
   1714a:	48 85 ed             	test   %rbp,%rbp
   1714d:	0f b7 7c 24 08       	movzwl 0x8(%rsp),%edi
   17152:	74 13                	je     17167 <bt_gatt_indicate+0x116>
		return gatt_indicate(conn, data.handle, params);
   17154:	89 fe                	mov    %edi,%esi
		params->_ref = 1;
   17156:	c6 43 2a 01          	movb   $0x1,0x2a(%rbx)
		return gatt_indicate(conn, data.handle, params);
   1715a:	48 89 da             	mov    %rbx,%rdx
   1715d:	48 89 ef             	mov    %rbp,%rdi
   17160:	e8 34 ea ff ff       	callq  15b99 <gatt_indicate>
   17165:	eb 52                	jmp    171b9 <bt_gatt_indicate+0x168>
	data.err = -ENOTCONN;
   17167:	c7 44 24 0c 95 ff ff 	movl   $0xffffff95,0xc(%rsp)
   1716e:	ff 
	data.type = BT_GATT_CCC_INDICATE;
   1716f:	66 c7 44 24 10 02 00 	movw   $0x2,0x10(%rsp)
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
   17176:	48 8d 54 24 24       	lea    0x24(%rsp),%rdx
	data.ind_params = params;
   1717b:	48 89 5c 24 18       	mov    %rbx,0x18(%rsp)
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
   17180:	c6 44 24 24 00       	movb   $0x0,0x24(%rsp)
   17185:	48 83 ec 08          	sub    $0x8,%rsp
   17189:	66 c7 44 24 2e 02 29 	movw   $0x2902,0x2e(%rsp)
   17190:	48 8d 44 24 08       	lea    0x8(%rsp),%rax
   17195:	4c 8d 0d 48 f2 ff ff 	lea    -0xdb8(%rip),%r9        # 163e4 <notify_cb>
	params->_ref = 0;
   1719c:	c6 43 2a 00          	movb   $0x0,0x2a(%rbx)
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
   171a0:	41 b8 01 00 00 00    	mov    $0x1,%r8d
   171a6:	31 c9                	xor    %ecx,%ecx
   171a8:	50                   	push   %rax
   171a9:	be ff ff 00 00       	mov    $0xffff,%esi
   171ae:	e8 b2 f9 ff ff       	callq  16b65 <bt_gatt_foreach_attr_type>
   171b3:	58                   	pop    %rax
   171b4:	5a                   	pop    %rdx
	return data.err;
   171b5:	8b 44 24 0c          	mov    0xc(%rsp),%eax
}
   171b9:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
   171be:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   171c5:	00 00 
   171c7:	74 05                	je     171ce <bt_gatt_indicate+0x17d>
   171c9:	e8 72 d4 fe ff       	callq  4640 <__stack_chk_fail@plt>
   171ce:	48 83 c4 38          	add    $0x38,%rsp
   171d2:	5b                   	pop    %rbx
   171d3:	5d                   	pop    %rbp
   171d4:	c3                   	retq   

00000000000171d5 <sc_process>:
{
   171d5:	53                   	push   %rbx
	atomic_clear_bit(sc->flags, SC_RANGE_CHANGED);
   171d6:	48 8d 5f 40          	lea    0x40(%rdi),%rbx
{
   171da:	49 89 f8             	mov    %rdi,%r8
	atomic_clear_bit(sc->flags, SC_RANGE_CHANGED);
   171dd:	4c 8d 4f c8          	lea    -0x38(%rdi),%r9
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   171e1:	be fe ff ff ff       	mov    $0xfffffffe,%esi
{
   171e6:	48 83 ec 10          	sub    $0x10,%rsp
   171ea:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   171f1:	00 00 
   171f3:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   171f8:	31 c0                	xor    %eax,%eax
	sc_range[0] = sys_cpu_to_le16(sc->start);
   171fa:	8b 47 f8             	mov    -0x8(%rdi),%eax
   171fd:	66 89 44 24 04       	mov    %ax,0x4(%rsp)
	sc_range[1] = sys_cpu_to_le16(sc->end);
   17202:	66 8b 47 fa          	mov    -0x6(%rdi),%ax
   17206:	48 89 df             	mov    %rbx,%rdi
   17209:	66 89 44 24 06       	mov    %ax,0x6(%rsp)
   1720e:	e8 bd e3 ff ff       	callq  155d0 <atomic_and>
	sc->params.attr = &_1_gatt_svc.attrs[2];
   17213:	48 8d 05 a6 e5 21 00 	lea    0x21e5a6(%rip),%rax        # 2357c0 <attr__1_gatt_svc>
	if (bt_gatt_indicate(NULL, &sc->params)) {
   1721a:	31 ff                	xor    %edi,%edi
	sc->start = 0U;
   1721c:	66 41 c7 40 f8 00 00 	movw   $0x0,-0x8(%r8)
	sc->end = 0U;
   17223:	66 41 c7 40 fa 00 00 	movw   $0x0,-0x6(%r8)
	sc->params.len = sizeof(sc_range);
   1722a:	66 41 c7 40 f0 04 00 	movw   $0x4,-0x10(%r8)
	if (bt_gatt_indicate(NULL, &sc->params)) {
   17231:	4c 89 ce             	mov    %r9,%rsi
	sc->params.attr = &_1_gatt_svc.attrs[2];
   17234:	48 83 c0 50          	add    $0x50,%rax
   17238:	49 89 40 d0          	mov    %rax,-0x30(%r8)
	sc->params.func = sc_indicate_rsp;
   1723c:	48 8d 05 cb ec ff ff 	lea    -0x1335(%rip),%rax        # 15f0e <sc_indicate_rsp>
   17243:	49 89 40 d8          	mov    %rax,-0x28(%r8)
	sc->params.data = &sc_range[0];
   17247:	48 8d 44 24 04       	lea    0x4(%rsp),%rax
   1724c:	49 89 40 e8          	mov    %rax,-0x18(%r8)
	if (bt_gatt_indicate(NULL, &sc->params)) {
   17250:	e8 fc fd ff ff       	callq  17051 <bt_gatt_indicate>
   17255:	85 c0                	test   %eax,%eax
   17257:	75 0d                	jne    17266 <sc_process+0x91>
	atomic_set_bit(sc->flags, SC_INDICATE_PENDING);
   17259:	be 01 00 00 00       	mov    $0x1,%esi
   1725e:	48 89 df             	mov    %rbx,%rdi
   17261:	e8 c4 ea ff ff       	callq  15d2a <atomic_set_bit>
}
   17266:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   1726b:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   17272:	00 00 
   17274:	74 05                	je     1727b <sc_process+0xa6>
   17276:	e8 c5 d3 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1727b:	48 83 c4 10          	add    $0x10,%rsp
   1727f:	5b                   	pop    %rbx
   17280:	c3                   	retq   

0000000000017281 <bt_gatt_check_perm>:
	if ((mask & BT_GATT_PERM_READ) &&
   17281:	f6 c2 01             	test   $0x1,%dl
   17284:	8a 4e 22             	mov    0x22(%rsi),%cl
   17287:	74 0e                	je     17297 <bt_gatt_check_perm+0x16>
   17289:	f6 c1 15             	test   $0x15,%cl
		return BT_ATT_ERR_READ_NOT_PERMITTED;
   1728c:	b0 02                	mov    $0x2,%al
	if ((mask & BT_GATT_PERM_READ) &&
   1728e:	74 42                	je     172d2 <bt_gatt_check_perm+0x51>
	    (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {
   17290:	48 83 7e 08 00       	cmpq   $0x0,0x8(%rsi)
   17295:	74 3b                	je     172d2 <bt_gatt_check_perm+0x51>
	if ((mask & BT_GATT_PERM_WRITE) &&
   17297:	f6 c2 02             	test   $0x2,%dl
   1729a:	74 0e                	je     172aa <bt_gatt_check_perm+0x29>
   1729c:	f6 c1 2a             	test   $0x2a,%cl
		return BT_ATT_ERR_WRITE_NOT_PERMITTED;
   1729f:	b0 03                	mov    $0x3,%al
	if ((mask & BT_GATT_PERM_WRITE) &&
   172a1:	74 2f                	je     172d2 <bt_gatt_check_perm+0x51>
	    (!(attr->perm & BT_GATT_PERM_WRITE_MASK) || !attr->write)) {
   172a3:	48 83 7e 10 00       	cmpq   $0x0,0x10(%rsi)
   172a8:	74 28                	je     172d2 <bt_gatt_check_perm+0x51>
{
   172aa:	53                   	push   %rbx
	mask &= attr->perm;
   172ab:	88 cb                	mov    %cl,%bl
   172ad:	21 d3                	and    %edx,%ebx
	if (mask & BT_GATT_PERM_AUTHEN_MASK) {
   172af:	f6 c3 30             	test   $0x30,%bl
   172b2:	75 11                	jne    172c5 <bt_gatt_check_perm+0x44>
	if ((mask & BT_GATT_PERM_ENCRYPT_MASK)) {
   172b4:	88 d9                	mov    %bl,%cl
   172b6:	83 e1 0c             	and    $0xc,%ecx
		return BT_ATT_ERR_INSUFFICIENT_ENCRYPTION;
   172b9:	80 f9 01             	cmp    $0x1,%cl
   172bc:	19 c0                	sbb    %eax,%eax
   172be:	f7 d0                	not    %eax
   172c0:	83 e0 0f             	and    $0xf,%eax
   172c3:	eb 0b                	jmp    172d0 <bt_gatt_check_perm+0x4f>
		if (bt_conn_get_security(conn) < BT_SECURITY_L3) {
   172c5:	e8 9a 9f ff ff       	callq  11264 <bt_conn_get_security>
   172ca:	3c 02                	cmp    $0x2,%al
   172cc:	77 e6                	ja     172b4 <bt_gatt_check_perm+0x33>
			return BT_ATT_ERR_AUTHENTICATION;
   172ce:	b0 05                	mov    $0x5,%al
}
   172d0:	5b                   	pop    %rbx
   172d1:	c3                   	retq   
   172d2:	c3                   	retq   

00000000000172d3 <update_ccc>:
{
   172d3:	41 55                	push   %r13
   172d5:	41 54                	push   %r12
   172d7:	55                   	push   %rbp
   172d8:	53                   	push   %rbx
   172d9:	48 83 ec 18          	sub    $0x18,%rsp
   172dd:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   172e4:	00 00 
   172e6:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   172eb:	31 c0                	xor    %eax,%eax
	if (attr->write != bt_gatt_attr_write_ccc) {
   172ed:	48 8d 05 07 e0 ff ff 	lea    -0x1ff9(%rip),%rax        # 152fb <bt_gatt_attr_write_ccc>
   172f4:	48 39 47 10          	cmp    %rax,0x10(%rdi)
   172f8:	0f 85 45 01 00 00    	jne    17443 <update_ccc+0x170>
   172fe:	48 8d 1d bb 30 22 00 	lea    0x2230bb(%rip),%rbx        # 23a3c0 <log_const_bt_gatt>
   17305:	48 2b 1d 44 ec 21 00 	sub    0x21ec44(%rip),%rbx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
   1730c:	49 89 fd             	mov    %rdi,%r13
	ccc = attr->user_data;
   1730f:	4c 8b 67 18          	mov    0x18(%rdi),%r12
	struct bt_conn *conn = data->conn;
   17313:	48 8b 2a             	mov    (%rdx),%rbp
   17316:	48 c1 eb 04          	shr    $0x4,%rbx
				BT_WARN("CCC %p not writable", attr);
   1731a:	66 81 e3 ff 03       	and    $0x3ff,%bx
		if (!cfg->value ||
   1731f:	66 41 83 7c 24 08 00 	cmpw   $0x0,0x8(%r12)
   17326:	0f 84 17 01 00 00    	je     17443 <update_ccc+0x170>
		    !bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
   1732c:	41 0f b6 34 24       	movzbl (%r12),%esi
   17331:	49 8d 54 24 01       	lea    0x1(%r12),%rdx
   17336:	48 89 ef             	mov    %rbp,%rdi
   17339:	e8 ab a3 ff ff       	callq  116e9 <bt_conn_is_peer_addr_le>
		if (!cfg->value ||
   1733e:	84 c0                	test   %al,%al
   17340:	0f 84 fd 00 00 00    	je     17443 <update_ccc+0x170>
		err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_WRITE_MASK);
   17346:	ba 2a 00 00 00       	mov    $0x2a,%edx
   1734b:	4c 89 ee             	mov    %r13,%rsi
   1734e:	48 89 ef             	mov    %rbp,%rdi
   17351:	e8 2b ff ff ff       	callq  17281 <bt_gatt_check_perm>
			if (err == BT_ATT_ERR_WRITE_NOT_PERMITTED) {
   17356:	3c 03                	cmp    $0x3,%al
   17358:	75 1c                	jne    17376 <update_ccc+0xa3>
				BT_WARN("CCC %p not writable", attr);
   1735a:	c1 e3 06             	shl    $0x6,%ebx
   1735d:	48 8d 3d 53 bd 01 00 	lea    0x1bd53(%rip),%rdi        # 330b7 <__func__.5785+0x244f>
   17364:	4c 89 ee             	mov    %r13,%rsi
   17367:	89 da                	mov    %ebx,%edx
   17369:	83 ca 02             	or     $0x2,%edx
   1736c:	e8 84 ff fe ff       	callq  72f5 <log_1>
   17371:	e9 cd 00 00 00       	jmpq   17443 <update_ccc+0x170>
		gatt_ccc_changed(attr, ccc);
   17376:	4c 89 e6             	mov    %r12,%rsi
   17379:	4c 89 ef             	mov    %r13,%rdi
   1737c:	e8 b7 db ff ff       	callq  14f38 <gatt_ccc_changed>
		if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) &&
   17381:	48 8d 05 f8 f4 21 00 	lea    0x21f4f8(%rip),%rax        # 236880 <sc_ccc>
   17388:	49 39 c4             	cmp    %rax,%r12
   1738b:	0f 85 b2 00 00 00    	jne    17443 <update_ccc+0x170>
	cfg = find_sc_cfg(conn->id, &conn->le.dst);
   17391:	0f b6 7d 08          	movzbl 0x8(%rbp),%edi
   17395:	48 8d b5 d8 00 00 00 	lea    0xd8(%rbp),%rsi
   1739c:	e8 bc de ff ff       	callq  1525d <find_sc_cfg>
	if (!cfg) {
   173a1:	48 85 c0             	test   %rax,%rax
	cfg = find_sc_cfg(conn->id, &conn->le.dst);
   173a4:	49 89 c4             	mov    %rax,%r12
	if (!cfg) {
   173a7:	0f 84 96 00 00 00    	je     17443 <update_ccc+0x170>
	if (!(cfg->data.start || cfg->data.end)) {
   173ad:	66 8b 50 08          	mov    0x8(%rax),%dx
   173b1:	66 8b 40 0a          	mov    0xa(%rax),%ax
   173b5:	66 85 d2             	test   %dx,%dx
   173b8:	75 09                	jne    173c3 <update_ccc+0xf0>
   173ba:	66 85 c0             	test   %ax,%ax
   173bd:	0f 84 80 00 00 00    	je     17443 <update_ccc+0x170>
	index = bt_conn_index(conn);
   173c3:	48 89 ef             	mov    %rbp,%rdi
	sc_range[0] = sys_cpu_to_le16(cfg->data.start);
   173c6:	66 89 54 24 04       	mov    %dx,0x4(%rsp)
	sc_range[1] = sys_cpu_to_le16(cfg->data.end);
   173cb:	66 89 44 24 06       	mov    %ax,0x6(%rsp)
	index = bt_conn_index(conn);
   173d0:	e8 c6 ab ff ff       	callq  11f9b <bt_conn_index>
	sc_restore_params[index].attr = &_1_gatt_svc.attrs[2];
   173d5:	0f b6 d0             	movzbl %al,%edx
   173d8:	48 8d 35 e1 e3 21 00 	lea    0x21e3e1(%rip),%rsi        # 2357c0 <attr__1_gatt_svc>
   173df:	48 8d 0d 7a 00 24 00 	lea    0x24007a(%rip),%rcx        # 257460 <sc_restore_params>
   173e6:	48 6b d2 30          	imul   $0x30,%rdx,%rdx
	sc_restore_params[index].func = sc_restore_rsp;
   173ea:	48 8d 3d 41 ea ff ff 	lea    -0x15bf(%rip),%rdi        # 15e32 <sc_restore_rsp>
	sc_restore_params[index].attr = &_1_gatt_svc.attrs[2];
   173f1:	48 83 c6 50          	add    $0x50,%rsi
   173f5:	48 01 ca             	add    %rcx,%rdx
   173f8:	48 89 72 08          	mov    %rsi,0x8(%rdx)
	sc_restore_params[index].data = &sc_range[0];
   173fc:	48 8d 74 24 04       	lea    0x4(%rsp),%rsi
	sc_restore_params[index].func = sc_restore_rsp;
   17401:	48 89 7a 10          	mov    %rdi,0x10(%rdx)
	sc_restore_params[index].len = sizeof(sc_range);
   17405:	66 c7 42 28 04 00    	movw   $0x4,0x28(%rdx)
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
   1740b:	48 89 ef             	mov    %rbp,%rdi
	sc_restore_params[index].data = &sc_range[0];
   1740e:	48 89 72 20          	mov    %rsi,0x20(%rdx)
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
   17412:	48 89 d6             	mov    %rdx,%rsi
   17415:	e8 37 fc ff ff       	callq  17051 <bt_gatt_indicate>
   1741a:	85 c0                	test   %eax,%eax
   1741c:	74 14                	je     17432 <update_ccc+0x15f>
		BT_ERR("SC restore indication failed");
   1741e:	c1 e3 06             	shl    $0x6,%ebx
   17421:	48 8d 3d a3 bc 01 00 	lea    0x1bca3(%rip),%rdi        # 330cb <__func__.5785+0x2463>
   17428:	89 de                	mov    %ebx,%esi
   1742a:	83 ce 01             	or     $0x1,%esi
   1742d:	e8 92 fe fe ff       	callq  72c4 <log_0>
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
   17432:	41 c7 44 24 08 00 00 	movl   $0x0,0x8(%r12)
   17439:	00 00 
		sc_store(cfg);
   1743b:	4c 89 e7             	mov    %r12,%rdi
   1743e:	e8 c6 e0 ff ff       	callq  15509 <sc_store>
}
   17443:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
   17448:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1744f:	00 00 
   17451:	b0 01                	mov    $0x1,%al
   17453:	74 05                	je     1745a <update_ccc+0x187>
   17455:	e8 e6 d1 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1745a:	48 83 c4 18          	add    $0x18,%rsp
   1745e:	5b                   	pop    %rbx
   1745f:	5d                   	pop    %rbp
   17460:	41 5c                	pop    %r12
   17462:	41 5d                	pop    %r13
   17464:	c3                   	retq   

0000000000017465 <bt_gatt_discover>:
{
   17465:	41 55                	push   %r13
   17467:	41 54                	push   %r12
   17469:	55                   	push   %rbp
   1746a:	53                   	push   %rbx
   1746b:	48 83 ec 28          	sub    $0x28,%rsp
   1746f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   17476:	00 00 
   17478:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1747d:	31 c0                	xor    %eax,%eax
	if (conn->state != BT_CONN_CONNECTED) {
   1747f:	80 7f 0a 07          	cmpb   $0x7,0xa(%rdi)
		return -ENOTCONN;
   17483:	b8 95 ff ff ff       	mov    $0xffffff95,%eax
	if (conn->state != BT_CONN_CONNECTED) {
   17488:	0f 85 b0 02 00 00    	jne    1773e <bt_gatt_discover+0x2d9>
   1748e:	48 89 f3             	mov    %rsi,%rbx
	switch (params->type) {
   17491:	0f b6 76 18          	movzbl 0x18(%rsi),%esi
   17495:	40 80 fe 05          	cmp    $0x5,%sil
   17499:	0f 87 76 02 00 00    	ja     17715 <bt_gatt_discover+0x2b0>
   1749f:	48 8d 15 f6 98 01 00 	lea    0x198f6(%rip),%rdx        # 30d9c <__func__.5785+0x134>
   174a6:	48 89 fd             	mov    %rdi,%rbp
   174a9:	48 63 04 b2          	movslq (%rdx,%rsi,4),%rax
   174ad:	48 01 d0             	add    %rdx,%rax
   174b0:	ff e0                	jmpq   *%rax
		if (params->uuid) {
   174b2:	48 83 3b 00          	cmpq   $0x0,(%rbx)
   174b6:	0f 84 c1 00 00 00    	je     1757d <bt_gatt_discover+0x118>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_TYPE_REQ, sizeof(*req));
   174bc:	ba 06 00 00 00       	mov    $0x6,%edx
   174c1:	be 06 00 00 00       	mov    $0x6,%esi
   174c6:	e8 13 c8 ff ff       	callq  13cde <bt_att_create_pdu>
	if (!buf) {
   174cb:	48 85 c0             	test   %rax,%rax
	buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_TYPE_REQ, sizeof(*req));
   174ce:	49 89 c4             	mov    %rax,%r12
	if (!buf) {
   174d1:	75 0a                	jne    174dd <bt_gatt_discover+0x78>
		return -ENOMEM;
   174d3:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
   174d8:	e9 61 02 00 00       	jmpq   1773e <bt_gatt_discover+0x2d9>
   174dd:	4c 8d 68 10          	lea    0x10(%rax),%r13
   174e1:	be 06 00 00 00       	mov    $0x6,%esi
   174e6:	4c 89 ef             	mov    %r13,%rdi
   174e9:	e8 9b 1b 00 00       	callq  19089 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
   174ee:	8b 53 10             	mov    0x10(%rbx),%edx
   174f1:	66 89 10             	mov    %dx,(%rax)
	req->end_handle = sys_cpu_to_le16(params->end_handle);
   174f4:	66 8b 53 16          	mov    0x16(%rbx),%dx
   174f8:	66 89 50 02          	mov    %dx,0x2(%rax)
		uuid_val = BT_UUID_GATT_SECONDARY_VAL;
   174fc:	80 7b 18 01          	cmpb   $0x1,0x18(%rbx)
   17500:	19 d2                	sbb    %edx,%edx
   17502:	66 81 c2 01 28       	add    $0x2801,%dx
	req->type = sys_cpu_to_le16(uuid_val);
   17507:	66 89 50 04          	mov    %dx,0x4(%rax)
	switch (params->uuid->type) {
   1750b:	48 8b 03             	mov    (%rbx),%rax
   1750e:	0f b6 30             	movzbl (%rax),%esi
   17511:	40 84 f6             	test   %sil,%sil
   17514:	74 19                	je     1752f <bt_gatt_discover+0xca>
   17516:	40 80 fe 02          	cmp    $0x2,%sil
   1751a:	75 21                	jne    1753d <bt_gatt_discover+0xd8>
		net_buf_add_mem(buf, BT_UUID_128(params->uuid)->val, 16);
   1751c:	48 8d 70 01          	lea    0x1(%rax),%rsi
	return net_buf_simple_add_mem(&buf->b, mem, len);
   17520:	ba 10 00 00 00       	mov    $0x10,%edx
   17525:	4c 89 ef             	mov    %r13,%rdi
   17528:	e8 6d 1b 00 00       	callq  1909a <net_buf_simple_add_mem>
   1752d:	eb 3f                	jmp    1756e <bt_gatt_discover+0x109>
		net_buf_add_le16(buf, BT_UUID_16(params->uuid)->val);
   1752f:	0f b7 70 02          	movzwl 0x2(%rax),%esi
	net_buf_simple_add_le16(&buf->b, val);
   17533:	4c 89 ef             	mov    %r13,%rdi
   17536:	e8 93 1b 00 00       	callq  190ce <net_buf_simple_add_le16>
   1753b:	eb 31                	jmp    1756e <bt_gatt_discover+0x109>
   1753d:	48 8d 15 7c 2e 22 00 	lea    0x222e7c(%rip),%rdx        # 23a3c0 <log_const_bt_gatt>
   17544:	48 2b 15 05 ea 21 00 	sub    0x21ea05(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Unknown UUID type %u", params->uuid->type);
   1754b:	48 8d 3d 96 bb 01 00 	lea    0x1bb96(%rip),%rdi        # 330e8 <__func__.5785+0x2480>
   17552:	48 c1 ea 04          	shr    $0x4,%rdx
   17556:	c1 e2 06             	shl    $0x6,%edx
   17559:	83 ca 01             	or     $0x1,%edx
   1755c:	e8 94 fd fe ff       	callq  72f5 <log_1>
		net_buf_unref(buf);
   17561:	4c 89 e7             	mov    %r12,%rdi
   17564:	e8 31 1a 00 00       	callq  18f9a <net_buf_unref>
   17569:	e9 cb 01 00 00       	jmpq   17739 <bt_gatt_discover+0x2d4>
	return gatt_send(conn, buf, gatt_find_type_rsp, params, NULL);
   1756e:	48 89 d9             	mov    %rbx,%rcx
   17571:	48 8d 15 3c 02 00 00 	lea    0x23c(%rip),%rdx        # 177b4 <gatt_find_type_rsp>
   17578:	e9 8b 01 00 00       	jmpq   17708 <bt_gatt_discover+0x2a3>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_GROUP_REQ, sizeof(*req));
   1757d:	ba 04 00 00 00       	mov    $0x4,%edx
   17582:	be 10 00 00 00       	mov    $0x10,%esi
   17587:	e8 52 c7 ff ff       	callq  13cde <bt_att_create_pdu>
	if (!buf) {
   1758c:	48 85 c0             	test   %rax,%rax
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_GROUP_REQ, sizeof(*req));
   1758f:	49 89 c4             	mov    %rax,%r12
	if (!buf) {
   17592:	0f 84 3b ff ff ff    	je     174d3 <bt_gatt_discover+0x6e>
	return net_buf_simple_add(&buf->b, len);
   17598:	4c 8d 68 10          	lea    0x10(%rax),%r13
   1759c:	be 04 00 00 00       	mov    $0x4,%esi
   175a1:	4c 89 ef             	mov    %r13,%rdi
   175a4:	e8 e0 1a 00 00       	callq  19089 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
   175a9:	8b 53 10             	mov    0x10(%rbx),%edx
	net_buf_simple_add_le16(&buf->b, val);
   175ac:	be 00 28 00 00       	mov    $0x2800,%esi
   175b1:	66 89 10             	mov    %dx,(%rax)
	req->end_handle = sys_cpu_to_le16(params->end_handle);
   175b4:	66 8b 53 16          	mov    0x16(%rbx),%dx
   175b8:	66 89 50 02          	mov    %dx,0x2(%rax)
	if (params->type == BT_GATT_DISCOVER_PRIMARY) {
   175bc:	80 7b 18 00          	cmpb   $0x0,0x18(%rbx)
   175c0:	74 05                	je     175c7 <bt_gatt_discover+0x162>
   175c2:	be 01 28 00 00       	mov    $0x2801,%esi
   175c7:	4c 89 ef             	mov    %r13,%rdi
   175ca:	e8 ff 1a 00 00       	callq  190ce <net_buf_simple_add_le16>
	return gatt_send(conn, buf, gatt_read_group_rsp, params, NULL);
   175cf:	48 89 d9             	mov    %rbx,%rcx
   175d2:	48 8d 15 ef 02 00 00 	lea    0x2ef(%rip),%rdx        # 178c8 <gatt_read_group_rsp>
   175d9:	e9 2a 01 00 00       	jmpq   17708 <bt_gatt_discover+0x2a3>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_REQ, sizeof(*req));
   175de:	ba 04 00 00 00       	mov    $0x4,%edx
   175e3:	be 08 00 00 00       	mov    $0x8,%esi
   175e8:	e8 f1 c6 ff ff       	callq  13cde <bt_att_create_pdu>
	if (!buf) {
   175ed:	48 85 c0             	test   %rax,%rax
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_REQ, sizeof(*req));
   175f0:	49 89 c4             	mov    %rax,%r12
	if (!buf) {
   175f3:	0f 84 da fe ff ff    	je     174d3 <bt_gatt_discover+0x6e>
	return net_buf_simple_add(&buf->b, len);
   175f9:	4c 8d 68 10          	lea    0x10(%rax),%r13
   175fd:	be 04 00 00 00       	mov    $0x4,%esi
   17602:	4c 89 ef             	mov    %r13,%rdi
   17605:	e8 7f 1a 00 00       	callq  19089 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
   1760a:	8b 53 10             	mov    0x10(%rbx),%edx
	net_buf_simple_add_le16(&buf->b, val);
   1760d:	be 02 28 00 00       	mov    $0x2802,%esi
   17612:	66 89 10             	mov    %dx,(%rax)
	req->end_handle = sys_cpu_to_le16(params->end_handle);
   17615:	66 8b 53 16          	mov    0x16(%rbx),%dx
   17619:	66 89 50 02          	mov    %dx,0x2(%rax)
	if (params->type == BT_GATT_DISCOVER_INCLUDE) {
   1761d:	80 7b 18 02          	cmpb   $0x2,0x18(%rbx)
   17621:	74 05                	je     17628 <bt_gatt_discover+0x1c3>
   17623:	be 03 28 00 00       	mov    $0x2803,%esi
   17628:	4c 89 ef             	mov    %r13,%rdi
   1762b:	e8 9e 1a 00 00       	callq  190ce <net_buf_simple_add_le16>
	return gatt_send(conn, buf, gatt_read_type_rsp, params, NULL);
   17630:	48 89 d9             	mov    %rbx,%rcx
   17633:	48 8d 15 2f 04 00 00 	lea    0x42f(%rip),%rdx        # 17a69 <gatt_read_type_rsp>
   1763a:	e9 c9 00 00 00       	jmpq   17708 <bt_gatt_discover+0x2a3>
		if (params->uuid &&
   1763f:	48 8b 3b             	mov    (%rbx),%rdi
   17642:	48 85 ff             	test   %rdi,%rdi
   17645:	74 7d                	je     176c4 <bt_gatt_discover+0x25f>
		    (!bt_uuid_cmp(params->uuid, BT_UUID_GATT_PRIMARY) ||
   17647:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
   1764c:	c6 44 24 08 00       	movb   $0x0,0x8(%rsp)
   17651:	66 c7 44 24 0a 00 28 	movw   $0x2800,0xa(%rsp)
   17658:	e8 f0 5e ff ff       	callq  d54d <bt_uuid_cmp>
		if (params->uuid &&
   1765d:	85 c0                	test   %eax,%eax
   1765f:	0f 84 d4 00 00 00    	je     17739 <bt_gatt_discover+0x2d4>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_SECONDARY) ||
   17665:	48 8b 3b             	mov    (%rbx),%rdi
   17668:	48 8d 74 24 0c       	lea    0xc(%rsp),%rsi
   1766d:	c6 44 24 0c 00       	movb   $0x0,0xc(%rsp)
   17672:	66 c7 44 24 0e 01 28 	movw   $0x2801,0xe(%rsp)
   17679:	e8 cf 5e ff ff       	callq  d54d <bt_uuid_cmp>
		    (!bt_uuid_cmp(params->uuid, BT_UUID_GATT_PRIMARY) ||
   1767e:	85 c0                	test   %eax,%eax
   17680:	0f 84 b3 00 00 00    	je     17739 <bt_gatt_discover+0x2d4>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_INCLUDE) ||
   17686:	48 8b 3b             	mov    (%rbx),%rdi
   17689:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
   1768e:	c6 44 24 10 00       	movb   $0x0,0x10(%rsp)
   17693:	66 c7 44 24 12 02 28 	movw   $0x2802,0x12(%rsp)
   1769a:	e8 ae 5e ff ff       	callq  d54d <bt_uuid_cmp>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_SECONDARY) ||
   1769f:	85 c0                	test   %eax,%eax
   176a1:	0f 84 92 00 00 00    	je     17739 <bt_gatt_discover+0x2d4>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_CHRC))) {
   176a7:	48 8b 3b             	mov    (%rbx),%rdi
   176aa:	48 8d 74 24 14       	lea    0x14(%rsp),%rsi
   176af:	c6 44 24 14 00       	movb   $0x0,0x14(%rsp)
   176b4:	66 c7 44 24 16 03 28 	movw   $0x2803,0x16(%rsp)
   176bb:	e8 8d 5e ff ff       	callq  d54d <bt_uuid_cmp>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_INCLUDE) ||
   176c0:	85 c0                	test   %eax,%eax
   176c2:	74 75                	je     17739 <bt_gatt_discover+0x2d4>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_INFO_REQ, sizeof(*req));
   176c4:	ba 04 00 00 00       	mov    $0x4,%edx
   176c9:	be 04 00 00 00       	mov    $0x4,%esi
   176ce:	48 89 ef             	mov    %rbp,%rdi
   176d1:	e8 08 c6 ff ff       	callq  13cde <bt_att_create_pdu>
	if (!buf) {
   176d6:	48 85 c0             	test   %rax,%rax
	buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_INFO_REQ, sizeof(*req));
   176d9:	49 89 c4             	mov    %rax,%r12
	if (!buf) {
   176dc:	0f 84 f1 fd ff ff    	je     174d3 <bt_gatt_discover+0x6e>
	return net_buf_simple_add(&buf->b, len);
   176e2:	48 8d 78 10          	lea    0x10(%rax),%rdi
   176e6:	be 04 00 00 00       	mov    $0x4,%esi
   176eb:	e8 99 19 00 00       	callq  19089 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
   176f0:	8b 53 10             	mov    0x10(%rbx),%edx
	return gatt_send(conn, buf, gatt_find_info_rsp, params, NULL);
   176f3:	48 89 d9             	mov    %rbx,%rcx
	req->start_handle = sys_cpu_to_le16(params->start_handle);
   176f6:	66 89 10             	mov    %dx,(%rax)
	req->end_handle = sys_cpu_to_le16(params->end_handle);
   176f9:	66 8b 53 16          	mov    0x16(%rbx),%dx
   176fd:	66 89 50 02          	mov    %dx,0x2(%rax)
	return gatt_send(conn, buf, gatt_find_info_rsp, params, NULL);
   17701:	48 8d 15 82 07 00 00 	lea    0x782(%rip),%rdx        # 17e8a <gatt_find_info_rsp>
   17708:	4c 89 e6             	mov    %r12,%rsi
   1770b:	48 89 ef             	mov    %rbp,%rdi
   1770e:	e8 cd e3 ff ff       	callq  15ae0 <gatt_send.constprop.35>
   17713:	eb 29                	jmp    1773e <bt_gatt_discover+0x2d9>
   17715:	48 8d 15 a4 2c 22 00 	lea    0x222ca4(%rip),%rdx        # 23a3c0 <log_const_bt_gatt>
   1771c:	48 2b 15 2d e8 21 00 	sub    0x21e82d(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Invalid discovery type: %u", params->type);
   17723:	48 8d 3d d3 b9 01 00 	lea    0x1b9d3(%rip),%rdi        # 330fd <__func__.5785+0x2495>
   1772a:	48 c1 ea 04          	shr    $0x4,%rdx
   1772e:	c1 e2 06             	shl    $0x6,%edx
   17731:	83 ca 01             	or     $0x1,%edx
   17734:	e8 bc fb fe ff       	callq  72f5 <log_1>
	return -EINVAL;
   17739:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
   1773e:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   17743:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1774a:	00 00 
   1774c:	74 05                	je     17753 <bt_gatt_discover+0x2ee>
   1774e:	e8 ed ce fe ff       	callq  4640 <__stack_chk_fail@plt>
   17753:	48 83 c4 28          	add    $0x28,%rsp
   17757:	5b                   	pop    %rbx
   17758:	5d                   	pop    %rbp
   17759:	41 5c                	pop    %r12
   1775b:	41 5d                	pop    %r13
   1775d:	c3                   	retq   

000000000001775e <gatt_discover_next>:
{
   1775e:	53                   	push   %rbx
   1775f:	48 89 fb             	mov    %rdi,%rbx
   17762:	48 83 ec 10          	sub    $0x10,%rsp
	if (!last_handle)
   17766:	66 85 f6             	test   %si,%si
   17769:	75 1b                	jne    17786 <gatt_discover_next+0x28>
	if (!bt_gatt_discover(conn, params)) {
   1776b:	48 89 d6             	mov    %rdx,%rsi
   1776e:	48 89 df             	mov    %rbx,%rdi
   17771:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
   17776:	e8 ea fc ff ff       	callq  17465 <bt_gatt_discover>
   1777b:	85 c0                	test   %eax,%eax
   1777d:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   17782:	75 0c                	jne    17790 <gatt_discover_next+0x32>
   17784:	eb 28                	jmp    177ae <gatt_discover_next+0x50>
	if (params->start_handle < UINT16_MAX) {
   17786:	66 83 fe ff          	cmp    $0xffff,%si
   1778a:	75 14                	jne    177a0 <gatt_discover_next+0x42>
	params->start_handle = last_handle;
   1778c:	66 89 72 10          	mov    %si,0x10(%rdx)
	params->func(conn, NULL, params);
   17790:	48 8b 42 08          	mov    0x8(%rdx),%rax
}
   17794:	48 83 c4 10          	add    $0x10,%rsp
	params->func(conn, NULL, params);
   17798:	48 89 df             	mov    %rbx,%rdi
}
   1779b:	5b                   	pop    %rbx
	params->func(conn, NULL, params);
   1779c:	31 f6                	xor    %esi,%esi
   1779e:	ff e0                	jmpq   *%rax
		params->start_handle++;
   177a0:	ff c6                	inc    %esi
	if (params->start_handle > params->end_handle) {
   177a2:	66 3b 72 16          	cmp    0x16(%rdx),%si
		params->start_handle++;
   177a6:	66 89 72 10          	mov    %si,0x10(%rdx)
	if (params->start_handle > params->end_handle) {
   177aa:	77 e4                	ja     17790 <gatt_discover_next+0x32>
   177ac:	eb bd                	jmp    1776b <gatt_discover_next+0xd>
}
   177ae:	48 83 c4 10          	add    $0x10,%rsp
   177b2:	5b                   	pop    %rbx
   177b3:	c3                   	retq   

00000000000177b4 <gatt_find_type_rsp>:
{
   177b4:	41 57                	push   %r15
   177b6:	41 56                	push   %r14
   177b8:	41 55                	push   %r13
   177ba:	41 54                	push   %r12
   177bc:	49 89 fd             	mov    %rdi,%r13
   177bf:	55                   	push   %rbp
   177c0:	53                   	push   %rbx
   177c1:	48 83 ec 68          	sub    $0x68,%rsp
   177c5:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   177cc:	00 00 
   177ce:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
   177d3:	31 c0                	xor    %eax,%eax
	if (err || (length % sizeof(struct bt_att_handle_group) != 0)) {
   177d5:	40 84 f6             	test   %sil,%sil
   177d8:	0f 85 ba 00 00 00    	jne    17898 <gatt_find_type_rsp+0xe4>
   177de:	f6 c1 03             	test   $0x3,%cl
   177e1:	0f 85 b1 00 00 00    	jne    17898 <gatt_find_type_rsp+0xe4>
	count = length / sizeof(struct bt_att_handle_group);
   177e7:	66 c1 e9 02          	shr    $0x2,%cx
		attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(&uuid_svc.uuid, 0,
   177eb:	4c 8d 7c 24 1c       	lea    0x1c(%rsp),%r15
   177f0:	49 89 d6             	mov    %rdx,%r14
	count = length / sizeof(struct bt_att_handle_group);
   177f3:	41 88 cc             	mov    %cl,%r12b
   177f6:	31 ed                	xor    %ebp,%ebp
	uint16_t end_handle = 0U, start_handle;
   177f8:	31 db                	xor    %ebx,%ebx
	for (uint8_t i = 0U; i < count; i++) {
   177fa:	41 38 ec             	cmp    %bpl,%r12b
   177fd:	0f 86 85 00 00 00    	jbe    17888 <gatt_find_type_rsp+0xd4>
		if (params->type == BT_GATT_DISCOVER_PRIMARY) {
   17803:	41 80 78 18 00       	cmpb   $0x0,0x18(%r8)
		start_handle = sys_le16_to_cpu(rsp[i].start_handle);
   17808:	66 41 8b 04 ae       	mov    (%r14,%rbp,4),%ax
		end_handle = sys_le16_to_cpu(rsp[i].end_handle);
   1780d:	66 41 8b 5c ae 02    	mov    0x2(%r14,%rbp,4),%bx
		uuid_svc.uuid.type = BT_UUID_TYPE_16;
   17813:	c6 44 24 1c 00       	movb   $0x0,0x1c(%rsp)
		if (params->type == BT_GATT_DISCOVER_PRIMARY) {
   17818:	75 09                	jne    17823 <gatt_find_type_rsp+0x6f>
			uuid_svc.val = BT_UUID_GATT_PRIMARY_VAL;
   1781a:	66 c7 44 24 1e 00 28 	movw   $0x2800,0x1e(%rsp)
   17821:	eb 07                	jmp    1782a <gatt_find_type_rsp+0x76>
			uuid_svc.val = BT_UUID_GATT_SECONDARY_VAL;
   17823:	66 c7 44 24 1e 01 28 	movw   $0x2801,0x1e(%rsp)
		value.uuid = params->uuid;
   1782a:	49 8b 10             	mov    (%r8),%rdx
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   1782d:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
   17832:	48 8d 74 24 30       	lea    0x30(%rsp),%rsi
		value.end_handle = end_handle;
   17837:	66 89 5c 24 28       	mov    %bx,0x28(%rsp)
		attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(&uuid_svc.uuid, 0,
   1783c:	4c 89 7c 24 30       	mov    %r15,0x30(%rsp)
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   17841:	4c 89 ef             	mov    %r13,%rdi
		attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(&uuid_svc.uuid, 0,
   17844:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
   1784b:	00 00 
   1784d:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
   17854:	00 00 
   17856:	48 ff c5             	inc    %rbp
		value.uuid = params->uuid;
   17859:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
		attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(&uuid_svc.uuid, 0,
   1785e:	48 8d 54 24 20       	lea    0x20(%rsp),%rdx
   17863:	c6 44 24 52 00       	movb   $0x0,0x52(%rsp)
		attr.handle = start_handle;
   17868:	66 89 44 24 50       	mov    %ax,0x50(%rsp)
		attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(&uuid_svc.uuid, 0,
   1786d:	48 89 54 24 48       	mov    %rdx,0x48(%rsp)
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   17872:	4c 89 c2             	mov    %r8,%rdx
   17875:	41 ff 50 08          	callq  *0x8(%r8)
   17879:	84 c0                	test   %al,%al
   1787b:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
   17880:	0f 85 74 ff ff ff    	jne    177fa <gatt_find_type_rsp+0x46>
   17886:	eb 1c                	jmp    178a4 <gatt_find_type_rsp+0xf0>
	gatt_discover_next(conn, end_handle, params);
   17888:	0f b7 f3             	movzwl %bx,%esi
   1788b:	4c 89 c2             	mov    %r8,%rdx
   1788e:	4c 89 ef             	mov    %r13,%rdi
   17891:	e8 c8 fe ff ff       	callq  1775e <gatt_discover_next>
   17896:	eb 0c                	jmp    178a4 <gatt_find_type_rsp+0xf0>
	params->func(conn, NULL, params);
   17898:	4c 89 c2             	mov    %r8,%rdx
   1789b:	31 f6                	xor    %esi,%esi
   1789d:	4c 89 ef             	mov    %r13,%rdi
   178a0:	41 ff 50 08          	callq  *0x8(%r8)
}
   178a4:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
   178a9:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   178b0:	00 00 
   178b2:	74 05                	je     178b9 <gatt_find_type_rsp+0x105>
   178b4:	e8 87 cd fe ff       	callq  4640 <__stack_chk_fail@plt>
   178b9:	48 83 c4 68          	add    $0x68,%rsp
   178bd:	5b                   	pop    %rbx
   178be:	5d                   	pop    %rbp
   178bf:	41 5c                	pop    %r12
   178c1:	41 5d                	pop    %r13
   178c3:	41 5e                	pop    %r14
   178c5:	41 5f                	pop    %r15
   178c7:	c3                   	retq   

00000000000178c8 <gatt_read_group_rsp>:
{
   178c8:	41 57                	push   %r15
   178ca:	41 56                	push   %r14
   178cc:	41 55                	push   %r13
   178ce:	41 54                	push   %r12
   178d0:	4d 89 c4             	mov    %r8,%r12
   178d3:	55                   	push   %rbp
   178d4:	53                   	push   %rbx
   178d5:	48 89 fb             	mov    %rdi,%rbx
   178d8:	48 83 ec 78          	sub    $0x78,%rsp
   178dc:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   178e3:	00 00 
   178e5:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
   178ea:	31 c0                	xor    %eax,%eax
	if (err) {
   178ec:	40 84 f6             	test   %sil,%sil
   178ef:	0f 85 33 01 00 00    	jne    17a28 <gatt_read_group_rsp+0x160>
	switch (rsp->len) {
   178f5:	0f b6 32             	movzbl (%rdx),%esi
   178f8:	49 89 d7             	mov    %rdx,%r15
   178fb:	40 80 fe 06          	cmp    $0x6,%sil
   178ff:	74 0d                	je     1790e <gatt_read_group_rsp+0x46>
   17901:	40 80 fe 14          	cmp    $0x14,%sil
   17905:	75 0e                	jne    17915 <gatt_read_group_rsp+0x4d>
		u.uuid.type = BT_UUID_TYPE_128;
   17907:	c6 44 24 56 02       	movb   $0x2,0x56(%rsp)
   1790c:	eb 30                	jmp    1793e <gatt_read_group_rsp+0x76>
		u.uuid.type = BT_UUID_TYPE_16;
   1790e:	c6 44 24 56 00       	movb   $0x0,0x56(%rsp)
   17913:	eb 29                	jmp    1793e <gatt_read_group_rsp+0x76>
   17915:	48 8d 15 a4 2a 22 00 	lea    0x222aa4(%rip),%rdx        # 23a3c0 <log_const_bt_gatt>
   1791c:	48 2b 15 2d e6 21 00 	sub    0x21e62d(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Invalid data len %u", rsp->len);
   17923:	48 8d 3d ee b7 01 00 	lea    0x1b7ee(%rip),%rdi        # 33118 <__func__.5785+0x24b0>
   1792a:	48 c1 ea 04          	shr    $0x4,%rdx
   1792e:	c1 e2 06             	shl    $0x6,%edx
   17931:	83 ca 01             	or     $0x1,%edx
   17934:	e8 bc f9 fe ff       	callq  72f5 <log_1>
   17939:	e9 ea 00 00 00       	jmpq   17a28 <gatt_read_group_rsp+0x160>
   1793e:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
	for (length--, pdu = rsp->data; length >= rsp->len;
   17943:	44 8d 69 ff          	lea    -0x1(%rcx),%r13d
   17947:	4d 8d 77 01          	lea    0x1(%r15),%r14
	uint16_t start_handle, end_handle = 0U;
   1794b:	31 ed                	xor    %ebp,%ebp
   1794d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
	for (length--, pdu = rsp->data; length >= rsp->len;
   17952:	41 0f b6 07          	movzbl (%r15),%eax
   17956:	66 41 39 c5          	cmp    %ax,%r13w
   1795a:	0f 82 bd 00 00 00    	jb     17a1d <gatt_read_group_rsp+0x155>
		struct bt_gatt_attr attr = {};
   17960:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
   17965:	31 c0                	xor    %eax,%eax
   17967:	b9 0a 00 00 00       	mov    $0xa,%ecx
   1796c:	f3 ab                	rep stos %eax,%es:(%rdi)
		start_handle = sys_le16_to_cpu(data->start_handle);
   1796e:	66 41 8b 06          	mov    (%r14),%ax
		if (!start_handle) {
   17972:	66 85 c0             	test   %ax,%ax
   17975:	0f 84 ad 00 00 00    	je     17a28 <gatt_read_group_rsp+0x160>
		end_handle = sys_le16_to_cpu(data->end_handle);
   1797b:	66 41 8b 6e 02       	mov    0x2(%r14),%bp
		if (!end_handle || end_handle < start_handle) {
   17980:	66 85 ed             	test   %bp,%bp
   17983:	0f 84 9f 00 00 00    	je     17a28 <gatt_read_group_rsp+0x160>
   17989:	66 39 e8             	cmp    %bp,%ax
   1798c:	0f 87 96 00 00 00    	ja     17a28 <gatt_read_group_rsp+0x160>
		switch (u.uuid.type) {
   17992:	8a 54 24 56          	mov    0x56(%rsp),%dl
   17996:	84 d2                	test   %dl,%dl
   17998:	74 11                	je     179ab <gatt_read_group_rsp+0xe3>
   1799a:	80 fa 02             	cmp    $0x2,%dl
   1799d:	75 16                	jne    179b5 <gatt_read_group_rsp+0xed>
   1799f:	41 0f 10 46 04       	movups 0x4(%r14),%xmm0
   179a4:	0f 11 44 24 57       	movups %xmm0,0x57(%rsp)
   179a9:	eb 0a                	jmp    179b5 <gatt_read_group_rsp+0xed>
   179ab:	66 41 8b 56 04       	mov    0x4(%r14),%dx
   179b0:	66 89 54 24 58       	mov    %dx,0x58(%rsp)
		if (params->type == BT_GATT_DISCOVER_PRIMARY) {
   179b5:	41 80 7c 24 18 00    	cmpb   $0x0,0x18(%r12)
		uuid_svc.uuid.type = BT_UUID_TYPE_16;
   179bb:	c6 44 24 14 00       	movb   $0x0,0x14(%rsp)
		if (params->type == BT_GATT_DISCOVER_PRIMARY) {
   179c0:	75 09                	jne    179cb <gatt_read_group_rsp+0x103>
			uuid_svc.val = BT_UUID_GATT_PRIMARY_VAL;
   179c2:	66 c7 44 24 16 00 28 	movw   $0x2800,0x16(%rsp)
   179c9:	eb 07                	jmp    179d2 <gatt_read_group_rsp+0x10a>
			uuid_svc.val = BT_UUID_GATT_SECONDARY_VAL;
   179cb:	66 c7 44 24 16 01 28 	movw   $0x2801,0x16(%rsp)
		value.uuid = &u.uuid;
   179d2:	48 8d 54 24 56       	lea    0x56(%rsp),%rdx
		attr.handle = start_handle;
   179d7:	66 89 44 24 48       	mov    %ax,0x48(%rsp)
		attr.user_data = &value;
   179dc:	48 8d 44 24 18       	lea    0x18(%rsp),%rax
		value.end_handle = end_handle;
   179e1:	66 89 6c 24 20       	mov    %bp,0x20(%rsp)
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   179e6:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   179eb:	48 89 df             	mov    %rbx,%rdi
		value.uuid = &u.uuid;
   179ee:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
		attr.uuid = &uuid_svc.uuid;
   179f3:	48 8d 54 24 14       	lea    0x14(%rsp),%rdx
		attr.user_data = &value;
   179f8:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
		attr.uuid = &uuid_svc.uuid;
   179fd:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   17a02:	4c 89 e2             	mov    %r12,%rdx
   17a05:	41 ff 54 24 08       	callq  *0x8(%r12)
   17a0a:	84 c0                	test   %al,%al
   17a0c:	74 37                	je     17a45 <gatt_read_group_rsp+0x17d>
	     length -= rsp->len, pdu = (const uint8_t *)pdu + rsp->len) {
   17a0e:	41 0f b6 17          	movzbl (%r15),%edx
   17a12:	41 29 d5             	sub    %edx,%r13d
   17a15:	49 01 d6             	add    %rdx,%r14
   17a18:	e9 35 ff ff ff       	jmpq   17952 <gatt_read_group_rsp+0x8a>
	if (length == 0U && end_handle) {
   17a1d:	66 45 85 ed          	test   %r13w,%r13w
   17a21:	75 05                	jne    17a28 <gatt_read_group_rsp+0x160>
   17a23:	66 85 ed             	test   %bp,%bp
   17a26:	75 0f                	jne    17a37 <gatt_read_group_rsp+0x16f>
	params->func(conn, NULL, params);
   17a28:	4c 89 e2             	mov    %r12,%rdx
   17a2b:	31 f6                	xor    %esi,%esi
   17a2d:	48 89 df             	mov    %rbx,%rdi
   17a30:	41 ff 54 24 08       	callq  *0x8(%r12)
   17a35:	eb 0e                	jmp    17a45 <gatt_read_group_rsp+0x17d>
	gatt_discover_next(conn, handle, params);
   17a37:	0f b7 f5             	movzwl %bp,%esi
   17a3a:	4c 89 e2             	mov    %r12,%rdx
   17a3d:	48 89 df             	mov    %rbx,%rdi
   17a40:	e8 19 fd ff ff       	callq  1775e <gatt_discover_next>
}
   17a45:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
   17a4a:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   17a51:	00 00 
   17a53:	74 05                	je     17a5a <gatt_read_group_rsp+0x192>
   17a55:	e8 e6 cb fe ff       	callq  4640 <__stack_chk_fail@plt>
   17a5a:	48 83 c4 78          	add    $0x78,%rsp
   17a5e:	5b                   	pop    %rbx
   17a5f:	5d                   	pop    %rbp
   17a60:	41 5c                	pop    %r12
   17a62:	41 5d                	pop    %r13
   17a64:	41 5e                	pop    %r14
   17a66:	41 5f                	pop    %r15
   17a68:	c3                   	retq   

0000000000017a69 <gatt_read_type_rsp>:
{
   17a69:	41 57                	push   %r15
   17a6b:	41 56                	push   %r14
   17a6d:	41 55                	push   %r13
   17a6f:	41 54                	push   %r12
   17a71:	49 89 fd             	mov    %rdi,%r13
   17a74:	55                   	push   %rbp
   17a75:	53                   	push   %rbx
   17a76:	4c 89 c3             	mov    %r8,%rbx
   17a79:	48 83 ec 78          	sub    $0x78,%rsp
   17a7d:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   17a84:	00 00 
   17a86:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
   17a8b:	31 c0                	xor    %eax,%eax
	if (err) {
   17a8d:	40 84 f6             	test   %sil,%sil
   17a90:	0f 85 a3 02 00 00    	jne    17d39 <gatt_read_type_rsp+0x2d0>
	if (params->type == BT_GATT_DISCOVER_INCLUDE) {
   17a96:	41 80 78 18 02       	cmpb   $0x2,0x18(%r8)
   17a9b:	49 89 d6             	mov    %rdx,%r14
   17a9e:	0f b6 32             	movzbl (%rdx),%esi
   17aa1:	0f 85 65 01 00 00    	jne    17c0c <gatt_read_type_rsp+0x1a3>
	switch (rsp->len) {
   17aa7:	40 80 fe 06          	cmp    $0x6,%sil
   17aab:	74 11                	je     17abe <gatt_read_type_rsp+0x55>
   17aad:	40 80 fe 08          	cmp    $0x8,%sil
   17ab1:	0f 85 6f 01 00 00    	jne    17c26 <gatt_read_type_rsp+0x1bd>
		u.uuid.type = BT_UUID_TYPE_16;
   17ab7:	c6 44 24 56 00       	movb   $0x0,0x56(%rsp)
   17abc:	eb 05                	jmp    17ac3 <gatt_read_type_rsp+0x5a>
		u.uuid.type = BT_UUID_TYPE_128;
   17abe:	c6 44 24 56 02       	movb   $0x2,0x56(%rsp)
			value.uuid = &u.uuid;
   17ac3:	48 8d 44 24 56       	lea    0x56(%rsp),%rax
	for (length--, pdu = rsp->data; length >= rsp->len;
   17ac8:	44 8d 61 ff          	lea    -0x1(%rcx),%r12d
   17acc:	4d 8d 7e 01          	lea    0x1(%r14),%r15
	uint16_t handle = 0U;
   17ad0:	31 ed                	xor    %ebp,%ebp
			value.uuid = &u.uuid;
   17ad2:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
	for (length--, pdu = rsp->data; length >= rsp->len;
   17ad7:	41 0f b6 06          	movzbl (%r14),%eax
   17adb:	66 41 39 c4          	cmp    %ax,%r12w
   17adf:	0f 82 49 02 00 00    	jb     17d2e <gatt_read_type_rsp+0x2c5>
		handle = sys_le16_to_cpu(data->handle);
   17ae5:	66 41 8b 2f          	mov    (%r15),%bp
		if (!handle) {
   17ae9:	66 85 ed             	test   %bp,%bp
   17aec:	0f 84 47 02 00 00    	je     17d39 <gatt_read_type_rsp+0x2d0>
		switch (u.uuid.type) {
   17af2:	40 8a 74 24 56       	mov    0x56(%rsp),%sil
		value.start_handle = sys_le16_to_cpu(incl->start_handle);
   17af7:	66 41 8b 57 02       	mov    0x2(%r15),%dx
		value.end_handle = sys_le16_to_cpu(incl->end_handle);
   17afc:	66 41 8b 47 04       	mov    0x4(%r15),%ax
		switch (u.uuid.type) {
   17b01:	40 84 f6             	test   %sil,%sil
		value.start_handle = sys_le16_to_cpu(incl->start_handle);
   17b04:	66 89 54 24 18       	mov    %dx,0x18(%rsp)
		value.end_handle = sys_le16_to_cpu(incl->end_handle);
   17b09:	66 89 44 24 1a       	mov    %ax,0x1a(%rsp)
		switch (u.uuid.type) {
   17b0e:	74 08                	je     17b18 <gatt_read_type_rsp+0xaf>
   17b10:	40 80 fe 02          	cmp    $0x2,%sil
   17b14:	74 18                	je     17b2e <gatt_read_type_rsp+0xc5>
   17b16:	eb 7c                	jmp    17b94 <gatt_read_type_rsp+0x12b>
			value.uuid = &u.uuid;
   17b18:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   17b1d:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
			u.u16.val = sys_le16_to_cpu(incl->uuid16);
   17b22:	66 41 8b 47 06       	mov    0x6(%r15),%ax
   17b27:	66 89 44 24 58       	mov    %ax,0x58(%rsp)
   17b2c:	eb 66                	jmp    17b94 <gatt_read_type_rsp+0x12b>
			params->_included.start_handle = value.start_handle;
   17b2e:	66 89 53 12          	mov    %dx,0x12(%rbx)
			params->_included.attr_handle = handle;
   17b32:	66 89 6b 10          	mov    %bp,0x10(%rbx)
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_REQ, sizeof(*req));
   17b36:	ba 02 00 00 00       	mov    $0x2,%edx
			params->_included.end_handle = value.end_handle;
   17b3b:	66 89 43 14          	mov    %ax,0x14(%rbx)
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_REQ, sizeof(*req));
   17b3f:	be 0a 00 00 00       	mov    $0xa,%esi
   17b44:	4c 89 ef             	mov    %r13,%rdi
   17b47:	e8 92 c1 ff ff       	callq  13cde <bt_att_create_pdu>
   17b4c:	49 89 c4             	mov    %rax,%r12
		return -ENOMEM;
   17b4f:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	if (!buf) {
   17b54:	4d 85 e4             	test   %r12,%r12
   17b57:	74 2b                	je     17b84 <gatt_read_type_rsp+0x11b>
   17b59:	49 8d 7c 24 10       	lea    0x10(%r12),%rdi
   17b5e:	be 02 00 00 00       	mov    $0x2,%esi
   17b63:	e8 21 15 00 00       	callq  19089 <net_buf_simple_add>
	req->handle = sys_cpu_to_le16(params->_included.start_handle);
   17b68:	66 8b 53 12          	mov    0x12(%rbx),%dx
	return gatt_send(conn, buf, read_included_uuid_cb, params, NULL);
   17b6c:	48 89 d9             	mov    %rbx,%rcx
   17b6f:	4c 89 e6             	mov    %r12,%rsi
   17b72:	4c 89 ef             	mov    %r13,%rdi
	req->handle = sys_cpu_to_le16(params->_included.start_handle);
   17b75:	66 89 10             	mov    %dx,(%rax)
	return gatt_send(conn, buf, read_included_uuid_cb, params, NULL);
   17b78:	48 8d 15 f9 01 00 00 	lea    0x1f9(%rip),%rdx        # 17d78 <read_included_uuid_cb>
   17b7f:	e8 5c df ff ff       	callq  15ae0 <gatt_send.constprop.35>
	if (!handle) {
   17b84:	66 85 c0             	test   %ax,%ax
			return read_included_uuid(conn, params);
   17b87:	89 c5                	mov    %eax,%ebp
	if (!handle) {
   17b89:	0f 85 b7 01 00 00    	jne    17d46 <gatt_read_type_rsp+0x2dd>
   17b8f:	e9 c0 01 00 00       	jmpq   17d54 <gatt_read_type_rsp+0x2eb>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   17b94:	48 8b 33             	mov    (%rbx),%rsi
   17b97:	48 85 f6             	test   %rsi,%rsi
   17b9a:	74 1d                	je     17bb9 <gatt_read_type_rsp+0x150>
   17b9c:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   17ba1:	e8 a7 59 ff ff       	callq  d54d <bt_uuid_cmp>
   17ba6:	85 c0                	test   %eax,%eax
   17ba8:	74 0f                	je     17bb9 <gatt_read_type_rsp+0x150>
	     length -= rsp->len, pdu = (const uint8_t *)pdu + rsp->len) {
   17baa:	41 0f b6 16          	movzbl (%r14),%edx
   17bae:	41 29 d4             	sub    %edx,%r12d
   17bb1:	49 01 d7             	add    %rdx,%r15
   17bb4:	e9 1e ff ff ff       	jmpq   17ad7 <gatt_read_type_rsp+0x6e>
		attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(
   17bb9:	48 8d 44 24 4e       	lea    0x4e(%rsp),%rax
   17bbe:	c6 44 24 4e 00       	movb   $0x0,0x4e(%rsp)
   17bc3:	66 c7 44 24 50 02 28 	movw   $0x2802,0x50(%rsp)
   17bca:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
   17bd1:	00 00 
   17bd3:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
   17bda:	00 00 
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   17bdc:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
		attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(
   17be1:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
   17be6:	48 8d 44 24 10       	lea    0x10(%rsp),%rax
   17beb:	c6 44 24 42 00       	movb   $0x0,0x42(%rsp)
		attr.handle = handle;
   17bf0:	66 89 6c 24 40       	mov    %bp,0x40(%rsp)
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   17bf5:	48 89 da             	mov    %rbx,%rdx
   17bf8:	4c 89 ef             	mov    %r13,%rdi
		attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(
   17bfb:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   17c00:	ff 53 08             	callq  *0x8(%rbx)
   17c03:	84 c0                	test   %al,%al
   17c05:	75 a3                	jne    17baa <gatt_read_type_rsp+0x141>
   17c07:	e9 48 01 00 00       	jmpq   17d54 <gatt_read_type_rsp+0x2eb>
	switch (rsp->len) {
   17c0c:	40 80 fe 07          	cmp    $0x7,%sil
   17c10:	74 0d                	je     17c1f <gatt_read_type_rsp+0x1b6>
   17c12:	40 80 fe 15          	cmp    $0x15,%sil
   17c16:	75 0e                	jne    17c26 <gatt_read_type_rsp+0x1bd>
		u.uuid.type = BT_UUID_TYPE_128;
   17c18:	c6 44 24 56 02       	movb   $0x2,0x56(%rsp)
   17c1d:	eb 30                	jmp    17c4f <gatt_read_type_rsp+0x1e6>
		u.uuid.type = BT_UUID_TYPE_16;
   17c1f:	c6 44 24 56 00       	movb   $0x0,0x56(%rsp)
   17c24:	eb 29                	jmp    17c4f <gatt_read_type_rsp+0x1e6>
   17c26:	48 8d 15 93 27 22 00 	lea    0x222793(%rip),%rdx        # 23a3c0 <log_const_bt_gatt>
   17c2d:	48 2b 15 1c e3 21 00 	sub    0x21e31c(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Invalid data len %u", rsp->len);
   17c34:	48 8d 3d dd b4 01 00 	lea    0x1b4dd(%rip),%rdi        # 33118 <__func__.5785+0x24b0>
   17c3b:	48 c1 ea 04          	shr    $0x4,%rdx
   17c3f:	c1 e2 06             	shl    $0x6,%edx
   17c42:	83 ca 01             	or     $0x1,%edx
   17c45:	e8 ab f6 fe ff       	callq  72f5 <log_1>
   17c4a:	e9 ea 00 00 00       	jmpq   17d39 <gatt_read_type_rsp+0x2d0>
   17c4f:	48 8d 44 24 56       	lea    0x56(%rsp),%rax
	for (length--, pdu = rsp->data; length >= rsp->len;
   17c54:	44 8d 61 ff          	lea    -0x1(%rcx),%r12d
   17c58:	4d 8d 7e 01          	lea    0x1(%r14),%r15
	uint16_t handle = 0U;
   17c5c:	31 ed                	xor    %ebp,%ebp
   17c5e:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
	for (length--, pdu = rsp->data; length >= rsp->len;
   17c63:	41 0f b6 06          	movzbl (%r14),%eax
   17c67:	66 41 39 c4          	cmp    %ax,%r12w
   17c6b:	0f 82 bd 00 00 00    	jb     17d2e <gatt_read_type_rsp+0x2c5>
		handle = sys_le16_to_cpu(data->handle);
   17c71:	66 41 8b 2f          	mov    (%r15),%bp
		if (!handle) {
   17c75:	66 85 ed             	test   %bp,%bp
   17c78:	0f 84 bb 00 00 00    	je     17d39 <gatt_read_type_rsp+0x2d0>
		switch (u.uuid.type) {
   17c7e:	8a 44 24 56          	mov    0x56(%rsp),%al
   17c82:	84 c0                	test   %al,%al
   17c84:	74 10                	je     17c96 <gatt_read_type_rsp+0x22d>
   17c86:	3c 02                	cmp    $0x2,%al
   17c88:	75 16                	jne    17ca0 <gatt_read_type_rsp+0x237>
   17c8a:	41 0f 10 47 05       	movups 0x5(%r15),%xmm0
   17c8f:	0f 11 44 24 57       	movups %xmm0,0x57(%rsp)
   17c94:	eb 0a                	jmp    17ca0 <gatt_read_type_rsp+0x237>
			u.u16.val = sys_le16_to_cpu(chrc->uuid16);
   17c96:	66 41 8b 47 05       	mov    0x5(%r15),%ax
   17c9b:	66 89 44 24 58       	mov    %ax,0x58(%rsp)
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   17ca0:	48 8b 33             	mov    (%rbx),%rsi
   17ca3:	48 85 f6             	test   %rsi,%rsi
   17ca6:	74 1a                	je     17cc2 <gatt_read_type_rsp+0x259>
   17ca8:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   17cad:	e8 9b 58 ff ff       	callq  d54d <bt_uuid_cmp>
   17cb2:	85 c0                	test   %eax,%eax
   17cb4:	74 0c                	je     17cc2 <gatt_read_type_rsp+0x259>
	     length -= rsp->len, pdu = (const uint8_t *)pdu + rsp->len) {
   17cb6:	41 0f b6 16          	movzbl (%r14),%edx
   17cba:	41 29 d4             	sub    %edx,%r12d
   17cbd:	49 01 d7             	add    %rdx,%r15
   17cc0:	eb a1                	jmp    17c63 <gatt_read_type_rsp+0x1fa>
		value = (struct bt_gatt_chrc)BT_GATT_CHRC_INIT(
   17cc2:	41 8a 47 02          	mov    0x2(%r15),%al
   17cc6:	66 41 8b 57 03       	mov    0x3(%r15),%dx
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   17ccb:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
		value = (struct bt_gatt_chrc)BT_GATT_CHRC_INIT(
   17cd0:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
		attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(
   17cd5:	c6 44 24 52 00       	movb   $0x0,0x52(%rsp)
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   17cda:	4c 89 ef             	mov    %r13,%rdi
		attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(
   17cdd:	66 c7 44 24 54 03 28 	movw   $0x2803,0x54(%rsp)
   17ce4:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
   17ceb:	00 00 
		value = (struct bt_gatt_chrc)BT_GATT_CHRC_INIT(
   17ced:	88 44 24 1a          	mov    %al,0x1a(%rsp)
		attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(
   17cf1:	48 8d 44 24 52       	lea    0x52(%rsp),%rax
		value = (struct bt_gatt_chrc)BT_GATT_CHRC_INIT(
   17cf6:	66 89 54 24 18       	mov    %dx,0x18(%rsp)
   17cfb:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
		attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(
   17d00:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
   17d07:	00 00 
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   17d09:	48 89 da             	mov    %rbx,%rdx
		attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(
   17d0c:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
   17d11:	48 8d 44 24 10       	lea    0x10(%rsp),%rax
   17d16:	c6 44 24 42 00       	movb   $0x0,0x42(%rsp)
		attr.handle = handle;
   17d1b:	66 89 6c 24 40       	mov    %bp,0x40(%rsp)
		attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(
   17d20:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   17d25:	ff 53 08             	callq  *0x8(%rbx)
   17d28:	84 c0                	test   %al,%al
   17d2a:	75 8a                	jne    17cb6 <gatt_read_type_rsp+0x24d>
   17d2c:	eb 26                	jmp    17d54 <gatt_read_type_rsp+0x2eb>
	if (length == 0U && handle) {
   17d2e:	66 45 85 e4          	test   %r12w,%r12w
   17d32:	75 05                	jne    17d39 <gatt_read_type_rsp+0x2d0>
   17d34:	66 85 ed             	test   %bp,%bp
   17d37:	75 0d                	jne    17d46 <gatt_read_type_rsp+0x2dd>
	params->func(conn, NULL, params);
   17d39:	48 89 da             	mov    %rbx,%rdx
   17d3c:	31 f6                	xor    %esi,%esi
   17d3e:	4c 89 ef             	mov    %r13,%rdi
   17d41:	ff 53 08             	callq  *0x8(%rbx)
   17d44:	eb 0e                	jmp    17d54 <gatt_read_type_rsp+0x2eb>
	gatt_discover_next(conn, handle, params);
   17d46:	0f b7 f5             	movzwl %bp,%esi
   17d49:	48 89 da             	mov    %rbx,%rdx
   17d4c:	4c 89 ef             	mov    %r13,%rdi
   17d4f:	e8 0a fa ff ff       	callq  1775e <gatt_discover_next>
}
   17d54:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
   17d59:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   17d60:	00 00 
   17d62:	74 05                	je     17d69 <gatt_read_type_rsp+0x300>
   17d64:	e8 d7 c8 fe ff       	callq  4640 <__stack_chk_fail@plt>
   17d69:	48 83 c4 78          	add    $0x78,%rsp
   17d6d:	5b                   	pop    %rbx
   17d6e:	5d                   	pop    %rbp
   17d6f:	41 5c                	pop    %r12
   17d71:	41 5d                	pop    %r13
   17d73:	41 5e                	pop    %r14
   17d75:	41 5f                	pop    %r15
   17d77:	c3                   	retq   

0000000000017d78 <read_included_uuid_cb>:
{
   17d78:	55                   	push   %rbp
   17d79:	53                   	push   %rbx
   17d7a:	48 89 fd             	mov    %rdi,%rbp
   17d7d:	4c 89 c3             	mov    %r8,%rbx
   17d80:	48 83 ec 68          	sub    $0x68,%rsp
   17d84:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   17d8b:	00 00 
   17d8d:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
   17d92:	31 c0                	xor    %eax,%eax
	if (length != 16U) {
   17d94:	66 83 f9 10          	cmp    $0x10,%cx
   17d98:	74 37                	je     17dd1 <read_included_uuid_cb+0x59>
   17d9a:	48 8d 15 1f 26 22 00 	lea    0x22261f(%rip),%rdx        # 23a3c0 <log_const_bt_gatt>
   17da1:	48 2b 15 a8 e1 21 00 	sub    0x21e1a8(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Invalid data len %u", length);
   17da8:	48 8d 3d 69 b3 01 00 	lea    0x1b369(%rip),%rdi        # 33118 <__func__.5785+0x24b0>
   17daf:	0f b7 f1             	movzwl %cx,%esi
   17db2:	48 c1 ea 04          	shr    $0x4,%rdx
   17db6:	c1 e2 06             	shl    $0x6,%edx
   17db9:	83 ca 01             	or     $0x1,%edx
   17dbc:	e8 34 f5 fe ff       	callq  72f5 <log_1>
		params->func(conn, NULL, params);
   17dc1:	48 89 da             	mov    %rbx,%rdx
   17dc4:	31 f6                	xor    %esi,%esi
   17dc6:	48 89 ef             	mov    %rbp,%rdi
   17dc9:	ff 53 08             	callq  *0x8(%rbx)
		return;
   17dcc:	e9 9d 00 00 00       	jmpq   17e6e <read_included_uuid_cb+0xf6>
	value.start_handle = params->_included.start_handle;
   17dd1:	66 41 8b 40 12       	mov    0x12(%r8),%ax
	if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   17dd6:	49 8b 30             	mov    (%r8),%rsi
	value.uuid = &u.uuid;
   17dd9:	48 8d 7c 24 47       	lea    0x47(%rsp),%rdi
   17dde:	0f 10 02             	movups (%rdx),%xmm0
   17de1:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	u.uuid.type = BT_UUID_TYPE_128;
   17de6:	c6 44 24 47 02       	movb   $0x2,0x47(%rsp)
	value.start_handle = params->_included.start_handle;
   17deb:	66 89 44 24 10       	mov    %ax,0x10(%rsp)
	value.end_handle = params->_included.end_handle;
   17df0:	41 8b 40 14          	mov    0x14(%r8),%eax
	if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   17df4:	48 85 f6             	test   %rsi,%rsi
   17df7:	0f 11 44 24 48       	movups %xmm0,0x48(%rsp)
	value.end_handle = params->_included.end_handle;
   17dfc:	66 89 44 24 12       	mov    %ax,0x12(%rsp)
	if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   17e01:	75 53                	jne    17e56 <read_included_uuid_cb+0xde>
	attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(
   17e03:	48 8d 44 24 42       	lea    0x42(%rsp),%rax
   17e08:	c6 44 24 42 00       	movb   $0x0,0x42(%rsp)
   17e0d:	66 c7 44 24 44 02 28 	movw   $0x2802,0x44(%rsp)
   17e14:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
   17e1b:	00 00 
   17e1d:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
   17e24:	00 00 
	if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   17e26:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
	attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(
   17e2b:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   17e30:	48 8d 44 24 08       	lea    0x8(%rsp),%rax
   17e35:	c6 44 24 3a 00       	movb   $0x0,0x3a(%rsp)
	if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   17e3a:	48 89 da             	mov    %rbx,%rdx
   17e3d:	48 89 ef             	mov    %rbp,%rdi
	attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(
   17e40:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
	attr.handle = params->_included.attr_handle;
   17e45:	8b 43 10             	mov    0x10(%rbx),%eax
   17e48:	66 89 44 24 38       	mov    %ax,0x38(%rsp)
	if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   17e4d:	ff 53 08             	callq  *0x8(%rbx)
   17e50:	84 c0                	test   %al,%al
   17e52:	75 0b                	jne    17e5f <read_included_uuid_cb+0xe7>
   17e54:	eb 18                	jmp    17e6e <read_included_uuid_cb+0xf6>
	if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   17e56:	e8 f2 56 ff ff       	callq  d54d <bt_uuid_cmp>
   17e5b:	85 c0                	test   %eax,%eax
   17e5d:	74 a4                	je     17e03 <read_included_uuid_cb+0x8b>
	gatt_discover_next(conn, params->start_handle, params);
   17e5f:	0f b7 73 10          	movzwl 0x10(%rbx),%esi
   17e63:	48 89 da             	mov    %rbx,%rdx
   17e66:	48 89 ef             	mov    %rbp,%rdi
   17e69:	e8 f0 f8 ff ff       	callq  1775e <gatt_discover_next>
}
   17e6e:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
   17e73:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   17e7a:	00 00 
   17e7c:	74 05                	je     17e83 <read_included_uuid_cb+0x10b>
   17e7e:	e8 bd c7 fe ff       	callq  4640 <__stack_chk_fail@plt>
   17e83:	48 83 c4 68          	add    $0x68,%rsp
   17e87:	5b                   	pop    %rbx
   17e88:	5d                   	pop    %rbp
   17e89:	c3                   	retq   

0000000000017e8a <gatt_find_info_rsp>:
{
   17e8a:	41 57                	push   %r15
   17e8c:	41 56                	push   %r14
   17e8e:	41 55                	push   %r13
   17e90:	41 54                	push   %r12
   17e92:	55                   	push   %rbp
   17e93:	53                   	push   %rbx
   17e94:	4c 89 c5             	mov    %r8,%rbp
   17e97:	48 83 ec 78          	sub    $0x78,%rsp
   17e9b:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   17ea2:	00 00 
   17ea4:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
   17ea9:	31 c0                	xor    %eax,%eax
	if (err) {
   17eab:	40 84 f6             	test   %sil,%sil
{
   17eae:	48 89 3c 24          	mov    %rdi,(%rsp)
	if (err) {
   17eb2:	0f 85 c0 01 00 00    	jne    18078 <gatt_find_info_rsp+0x1ee>
	switch (rsp->format) {
   17eb8:	0f b6 32             	movzbl (%rdx),%esi
   17ebb:	48 89 d3             	mov    %rdx,%rbx
   17ebe:	40 80 fe 01          	cmp    $0x1,%sil
   17ec2:	74 13                	je     17ed7 <gatt_find_info_rsp+0x4d>
   17ec4:	40 80 fe 02          	cmp    $0x2,%sil
   17ec8:	75 1a                	jne    17ee4 <gatt_find_info_rsp+0x5a>
		u.uuid.type = BT_UUID_TYPE_128;
   17eca:	c6 44 24 56 02       	movb   $0x2,0x56(%rsp)
		len = sizeof(*info.i128);
   17ecf:	41 be 12 00 00 00    	mov    $0x12,%r14d
		break;
   17ed5:	eb 36                	jmp    17f0d <gatt_find_info_rsp+0x83>
		u.uuid.type = BT_UUID_TYPE_16;
   17ed7:	c6 44 24 56 00       	movb   $0x0,0x56(%rsp)
		len = sizeof(*info.i16);
   17edc:	41 be 04 00 00 00    	mov    $0x4,%r14d
		break;
   17ee2:	eb 29                	jmp    17f0d <gatt_find_info_rsp+0x83>
   17ee4:	48 8d 15 d5 24 22 00 	lea    0x2224d5(%rip),%rdx        # 23a3c0 <log_const_bt_gatt>
   17eeb:	48 2b 15 5e e0 21 00 	sub    0x21e05e(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Invalid format %u", rsp->format);
   17ef2:	48 8d 3d 33 b2 01 00 	lea    0x1b233(%rip),%rdi        # 3312c <__func__.5785+0x24c4>
   17ef9:	48 c1 ea 04          	shr    $0x4,%rdx
   17efd:	c1 e2 06             	shl    $0x6,%edx
   17f00:	83 ca 01             	or     $0x1,%edx
   17f03:	e8 ed f3 fe ff       	callq  72f5 <log_1>
   17f08:	e9 6b 01 00 00       	jmpq   18078 <gatt_find_info_rsp+0x1ee>
	length--;
   17f0d:	8d 41 ff             	lea    -0x1(%rcx),%eax
	if (length < len) {
   17f10:	66 44 39 f0          	cmp    %r14w,%ax
   17f14:	0f 82 5e 01 00 00    	jb     18078 <gatt_find_info_rsp+0x1ee>
	for (i = length / len, pdu = rsp->info; i != 0;
   17f1a:	31 d2                	xor    %edx,%edx
   17f1c:	4c 8d 64 24 56       	lea    0x56(%rsp),%r12
   17f21:	48 ff c3             	inc    %rbx
   17f24:	66 41 f7 f6          	div    %r14w
	bool skip = false;
   17f28:	45 31 ff             	xor    %r15d,%r15d
	uint16_t handle = 0U;
   17f2b:	45 31 ed             	xor    %r13d,%r13d
	for (i = length / len, pdu = rsp->info; i != 0;
   17f2e:	0f b7 c0             	movzwl %ax,%eax
   17f31:	89 44 24 0c          	mov    %eax,0xc(%rsp)
   17f35:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp)
   17f3a:	0f 84 26 01 00 00    	je     18066 <gatt_find_info_rsp+0x1dc>
		if (skip) {
   17f40:	45 84 ff             	test   %r15b,%r15b
		handle = sys_le16_to_cpu(info.i16->handle);
   17f43:	66 44 8b 2b          	mov    (%rbx),%r13w
		if (skip) {
   17f47:	0f 85 06 01 00 00    	jne    18053 <gatt_find_info_rsp+0x1c9>
		switch (u.uuid.type) {
   17f4d:	8a 44 24 56          	mov    0x56(%rsp),%al
   17f51:	84 c0                	test   %al,%al
   17f53:	74 0f                	je     17f64 <gatt_find_info_rsp+0xda>
   17f55:	3c 02                	cmp    $0x2,%al
   17f57:	75 14                	jne    17f6d <gatt_find_info_rsp+0xe3>
   17f59:	0f 10 43 02          	movups 0x2(%rbx),%xmm0
   17f5d:	0f 11 44 24 57       	movups %xmm0,0x57(%rsp)
   17f62:	eb 09                	jmp    17f6d <gatt_find_info_rsp+0xe3>
			u.u16.val = sys_le16_to_cpu(info.i16->uuid);
   17f64:	66 8b 43 02          	mov    0x2(%rbx),%ax
   17f68:	66 89 44 24 58       	mov    %ax,0x58(%rsp)
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   17f6d:	48 8b 75 00          	mov    0x0(%rbp),%rsi
   17f71:	48 85 f6             	test   %rsi,%rsi
   17f74:	75 08                	jne    17f7e <gatt_find_info_rsp+0xf4>
		if (params->type == BT_GATT_DISCOVER_DESCRIPTOR) {
   17f76:	80 7d 18 04          	cmpb   $0x4,0x18(%rbp)
   17f7a:	75 13                	jne    17f8f <gatt_find_info_rsp+0x105>
   17f7c:	eb 58                	jmp    17fd6 <gatt_find_info_rsp+0x14c>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   17f7e:	4c 89 e7             	mov    %r12,%rdi
   17f81:	e8 c7 55 ff ff       	callq  d54d <bt_uuid_cmp>
   17f86:	85 c0                	test   %eax,%eax
   17f88:	74 ec                	je     17f76 <gatt_find_info_rsp+0xec>
   17f8a:	e9 c4 00 00 00       	jmpq   18053 <gatt_find_info_rsp+0x1c9>
		attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(
   17f8f:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
   17f94:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
   17f9b:	00 00 
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   17f9d:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
		attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(
   17fa2:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
   17fa9:	00 00 
   17fab:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
   17fb2:	00 00 
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   17fb4:	48 89 ea             	mov    %rbp,%rdx
		attr = (struct bt_gatt_attr)BT_GATT_ATTRIBUTE(
   17fb7:	c6 44 24 3a 00       	movb   $0x0,0x3a(%rsp)
		attr.handle = handle;
   17fbc:	66 44 89 6c 24 38    	mov    %r13w,0x38(%rsp)
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   17fc2:	48 8b 3c 24          	mov    (%rsp),%rdi
   17fc6:	ff 55 08             	callq  *0x8(%rbp)
   17fc9:	84 c0                	test   %al,%al
   17fcb:	0f 85 85 00 00 00    	jne    18056 <gatt_find_info_rsp+0x1cc>
   17fd1:	e9 ae 00 00 00       	jmpq   18084 <gatt_find_info_rsp+0x1fa>
			if (!bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) ||
   17fd6:	48 8d 74 24 46       	lea    0x46(%rsp),%rsi
   17fdb:	4c 89 e7             	mov    %r12,%rdi
   17fde:	c6 44 24 46 00       	movb   $0x0,0x46(%rsp)
   17fe3:	66 c7 44 24 48 00 28 	movw   $0x2800,0x48(%rsp)
   17fea:	e8 5e 55 ff ff       	callq  d54d <bt_uuid_cmp>
   17fef:	85 c0                	test   %eax,%eax
   17ff1:	74 60                	je     18053 <gatt_find_info_rsp+0x1c9>
			    !bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY) ||
   17ff3:	48 8d 74 24 4a       	lea    0x4a(%rsp),%rsi
   17ff8:	4c 89 e7             	mov    %r12,%rdi
   17ffb:	c6 44 24 4a 00       	movb   $0x0,0x4a(%rsp)
   18000:	66 c7 44 24 4c 01 28 	movw   $0x2801,0x4c(%rsp)
   18007:	e8 41 55 ff ff       	callq  d54d <bt_uuid_cmp>
			if (!bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) ||
   1800c:	85 c0                	test   %eax,%eax
   1800e:	74 43                	je     18053 <gatt_find_info_rsp+0x1c9>
			    !bt_uuid_cmp(&u.uuid, BT_UUID_GATT_INCLUDE)) {
   18010:	48 8d 74 24 4e       	lea    0x4e(%rsp),%rsi
   18015:	4c 89 e7             	mov    %r12,%rdi
   18018:	c6 44 24 4e 00       	movb   $0x0,0x4e(%rsp)
   1801d:	66 c7 44 24 50 02 28 	movw   $0x2802,0x50(%rsp)
   18024:	e8 24 55 ff ff       	callq  d54d <bt_uuid_cmp>
			    !bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY) ||
   18029:	85 c0                	test   %eax,%eax
   1802b:	74 26                	je     18053 <gatt_find_info_rsp+0x1c9>
			if (!bt_uuid_cmp(&u.uuid, BT_UUID_GATT_CHRC)) {
   1802d:	48 8d 74 24 52       	lea    0x52(%rsp),%rsi
   18032:	4c 89 e7             	mov    %r12,%rdi
   18035:	c6 44 24 52 00       	movb   $0x0,0x52(%rsp)
   1803a:	66 c7 44 24 54 03 28 	movw   $0x2803,0x54(%rsp)
   18041:	e8 07 55 ff ff       	callq  d54d <bt_uuid_cmp>
   18046:	85 c0                	test   %eax,%eax
   18048:	0f 85 41 ff ff ff    	jne    17f8f <gatt_find_info_rsp+0x105>
				skip = true;
   1804e:	41 b7 01             	mov    $0x1,%r15b
   18051:	eb 03                	jmp    18056 <gatt_find_info_rsp+0x1cc>
			skip = false;
   18053:	45 31 ff             	xor    %r15d,%r15d
	     i--, pdu = (const uint8_t *)pdu + len) {
   18056:	41 0f b7 c6          	movzwl %r14w,%eax
   1805a:	ff 4c 24 0c          	decl   0xc(%rsp)
   1805e:	48 01 c3             	add    %rax,%rbx
   18061:	e9 cf fe ff ff       	jmpq   17f35 <gatt_find_info_rsp+0xab>
	gatt_discover_next(conn, handle, params);
   18066:	48 8b 3c 24          	mov    (%rsp),%rdi
   1806a:	41 0f b7 f5          	movzwl %r13w,%esi
   1806e:	48 89 ea             	mov    %rbp,%rdx
   18071:	e8 e8 f6 ff ff       	callq  1775e <gatt_discover_next>
	return;
   18076:	eb 0c                	jmp    18084 <gatt_find_info_rsp+0x1fa>
	params->func(conn, NULL, params);
   18078:	48 89 ea             	mov    %rbp,%rdx
   1807b:	31 f6                	xor    %esi,%esi
   1807d:	48 8b 3c 24          	mov    (%rsp),%rdi
   18081:	ff 55 08             	callq  *0x8(%rbp)
}
   18084:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
   18089:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   18090:	00 00 
   18092:	74 05                	je     18099 <gatt_find_info_rsp+0x20f>
   18094:	e8 a7 c5 fe ff       	callq  4640 <__stack_chk_fail@plt>
   18099:	48 83 c4 78          	add    $0x78,%rsp
   1809d:	5b                   	pop    %rbx
   1809e:	5d                   	pop    %rbp
   1809f:	41 5c                	pop    %r12
   180a1:	41 5d                	pop    %r13
   180a3:	41 5e                	pop    %r14
   180a5:	41 5f                	pop    %r15
   180a7:	c3                   	retq   

00000000000180a8 <bt_gatt_read>:
	if (conn->state != BT_CONN_CONNECTED) {
   180a8:	80 7f 0a 07          	cmpb   $0x7,0xa(%rdi)
   180ac:	0f 85 63 01 00 00    	jne    18215 <bt_gatt_read+0x16d>
{
   180b2:	41 56                	push   %r14
   180b4:	41 55                	push   %r13
   180b6:	41 54                	push   %r12
   180b8:	55                   	push   %rbp
   180b9:	48 89 fd             	mov    %rdi,%rbp
   180bc:	53                   	push   %rbx
	if (params->handle_count == 0) {
   180bd:	48 8b 56 08          	mov    0x8(%rsi),%rdx
   180c1:	48 89 f3             	mov    %rsi,%rbx
   180c4:	48 85 d2             	test   %rdx,%rdx
   180c7:	75 73                	jne    1813c <bt_gatt_read+0x94>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_REQ, sizeof(*req));
   180c9:	ba 04 00 00 00       	mov    $0x4,%edx
   180ce:	be 08 00 00 00       	mov    $0x8,%esi
   180d3:	e8 06 bc ff ff       	callq  13cde <bt_att_create_pdu>
	if (!buf) {
   180d8:	48 85 c0             	test   %rax,%rax
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_REQ, sizeof(*req));
   180db:	49 89 c4             	mov    %rax,%r12
	if (!buf) {
   180de:	75 0e                	jne    180ee <bt_gatt_read+0x46>
}
   180e0:	5b                   	pop    %rbx
		return -ENOMEM;
   180e1:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
}
   180e6:	5d                   	pop    %rbp
   180e7:	41 5c                	pop    %r12
   180e9:	41 5d                	pop    %r13
   180eb:	41 5e                	pop    %r14
   180ed:	c3                   	retq   
   180ee:	4c 8d 68 10          	lea    0x10(%rax),%r13
   180f2:	be 04 00 00 00       	mov    $0x4,%esi
   180f7:	4c 89 ef             	mov    %r13,%rdi
   180fa:	e8 8a 0f 00 00       	callq  19089 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->by_uuid.start_handle);
   180ff:	8b 53 10             	mov    0x10(%rbx),%edx
	if (params->by_uuid.uuid->type == BT_UUID_TYPE_16) {
   18102:	48 8b 73 18          	mov    0x18(%rbx),%rsi
	req->start_handle = sys_cpu_to_le16(params->by_uuid.start_handle);
   18106:	66 89 10             	mov    %dx,(%rax)
	req->end_handle = sys_cpu_to_le16(params->by_uuid.end_handle);
   18109:	66 8b 53 12          	mov    0x12(%rbx),%dx
   1810d:	66 89 50 02          	mov    %dx,0x2(%rax)
	if (params->by_uuid.uuid->type == BT_UUID_TYPE_16) {
   18111:	80 3e 00             	cmpb   $0x0,(%rsi)
   18114:	75 11                	jne    18127 <bt_gatt_read+0x7f>
		net_buf_add_le16(buf, BT_UUID_16(params->by_uuid.uuid)->val);
   18116:	0f b7 76 02          	movzwl 0x2(%rsi),%esi
	net_buf_simple_add_le16(&buf->b, val);
   1811a:	4c 89 ef             	mov    %r13,%rdi
   1811d:	e8 ac 0f 00 00       	callq  190ce <net_buf_simple_add_le16>
   18122:	e9 d1 00 00 00       	jmpq   181f8 <bt_gatt_read+0x150>
		net_buf_add_mem(buf, BT_UUID_128(params->by_uuid.uuid)->val, 16);
   18127:	48 ff c6             	inc    %rsi
	return net_buf_simple_add_mem(&buf->b, mem, len);
   1812a:	ba 10 00 00 00       	mov    $0x10,%edx
   1812f:	4c 89 ef             	mov    %r13,%rdi
   18132:	e8 63 0f 00 00       	callq  1909a <net_buf_simple_add_mem>
   18137:	e9 bc 00 00 00       	jmpq   181f8 <bt_gatt_read+0x150>
	if (params->handle_count > 1) {
   1813c:	48 83 fa 01          	cmp    $0x1,%rdx
   18140:	76 47                	jbe    18189 <bt_gatt_read+0xe1>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_REQ,
   18142:	48 01 d2             	add    %rdx,%rdx
   18145:	be 0e 00 00 00       	mov    $0xe,%esi
   1814a:	e8 8f bb ff ff       	callq  13cde <bt_att_create_pdu>
	if (!buf) {
   1814f:	48 85 c0             	test   %rax,%rax
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_REQ,
   18152:	49 89 c4             	mov    %rax,%r12
	if (!buf) {
   18155:	74 89                	je     180e0 <bt_gatt_read+0x38>
	net_buf_simple_add_le16(&buf->b, val);
   18157:	4c 8d 70 10          	lea    0x10(%rax),%r14
	for (i = 0U; i < params->handle_count; i++) {
   1815b:	45 31 ed             	xor    %r13d,%r13d
   1815e:	41 0f b6 c5          	movzbl %r13b,%eax
   18162:	48 3b 43 08          	cmp    0x8(%rbx),%rax
   18166:	73 15                	jae    1817d <bt_gatt_read+0xd5>
		net_buf_add_le16(buf, params->handles[i]);
   18168:	48 8b 53 10          	mov    0x10(%rbx),%rdx
   1816c:	4c 89 f7             	mov    %r14,%rdi
	for (i = 0U; i < params->handle_count; i++) {
   1816f:	41 ff c5             	inc    %r13d
		net_buf_add_le16(buf, params->handles[i]);
   18172:	0f b7 34 42          	movzwl (%rdx,%rax,2),%esi
   18176:	e8 53 0f 00 00       	callq  190ce <net_buf_simple_add_le16>
   1817b:	eb e1                	jmp    1815e <bt_gatt_read+0xb6>
	return gatt_send(conn, buf, gatt_read_mult_rsp, params, NULL);
   1817d:	48 89 d9             	mov    %rbx,%rcx
   18180:	48 8d 15 62 d6 ff ff 	lea    -0x299e(%rip),%rdx        # 157e9 <gatt_read_mult_rsp>
   18187:	eb 79                	jmp    18202 <bt_gatt_read+0x15a>
	if (params->single.offset) {
   18189:	66 83 7e 12 00       	cmpw   $0x0,0x12(%rsi)
   1818e:	74 39                	je     181c9 <bt_gatt_read+0x121>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_BLOB_REQ, sizeof(*req));
   18190:	ba 04 00 00 00       	mov    $0x4,%edx
   18195:	be 0c 00 00 00       	mov    $0xc,%esi
   1819a:	e8 3f bb ff ff       	callq  13cde <bt_att_create_pdu>
	if (!buf) {
   1819f:	48 85 c0             	test   %rax,%rax
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_BLOB_REQ, sizeof(*req));
   181a2:	49 89 c4             	mov    %rax,%r12
	if (!buf) {
   181a5:	0f 84 35 ff ff ff    	je     180e0 <bt_gatt_read+0x38>
	return net_buf_simple_add(&buf->b, len);
   181ab:	48 8d 78 10          	lea    0x10(%rax),%rdi
   181af:	be 04 00 00 00       	mov    $0x4,%esi
   181b4:	e8 d0 0e 00 00       	callq  19089 <net_buf_simple_add>
	req->handle = sys_cpu_to_le16(params->single.handle);
   181b9:	8b 53 10             	mov    0x10(%rbx),%edx
   181bc:	66 89 10             	mov    %dx,(%rax)
	req->offset = sys_cpu_to_le16(params->single.offset);
   181bf:	66 8b 53 12          	mov    0x12(%rbx),%dx
   181c3:	66 89 50 02          	mov    %dx,0x2(%rax)
   181c7:	eb 2f                	jmp    181f8 <bt_gatt_read+0x150>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_REQ, sizeof(*req));
   181c9:	ba 02 00 00 00       	mov    $0x2,%edx
   181ce:	be 0a 00 00 00       	mov    $0xa,%esi
   181d3:	e8 06 bb ff ff       	callq  13cde <bt_att_create_pdu>
	if (!buf) {
   181d8:	48 85 c0             	test   %rax,%rax
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_REQ, sizeof(*req));
   181db:	49 89 c4             	mov    %rax,%r12
	if (!buf) {
   181de:	0f 84 fc fe ff ff    	je     180e0 <bt_gatt_read+0x38>
   181e4:	48 8d 78 10          	lea    0x10(%rax),%rdi
   181e8:	be 02 00 00 00       	mov    $0x2,%esi
   181ed:	e8 97 0e 00 00       	callq  19089 <net_buf_simple_add>
	req->handle = sys_cpu_to_le16(params->single.handle);
   181f2:	8b 53 10             	mov    0x10(%rbx),%edx
   181f5:	66 89 10             	mov    %dx,(%rax)
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
   181f8:	48 8d 15 1c 00 00 00 	lea    0x1c(%rip),%rdx        # 1821b <gatt_read_rsp>
   181ff:	48 89 d9             	mov    %rbx,%rcx
}
   18202:	5b                   	pop    %rbx
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
   18203:	4c 89 e6             	mov    %r12,%rsi
   18206:	48 89 ef             	mov    %rbp,%rdi
}
   18209:	5d                   	pop    %rbp
   1820a:	41 5c                	pop    %r12
   1820c:	41 5d                	pop    %r13
   1820e:	41 5e                	pop    %r14
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
   18210:	e9 cb d8 ff ff       	jmpq   15ae0 <gatt_send.constprop.35>
		return -ENOTCONN;
   18215:	b8 95 ff ff ff       	mov    $0xffffff95,%eax
}
   1821a:	c3                   	retq   

000000000001821b <gatt_read_rsp>:
	if (err || !length) {
   1821b:	40 84 f6             	test   %sil,%sil
{
   1821e:	41 56                	push   %r14
   18220:	41 55                	push   %r13
   18222:	41 54                	push   %r12
   18224:	55                   	push   %rbp
   18225:	53                   	push   %rbx
   18226:	4c 89 c3             	mov    %r8,%rbx
	if (err || !length) {
   18229:	75 05                	jne    18230 <gatt_read_rsp+0x15>
   1822b:	66 85 c9             	test   %cx,%cx
   1822e:	75 14                	jne    18244 <gatt_read_rsp+0x29>
		params->func(conn, err, params, NULL, 0);
   18230:	40 0f b6 f6          	movzbl %sil,%esi
   18234:	48 8b 03             	mov    (%rbx),%rax
   18237:	45 31 c0             	xor    %r8d,%r8d
   1823a:	31 c9                	xor    %ecx,%ecx
   1823c:	48 89 da             	mov    %rbx,%rdx
   1823f:	e9 0c 01 00 00       	jmpq   18350 <gatt_read_rsp+0x135>
	if (!params->handle_count) {
   18244:	49 83 78 08 00       	cmpq   $0x0,0x8(%r8)
   18249:	41 89 cc             	mov    %ecx,%r12d
   1824c:	48 89 d5             	mov    %rdx,%rbp
   1824f:	49 89 fd             	mov    %rdi,%r13
   18252:	0f 85 9b 00 00 00    	jne    182f3 <gatt_read_rsp+0xd8>
	for (length--, pdu = rsp->data; length;
   18258:	4c 8d 72 01          	lea    0x1(%rdx),%r14
   1825c:	41 ff cc             	dec    %r12d
   1825f:	66 45 85 e4          	test   %r12w,%r12w
   18263:	0f 84 c5 00 00 00    	je     1832e <gatt_read_rsp+0x113>
		handle = sys_le16_to_cpu(data->handle);
   18269:	66 41 8b 06          	mov    (%r14),%ax
		if (!handle) {
   1826d:	66 85 c0             	test   %ax,%ax
   18270:	75 2c                	jne    1829e <gatt_read_rsp+0x83>
   18272:	48 8d 35 47 21 22 00 	lea    0x222147(%rip),%rsi        # 23a3c0 <log_const_bt_gatt>
   18279:	48 2b 35 d0 dc 21 00 	sub    0x21dcd0(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Invalid handle");
   18280:	48 8d 3d b7 ae 01 00 	lea    0x1aeb7(%rip),%rdi        # 3313e <__func__.5785+0x24d6>
}
   18287:	5b                   	pop    %rbx
   18288:	5d                   	pop    %rbp
   18289:	41 5c                	pop    %r12
   1828b:	41 5d                	pop    %r13
   1828d:	41 5e                	pop    %r14
   1828f:	48 c1 ee 04          	shr    $0x4,%rsi
			BT_ERR("Invalid handle");
   18293:	c1 e6 06             	shl    $0x6,%esi
   18296:	83 ce 01             	or     $0x1,%esi
   18299:	e9 26 f0 fe ff       	jmpq   72c4 <log_0>
		len = rsp->len > length ? length - 2 : rsp->len - 2;
   1829e:	0f b6 55 00          	movzbl 0x0(%rbp),%edx
   182a2:	66 44 39 e2          	cmp    %r12w,%dx
   182a6:	44 8d 42 fe          	lea    -0x2(%rdx),%r8d
   182aa:	76 05                	jbe    182b1 <gatt_read_rsp+0x96>
   182ac:	45 8d 44 24 fe       	lea    -0x2(%r12),%r8d
		if (params->func(conn, 0, params, data->value, len) ==
   182b1:	31 f6                	xor    %esi,%esi
		params->by_uuid.start_handle = handle;
   182b3:	66 89 43 10          	mov    %ax,0x10(%rbx)
		if (params->func(conn, 0, params, data->value, len) ==
   182b7:	49 8d 4e 02          	lea    0x2(%r14),%rcx
   182bb:	45 0f b7 c0          	movzwl %r8w,%r8d
   182bf:	48 89 da             	mov    %rbx,%rdx
   182c2:	4c 89 ef             	mov    %r13,%rdi
   182c5:	ff 13                	callq  *(%rbx)
   182c7:	84 c0                	test   %al,%al
   182c9:	0f 84 8b 00 00 00    	je     1835a <gatt_read_rsp+0x13f>
		if (rsp->len > length) {
   182cf:	0f b6 4d 00          	movzbl 0x0(%rbp),%ecx
   182d3:	66 41 39 cc          	cmp    %cx,%r12w
   182d7:	72 55                	jb     1832e <gatt_read_rsp+0x113>
		if (params->by_uuid.start_handle == params->by_uuid.end_handle) {
   182d9:	8b 53 10             	mov    0x10(%rbx),%edx
   182dc:	66 3b 53 12          	cmp    0x12(%rbx),%dx
   182e0:	74 38                	je     1831a <gatt_read_rsp+0xff>
		params->by_uuid.start_handle++;
   182e2:	ff c2                	inc    %edx
	     length -= rsp->len, pdu = (const uint8_t *)pdu + rsp->len) {
   182e4:	41 29 cc             	sub    %ecx,%r12d
   182e7:	49 01 ce             	add    %rcx,%r14
		params->by_uuid.start_handle++;
   182ea:	66 89 53 10          	mov    %dx,0x10(%rbx)
   182ee:	e9 6c ff ff ff       	jmpq   1825f <gatt_read_rsp+0x44>
   182f3:	44 0f b7 f1          	movzwl %cx,%r14d
	if (params->func(conn, 0, params, pdu, length) == BT_GATT_ITER_STOP) {
   182f7:	31 f6                	xor    %esi,%esi
   182f9:	48 89 d1             	mov    %rdx,%rcx
   182fc:	45 89 f0             	mov    %r14d,%r8d
   182ff:	48 89 da             	mov    %rbx,%rdx
   18302:	ff 13                	callq  *(%rbx)
   18304:	84 c0                	test   %al,%al
   18306:	74 52                	je     1835a <gatt_read_rsp+0x13f>
	if (length < (bt_att_get_mtu(conn) - 1)) {
   18308:	4c 89 ef             	mov    %r13,%rdi
   1830b:	e8 f0 c4 ff ff       	callq  14800 <bt_att_get_mtu>
   18310:	0f b7 c0             	movzwl %ax,%eax
   18313:	ff c8                	dec    %eax
   18315:	41 39 c6             	cmp    %eax,%r14d
   18318:	7d 0f                	jge    18329 <gatt_read_rsp+0x10e>
		params->func(conn, 0, params, NULL, 0);
   1831a:	48 8b 03             	mov    (%rbx),%rax
   1831d:	45 31 c0             	xor    %r8d,%r8d
   18320:	31 c9                	xor    %ecx,%ecx
   18322:	48 89 da             	mov    %rbx,%rdx
   18325:	31 f6                	xor    %esi,%esi
   18327:	eb 24                	jmp    1834d <gatt_read_rsp+0x132>
	params->single.offset += length;
   18329:	66 44 01 63 12       	add    %r12w,0x12(%rbx)
	if (bt_gatt_read(conn, params) < 0) {
   1832e:	48 89 de             	mov    %rbx,%rsi
   18331:	4c 89 ef             	mov    %r13,%rdi
   18334:	e8 6f fd ff ff       	callq  180a8 <bt_gatt_read>
   18339:	85 c0                	test   %eax,%eax
   1833b:	79 1d                	jns    1835a <gatt_read_rsp+0x13f>
		params->func(conn, BT_ATT_ERR_UNLIKELY, params, NULL, 0);
   1833d:	48 8b 03             	mov    (%rbx),%rax
   18340:	45 31 c0             	xor    %r8d,%r8d
   18343:	31 c9                	xor    %ecx,%ecx
   18345:	48 89 da             	mov    %rbx,%rdx
   18348:	be 0e 00 00 00       	mov    $0xe,%esi
   1834d:	4c 89 ef             	mov    %r13,%rdi
}
   18350:	5b                   	pop    %rbx
   18351:	5d                   	pop    %rbp
   18352:	41 5c                	pop    %r12
   18354:	41 5d                	pop    %r13
   18356:	41 5e                	pop    %r14
		params->func(conn, BT_ATT_ERR_UNLIKELY, params, NULL, 0);
   18358:	ff e0                	jmpq   *%rax
}
   1835a:	5b                   	pop    %rbx
   1835b:	5d                   	pop    %rbp
   1835c:	41 5c                	pop    %r12
   1835e:	41 5d                	pop    %r13
   18360:	41 5e                	pop    %r14
   18362:	c3                   	retq   

0000000000018363 <bt_gatt_cancel>:
	bt_att_req_cancel(conn, params);
   18363:	e9 35 cb ff ff       	jmpq   14e9d <bt_att_req_cancel>

0000000000018368 <bt_gatt_unsubscribe>:
	if (conn->state != BT_CONN_CONNECTED) {
   18368:	80 7f 0a 07          	cmpb   $0x7,0xa(%rdi)
   1836c:	0f 85 37 01 00 00    	jne    184a9 <bt_gatt_unsubscribe+0x141>
{
   18372:	41 57                	push   %r15
   18374:	41 56                	push   %r14
   18376:	41 55                	push   %r13
   18378:	41 54                	push   %r12
   1837a:	55                   	push   %rbp
   1837b:	53                   	push   %rbx
   1837c:	48 89 f3             	mov    %rsi,%rbx
   1837f:	48 83 ec 18          	sub    $0x18,%rsp
   18383:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	sub = gatt_sub_find(conn);
   18388:	e8 e5 d0 ff ff       	callq  15472 <gatt_sub_find>
	if (!sub) {
   1838d:	48 85 c0             	test   %rax,%rax
	sub = gatt_sub_find(conn);
   18390:	49 89 c5             	mov    %rax,%r13
	if (!sub) {
   18393:	75 0a                	jne    1839f <bt_gatt_unsubscribe+0x37>
		return -EINVAL;
   18395:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   1839a:	e9 10 01 00 00       	jmpq   184af <bt_gatt_unsubscribe+0x147>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, tmp, next, node) {
   1839f:	48 8b 40 08          	mov    0x8(%rax),%rax
   183a3:	45 31 e4             	xor    %r12d,%r12d
   183a6:	31 d2                	xor    %edx,%edx
   183a8:	48 85 c0             	test   %rax,%rax
   183ab:	74 15                	je     183c2 <bt_gatt_unsubscribe+0x5a>
   183ad:	48 89 c2             	mov    %rax,%rdx
   183b0:	48 83 ea 20          	sub    $0x20,%rdx
   183b4:	74 0c                	je     183c2 <bt_gatt_unsubscribe+0x5a>
	return node->next;
   183b6:	48 8b 00             	mov    (%rax),%rax
   183b9:	48 85 c0             	test   %rax,%rax
   183bc:	74 04                	je     183c2 <bt_gatt_unsubscribe+0x5a>
   183be:	4c 8d 60 e0          	lea    -0x20(%rax),%r12
   183c2:	31 ed                	xor    %ebp,%ebp
   183c4:	45 31 ff             	xor    %r15d,%r15d
   183c7:	45 31 f6             	xor    %r14d,%r14d
   183ca:	48 85 d2             	test   %rdx,%rdx
   183cd:	0f 84 91 00 00 00    	je     18464 <bt_gatt_unsubscribe+0xfc>
		if (params == tmp) {
   183d3:	48 39 da             	cmp    %rbx,%rdx
   183d6:	48 8d 42 20          	lea    0x20(%rdx),%rax
   183da:	75 53                	jne    1842f <bt_gatt_unsubscribe+0xc7>
Z_GENLIST_REMOVE(slist, snode)
   183dc:	48 85 ed             	test   %rbp,%rbp
   183df:	48 8b 72 20          	mov    0x20(%rdx),%rsi
   183e3:	75 10                	jne    183f5 <bt_gatt_unsubscribe+0x8d>
   183e5:	49 3b 45 10          	cmp    0x10(%r13),%rax
	list->head = node;
   183e9:	49 89 75 08          	mov    %rsi,0x8(%r13)
Z_GENLIST_REMOVE(slist, snode)
   183ed:	75 14                	jne    18403 <bt_gatt_unsubscribe+0x9b>
	list->tail = node;
   183ef:	49 89 75 10          	mov    %rsi,0x10(%r13)
   183f3:	eb 0e                	jmp    18403 <bt_gatt_unsubscribe+0x9b>
	parent->next = child;
   183f5:	48 89 75 00          	mov    %rsi,0x0(%rbp)
Z_GENLIST_REMOVE(slist, snode)
   183f9:	49 3b 45 10          	cmp    0x10(%r13),%rax
   183fd:	75 04                	jne    18403 <bt_gatt_unsubscribe+0x9b>
	list->tail = node;
   183ff:	49 89 6d 10          	mov    %rbp,0x10(%r13)
			if (atomic_test_bit(params->flags,
   18403:	48 8d 7a 18          	lea    0x18(%rdx),%rdi
	parent->next = child;
   18407:	48 c7 42 20 00 00 00 	movq   $0x0,0x20(%rdx)
   1840e:	00 
   1840f:	be 02 00 00 00       	mov    $0x2,%esi
   18414:	e8 ac d1 ff ff       	callq  155c5 <atomic_test_bit>
   18419:	84 c0                	test   %al,%al
   1841b:	41 88 c7             	mov    %al,%r15b
   1841e:	74 21                	je     18441 <bt_gatt_unsubscribe+0xd9>
				bt_gatt_cancel(conn, params);
   18420:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   18425:	48 89 d6             	mov    %rdx,%rsi
   18428:	e8 36 ff ff ff       	callq  18363 <bt_gatt_cancel>
   1842d:	eb 15                	jmp    18444 <bt_gatt_unsubscribe+0xdc>
		if (tmp->value_handle == params->value_handle) {
   1842f:	48 89 c5             	mov    %rax,%rbp
   18432:	8b 43 10             	mov    0x10(%rbx),%eax
   18435:	66 39 42 10          	cmp    %ax,0x10(%rdx)
   18439:	b0 01                	mov    $0x1,%al
   1843b:	44 0f 44 f0          	cmove  %eax,%r14d
   1843f:	eb 03                	jmp    18444 <bt_gatt_unsubscribe+0xdc>
			found = true;
   18441:	41 b7 01             	mov    $0x1,%r15b
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, tmp, next, node) {
   18444:	31 c0                	xor    %eax,%eax
   18446:	4d 85 e4             	test   %r12,%r12
   18449:	74 0e                	je     18459 <bt_gatt_unsubscribe+0xf1>
	return node->next;
   1844b:	49 8b 54 24 20       	mov    0x20(%r12),%rdx
   18450:	48 85 d2             	test   %rdx,%rdx
   18453:	74 04                	je     18459 <bt_gatt_unsubscribe+0xf1>
   18455:	48 8d 42 e0          	lea    -0x20(%rdx),%rax
   18459:	4c 89 e2             	mov    %r12,%rdx
   1845c:	49 89 c4             	mov    %rax,%r12
   1845f:	e9 66 ff ff ff       	jmpq   183ca <bt_gatt_unsubscribe+0x62>
	if (!found) {
   18464:	45 84 ff             	test   %r15b,%r15b
   18467:	0f 84 28 ff ff ff    	je     18395 <bt_gatt_unsubscribe+0x2d>
	if (has_subscription) {
   1846d:	45 84 f6             	test   %r14b,%r14b
   18470:	74 10                	je     18482 <bt_gatt_unsubscribe+0x11a>
		params->notify(conn, params, NULL, 0);
   18472:	31 c9                	xor    %ecx,%ecx
   18474:	48 89 de             	mov    %rbx,%rsi
   18477:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   1847c:	ff 13                	callq  *(%rbx)
		return 0;
   1847e:	31 c0                	xor    %eax,%eax
   18480:	eb 2d                	jmp    184af <bt_gatt_unsubscribe+0x147>
	params->value = 0x0000;
   18482:	66 c7 43 14 00 00    	movw   $0x0,0x14(%rbx)
	return gatt_write_ccc(conn, params->ccc_handle, params->value,
   18488:	0f b7 73 12          	movzwl 0x12(%rbx),%esi
   1848c:	48 89 d9             	mov    %rbx,%rcx
   1848f:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
}
   18494:	48 83 c4 18          	add    $0x18,%rsp
	return gatt_write_ccc(conn, params->ccc_handle, params->value,
   18498:	31 d2                	xor    %edx,%edx
}
   1849a:	5b                   	pop    %rbx
   1849b:	5d                   	pop    %rbp
   1849c:	41 5c                	pop    %r12
   1849e:	41 5d                	pop    %r13
   184a0:	41 5e                	pop    %r14
   184a2:	41 5f                	pop    %r15
	return gatt_write_ccc(conn, params->ccc_handle, params->value,
   184a4:	e9 f8 d7 ff ff       	jmpq   15ca1 <gatt_write_ccc.constprop.29>
		return -ENOTCONN;
   184a9:	b8 95 ff ff ff       	mov    $0xffffff95,%eax
}
   184ae:	c3                   	retq   
   184af:	48 83 c4 18          	add    $0x18,%rsp
   184b3:	5b                   	pop    %rbx
   184b4:	5d                   	pop    %rbp
   184b5:	41 5c                	pop    %r12
   184b7:	41 5d                	pop    %r13
   184b9:	41 5e                	pop    %r14
   184bb:	41 5f                	pop    %r15
   184bd:	c3                   	retq   

00000000000184be <bt_gatt_notification>:
{
   184be:	41 57                	push   %r15
   184c0:	41 56                	push   %r14
   184c2:	49 89 d7             	mov    %rdx,%r15
   184c5:	41 55                	push   %r13
   184c7:	41 54                	push   %r12
   184c9:	49 89 fd             	mov    %rdi,%r13
   184cc:	55                   	push   %rbp
   184cd:	53                   	push   %rbx
   184ce:	41 89 f6             	mov    %esi,%r14d
   184d1:	44 0f b7 e1          	movzwl %cx,%r12d
   184d5:	48 83 ec 08          	sub    $0x8,%rsp
	sub = gatt_sub_find(conn);
   184d9:	e8 94 cf ff ff       	callq  15472 <gatt_sub_find>
	if (!sub) {
   184de:	48 85 c0             	test   %rax,%rax
   184e1:	74 61                	je     18544 <bt_gatt_notification+0x86>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   184e3:	48 8b 40 08          	mov    0x8(%rax),%rax
   184e7:	48 85 c0             	test   %rax,%rax
   184ea:	74 58                	je     18544 <bt_gatt_notification+0x86>
   184ec:	48 89 c5             	mov    %rax,%rbp
   184ef:	48 83 ed 20          	sub    $0x20,%rbp
   184f3:	74 4f                	je     18544 <bt_gatt_notification+0x86>
   184f5:	48 8b 00             	mov    (%rax),%rax
   184f8:	31 db                	xor    %ebx,%ebx
   184fa:	48 85 c0             	test   %rax,%rax
   184fd:	74 04                	je     18503 <bt_gatt_notification+0x45>
   184ff:	48 8d 58 e0          	lea    -0x20(%rax),%rbx
		if (handle != params->value_handle) {
   18503:	66 44 39 75 10       	cmp    %r14w,0x10(%rbp)
   18508:	75 1e                	jne    18528 <bt_gatt_notification+0x6a>
		if (params->notify(conn, params, data, length) ==
   1850a:	44 89 e1             	mov    %r12d,%ecx
   1850d:	4c 89 fa             	mov    %r15,%rdx
   18510:	48 89 ee             	mov    %rbp,%rsi
   18513:	4c 89 ef             	mov    %r13,%rdi
   18516:	ff 55 00             	callq  *0x0(%rbp)
   18519:	84 c0                	test   %al,%al
   1851b:	75 0b                	jne    18528 <bt_gatt_notification+0x6a>
			bt_gatt_unsubscribe(conn, params);
   1851d:	48 89 ee             	mov    %rbp,%rsi
   18520:	4c 89 ef             	mov    %r13,%rdi
   18523:	e8 40 fe ff ff       	callq  18368 <bt_gatt_unsubscribe>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   18528:	48 85 db             	test   %rbx,%rbx
   1852b:	74 17                	je     18544 <bt_gatt_notification+0x86>
   1852d:	48 8b 53 20          	mov    0x20(%rbx),%rdx
   18531:	31 c0                	xor    %eax,%eax
   18533:	48 85 d2             	test   %rdx,%rdx
   18536:	74 04                	je     1853c <bt_gatt_notification+0x7e>
   18538:	48 8d 42 e0          	lea    -0x20(%rdx),%rax
   1853c:	48 89 dd             	mov    %rbx,%rbp
   1853f:	48 89 c3             	mov    %rax,%rbx
   18542:	eb bf                	jmp    18503 <bt_gatt_notification+0x45>
}
   18544:	58                   	pop    %rax
   18545:	5b                   	pop    %rbx
   18546:	5d                   	pop    %rbp
   18547:	41 5c                	pop    %r12
   18549:	41 5d                	pop    %r13
   1854b:	41 5e                	pop    %r14
   1854d:	41 5f                	pop    %r15
   1854f:	c3                   	retq   

0000000000018550 <bt_gatt_mult_notification>:
{
   18550:	41 57                	push   %r15
   18552:	41 56                	push   %r14
   18554:	41 55                	push   %r13
   18556:	41 54                	push   %r12
   18558:	49 89 fc             	mov    %rdi,%r12
   1855b:	55                   	push   %rbp
   1855c:	53                   	push   %rbx
   1855d:	89 d5                	mov    %edx,%ebp
   1855f:	48 83 ec 48          	sub    $0x48,%rsp
   18563:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1856a:	00 00 
   1856c:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
   18571:	31 c0                	xor    %eax,%eax
   18573:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	sub = gatt_sub_find(conn);
   18578:	e8 f5 ce ff ff       	callq  15472 <gatt_sub_find>
	if (!sub) {
   1857d:	48 85 c0             	test   %rax,%rax
   18580:	0f 84 08 01 00 00    	je     1868e <bt_gatt_mult_notification+0x13e>
	net_buf_simple_init_with_data(&buf, (void *)data, length);
   18586:	4c 8d 6c 24 20       	lea    0x20(%rsp),%r13
   1858b:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   18590:	49 89 c6             	mov    %rax,%r14
   18593:	0f b7 c5             	movzwl %bp,%eax
   18596:	48 89 c2             	mov    %rax,%rdx
   18599:	4c 89 ef             	mov    %r13,%rdi
   1859c:	48 89 04 24          	mov    %rax,(%rsp)
   185a0:	e8 c4 09 00 00       	callq  18f69 <net_buf_simple_init_with_data>
	while (buf.len > sizeof(*nfy)) {
   185a5:	66 83 7c 24 28 04    	cmpw   $0x4,0x28(%rsp)
   185ab:	0f 86 dd 00 00 00    	jbe    1868e <bt_gatt_mult_notification+0x13e>
		nfy = net_buf_simple_pull_mem(&buf, sizeof(*nfy));
   185b1:	be 04 00 00 00       	mov    $0x4,%esi
   185b6:	4c 89 ef             	mov    %r13,%rdi
   185b9:	e8 51 0b 00 00       	callq  1910f <net_buf_simple_pull_mem>
		len = sys_cpu_to_le16(nfy->len);
   185be:	66 8b 58 02          	mov    0x2(%rax),%bx
		if (len > buf.len) {
   185c2:	66 3b 5c 24 28       	cmp    0x28(%rsp),%bx
		nfy = net_buf_simple_pull_mem(&buf, sizeof(*nfy));
   185c7:	48 89 c5             	mov    %rax,%rbp
		if (len > buf.len) {
   185ca:	76 30                	jbe    185fc <bt_gatt_mult_notification+0xac>
   185cc:	48 8d 0d ed 1d 22 00 	lea    0x221ded(%rip),%rcx        # 23a3c0 <log_const_bt_gatt>
   185d3:	48 2b 0d 76 d9 21 00 	sub    0x21d976(%rip),%rcx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
			BT_ERR("Invalid data len %u > %u", len, length);
   185da:	48 8d 3d 6c ab 01 00 	lea    0x1ab6c(%rip),%rdi        # 3314d <__func__.5785+0x24e5>
   185e1:	48 8b 14 24          	mov    (%rsp),%rdx
   185e5:	0f b7 f3             	movzwl %bx,%esi
   185e8:	48 c1 e9 04          	shr    $0x4,%rcx
   185ec:	c1 e1 06             	shl    $0x6,%ecx
   185ef:	83 c9 01             	or     $0x1,%ecx
   185f2:	e8 3b ed fe ff       	callq  7332 <log_2>
   185f7:	e9 92 00 00 00       	jmpq   1868e <bt_gatt_mult_notification+0x13e>
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp,
   185fc:	49 8b 46 08          	mov    0x8(%r14),%rax
   18600:	48 85 c0             	test   %rax,%rax
   18603:	74 79                	je     1867e <bt_gatt_mult_notification+0x12e>
   18605:	49 89 c1             	mov    %rax,%r9
   18608:	49 83 e9 20          	sub    $0x20,%r9
   1860c:	74 70                	je     1867e <bt_gatt_mult_notification+0x12e>
   1860e:	48 8b 00             	mov    (%rax),%rax
   18611:	45 31 ff             	xor    %r15d,%r15d
   18614:	48 85 c0             	test   %rax,%rax
   18617:	74 04                	je     1861d <bt_gatt_mult_notification+0xcd>
   18619:	4c 8d 78 e0          	lea    -0x20(%rax),%r15
		handle = sys_cpu_to_le16(nfy->handle);
   1861d:	66 8b 45 00          	mov    0x0(%rbp),%ax
   18621:	66 89 44 24 08       	mov    %ax,0x8(%rsp)
			if (params->notify(conn, params, nfy->value, len) ==
   18626:	0f b7 c3             	movzwl %bx,%eax
   18629:	89 44 24 14          	mov    %eax,0x14(%rsp)
			if (handle != params->value_handle) {
   1862d:	8b 44 24 08          	mov    0x8(%rsp),%eax
   18631:	66 41 3b 41 10       	cmp    0x10(%r9),%ax
   18636:	75 2a                	jne    18662 <bt_gatt_mult_notification+0x112>
			if (params->notify(conn, params, nfy->value, len) ==
   18638:	4c 89 ce             	mov    %r9,%rsi
   1863b:	4c 89 4c 24 18       	mov    %r9,0x18(%rsp)
   18640:	48 8d 55 04          	lea    0x4(%rbp),%rdx
   18644:	8b 4c 24 14          	mov    0x14(%rsp),%ecx
   18648:	4c 89 e7             	mov    %r12,%rdi
   1864b:	41 ff 11             	callq  *(%r9)
   1864e:	84 c0                	test   %al,%al
   18650:	4c 8b 4c 24 18       	mov    0x18(%rsp),%r9
   18655:	75 0b                	jne    18662 <bt_gatt_mult_notification+0x112>
				bt_gatt_unsubscribe(conn, params);
   18657:	4c 89 ce             	mov    %r9,%rsi
   1865a:	4c 89 e7             	mov    %r12,%rdi
   1865d:	e8 06 fd ff ff       	callq  18368 <bt_gatt_unsubscribe>
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp,
   18662:	4d 85 ff             	test   %r15,%r15
   18665:	74 17                	je     1867e <bt_gatt_mult_notification+0x12e>
   18667:	49 8b 57 20          	mov    0x20(%r15),%rdx
   1866b:	31 c0                	xor    %eax,%eax
   1866d:	48 85 d2             	test   %rdx,%rdx
   18670:	74 04                	je     18676 <bt_gatt_mult_notification+0x126>
   18672:	48 8d 42 e0          	lea    -0x20(%rdx),%rax
   18676:	4d 89 f9             	mov    %r15,%r9
   18679:	49 89 c7             	mov    %rax,%r15
   1867c:	eb af                	jmp    1862d <bt_gatt_mult_notification+0xdd>
		net_buf_simple_pull_mem(&buf, len);
   1867e:	0f b7 f3             	movzwl %bx,%esi
   18681:	4c 89 ef             	mov    %r13,%rdi
   18684:	e8 86 0a 00 00       	callq  1910f <net_buf_simple_pull_mem>
   18689:	e9 17 ff ff ff       	jmpq   185a5 <bt_gatt_mult_notification+0x55>
}
   1868e:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
   18693:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1869a:	00 00 
   1869c:	74 05                	je     186a3 <bt_gatt_mult_notification+0x153>
   1869e:	e8 9d bf fe ff       	callq  4640 <__stack_chk_fail@plt>
   186a3:	48 83 c4 48          	add    $0x48,%rsp
   186a7:	5b                   	pop    %rbx
   186a8:	5d                   	pop    %rbp
   186a9:	41 5c                	pop    %r12
   186ab:	41 5d                	pop    %r13
   186ad:	41 5e                	pop    %r14
   186af:	41 5f                	pop    %r15
   186b1:	c3                   	retq   

00000000000186b2 <bt_gatt_connected>:
{
   186b2:	41 54                	push   %r12
   186b4:	55                   	push   %rbp
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   186b5:	4c 8d a7 d8 00 00 00 	lea    0xd8(%rdi),%r12
{
   186bc:	53                   	push   %rbx
   186bd:	48 89 fd             	mov    %rdi,%rbp
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   186c0:	4c 89 e6             	mov    %r12,%rsi
{
   186c3:	48 83 ec 50          	sub    $0x50,%rsp
	data.conn = conn;
   186c7:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   186cc:	0f b6 7f 08          	movzbl 0x8(%rdi),%edi
{
   186d0:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   186d7:	00 00 
   186d9:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
   186de:	31 c0                	xor    %eax,%eax
	data.sec = BT_SECURITY_L1;
   186e0:	c6 44 24 18 01       	movb   $0x1,0x18(%rsp)
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   186e5:	e8 89 7c ff ff       	callq  10373 <bt_addr_le_is_bonded>
	if (IS_ENABLED(CONFIG_BT_SETTINGS_CCC_LAZY_LOADING) &&
   186ea:	84 c0                	test   %al,%al
   186ec:	74 55                	je     18743 <bt_gatt_connected+0x91>
		if (conn->id) {
   186ee:	0f b6 55 08          	movzbl 0x8(%rbp),%edx
			bt_settings_encode_key(key, sizeof(key), "ccc",
   186f2:	45 31 c0             	xor    %r8d,%r8d
   186f5:	48 8d 5c 24 24       	lea    0x24(%rsp),%rbx
		if (conn->id) {
   186fa:	84 d2                	test   %dl,%dl
   186fc:	74 1c                	je     1871a <bt_gatt_connected+0x68>
			u8_to_dec(id_str, sizeof(id_str), conn->id);
   186fe:	4c 8d 44 24 20       	lea    0x20(%rsp),%r8
   18703:	be 04 00 00 00       	mov    $0x4,%esi
   18708:	4c 89 c7             	mov    %r8,%rdi
   1870b:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
   18710:	e8 76 d0 fe ff       	callq  578b <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "ccc",
   18715:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
			bt_settings_encode_key(key, sizeof(key), "ccc",
   1871a:	48 8d 15 86 a9 01 00 	lea    0x1a986(%rip),%rdx        # 330a7 <__func__.5785+0x243f>
   18721:	be 24 00 00 00       	mov    $0x24,%esi
   18726:	48 89 df             	mov    %rbx,%rdi
   18729:	4c 89 e1             	mov    %r12,%rcx
   1872c:	e8 d3 4b ff ff       	callq  d304 <bt_settings_encode_key>
		settings_load_subtree_direct(key, ccc_set_direct, (void *)key);
   18731:	48 8d 35 4e e7 ff ff 	lea    -0x18b2(%rip),%rsi        # 16e86 <ccc_set_direct>
   18738:	48 89 da             	mov    %rbx,%rdx
   1873b:	48 89 df             	mov    %rbx,%rdi
   1873e:	e8 33 fd fe ff       	callq  8476 <settings_load_subtree_direct>
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
   18743:	48 8d 4c 24 10       	lea    0x10(%rsp),%rcx
   18748:	48 8d 15 84 eb ff ff 	lea    -0x147c(%rip),%rdx        # 172d3 <update_ccc>
   1874f:	be ff ff 00 00       	mov    $0xffff,%esi
   18754:	bf 01 00 00 00       	mov    $0x1,%edi
   18759:	e8 0b e5 ff ff       	callq  16c69 <bt_gatt_foreach_attr>
	sub = gatt_sub_find(conn);
   1875e:	48 89 ef             	mov    %rbp,%rdi
   18761:	e8 0c cd ff ff       	callq  15472 <gatt_sub_find>
	if (!sub) {
   18766:	48 85 c0             	test   %rax,%rax
   18769:	74 4d                	je     187b8 <bt_gatt_connected+0x106>
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, params, node) {
   1876b:	48 8b 58 08          	mov    0x8(%rax),%rbx
   1876f:	48 85 db             	test   %rbx,%rbx
   18772:	74 44                	je     187b8 <bt_gatt_connected+0x106>
   18774:	48 83 eb 20          	sub    $0x20,%rbx
   18778:	48 85 db             	test   %rbx,%rbx
   1877b:	74 3b                	je     187b8 <bt_gatt_connected+0x106>
		if (bt_addr_le_is_bonded(conn->id, &conn->le.dst) &&
   1877d:	0f b6 7d 08          	movzbl 0x8(%rbp),%edi
   18781:	4c 89 e6             	mov    %r12,%rsi
   18784:	e8 ea 7b ff ff       	callq  10373 <bt_addr_le_is_bonded>
   18789:	84 c0                	test   %al,%al
   1878b:	74 25                	je     187b2 <bt_gatt_connected+0x100>
		    !atomic_test_bit(params->flags,
   1878d:	48 8d 7b 18          	lea    0x18(%rbx),%rdi
   18791:	be 01 00 00 00       	mov    $0x1,%esi
   18796:	e8 2a ce ff ff       	callq  155c5 <atomic_test_bit>
		if (bt_addr_le_is_bonded(conn->id, &conn->le.dst) &&
   1879b:	84 c0                	test   %al,%al
   1879d:	75 13                	jne    187b2 <bt_gatt_connected+0x100>
			gatt_write_ccc(conn, params->ccc_handle, params->value,
   1879f:	0f b7 53 14          	movzwl 0x14(%rbx),%edx
   187a3:	0f b7 73 12          	movzwl 0x12(%rbx),%esi
   187a7:	48 89 d9             	mov    %rbx,%rcx
   187aa:	48 89 ef             	mov    %rbp,%rdi
   187ad:	e8 ef d4 ff ff       	callq  15ca1 <gatt_write_ccc.constprop.29>
   187b2:	48 8b 5b 20          	mov    0x20(%rbx),%rbx
   187b6:	eb b7                	jmp    1876f <bt_gatt_connected+0xbd>
}
   187b8:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
   187bd:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   187c4:	00 00 
   187c6:	74 05                	je     187cd <bt_gatt_connected+0x11b>
   187c8:	e8 73 be fe ff       	callq  4640 <__stack_chk_fail@plt>
   187cd:	48 83 c4 50          	add    $0x50,%rsp
   187d1:	5b                   	pop    %rbx
   187d2:	5d                   	pop    %rbp
   187d3:	41 5c                	pop    %r12
   187d5:	c3                   	retq   

00000000000187d6 <bt_gatt_change_aware>:
{
   187d6:	55                   	push   %rbp
   187d7:	53                   	push   %rbx
   187d8:	89 f5                	mov    %esi,%ebp
   187da:	40 88 f3             	mov    %sil,%bl
   187dd:	48 83 ec 08          	sub    $0x8,%rsp
	cfg = find_cf_cfg(conn);
   187e1:	e8 01 ca ff ff       	callq  151e7 <find_cf_cfg>
	if (!cfg || !CF_ROBUST_CACHING(cfg)) {
   187e6:	48 85 c0             	test   %rax,%rax
   187e9:	75 04                	jne    187ef <bt_gatt_change_aware+0x19>
		return true;
   187eb:	b3 01                	mov    $0x1,%bl
   187ed:	eb 46                	jmp    18835 <bt_gatt_change_aware+0x5f>
	if (!cfg || !CF_ROBUST_CACHING(cfg)) {
   187ef:	f6 40 08 01          	testb  $0x1,0x8(%rax)
   187f3:	74 f6                	je     187eb <bt_gatt_change_aware+0x15>
	if (atomic_test_bit(cfg->flags, CF_CHANGE_AWARE)) {
   187f5:	4c 8d 40 0c          	lea    0xc(%rax),%r8
   187f9:	31 f6                	xor    %esi,%esi
   187fb:	4c 89 c7             	mov    %r8,%rdi
   187fe:	e8 c2 cd ff ff       	callq  155c5 <atomic_test_bit>
   18803:	84 c0                	test   %al,%al
   18805:	75 e4                	jne    187eb <bt_gatt_change_aware+0x15>
	if (!req) {
   18807:	40 84 ed             	test   %bpl,%bpl
   1880a:	74 29                	je     18835 <bt_gatt_change_aware+0x5f>
	if (atomic_test_bit(cfg->flags, CF_OUT_OF_SYNC)) {
   1880c:	be 01 00 00 00       	mov    $0x1,%esi
   18811:	e8 af cd ff ff       	callq  155c5 <atomic_test_bit>
   18816:	84 c0                	test   %al,%al
   18818:	88 c3                	mov    %al,%bl
	atomic_set_bit(cfg->flags, CF_OUT_OF_SYNC);
   1881a:	be 01 00 00 00       	mov    $0x1,%esi
	if (atomic_test_bit(cfg->flags, CF_OUT_OF_SYNC)) {
   1881f:	74 0c                	je     1882d <bt_gatt_change_aware+0x57>
   18821:	be fd ff ff ff       	mov    $0xfffffffd,%esi
   18826:	e8 a5 cd ff ff       	callq  155d0 <atomic_and>
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   1882b:	31 f6                	xor    %esi,%esi
	atomic_set_bit(cfg->flags, CF_OUT_OF_SYNC);
   1882d:	4c 89 c7             	mov    %r8,%rdi
   18830:	e8 f5 d4 ff ff       	callq  15d2a <atomic_set_bit>
}
   18835:	88 d8                	mov    %bl,%al
   18837:	5a                   	pop    %rdx
   18838:	5b                   	pop    %rbx
   18839:	5d                   	pop    %rbp
   1883a:	c3                   	retq   

000000000001883b <db_hash_read>:
{
   1883b:	41 56                	push   %r14
   1883d:	41 55                	push   %r13
   1883f:	45 89 c6             	mov    %r8d,%r14d
   18842:	41 54                	push   %r12
   18844:	55                   	push   %rbp
   18845:	48 89 fd             	mov    %rdi,%rbp
	err = k_delayed_work_cancel(&db_hash_work);
   18848:	48 8d 3d d1 ec 23 00 	lea    0x23ecd1(%rip),%rdi        # 257520 <db_hash_work>
{
   1884f:	53                   	push   %rbx
   18850:	49 89 f4             	mov    %rsi,%r12
   18853:	49 89 d5             	mov    %rdx,%r13
   18856:	89 cb                	mov    %ecx,%ebx
	err = k_delayed_work_cancel(&db_hash_work);
   18858:	e8 aa 3b 01 00       	callq  2c407 <k_delayed_work_cancel>
	if (!err) {
   1885d:	85 c0                	test   %eax,%eax
   1885f:	75 0a                	jne    1886b <db_hash_read+0x30>
		db_hash_gen(true);
   18861:	bf 01 00 00 00       	mov    $0x1,%edi
   18866:	e8 1d e4 ff ff       	callq  16c88 <db_hash_gen>
	bt_gatt_change_aware(conn, true);
   1886b:	48 89 ef             	mov    %rbp,%rdi
   1886e:	be 01 00 00 00       	mov    $0x1,%esi
   18873:	e8 5e ff ff ff       	callq  187d6 <bt_gatt_change_aware>
	return bt_gatt_attr_read(conn, attr, buf, len, offset, db_hash,
   18878:	48 83 ec 08          	sub    $0x8,%rsp
   1887c:	4c 8d 0d ad f4 23 00 	lea    0x23f4ad(%rip),%r9        # 257d30 <db_hash>
   18883:	0f b7 cb             	movzwl %bx,%ecx
   18886:	6a 10                	pushq  $0x10
   18888:	4c 89 ea             	mov    %r13,%rdx
   1888b:	45 0f b7 c6          	movzwl %r14w,%r8d
   1888f:	4c 89 e6             	mov    %r12,%rsi
   18892:	48 89 ef             	mov    %rbp,%rdi
   18895:	e8 8d de ff ff       	callq  16727 <bt_gatt_attr_read>
   1889a:	5a                   	pop    %rdx
   1889b:	59                   	pop    %rcx
}
   1889c:	5b                   	pop    %rbx
   1889d:	5d                   	pop    %rbp
   1889e:	41 5c                	pop    %r12
   188a0:	41 5d                	pop    %r13
   188a2:	41 5e                	pop    %r14
   188a4:	c3                   	retq   

00000000000188a5 <bt_gatt_store_ccc>:
{
   188a5:	41 55                	push   %r13
   188a7:	41 54                	push   %r12
	bt_gatt_foreach_attr(0x0001, 0xffff, ccc_save, &save);
   188a9:	48 8d 15 87 cf ff ff 	lea    -0x3079(%rip),%rdx        # 15837 <ccc_save>
{
   188b0:	55                   	push   %rbp
   188b1:	53                   	push   %rbx
   188b2:	49 89 f4             	mov    %rsi,%r12
   188b5:	89 fb                	mov    %edi,%ebx
   188b7:	48 81 ec 28 01 00 00 	sub    $0x128,%rsp
	bt_gatt_foreach_attr(0x0001, 0xffff, ccc_save, &save);
   188be:	4c 8d 6c 24 10       	lea    0x10(%rsp),%r13
	save.addr_with_id.addr = addr;
   188c3:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
	save.addr_with_id.id = id;
   188c8:	40 88 7c 24 18       	mov    %dil,0x18(%rsp)
	bt_gatt_foreach_attr(0x0001, 0xffff, ccc_save, &save);
   188cd:	be ff ff 00 00       	mov    $0xffff,%esi
   188d2:	bf 01 00 00 00       	mov    $0x1,%edi
	save.count = 0;
   188d7:	48 c7 84 24 e0 00 00 	movq   $0x0,0xe0(%rsp)
   188de:	00 00 00 00 00 
	bt_gatt_foreach_attr(0x0001, 0xffff, ccc_save, &save);
   188e3:	4c 89 e9             	mov    %r13,%rcx
   188e6:	48 8d ac 24 f4 00 00 	lea    0xf4(%rsp),%rbp
   188ed:	00 
{
   188ee:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   188f5:	00 00 
   188f7:	48 89 84 24 18 01 00 	mov    %rax,0x118(%rsp)
   188fe:	00 
   188ff:	31 c0                	xor    %eax,%eax
	bt_gatt_foreach_attr(0x0001, 0xffff, ccc_save, &save);
   18901:	e8 63 e3 ff ff       	callq  16c69 <bt_gatt_foreach_attr>
		bt_settings_encode_key(key, sizeof(key), "ccc", addr, NULL);
   18906:	45 31 c0             	xor    %r8d,%r8d
	if (id) {
   18909:	84 db                	test   %bl,%bl
   1890b:	74 22                	je     1892f <bt_gatt_store_ccc+0x8a>
		u8_to_dec(id_str, sizeof(id_str), id);
   1890d:	4c 8d 84 24 f0 00 00 	lea    0xf0(%rsp),%r8
   18914:	00 
   18915:	0f b6 d3             	movzbl %bl,%edx
   18918:	be 04 00 00 00       	mov    $0x4,%esi
   1891d:	4c 89 c7             	mov    %r8,%rdi
   18920:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
   18925:	e8 61 ce fe ff       	callq  578b <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "ccc", addr, id_str);
   1892a:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
		bt_settings_encode_key(key, sizeof(key), "ccc", addr, NULL);
   1892f:	48 8d 15 71 a7 01 00 	lea    0x1a771(%rip),%rdx        # 330a7 <__func__.5785+0x243f>
   18936:	be 24 00 00 00       	mov    $0x24,%esi
   1893b:	4c 89 e1             	mov    %r12,%rcx
   1893e:	48 89 ef             	mov    %rbp,%rdi
   18941:	e8 be 49 ff ff       	callq  d304 <bt_settings_encode_key>
	if (save.count) {
   18946:	48 8b 94 24 e0 00 00 	mov    0xe0(%rsp),%rdx
   1894d:	00 
		str = NULL;
   1894e:	31 f6                	xor    %esi,%esi
	if (save.count) {
   18950:	48 85 d2             	test   %rdx,%rdx
   18953:	74 08                	je     1895d <bt_gatt_store_ccc+0xb8>
		str = (char *)save.store;
   18955:	49 8d 75 10          	lea    0x10(%r13),%rsi
		len = save.count * sizeof(*save.store);
   18959:	48 c1 e2 02          	shl    $0x2,%rdx
	err = settings_save_one(key, str, len);
   1895d:	48 89 ef             	mov    %rbp,%rdi
   18960:	e8 15 fa fe ff       	callq  837a <settings_save_one>
	if (err) {
   18965:	85 c0                	test   %eax,%eax
   18967:	74 2f                	je     18998 <bt_gatt_store_ccc+0xf3>
   18969:	48 8d 15 50 1a 22 00 	lea    0x221a50(%rip),%rdx        # 23a3c0 <log_const_bt_gatt>
   18970:	48 2b 15 d9 d5 21 00 	sub    0x21d5d9(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Failed to store CCCs (err %d)", err);
   18977:	48 8d 3d e8 a7 01 00 	lea    0x1a7e8(%rip),%rdi        # 33166 <__func__.5785+0x24fe>
   1897e:	48 63 f0             	movslq %eax,%rsi
   18981:	89 44 24 08          	mov    %eax,0x8(%rsp)
   18985:	48 c1 ea 04          	shr    $0x4,%rdx
   18989:	c1 e2 06             	shl    $0x6,%edx
   1898c:	83 ca 01             	or     $0x1,%edx
   1898f:	e8 61 e9 fe ff       	callq  72f5 <log_1>
   18994:	8b 44 24 08          	mov    0x8(%rsp),%eax
}
   18998:	48 8b 8c 24 18 01 00 	mov    0x118(%rsp),%rcx
   1899f:	00 
   189a0:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   189a7:	00 00 
   189a9:	74 05                	je     189b0 <bt_gatt_store_ccc+0x10b>
   189ab:	e8 90 bc fe ff       	callq  4640 <__stack_chk_fail@plt>
   189b0:	48 81 c4 28 01 00 00 	add    $0x128,%rsp
   189b7:	5b                   	pop    %rbx
   189b8:	5d                   	pop    %rbp
   189b9:	41 5c                	pop    %r12
   189bb:	41 5d                	pop    %r13
   189bd:	c3                   	retq   

00000000000189be <bt_gatt_disconnected>:

	return 0;
}

void bt_gatt_disconnected(struct bt_conn *conn)
{
   189be:	41 57                	push   %r15
   189c0:	41 56                	push   %r14
	BT_DBG("conn %p", conn);
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
   189c2:	48 8d 15 94 db ff ff 	lea    -0x246c(%rip),%rdx        # 1655d <disconnected_cb>
{
   189c9:	41 55                	push   %r13
   189cb:	41 54                	push   %r12
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
   189cd:	48 89 f9             	mov    %rdi,%rcx
{
   189d0:	55                   	push   %rbp
   189d1:	53                   	push   %rbx
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
   189d2:	be ff ff 00 00       	mov    $0xffff,%esi
{
   189d7:	48 89 fb             	mov    %rdi,%rbx
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
   189da:	bf 01 00 00 00       	mov    $0x1,%edi
{
   189df:	48 83 ec 58          	sub    $0x58,%rsp
		k_delayed_work_cancel(&gatt_ccc_store.work);
	}
#endif

	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   189e3:	48 8d ab d8 00 00 00 	lea    0xd8(%rbx),%rbp
{
   189ea:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   189f1:	00 00 
   189f3:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
   189f8:	31 c0                	xor    %eax,%eax
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
   189fa:	e8 6a e2 ff ff       	callq  16c69 <bt_gatt_foreach_attr>
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   189ff:	0f b6 7b 08          	movzbl 0x8(%rbx),%edi
   18a03:	48 89 ee             	mov    %rbp,%rsi
   18a06:	e8 68 79 ff ff       	callq  10373 <bt_addr_le_is_bonded>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
   18a0b:	84 c0                	test   %al,%al
   18a0d:	0f 84 bf 00 00 00    	je     18ad2 <bt_gatt_disconnected+0x114>
		bt_gatt_store_ccc(conn->id, &conn->le.dst);
   18a13:	0f b6 7b 08          	movzbl 0x8(%rbx),%edi
   18a17:	48 89 ee             	mov    %rbp,%rsi
   18a1a:	4c 8d 6c 24 24       	lea    0x24(%rsp),%r13
   18a1f:	e8 81 fe ff ff       	callq  188a5 <bt_gatt_store_ccc>
	cfg = find_cf_cfg(conn);
   18a24:	48 89 df             	mov    %rbx,%rdi
   18a27:	e8 bb c7 ff ff       	callq  151e7 <find_cf_cfg>
	if (!cfg) {
   18a2c:	48 85 c0             	test   %rax,%rax
   18a2f:	74 48                	je     18a79 <bt_gatt_disconnected+0xbb>
		if (conn->id) {
   18a31:	0f b6 53 08          	movzbl 0x8(%rbx),%edx
		str = (char *)cfg->data;
   18a35:	4c 8d 60 08          	lea    0x8(%rax),%r12
		if (conn->id) {
   18a39:	84 d2                	test   %dl,%dl
   18a3b:	0f 84 c7 01 00 00    	je     18c08 <bt_gatt_disconnected+0x24a>
			u8_to_dec(id_str, sizeof(id_str), conn->id);
   18a41:	4c 8d 44 24 20       	lea    0x20(%rsp),%r8
   18a46:	be 04 00 00 00       	mov    $0x4,%esi
   18a4b:	4c 89 c7             	mov    %r8,%rdi
   18a4e:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
   18a53:	e8 33 cd fe ff       	callq  578b <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "cf",
   18a58:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
   18a5d:	48 8d 15 4c a7 01 00 	lea    0x1a74c(%rip),%rdx        # 331b0 <__func__.5785+0x2548>
   18a64:	48 89 e9             	mov    %rbp,%rcx
   18a67:	be 24 00 00 00       	mov    $0x24,%esi
   18a6c:	4c 89 ef             	mov    %r13,%rdi
   18a6f:	e8 90 48 ff ff       	callq  d304 <bt_settings_encode_key>
   18a74:	e9 8f 01 00 00       	jmpq   18c08 <bt_gatt_disconnected+0x24a>
		len = 0;
   18a79:	45 31 f6             	xor    %r14d,%r14d
		str = NULL;
   18a7c:	45 31 e4             	xor    %r12d,%r12d
		bt_settings_encode_key(key, sizeof(key), "cf",
   18a7f:	48 8d 15 2a a7 01 00 	lea    0x1a72a(%rip),%rdx        # 331b0 <__func__.5785+0x2548>
   18a86:	45 31 c0             	xor    %r8d,%r8d
   18a89:	48 89 e9             	mov    %rbp,%rcx
   18a8c:	be 24 00 00 00       	mov    $0x24,%esi
   18a91:	4c 89 ef             	mov    %r13,%rdi
   18a94:	e8 6b 48 ff ff       	callq  d304 <bt_settings_encode_key>
	err = settings_save_one(key, str, len);
   18a99:	4c 89 f2             	mov    %r14,%rdx
   18a9c:	4c 89 e6             	mov    %r12,%rsi
   18a9f:	4c 89 ef             	mov    %r13,%rdi
   18aa2:	e8 d3 f8 fe ff       	callq  837a <settings_save_one>
	if (err) {
   18aa7:	85 c0                	test   %eax,%eax
   18aa9:	74 27                	je     18ad2 <bt_gatt_disconnected+0x114>
   18aab:	48 8d 15 0e 19 22 00 	lea    0x22190e(%rip),%rdx        # 23a3c0 <log_const_bt_gatt>
   18ab2:	48 2b 15 97 d4 21 00 	sub    0x21d497(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		BT_ERR("Failed to store Client Features (err %d)", err);
   18ab9:	48 8d 3d c4 a6 01 00 	lea    0x1a6c4(%rip),%rdi        # 33184 <__func__.5785+0x251c>
   18ac0:	48 63 f0             	movslq %eax,%rsi
   18ac3:	48 c1 ea 04          	shr    $0x4,%rdx
   18ac7:	c1 e2 06             	shl    $0x6,%edx
   18aca:	83 ca 01             	or     $0x1,%edx
   18acd:	e8 23 e8 fe ff       	callq  72f5 <log_1>
		bt_gatt_store_cf(conn);
	}

	/* Make sure to clear the CCC entry when using lazy loading */
	if (IS_ENABLED(CONFIG_BT_SETTINGS_CCC_LAZY_LOADING) &&
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   18ad2:	0f b6 7b 08          	movzbl 0x8(%rbx),%edi
   18ad6:	48 89 ee             	mov    %rbp,%rsi
   18ad9:	e8 95 78 ff ff       	callq  10373 <bt_addr_le_is_bonded>
	if (IS_ENABLED(CONFIG_BT_SETTINGS_CCC_LAZY_LOADING) &&
   18ade:	84 c0                	test   %al,%al
   18ae0:	74 27                	je     18b09 <bt_gatt_disconnected+0x14b>
		struct addr_with_id addr_with_id = {
   18ae2:	8a 43 08             	mov    0x8(%rbx),%al
			.addr = &conn->le.dst,
			.id = conn->id,
		};
		bt_gatt_foreach_attr(0x0001, 0xffff,
   18ae5:	48 8d 4c 24 10       	lea    0x10(%rsp),%rcx
   18aea:	48 8d 15 9d cd ff ff 	lea    -0x3263(%rip),%rdx        # 1588e <remove_peer_from_attr>
   18af1:	be ff ff 00 00       	mov    $0xffff,%esi
   18af6:	bf 01 00 00 00       	mov    $0x1,%edi
		struct addr_with_id addr_with_id = {
   18afb:	48 89 6c 24 10       	mov    %rbp,0x10(%rsp)
   18b00:	88 44 24 18          	mov    %al,0x18(%rsp)
		bt_gatt_foreach_attr(0x0001, 0xffff,
   18b04:	e8 60 e1 ff ff       	callq  16c69 <bt_gatt_foreach_attr>
	sub = gatt_sub_find(conn);
   18b09:	48 89 df             	mov    %rbx,%rdi
   18b0c:	e8 61 c9 ff ff       	callq  15472 <gatt_sub_find>
	if (!sub) {
   18b11:	48 85 c0             	test   %rax,%rax
	sub = gatt_sub_find(conn);
   18b14:	49 89 c5             	mov    %rax,%r13
	if (!sub) {
   18b17:	0f 84 a3 00 00 00    	je     18bc0 <bt_gatt_disconnected+0x202>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   18b1d:	48 8b 40 08          	mov    0x8(%rax),%rax
   18b21:	48 85 c0             	test   %rax,%rax
   18b24:	0f 84 96 00 00 00    	je     18bc0 <bt_gatt_disconnected+0x202>
   18b2a:	49 89 c7             	mov    %rax,%r15
   18b2d:	49 83 ef 20          	sub    $0x20,%r15
   18b31:	0f 84 89 00 00 00    	je     18bc0 <bt_gatt_disconnected+0x202>
   18b37:	48 8b 00             	mov    (%rax),%rax
   18b3a:	45 31 e4             	xor    %r12d,%r12d
   18b3d:	48 85 c0             	test   %rax,%rax
   18b40:	74 04                	je     18b46 <bt_gatt_disconnected+0x188>
   18b42:	4c 8d 60 e0          	lea    -0x20(%rax),%r12
	bt_addr_le_copy(&sub->peer, &conn->le.dst);
   18b46:	49 8d 45 01          	lea    0x1(%r13),%rax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   18b4a:	45 31 f6             	xor    %r14d,%r14d
	bt_addr_le_copy(&sub->peer, &conn->le.dst);
   18b4d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
		if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst) ||
   18b52:	0f b6 7b 08          	movzbl 0x8(%rbx),%edi
   18b56:	48 89 ee             	mov    %rbp,%rsi
   18b59:	e8 15 78 ff ff       	callq  10373 <bt_addr_le_is_bonded>
   18b5e:	84 c0                	test   %al,%al
   18b60:	75 1a                	jne    18b7c <bt_gatt_disconnected+0x1be>
			params->value = 0U;
   18b62:	66 41 c7 47 14 00 00 	movw   $0x0,0x14(%r15)
			gatt_sub_remove(conn, sub, prev, params);
   18b69:	4c 89 f9             	mov    %r15,%rcx
   18b6c:	4c 89 f2             	mov    %r14,%rdx
   18b6f:	4c 89 ee             	mov    %r13,%rsi
   18b72:	48 89 df             	mov    %rbx,%rdi
   18b75:	e8 f1 d3 ff ff       	callq  15f6b <gatt_sub_remove>
   18b7a:	eb 27                	jmp    18ba3 <bt_gatt_disconnected+0x1e5>
		    (atomic_test_bit(params->flags,
   18b7c:	49 8d 7f 18          	lea    0x18(%r15),%rdi
   18b80:	31 f6                	xor    %esi,%esi
   18b82:	e8 3e ca ff ff       	callq  155c5 <atomic_test_bit>
		if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst) ||
   18b87:	84 c0                	test   %al,%al
   18b89:	75 d7                	jne    18b62 <bt_gatt_disconnected+0x1a4>
	if (sub->peer.type == BT_ADDR_LE_PUBLIC) {
   18b8b:	41 80 7d 01 00       	cmpb   $0x0,0x1(%r13)
   18b90:	74 0d                	je     18b9f <bt_gatt_disconnected+0x1e1>
	bt_addr_le_copy(&sub->peer, &conn->le.dst);
   18b92:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   18b97:	48 89 ee             	mov    %rbp,%rsi
   18b9a:	e8 fd c3 ff ff       	callq  14f9c <bt_addr_le_copy>
			prev = &params->node;
   18b9f:	4d 8d 77 20          	lea    0x20(%r15),%r14
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   18ba3:	4d 85 e4             	test   %r12,%r12
   18ba6:	74 18                	je     18bc0 <bt_gatt_disconnected+0x202>
   18ba8:	49 8b 54 24 20       	mov    0x20(%r12),%rdx
   18bad:	31 c0                	xor    %eax,%eax
   18baf:	48 85 d2             	test   %rdx,%rdx
   18bb2:	74 04                	je     18bb8 <bt_gatt_disconnected+0x1fa>
   18bb4:	48 8d 42 e0          	lea    -0x20(%rdx),%rax
   18bb8:	4d 89 e7             	mov    %r12,%r15
   18bbb:	49 89 c4             	mov    %rax,%r12
   18bbe:	eb 92                	jmp    18b52 <bt_gatt_disconnected+0x194>
	cfg = find_cf_cfg(conn);
   18bc0:	48 89 df             	mov    %rbx,%rdi
   18bc3:	e8 1f c6 ff ff       	callq  151e7 <find_cf_cfg>
	if (!cfg) {
   18bc8:	48 85 c0             	test   %rax,%rax
	cfg = find_cf_cfg(conn);
   18bcb:	49 89 c4             	mov    %rax,%r12
	if (!cfg) {
   18bce:	74 4d                	je     18c1d <bt_gatt_disconnected+0x25f>
	if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   18bd0:	0f b6 7b 08          	movzbl 0x8(%rbx),%edi
   18bd4:	48 89 ee             	mov    %rbp,%rsi
   18bd7:	e8 97 77 ff ff       	callq  10373 <bt_addr_le_is_bonded>
   18bdc:	84 c0                	test   %al,%al
   18bde:	75 0a                	jne    18bea <bt_gatt_disconnected+0x22c>
		clear_cf_cfg(cfg);
   18be0:	4c 89 e7             	mov    %r12,%rdi
   18be3:	e8 e5 cc ff ff       	callq  158cd <clear_cf_cfg>
   18be8:	eb 33                	jmp    18c1d <bt_gatt_disconnected+0x25f>
		bt_addr_le_copy(&cfg->peer, &conn->le.dst);
   18bea:	49 8d 7c 24 01       	lea    0x1(%r12),%rdi
   18bef:	48 89 ee             	mov    %rbp,%rsi
   18bf2:	e8 a5 c3 ff ff       	callq  14f9c <bt_addr_le_copy>
		atomic_clear_bit(cfg->flags, CF_OUT_OF_SYNC);
   18bf7:	49 8d 7c 24 0c       	lea    0xc(%r12),%rdi
   18bfc:	be fd ff ff ff       	mov    $0xfffffffd,%esi
   18c01:	e8 ca c9 ff ff       	callq  155d0 <atomic_and>
#endif /* CONFIG_BT_GATT_CLIENT */

#if defined(CONFIG_BT_GATT_CACHING)
	remove_cf_cfg(conn);
#endif
}
   18c06:	eb 15                	jmp    18c1d <bt_gatt_disconnected+0x25f>
	if (!cfg || !conn->id) {
   18c08:	80 7b 08 00          	cmpb   $0x0,0x8(%rbx)
   18c0c:	41 be 01 00 00 00    	mov    $0x1,%r14d
   18c12:	0f 84 67 fe ff ff    	je     18a7f <bt_gatt_disconnected+0xc1>
   18c18:	e9 7c fe ff ff       	jmpq   18a99 <bt_gatt_disconnected+0xdb>
}
   18c1d:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
   18c22:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   18c29:	00 00 
   18c2b:	74 05                	je     18c32 <bt_gatt_disconnected+0x274>
   18c2d:	e8 0e ba fe ff       	callq  4640 <__stack_chk_fail@plt>
   18c32:	48 83 c4 58          	add    $0x58,%rsp
   18c36:	5b                   	pop    %rbx
   18c37:	5d                   	pop    %rbp
   18c38:	41 5c                	pop    %r12
   18c3a:	41 5d                	pop    %r13
   18c3c:	41 5e                	pop    %r14
   18c3e:	41 5f                	pop    %r15
   18c40:	c3                   	retq   

0000000000018c41 <bt_smp_accept>:
	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
		struct bt_l2cap_le_chan *smp = &bt_smp_pool[i];

		if (smp->chan.conn) {
   18c41:	48 83 3d 17 e9 23 00 	cmpq   $0x0,0x23e917(%rip)        # 257560 <bt_smp_pool>
   18c48:	00 
   18c49:	75 1b                	jne    18c66 <bt_smp_accept+0x25>
			continue;
		}

		smp->chan.ops = &ops;
   18c4b:	48 8d 05 ce c9 21 00 	lea    0x21c9ce(%rip),%rax        # 235620 <ops.8040>
   18c52:	48 89 05 0f e9 23 00 	mov    %rax,0x23e90f(%rip)        # 257568 <bt_smp_pool+0x8>

		*chan = &smp->chan;
   18c59:	48 8d 05 00 e9 23 00 	lea    0x23e900(%rip),%rax        # 257560 <bt_smp_pool>
   18c60:	48 89 06             	mov    %rax,(%rsi)

		return 0;
   18c63:	31 c0                	xor    %eax,%eax
	}

	BT_ERR("No available SMP context for conn %p", conn);

	return -ENOMEM;
}
   18c65:	c3                   	retq   
{
   18c66:	48 83 ec 08          	sub    $0x8,%rsp
   18c6a:	48 8d 15 8f 17 22 00 	lea    0x22178f(%rip),%rdx        # 23a400 <log_const_bt_smp>
   18c71:	48 2b 15 d8 d2 21 00 	sub    0x21d2d8(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
   18c78:	48 89 fe             	mov    %rdi,%rsi
	BT_ERR("No available SMP context for conn %p", conn);
   18c7b:	48 8d 3d 3f a5 01 00 	lea    0x1a53f(%rip),%rdi        # 331c1 <__func__.5785+0x2559>
   18c82:	48 c1 ea 04          	shr    $0x4,%rdx
   18c86:	c1 e2 06             	shl    $0x6,%edx
   18c89:	83 ca 01             	or     $0x1,%edx
   18c8c:	e8 64 e6 fe ff       	callq  72f5 <log_1>
	return -ENOMEM;
   18c91:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
}
   18c96:	5a                   	pop    %rdx
   18c97:	c3                   	retq   

0000000000018c98 <bt_smp_recv>:
{
   18c98:	41 54                	push   %r12
   18c9a:	55                   	push   %rbp
	buf = bt_l2cap_create_pdu(NULL, 0);
   18c9b:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
{
   18c9f:	53                   	push   %rbx
	buf = bt_l2cap_create_pdu(NULL, 0);
   18ca0:	31 f6                	xor    %esi,%esi
	struct bt_conn *conn = chan->conn;
   18ca2:	4c 8b 27             	mov    (%rdi),%r12
	buf = bt_l2cap_create_pdu(NULL, 0);
   18ca5:	31 ff                	xor    %edi,%edi
   18ca7:	e8 1f 96 ff ff       	callq  122cb <bt_l2cap_create_pdu_timeout>
   18cac:	48 8d 68 10          	lea    0x10(%rax),%rbp
   18cb0:	be 01 00 00 00       	mov    $0x1,%esi
   18cb5:	48 89 c3             	mov    %rax,%rbx
   18cb8:	48 89 ef             	mov    %rbp,%rdi
   18cbb:	e8 c9 03 00 00       	callq  19089 <net_buf_simple_add>
   18cc0:	48 89 ef             	mov    %rbp,%rdi
   18cc3:	be 01 00 00 00       	mov    $0x1,%esi
	hdr->code = BT_SMP_CMD_PAIRING_FAIL;
   18cc8:	c6 00 05             	movb   $0x5,(%rax)
   18ccb:	e8 b9 03 00 00       	callq  19089 <net_buf_simple_add>
   18cd0:	48 89 da             	mov    %rbx,%rdx
   18cd3:	4c 89 e7             	mov    %r12,%rdi
	rsp->reason = BT_SMP_ERR_PAIRING_NOTSUPP;
   18cd6:	c6 00 05             	movb   $0x5,(%rax)
   18cd9:	45 31 c0             	xor    %r8d,%r8d
   18cdc:	31 c9                	xor    %ecx,%ecx
   18cde:	be 06 00 00 00       	mov    $0x6,%esi
   18ce3:	e8 63 96 ff ff       	callq  1234b <bt_l2cap_send_cb>
}
   18ce8:	5b                   	pop    %rbx
   18ce9:	31 c0                	xor    %eax,%eax
   18ceb:	5d                   	pop    %rbp
   18cec:	41 5c                	pop    %r12
   18cee:	c3                   	retq   

0000000000018cef <bt_smp_sign>:
   18cef:	b8 a1 ff ff ff       	mov    $0xffffffa1,%eax
   18cf4:	c3                   	retq   

0000000000018cf5 <bt_smp_init>:
BT_L2CAP_CHANNEL_DEFINE(smp_fixed_chan, BT_L2CAP_CID_SMP, bt_smp_accept, NULL);

int bt_smp_init(void)
{
	return 0;
}
   18cf5:	31 c0                	xor    %eax,%eax
   18cf7:	c3                   	retq   

0000000000018cf8 <fixed_data_unref>:
}

static void fixed_data_unref(struct net_buf *buf, uint8_t *data)
{
	/* Nothing needed for fixed-size data pools */
}
   18cf8:	c3                   	retq   

0000000000018cf9 <net_buf_pool_get>:
	return &_net_buf_pool_list[id];
   18cf9:	48 63 c7             	movslq %edi,%rax
   18cfc:	48 6b c0 50          	imul   $0x50,%rax,%rax
   18d00:	48 03 05 79 d2 21 00 	add    0x21d279(%rip),%rax        # 235f80 <_GLOBAL_OFFSET_TABLE_+0x2a0>
}
   18d07:	c3                   	retq   

0000000000018d08 <data_alloc>:
};

#endif /* CONFIG_HEAP_MEM_POOL_SIZE > 0 */

static uint8_t *data_alloc(struct net_buf *buf, size_t *size, k_timeout_t timeout)
{
   18d08:	53                   	push   %rbx
   18d09:	48 89 fb             	mov    %rdi,%rbx
   18d0c:	48 83 ec 10          	sub    $0x10,%rsp
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   18d10:	0f b6 7f 0a          	movzbl 0xa(%rdi),%edi
{
   18d14:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
   18d19:	48 89 14 24          	mov    %rdx,(%rsp)
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   18d1d:	e8 d7 ff ff ff       	callq  18cf9 <net_buf_pool_get>

	return pool->alloc->cb->alloc(buf, size, timeout);
   18d22:	48 8b 40 40          	mov    0x40(%rax),%rax
   18d26:	48 8b 14 24          	mov    (%rsp),%rdx
   18d2a:	48 89 df             	mov    %rbx,%rdi
   18d2d:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   18d32:	48 8b 00             	mov    (%rax),%rax
   18d35:	48 8b 00             	mov    (%rax),%rax
}
   18d38:	48 83 c4 10          	add    $0x10,%rsp
   18d3c:	5b                   	pop    %rbx
	return pool->alloc->cb->alloc(buf, size, timeout);
   18d3d:	ff e0                	jmpq   *%rax

0000000000018d3f <net_buf_destroy>:
{
   18d3f:	53                   	push   %rbx
   18d40:	48 89 fb             	mov    %rdi,%rbx
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   18d43:	0f b6 7f 0a          	movzbl 0xa(%rdi),%edi
   18d47:	e8 ad ff ff ff       	callq  18cf9 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
   18d4c:	48 89 de             	mov    %rbx,%rsi
   18d4f:	48 89 c7             	mov    %rax,%rdi
}
   18d52:	5b                   	pop    %rbx
	k_lifo_put(&pool->free, buf);
   18d53:	e9 e5 25 01 00       	jmpq   2b33d <k_queue_prepend>

0000000000018d58 <net_buf_id>:
{
   18d58:	53                   	push   %rbx
   18d59:	48 89 fb             	mov    %rdi,%rbx
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   18d5c:	0f b6 7f 0a          	movzbl 0xa(%rdi),%edi
   18d60:	e8 94 ff ff ff       	callq  18cf9 <net_buf_pool_get>
	return buf - pool->__bufs;
   18d65:	48 2b 58 48          	sub    0x48(%rax),%rbx
   18d69:	48 89 d8             	mov    %rbx,%rax
   18d6c:	48 bb ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rbx
   18d73:	aa aa aa 
   18d76:	48 c1 f8 04          	sar    $0x4,%rax
   18d7a:	48 0f af c3          	imul   %rbx,%rax
}
   18d7e:	5b                   	pop    %rbx
   18d7f:	c3                   	retq   

0000000000018d80 <fixed_data_alloc>:
{
   18d80:	41 54                	push   %r12
   18d82:	55                   	push   %rbp
   18d83:	48 89 fd             	mov    %rdi,%rbp
   18d86:	53                   	push   %rbx
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   18d87:	0f b6 7f 0a          	movzbl 0xa(%rdi),%edi
{
   18d8b:	48 89 f3             	mov    %rsi,%rbx
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   18d8e:	e8 66 ff ff ff       	callq  18cf9 <net_buf_pool_get>
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   18d93:	48 8b 40 40          	mov    0x40(%rax),%rax
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
   18d97:	48 89 ef             	mov    %rbp,%rdi
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   18d9a:	48 8b 50 08          	mov    0x8(%rax),%rdx
	*size = MIN(fixed->data_size, *size);
   18d9e:	48 8b 02             	mov    (%rdx),%rax
   18da1:	48 39 03             	cmp    %rax,(%rbx)
   18da4:	48 0f 46 03          	cmovbe (%rbx),%rax
   18da8:	48 89 03             	mov    %rax,(%rbx)
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
   18dab:	4c 8b 22             	mov    (%rdx),%r12
   18dae:	48 8b 5a 08          	mov    0x8(%rdx),%rbx
   18db2:	e8 a1 ff ff ff       	callq  18d58 <net_buf_id>
   18db7:	48 98                	cltq   
   18db9:	49 0f af c4          	imul   %r12,%rax
   18dbd:	48 01 d8             	add    %rbx,%rax
}
   18dc0:	5b                   	pop    %rbx
   18dc1:	5d                   	pop    %rbp
   18dc2:	41 5c                	pop    %r12
   18dc4:	c3                   	retq   

0000000000018dc5 <net_buf_reset>:
	buf->data = buf->__buf;
   18dc5:	48 8b 47 20          	mov    0x20(%rdi),%rax
	buf->len  = 0U;
   18dc9:	66 c7 47 18 00 00    	movw   $0x0,0x18(%rdi)
	buf->data = buf->__buf;
   18dcf:	48 89 47 10          	mov    %rax,0x10(%rdi)
}
   18dd3:	c3                   	retq   

0000000000018dd4 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
   18dd4:	41 57                	push   %r15
   18dd6:	41 56                	push   %r14
   18dd8:	41 55                	push   %r13
   18dda:	41 54                	push   %r12
   18ddc:	49 89 fd             	mov    %rdi,%r13
   18ddf:	55                   	push   %rbp
   18de0:	53                   	push   %rbx
	uint64_t end = z_timeout_end_calc(timeout);
   18de1:	48 89 d7             	mov    %rdx,%rdi
{
   18de4:	48 89 d5             	mov    %rdx,%rbp
   18de7:	48 83 ec 18          	sub    $0x18,%rsp
   18deb:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	uint64_t end = z_timeout_end_calc(timeout);
   18df0:	e8 c3 39 01 00       	callq  2c7b8 <z_timeout_end_calc>
   18df5:	49 89 c4             	mov    %rax,%r12
	return posix_irq_lock();
   18df8:	e8 95 31 ff ff       	callq  bf92 <posix_irq_lock>
   18dfd:	41 89 c7             	mov    %eax,%r15d
	key = irq_lock();

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
   18e00:	66 41 8b 45 32       	mov    0x32(%r13),%ax
   18e05:	66 85 c0             	test   %ax,%ax
   18e08:	74 6b                	je     18e75 <net_buf_alloc_len+0xa1>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
   18e0a:	66 41 3b 45 30       	cmp    0x30(%r13),%ax
   18e0f:	73 1c                	jae    18e2d <net_buf_alloc_len+0x59>
	return z_impl_k_queue_get(queue, timeout);
   18e11:	31 f6                	xor    %esi,%esi
   18e13:	4c 89 ef             	mov    %r13,%rdi
   18e16:	e8 d9 25 01 00       	callq  2b3f4 <z_impl_k_queue_get>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
   18e1b:	48 85 c0             	test   %rax,%rax
   18e1e:	48 89 c3             	mov    %rax,%rbx
   18e21:	74 0a                	je     18e2d <net_buf_alloc_len+0x59>
	posix_irq_unlock(key);
   18e23:	44 89 ff             	mov    %r15d,%edi
   18e26:	e8 71 31 ff ff       	callq  bf9c <posix_irq_unlock>
   18e2b:	eb 63                	jmp    18e90 <net_buf_alloc_len+0xbc>
				irq_unlock(key);
				goto success;
			}
		}

		uninit_count = pool->uninit_count--;
   18e2d:	45 0f b7 75 32       	movzwl 0x32(%r13),%r14d
   18e32:	44 89 ff             	mov    %r15d,%edi
   18e35:	41 8d 46 ff          	lea    -0x1(%r14),%eax
   18e39:	66 41 89 45 32       	mov    %ax,0x32(%r13)
   18e3e:	e8 59 31 ff ff       	callq  bf9c <posix_irq_unlock>
	buf = &pool->__bufs[pool->buf_count - uninit_count];
   18e43:	41 0f b7 5d 30       	movzwl 0x30(%r13),%ebx
	return pool - _net_buf_pool_list;
   18e48:	48 b8 cd cc cc cc cc 	movabs $0xcccccccccccccccd,%rax
   18e4f:	cc cc cc 
	buf = &pool->__bufs[pool->buf_count - uninit_count];
   18e52:	44 29 f3             	sub    %r14d,%ebx
   18e55:	48 63 db             	movslq %ebx,%rbx
   18e58:	48 6b db 30          	imul   $0x30,%rbx,%rbx
   18e5c:	49 03 5d 48          	add    0x48(%r13),%rbx
	return pool - _net_buf_pool_list;
   18e60:	4c 2b 2d 19 d1 21 00 	sub    0x21d119(%rip),%r13        # 235f80 <_GLOBAL_OFFSET_TABLE_+0x2a0>
   18e67:	49 c1 fd 04          	sar    $0x4,%r13
   18e6b:	4c 0f af e8          	imul   %rax,%r13
	buf->pool_id = pool_id(pool);
   18e6f:	44 88 6b 0a          	mov    %r13b,0xa(%rbx)
		irq_unlock(key);

		buf = pool_get_uninit(pool, uninit_count);
		goto success;
   18e73:	eb 1b                	jmp    18e90 <net_buf_alloc_len+0xbc>
   18e75:	44 89 ff             	mov    %r15d,%edi
   18e78:	e8 1f 31 ff ff       	callq  bf9c <posix_irq_unlock>
   18e7d:	48 89 ee             	mov    %rbp,%rsi
   18e80:	4c 89 ef             	mov    %r13,%rdi
   18e83:	e8 6c 25 01 00       	callq  2b3f4 <z_impl_k_queue_get>
		buf = k_lifo_get(&pool->free, timeout);
	}
#else
	buf = k_lifo_get(&pool->free, timeout);
#endif
	if (!buf) {
   18e88:	48 85 c0             	test   %rax,%rax
   18e8b:	48 89 c3             	mov    %rax,%rbx
   18e8e:	74 72                	je     18f02 <net_buf_alloc_len+0x12e>
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
   18e90:	48 83 7c 24 08 00    	cmpq   $0x0,0x8(%rsp)
   18e96:	74 44                	je     18edc <net_buf_alloc_len+0x108>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
   18e98:	48 85 ed             	test   %rbp,%rbp
   18e9b:	74 1a                	je     18eb7 <net_buf_alloc_len+0xe3>
   18e9d:	48 83 fd ff          	cmp    $0xffffffffffffffff,%rbp
   18ea1:	74 14                	je     18eb7 <net_buf_alloc_len+0xe3>
   18ea3:	4c 89 e5             	mov    %r12,%rbp
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			int64_t remaining = end - z_tick_get();
   18ea6:	e8 d4 38 01 00       	callq  2c77f <z_tick_get>
   18eab:	48 29 c5             	sub    %rax,%rbp
   18eae:	b8 00 00 00 00       	mov    $0x0,%eax
   18eb3:	48 0f 48 e8          	cmovs  %rax,%rbp
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
   18eb7:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
   18ebc:	48 89 ea             	mov    %rbp,%rdx
   18ebf:	48 89 df             	mov    %rbx,%rdi
   18ec2:	e8 41 fe ff ff       	callq  18d08 <data_alloc>
		if (!buf->__buf) {
   18ec7:	48 85 c0             	test   %rax,%rax
		buf->__buf = data_alloc(buf, &size, timeout);
   18eca:	48 89 43 20          	mov    %rax,0x20(%rbx)
		if (!buf->__buf) {
   18ece:	75 14                	jne    18ee4 <net_buf_alloc_len+0x110>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
   18ed0:	48 89 df             	mov    %rbx,%rdi
			return NULL;
   18ed3:	31 db                	xor    %ebx,%ebx
			net_buf_destroy(buf);
   18ed5:	e8 65 fe ff ff       	callq  18d3f <net_buf_destroy>
			return NULL;
   18eda:	eb 26                	jmp    18f02 <net_buf_alloc_len+0x12e>
		}

		NET_BUF_ASSERT(req_size <= size);
	} else {
		buf->__buf = NULL;
   18edc:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
   18ee3:	00 
	}

	buf->ref   = 1U;
	buf->flags = 0U;
	buf->frags = NULL;
   18ee4:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
	buf->size  = size;
   18eeb:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
	net_buf_reset(buf);
   18ef0:	48 89 df             	mov    %rbx,%rdi
	buf->frags = NULL;
   18ef3:	66 c7 43 08 01 00    	movw   $0x1,0x8(%rbx)
	buf->size  = size;
   18ef9:	66 89 43 1a          	mov    %ax,0x1a(%rbx)
	net_buf_reset(buf);
   18efd:	e8 c3 fe ff ff       	callq  18dc5 <net_buf_reset>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	atomic_dec(&pool->avail_count);
	__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);
#endif
	return buf;
}
   18f02:	48 83 c4 18          	add    $0x18,%rsp
   18f06:	48 89 d8             	mov    %rbx,%rax
   18f09:	5b                   	pop    %rbx
   18f0a:	5d                   	pop    %rbp
   18f0b:	41 5c                	pop    %r12
   18f0d:	41 5d                	pop    %r13
   18f0f:	41 5e                	pop    %r14
   18f11:	41 5f                	pop    %r15
   18f13:	c3                   	retq   

0000000000018f14 <net_buf_alloc_fixed>:
}
#else
struct net_buf *net_buf_alloc_fixed(struct net_buf_pool *pool,
				    k_timeout_t timeout)
{
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   18f14:	48 8b 47 40          	mov    0x40(%rdi),%rax
{
   18f18:	48 89 f2             	mov    %rsi,%rdx

	return net_buf_alloc_len(pool, fixed->data_size, timeout);
   18f1b:	48 8b 40 08          	mov    0x8(%rax),%rax
   18f1f:	48 8b 30             	mov    (%rax),%rsi
   18f22:	e9 ad fe ff ff       	jmpq   18dd4 <net_buf_alloc_len>

0000000000018f27 <net_buf_get>:
struct net_buf *net_buf_get_debug(struct k_fifo *fifo, k_timeout_t timeout,
				  const char *func, int line)
#else
struct net_buf *net_buf_get(struct k_fifo *fifo, k_timeout_t timeout)
#endif
{
   18f27:	41 54                	push   %r12
   18f29:	49 89 fc             	mov    %rdi,%r12
   18f2c:	55                   	push   %rbp
   18f2d:	53                   	push   %rbx
   18f2e:	e8 c1 24 01 00       	callq  2b3f4 <z_impl_k_queue_get>
	struct net_buf *buf, *frag;

	NET_BUF_DBG("%s():%d: fifo %p", func, line, fifo);

	buf = k_fifo_get(fifo, timeout);
	if (!buf) {
   18f33:	48 85 c0             	test   %rax,%rax
   18f36:	48 89 c5             	mov    %rax,%rbp
   18f39:	48 89 c3             	mov    %rax,%rbx
   18f3c:	74 23                	je     18f61 <net_buf_get+0x3a>
	}

	NET_BUF_DBG("%s():%d: buf %p fifo %p", func, line, buf, fifo);

	/* Get any fragments belonging to this buffer */
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   18f3e:	f6 43 09 01          	testb  $0x1,0x9(%rbx)
   18f42:	74 16                	je     18f5a <net_buf_get+0x33>
   18f44:	31 f6                	xor    %esi,%esi
   18f46:	4c 89 e7             	mov    %r12,%rdi
   18f49:	e8 a6 24 01 00       	callq  2b3f4 <z_impl_k_queue_get>
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
		__ASSERT_NO_MSG(frag->frags);

		/* The fragments flag is only for FIFO-internal usage */
		frag->flags &= ~NET_BUF_FRAGS;
   18f4e:	80 63 09 fe          	andb   $0xfe,0x9(%rbx)
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
   18f52:	48 89 03             	mov    %rax,(%rbx)
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   18f55:	48 89 c3             	mov    %rax,%rbx
   18f58:	eb e4                	jmp    18f3e <net_buf_get+0x17>
	}

	/* Mark the end of the fragment list */
	frag->frags = NULL;
   18f5a:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)

	return buf;
}
   18f61:	48 89 e8             	mov    %rbp,%rax
   18f64:	5b                   	pop    %rbx
   18f65:	5d                   	pop    %rbp
   18f66:	41 5c                	pop    %r12
   18f68:	c3                   	retq   

0000000000018f69 <net_buf_simple_init_with_data>:

void net_buf_simple_init_with_data(struct net_buf_simple *buf,
				   void *data, size_t size)
{
	buf->__buf = data;
   18f69:	48 89 77 10          	mov    %rsi,0x10(%rdi)
	buf->data  = data;
   18f6d:	48 89 37             	mov    %rsi,(%rdi)
	buf->size  = size;
   18f70:	66 89 57 0a          	mov    %dx,0xa(%rdi)
	buf->len   = size;
   18f74:	66 89 57 08          	mov    %dx,0x8(%rdi)
}
   18f78:	c3                   	retq   

0000000000018f79 <net_buf_simple_reserve>:
{
	__ASSERT_NO_MSG(buf);
	__ASSERT_NO_MSG(buf->len == 0U);
	NET_BUF_DBG("buf %p reserve %zu", buf, reserve);

	buf->data = buf->__buf + reserve;
   18f79:	48 03 77 10          	add    0x10(%rdi),%rsi
   18f7d:	48 89 37             	mov    %rsi,(%rdi)
}
   18f80:	c3                   	retq   

0000000000018f81 <net_buf_put>:
	struct net_buf *tail;

	__ASSERT_NO_MSG(fifo);
	__ASSERT_NO_MSG(buf);

	for (tail = buf; tail->frags; tail = tail->frags) {
   18f81:	48 89 f2             	mov    %rsi,%rdx
   18f84:	48 8b 02             	mov    (%rdx),%rax
   18f87:	48 85 c0             	test   %rax,%rax
   18f8a:	74 09                	je     18f95 <net_buf_put+0x14>
		tail->flags |= NET_BUF_FRAGS;
   18f8c:	80 4a 09 01          	orb    $0x1,0x9(%rdx)
   18f90:	48 89 c2             	mov    %rax,%rdx
   18f93:	eb ef                	jmp    18f84 <net_buf_put+0x3>
	}

	k_fifo_put_list(fifo, buf, tail);
   18f95:	e9 b2 23 01 00       	jmpq   2b34c <k_queue_append_list>

0000000000018f9a <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
   18f9a:	41 54                	push   %r12
   18f9c:	55                   	push   %rbp
   18f9d:	53                   	push   %rbx
   18f9e:	48 89 fb             	mov    %rdi,%rbx
	__ASSERT_NO_MSG(buf);

	while (buf) {
   18fa1:	48 85 db             	test   %rbx,%rbx
   18fa4:	74 6a                	je     19010 <net_buf_unref+0x76>
		}
#endif
		NET_BUF_DBG("buf %p ref %u pool_id %u frags %p", buf, buf->ref,
			    buf->pool_id, buf->frags);

		if (--buf->ref > 0) {
   18fa6:	fe 4b 08             	decb   0x8(%rbx)
		struct net_buf *frags = buf->frags;
   18fa9:	4c 8b 23             	mov    (%rbx),%r12
		if (--buf->ref > 0) {
   18fac:	75 62                	jne    19010 <net_buf_unref+0x76>
			return;
		}

		if (buf->__buf) {
   18fae:	48 8b 6b 20          	mov    0x20(%rbx),%rbp
   18fb2:	48 85 ed             	test   %rbp,%rbp
   18fb5:	74 27                	je     18fde <net_buf_unref+0x44>
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   18fb7:	0f b6 7b 0a          	movzbl 0xa(%rbx),%edi
   18fbb:	e8 39 fd ff ff       	callq  18cf9 <net_buf_pool_get>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
   18fc0:	f6 43 09 02          	testb  $0x2,0x9(%rbx)
   18fc4:	75 10                	jne    18fd6 <net_buf_unref+0x3c>
	pool->alloc->cb->unref(buf, data);
   18fc6:	48 8b 40 40          	mov    0x40(%rax),%rax
   18fca:	48 89 ee             	mov    %rbp,%rsi
   18fcd:	48 89 df             	mov    %rbx,%rdi
   18fd0:	48 8b 00             	mov    (%rax),%rax
   18fd3:	ff 50 10             	callq  *0x10(%rax)
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
   18fd6:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
   18fdd:	00 
		}

		buf->data = NULL;
		buf->frags = NULL;

		pool = net_buf_pool_get(buf->pool_id);
   18fde:	0f b6 7b 0a          	movzbl 0xa(%rbx),%edi
		buf->data = NULL;
   18fe2:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
   18fe9:	00 
		buf->frags = NULL;
   18fea:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
		pool = net_buf_pool_get(buf->pool_id);
   18ff1:	e8 03 fd ff ff       	callq  18cf9 <net_buf_pool_get>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
		atomic_inc(&pool->avail_count);
		__ASSERT_NO_MSG(atomic_get(&pool->avail_count) <= pool->buf_count);
#endif

		if (pool->destroy) {
   18ff6:	48 8b 40 38          	mov    0x38(%rax),%rax
			pool->destroy(buf);
   18ffa:	48 89 df             	mov    %rbx,%rdi
		if (pool->destroy) {
   18ffd:	48 85 c0             	test   %rax,%rax
   19000:	74 04                	je     19006 <net_buf_unref+0x6c>
			pool->destroy(buf);
   19002:	ff d0                	callq  *%rax
   19004:	eb 05                	jmp    1900b <net_buf_unref+0x71>
		} else {
			net_buf_destroy(buf);
   19006:	e8 34 fd ff ff       	callq  18d3f <net_buf_destroy>
{
   1900b:	4c 89 e3             	mov    %r12,%rbx
   1900e:	eb 91                	jmp    18fa1 <net_buf_unref+0x7>
		}

		buf = frags;
	}
}
   19010:	5b                   	pop    %rbx
   19011:	5d                   	pop    %rbp
   19012:	41 5c                	pop    %r12
   19014:	c3                   	retq   

0000000000019015 <net_buf_ref>:

struct net_buf *net_buf_ref(struct net_buf *buf)
{
   19015:	48 89 f8             	mov    %rdi,%rax
	__ASSERT_NO_MSG(buf);

	NET_BUF_DBG("buf %p (old) ref %u pool_id %u",
		    buf, buf->ref, buf->pool_id);
	buf->ref++;
   19018:	fe 47 08             	incb   0x8(%rdi)
	return buf;
}
   1901b:	c3                   	retq   

000000000001901c <net_buf_frag_last>:

	return clone;
}

struct net_buf *net_buf_frag_last(struct net_buf *buf)
{
   1901c:	48 89 f8             	mov    %rdi,%rax
	__ASSERT_NO_MSG(buf);

	while (buf->frags) {
   1901f:	48 8b 10             	mov    (%rax),%rdx
   19022:	48 85 d2             	test   %rdx,%rdx
   19025:	74 05                	je     1902c <net_buf_frag_last+0x10>
   19027:	48 89 d0             	mov    %rdx,%rax
   1902a:	eb f3                	jmp    1901f <net_buf_frag_last+0x3>
		buf = buf->frags;
	}

	return buf;
}
   1902c:	c3                   	retq   

000000000001902d <net_buf_frag_insert>:

void net_buf_frag_insert(struct net_buf *parent, struct net_buf *frag)
{
   1902d:	55                   	push   %rbp
   1902e:	53                   	push   %rbx
   1902f:	48 89 f5             	mov    %rsi,%rbp
   19032:	48 89 fb             	mov    %rdi,%rbx
   19035:	48 83 ec 08          	sub    $0x8,%rsp
	__ASSERT_NO_MSG(parent);
	__ASSERT_NO_MSG(frag);

	if (parent->frags) {
   19039:	48 83 3f 00          	cmpq   $0x0,(%rdi)
   1903d:	74 0e                	je     1904d <net_buf_frag_insert+0x20>
		net_buf_frag_last(frag)->frags = parent->frags;
   1903f:	48 89 f7             	mov    %rsi,%rdi
   19042:	e8 d5 ff ff ff       	callq  1901c <net_buf_frag_last>
   19047:	48 8b 13             	mov    (%rbx),%rdx
   1904a:	48 89 10             	mov    %rdx,(%rax)
	}
	/* Take ownership of the fragment reference */
	parent->frags = frag;
   1904d:	48 89 2b             	mov    %rbp,(%rbx)
}
   19050:	58                   	pop    %rax
   19051:	5b                   	pop    %rbx
   19052:	5d                   	pop    %rbp
   19053:	c3                   	retq   

0000000000019054 <net_buf_frag_add>:

struct net_buf *net_buf_frag_add(struct net_buf *head, struct net_buf *frag)
{
	__ASSERT_NO_MSG(frag);

	if (!head) {
   19054:	48 85 ff             	test   %rdi,%rdi
   19057:	75 08                	jne    19061 <net_buf_frag_add+0xd>
		return net_buf_ref(frag);
   19059:	48 89 f7             	mov    %rsi,%rdi
   1905c:	e9 b4 ff ff ff       	jmpq   19015 <net_buf_ref>
{
   19061:	53                   	push   %rbx
   19062:	48 89 fb             	mov    %rdi,%rbx
   19065:	48 83 ec 10          	sub    $0x10,%rsp
   19069:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	}

	net_buf_frag_insert(net_buf_frag_last(head), frag);
   1906e:	e8 a9 ff ff ff       	callq  1901c <net_buf_frag_last>
   19073:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   19078:	48 89 c7             	mov    %rax,%rdi
   1907b:	e8 ad ff ff ff       	callq  1902d <net_buf_frag_insert>

	return head;
}
   19080:	48 83 c4 10          	add    $0x10,%rsp
   19084:	48 89 d8             	mov    %rbx,%rax
   19087:	5b                   	pop    %rbx
   19088:	c3                   	retq   

0000000000019089 <net_buf_simple_add>:
	return buf->data + buf->len;
   19089:	0f b7 47 08          	movzwl 0x8(%rdi),%eax
   1908d:	48 89 c2             	mov    %rax,%rdx
   19090:	48 03 07             	add    (%rdi),%rax

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
   19093:	01 f2                	add    %esi,%edx
   19095:	66 89 57 08          	mov    %dx,0x8(%rdi)
	return tail;
}
   19099:	c3                   	retq   

000000000001909a <net_buf_simple_add_mem>:

void *net_buf_simple_add_mem(struct net_buf_simple *buf, const void *mem,
			     size_t len)
{
   1909a:	55                   	push   %rbp
   1909b:	53                   	push   %rbx
   1909c:	48 89 f5             	mov    %rsi,%rbp
   1909f:	48 89 d3             	mov    %rdx,%rbx
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	return memcpy(net_buf_simple_add(buf, len), mem, len);
   190a2:	48 89 d6             	mov    %rdx,%rsi
{
   190a5:	48 83 ec 08          	sub    $0x8,%rsp
	return memcpy(net_buf_simple_add(buf, len), mem, len);
   190a9:	e8 db ff ff ff       	callq  19089 <net_buf_simple_add>
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
   190ae:	48 89 ee             	mov    %rbp,%rsi
   190b1:	48 89 d9             	mov    %rbx,%rcx
   190b4:	48 89 c7             	mov    %rax,%rdi
   190b7:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
}
   190b9:	5a                   	pop    %rdx
   190ba:	5b                   	pop    %rbx
   190bb:	5d                   	pop    %rbp
   190bc:	c3                   	retq   

00000000000190bd <net_buf_simple_add_u8>:

uint8_t *net_buf_simple_add_u8(struct net_buf_simple *buf, uint8_t val)
{
   190bd:	53                   	push   %rbx
   190be:	89 f3                	mov    %esi,%ebx
	uint8_t *u8;

	NET_BUF_SIMPLE_DBG("buf %p val 0x%02x", buf, val);

	u8 = net_buf_simple_add(buf, 1);
   190c0:	be 01 00 00 00       	mov    $0x1,%esi
   190c5:	e8 bf ff ff ff       	callq  19089 <net_buf_simple_add>
	*u8 = val;
   190ca:	88 18                	mov    %bl,(%rax)

	return u8;
}
   190cc:	5b                   	pop    %rbx
   190cd:	c3                   	retq   

00000000000190ce <net_buf_simple_add_le16>:

void net_buf_simple_add_le16(struct net_buf_simple *buf, uint16_t val)
{
   190ce:	53                   	push   %rbx
   190cf:	89 f3                	mov    %esi,%ebx
	NET_BUF_SIMPLE_DBG("buf %p val %u", buf, val);

	sys_put_le16(val, net_buf_simple_add(buf, sizeof(val)));
   190d1:	be 02 00 00 00       	mov    $0x2,%esi
   190d6:	e8 ae ff ff ff       	callq  19089 <net_buf_simple_add>
	dst[0] = val;
   190db:	88 18                	mov    %bl,(%rax)
	dst[1] = val >> 8;
   190dd:	88 78 01             	mov    %bh,0x1(%rax)
}
   190e0:	5b                   	pop    %rbx
   190e1:	c3                   	retq   

00000000000190e2 <net_buf_simple_push>:
{
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_headroom(buf) >= len);

	buf->data -= len;
   190e2:	48 8b 07             	mov    (%rdi),%rax
	buf->len += len;
   190e5:	66 01 77 08          	add    %si,0x8(%rdi)
	buf->data -= len;
   190e9:	48 29 f0             	sub    %rsi,%rax
   190ec:	48 89 07             	mov    %rax,(%rdi)
	return buf->data;
}
   190ef:	c3                   	retq   

00000000000190f0 <net_buf_simple_push_u8>:

	sys_put_be16(val, net_buf_simple_push(buf, sizeof(val)));
}

void net_buf_simple_push_u8(struct net_buf_simple *buf, uint8_t val)
{
   190f0:	53                   	push   %rbx
   190f1:	89 f3                	mov    %esi,%ebx
	uint8_t *data = net_buf_simple_push(buf, 1);
   190f3:	be 01 00 00 00       	mov    $0x1,%esi
   190f8:	e8 e5 ff ff ff       	callq  190e2 <net_buf_simple_push>

	*data = val;
   190fd:	88 18                	mov    %bl,(%rax)
}
   190ff:	5b                   	pop    %rbx
   19100:	c3                   	retq   

0000000000019101 <net_buf_simple_pull>:
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
	return buf->data += len;
   19101:	48 8b 07             	mov    (%rdi),%rax
	buf->len -= len;
   19104:	66 29 77 08          	sub    %si,0x8(%rdi)
	return buf->data += len;
   19108:	48 01 f0             	add    %rsi,%rax
   1910b:	48 89 07             	mov    %rax,(%rdi)
}
   1910e:	c3                   	retq   

000000000001910f <net_buf_simple_pull_mem>:

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
	void *data = buf->data;
   1910f:	48 8b 07             	mov    (%rdi),%rax

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
   19112:	66 29 77 08          	sub    %si,0x8(%rdi)
	buf->data += len;
   19116:	48 01 c6             	add    %rax,%rsi
   19119:	48 89 37             	mov    %rsi,(%rdi)

	return data;
}
   1911c:	c3                   	retq   

000000000001911d <net_buf_simple_pull_le16>:

uint16_t net_buf_simple_pull_le16(struct net_buf_simple *buf)
{
	uint16_t val;

	val = UNALIGNED_GET((uint16_t *)buf->data);
   1911d:	48 8b 07             	mov    (%rdi),%rax
{
   19120:	53                   	push   %rbx
	net_buf_simple_pull(buf, sizeof(val));
   19121:	be 02 00 00 00       	mov    $0x2,%esi
	val = UNALIGNED_GET((uint16_t *)buf->data);
   19126:	66 8b 18             	mov    (%rax),%bx
	net_buf_simple_pull(buf, sizeof(val));
   19129:	e8 d3 ff ff ff       	callq  19101 <net_buf_simple_pull>

	return sys_le16_to_cpu(val);
}
   1912e:	89 d8                	mov    %ebx,%eax
   19130:	5b                   	pop    %rbx
   19131:	c3                   	retq   

0000000000019132 <net_buf_simple_headroom>:
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
   19132:	48 8b 07             	mov    (%rdi),%rax
   19135:	48 2b 47 10          	sub    0x10(%rdi),%rax
}
   19139:	c3                   	retq   

000000000001913a <net_buf_simple_tailroom>:

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
   1913a:	55                   	push   %rbp
   1913b:	53                   	push   %rbx
   1913c:	48 89 fd             	mov    %rdi,%rbp
   1913f:	48 83 ec 08          	sub    $0x8,%rsp
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
   19143:	0f b7 5f 0a          	movzwl 0xa(%rdi),%ebx
   19147:	e8 e6 ff ff ff       	callq  19132 <net_buf_simple_headroom>
   1914c:	0f b7 55 08          	movzwl 0x8(%rbp),%edx
   19150:	48 29 c3             	sub    %rax,%rbx
   19153:	48 89 d8             	mov    %rbx,%rax
   19156:	48 29 d0             	sub    %rdx,%rax
}
   19159:	5a                   	pop    %rdx
   1915a:	5b                   	pop    %rbx
   1915b:	5d                   	pop    %rbp
   1915c:	c3                   	retq   

000000000001915d <sdl_filter>:
	struct sdl_data *data = arg;
	uint32_t row = 0;
	uint32_t column = 0;
	bool pressed = 0;

	switch (event->type) {
   1915d:	8b 06                	mov    (%rsi),%eax
   1915f:	3d 01 04 00 00       	cmp    $0x401,%eax
   19164:	74 20                	je     19186 <sdl_filter+0x29>
   19166:	3d 02 04 00 00       	cmp    $0x402,%eax
   1916b:	74 09                	je     19176 <sdl_filter+0x19>
   1916d:	3d 00 04 00 00       	cmp    $0x400,%eax
   19172:	75 44                	jne    191b8 <sdl_filter+0x5b>
   19174:	eb 0a                	jmp    19180 <sdl_filter+0x23>
		column = event->button.x;
		row = event->button.y;
	} break;
	case SDL_MOUSEBUTTONUP: {
		pressed = 0;
		column = event->button.x;
   19176:	8b 56 14             	mov    0x14(%rsi),%edx
		pressed = 0;
   19179:	31 c9                	xor    %ecx,%ecx
		row = event->button.y;
   1917b:	8b 76 18             	mov    0x18(%rsi),%esi
	} break;
   1917e:	eb 19                	jmp    19199 <sdl_filter+0x3c>
	case SDL_MOUSEMOTION: {
		if (!event->motion.state)
   19180:	83 7e 10 00          	cmpl   $0x0,0x10(%rsi)
   19184:	74 0d                	je     19193 <sdl_filter+0x36>
			break;
		pressed = 1;
		column = event->button.x;
   19186:	8b 56 14             	mov    0x14(%rsi),%edx
		pressed = 1;
   19189:	b9 01 00 00 00       	mov    $0x1,%ecx
		row = event->button.y;
   1918e:	8b 76 18             	mov    0x18(%rsi),%esi
	} break;
   19191:	eb 06                	jmp    19199 <sdl_filter+0x3c>
	bool pressed = 0;
   19193:	31 c9                	xor    %ecx,%ecx
	uint32_t column = 0;
   19195:	31 d2                	xor    %edx,%edx
	uint32_t row = 0;
   19197:	31 f6                	xor    %esi,%esi
	default:
		return 1;
	}

	if (data->enabled && data->callback) {
   19199:	80 7f 10 00          	cmpb   $0x0,0x10(%rdi)
   1919d:	74 19                	je     191b8 <sdl_filter+0x5b>
   1919f:	48 8b 47 08          	mov    0x8(%rdi),%rax
   191a3:	48 85 c0             	test   %rax,%rax
   191a6:	74 10                	je     191b8 <sdl_filter+0x5b>
{
   191a8:	48 83 ec 08          	sub    $0x8,%rsp
		data->callback(data->dev, row, column, pressed);
   191ac:	48 8b 3f             	mov    (%rdi),%rdi
   191af:	ff d0                	callq  *%rax
	}
	return 1;
}
   191b1:	b8 01 00 00 00       	mov    $0x1,%eax
   191b6:	5a                   	pop    %rdx
   191b7:	c3                   	retq   
   191b8:	b8 01 00 00 00       	mov    $0x1,%eax
   191bd:	c3                   	retq   

00000000000191be <sdl_enable_callback>:
static int sdl_enable_callback(const struct device *dev)
{
	struct sdl_data *data = dev->data;

	LOG_DBG("%s: enable cb", dev->name);
	data->enabled = true;
   191be:	48 8b 47 18          	mov    0x18(%rdi),%rax
   191c2:	c6 40 10 01          	movb   $0x1,0x10(%rax)
	return 0;
}
   191c6:	31 c0                	xor    %eax,%eax
   191c8:	c3                   	retq   

00000000000191c9 <sdl_disable_callback>:
static int sdl_disable_callback(const struct device *dev)
{
	struct sdl_data *data = dev->data;

	LOG_DBG("%s: disable cb", dev->name);
	data->enabled = false;
   191c9:	48 8b 47 18          	mov    0x18(%rdi),%rax
   191cd:	c6 40 10 00          	movb   $0x0,0x10(%rax)
	return 0;
}
   191d1:	31 c0                	xor    %eax,%eax
   191d3:	c3                   	retq   

00000000000191d4 <sdl_init>:
   191d4:	48 8d 15 55 12 22 00 	lea    0x221255(%rip),%rdx        # 23a430 <log_const_kscan>
   191db:	48 2b 15 6e cd 21 00 	sub    0x21cd6e(%rip),%rdx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>

static int sdl_init(const struct device *dev)
{
   191e2:	53                   	push   %rbx
	struct sdl_data *data = dev->data;
   191e3:	48 8b 5f 18          	mov    0x18(%rdi),%rbx

	data->dev = dev;

	LOG_INF("Init '%s' device", dev->name);
   191e7:	48 8b 37             	mov    (%rdi),%rsi
   191ea:	48 c1 ea 04          	shr    $0x4,%rdx
	data->dev = dev;
   191ee:	48 89 3b             	mov    %rdi,(%rbx)
	LOG_INF("Init '%s' device", dev->name);
   191f1:	48 8d 3d fd 9f 01 00 	lea    0x19ffd(%rip),%rdi        # 331f5 <__func__.5785+0x258d>
   191f8:	c1 e2 06             	shl    $0x6,%edx
   191fb:	83 ca 03             	or     $0x3,%edx
   191fe:	e8 f2 e0 fe ff       	callq  72f5 <log_1>
	SDL_AddEventWatch(sdl_filter, data);
   19203:	48 8d 3d 53 ff ff ff 	lea    -0xad(%rip),%rdi        # 1915d <sdl_filter>
   1920a:	48 89 de             	mov    %rbx,%rsi
   1920d:	e8 1e b4 fe ff       	callq  4630 <SDL_AddEventWatch@plt>

	return 0;
}
   19212:	31 c0                	xor    %eax,%eax
   19214:	5b                   	pop    %rbx
   19215:	c3                   	retq   

0000000000019216 <sdl_configure>:
	if (!callback) {
   19216:	48 85 f6             	test   %rsi,%rsi
	struct sdl_data *data = dev->data;
   19219:	48 8b 47 18          	mov    0x18(%rdi),%rax
	if (!callback) {
   1921d:	75 2f                	jne    1924e <sdl_configure+0x38>
{
   1921f:	48 83 ec 08          	sub    $0x8,%rsp
   19223:	48 8d 35 06 12 22 00 	lea    0x221206(%rip),%rsi        # 23a430 <log_const_kscan>
   1922a:	48 2b 35 1f cd 21 00 	sub    0x21cd1f(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
		LOG_ERR("Callback is null");
   19231:	48 8d 3d ce 9f 01 00 	lea    0x19fce(%rip),%rdi        # 33206 <__func__.5785+0x259e>
   19238:	48 c1 ee 04          	shr    $0x4,%rsi
   1923c:	c1 e6 06             	shl    $0x6,%esi
   1923f:	83 ce 01             	or     $0x1,%esi
   19242:	e8 7d e0 fe ff       	callq  72c4 <log_0>
   19247:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
   1924c:	5a                   	pop    %rdx
   1924d:	c3                   	retq   
	data->callback = callback;
   1924e:	48 89 70 08          	mov    %rsi,0x8(%rax)
	return 0;
   19252:	31 c0                	xor    %eax,%eax
}
   19254:	c3                   	retq   

0000000000019255 <lv_disp_get_scr_act>:
 * screen)
 * @return pointer to the active screen object (loaded by 'lv_scr_load()')
 */
lv_obj_t * lv_disp_get_scr_act(lv_disp_t * disp)
{
    if(!disp) disp = lv_disp_get_default();
   19255:	48 85 ff             	test   %rdi,%rdi
   19258:	75 36                	jne    19290 <lv_disp_get_scr_act+0x3b>
{
   1925a:	48 83 ec 08          	sub    $0x8,%rsp
    if(!disp) disp = lv_disp_get_default();
   1925e:	e8 db bd 00 00       	callq  2503e <lv_disp_get_default>
    if(!disp) {
   19263:	48 85 c0             	test   %rax,%rax
   19266:	75 30                	jne    19298 <lv_disp_get_scr_act+0x43>
        LV_LOG_WARN("no display registered to get its active screen");
   19268:	4c 8d 05 ae 9f 01 00 	lea    0x19fae(%rip),%r8        # 3321d <__func__.5785+0x25b5>
   1926f:	48 8d 0d 2a 76 01 00 	lea    0x1762a(%rip),%rcx        # 308a0 <__func__.5668>
   19276:	48 8d 35 cf 9f 01 00 	lea    0x19fcf(%rip),%rsi        # 3324c <__func__.5785+0x25e4>
   1927d:	ba 35 00 00 00       	mov    $0x35,%edx
   19282:	bf 02 00 00 00       	mov    $0x2,%edi
   19287:	e8 ca cc 00 00       	callq  25f56 <_lv_log_add>
        return NULL;
   1928c:	31 c0                	xor    %eax,%eax
   1928e:	eb 0f                	jmp    1929f <lv_disp_get_scr_act+0x4a>
    }

    return disp->act_scr;
   19290:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
}
   19297:	c3                   	retq   
    return disp->act_scr;
   19298:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
}
   1929f:	5a                   	pop    %rdx
   192a0:	c3                   	retq   

00000000000192a1 <lv_disp_get_scr_prev>:
 * screen)
 * @return pointer to the previous screen object or NULL if not used now
 */
lv_obj_t * lv_disp_get_scr_prev(lv_disp_t * disp)
{
    if(!disp) disp = lv_disp_get_default();
   192a1:	48 85 ff             	test   %rdi,%rdi
   192a4:	75 36                	jne    192dc <lv_disp_get_scr_prev+0x3b>
{
   192a6:	48 83 ec 08          	sub    $0x8,%rsp
    if(!disp) disp = lv_disp_get_default();
   192aa:	e8 8f bd 00 00       	callq  2503e <lv_disp_get_default>
    if(!disp) {
   192af:	48 85 c0             	test   %rax,%rax
   192b2:	75 30                	jne    192e4 <lv_disp_get_scr_prev+0x43>
        LV_LOG_WARN("no display registered to get its previous screen");
   192b4:	4c 8d 05 c7 9f 01 00 	lea    0x19fc7(%rip),%r8        # 33282 <__func__.5785+0x261a>
   192bb:	48 8d 0d be 75 01 00 	lea    0x175be(%rip),%rcx        # 30880 <__func__.5672>
   192c2:	48 8d 35 83 9f 01 00 	lea    0x19f83(%rip),%rsi        # 3324c <__func__.5785+0x25e4>
   192c9:	ba 46 00 00 00       	mov    $0x46,%edx
   192ce:	bf 02 00 00 00       	mov    $0x2,%edi
   192d3:	e8 7e cc 00 00       	callq  25f56 <_lv_log_add>
        return NULL;
   192d8:	31 c0                	xor    %eax,%eax
   192da:	eb 0f                	jmp    192eb <lv_disp_get_scr_prev+0x4a>
    }

    return disp->prev_scr;
   192dc:	48 8b 87 88 00 00 00 	mov    0x88(%rdi),%rax
}
   192e3:	c3                   	retq   
    return disp->prev_scr;
   192e4:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
}
   192eb:	5a                   	pop    %rdx
   192ec:	c3                   	retq   

00000000000192ed <lv_disp_load_scr>:
/**
 * Make a screen active
 * @param scr pointer to a screen
 */
void lv_disp_load_scr(lv_obj_t * scr)
{
   192ed:	53                   	push   %rbx
   192ee:	48 89 fb             	mov    %rdi,%rbx
    lv_disp_t * d = lv_obj_get_disp(scr);
   192f1:	e8 48 15 00 00       	callq  1a83e <lv_obj_get_disp>
    if(!d) return;  /*Shouldn't happen, just to be sure*/
   192f6:	48 85 c0             	test   %rax,%rax
   192f9:	74 10                	je     1930b <lv_disp_load_scr+0x1e>
    d->act_scr = scr;
   192fb:	48 89 98 80 00 00 00 	mov    %rbx,0x80(%rax)

    lv_obj_invalidate(scr);
   19302:	48 89 df             	mov    %rbx,%rdi
}
   19305:	5b                   	pop    %rbx
    lv_obj_invalidate(scr);
   19306:	e9 a7 19 00 00       	jmpq   1acb2 <lv_obj_invalidate>
}
   1930b:	5b                   	pop    %rbx
   1930c:	c3                   	retq   

000000000001930d <lv_disp_get_layer_top>:
 * @param disp pointer to display which top layer should be get. (NULL to use the default screen)
 * @return pointer to the top layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_top(lv_disp_t * disp)
{
    if(!disp) disp = lv_disp_get_default();
   1930d:	48 85 ff             	test   %rdi,%rdi
   19310:	75 36                	jne    19348 <lv_disp_get_layer_top+0x3b>
{
   19312:	48 83 ec 08          	sub    $0x8,%rsp
    if(!disp) disp = lv_disp_get_default();
   19316:	e8 23 bd 00 00       	callq  2503e <lv_disp_get_default>
    if(!disp) {
   1931b:	48 85 c0             	test   %rax,%rax
   1931e:	75 30                	jne    19350 <lv_disp_get_layer_top+0x43>
        LV_LOG_WARN("lv_layer_top: no display registered to get its top layer");
   19320:	4c 8d 05 8c 9f 01 00 	lea    0x19f8c(%rip),%r8        # 332b3 <__func__.5785+0x264b>
   19327:	48 8d 0d 32 75 01 00 	lea    0x17532(%rip),%rcx        # 30860 <__func__.5680>
   1932e:	48 8d 35 17 9f 01 00 	lea    0x19f17(%rip),%rsi        # 3324c <__func__.5785+0x25e4>
   19335:	ba 63 00 00 00       	mov    $0x63,%edx
   1933a:	bf 02 00 00 00       	mov    $0x2,%edi
   1933f:	e8 12 cc 00 00       	callq  25f56 <_lv_log_add>
        return NULL;
   19344:	31 c0                	xor    %eax,%eax
   19346:	eb 0f                	jmp    19357 <lv_disp_get_layer_top+0x4a>
    }

    return disp->top_layer;
   19348:	48 8b 87 90 00 00 00 	mov    0x90(%rdi),%rax
}
   1934f:	c3                   	retq   
    return disp->top_layer;
   19350:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
}
   19357:	5a                   	pop    %rdx
   19358:	c3                   	retq   

0000000000019359 <lv_disp_get_layer_sys>:
 * @param disp pointer to display which sys. layer  should be get. (NULL to use the default screen)
 * @return pointer to the sys layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_sys(lv_disp_t * disp)
{
    if(!disp) disp = lv_disp_get_default();
   19359:	48 85 ff             	test   %rdi,%rdi
   1935c:	75 36                	jne    19394 <lv_disp_get_layer_sys+0x3b>
{
   1935e:	48 83 ec 08          	sub    $0x8,%rsp
    if(!disp) disp = lv_disp_get_default();
   19362:	e8 d7 bc 00 00       	callq  2503e <lv_disp_get_default>
    if(!disp) {
   19367:	48 85 c0             	test   %rax,%rax
   1936a:	75 30                	jne    1939c <lv_disp_get_layer_sys+0x43>
        LV_LOG_WARN("lv_layer_sys: no display registered to get its sys. layer");
   1936c:	4c 8d 05 79 9f 01 00 	lea    0x19f79(%rip),%r8        # 332ec <__func__.5785+0x2684>
   19373:	48 8d 0d c6 74 01 00 	lea    0x174c6(%rip),%rcx        # 30840 <__func__.5684>
   1937a:	48 8d 35 cb 9e 01 00 	lea    0x19ecb(%rip),%rsi        # 3324c <__func__.5785+0x25e4>
   19381:	ba 74 00 00 00       	mov    $0x74,%edx
   19386:	bf 02 00 00 00       	mov    $0x2,%edi
   1938b:	e8 c6 cb 00 00       	callq  25f56 <_lv_log_add>
        return NULL;
   19390:	31 c0                	xor    %eax,%eax
   19392:	eb 0f                	jmp    193a3 <lv_disp_get_layer_sys+0x4a>
    }

    return disp->sys_layer;
   19394:	48 8b 87 98 00 00 00 	mov    0x98(%rdi),%rax
}
   1939b:	c3                   	retq   
    return disp->sys_layer;
   1939c:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
}
   193a3:	5a                   	pop    %rdx
   193a4:	c3                   	retq   

00000000000193a5 <indev_reset_check>:
 * @param proc pointer to an input device 'proc'
 * @return true if indev query should be immediately truncated.
 */
static bool indev_reset_check(lv_indev_proc_t * proc)
{
    if(proc->reset_query) {
   193a5:	8a 47 48             	mov    0x48(%rdi),%al
   193a8:	a8 02                	test   $0x2,%al
   193aa:	74 0b                	je     193b7 <indev_reset_check+0x12>
        indev_obj_act = NULL;
   193ac:	48 c7 05 01 ec 23 00 	movq   $0x0,0x23ec01(%rip)        # 257fb8 <indev_obj_act>
   193b3:	00 00 00 00 
    }

    return proc->reset_query ? true : false;
   193b7:	d0 e8                	shr    %al
   193b9:	83 e0 01             	and    $0x1,%eax
}
   193bc:	c3                   	retq   

00000000000193bd <indev_proc_reset_query_handler>:
    if(indev->proc.reset_query) {
   193bd:	8a 97 80 00 00 00    	mov    0x80(%rdi),%dl
   193c3:	f6 c2 02             	test   $0x2,%dl
   193c6:	74 52                	je     1941a <indev_proc_reset_query_handler+0x5d>
        indev->proc.types.pointer.drag_dir = LV_DRAG_DIR_BOTH;
   193c8:	8a 47 76             	mov    0x76(%rdi),%al
        indev->proc.reset_query                     = 0;
   193cb:	83 e2 fc             	and    $0xfffffffc,%edx
        indev->proc.types.pointer.act_obj           = NULL;
   193ce:	48 c7 47 58 00 00 00 	movq   $0x0,0x58(%rdi)
   193d5:	00 
        indev->proc.types.pointer.last_obj          = NULL;
   193d6:	48 c7 47 60 00 00 00 	movq   $0x0,0x60(%rdi)
   193dd:	00 
        indev->proc.pr_timestamp                    = 0;
   193de:	c7 47 78 00 00 00 00 	movl   $0x0,0x78(%rdi)
        indev->proc.longpr_rep_timestamp            = 0;
   193e5:	c7 47 7c 00 00 00 00 	movl   $0x0,0x7c(%rdi)
        indev->proc.types.pointer.drag_sum.x        = 0;
   193ec:	48 c7 47 4c 00 00 00 	movq   $0x0,0x4c(%rdi)
   193f3:	00 
        indev->proc.types.pointer.drag_dir = LV_DRAG_DIR_BOTH;
   193f4:	83 e0 e0             	and    $0xffffffe0,%eax
        indev->proc.types.pointer.gesture_sum.x     = 0;
   193f7:	66 c7 47 72 00 00    	movw   $0x0,0x72(%rdi)
        indev->proc.types.pointer.gesture_sum.y     = 0;
   193fd:	66 c7 47 74 00 00    	movw   $0x0,0x74(%rdi)
        indev->proc.types.pointer.drag_dir = LV_DRAG_DIR_BOTH;
   19403:	83 c8 0c             	or     $0xc,%eax
        indev->proc.reset_query                     = 0;
   19406:	88 97 80 00 00 00    	mov    %dl,0x80(%rdi)
        indev_obj_act                               = NULL;
   1940c:	48 c7 05 a1 eb 23 00 	movq   $0x0,0x23eba1(%rip)        # 257fb8 <indev_obj_act>
   19413:	00 00 00 00 
        indev->proc.types.pointer.drag_dir = LV_DRAG_DIR_BOTH;
   19417:	88 47 76             	mov    %al,0x76(%rdi)
}
   1941a:	c3                   	retq   

000000000001941b <get_dragged_obj>:
    if(obj == NULL) return NULL;
   1941b:	48 85 ff             	test   %rdi,%rdi
{
   1941e:	53                   	push   %rbx
   1941f:	48 89 fb             	mov    %rdi,%rbx
    if(obj == NULL) return NULL;
   19422:	75 14                	jne    19438 <get_dragged_obj+0x1d>
   19424:	31 db                	xor    %ebx,%ebx
   19426:	eb 1c                	jmp    19444 <get_dragged_obj+0x29>
    while(lv_obj_get_drag_parent(drag_obj) != false && drag_obj != NULL) {
   19428:	48 85 db             	test   %rbx,%rbx
   1942b:	74 f7                	je     19424 <get_dragged_obj+0x9>
        drag_obj = lv_obj_get_parent(drag_obj);
   1942d:	48 89 df             	mov    %rbx,%rdi
   19430:	e8 ea 13 00 00       	callq  1a81f <lv_obj_get_parent>
   19435:	48 89 c3             	mov    %rax,%rbx
    while(lv_obj_get_drag_parent(drag_obj) != false && drag_obj != NULL) {
   19438:	48 89 df             	mov    %rbx,%rdi
   1943b:	e8 3b 1c 00 00       	callq  1b07b <lv_obj_get_drag_parent>
   19440:	84 c0                	test   %al,%al
   19442:	75 e4                	jne    19428 <get_dragged_obj+0xd>
}
   19444:	48 89 d8             	mov    %rbx,%rax
   19447:	5b                   	pop    %rbx
   19448:	c3                   	retq   

0000000000019449 <indev_drag_throw.part.4>:
static void indev_drag_throw(lv_indev_proc_t * proc)
   19449:	41 55                	push   %r13
   1944b:	41 54                	push   %r12
   1944d:	55                   	push   %rbp
   1944e:	53                   	push   %rbx
   1944f:	48 89 fb             	mov    %rdi,%rbx
   19452:	48 83 ec 28          	sub    $0x28,%rsp
    lv_obj_t * drag_obj = get_dragged_obj(proc->types.pointer.last_obj);
   19456:	48 8b 7f 28          	mov    0x28(%rdi),%rdi
static void indev_drag_throw(lv_indev_proc_t * proc)
   1945a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   19461:	00 00 
   19463:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   19468:	31 c0                	xor    %eax,%eax
    lv_obj_t * drag_obj = get_dragged_obj(proc->types.pointer.last_obj);
   1946a:	e8 ac ff ff ff       	callq  1941b <get_dragged_obj>
    if(drag_obj == NULL) return;
   1946f:	48 85 c0             	test   %rax,%rax
   19472:	0f 84 8c 01 00 00    	je     19604 <indev_drag_throw.part.4+0x1bb>
    if(lv_obj_get_drag_throw(drag_obj) == false) {
   19478:	48 89 c7             	mov    %rax,%rdi
   1947b:	48 89 c5             	mov    %rax,%rbp
   1947e:	e8 ee 1b 00 00       	callq  1b071 <lv_obj_get_drag_throw>
   19483:	84 c0                	test   %al,%al
   19485:	75 3a                	jne    194c1 <indev_drag_throw.part.4+0x78>
        proc->types.pointer.drag_in_prog = 0;
   19487:	80 63 3e fd          	andb   $0xfd,0x3e(%rbx)
        drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);
   1948b:	48 8b 15 2e eb 23 00 	mov    0x23eb2e(%rip),%rdx        # 257fc0 <indev_act>
   19492:	be 13 00 00 00       	mov    $0x13,%esi
   19497:	48 89 ef             	mov    %rbp,%rdi
   1949a:	ff 55 30             	callq  *0x30(%rbp)
        if(indev_reset_check(proc)) return;
   1949d:	48 89 df             	mov    %rbx,%rdi
   194a0:	e8 00 ff ff ff       	callq  193a5 <indev_reset_check>
   194a5:	84 c0                	test   %al,%al
   194a7:	0f 85 57 01 00 00    	jne    19604 <indev_drag_throw.part.4+0x1bb>
        lv_event_send(drag_obj, LV_EVENT_DRAG_END, NULL);
   194ad:	31 d2                	xor    %edx,%edx
   194af:	be 09 00 00 00       	mov    $0x9,%esi
   194b4:	48 89 ef             	mov    %rbp,%rdi
   194b7:	e8 f4 12 00 00       	callq  1a7b0 <lv_event_send>
   194bc:	e9 43 01 00 00       	jmpq   19604 <indev_drag_throw.part.4+0x1bb>
    lv_drag_dir_t allowed_dirs = lv_obj_get_drag_dir(drag_obj);
   194c1:	48 89 ef             	mov    %rbp,%rdi
   194c4:	e8 9e 1b 00 00       	callq  1b067 <lv_obj_get_drag_dir>
        proc->types.pointer.drag_throw_vect.x * (100 - indev_act->driver.drag_throw) / 100;
   194c9:	48 8b 35 f0 ea 23 00 	mov    0x23eaf0(%rip),%rsi        # 257fc0 <indev_act>
    lv_drag_dir_t allowed_dirs = lv_obj_get_drag_dir(drag_obj);
   194d0:	41 88 c5             	mov    %al,%r13b
        proc->types.pointer.drag_throw_vect.x * (100 - indev_act->driver.drag_throw) / 100;
   194d3:	b9 64 00 00 00       	mov    $0x64,%ecx
   194d8:	89 ca                	mov    %ecx,%edx
   194da:	0f b6 46 31          	movzbl 0x31(%rsi),%eax
   194de:	29 c2                	sub    %eax,%edx
   194e0:	89 d0                	mov    %edx,%eax
   194e2:	0f bf 53 18          	movswl 0x18(%rbx),%edx
   194e6:	0f af c2             	imul   %edx,%eax
   194e9:	99                   	cltd   
   194ea:	f7 f9                	idiv   %ecx
        proc->types.pointer.drag_throw_vect.y * (100 - indev_act->driver.drag_throw) / 100;
   194ec:	89 ca                	mov    %ecx,%edx
    proc->types.pointer.drag_throw_vect.x =
   194ee:	66 89 43 18          	mov    %ax,0x18(%rbx)
        proc->types.pointer.drag_throw_vect.y * (100 - indev_act->driver.drag_throw) / 100;
   194f2:	0f b6 46 31          	movzbl 0x31(%rsi),%eax
   194f6:	29 c2                	sub    %eax,%edx
   194f8:	89 d0                	mov    %edx,%eax
   194fa:	0f bf 53 1a          	movswl 0x1a(%rbx),%edx
   194fe:	0f af c2             	imul   %edx,%eax
   19501:	99                   	cltd   
   19502:	f7 f9                	idiv   %ecx
    proc->types.pointer.drag_throw_vect.y =
   19504:	66 89 43 1a          	mov    %ax,0x1a(%rbx)
    if(proc->types.pointer.drag_throw_vect.x != 0 || proc->types.pointer.drag_throw_vect.y != 0) {
   19508:	83 7b 18 00          	cmpl   $0x0,0x18(%rbx)
   1950c:	0f 84 bd 00 00 00    	je     195cf <indev_drag_throw.part.4+0x186>
        lv_obj_get_coords(drag_obj, &coords_ori);
   19512:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
   19517:	48 89 ef             	mov    %rbp,%rdi
   1951a:	e8 93 14 00 00       	callq  1a9b2 <lv_obj_get_coords>
        lv_coord_t act_x = lv_obj_get_x(drag_obj) + proc->types.pointer.drag_throw_vect.x;
   1951f:	48 89 ef             	mov    %rbp,%rdi
   19522:	e8 9a 14 00 00       	callq  1a9c1 <lv_obj_get_x>
   19527:	03 43 18             	add    0x18(%rbx),%eax
        lv_coord_t act_y = lv_obj_get_y(drag_obj) + proc->types.pointer.drag_throw_vect.y;
   1952a:	48 89 ef             	mov    %rbp,%rdi
        lv_coord_t act_x = lv_obj_get_x(drag_obj) + proc->types.pointer.drag_throw_vect.x;
   1952d:	41 89 c4             	mov    %eax,%r12d
        lv_coord_t act_y = lv_obj_get_y(drag_obj) + proc->types.pointer.drag_throw_vect.y;
   19530:	e8 a5 14 00 00       	callq  1a9da <lv_obj_get_y>
   19535:	66 03 43 1a          	add    0x1a(%rbx),%ax
        if(allowed_dirs == LV_DRAG_DIR_BOTH) lv_obj_set_pos(drag_obj, act_x, act_y);
   19539:	41 80 fd 03          	cmp    $0x3,%r13b
        lv_coord_t act_y = lv_obj_get_y(drag_obj) + proc->types.pointer.drag_throw_vect.y;
   1953d:	0f bf d0             	movswl %ax,%edx
        if(allowed_dirs == LV_DRAG_DIR_BOTH) lv_obj_set_pos(drag_obj, act_x, act_y);
   19540:	75 0e                	jne    19550 <indev_drag_throw.part.4+0x107>
   19542:	41 0f bf f4          	movswl %r12w,%esi
   19546:	48 89 ef             	mov    %rbp,%rdi
   19549:	e8 99 18 00 00       	callq  1ade7 <lv_obj_set_pos>
   1954e:	eb 32                	jmp    19582 <indev_drag_throw.part.4+0x139>
        else if(allowed_dirs == LV_DRAG_DIR_HOR) lv_obj_set_x(drag_obj, act_x);
   19550:	41 80 fd 01          	cmp    $0x1,%r13b
   19554:	74 13                	je     19569 <indev_drag_throw.part.4+0x120>
        else if(allowed_dirs == LV_DRAG_DIR_VER) lv_obj_set_y(drag_obj, act_y);
   19556:	41 80 fd 02          	cmp    $0x2,%r13b
   1955a:	74 1b                	je     19577 <indev_drag_throw.part.4+0x12e>
        else if(allowed_dirs == LV_DRAG_DIR_ONE) {
   1955c:	41 80 fd 04          	cmp    $0x4,%r13b
   19560:	75 20                	jne    19582 <indev_drag_throw.part.4+0x139>
            if(proc->types.pointer.drag_sum.x) lv_obj_set_x(drag_obj, act_x);
   19562:	66 83 7b 14 00       	cmpw   $0x0,0x14(%rbx)
   19567:	74 0e                	je     19577 <indev_drag_throw.part.4+0x12e>
   19569:	41 0f bf f4          	movswl %r12w,%esi
   1956d:	48 89 ef             	mov    %rbp,%rdi
   19570:	e8 3a 19 00 00       	callq  1aeaf <lv_obj_set_x>
   19575:	eb 0b                	jmp    19582 <indev_drag_throw.part.4+0x139>
            else lv_obj_set_y(drag_obj, act_y);
   19577:	0f bf f2             	movswl %dx,%esi
   1957a:	48 89 ef             	mov    %rbp,%rdi
   1957d:	e8 4e 19 00 00       	callq  1aed0 <lv_obj_set_y>
        lv_obj_get_coords(drag_obj, &coord_new);
   19582:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
   19587:	48 89 ef             	mov    %rbp,%rdi
   1958a:	e8 23 14 00 00       	callq  1a9b2 <lv_obj_get_coords>
        if((coords_ori.x1 == coord_new.x1 || proc->types.pointer.drag_throw_vect.x == 0) &&
   1958f:	8b 44 24 10          	mov    0x10(%rsp),%eax
   19593:	66 39 44 24 08       	cmp    %ax,0x8(%rsp)
   19598:	74 07                	je     195a1 <indev_drag_throw.part.4+0x158>
   1959a:	66 83 7b 18 00       	cmpw   $0x0,0x18(%rbx)
   1959f:	75 63                	jne    19604 <indev_drag_throw.part.4+0x1bb>
   195a1:	66 8b 44 24 12       	mov    0x12(%rsp),%ax
   195a6:	66 39 44 24 0a       	cmp    %ax,0xa(%rsp)
   195ab:	74 07                	je     195b4 <indev_drag_throw.part.4+0x16b>
           (coords_ori.y1 == coord_new.y1 || proc->types.pointer.drag_throw_vect.y == 0)) {
   195ad:	66 83 7b 1a 00       	cmpw   $0x0,0x1a(%rbx)
   195b2:	75 50                	jne    19604 <indev_drag_throw.part.4+0x1bb>
            proc->types.pointer.drag_in_prog      = 0;
   195b4:	80 63 3e fd          	andb   $0xfd,0x3e(%rbx)
            proc->types.pointer.vect.x            = 0;
   195b8:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%rbx)
            proc->types.pointer.drag_throw_vect.x = 0;
   195bf:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%rbx)
            drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);
   195c6:	48 8b 15 f3 e9 23 00 	mov    0x23e9f3(%rip),%rdx        # 257fc0 <indev_act>
   195cd:	eb 07                	jmp    195d6 <indev_drag_throw.part.4+0x18d>
        proc->types.pointer.drag_in_prog = 0;
   195cf:	80 63 3e fd          	andb   $0xfd,0x3e(%rbx)
        drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);
   195d3:	48 89 f2             	mov    %rsi,%rdx
   195d6:	be 13 00 00 00       	mov    $0x13,%esi
   195db:	48 89 ef             	mov    %rbp,%rdi
   195de:	ff 55 30             	callq  *0x30(%rbp)
        if(indev_reset_check(proc)) return;
   195e1:	48 89 df             	mov    %rbx,%rdi
   195e4:	e8 bc fd ff ff       	callq  193a5 <indev_reset_check>
   195e9:	84 c0                	test   %al,%al
   195eb:	75 17                	jne    19604 <indev_drag_throw.part.4+0x1bb>
        lv_event_send(drag_obj, LV_EVENT_DRAG_END, NULL);
   195ed:	48 89 ef             	mov    %rbp,%rdi
   195f0:	31 d2                	xor    %edx,%edx
   195f2:	be 09 00 00 00       	mov    $0x9,%esi
   195f7:	e8 b4 11 00 00       	callq  1a7b0 <lv_event_send>
        if(indev_reset_check(proc)) return;
   195fc:	48 89 df             	mov    %rbx,%rdi
   195ff:	e8 a1 fd ff ff       	callq  193a5 <indev_reset_check>
}
   19604:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
   19609:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   19610:	00 00 
   19612:	74 05                	je     19619 <indev_drag_throw.part.4+0x1d0>
   19614:	e8 27 b0 fe ff       	callq  4640 <__stack_chk_fail@plt>
   19619:	48 83 c4 28          	add    $0x28,%rsp
   1961d:	5b                   	pop    %rbx
   1961e:	5d                   	pop    %rbp
   1961f:	41 5c                	pop    %r12
   19621:	41 5d                	pop    %r13
   19623:	c3                   	retq   

0000000000019624 <indev_proc_release>:
{
   19624:	55                   	push   %rbp
   19625:	53                   	push   %rbx
   19626:	48 89 fb             	mov    %rdi,%rbx
   19629:	48 83 ec 08          	sub    $0x8,%rsp
    if(proc->wait_until_release != 0) {
   1962d:	8a 47 48             	mov    0x48(%rdi),%al
   19630:	a8 08                	test   $0x8,%al
   19632:	74 1e                	je     19652 <indev_proc_release+0x2e>
        proc->wait_until_release     = 0;
   19634:	83 e0 f7             	and    $0xfffffff7,%eax
        proc->types.pointer.act_obj  = NULL;
   19637:	48 c7 47 20 00 00 00 	movq   $0x0,0x20(%rdi)
   1963e:	00 
        proc->types.pointer.last_obj = NULL;
   1963f:	48 c7 47 28 00 00 00 	movq   $0x0,0x28(%rdi)
   19646:	00 
        proc->pr_timestamp           = 0;
   19647:	48 c7 47 40 00 00 00 	movq   $0x0,0x40(%rdi)
   1964e:	00 
        proc->wait_until_release     = 0;
   1964f:	88 47 48             	mov    %al,0x48(%rdi)
    indev_obj_act = proc->types.pointer.act_obj;
   19652:	48 8b 7b 20          	mov    0x20(%rbx),%rdi
    if(indev_obj_act) {
   19656:	48 85 ff             	test   %rdi,%rdi
    indev_obj_act = proc->types.pointer.act_obj;
   19659:	48 89 3d 58 e9 23 00 	mov    %rdi,0x23e958(%rip)        # 257fb8 <indev_obj_act>
    if(indev_obj_act) {
   19660:	0f 84 72 01 00 00    	je     197d8 <indev_proc_release+0x1b4>
        if(lv_obj_is_protected(indev_obj_act, LV_PROTECT_PRESS_LOST)) {
   19666:	be 10 00 00 00       	mov    $0x10,%esi
   1966b:	e8 56 1f 00 00       	callq  1b5c6 <lv_obj_is_protected>
   19670:	84 c0                	test   %al,%al
   19672:	48 8b 05 3f e9 23 00 	mov    0x23e93f(%rip),%rax        # 257fb8 <indev_obj_act>
            indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_RELEASED, indev_act);
   19679:	be 0e 00 00 00       	mov    $0xe,%esi
   1967e:	48 8b 15 3b e9 23 00 	mov    0x23e93b(%rip),%rdx        # 257fc0 <indev_act>
   19685:	48 89 c7             	mov    %rax,%rdi
        if(lv_obj_is_protected(indev_obj_act, LV_PROTECT_PRESS_LOST)) {
   19688:	74 47                	je     196d1 <indev_proc_release+0xad>
            indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_RELEASED, indev_act);
   1968a:	ff 50 30             	callq  *0x30(%rax)
            if(indev_reset_check(proc)) return;
   1968d:	48 89 df             	mov    %rbx,%rdi
   19690:	e8 10 fd ff ff       	callq  193a5 <indev_reset_check>
   19695:	84 c0                	test   %al,%al
   19697:	0f 85 61 01 00 00    	jne    197fe <indev_proc_release+0x1da>
            if(proc->types.pointer.drag_in_prog == 0) {
   1969d:	f6 43 3e 02          	testb  $0x2,0x3e(%rbx)
   196a1:	0f 85 98 00 00 00    	jne    1973f <indev_proc_release+0x11b>
                if(proc->long_pr_sent == 0) {
   196a7:	f6 43 48 01          	testb  $0x1,0x48(%rbx)
   196ab:	75 6f                	jne    1971c <indev_proc_release+0xf8>
                    lv_event_send(indev_obj_act, LV_EVENT_SHORT_CLICKED, NULL);
   196ad:	48 8b 3d 04 e9 23 00 	mov    0x23e904(%rip),%rdi        # 257fb8 <indev_obj_act>
   196b4:	31 d2                	xor    %edx,%edx
   196b6:	be 03 00 00 00       	mov    $0x3,%esi
   196bb:	e8 f0 10 00 00       	callq  1a7b0 <lv_event_send>
                    if(indev_reset_check(proc)) return;
   196c0:	48 89 df             	mov    %rbx,%rdi
   196c3:	e8 dd fc ff ff       	callq  193a5 <indev_reset_check>
   196c8:	84 c0                	test   %al,%al
   196ca:	74 50                	je     1971c <indev_proc_release+0xf8>
   196cc:	e9 2d 01 00 00       	jmpq   197fe <indev_proc_release+0x1da>
            indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_RELEASED, indev_act);
   196d1:	ff 50 30             	callq  *0x30(%rax)
            if(indev_reset_check(proc)) return;
   196d4:	48 89 df             	mov    %rbx,%rdi
   196d7:	e8 c9 fc ff ff       	callq  193a5 <indev_reset_check>
   196dc:	84 c0                	test   %al,%al
   196de:	0f 85 1a 01 00 00    	jne    197fe <indev_proc_release+0x1da>
            if(proc->long_pr_sent == 0 && proc->types.pointer.drag_in_prog == 0) {
   196e4:	f6 43 48 01          	testb  $0x1,0x48(%rbx)
   196e8:	74 08                	je     196f2 <indev_proc_release+0xce>
            if(proc->types.pointer.drag_in_prog == 0) {
   196ea:	f6 43 3e 02          	testb  $0x2,0x3e(%rbx)
   196ee:	74 2c                	je     1971c <indev_proc_release+0xf8>
   196f0:	eb 4d                	jmp    1973f <indev_proc_release+0x11b>
            if(proc->long_pr_sent == 0 && proc->types.pointer.drag_in_prog == 0) {
   196f2:	f6 43 3e 02          	testb  $0x2,0x3e(%rbx)
   196f6:	75 f2                	jne    196ea <indev_proc_release+0xc6>
                lv_event_send(indev_obj_act, LV_EVENT_SHORT_CLICKED, NULL);
   196f8:	48 8b 3d b9 e8 23 00 	mov    0x23e8b9(%rip),%rdi        # 257fb8 <indev_obj_act>
   196ff:	31 d2                	xor    %edx,%edx
   19701:	be 03 00 00 00       	mov    $0x3,%esi
   19706:	e8 a5 10 00 00       	callq  1a7b0 <lv_event_send>
                if(indev_reset_check(proc)) return;
   1970b:	48 89 df             	mov    %rbx,%rdi
   1970e:	e8 92 fc ff ff       	callq  193a5 <indev_reset_check>
   19713:	84 c0                	test   %al,%al
   19715:	74 d3                	je     196ea <indev_proc_release+0xc6>
   19717:	e9 e2 00 00 00       	jmpq   197fe <indev_proc_release+0x1da>
                lv_event_send(indev_obj_act, LV_EVENT_CLICKED, NULL);
   1971c:	48 8b 3d 95 e8 23 00 	mov    0x23e895(%rip),%rdi        # 257fb8 <indev_obj_act>
   19723:	31 d2                	xor    %edx,%edx
   19725:	be 06 00 00 00       	mov    $0x6,%esi
   1972a:	e8 81 10 00 00       	callq  1a7b0 <lv_event_send>
                if(indev_reset_check(proc)) return;
   1972f:	48 89 df             	mov    %rbx,%rdi
   19732:	e8 6e fc ff ff       	callq  193a5 <indev_reset_check>
   19737:	84 c0                	test   %al,%al
   19739:	0f 85 bf 00 00 00    	jne    197fe <indev_proc_release+0x1da>
            lv_event_send(indev_obj_act, LV_EVENT_RELEASED, NULL);
   1973f:	48 8b 3d 72 e8 23 00 	mov    0x23e872(%rip),%rdi        # 257fb8 <indev_obj_act>
   19746:	31 d2                	xor    %edx,%edx
   19748:	be 07 00 00 00       	mov    $0x7,%esi
   1974d:	e8 5e 10 00 00       	callq  1a7b0 <lv_event_send>
            if(indev_reset_check(proc)) return;
   19752:	48 89 df             	mov    %rbx,%rdi
   19755:	e8 4b fc ff ff       	callq  193a5 <indev_reset_check>
   1975a:	84 c0                	test   %al,%al
   1975c:	0f 85 9c 00 00 00    	jne    197fe <indev_proc_release+0x1da>
        lv_obj_t * drag_obj = get_dragged_obj(indev_obj_act);
   19762:	48 8b 3d 4f e8 23 00 	mov    0x23e84f(%rip),%rdi        # 257fb8 <indev_obj_act>
   19769:	e8 ad fc ff ff       	callq  1941b <get_dragged_obj>
        if(drag_obj) {
   1976e:	48 85 c0             	test   %rax,%rax
        lv_obj_t * drag_obj = get_dragged_obj(indev_obj_act);
   19771:	48 89 c5             	mov    %rax,%rbp
        if(drag_obj) {
   19774:	74 0c                	je     19782 <indev_proc_release+0x15e>
            if(lv_obj_get_drag_throw(drag_obj) && proc->types.pointer.drag_in_prog) {
   19776:	48 89 c7             	mov    %rax,%rdi
   19779:	e8 f3 18 00 00       	callq  1b071 <lv_obj_get_drag_throw>
   1977e:	84 c0                	test   %al,%al
   19780:	75 12                	jne    19794 <indev_proc_release+0x170>
        proc->types.pointer.act_obj = NULL;
   19782:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
   19789:	00 
        proc->pr_timestamp          = 0;
   1978a:	48 c7 43 40 00 00 00 	movq   $0x0,0x40(%rbx)
   19791:	00 
   19792:	eb 44                	jmp    197d8 <indev_proc_release+0x1b4>
            if(lv_obj_get_drag_throw(drag_obj) && proc->types.pointer.drag_in_prog) {
   19794:	f6 43 3e 02          	testb  $0x2,0x3e(%rbx)
   19798:	74 e8                	je     19782 <indev_proc_release+0x15e>
                if(drag_obj->signal_cb) drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_THROW_BEGIN, NULL);
   1979a:	48 8b 45 30          	mov    0x30(%rbp),%rax
   1979e:	48 85 c0             	test   %rax,%rax
   197a1:	74 0c                	je     197af <indev_proc_release+0x18b>
   197a3:	31 d2                	xor    %edx,%edx
   197a5:	be 12 00 00 00       	mov    $0x12,%esi
   197aa:	48 89 ef             	mov    %rbp,%rdi
   197ad:	ff d0                	callq  *%rax
                if(indev_reset_check(proc)) return;
   197af:	48 89 df             	mov    %rbx,%rdi
   197b2:	e8 ee fb ff ff       	callq  193a5 <indev_reset_check>
   197b7:	84 c0                	test   %al,%al
   197b9:	75 43                	jne    197fe <indev_proc_release+0x1da>
                lv_event_send(drag_obj, LV_EVENT_DRAG_THROW_BEGIN, NULL);
   197bb:	31 d2                	xor    %edx,%edx
   197bd:	be 0a 00 00 00       	mov    $0xa,%esi
   197c2:	48 89 ef             	mov    %rbp,%rdi
   197c5:	e8 e6 0f 00 00       	callq  1a7b0 <lv_event_send>
                if(indev_reset_check(proc)) return;
   197ca:	48 89 df             	mov    %rbx,%rdi
   197cd:	e8 d3 fb ff ff       	callq  193a5 <indev_reset_check>
   197d2:	84 c0                	test   %al,%al
   197d4:	74 ac                	je     19782 <indev_proc_release+0x15e>
   197d6:	eb 26                	jmp    197fe <indev_proc_release+0x1da>
    if(proc->types.pointer.last_obj != NULL && proc->reset_query == 0) {
   197d8:	48 83 7b 28 00       	cmpq   $0x0,0x28(%rbx)
   197dd:	74 1f                	je     197fe <indev_proc_release+0x1da>
   197df:	f6 43 48 02          	testb  $0x2,0x48(%rbx)
   197e3:	75 19                	jne    197fe <indev_proc_release+0x1da>
    if(proc->types.pointer.drag_in_prog == 0) return;
   197e5:	f6 43 3e 02          	testb  $0x2,0x3e(%rbx)
   197e9:	74 08                	je     197f3 <indev_proc_release+0x1cf>
   197eb:	48 89 df             	mov    %rbx,%rdi
   197ee:	e8 56 fc ff ff       	callq  19449 <indev_drag_throw.part.4>
}
   197f3:	5a                   	pop    %rdx
        if(indev_reset_check(proc)) return;
   197f4:	48 89 df             	mov    %rbx,%rdi
}
   197f7:	5b                   	pop    %rbx
   197f8:	5d                   	pop    %rbp
        if(indev_reset_check(proc)) return;
   197f9:	e9 a7 fb ff ff       	jmpq   193a5 <indev_reset_check>
}
   197fe:	58                   	pop    %rax
   197ff:	5b                   	pop    %rbx
   19800:	5d                   	pop    %rbp
   19801:	c3                   	retq   

0000000000019802 <lv_indev_get_act>:
}
   19802:	48 8b 05 b7 e7 23 00 	mov    0x23e7b7(%rip),%rax        # 257fc0 <indev_act>
   19809:	c3                   	retq   

000000000001980a <lv_indev_reset>:
    if(indev) {
   1980a:	48 85 ff             	test   %rdi,%rdi
   1980d:	74 2f                	je     1983e <lv_indev_reset+0x34>
        indev->proc.reset_query = 1;
   1980f:	80 8f 80 00 00 00 02 	orb    $0x2,0x80(%rdi)
        if(indev_act == indev) indev_obj_act = NULL;
   19816:	48 39 3d a3 e7 23 00 	cmp    %rdi,0x23e7a3(%rip)        # 257fc0 <indev_act>
   1981d:	75 0b                	jne    1982a <lv_indev_reset+0x20>
   1981f:	48 c7 05 8e e7 23 00 	movq   $0x0,0x23e78e(%rip)        # 257fb8 <indev_obj_act>
   19826:	00 00 00 00 
        if(obj == NULL || indev->proc.types.pointer.last_pressed == obj) {
   1982a:	48 85 f6             	test   %rsi,%rsi
   1982d:	74 06                	je     19835 <lv_indev_reset+0x2b>
   1982f:	48 39 77 68          	cmp    %rsi,0x68(%rdi)
   19833:	75 4e                	jne    19883 <lv_indev_reset+0x79>
            indev->proc.types.pointer.last_pressed = NULL;
   19835:	48 c7 47 68 00 00 00 	movq   $0x0,0x68(%rdi)
   1983c:	00 
   1983d:	c3                   	retq   
{
   1983e:	53                   	push   %rbx
        lv_indev_t * i = lv_indev_get_next(NULL);
   1983f:	31 ff                	xor    %edi,%edi
   19841:	48 89 f3             	mov    %rsi,%rbx
            i = lv_indev_get_next(i);
   19844:	e8 ac bb 00 00       	callq  253f5 <lv_indev_get_next>
        while(i) {
   19849:	48 85 c0             	test   %rax,%rax
   1984c:	74 33                	je     19881 <lv_indev_reset+0x77>
            i->proc.reset_query = 1;
   1984e:	80 88 80 00 00 00 02 	orb    $0x2,0x80(%rax)
            if(indev_act == i) indev_obj_act = NULL;
   19855:	48 3b 05 64 e7 23 00 	cmp    0x23e764(%rip),%rax        # 257fc0 <indev_act>
   1985c:	75 0b                	jne    19869 <lv_indev_reset+0x5f>
   1985e:	48 c7 05 4f e7 23 00 	movq   $0x0,0x23e74f(%rip)        # 257fb8 <indev_obj_act>
   19865:	00 00 00 00 
            if(obj == NULL || i->proc.types.pointer.last_pressed == obj) {
   19869:	48 85 db             	test   %rbx,%rbx
   1986c:	74 06                	je     19874 <lv_indev_reset+0x6a>
   1986e:	48 3b 58 68          	cmp    0x68(%rax),%rbx
   19872:	75 08                	jne    1987c <lv_indev_reset+0x72>
                i->proc.types.pointer.last_pressed = NULL;
   19874:	48 c7 40 68 00 00 00 	movq   $0x0,0x68(%rax)
   1987b:	00 
            i = lv_indev_get_next(i);
   1987c:	48 89 c7             	mov    %rax,%rdi
   1987f:	eb c3                	jmp    19844 <lv_indev_reset+0x3a>
}
   19881:	5b                   	pop    %rbx
   19882:	c3                   	retq   
   19883:	c3                   	retq   

0000000000019884 <_lv_indev_init>:
    lv_indev_reset(NULL, NULL); /*Reset all input devices*/
   19884:	31 f6                	xor    %esi,%esi
   19886:	31 ff                	xor    %edi,%edi
   19888:	e9 7d ff ff ff       	jmpq   1980a <lv_indev_reset>

000000000001988d <lv_indev_is_dragging>:
    if(indev == NULL) return false;
   1988d:	31 c0                	xor    %eax,%eax
   1988f:	48 85 ff             	test   %rdi,%rdi
   19892:	74 11                	je     198a5 <lv_indev_is_dragging+0x18>
    if(indev->driver.type != LV_INDEV_TYPE_POINTER && indev->driver.type != LV_INDEV_TYPE_BUTTON) return false;
   19894:	8a 17                	mov    (%rdi),%dl
   19896:	83 e2 fd             	and    $0xfffffffd,%edx
   19899:	fe ca                	dec    %dl
   1989b:	75 08                	jne    198a5 <lv_indev_is_dragging+0x18>
    return indev->proc.types.pointer.drag_in_prog == 0 ? false : true;
   1989d:	8a 47 76             	mov    0x76(%rdi),%al
   198a0:	d0 e8                	shr    %al
   198a2:	83 e0 01             	and    $0x1,%eax
}
   198a5:	c3                   	retq   

00000000000198a6 <lv_indev_search_obj>:
{
   198a6:	41 55                	push   %r13
   198a8:	41 54                	push   %r12
   198aa:	49 89 f5             	mov    %rsi,%r13
   198ad:	55                   	push   %rbp
   198ae:	53                   	push   %rbx
   198af:	48 89 fb             	mov    %rdi,%rbx
   198b2:	48 83 ec 08          	sub    $0x8,%rsp
    if(lv_obj_hittest(obj, point)) {
   198b6:	e8 54 2a 00 00       	callq  1c30f <lv_obj_hittest>
   198bb:	84 c0                	test   %al,%al
   198bd:	75 04                	jne    198c3 <lv_indev_search_obj+0x1d>
    lv_obj_t * found_p = NULL;
   198bf:	31 c0                	xor    %eax,%eax
   198c1:	eb 61                	jmp    19924 <lv_indev_search_obj+0x7e>
        _LV_LL_READ(obj->child_ll, i) {
   198c3:	4c 8d 63 08          	lea    0x8(%rbx),%r12
   198c7:	4c 89 e7             	mov    %r12,%rdi
   198ca:	e8 9c c3 00 00       	callq  25c6b <_lv_ll_get_head>
   198cf:	48 85 c0             	test   %rax,%rax
   198d2:	48 89 c5             	mov    %rax,%rbp
   198d5:	74 1d                	je     198f4 <lv_indev_search_obj+0x4e>
            found_p = lv_indev_search_obj(i, point);
   198d7:	4c 89 ee             	mov    %r13,%rsi
   198da:	48 89 ef             	mov    %rbp,%rdi
   198dd:	e8 c4 ff ff ff       	callq  198a6 <lv_indev_search_obj>
            if(found_p != NULL) {
   198e2:	48 85 c0             	test   %rax,%rax
   198e5:	75 3d                	jne    19924 <lv_indev_search_obj+0x7e>
        _LV_LL_READ(obj->child_ll, i) {
   198e7:	48 89 ee             	mov    %rbp,%rsi
   198ea:	4c 89 e7             	mov    %r12,%rdi
   198ed:	e8 91 c3 00 00       	callq  25c83 <_lv_ll_get_next>
   198f2:	eb db                	jmp    198cf <lv_indev_search_obj+0x29>
        if(found_p == NULL && lv_obj_get_click(obj) != false) {
   198f4:	48 89 df             	mov    %rbx,%rdi
            lv_obj_t * hidden_i = obj;
   198f7:	48 89 dd             	mov    %rbx,%rbp
        if(found_p == NULL && lv_obj_get_click(obj) != false) {
   198fa:	e8 58 17 00 00       	callq  1b057 <lv_obj_get_click>
   198ff:	84 c0                	test   %al,%al
   19901:	74 bc                	je     198bf <lv_indev_search_obj+0x19>
            while(hidden_i != NULL) {
   19903:	48 85 ed             	test   %rbp,%rbp
   19906:	74 19                	je     19921 <lv_indev_search_obj+0x7b>
                if(lv_obj_get_hidden(hidden_i) == true) break;
   19908:	48 89 ef             	mov    %rbp,%rdi
   1990b:	e8 26 12 00 00       	callq  1ab36 <lv_obj_get_hidden>
   19910:	84 c0                	test   %al,%al
   19912:	75 ab                	jne    198bf <lv_indev_search_obj+0x19>
                hidden_i = lv_obj_get_parent(hidden_i);
   19914:	48 89 ef             	mov    %rbp,%rdi
   19917:	e8 03 0f 00 00       	callq  1a81f <lv_obj_get_parent>
   1991c:	48 89 c5             	mov    %rax,%rbp
   1991f:	eb e2                	jmp    19903 <lv_indev_search_obj+0x5d>
            if(hidden_i == NULL) found_p = obj;
   19921:	48 89 d8             	mov    %rbx,%rax
}
   19924:	5a                   	pop    %rdx
   19925:	5b                   	pop    %rbx
   19926:	5d                   	pop    %rbp
   19927:	41 5c                	pop    %r12
   19929:	41 5d                	pop    %r13
   1992b:	c3                   	retq   

000000000001992c <indev_proc_press>:
    if(proc->wait_until_release != 0) return;
   1992c:	f6 47 48 08          	testb  $0x8,0x48(%rdi)
    indev_obj_act = proc->types.pointer.act_obj;
   19930:	48 8b 47 20          	mov    0x20(%rdi),%rax
   19934:	48 89 05 7d e6 23 00 	mov    %rax,0x23e67d(%rip)        # 257fb8 <indev_obj_act>
    if(proc->wait_until_release != 0) return;
   1993b:	0f 85 60 09 00 00    	jne    1a2a1 <indev_proc_press+0x975>
{
   19941:	41 57                	push   %r15
   19943:	41 56                	push   %r14
   19945:	41 55                	push   %r13
   19947:	41 54                	push   %r12
   19949:	49 89 fd             	mov    %rdi,%r13
   1994c:	55                   	push   %rbp
   1994d:	53                   	push   %rbx
   1994e:	48 83 ec 18          	sub    $0x18,%rsp
    lv_disp_t * disp = indev_act->driver.disp;
   19952:	48 8b 15 67 e6 23 00 	mov    0x23e667(%rip),%rdx        # 257fc0 <indev_act>
    if(indev_obj_act == NULL) {
   19959:	48 85 c0             	test   %rax,%rax
    lv_disp_t * disp = indev_act->driver.disp;
   1995c:	48 8b 5a 20          	mov    0x20(%rdx),%rbx
    if(indev_obj_act == NULL) {
   19960:	74 1c                	je     1997e <indev_proc_press+0x52>
    else if(proc->types.pointer.drag_in_prog == 0 &&
   19962:	41 f6 45 3e 02       	testb  $0x2,0x3e(%r13)
    if(indev_obj_act && (lv_obj_get_state(indev_obj_act, LV_OBJ_PART_MAIN) & LV_STATE_DISABLED)) {
   19967:	48 89 c7             	mov    %rax,%rdi
    else if(proc->types.pointer.drag_in_prog == 0 &&
   1996a:	0f 85 99 00 00 00    	jne    19a09 <indev_proc_press+0xdd>
            lv_obj_is_protected(indev_obj_act, LV_PROTECT_PRESS_LOST) == false) {
   19970:	be 10 00 00 00       	mov    $0x10,%esi
   19975:	e8 4c 1c 00 00       	callq  1b5c6 <lv_obj_is_protected>
    else if(proc->types.pointer.drag_in_prog == 0 &&
   1997a:	84 c0                	test   %al,%al
   1997c:	75 7f                	jne    199fd <indev_proc_press+0xd1>
        indev_obj_act = lv_indev_search_obj(lv_disp_get_layer_sys(disp), &proc->types.pointer.act_point);
   1997e:	49 8d 6d 08          	lea    0x8(%r13),%rbp
   19982:	48 89 df             	mov    %rbx,%rdi
   19985:	e8 cf f9 ff ff       	callq  19359 <lv_disp_get_layer_sys>
   1998a:	48 89 ee             	mov    %rbp,%rsi
   1998d:	48 89 c7             	mov    %rax,%rdi
   19990:	e8 11 ff ff ff       	callq  198a6 <lv_indev_search_obj>
        if(indev_obj_act == NULL) indev_obj_act = lv_indev_search_obj(lv_disp_get_layer_top(disp),
   19995:	48 85 c0             	test   %rax,%rax
        indev_obj_act = lv_indev_search_obj(lv_disp_get_layer_sys(disp), &proc->types.pointer.act_point);
   19998:	48 89 05 19 e6 23 00 	mov    %rax,0x23e619(%rip)        # 257fb8 <indev_obj_act>
        if(indev_obj_act == NULL) indev_obj_act = lv_indev_search_obj(lv_disp_get_layer_top(disp),
   1999f:	75 1a                	jne    199bb <indev_proc_press+0x8f>
   199a1:	48 89 df             	mov    %rbx,%rdi
   199a4:	e8 64 f9 ff ff       	callq  1930d <lv_disp_get_layer_top>
   199a9:	48 89 ee             	mov    %rbp,%rsi
   199ac:	48 89 c7             	mov    %rax,%rdi
   199af:	e8 f2 fe ff ff       	callq  198a6 <lv_indev_search_obj>
   199b4:	48 89 05 fd e5 23 00 	mov    %rax,0x23e5fd(%rip)        # 257fb8 <indev_obj_act>
        if(indev_obj_act == NULL) indev_obj_act = lv_indev_search_obj(lv_disp_get_scr_act(disp),
   199bb:	48 83 3d f5 e5 23 00 	cmpq   $0x0,0x23e5f5(%rip)        # 257fb8 <indev_obj_act>
   199c2:	00 
   199c3:	75 1a                	jne    199df <indev_proc_press+0xb3>
   199c5:	48 89 df             	mov    %rbx,%rdi
   199c8:	e8 88 f8 ff ff       	callq  19255 <lv_disp_get_scr_act>
   199cd:	48 89 ee             	mov    %rbp,%rsi
   199d0:	48 89 c7             	mov    %rax,%rdi
   199d3:	e8 ce fe ff ff       	callq  198a6 <lv_indev_search_obj>
   199d8:	48 89 05 d9 e5 23 00 	mov    %rax,0x23e5d9(%rip)        # 257fb8 <indev_obj_act>
    if(new_obj_searched && proc->types.pointer.last_obj) {
   199df:	49 83 7d 28 00       	cmpq   $0x0,0x28(%r13)
   199e4:	74 17                	je     199fd <indev_proc_press+0xd1>
    if(proc->types.pointer.drag_in_prog == 0) return;
   199e6:	41 f6 45 3e 02       	testb  $0x2,0x3e(%r13)
        proc->types.pointer.drag_throw_vect.x = 0;
   199eb:	41 c7 45 18 00 00 00 	movl   $0x0,0x18(%r13)
   199f2:	00 
    if(proc->types.pointer.drag_in_prog == 0) return;
   199f3:	74 08                	je     199fd <indev_proc_press+0xd1>
   199f5:	4c 89 ef             	mov    %r13,%rdi
   199f8:	e8 4c fa ff ff       	callq  19449 <indev_drag_throw.part.4>
    if(indev_obj_act && (lv_obj_get_state(indev_obj_act, LV_OBJ_PART_MAIN) & LV_STATE_DISABLED)) {
   199fd:	48 8b 3d b4 e5 23 00 	mov    0x23e5b4(%rip),%rdi        # 257fb8 <indev_obj_act>
   19a04:	48 85 ff             	test   %rdi,%rdi
   19a07:	74 16                	je     19a1f <indev_proc_press+0xf3>
   19a09:	31 f6                	xor    %esi,%esi
   19a0b:	e8 be 1b 00 00       	callq  1b5ce <lv_obj_get_state>
   19a10:	a8 20                	test   $0x20,%al
   19a12:	74 0b                	je     19a1f <indev_proc_press+0xf3>
        indev_obj_act = proc->types.pointer.act_obj;
   19a14:	49 8b 45 20          	mov    0x20(%r13),%rax
   19a18:	48 89 05 99 e5 23 00 	mov    %rax,0x23e599(%rip)        # 257fb8 <indev_obj_act>
    if(indev_obj_act != proc->types.pointer.act_obj) {
   19a1f:	49 8b 5d 20          	mov    0x20(%r13),%rbx
   19a23:	48 3b 1d 8e e5 23 00 	cmp    0x23e58e(%rip),%rbx        # 257fb8 <indev_obj_act>
   19a2a:	75 4b                	jne    19a77 <indev_proc_press+0x14b>
    proc->types.pointer.drag_throw_vect.x = (proc->types.pointer.drag_throw_vect.x * 5) >> 3;
   19a2c:	41 0f bf 55 18       	movswl 0x18(%r13),%edx
    proc->types.pointer.drag_throw_vect.y = (proc->types.pointer.drag_throw_vect.y * 5) >> 3;
   19a31:	41 0f bf 45 1a       	movswl 0x1a(%r13),%eax
    proc->types.pointer.vect.x = proc->types.pointer.act_point.x - proc->types.pointer.last_point.x;
   19a36:	41 8b 7d 08          	mov    0x8(%r13),%edi
    proc->types.pointer.vect.y = proc->types.pointer.act_point.y - proc->types.pointer.last_point.y;
   19a3a:	66 41 8b 75 0a       	mov    0xa(%r13),%si
    proc->types.pointer.vect.x = proc->types.pointer.act_point.x - proc->types.pointer.last_point.x;
   19a3f:	41 2b 7d 0c          	sub    0xc(%r13),%edi
    proc->types.pointer.vect.y = proc->types.pointer.act_point.y - proc->types.pointer.last_point.y;
   19a43:	66 41 2b 75 0e       	sub    0xe(%r13),%si
    proc->types.pointer.drag_throw_vect.x = (proc->types.pointer.drag_throw_vect.x * 5) >> 3;
   19a48:	8d 14 92             	lea    (%rdx,%rdx,4),%edx
    proc->types.pointer.drag_throw_vect.y = (proc->types.pointer.drag_throw_vect.y * 5) >> 3;
   19a4b:	8d 04 80             	lea    (%rax,%rax,4),%eax
    proc->types.pointer.drag_throw_vect.x = (proc->types.pointer.drag_throw_vect.x * 5) >> 3;
   19a4e:	c1 fa 03             	sar    $0x3,%edx
    proc->types.pointer.drag_throw_vect.y = (proc->types.pointer.drag_throw_vect.y * 5) >> 3;
   19a51:	c1 f8 03             	sar    $0x3,%eax
    proc->types.pointer.vect.x = proc->types.pointer.act_point.x - proc->types.pointer.last_point.x;
   19a54:	66 41 89 7d 10       	mov    %di,0x10(%r13)
    if(proc->types.pointer.drag_throw_vect.x < 0)
   19a59:	85 d2                	test   %edx,%edx
    proc->types.pointer.vect.y = proc->types.pointer.act_point.y - proc->types.pointer.last_point.y;
   19a5b:	66 41 89 75 12       	mov    %si,0x12(%r13)
    proc->types.pointer.drag_throw_vect.x = (proc->types.pointer.drag_throw_vect.x * 5) >> 3;
   19a60:	66 41 89 55 18       	mov    %dx,0x18(%r13)
    proc->types.pointer.drag_throw_vect.y = (proc->types.pointer.drag_throw_vect.y * 5) >> 3;
   19a65:	66 41 89 45 1a       	mov    %ax,0x1a(%r13)
    if(proc->types.pointer.drag_throw_vect.x < 0)
   19a6a:	0f 89 f8 01 00 00    	jns    19c68 <indev_proc_press+0x33c>
        proc->types.pointer.drag_throw_vect.x++;
   19a70:	ff c2                	inc    %edx
   19a72:	e9 f5 01 00 00       	jmpq   19c6c <indev_proc_press+0x340>
   19a77:	66 41 8b 45 0a       	mov    0xa(%r13),%ax
        proc->types.pointer.last_point.x = proc->types.pointer.act_point.x;
   19a7c:	41 8b 55 08          	mov    0x8(%r13),%edx
        if(proc->types.pointer.act_obj != NULL) {
   19a80:	48 85 db             	test   %rbx,%rbx
        proc->types.pointer.last_point.x = proc->types.pointer.act_point.x;
   19a83:	66 41 89 55 0c       	mov    %dx,0xc(%r13)
        proc->types.pointer.last_point.y = proc->types.pointer.act_point.y;
   19a88:	66 41 89 45 0e       	mov    %ax,0xe(%r13)
        if(proc->types.pointer.act_obj != NULL) {
   19a8d:	75 51                	jne    19ae0 <indev_proc_press+0x1b4>
        proc->types.pointer.act_obj  = indev_obj_act; /*Save the pressed object*/
   19a8f:	48 8b 05 22 e5 23 00 	mov    0x23e522(%rip),%rax        # 257fb8 <indev_obj_act>
        if(indev_obj_act != NULL) {
   19a96:	48 85 c0             	test   %rax,%rax
        proc->types.pointer.act_obj  = indev_obj_act; /*Save the pressed object*/
   19a99:	49 89 45 20          	mov    %rax,0x20(%r13)
        proc->types.pointer.last_obj = indev_obj_act;
   19a9d:	49 89 45 28          	mov    %rax,0x28(%r13)
        if(indev_obj_act != NULL) {
   19aa1:	74 89                	je     19a2c <indev_proc_press+0x100>
            proc->pr_timestamp                 = lv_tick_get();
   19aa3:	e8 e6 b9 00 00       	callq  2548e <lv_tick_get>
   19aa8:	41 89 45 40          	mov    %eax,0x40(%r13)
            proc->types.pointer.drag_dir = LV_DRAG_DIR_BOTH;
   19aac:	41 8a 45 3e          	mov    0x3e(%r13),%al
            lv_obj_t * last_top = NULL;
   19ab0:	31 db                	xor    %ebx,%ebx
            proc->long_pr_sent                 = 0;
   19ab2:	41 80 65 48 fe       	andb   $0xfe,0x48(%r13)
            proc->types.pointer.gesture_sum.x  = 0;
   19ab7:	66 41 c7 45 3a 00 00 	movw   $0x0,0x3a(%r13)
            proc->types.pointer.gesture_sum.y  = 0;
   19abe:	66 41 c7 45 3c 00 00 	movw   $0x0,0x3c(%r13)
            proc->types.pointer.vect.x         = 0;
   19ac5:	49 c7 45 10 00 00 00 	movq   $0x0,0x10(%r13)
   19acc:	00 
            proc->types.pointer.drag_dir = LV_DRAG_DIR_BOTH;
   19acd:	83 e0 c0             	and    $0xffffffc0,%eax
            proc->types.pointer.gesture_sent   = 0;
   19ad0:	83 c8 0c             	or     $0xc,%eax
   19ad3:	41 88 45 3e          	mov    %al,0x3e(%r13)
            lv_obj_t * i        = indev_obj_act;
   19ad7:	48 8b 05 da e4 23 00 	mov    0x23e4da(%rip),%rax        # 257fb8 <indev_obj_act>
            while(i != NULL) {
   19ade:	eb 46                	jmp    19b26 <indev_proc_press+0x1fa>
            last_obj->signal_cb(last_obj, LV_SIGNAL_PRESS_LOST, indev_act);
   19ae0:	48 8b 15 d9 e4 23 00 	mov    0x23e4d9(%rip),%rdx        # 257fc0 <indev_act>
   19ae7:	be 0d 00 00 00       	mov    $0xd,%esi
   19aec:	48 89 df             	mov    %rbx,%rdi
   19aef:	ff 53 30             	callq  *0x30(%rbx)
            if(indev_reset_check(proc)) return;
   19af2:	4c 89 ef             	mov    %r13,%rdi
   19af5:	e8 ab f8 ff ff       	callq  193a5 <indev_reset_check>
   19afa:	84 c0                	test   %al,%al
   19afc:	0f 85 90 07 00 00    	jne    1a292 <indev_proc_press+0x966>
            lv_event_send(last_obj, LV_EVENT_PRESS_LOST, NULL);
   19b02:	31 d2                	xor    %edx,%edx
   19b04:	be 02 00 00 00       	mov    $0x2,%esi
   19b09:	48 89 df             	mov    %rbx,%rdi
   19b0c:	e8 9f 0c 00 00       	callq  1a7b0 <lv_event_send>
            if(indev_reset_check(proc)) return;
   19b11:	4c 89 ef             	mov    %r13,%rdi
   19b14:	e8 8c f8 ff ff       	callq  193a5 <indev_reset_check>
   19b19:	84 c0                	test   %al,%al
   19b1b:	0f 84 6e ff ff ff    	je     19a8f <indev_proc_press+0x163>
   19b21:	e9 6c 07 00 00       	jmpq   1a292 <indev_proc_press+0x966>
            while(i != NULL) {
   19b26:	48 85 c0             	test   %rax,%rax
   19b29:	74 12                	je     19b3d <indev_proc_press+0x211>
   19b2b:	f6 40 5a 20          	testb  $0x20,0x5a(%rax)
                i = lv_obj_get_parent(i);
   19b2f:	48 89 c7             	mov    %rax,%rdi
   19b32:	48 0f 45 d8          	cmovne %rax,%rbx
   19b36:	e8 e4 0c 00 00       	callq  1a81f <lv_obj_get_parent>
   19b3b:	eb e9                	jmp    19b26 <indev_proc_press+0x1fa>
            if(last_top != NULL) {
   19b3d:	48 85 db             	test   %rbx,%rbx
   19b40:	74 08                	je     19b4a <indev_proc_press+0x21e>
                lv_obj_move_foreground(last_top);
   19b42:	48 89 df             	mov    %rbx,%rdi
   19b45:	e8 43 12 00 00       	callq  1ad8d <lv_obj_move_foreground>
            indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_PRESSED, indev_act);
   19b4a:	48 8b 05 67 e4 23 00 	mov    0x23e467(%rip),%rax        # 257fb8 <indev_obj_act>
   19b51:	48 8b 15 68 e4 23 00 	mov    0x23e468(%rip),%rdx        # 257fc0 <indev_act>
   19b58:	be 0b 00 00 00       	mov    $0xb,%esi
   19b5d:	48 89 c7             	mov    %rax,%rdi
   19b60:	ff 50 30             	callq  *0x30(%rax)
            if(indev_reset_check(proc)) return;
   19b63:	4c 89 ef             	mov    %r13,%rdi
   19b66:	e8 3a f8 ff ff       	callq  193a5 <indev_reset_check>
   19b6b:	84 c0                	test   %al,%al
   19b6d:	0f 85 1f 07 00 00    	jne    1a292 <indev_proc_press+0x966>
            lv_event_send(indev_obj_act, LV_EVENT_PRESSED, NULL);
   19b73:	48 8b 3d 3e e4 23 00 	mov    0x23e43e(%rip),%rdi        # 257fb8 <indev_obj_act>
   19b7a:	31 d2                	xor    %edx,%edx
   19b7c:	31 f6                	xor    %esi,%esi
   19b7e:	e8 2d 0c 00 00       	callq  1a7b0 <lv_event_send>
            if(indev_reset_check(proc)) return;
   19b83:	4c 89 ef             	mov    %r13,%rdi
   19b86:	e8 1a f8 ff ff       	callq  193a5 <indev_reset_check>
   19b8b:	84 c0                	test   %al,%al
   19b8d:	0f 85 ff 06 00 00    	jne    1a292 <indev_proc_press+0x966>
            if(indev_act->proc.wait_until_release) return;
   19b93:	48 8b 1d 26 e4 23 00 	mov    0x23e426(%rip),%rbx        # 257fc0 <indev_act>
   19b9a:	f6 83 80 00 00 00 08 	testb  $0x8,0x80(%rbx)
   19ba1:	0f 85 eb 06 00 00    	jne    1a292 <indev_proc_press+0x966>
    lv_obj_t * obj_to_focus = lv_obj_get_focused_obj(indev_obj_act);
   19ba7:	48 8b 3d 0a e4 23 00 	mov    0x23e40a(%rip),%rdi        # 257fb8 <indev_obj_act>
   19bae:	e8 a6 36 00 00       	callq  1d259 <lv_obj_get_focused_obj>
    if(lv_obj_is_protected(indev_obj_act, LV_PROTECT_CLICK_FOCUS) == false &&
   19bb3:	48 8b 3d fe e3 23 00 	mov    0x23e3fe(%rip),%rdi        # 257fb8 <indev_obj_act>
   19bba:	be 20 00 00 00       	mov    $0x20,%esi
    lv_obj_t * obj_to_focus = lv_obj_get_focused_obj(indev_obj_act);
   19bbf:	48 89 c5             	mov    %rax,%rbp
    if(lv_obj_is_protected(indev_obj_act, LV_PROTECT_CLICK_FOCUS) == false &&
   19bc2:	e8 ff 19 00 00       	callq  1b5c6 <lv_obj_is_protected>
   19bc7:	84 c0                	test   %al,%al
   19bc9:	0f 85 84 00 00 00    	jne    19c53 <indev_proc_press+0x327>
       proc->types.pointer.last_pressed != obj_to_focus) {
   19bcf:	48 8b 7b 68          	mov    0x68(%rbx),%rdi
    if(lv_obj_is_protected(indev_obj_act, LV_PROTECT_CLICK_FOCUS) == false &&
   19bd3:	48 39 fd             	cmp    %rdi,%rbp
   19bd6:	74 7b                	je     19c53 <indev_proc_press+0x327>
        if(proc->types.pointer.last_pressed) {
   19bd8:	48 85 ff             	test   %rdi,%rdi
            indev_click_focus(&indev_act->proc);
   19bdb:	4c 8d 63 38          	lea    0x38(%rbx),%r12
        if(proc->types.pointer.last_pressed) {
   19bdf:	75 1d                	jne    19bfe <indev_proc_press+0x2d2>
        lv_signal_send(obj_to_focus, LV_SIGNAL_FOCUS, NULL);
   19be1:	31 d2                	xor    %edx,%edx
   19be3:	be 16 00 00 00       	mov    $0x16,%esi
   19be8:	48 89 ef             	mov    %rbp,%rdi
   19beb:	e8 e5 0b 00 00       	callq  1a7d5 <lv_signal_send>
        if(indev_reset_check(proc)) return;
   19bf0:	4c 89 e7             	mov    %r12,%rdi
   19bf3:	e8 ad f7 ff ff       	callq  193a5 <indev_reset_check>
   19bf8:	84 c0                	test   %al,%al
   19bfa:	75 57                	jne    19c53 <indev_proc_press+0x327>
   19bfc:	eb 36                	jmp    19c34 <indev_proc_press+0x308>
            lv_signal_send(proc->types.pointer.last_pressed, LV_SIGNAL_DEFOCUS, NULL);
   19bfe:	31 d2                	xor    %edx,%edx
   19c00:	be 17 00 00 00       	mov    $0x17,%esi
   19c05:	e8 cb 0b 00 00       	callq  1a7d5 <lv_signal_send>
            if(indev_reset_check(proc)) return;
   19c0a:	4c 89 e7             	mov    %r12,%rdi
   19c0d:	e8 93 f7 ff ff       	callq  193a5 <indev_reset_check>
   19c12:	84 c0                	test   %al,%al
   19c14:	75 3d                	jne    19c53 <indev_proc_press+0x327>
            lv_event_send(proc->types.pointer.last_pressed, LV_EVENT_DEFOCUSED, NULL);
   19c16:	48 8b 7b 68          	mov    0x68(%rbx),%rdi
   19c1a:	31 d2                	xor    %edx,%edx
   19c1c:	be 0e 00 00 00       	mov    $0xe,%esi
   19c21:	e8 8a 0b 00 00       	callq  1a7b0 <lv_event_send>
            if(indev_reset_check(proc)) return;
   19c26:	4c 89 e7             	mov    %r12,%rdi
   19c29:	e8 77 f7 ff ff       	callq  193a5 <indev_reset_check>
   19c2e:	84 c0                	test   %al,%al
   19c30:	74 af                	je     19be1 <indev_proc_press+0x2b5>
   19c32:	eb 1f                	jmp    19c53 <indev_proc_press+0x327>
        lv_event_send(obj_to_focus, LV_EVENT_FOCUSED, NULL);
   19c34:	31 d2                	xor    %edx,%edx
   19c36:	be 0d 00 00 00       	mov    $0xd,%esi
   19c3b:	48 89 ef             	mov    %rbp,%rdi
   19c3e:	e8 6d 0b 00 00       	callq  1a7b0 <lv_event_send>
        if(indev_reset_check(proc)) return;
   19c43:	4c 89 e7             	mov    %r12,%rdi
   19c46:	e8 5a f7 ff ff       	callq  193a5 <indev_reset_check>
   19c4b:	84 c0                	test   %al,%al
   19c4d:	75 04                	jne    19c53 <indev_proc_press+0x327>
        proc->types.pointer.last_pressed = obj_to_focus;
   19c4f:	48 89 6b 68          	mov    %rbp,0x68(%rbx)
            if(indev_reset_check(proc)) return;
   19c53:	4c 89 ef             	mov    %r13,%rdi
   19c56:	e8 4a f7 ff ff       	callq  193a5 <indev_reset_check>
   19c5b:	84 c0                	test   %al,%al
   19c5d:	0f 84 c9 fd ff ff    	je     19a2c <indev_proc_press+0x100>
   19c63:	e9 2a 06 00 00       	jmpq   1a292 <indev_proc_press+0x966>
    else if(proc->types.pointer.drag_throw_vect.x > 0)
   19c68:	74 07                	je     19c71 <indev_proc_press+0x345>
        proc->types.pointer.drag_throw_vect.x--;
   19c6a:	ff ca                	dec    %edx
   19c6c:	66 41 89 55 18       	mov    %dx,0x18(%r13)
    if(proc->types.pointer.drag_throw_vect.y < 0)
   19c71:	85 c0                	test   %eax,%eax
   19c73:	79 04                	jns    19c79 <indev_proc_press+0x34d>
        proc->types.pointer.drag_throw_vect.y++;
   19c75:	ff c0                	inc    %eax
   19c77:	eb 04                	jmp    19c7d <indev_proc_press+0x351>
    else if(proc->types.pointer.drag_throw_vect.y > 0)
   19c79:	74 07                	je     19c82 <indev_proc_press+0x356>
        proc->types.pointer.drag_throw_vect.y--;
   19c7b:	ff c8                	dec    %eax
   19c7d:	66 41 89 45 1a       	mov    %ax,0x1a(%r13)
    if(indev_obj_act != NULL) {
   19c82:	48 8b 05 2f e3 23 00 	mov    0x23e32f(%rip),%rax        # 257fb8 <indev_obj_act>
    proc->types.pointer.drag_throw_vect.x += (proc->types.pointer.vect.x * 4) >> 3;
   19c89:	0f bf ff             	movswl %di,%edi
    proc->types.pointer.drag_throw_vect.y += (proc->types.pointer.vect.y * 4) >> 3;
   19c8c:	0f bf f6             	movswl %si,%esi
    proc->types.pointer.drag_throw_vect.x += (proc->types.pointer.vect.x * 4) >> 3;
   19c8f:	d1 ff                	sar    %edi
    proc->types.pointer.drag_throw_vect.y += (proc->types.pointer.vect.y * 4) >> 3;
   19c91:	d1 fe                	sar    %esi
    proc->types.pointer.drag_throw_vect.x += (proc->types.pointer.vect.x * 4) >> 3;
   19c93:	66 41 01 7d 18       	add    %di,0x18(%r13)
    proc->types.pointer.drag_throw_vect.y += (proc->types.pointer.vect.y * 4) >> 3;
   19c98:	66 41 01 75 1a       	add    %si,0x1a(%r13)
    if(indev_obj_act != NULL) {
   19c9d:	48 85 c0             	test   %rax,%rax
   19ca0:	0f 84 ec 05 00 00    	je     1a292 <indev_proc_press+0x966>
        indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_PRESSING, indev_act);
   19ca6:	be 0c 00 00 00       	mov    $0xc,%esi
   19cab:	48 89 c7             	mov    %rax,%rdi
   19cae:	48 8b 15 0b e3 23 00 	mov    0x23e30b(%rip),%rdx        # 257fc0 <indev_act>
   19cb5:	ff 50 30             	callq  *0x30(%rax)
        if(indev_reset_check(proc)) return;
   19cb8:	4c 89 ef             	mov    %r13,%rdi
   19cbb:	e8 e5 f6 ff ff       	callq  193a5 <indev_reset_check>
   19cc0:	84 c0                	test   %al,%al
   19cc2:	0f 85 ca 05 00 00    	jne    1a292 <indev_proc_press+0x966>
        lv_event_send(indev_obj_act, LV_EVENT_PRESSING, NULL);
   19cc8:	48 8b 3d e9 e2 23 00 	mov    0x23e2e9(%rip),%rdi        # 257fb8 <indev_obj_act>
   19ccf:	31 d2                	xor    %edx,%edx
   19cd1:	be 01 00 00 00       	mov    $0x1,%esi
   19cd6:	e8 d5 0a 00 00       	callq  1a7b0 <lv_event_send>
        if(indev_reset_check(proc)) return;
   19cdb:	4c 89 ef             	mov    %r13,%rdi
   19cde:	e8 c2 f6 ff ff       	callq  193a5 <indev_reset_check>
   19ce3:	84 c0                	test   %al,%al
   19ce5:	40 88 c5             	mov    %al,%bpl
   19ce8:	0f 85 a4 05 00 00    	jne    1a292 <indev_proc_press+0x966>
        if(indev_act->proc.wait_until_release) return;
   19cee:	48 8b 05 cb e2 23 00 	mov    0x23e2cb(%rip),%rax        # 257fc0 <indev_act>
   19cf5:	f6 80 80 00 00 00 08 	testb  $0x8,0x80(%rax)
   19cfc:	0f 85 90 05 00 00    	jne    1a292 <indev_proc_press+0x966>
    lv_obj_t * drag_obj    = get_dragged_obj(proc->types.pointer.act_obj);
   19d02:	49 8b 7d 20          	mov    0x20(%r13),%rdi
   19d06:	e8 10 f7 ff ff       	callq  1941b <get_dragged_obj>
    if(drag_obj == NULL) return;
   19d0b:	48 85 c0             	test   %rax,%rax
    lv_obj_t * drag_obj    = get_dragged_obj(proc->types.pointer.act_obj);
   19d0e:	48 89 c3             	mov    %rax,%rbx
    if(drag_obj == NULL) return;
   19d11:	0f 84 5b 03 00 00    	je     1a072 <indev_proc_press+0x746>
    if(lv_obj_get_drag(drag_obj) == false) return;
   19d17:	48 89 c7             	mov    %rax,%rdi
   19d1a:	e8 3f 13 00 00       	callq  1b05e <lv_obj_get_drag>
   19d1f:	84 c0                	test   %al,%al
   19d21:	41 88 c4             	mov    %al,%r12b
   19d24:	0f 84 48 03 00 00    	je     1a072 <indev_proc_press+0x746>
    lv_drag_dir_t allowed_dirs = lv_obj_get_drag_dir(drag_obj);
   19d2a:	48 89 df             	mov    %rbx,%rdi
   19d2d:	e8 35 13 00 00       	callq  1b067 <lv_obj_get_drag_dir>
    if(proc->types.pointer.drag_limit_out == 0) {
   19d32:	41 f6 45 3e 01       	testb  $0x1,0x3e(%r13)
    lv_drag_dir_t allowed_dirs = lv_obj_get_drag_dir(drag_obj);
   19d37:	41 88 c0             	mov    %al,%r8b
    if(proc->types.pointer.drag_limit_out == 0) {
   19d3a:	0f 85 ae 00 00 00    	jne    19dee <indev_proc_press+0x4c2>
        proc->types.pointer.drag_sum.x += proc->types.pointer.vect.x;
   19d40:	41 8b 55 10          	mov    0x10(%r13),%edx
        proc->types.pointer.drag_sum.y += proc->types.pointer.vect.y;
   19d44:	66 41 8b 45 12       	mov    0x12(%r13),%ax
        if(allowed_dirs == LV_DRAG_DIR_VER || allowed_dirs == LV_DRAG_DIR_BOTH) {
   19d49:	41 8d 78 fe          	lea    -0x2(%r8),%edi
        proc->types.pointer.drag_sum.x += proc->types.pointer.vect.x;
   19d4d:	41 03 55 14          	add    0x14(%r13),%edx
        proc->types.pointer.drag_sum.y += proc->types.pointer.vect.y;
   19d51:	66 41 03 45 16       	add    0x16(%r13),%ax
        if(allowed_dirs == LV_DRAG_DIR_HOR || allowed_dirs == LV_DRAG_DIR_BOTH) {
   19d56:	44 88 c6             	mov    %r8b,%sil
   19d59:	83 e6 fd             	and    $0xfffffffd,%esi
        if(allowed_dirs == LV_DRAG_DIR_VER || allowed_dirs == LV_DRAG_DIR_BOTH) {
   19d5c:	40 80 ff 01          	cmp    $0x1,%dil
        proc->types.pointer.drag_sum.x += proc->types.pointer.vect.x;
   19d60:	66 41 89 55 14       	mov    %dx,0x14(%r13)
        proc->types.pointer.drag_sum.y += proc->types.pointer.vect.y;
   19d65:	66 41 89 45 16       	mov    %ax,0x16(%r13)
        if(allowed_dirs == LV_DRAG_DIR_VER || allowed_dirs == LV_DRAG_DIR_BOTH) {
   19d6a:	76 35                	jbe    19da1 <indev_proc_press+0x475>
        if(allowed_dirs == LV_DRAG_DIR_ONE) {
   19d6c:	41 80 f8 04          	cmp    $0x4,%r8b
   19d70:	75 24                	jne    19d96 <indev_proc_press+0x46a>
            if(LV_MATH_ABS(proc->types.pointer.drag_sum.x) > LV_MATH_ABS(proc->types.pointer.drag_sum.y)) {
   19d72:	0f bf f2             	movswl %dx,%esi
   19d75:	89 f7                	mov    %esi,%edi
   19d77:	c1 ff 1f             	sar    $0x1f,%edi
   19d7a:	31 fe                	xor    %edi,%esi
   19d7c:	29 fe                	sub    %edi,%esi
   19d7e:	89 f7                	mov    %esi,%edi
   19d80:	0f bf f0             	movswl %ax,%esi
   19d83:	41 89 f1             	mov    %esi,%r9d
   19d86:	41 c1 f9 1f          	sar    $0x1f,%r9d
   19d8a:	44 31 ce             	xor    %r9d,%esi
   19d8d:	44 29 ce             	sub    %r9d,%esi
   19d90:	39 f7                	cmp    %esi,%edi
   19d92:	7f 15                	jg     19da9 <indev_proc_press+0x47d>
   19d94:	eb 37                	jmp    19dcd <indev_proc_press+0x4a1>
        if((hor_en && LV_MATH_ABS(proc->types.pointer.drag_sum.x) >= indev_act->driver.drag_limit) ||
   19d96:	40 fe ce             	dec    %sil
   19d99:	0f 85 d3 02 00 00    	jne    1a072 <indev_proc_press+0x746>
   19d9f:	eb 08                	jmp    19da9 <indev_proc_press+0x47d>
   19da1:	40 fe ce             	dec    %sil
   19da4:	75 27                	jne    19dcd <indev_proc_press+0x4a1>
                ver_en = true;
   19da6:	44 88 e5             	mov    %r12b,%bpl
        if((hor_en && LV_MATH_ABS(proc->types.pointer.drag_sum.x) >= indev_act->driver.drag_limit) ||
   19da9:	0f bf d2             	movswl %dx,%edx
   19dac:	89 d6                	mov    %edx,%esi
   19dae:	c1 fe 1f             	sar    $0x1f,%esi
   19db1:	31 f2                	xor    %esi,%edx
   19db3:	29 f2                	sub    %esi,%edx
   19db5:	48 8b 35 04 e2 23 00 	mov    0x23e204(%rip),%rsi        # 257fc0 <indev_act>
   19dbc:	0f b6 76 30          	movzbl 0x30(%rsi),%esi
   19dc0:	39 f2                	cmp    %esi,%edx
   19dc2:	7d 22                	jge    19de6 <indev_proc_press+0x4ba>
   19dc4:	40 84 ed             	test   %bpl,%bpl
   19dc7:	0f 84 a5 02 00 00    	je     1a072 <indev_proc_press+0x746>
           (ver_en && LV_MATH_ABS(proc->types.pointer.drag_sum.y) >= indev_act->driver.drag_limit)) {
   19dcd:	98                   	cwtl   
   19dce:	99                   	cltd   
   19dcf:	31 d0                	xor    %edx,%eax
   19dd1:	29 d0                	sub    %edx,%eax
   19dd3:	48 8b 15 e6 e1 23 00 	mov    0x23e1e6(%rip),%rdx        # 257fc0 <indev_act>
   19dda:	0f b6 52 30          	movzbl 0x30(%rdx),%edx
   19dde:	39 d0                	cmp    %edx,%eax
   19de0:	0f 8c 8c 02 00 00    	jl     1a072 <indev_proc_press+0x746>
            proc->types.pointer.drag_limit_out = 1;
   19de6:	41 80 4d 3e 01       	orb    $0x1,0x3e(%r13)
            drag_just_started                   = true;
   19deb:	44 88 e5             	mov    %r12b,%bpl
        if(proc->types.pointer.vect.x != 0 || proc->types.pointer.vect.y != 0) {
   19dee:	41 83 7d 10 00       	cmpl   $0x0,0x10(%r13)
   19df3:	0f 84 79 02 00 00    	je     1a072 <indev_proc_press+0x746>
            lv_coord_t prev_par_w = lv_obj_get_width(lv_obj_get_parent(drag_obj));
   19df9:	48 89 df             	mov    %rbx,%rdi
   19dfc:	44 88 44 24 0a       	mov    %r8b,0xa(%rsp)
            lv_coord_t prev_x     = drag_obj->coords.x1;
   19e01:	44 8b 7b 20          	mov    0x20(%rbx),%r15d
            lv_coord_t prev_y     = drag_obj->coords.y1;
   19e05:	66 44 8b 73 22       	mov    0x22(%rbx),%r14w
            lv_coord_t prev_par_w = lv_obj_get_width(lv_obj_get_parent(drag_obj));
   19e0a:	e8 10 0a 00 00       	callq  1a81f <lv_obj_get_parent>
   19e0f:	48 89 c7             	mov    %rax,%rdi
   19e12:	e8 de 0b 00 00       	callq  1a9f5 <lv_obj_get_width>
            lv_coord_t prev_par_h = lv_obj_get_height(lv_obj_get_parent(drag_obj));
   19e17:	48 89 df             	mov    %rbx,%rdi
            lv_coord_t prev_par_w = lv_obj_get_width(lv_obj_get_parent(drag_obj));
   19e1a:	66 89 44 24 06       	mov    %ax,0x6(%rsp)
            lv_coord_t prev_par_h = lv_obj_get_height(lv_obj_get_parent(drag_obj));
   19e1f:	e8 fb 09 00 00       	callq  1a81f <lv_obj_get_parent>
   19e24:	48 89 c7             	mov    %rax,%rdi
   19e27:	e8 d4 0b 00 00       	callq  1aa00 <lv_obj_get_height>
            lv_coord_t act_x = lv_obj_get_x(drag_obj);
   19e2c:	48 89 df             	mov    %rbx,%rdi
            lv_coord_t prev_par_h = lv_obj_get_height(lv_obj_get_parent(drag_obj));
   19e2f:	66 89 44 24 08       	mov    %ax,0x8(%rsp)
            lv_coord_t act_x = lv_obj_get_x(drag_obj);
   19e34:	e8 88 0b 00 00       	callq  1a9c1 <lv_obj_get_x>
            lv_coord_t act_y = lv_obj_get_y(drag_obj);
   19e39:	48 89 df             	mov    %rbx,%rdi
            lv_coord_t act_x = lv_obj_get_x(drag_obj);
   19e3c:	41 89 c4             	mov    %eax,%r12d
            lv_coord_t act_y = lv_obj_get_y(drag_obj);
   19e3f:	e8 96 0b 00 00       	callq  1a9da <lv_obj_get_y>
            if(allowed_dirs == LV_DRAG_DIR_BOTH) {
   19e44:	44 8a 44 24 0a       	mov    0xa(%rsp),%r8b
            lv_coord_t act_y = lv_obj_get_y(drag_obj);
   19e49:	89 c2                	mov    %eax,%edx
            if(allowed_dirs == LV_DRAG_DIR_BOTH) {
   19e4b:	41 80 f8 03          	cmp    $0x3,%r8b
   19e4f:	75 1d                	jne    19e6e <indev_proc_press+0x542>
                if(drag_just_started) {
   19e51:	40 84 ed             	test   %bpl,%bpl
   19e54:	0f 84 d2 00 00 00    	je     19f2c <indev_proc_press+0x600>
                    proc->types.pointer.drag_dir = LV_DRAG_DIR_BOTH;
   19e5a:	41 8a 45 3e          	mov    0x3e(%r13),%al
                    act_x += proc->types.pointer.drag_sum.x;
   19e5e:	45 03 65 14          	add    0x14(%r13),%r12d
                    proc->types.pointer.drag_dir = LV_DRAG_DIR_BOTH;
   19e62:	83 e0 e3             	and    $0xffffffe3,%eax
   19e65:	83 c8 0c             	or     $0xc,%eax
   19e68:	41 88 45 3e          	mov    %al,0x3e(%r13)
   19e6c:	eb 51                	jmp    19ebf <indev_proc_press+0x593>
            else if(allowed_dirs == LV_DRAG_DIR_HOR) {
   19e6e:	41 80 f8 01          	cmp    $0x1,%r8b
   19e72:	75 27                	jne    19e9b <indev_proc_press+0x56f>
                if(drag_just_started) {
   19e74:	40 84 ed             	test   %bpl,%bpl
   19e77:	0f 84 af 00 00 00    	je     19f2c <indev_proc_press+0x600>
                    proc->types.pointer.drag_dir = LV_DRAG_DIR_HOR;
   19e7d:	41 8a 45 3e          	mov    0x3e(%r13),%al
                    proc->types.pointer.drag_sum.y = 0;
   19e81:	66 41 c7 45 16 00 00 	movw   $0x0,0x16(%r13)
                    act_x += proc->types.pointer.drag_sum.x;
   19e88:	45 03 65 14          	add    0x14(%r13),%r12d
                    proc->types.pointer.drag_dir = LV_DRAG_DIR_HOR;
   19e8c:	83 e0 e3             	and    $0xffffffe3,%eax
   19e8f:	83 c8 04             	or     $0x4,%eax
   19e92:	41 88 45 3e          	mov    %al,0x3e(%r13)
   19e96:	e9 91 00 00 00       	jmpq   19f2c <indev_proc_press+0x600>
            else if(allowed_dirs == LV_DRAG_DIR_VER) {
   19e9b:	41 80 f8 02          	cmp    $0x2,%r8b
   19e9f:	75 25                	jne    19ec6 <indev_proc_press+0x59a>
                if(drag_just_started) {
   19ea1:	40 84 ed             	test   %bpl,%bpl
   19ea4:	0f 84 82 00 00 00    	je     19f2c <indev_proc_press+0x600>
                    proc->types.pointer.drag_dir = LV_DRAG_DIR_VER;
   19eaa:	41 8a 45 3e          	mov    0x3e(%r13),%al
                    proc->types.pointer.drag_sum.x = 0;
   19eae:	66 41 c7 45 14 00 00 	movw   $0x0,0x14(%r13)
                    proc->types.pointer.drag_dir = LV_DRAG_DIR_VER;
   19eb5:	83 e0 e3             	and    $0xffffffe3,%eax
   19eb8:	83 c8 08             	or     $0x8,%eax
   19ebb:	41 88 45 3e          	mov    %al,0x3e(%r13)
                    act_y += proc->types.pointer.drag_sum.y;
   19ebf:	66 41 03 55 16       	add    0x16(%r13),%dx
   19ec4:	eb 66                	jmp    19f2c <indev_proc_press+0x600>
                if(drag_just_started) {
   19ec6:	41 80 f8 04          	cmp    $0x4,%r8b
   19eca:	75 60                	jne    19f2c <indev_proc_press+0x600>
   19ecc:	40 84 ed             	test   %bpl,%bpl
   19ecf:	74 5b                	je     19f2c <indev_proc_press+0x600>
                    if(LV_MATH_ABS(proc->types.pointer.drag_sum.x) > LV_MATH_ABS(proc->types.pointer.drag_sum.y)) {
   19ed1:	45 0f bf 55 14       	movswl 0x14(%r13),%r10d
   19ed6:	66 41 8b 7d 16       	mov    0x16(%r13),%di
   19edb:	44 89 d0             	mov    %r10d,%eax
   19ede:	45 89 d1             	mov    %r10d,%r9d
   19ee1:	c1 f8 1f             	sar    $0x1f,%eax
   19ee4:	41 31 c2             	xor    %eax,%r10d
   19ee7:	41 29 c2             	sub    %eax,%r10d
   19eea:	0f bf c7             	movswl %di,%eax
   19eed:	41 89 c3             	mov    %eax,%r11d
   19ef0:	41 c1 fb 1f          	sar    $0x1f,%r11d
   19ef4:	44 31 d8             	xor    %r11d,%eax
   19ef7:	44 29 d8             	sub    %r11d,%eax
   19efa:	41 39 c2             	cmp    %eax,%r10d
   19efd:	41 8a 45 3e          	mov    0x3e(%r13),%al
   19f01:	7e 16                	jle    19f19 <indev_proc_press+0x5ed>
                        proc->types.pointer.drag_dir = LV_DRAG_DIR_HOR;
   19f03:	83 e0 e3             	and    $0xffffffe3,%eax
                        proc->types.pointer.drag_sum.y = 0;
   19f06:	66 41 c7 45 16 00 00 	movw   $0x0,0x16(%r13)
                        act_x += proc->types.pointer.drag_sum.x;
   19f0d:	45 01 cc             	add    %r9d,%r12d
                        proc->types.pointer.drag_dir = LV_DRAG_DIR_HOR;
   19f10:	83 c8 04             	or     $0x4,%eax
   19f13:	41 88 45 3e          	mov    %al,0x3e(%r13)
   19f17:	eb 13                	jmp    19f2c <indev_proc_press+0x600>
                        proc->types.pointer.drag_dir = LV_DRAG_DIR_VER;
   19f19:	83 e0 e3             	and    $0xffffffe3,%eax
                        proc->types.pointer.drag_sum.x = 0;
   19f1c:	66 41 c7 45 14 00 00 	movw   $0x0,0x14(%r13)
                        act_y += proc->types.pointer.drag_sum.y;
   19f23:	01 fa                	add    %edi,%edx
                        proc->types.pointer.drag_dir = LV_DRAG_DIR_VER;
   19f25:	83 c8 08             	or     $0x8,%eax
   19f28:	41 88 45 3e          	mov    %al,0x3e(%r13)
            if(allowed_dirs == LV_DRAG_DIR_HOR ||
   19f2c:	44 88 c0             	mov    %r8b,%al
   19f2f:	83 e0 fd             	and    $0xfffffffd,%eax
   19f32:	fe c8                	dec    %al
   19f34:	74 2c                	je     19f62 <indev_proc_press+0x636>
               allowed_dirs == LV_DRAG_DIR_BOTH ||
   19f36:	41 80 f8 04          	cmp    $0x4,%r8b
   19f3a:	75 2a                	jne    19f66 <indev_proc_press+0x63a>
                LV_MATH_ABS(proc->types.pointer.drag_sum.x) > LV_MATH_ABS(proc->types.pointer.drag_sum.y))) {
   19f3c:	41 0f bf 45 14       	movswl 0x14(%r13),%eax
   19f41:	89 c7                	mov    %eax,%edi
   19f43:	c1 ff 1f             	sar    $0x1f,%edi
   19f46:	31 f8                	xor    %edi,%eax
   19f48:	29 f8                	sub    %edi,%eax
   19f4a:	89 c7                	mov    %eax,%edi
   19f4c:	41 0f bf 45 16       	movswl 0x16(%r13),%eax
   19f51:	41 89 c1             	mov    %eax,%r9d
   19f54:	41 c1 f9 1f          	sar    $0x1f,%r9d
   19f58:	44 31 c8             	xor    %r9d,%eax
   19f5b:	44 29 c8             	sub    %r9d,%eax
               (allowed_dirs == LV_DRAG_DIR_ONE &&
   19f5e:	39 c7                	cmp    %eax,%edi
   19f60:	7e 04                	jle    19f66 <indev_proc_press+0x63a>
                act_x += proc->types.pointer.vect.x;
   19f62:	45 03 65 10          	add    0x10(%r13),%r12d
            if(allowed_dirs == LV_DRAG_DIR_VER ||
   19f66:	41 8d 40 fe          	lea    -0x2(%r8),%eax
   19f6a:	3c 01                	cmp    $0x1,%al
   19f6c:	76 2c                	jbe    19f9a <indev_proc_press+0x66e>
               allowed_dirs == LV_DRAG_DIR_BOTH ||
   19f6e:	41 80 f8 04          	cmp    $0x4,%r8b
   19f72:	75 2b                	jne    19f9f <indev_proc_press+0x673>
                LV_MATH_ABS(proc->types.pointer.drag_sum.x) < LV_MATH_ABS(proc->types.pointer.drag_sum.y))) {
   19f74:	41 0f bf 45 14       	movswl 0x14(%r13),%eax
   19f79:	89 c7                	mov    %eax,%edi
   19f7b:	c1 ff 1f             	sar    $0x1f,%edi
   19f7e:	31 f8                	xor    %edi,%eax
   19f80:	29 f8                	sub    %edi,%eax
   19f82:	89 c7                	mov    %eax,%edi
   19f84:	41 0f bf 45 16       	movswl 0x16(%r13),%eax
   19f89:	41 89 c0             	mov    %eax,%r8d
   19f8c:	41 c1 f8 1f          	sar    $0x1f,%r8d
   19f90:	44 31 c0             	xor    %r8d,%eax
   19f93:	44 29 c0             	sub    %r8d,%eax
               (allowed_dirs == LV_DRAG_DIR_ONE &&
   19f96:	39 c7                	cmp    %eax,%edi
   19f98:	7d 05                	jge    19f9f <indev_proc_press+0x673>
                act_y += proc->types.pointer.vect.y;
   19f9a:	66 41 03 55 12       	add    0x12(%r13),%dx
                lv_disp_get_inv_buf_size(indev_act->driver.disp); /*Get the number of currently invalidated areas*/
   19f9f:	48 8b 05 1a e0 23 00 	mov    0x23e01a(%rip),%rax        # 257fc0 <indev_act>
   19fa6:	89 54 24 0c          	mov    %edx,0xc(%rsp)
            uint16_t inv_buf_size =
   19faa:	48 8b 78 20          	mov    0x20(%rax),%rdi
   19fae:	e8 54 b1 00 00       	callq  25107 <lv_disp_get_inv_buf_size>
            lv_obj_set_pos(drag_obj, act_x, act_y);
   19fb3:	8b 54 24 0c          	mov    0xc(%rsp),%edx
   19fb7:	41 0f bf f4          	movswl %r12w,%esi
   19fbb:	48 89 df             	mov    %rbx,%rdi
            uint16_t inv_buf_size =
   19fbe:	66 89 44 24 0a       	mov    %ax,0xa(%rsp)
            lv_obj_set_pos(drag_obj, act_x, act_y);
   19fc3:	0f bf d2             	movswl %dx,%edx
   19fc6:	e8 1c 0e 00 00       	callq  1ade7 <lv_obj_set_pos>
            proc->types.pointer.drag_in_prog = 1;
   19fcb:	41 80 4d 3e 02       	orb    $0x2,0x3e(%r13)
            if(drag_obj->coords.x1 == prev_x && drag_obj->coords.y1 == prev_y) {
   19fd0:	66 44 3b 7b 20       	cmp    0x20(%rbx),%r15w
   19fd5:	75 61                	jne    1a038 <indev_proc_press+0x70c>
   19fd7:	66 44 3b 73 22       	cmp    0x22(%rbx),%r14w
   19fdc:	75 5a                	jne    1a038 <indev_proc_press+0x70c>
                lv_coord_t act_par_w = lv_obj_get_width(lv_obj_get_parent(drag_obj));
   19fde:	48 89 df             	mov    %rbx,%rdi
   19fe1:	e8 39 08 00 00       	callq  1a81f <lv_obj_get_parent>
   19fe6:	48 89 c7             	mov    %rax,%rdi
   19fe9:	e8 07 0a 00 00       	callq  1a9f5 <lv_obj_get_width>
                lv_coord_t act_par_h = lv_obj_get_height(lv_obj_get_parent(drag_obj));
   19fee:	48 89 df             	mov    %rbx,%rdi
                lv_coord_t act_par_w = lv_obj_get_width(lv_obj_get_parent(drag_obj));
   19ff1:	41 89 c6             	mov    %eax,%r14d
                lv_coord_t act_par_h = lv_obj_get_height(lv_obj_get_parent(drag_obj));
   19ff4:	e8 26 08 00 00       	callq  1a81f <lv_obj_get_parent>
   19ff9:	48 89 c7             	mov    %rax,%rdi
   19ffc:	e8 ff 09 00 00       	callq  1aa00 <lv_obj_get_height>
                if(act_par_w == prev_par_w && act_par_h == prev_par_h) {
   1a001:	66 44 39 74 24 06    	cmp    %r14w,0x6(%rsp)
   1a007:	75 2f                	jne    1a038 <indev_proc_press+0x70c>
   1a009:	66 39 44 24 08       	cmp    %ax,0x8(%rsp)
   1a00e:	75 28                	jne    1a038 <indev_proc_press+0x70c>
                    uint16_t new_inv_buf_size = lv_disp_get_inv_buf_size(indev_act->driver.disp);
   1a010:	48 8b 05 a9 df 23 00 	mov    0x23dfa9(%rip),%rax        # 257fc0 <indev_act>
   1a017:	48 8b 78 20          	mov    0x20(%rax),%rdi
   1a01b:	e8 e7 b0 00 00       	callq  25107 <lv_disp_get_inv_buf_size>
                    _lv_disp_pop_from_inv_buf(indev_act->driver.disp, new_inv_buf_size - inv_buf_size);
   1a020:	66 2b 44 24 0a       	sub    0xa(%rsp),%ax
   1a025:	0f b7 f0             	movzwl %ax,%esi
   1a028:	48 8b 05 91 df 23 00 	mov    0x23df91(%rip),%rax        # 257fc0 <indev_act>
   1a02f:	48 8b 78 20          	mov    0x20(%rax),%rdi
   1a033:	e8 db b0 00 00       	callq  25113 <_lv_disp_pop_from_inv_buf>
            if(drag_just_started) {
   1a038:	40 84 ed             	test   %bpl,%bpl
   1a03b:	74 35                	je     1a072 <indev_proc_press+0x746>
                drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_BEGIN, indev_act);
   1a03d:	48 8b 15 7c df 23 00 	mov    0x23df7c(%rip),%rdx        # 257fc0 <indev_act>
   1a044:	be 11 00 00 00       	mov    $0x11,%esi
   1a049:	48 89 df             	mov    %rbx,%rdi
   1a04c:	ff 53 30             	callq  *0x30(%rbx)
                if(indev_reset_check(proc)) return;
   1a04f:	4c 89 ef             	mov    %r13,%rdi
   1a052:	e8 4e f3 ff ff       	callq  193a5 <indev_reset_check>
   1a057:	84 c0                	test   %al,%al
   1a059:	75 17                	jne    1a072 <indev_proc_press+0x746>
                lv_event_send(drag_obj, LV_EVENT_DRAG_BEGIN, NULL);
   1a05b:	48 89 df             	mov    %rbx,%rdi
   1a05e:	31 d2                	xor    %edx,%edx
   1a060:	be 08 00 00 00       	mov    $0x8,%esi
   1a065:	e8 46 07 00 00       	callq  1a7b0 <lv_event_send>
                if(indev_reset_check(proc)) return;
   1a06a:	4c 89 ef             	mov    %r13,%rdi
   1a06d:	e8 33 f3 ff ff       	callq  193a5 <indev_reset_check>
    if(proc->types.pointer.gesture_sent) return;
   1a072:	41 f6 45 3e 20       	testb  $0x20,0x3e(%r13)
   1a077:	0f 85 b2 00 00 00    	jne    1a12f <indev_proc_press+0x803>
    lv_obj_t * gesture_obj = proc->types.pointer.act_obj;
   1a07d:	49 8b 5d 20          	mov    0x20(%r13),%rbx
    while(gesture_obj && lv_obj_get_gesture_parent(gesture_obj)) {
   1a081:	48 85 db             	test   %rbx,%rbx
   1a084:	0f 84 a5 00 00 00    	je     1a12f <indev_proc_press+0x803>
   1a08a:	48 89 df             	mov    %rbx,%rdi
   1a08d:	e8 f3 0f 00 00       	callq  1b085 <lv_obj_get_gesture_parent>
   1a092:	84 c0                	test   %al,%al
   1a094:	74 0d                	je     1a0a3 <indev_proc_press+0x777>
        gesture_obj = lv_obj_get_parent(gesture_obj);
   1a096:	48 89 df             	mov    %rbx,%rdi
   1a099:	e8 81 07 00 00       	callq  1a81f <lv_obj_get_parent>
   1a09e:	48 89 c3             	mov    %rax,%rbx
   1a0a1:	eb de                	jmp    1a081 <indev_proc_press+0x755>
    if((LV_MATH_ABS(proc->types.pointer.vect.x) < indev_act->driver.gesture_min_velocity) &&
   1a0a3:	41 0f bf 45 10       	movswl 0x10(%r13),%eax
   1a0a8:	48 8b 15 11 df 23 00 	mov    0x23df11(%rip),%rdx        # 257fc0 <indev_act>
   1a0af:	66 45 8b 45 12       	mov    0x12(%r13),%r8w
   1a0b4:	0f b6 72 32          	movzbl 0x32(%rdx),%esi
   1a0b8:	41 89 c1             	mov    %eax,%r9d
   1a0bb:	89 c7                	mov    %eax,%edi
   1a0bd:	41 c1 f9 1f          	sar    $0x1f,%r9d
   1a0c1:	44 31 c8             	xor    %r9d,%eax
   1a0c4:	44 29 c8             	sub    %r9d,%eax
   1a0c7:	39 f0                	cmp    %esi,%eax
   1a0c9:	7d 1d                	jge    1a0e8 <indev_proc_press+0x7bc>
       (LV_MATH_ABS(proc->types.pointer.vect.y) < indev_act->driver.gesture_min_velocity)) {
   1a0cb:	41 0f bf c0          	movswl %r8w,%eax
   1a0cf:	41 89 c1             	mov    %eax,%r9d
   1a0d2:	41 c1 f9 1f          	sar    $0x1f,%r9d
   1a0d6:	44 31 c8             	xor    %r9d,%eax
   1a0d9:	44 29 c8             	sub    %r9d,%eax
    if((LV_MATH_ABS(proc->types.pointer.vect.x) < indev_act->driver.gesture_min_velocity) &&
   1a0dc:	39 c6                	cmp    %eax,%esi
   1a0de:	7e 08                	jle    1a0e8 <indev_proc_press+0x7bc>
        proc->types.pointer.gesture_sum.x = 0;
   1a0e0:	41 c7 45 3a 00 00 00 	movl   $0x0,0x3a(%r13)
   1a0e7:	00 
    proc->types.pointer.gesture_sum.x += proc->types.pointer.vect.x;
   1a0e8:	66 41 03 7d 3a       	add    0x3a(%r13),%di
    proc->types.pointer.gesture_sum.y += proc->types.pointer.vect.y;
   1a0ed:	45 03 45 3c          	add    0x3c(%r13),%r8d
    if((LV_MATH_ABS(proc->types.pointer.gesture_sum.x) > indev_act->driver.gesture_limit) ||
   1a0f1:	0f bf f7             	movswl %di,%esi
    proc->types.pointer.gesture_sum.x += proc->types.pointer.vect.x;
   1a0f4:	66 41 89 7d 3a       	mov    %di,0x3a(%r13)
    proc->types.pointer.gesture_sum.y += proc->types.pointer.vect.y;
   1a0f9:	66 45 89 45 3c       	mov    %r8w,0x3c(%r13)
    if((LV_MATH_ABS(proc->types.pointer.gesture_sum.x) > indev_act->driver.gesture_limit) ||
   1a0fe:	89 f0                	mov    %esi,%eax
   1a100:	44 0f b6 4a 33       	movzbl 0x33(%rdx),%r9d
   1a105:	c1 f8 1f             	sar    $0x1f,%eax
   1a108:	31 c6                	xor    %eax,%esi
   1a10a:	29 c6                	sub    %eax,%esi
   1a10c:	41 0f bf c0          	movswl %r8w,%eax
   1a110:	41 89 c2             	mov    %eax,%r10d
   1a113:	41 c1 fa 1f          	sar    $0x1f,%r10d
   1a117:	44 31 d0             	xor    %r10d,%eax
   1a11a:	44 29 d0             	sub    %r10d,%eax
   1a11d:	44 39 ce             	cmp    %r9d,%esi
   1a120:	0f 8f 14 01 00 00    	jg     1a23a <indev_proc_press+0x90e>
   1a126:	41 39 c1             	cmp    %eax,%r9d
   1a129:	0f 8c 0b 01 00 00    	jl     1a23a <indev_proc_press+0x90e>
        if(indev_reset_check(proc)) return;
   1a12f:	4c 89 ef             	mov    %r13,%rdi
   1a132:	e8 6e f2 ff ff       	callq  193a5 <indev_reset_check>
   1a137:	84 c0                	test   %al,%al
   1a139:	0f 85 53 01 00 00    	jne    1a292 <indev_proc_press+0x966>
        if(proc->types.pointer.drag_in_prog == 0 && proc->long_pr_sent == 0) {
   1a13f:	41 f6 45 3e 02       	testb  $0x2,0x3e(%r13)
   1a144:	0f 85 48 01 00 00    	jne    1a292 <indev_proc_press+0x966>
   1a14a:	41 f6 45 48 01       	testb  $0x1,0x48(%r13)
   1a14f:	75 76                	jne    1a1c7 <indev_proc_press+0x89b>
            if(lv_tick_elaps(proc->pr_timestamp) > indev_act->driver.long_press_time) {
   1a151:	41 8b 7d 40          	mov    0x40(%r13),%edi
   1a155:	e8 45 b3 00 00       	callq  2549f <lv_tick_elaps>
   1a15a:	48 8b 15 5f de 23 00 	mov    0x23de5f(%rip),%rdx        # 257fc0 <indev_act>
   1a161:	0f b7 72 34          	movzwl 0x34(%rdx),%esi
   1a165:	39 f0                	cmp    %esi,%eax
   1a167:	76 53                	jbe    1a1bc <indev_proc_press+0x890>
                indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_LONG_PRESS, indev_act);
   1a169:	48 8b 05 48 de 23 00 	mov    0x23de48(%rip),%rax        # 257fb8 <indev_obj_act>
   1a170:	be 0f 00 00 00       	mov    $0xf,%esi
   1a175:	48 89 c7             	mov    %rax,%rdi
   1a178:	ff 50 30             	callq  *0x30(%rax)
                if(indev_reset_check(proc)) return;
   1a17b:	4c 89 ef             	mov    %r13,%rdi
   1a17e:	e8 22 f2 ff ff       	callq  193a5 <indev_reset_check>
   1a183:	84 c0                	test   %al,%al
   1a185:	0f 85 07 01 00 00    	jne    1a292 <indev_proc_press+0x966>
                lv_event_send(indev_obj_act, LV_EVENT_LONG_PRESSED, NULL);
   1a18b:	48 8b 3d 26 de 23 00 	mov    0x23de26(%rip),%rdi        # 257fb8 <indev_obj_act>
   1a192:	31 d2                	xor    %edx,%edx
   1a194:	be 04 00 00 00       	mov    $0x4,%esi
   1a199:	e8 12 06 00 00       	callq  1a7b0 <lv_event_send>
                if(indev_reset_check(proc)) return;
   1a19e:	4c 89 ef             	mov    %r13,%rdi
   1a1a1:	e8 ff f1 ff ff       	callq  193a5 <indev_reset_check>
   1a1a6:	84 c0                	test   %al,%al
   1a1a8:	0f 85 e4 00 00 00    	jne    1a292 <indev_proc_press+0x966>
                proc->long_pr_sent = 1;
   1a1ae:	41 80 4d 48 01       	orb    $0x1,0x48(%r13)
                proc->longpr_rep_timestamp = lv_tick_get();
   1a1b3:	e8 d6 b2 00 00       	callq  2548e <lv_tick_get>
   1a1b8:	41 89 45 44          	mov    %eax,0x44(%r13)
        if(proc->types.pointer.drag_in_prog == 0 && proc->long_pr_sent == 1) {
   1a1bc:	41 f6 45 3e 02       	testb  $0x2,0x3e(%r13)
   1a1c1:	0f 85 cb 00 00 00    	jne    1a292 <indev_proc_press+0x966>
   1a1c7:	41 f6 45 48 01       	testb  $0x1,0x48(%r13)
   1a1cc:	0f 84 c0 00 00 00    	je     1a292 <indev_proc_press+0x966>
            if(lv_tick_elaps(proc->longpr_rep_timestamp) > indev_act->driver.long_press_rep_time) {
   1a1d2:	41 8b 7d 44          	mov    0x44(%r13),%edi
   1a1d6:	e8 c4 b2 00 00       	callq  2549f <lv_tick_elaps>
   1a1db:	48 8b 15 de dd 23 00 	mov    0x23ddde(%rip),%rdx        # 257fc0 <indev_act>
   1a1e2:	0f b7 72 36          	movzwl 0x36(%rdx),%esi
   1a1e6:	39 f0                	cmp    %esi,%eax
   1a1e8:	0f 86 a4 00 00 00    	jbe    1a292 <indev_proc_press+0x966>
                indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_LONG_PRESS_REP, indev_act);
   1a1ee:	48 8b 05 c3 dd 23 00 	mov    0x23ddc3(%rip),%rax        # 257fb8 <indev_obj_act>
   1a1f5:	be 10 00 00 00       	mov    $0x10,%esi
   1a1fa:	48 89 c7             	mov    %rax,%rdi
   1a1fd:	ff 50 30             	callq  *0x30(%rax)
                if(indev_reset_check(proc)) return;
   1a200:	4c 89 ef             	mov    %r13,%rdi
   1a203:	e8 9d f1 ff ff       	callq  193a5 <indev_reset_check>
   1a208:	84 c0                	test   %al,%al
   1a20a:	0f 85 82 00 00 00    	jne    1a292 <indev_proc_press+0x966>
                lv_event_send(indev_obj_act, LV_EVENT_LONG_PRESSED_REPEAT, NULL);
   1a210:	48 8b 3d a1 dd 23 00 	mov    0x23dda1(%rip),%rdi        # 257fb8 <indev_obj_act>
   1a217:	31 d2                	xor    %edx,%edx
   1a219:	be 05 00 00 00       	mov    $0x5,%esi
   1a21e:	e8 8d 05 00 00       	callq  1a7b0 <lv_event_send>
                if(indev_reset_check(proc)) return;
   1a223:	4c 89 ef             	mov    %r13,%rdi
   1a226:	e8 7a f1 ff ff       	callq  193a5 <indev_reset_check>
   1a22b:	84 c0                	test   %al,%al
   1a22d:	75 63                	jne    1a292 <indev_proc_press+0x966>
                proc->longpr_rep_timestamp = lv_tick_get();
   1a22f:	e8 5a b2 00 00       	callq  2548e <lv_tick_get>
   1a234:	41 89 45 44          	mov    %eax,0x44(%r13)
   1a238:	eb 58                	jmp    1a292 <indev_proc_press+0x966>
        proc->types.pointer.gesture_sent = 1;
   1a23a:	41 80 4d 3e 20       	orb    $0x20,0x3e(%r13)
        if(LV_MATH_ABS(proc->types.pointer.gesture_sum.x) > LV_MATH_ABS(proc->types.pointer.gesture_sum.y)) {
   1a23f:	39 c6                	cmp    %eax,%esi
   1a241:	7e 0f                	jle    1a252 <indev_proc_press+0x926>
                proc->types.pointer.gesture_dir = LV_GESTURE_DIR_RIGHT;
   1a243:	66 85 ff             	test   %di,%di
   1a246:	0f 9f c0             	setg   %al
   1a249:	83 c0 02             	add    $0x2,%eax
   1a24c:	41 88 45 38          	mov    %al,0x38(%r13)
   1a250:	eb 09                	jmp    1a25b <indev_proc_press+0x92f>
                proc->types.pointer.gesture_dir = LV_GESTURE_DIR_BOTTOM;
   1a252:	66 45 85 c0          	test   %r8w,%r8w
   1a256:	41 0f 9f 45 38       	setg   0x38(%r13)
        gesture_obj->signal_cb(gesture_obj, LV_SIGNAL_GESTURE, indev_act);
   1a25b:	be 14 00 00 00       	mov    $0x14,%esi
   1a260:	48 89 df             	mov    %rbx,%rdi
   1a263:	ff 53 30             	callq  *0x30(%rbx)
        if(indev_reset_check(proc)) return;
   1a266:	4c 89 ef             	mov    %r13,%rdi
   1a269:	e8 37 f1 ff ff       	callq  193a5 <indev_reset_check>
   1a26e:	84 c0                	test   %al,%al
   1a270:	0f 85 b9 fe ff ff    	jne    1a12f <indev_proc_press+0x803>
        lv_event_send(gesture_obj, LV_EVENT_GESTURE, NULL);
   1a276:	48 89 df             	mov    %rbx,%rdi
   1a279:	31 d2                	xor    %edx,%edx
   1a27b:	be 0b 00 00 00       	mov    $0xb,%esi
   1a280:	e8 2b 05 00 00       	callq  1a7b0 <lv_event_send>
        if(indev_reset_check(proc)) return;
   1a285:	4c 89 ef             	mov    %r13,%rdi
   1a288:	e8 18 f1 ff ff       	callq  193a5 <indev_reset_check>
   1a28d:	e9 9d fe ff ff       	jmpq   1a12f <indev_proc_press+0x803>
}
   1a292:	48 83 c4 18          	add    $0x18,%rsp
   1a296:	5b                   	pop    %rbx
   1a297:	5d                   	pop    %rbp
   1a298:	41 5c                	pop    %r12
   1a29a:	41 5d                	pop    %r13
   1a29c:	41 5e                	pop    %r14
   1a29e:	41 5f                	pop    %r15
   1a2a0:	c3                   	retq   
   1a2a1:	c3                   	retq   

000000000001a2a2 <_lv_indev_read_task>:
{
   1a2a2:	41 54                	push   %r12
   1a2a4:	55                   	push   %rbp
   1a2a5:	53                   	push   %rbx
   1a2a6:	48 83 ec 20          	sub    $0x20,%rsp
    indev_act = task->user_data;
   1a2aa:	48 8b 4f 10          	mov    0x10(%rdi),%rcx
{
   1a2ae:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1a2b5:	00 00 
   1a2b7:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1a2bc:	31 c0                	xor    %eax,%eax
    if(indev_act->driver.disp == NULL) return; /*Not assigned to any displays*/
   1a2be:	48 83 79 20 00       	cmpq   $0x0,0x20(%rcx)
    indev_act = task->user_data;
   1a2c3:	48 89 0d f6 dc 23 00 	mov    %rcx,0x23dcf6(%rip)        # 257fc0 <indev_act>
    if(indev_act->driver.disp == NULL) return; /*Not assigned to any displays*/
   1a2ca:	0f 84 5f 01 00 00    	je     1a42f <_lv_indev_read_task+0x18d>
    indev_proc_reset_query_handler(indev_act);
   1a2d0:	48 89 cf             	mov    %rcx,%rdi
   1a2d3:	e8 e5 f0 ff ff       	callq  193bd <indev_proc_reset_query_handler>
    if(indev_act->proc.disabled) return;
   1a2d8:	f6 81 80 00 00 00 04 	testb  $0x4,0x80(%rcx)
   1a2df:	0f 85 4a 01 00 00    	jne    1a42f <_lv_indev_read_task+0x18d>
        more_to_read = _lv_indev_read(indev_act, &data);
   1a2e5:	4c 8d 64 24 08       	lea    0x8(%rsp),%r12
   1a2ea:	48 8b 3d cf dc 23 00 	mov    0x23dccf(%rip),%rdi        # 257fc0 <indev_act>
   1a2f1:	4c 89 e6             	mov    %r12,%rsi
   1a2f4:	e8 15 b1 00 00       	callq  2540e <_lv_indev_read>
        indev_proc_reset_query_handler(indev_act);
   1a2f9:	48 8b 0d c0 dc 23 00 	mov    0x23dcc0(%rip),%rcx        # 257fc0 <indev_act>
        more_to_read = _lv_indev_read(indev_act, &data);
   1a300:	40 88 c5             	mov    %al,%bpl
        indev_proc_reset_query_handler(indev_act);
   1a303:	48 89 cf             	mov    %rcx,%rdi
   1a306:	e8 b2 f0 ff ff       	callq  193bd <indev_proc_reset_query_handler>
        indev_act->proc.state = data.state;
   1a30b:	8a 44 24 16          	mov    0x16(%rsp),%al
        indev_obj_act = NULL;
   1a30f:	48 c7 05 9e dc 23 00 	movq   $0x0,0x23dc9e(%rip)        # 257fb8 <indev_obj_act>
   1a316:	00 00 00 00 
        indev_act->proc.state = data.state;
   1a31a:	88 41 38             	mov    %al,0x38(%rcx)
        if(indev_act->proc.state == LV_INDEV_STATE_PR) {
   1a31d:	fe c8                	dec    %al
   1a31f:	74 0d                	je     1a32e <_lv_indev_read_task+0x8c>
        else if(indev_act->driver.type == LV_INDEV_TYPE_ENCODER && data.enc_diff) {
   1a321:	80 39 04             	cmpb   $0x4,(%rcx)
   1a324:	75 17                	jne    1a33d <_lv_indev_read_task+0x9b>
   1a326:	66 83 7c 24 14 00    	cmpw   $0x0,0x14(%rsp)
   1a32c:	74 0f                	je     1a33d <_lv_indev_read_task+0x9b>
            indev_act->driver.disp->last_activity_time = lv_tick_get();
   1a32e:	48 8b 59 20          	mov    0x20(%rcx),%rbx
   1a332:	e8 57 b1 00 00       	callq  2548e <lv_tick_get>
   1a337:	89 83 d4 01 00 00    	mov    %eax,0x1d4(%rbx)
        if(indev_act->driver.type == LV_INDEV_TYPE_POINTER) {
   1a33d:	48 8b 1d 7c dc 23 00 	mov    0x23dc7c(%rip),%rbx        # 257fc0 <indev_act>
   1a344:	8a 03                	mov    (%rbx),%al
   1a346:	3c 01                	cmp    $0x1,%al
   1a348:	75 3f                	jne    1a389 <_lv_indev_read_task+0xe7>
    if(i->cursor != NULL &&
   1a34a:	48 8b bb 88 00 00 00 	mov    0x88(%rbx),%rdi
   1a351:	48 85 ff             	test   %rdi,%rdi
   1a354:	74 18                	je     1a36e <_lv_indev_read_task+0xcc>
   1a356:	8b 44 24 08          	mov    0x8(%rsp),%eax
   1a35a:	39 43 44             	cmp    %eax,0x44(%rbx)
   1a35d:	74 0f                	je     1a36e <_lv_indev_read_task+0xcc>
        lv_obj_set_pos(i->cursor, data->point.x, data->point.y);
   1a35f:	0f bf 54 24 0a       	movswl 0xa(%rsp),%edx
   1a364:	0f bf 74 24 08       	movswl 0x8(%rsp),%esi
   1a369:	e8 79 0a 00 00       	callq  1ade7 <lv_obj_set_pos>
    i->proc.types.pointer.act_point.x = data->point.x;
   1a36e:	8b 44 24 08          	mov    0x8(%rsp),%eax
   1a372:	48 8d 7b 38          	lea    0x38(%rbx),%rdi
    if(i->proc.state == LV_INDEV_STATE_PR) {
   1a376:	80 7b 38 01          	cmpb   $0x1,0x38(%rbx)
    i->proc.types.pointer.act_point.x = data->point.x;
   1a37a:	66 89 43 40          	mov    %ax,0x40(%rbx)
    i->proc.types.pointer.act_point.y = data->point.y;
   1a37e:	66 8b 44 24 0a       	mov    0xa(%rsp),%ax
   1a383:	66 89 43 42          	mov    %ax,0x42(%rbx)
   1a387:	eb 5e                	jmp    1a3e7 <_lv_indev_read_task+0x145>
        else if(indev_act->driver.type == LV_INDEV_TYPE_BUTTON) {
   1a389:	3c 03                	cmp    $0x3,%al
   1a38b:	75 77                	jne    1a404 <_lv_indev_read_task+0x162>
    if(i->btn_points == NULL) {
   1a38d:	48 8b 83 98 00 00 00 	mov    0x98(%rbx),%rax
   1a394:	48 85 c0             	test   %rax,%rax
   1a397:	75 26                	jne    1a3bf <_lv_indev_read_task+0x11d>
        LV_LOG_WARN("indev_button_proc: btn_points was  NULL");
   1a399:	4c 8d 05 e4 8f 01 00 	lea    0x18fe4(%rip),%r8        # 33384 <__func__.5785+0x271c>
   1a3a0:	48 8d 0d 19 65 01 00 	lea    0x16519(%rip),%rcx        # 308c0 <__func__.5843>
   1a3a7:	48 8d 35 9f 8f 01 00 	lea    0x18f9f(%rip),%rsi        # 3334d <__func__.5785+0x26e5>
   1a3ae:	ba 26 03 00 00       	mov    $0x326,%edx
   1a3b3:	bf 02 00 00 00       	mov    $0x2,%edi
   1a3b8:	e8 99 bb 00 00       	callq  25f56 <_lv_log_add>
   1a3bd:	eb 45                	jmp    1a404 <_lv_indev_read_task+0x162>
    i->proc.types.pointer.act_point.x = i->btn_points[data->btn_id].x;
   1a3bf:	8b 54 24 10          	mov    0x10(%rsp),%edx
   1a3c3:	48 8d 7b 38          	lea    0x38(%rbx),%rdi
   1a3c7:	48 8d 04 90          	lea    (%rax,%rdx,4),%rax
   1a3cb:	66 8b 10             	mov    (%rax),%dx
    i->proc.types.pointer.act_point.y = i->btn_points[data->btn_id].y;
   1a3ce:	66 8b 40 02          	mov    0x2(%rax),%ax
    i->proc.types.pointer.act_point.x = i->btn_points[data->btn_id].x;
   1a3d2:	66 89 53 40          	mov    %dx,0x40(%rbx)
    i->proc.types.pointer.act_point.y = i->btn_points[data->btn_id].y;
   1a3d6:	66 89 43 42          	mov    %ax,0x42(%rbx)
    if(i->proc.types.pointer.last_point.x == i->proc.types.pointer.act_point.x &&
   1a3da:	8b 43 40             	mov    0x40(%rbx),%eax
   1a3dd:	39 43 44             	cmp    %eax,0x44(%rbx)
   1a3e0:	75 0e                	jne    1a3f0 <_lv_indev_read_task+0x14e>
       i->proc.types.pointer.last_point.y == i->proc.types.pointer.act_point.y && data->state == LV_INDEV_STATE_PR) {
   1a3e2:	80 7c 24 16 01       	cmpb   $0x1,0x16(%rsp)
   1a3e7:	75 07                	jne    1a3f0 <_lv_indev_read_task+0x14e>
        indev_proc_press(&i->proc);
   1a3e9:	e8 3e f5 ff ff       	callq  1992c <indev_proc_press>
   1a3ee:	eb 05                	jmp    1a3f5 <_lv_indev_read_task+0x153>
        indev_proc_release(&i->proc);
   1a3f0:	e8 2f f2 ff ff       	callq  19624 <indev_proc_release>
    i->proc.types.pointer.last_point.x = i->proc.types.pointer.act_point.x;
   1a3f5:	8b 43 40             	mov    0x40(%rbx),%eax
   1a3f8:	66 89 43 44          	mov    %ax,0x44(%rbx)
    i->proc.types.pointer.last_point.y = i->proc.types.pointer.act_point.y;
   1a3fc:	66 8b 43 42          	mov    0x42(%rbx),%ax
   1a400:	66 89 43 46          	mov    %ax,0x46(%rbx)
        indev_proc_reset_query_handler(indev_act);
   1a404:	48 8b 3d b5 db 23 00 	mov    0x23dbb5(%rip),%rdi        # 257fc0 <indev_act>
   1a40b:	e8 ad ef ff ff       	callq  193bd <indev_proc_reset_query_handler>
    } while(more_to_read);
   1a410:	40 84 ed             	test   %bpl,%bpl
   1a413:	0f 85 d1 fe ff ff    	jne    1a2ea <_lv_indev_read_task+0x48>
    indev_act     = NULL;
   1a419:	48 c7 05 9c db 23 00 	movq   $0x0,0x23db9c(%rip)        # 257fc0 <indev_act>
   1a420:	00 00 00 00 
    indev_obj_act = NULL;
   1a424:	48 c7 05 89 db 23 00 	movq   $0x0,0x23db89(%rip)        # 257fb8 <indev_obj_act>
   1a42b:	00 00 00 00 
}
   1a42f:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
   1a434:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1a43b:	00 00 
   1a43d:	74 05                	je     1a444 <_lv_indev_read_task+0x1a2>
   1a43f:	e8 fc a1 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1a444:	48 83 c4 20          	add    $0x20,%rsp
   1a448:	5b                   	pop    %rbx
   1a449:	5d                   	pop    %rbp
   1a44a:	41 5c                	pop    %r12
   1a44c:	c3                   	retq   

000000000001a44d <style_prop_is_cacheble>:
}

static bool style_prop_is_cacheble(lv_style_property_t prop)
{

    switch(prop) {
   1a44d:	66 83 ff 50          	cmp    $0x50,%di
   1a451:	0f 84 c1 00 00 00    	je     1a518 <style_prop_is_cacheble+0xcb>
   1a457:	77 5a                	ja     1a4b3 <style_prop_is_cacheble+0x66>
   1a459:	66 83 ff 18          	cmp    $0x18,%di
   1a45d:	77 30                	ja     1a48f <style_prop_is_cacheble+0x42>
   1a45f:	66 83 ff 15          	cmp    $0x15,%di
   1a463:	0f 83 af 00 00 00    	jae    1a518 <style_prop_is_cacheble+0xcb>
   1a469:	66 83 ff 07          	cmp    $0x7,%di
   1a46d:	77 0e                	ja     1a47d <style_prop_is_cacheble+0x30>
   1a46f:	66 83 ff 04          	cmp    $0x4,%di
   1a473:	0f 83 9f 00 00 00    	jae    1a518 <style_prop_is_cacheble+0xcb>
   1a479:	ff cf                	dec    %edi
   1a47b:	eb 7d                	jmp    1a4fa <style_prop_is_cacheble+0xad>
   1a47d:	83 ef 10             	sub    $0x10,%edi
   1a480:	66 83 ff 03          	cmp    $0x3,%di
   1a484:	0f 87 8b 00 00 00    	ja     1a515 <style_prop_is_cacheble+0xc8>
   1a48a:	e9 89 00 00 00       	jmpq   1a518 <style_prop_is_cacheble+0xcb>
   1a48f:	66 83 ff 33          	cmp    $0x33,%di
   1a493:	77 12                	ja     1a4a7 <style_prop_is_cacheble+0x5a>
   1a495:	66 83 ff 30          	cmp    $0x30,%di
   1a499:	73 7d                	jae    1a518 <style_prop_is_cacheble+0xcb>
   1a49b:	66 83 ff 20          	cmp    $0x20,%di
   1a49f:	74 77                	je     1a518 <style_prop_is_cacheble+0xcb>
   1a4a1:	66 83 ff 2c          	cmp    $0x2c,%di
   1a4a5:	eb 6c                	jmp    1a513 <style_prop_is_cacheble+0xc6>
   1a4a7:	66 83 ff 40          	cmp    $0x40,%di
   1a4ab:	74 6b                	je     1a518 <style_prop_is_cacheble+0xcb>
   1a4ad:	66 83 ff 42          	cmp    $0x42,%di
   1a4b1:	eb 60                	jmp    1a513 <style_prop_is_cacheble+0xc6>
   1a4b3:	66 81 ff ff 00       	cmp    $0xff,%di
   1a4b8:	74 5e                	je     1a518 <style_prop_is_cacheble+0xcb>
   1a4ba:	77 27                	ja     1a4e3 <style_prop_is_cacheble+0x96>
   1a4bc:	66 83 ff 6e          	cmp    $0x6e,%di
   1a4c0:	74 56                	je     1a518 <style_prop_is_cacheble+0xcb>
   1a4c2:	77 0c                	ja     1a4d0 <style_prop_is_cacheble+0x83>
   1a4c4:	66 83 ff 54          	cmp    $0x54,%di
   1a4c8:	74 4e                	je     1a518 <style_prop_is_cacheble+0xcb>
   1a4ca:	66 83 ff 60          	cmp    $0x60,%di
   1a4ce:	eb 43                	jmp    1a513 <style_prop_is_cacheble+0xc6>
   1a4d0:	66 83 ff 7f          	cmp    $0x7f,%di
   1a4d4:	74 42                	je     1a518 <style_prop_is_cacheble+0xcb>
   1a4d6:	66 81 ff 91 00       	cmp    $0x91,%di
   1a4db:	74 3b                	je     1a518 <style_prop_is_cacheble+0xcb>
   1a4dd:	66 83 ff 72          	cmp    $0x72,%di
   1a4e1:	eb 30                	jmp    1a513 <style_prop_is_cacheble+0xc6>
   1a4e3:	66 81 ff 83 80       	cmp    $0x8083,%di
   1a4e8:	74 2e                	je     1a518 <style_prop_is_cacheble+0xcb>
   1a4ea:	77 14                	ja     1a500 <style_prop_is_cacheble+0xb3>
   1a4ec:	66 81 ff 0c 80       	cmp    $0x800c,%di
   1a4f1:	74 25                	je     1a518 <style_prop_is_cacheble+0xcb>
   1a4f3:	72 20                	jb     1a515 <style_prop_is_cacheble+0xc8>
   1a4f5:	66 81 c7 80 7f       	add    $0x7f80,%di
   1a4fa:	66 83 ff 01          	cmp    $0x1,%di
   1a4fe:	eb 84                	jmp    1a484 <style_prop_is_cacheble+0x37>
   1a500:	66 81 ff a0 80       	cmp    $0x80a0,%di
   1a505:	74 11                	je     1a518 <style_prop_is_cacheble+0xcb>
   1a507:	66 81 ff ad 80       	cmp    $0x80ad,%di
   1a50c:	74 0a                	je     1a518 <style_prop_is_cacheble+0xcb>
   1a50e:	66 81 ff 8e 80       	cmp    $0x808e,%di
   1a513:	74 03                	je     1a518 <style_prop_is_cacheble+0xcb>
        case LV_STYLE_TEXT_BLEND_MODE:
        case LV_STYLE_VALUE_BLEND_MODE:
            return true;
            break;
        default:
            return false;
   1a515:	31 c0                	xor    %eax,%eax
   1a517:	c3                   	retq   
            return true;
   1a518:	b0 01                	mov    $0x1,%al
    }
}
   1a51a:	c3                   	retq   

000000000001a51b <_lv_memset_00>:
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
   1a51b:	89 f1                	mov    %esi,%ecx
   1a51d:	31 c0                	xor    %eax,%eax
   1a51f:	f3 aa                	rep stos %al,%es:(%rdi)
 * @param len number of byte to set
 */
static inline void _lv_memset_00(void * dst, size_t len)
{
    memset(dst, 0x00, len);
}
   1a521:	c3                   	retq   

000000000001a522 <refresh_children_position>:
{
   1a522:	41 55                	push   %r13
   1a524:	41 54                	push   %r12
    _LV_LL_READ(obj->child_ll, i) {
   1a526:	4c 8d 67 08          	lea    0x8(%rdi),%r12
{
   1a52a:	55                   	push   %rbp
   1a52b:	53                   	push   %rbx
   1a52c:	44 0f bf ea          	movswl %dx,%r13d
    _LV_LL_READ(obj->child_ll, i) {
   1a530:	4c 89 e7             	mov    %r12,%rdi
{
   1a533:	89 f3                	mov    %esi,%ebx
   1a535:	44 89 ed             	mov    %r13d,%ebp
   1a538:	48 83 ec 18          	sub    $0x18,%rsp
    _LV_LL_READ(obj->child_ll, i) {
   1a53c:	e8 2a b7 00 00       	callq  25c6b <_lv_ll_get_head>
   1a541:	48 85 c0             	test   %rax,%rax
   1a544:	74 35                	je     1a57b <refresh_children_position+0x59>
        i->coords.x1 += x_diff;
   1a546:	66 01 58 20          	add    %bx,0x20(%rax)
        i->coords.y1 += y_diff;
   1a54a:	66 01 68 22          	add    %bp,0x22(%rax)
        refresh_children_position(i, x_diff, y_diff);
   1a54e:	0f bf f3             	movswl %bx,%esi
   1a551:	48 89 c7             	mov    %rax,%rdi
   1a554:	44 89 ea             	mov    %r13d,%edx
   1a557:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
        i->coords.x2 += x_diff;
   1a55c:	66 01 58 24          	add    %bx,0x24(%rax)
        i->coords.y2 += y_diff;
   1a560:	66 01 68 26          	add    %bp,0x26(%rax)
        refresh_children_position(i, x_diff, y_diff);
   1a564:	e8 b9 ff ff ff       	callq  1a522 <refresh_children_position>
    _LV_LL_READ(obj->child_ll, i) {
   1a569:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   1a56e:	4c 89 e7             	mov    %r12,%rdi
   1a571:	48 89 c6             	mov    %rax,%rsi
   1a574:	e8 0a b7 00 00       	callq  25c83 <_lv_ll_get_next>
   1a579:	eb c6                	jmp    1a541 <refresh_children_position+0x1f>
}
   1a57b:	48 83 c4 18          	add    $0x18,%rsp
   1a57f:	5b                   	pop    %rbx
   1a580:	5d                   	pop    %rbp
   1a581:	41 5c                	pop    %r12
   1a583:	41 5d                	pop    %r13
   1a585:	c3                   	retq   

000000000001a586 <lv_area_copy>:
 * Copy an area
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
   1a586:	48 8b 06             	mov    (%rsi),%rax
   1a589:	48 89 07             	mov    %rax,(%rdi)
    _lv_memcpy_small(dest, src, sizeof(lv_area_t));
}
   1a58c:	c3                   	retq   

000000000001a58d <lv_init>:
    if(lv_initialized) {
   1a58d:	80 3d 57 4b 24 00 00 	cmpb   $0x0,0x244b57(%rip)        # 25f0eb <lv_initialized>
   1a594:	74 26                	je     1a5bc <lv_init+0x2f>
        LV_LOG_WARN("lv_init: already inited");
   1a596:	4c 8d 05 0f 8e 01 00 	lea    0x18e0f(%rip),%r8        # 333ac <__func__.5785+0x2744>
   1a59d:	48 8d 0d 3c 66 01 00 	lea    0x1663c(%rip),%rcx        # 30be0 <__func__.5983>
   1a5a4:	ba aa 00 00 00       	mov    $0xaa,%edx
   1a5a9:	48 8d 35 14 8e 01 00 	lea    0x18e14(%rip),%rsi        # 333c4 <__func__.5785+0x275c>
   1a5b0:	bf 02 00 00 00       	mov    $0x2,%edi
   1a5b5:	31 c0                	xor    %eax,%eax
   1a5b7:	e9 af 00 00 00       	jmpq   1a66b <lv_init+0xde>
{
   1a5bc:	48 83 ec 08          	sub    $0x8,%rsp
    _lv_mem_init();
   1a5c0:	e8 cb ba 00 00       	callq  26090 <_lv_mem_init>
    _lv_task_core_init();
   1a5c5:	e8 bc c1 00 00       	callq  26786 <_lv_task_core_init>
    _lv_ll_init(&LV_GC_ROOT(_lv_obj_style_trans_ll), sizeof(lv_style_trans_t));
   1a5ca:	48 8d 3d bf d7 23 00 	lea    0x23d7bf(%rip),%rdi        # 257d90 <_lv_obj_style_trans_ll>
   1a5d1:	be 20 00 00 00       	mov    $0x20,%esi
   1a5d6:	e8 d3 b5 00 00       	callq  25bae <_lv_ll_init>
    _lv_ll_init(&LV_GC_ROOT(_lv_disp_ll), sizeof(lv_disp_t));
   1a5db:	48 8d 3d 0e d8 23 00 	lea    0x23d80e(%rip),%rdi        # 257df0 <_lv_disp_ll>
   1a5e2:	be d8 01 00 00       	mov    $0x1d8,%esi
   1a5e7:	e8 c2 b5 00 00       	callq  25bae <_lv_ll_init>
    _lv_ll_init(&LV_GC_ROOT(_lv_indev_ll), sizeof(lv_indev_t));
   1a5ec:	48 8d 3d dd d7 23 00 	lea    0x23d7dd(%rip),%rdi        # 257dd0 <_lv_indev_ll>
   1a5f3:	be a0 00 00 00       	mov    $0xa0,%esi
   1a5f8:	e8 b1 b5 00 00       	callq  25bae <_lv_ll_init>
    lv_theme_t * th = LV_THEME_DEFAULT_INIT(LV_THEME_DEFAULT_COLOR_PRIMARY, LV_THEME_DEFAULT_COLOR_SECONDARY,
   1a5fd:	48 8d 0d dc c2 21 00 	lea    0x21c2dc(%rip),%rcx        # 2368e0 <lv_font_montserrat_14>
   1a604:	48 83 ec 08          	sub    $0x8,%rsp
   1a608:	be 00 00 00 ff       	mov    $0xff000000,%esi
   1a60d:	31 d2                	xor    %edx,%edx
   1a60f:	83 cf ff             	or     $0xffffffff,%edi
   1a612:	51                   	push   %rcx
   1a613:	49 89 c9             	mov    %rcx,%r9
   1a616:	49 89 c8             	mov    %rcx,%r8
   1a619:	e8 33 d0 00 00       	callq  27651 <lv_theme_mono_init>
   1a61e:	5a                   	pop    %rdx
   1a61f:	59                   	pop    %rcx
    lv_theme_set_act(th);
   1a620:	48 89 c7             	mov    %rax,%rdi
   1a623:	e8 39 cf 00 00       	callq  27561 <lv_theme_set_act>
    _lv_refr_init();
   1a628:	e8 c1 2f 00 00       	callq  1d5ee <_lv_refr_init>
    _lv_indev_init();
   1a62d:	e8 52 f2 ff ff       	callq  19884 <_lv_indev_init>
    _lv_img_decoder_init();
   1a632:	e8 1a a9 00 00       	callq  24f51 <_lv_img_decoder_init>
    lv_img_cache_set_size(LV_IMG_CACHE_DEF_SIZE);
   1a637:	bf 01 00 00 00       	mov    $0x1,%edi
   1a63c:	e8 8a 9f 00 00       	callq  245cb <lv_img_cache_set_size>
    lv_initialized = true;
   1a641:	c6 05 a3 4a 24 00 01 	movb   $0x1,0x244aa3(%rip)        # 25f0eb <lv_initialized>
    LV_LOG_INFO("lv_init ready");
   1a648:	4c 8d 05 aa 8d 01 00 	lea    0x18daa(%rip),%r8        # 333f9 <__func__.5785+0x2791>
   1a64f:	48 8d 0d 8a 65 01 00 	lea    0x1658a(%rip),%rcx        # 30be0 <__func__.5983>
}
   1a656:	41 59                	pop    %r9
    LV_LOG_INFO("lv_init ready");
   1a658:	48 8d 35 65 8d 01 00 	lea    0x18d65(%rip),%rsi        # 333c4 <__func__.5785+0x275c>
   1a65f:	ba e1 00 00 00       	mov    $0xe1,%edx
   1a664:	bf 01 00 00 00       	mov    $0x1,%edi
   1a669:	31 c0                	xor    %eax,%eax
   1a66b:	e9 e6 b8 00 00       	jmpq   25f56 <_lv_log_add>

000000000001a670 <lv_obj_realign>:
    LV_LOG_WARN("lv_obj_realign: no effect because LV_USE_OBJ_REALIGN = 0");
   1a670:	4c 8d 05 90 8d 01 00 	lea    0x18d90(%rip),%r8        # 33407 <__func__.5785+0x279f>
   1a677:	48 8d 0d 42 65 01 00 	lea    0x16542(%rip),%rcx        # 30bc0 <__func__.6158>
   1a67e:	48 8d 35 3f 8d 01 00 	lea    0x18d3f(%rip),%rsi        # 333c4 <__func__.5785+0x275c>
   1a685:	ba 5e 04 00 00       	mov    $0x45e,%edx
   1a68a:	bf 02 00 00 00       	mov    $0x2,%edi
   1a68f:	31 c0                	xor    %eax,%eax
   1a691:	e9 c0 b8 00 00       	jmpq   25f56 <_lv_log_add>

000000000001a696 <lv_obj_set_click>:
    obj->click = (en == true ? 1 : 0);
   1a696:	40 88 f0             	mov    %sil,%al
   1a699:	40 8a 77 5a          	mov    0x5a(%rdi),%sil
   1a69d:	83 e0 01             	and    $0x1,%eax
   1a6a0:	83 e6 fe             	and    $0xfffffffe,%esi
   1a6a3:	09 c6                	or     %eax,%esi
   1a6a5:	40 88 77 5a          	mov    %sil,0x5a(%rdi)
}
   1a6a9:	c3                   	retq   

000000000001a6aa <lv_obj_add_protect>:
    obj->protect |= prot;
   1a6aa:	40 08 77 5c          	or     %sil,0x5c(%rdi)
}
   1a6ae:	c3                   	retq   

000000000001a6af <lv_obj_clear_protect>:
    prot = (~prot) & 0xFF;
   1a6af:	f7 d6                	not    %esi
    obj->protect &= prot;
   1a6b1:	40 20 77 5c          	and    %sil,0x5c(%rdi)
}
   1a6b5:	c3                   	retq   

000000000001a6b6 <lv_obj_set_event_cb>:
    obj->event_cb = event_cb;
   1a6b6:	48 89 77 28          	mov    %rsi,0x28(%rdi)
}
   1a6ba:	c3                   	retq   

000000000001a6bb <lv_event_send_func>:
{
   1a6bb:	41 56                	push   %r14
   1a6bd:	41 55                	push   %r13
   1a6bf:	49 89 fd             	mov    %rdi,%r13
   1a6c2:	41 54                	push   %r12
   1a6c4:	55                   	push   %rbp
   1a6c5:	49 89 cc             	mov    %rcx,%r12
   1a6c8:	53                   	push   %rbx
   1a6c9:	48 89 f5             	mov    %rsi,%rbp
   1a6cc:	89 d3                	mov    %edx,%ebx
   1a6ce:	48 83 ec 20          	sub    $0x20,%rsp
   1a6d2:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1a6d9:	00 00 
   1a6db:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1a6e0:	31 c0                	xor    %eax,%eax
    if(event_temp_data_head) {
   1a6e2:	48 8b 05 e7 d8 23 00 	mov    0x23d8e7(%rip),%rax        # 257fd0 <event_temp_data_head>
    event_temp_data.obj     = obj;
   1a6e9:	48 89 34 24          	mov    %rsi,(%rsp)
    event_temp_data.deleted = false;
   1a6ed:	c6 44 24 08 00       	movb   $0x0,0x8(%rsp)
    event_temp_data.prev    = NULL;
   1a6f2:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
   1a6f9:	00 00 
    if(event_temp_data_head) {
   1a6fb:	48 85 c0             	test   %rax,%rax
   1a6fe:	74 05                	je     1a705 <lv_event_send_func+0x4a>
        event_temp_data.prev = event_temp_data_head;
   1a700:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    event_temp_data_head = &event_temp_data;
   1a705:	48 89 e0             	mov    %rsp,%rax
    const void * event_act_data_save = event_act_data;
   1a708:	4c 8b 35 b9 d8 23 00 	mov    0x23d8b9(%rip),%r14        # 257fc8 <event_act_data>
    event_act_data                   = data;
   1a70f:	4c 89 25 b2 d8 23 00 	mov    %r12,0x23d8b2(%rip)        # 257fc8 <event_act_data>
    event_temp_data_head = &event_temp_data;
   1a716:	48 89 05 b3 d8 23 00 	mov    %rax,0x23d8b3(%rip)        # 257fd0 <event_temp_data_head>
    lv_indev_t * indev_act = lv_indev_get_act();
   1a71d:	e8 e0 f0 ff ff       	callq  19802 <lv_indev_get_act>
    if(indev_act) {
   1a722:	48 85 c0             	test   %rax,%rax
   1a725:	74 11                	je     1a738 <lv_event_send_func+0x7d>
        if(indev_act->driver.feedback_cb) indev_act->driver.feedback_cb(&indev_act->driver, event);
   1a727:	48 8b 50 10          	mov    0x10(%rax),%rdx
   1a72b:	48 85 d2             	test   %rdx,%rdx
   1a72e:	74 08                	je     1a738 <lv_event_send_func+0x7d>
   1a730:	0f b6 f3             	movzbl %bl,%esi
   1a733:	48 89 c7             	mov    %rax,%rdi
   1a736:	ff d2                	callq  *%rdx
    if(event_xcb) event_xcb(obj, event);
   1a738:	4d 85 ed             	test   %r13,%r13
   1a73b:	74 09                	je     1a746 <lv_event_send_func+0x8b>
   1a73d:	0f b6 f3             	movzbl %bl,%esi
   1a740:	48 89 ef             	mov    %rbp,%rdi
   1a743:	41 ff d5             	callq  *%r13
    event_temp_data_head = event_temp_data_head->prev;
   1a746:	48 8b 05 83 d8 23 00 	mov    0x23d883(%rip),%rax        # 257fd0 <event_temp_data_head>
    event_act_data = event_act_data_save;
   1a74d:	4c 89 35 74 d8 23 00 	mov    %r14,0x23d874(%rip)        # 257fc8 <event_act_data>
    event_temp_data_head = event_temp_data_head->prev;
   1a754:	48 8b 40 10          	mov    0x10(%rax),%rax
   1a758:	48 89 05 71 d8 23 00 	mov    %rax,0x23d871(%rip)        # 257fd0 <event_temp_data_head>
        return LV_RES_INV;
   1a75f:	31 c0                	xor    %eax,%eax
    if(event_temp_data.deleted) {
   1a761:	80 7c 24 08 00       	cmpb   $0x0,0x8(%rsp)
   1a766:	75 26                	jne    1a78e <lv_event_send_func+0xd3>
    if(obj) {
   1a768:	48 85 ed             	test   %rbp,%rbp
    return LV_RES_OK;
   1a76b:	b0 01                	mov    $0x1,%al
    if(obj) {
   1a76d:	74 1f                	je     1a78e <lv_event_send_func+0xd3>
        if(obj->parent_event && obj->parent) {
   1a76f:	f6 45 5a 40          	testb  $0x40,0x5a(%rbp)
   1a773:	74 19                	je     1a78e <lv_event_send_func+0xd3>
   1a775:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
   1a779:	48 85 ff             	test   %rdi,%rdi
   1a77c:	74 10                	je     1a78e <lv_event_send_func+0xd3>
            lv_res_t res = lv_event_send(obj->parent, event, data);
   1a77e:	0f b6 f3             	movzbl %bl,%esi
   1a781:	4c 89 e2             	mov    %r12,%rdx
   1a784:	e8 27 00 00 00       	callq  1a7b0 <lv_event_send>
            if(res != LV_RES_OK) {
   1a789:	fe c8                	dec    %al
   1a78b:	0f 94 c0             	sete   %al
}
   1a78e:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   1a793:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1a79a:	00 00 
   1a79c:	74 05                	je     1a7a3 <lv_event_send_func+0xe8>
   1a79e:	e8 9d 9e fe ff       	callq  4640 <__stack_chk_fail@plt>
   1a7a3:	48 83 c4 20          	add    $0x20,%rsp
   1a7a7:	5b                   	pop    %rbx
   1a7a8:	5d                   	pop    %rbp
   1a7a9:	41 5c                	pop    %r12
   1a7ab:	41 5d                	pop    %r13
   1a7ad:	41 5e                	pop    %r14
   1a7af:	c3                   	retq   

000000000001a7b0 <lv_event_send>:
    if(obj == NULL) return LV_RES_OK;
   1a7b0:	48 85 ff             	test   %rdi,%rdi
{
   1a7b3:	48 89 f8             	mov    %rdi,%rax
    if(obj == NULL) return LV_RES_OK;
   1a7b6:	74 15                	je     1a7cd <lv_event_send+0x1d>
    res = lv_event_send_func(obj->event_cb, obj, event, data);
   1a7b8:	48 8b 7f 28          	mov    0x28(%rdi),%rdi
   1a7bc:	40 0f b6 f6          	movzbl %sil,%esi
   1a7c0:	48 89 d1             	mov    %rdx,%rcx
   1a7c3:	89 f2                	mov    %esi,%edx
   1a7c5:	48 89 c6             	mov    %rax,%rsi
   1a7c8:	e9 ee fe ff ff       	jmpq   1a6bb <lv_event_send_func>
}
   1a7cd:	b0 01                	mov    $0x1,%al
   1a7cf:	c3                   	retq   

000000000001a7d0 <lv_obj_set_signal_cb>:
    obj->signal_cb = signal_cb;
   1a7d0:	48 89 77 30          	mov    %rsi,0x30(%rdi)
}
   1a7d4:	c3                   	retq   

000000000001a7d5 <lv_signal_send>:
    if(obj == NULL) return LV_RES_OK;
   1a7d5:	48 85 ff             	test   %rdi,%rdi
   1a7d8:	74 0f                	je     1a7e9 <lv_signal_send+0x14>
    if(obj->signal_cb) res = obj->signal_cb(obj, signal, param);
   1a7da:	48 8b 47 30          	mov    0x30(%rdi),%rax
   1a7de:	48 85 c0             	test   %rax,%rax
   1a7e1:	74 06                	je     1a7e9 <lv_signal_send+0x14>
   1a7e3:	40 0f b6 f6          	movzbl %sil,%esi
   1a7e7:	ff e0                	jmpq   *%rax
}
   1a7e9:	b0 01                	mov    $0x1,%al
   1a7eb:	c3                   	retq   

000000000001a7ec <lv_obj_set_design_cb>:
    obj->design_cb = design_cb;
   1a7ec:	48 89 77 38          	mov    %rsi,0x38(%rdi)
}
   1a7f0:	c3                   	retq   

000000000001a7f1 <lv_obj_allocate_ext_attr>:
{
   1a7f1:	53                   	push   %rbx
   1a7f2:	48 89 fb             	mov    %rdi,%rbx
    void * new_ext = lv_mem_realloc(obj->ext_attr, ext_size);
   1a7f5:	48 8b 7f 40          	mov    0x40(%rdi),%rdi
   1a7f9:	0f b7 f6             	movzwl %si,%esi
   1a7fc:	e8 3c b9 00 00       	callq  2613d <lv_mem_realloc>
    if(new_ext == NULL) return NULL;
   1a801:	48 85 c0             	test   %rax,%rax
   1a804:	74 04                	je     1a80a <lv_obj_allocate_ext_attr+0x19>
    obj->ext_attr = new_ext;
   1a806:	48 89 43 40          	mov    %rax,0x40(%rbx)
}
   1a80a:	5b                   	pop    %rbx
   1a80b:	c3                   	retq   

000000000001a80c <lv_obj_refresh_ext_draw_pad>:
    obj->ext_draw_pad = 0;
   1a80c:	66 c7 47 58 00 00    	movw   $0x0,0x58(%rdi)
    obj->signal_cb(obj, LV_SIGNAL_REFR_EXT_DRAW_PAD, NULL);
   1a812:	48 8b 47 30          	mov    0x30(%rdi),%rax
   1a816:	31 d2                	xor    %edx,%edx
   1a818:	be 06 00 00 00       	mov    $0x6,%esi
   1a81d:	ff e0                	jmpq   *%rax

000000000001a81f <lv_obj_get_parent>:
    return obj->parent;
   1a81f:	48 8b 07             	mov    (%rdi),%rax
}
   1a822:	c3                   	retq   

000000000001a823 <lv_obj_get_screen>:
{
   1a823:	53                   	push   %rbx
   1a824:	48 89 fb             	mov    %rdi,%rbx
        par   = lv_obj_get_parent(act_p);
   1a827:	48 89 df             	mov    %rbx,%rdi
   1a82a:	e8 f0 ff ff ff       	callq  1a81f <lv_obj_get_parent>
    } while(par != NULL);
   1a82f:	48 85 c0             	test   %rax,%rax
   1a832:	74 05                	je     1a839 <lv_obj_get_screen+0x16>
   1a834:	48 89 c3             	mov    %rax,%rbx
   1a837:	eb ee                	jmp    1a827 <lv_obj_get_screen+0x4>
}
   1a839:	48 89 d8             	mov    %rbx,%rax
   1a83c:	5b                   	pop    %rbx
   1a83d:	c3                   	retq   

000000000001a83e <lv_obj_get_disp>:
{
   1a83e:	41 54                	push   %r12
   1a840:	55                   	push   %rbp
   1a841:	48 89 fd             	mov    %rdi,%rbp
   1a844:	53                   	push   %rbx
    if(obj->parent == NULL)
   1a845:	48 83 3f 00          	cmpq   $0x0,(%rdi)
   1a849:	74 08                	je     1a853 <lv_obj_get_disp+0x15>
        scr = lv_obj_get_screen(obj); /*get the screen of `obj`*/
   1a84b:	e8 d3 ff ff ff       	callq  1a823 <lv_obj_get_screen>
   1a850:	48 89 c5             	mov    %rax,%rbp
    _LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d) {
   1a853:	48 8d 3d 96 d5 23 00 	lea    0x23d596(%rip),%rdi        # 257df0 <_lv_disp_ll>
   1a85a:	e8 0c b4 00 00       	callq  25c6b <_lv_ll_get_head>
   1a85f:	48 85 c0             	test   %rax,%rax
   1a862:	48 89 c3             	mov    %rax,%rbx
   1a865:	74 34                	je     1a89b <lv_obj_get_disp+0x5d>
        _LV_LL_READ(d->scr_ll, s) {
   1a867:	4c 8d 63 68          	lea    0x68(%rbx),%r12
   1a86b:	4c 89 e7             	mov    %r12,%rdi
   1a86e:	e8 f8 b3 00 00       	callq  25c6b <_lv_ll_get_head>
   1a873:	48 85 c0             	test   %rax,%rax
   1a876:	74 12                	je     1a88a <lv_obj_get_disp+0x4c>
            if(s == scr) return d;
   1a878:	48 39 c5             	cmp    %rax,%rbp
   1a87b:	74 44                	je     1a8c1 <lv_obj_get_disp+0x83>
        _LV_LL_READ(d->scr_ll, s) {
   1a87d:	48 89 c6             	mov    %rax,%rsi
   1a880:	4c 89 e7             	mov    %r12,%rdi
   1a883:	e8 fb b3 00 00       	callq  25c83 <_lv_ll_get_next>
   1a888:	eb e9                	jmp    1a873 <lv_obj_get_disp+0x35>
    _LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d) {
   1a88a:	48 8d 3d 5f d5 23 00 	lea    0x23d55f(%rip),%rdi        # 257df0 <_lv_disp_ll>
   1a891:	48 89 de             	mov    %rbx,%rsi
   1a894:	e8 ea b3 00 00       	callq  25c83 <_lv_ll_get_next>
   1a899:	eb c4                	jmp    1a85f <lv_obj_get_disp+0x21>
    LV_LOG_WARN("lv_scr_get_disp: screen not found")
   1a89b:	4c 8d 05 9e 8b 01 00 	lea    0x18b9e(%rip),%r8        # 33440 <__func__.5785+0x27d8>
   1a8a2:	48 8d 0d 37 60 01 00 	lea    0x16037(%rip),%rcx        # 308e0 <__func__.6468>
   1a8a9:	48 8d 35 14 8b 01 00 	lea    0x18b14(%rip),%rsi        # 333c4 <__func__.5785+0x275c>
   1a8b0:	ba 54 08 00 00       	mov    $0x854,%edx
   1a8b5:	bf 02 00 00 00       	mov    $0x2,%edi
   1a8ba:	31 c0                	xor    %eax,%eax
   1a8bc:	e8 95 b6 00 00       	callq  25f56 <_lv_log_add>
}
   1a8c1:	48 89 d8             	mov    %rbx,%rax
   1a8c4:	5b                   	pop    %rbx
   1a8c5:	5d                   	pop    %rbp
   1a8c6:	41 5c                	pop    %r12
   1a8c8:	c3                   	retq   

000000000001a8c9 <obj_del_core>:
{
   1a8c9:	55                   	push   %rbp
   1a8ca:	53                   	push   %rbx
   1a8cb:	48 89 fb             	mov    %rdi,%rbx
    i = _lv_ll_get_head(&(obj->child_ll));
   1a8ce:	48 8d 6b 08          	lea    0x8(%rbx),%rbp
    lv_event_send(obj, LV_EVENT_DELETE, NULL);
   1a8d2:	31 d2                	xor    %edx,%edx
   1a8d4:	be 15 00 00 00       	mov    $0x15,%esi
{
   1a8d9:	48 83 ec 18          	sub    $0x18,%rsp
    lv_event_send(obj, LV_EVENT_DELETE, NULL);
   1a8dd:	e8 ce fe ff ff       	callq  1a7b0 <lv_event_send>
        i = _lv_ll_get_head(&(obj->child_ll));
   1a8e2:	48 89 ef             	mov    %rbp,%rdi
   1a8e5:	e8 81 b3 00 00       	callq  25c6b <_lv_ll_get_head>
    while(i != NULL) {
   1a8ea:	48 85 c0             	test   %rax,%rax
   1a8ed:	74 0a                	je     1a8f9 <obj_del_core+0x30>
        obj_del_core(i);
   1a8ef:	48 89 c7             	mov    %rax,%rdi
   1a8f2:	e8 d2 ff ff ff       	callq  1a8c9 <obj_del_core>
   1a8f7:	eb e9                	jmp    1a8e2 <obj_del_core+0x19>
    lv_event_temp_data_t * t = event_temp_data_head;
   1a8f9:	48 8b 05 d0 d6 23 00 	mov    0x23d6d0(%rip),%rax        # 257fd0 <event_temp_data_head>
    while(t) {
   1a900:	48 85 c0             	test   %rax,%rax
   1a903:	74 0f                	je     1a914 <obj_del_core+0x4b>
        if(t->obj == obj) t->deleted = true;
   1a905:	48 3b 18             	cmp    (%rax),%rbx
   1a908:	75 04                	jne    1a90e <obj_del_core+0x45>
   1a90a:	c6 40 08 01          	movb   $0x1,0x8(%rax)
        t = t->prev;
   1a90e:	48 8b 40 10          	mov    0x10(%rax),%rax
   1a912:	eb ec                	jmp    1a900 <obj_del_core+0x37>
    lv_indev_t * indev = lv_indev_get_next(NULL);
   1a914:	31 ff                	xor    %edi,%edi
        indev = lv_indev_get_next(indev);
   1a916:	e8 da aa 00 00       	callq  253f5 <lv_indev_get_next>
    while(indev) {
   1a91b:	48 85 c0             	test   %rax,%rax
   1a91e:	74 34                	je     1a954 <obj_del_core+0x8b>
        if(indev->proc.types.pointer.act_obj == obj || indev->proc.types.pointer.last_obj == obj) {
   1a920:	48 39 58 58          	cmp    %rbx,0x58(%rax)
   1a924:	74 06                	je     1a92c <obj_del_core+0x63>
   1a926:	48 39 58 60          	cmp    %rbx,0x60(%rax)
   1a92a:	75 15                	jne    1a941 <obj_del_core+0x78>
            lv_indev_reset(indev, obj);
   1a92c:	48 89 c7             	mov    %rax,%rdi
   1a92f:	48 89 de             	mov    %rbx,%rsi
   1a932:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   1a937:	e8 ce ee ff ff       	callq  1980a <lv_indev_reset>
   1a93c:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
        if(indev->proc.types.pointer.last_pressed == obj) {
   1a941:	48 39 58 68          	cmp    %rbx,0x68(%rax)
   1a945:	75 08                	jne    1a94f <obj_del_core+0x86>
            indev->proc.types.pointer.last_pressed = NULL;
   1a947:	48 c7 40 68 00 00 00 	movq   $0x0,0x68(%rax)
   1a94e:	00 
        indev = lv_indev_get_next(indev);
   1a94f:	48 89 c7             	mov    %rax,%rdi
   1a952:	eb c2                	jmp    1a916 <obj_del_core+0x4d>
    obj->signal_cb(obj, LV_SIGNAL_CLEANUP, NULL);
   1a954:	31 d2                	xor    %edx,%edx
   1a956:	31 f6                	xor    %esi,%esi
   1a958:	48 89 df             	mov    %rbx,%rdi
   1a95b:	ff 53 30             	callq  *0x30(%rbx)
    lv_obj_t * par = lv_obj_get_parent(obj);
   1a95e:	48 89 df             	mov    %rbx,%rdi
   1a961:	e8 b9 fe ff ff       	callq  1a81f <lv_obj_get_parent>
    if(par == NULL) { /*It is a screen*/
   1a966:	48 85 c0             	test   %rax,%rax
        _lv_ll_remove(&(par->child_ll), obj);
   1a969:	48 8d 78 08          	lea    0x8(%rax),%rdi
    if(par == NULL) { /*It is a screen*/
   1a96d:	75 0c                	jne    1a97b <obj_del_core+0xb2>
        lv_disp_t * d = lv_obj_get_disp(obj);
   1a96f:	48 89 df             	mov    %rbx,%rdi
   1a972:	e8 c7 fe ff ff       	callq  1a83e <lv_obj_get_disp>
        _lv_ll_remove(&d->scr_ll, obj);
   1a977:	48 8d 78 68          	lea    0x68(%rax),%rdi
        _lv_ll_remove(&(par->child_ll), obj);
   1a97b:	48 89 de             	mov    %rbx,%rsi
   1a97e:	e8 a3 b3 00 00       	callq  25d26 <_lv_ll_remove>
    if(obj->ext_attr != NULL) lv_mem_free(obj->ext_attr);
   1a983:	48 8b 7b 40          	mov    0x40(%rbx),%rdi
   1a987:	48 85 ff             	test   %rdi,%rdi
   1a98a:	74 05                	je     1a991 <obj_del_core+0xc8>
   1a98c:	e8 73 b7 00 00       	callq  26104 <lv_mem_free>
}
   1a991:	48 83 c4 18          	add    $0x18,%rsp
    lv_mem_free(obj); /*Free the object itself*/
   1a995:	48 89 df             	mov    %rbx,%rdi
}
   1a998:	5b                   	pop    %rbx
   1a999:	5d                   	pop    %rbp
    lv_mem_free(obj); /*Free the object itself*/
   1a99a:	e9 65 b7 00 00       	jmpq   26104 <lv_mem_free>

000000000001a99f <lv_obj_get_child>:
{
   1a99f:	48 83 c7 08          	add    $0x8,%rdi
    if(child == NULL) {
   1a9a3:	48 85 f6             	test   %rsi,%rsi
   1a9a6:	75 05                	jne    1a9ad <lv_obj_get_child+0xe>
        result = _lv_ll_get_head(&obj->child_ll);
   1a9a8:	e9 be b2 00 00       	jmpq   25c6b <_lv_ll_get_head>
        result = _lv_ll_get_next(&obj->child_ll, child);
   1a9ad:	e9 d1 b2 00 00       	jmpq   25c83 <_lv_ll_get_next>

000000000001a9b2 <lv_obj_get_coords>:
{
   1a9b2:	48 89 f0             	mov    %rsi,%rax
    lv_area_copy(cords_p, &obj->coords);
   1a9b5:	48 8d 77 20          	lea    0x20(%rdi),%rsi
   1a9b9:	48 89 c7             	mov    %rax,%rdi
   1a9bc:	e9 c5 fb ff ff       	jmpq   1a586 <lv_area_copy>

000000000001a9c1 <lv_obj_get_x>:
{
   1a9c1:	53                   	push   %rbx
   1a9c2:	48 89 fb             	mov    %rdi,%rbx
    lv_obj_t * parent = lv_obj_get_parent(obj);
   1a9c5:	e8 55 fe ff ff       	callq  1a81f <lv_obj_get_parent>
    if(parent) {
   1a9ca:	48 85 c0             	test   %rax,%rax
    lv_obj_t * parent = lv_obj_get_parent(obj);
   1a9cd:	48 89 c2             	mov    %rax,%rdx
   1a9d0:	8b 43 20             	mov    0x20(%rbx),%eax
    if(parent) {
   1a9d3:	74 03                	je     1a9d8 <lv_obj_get_x+0x17>
        rel_x             = obj->coords.x1 - parent->coords.x1;
   1a9d5:	2b 42 20             	sub    0x20(%rdx),%eax
}
   1a9d8:	5b                   	pop    %rbx
   1a9d9:	c3                   	retq   

000000000001a9da <lv_obj_get_y>:
{
   1a9da:	53                   	push   %rbx
   1a9db:	48 89 fb             	mov    %rdi,%rbx
    lv_obj_t * parent = lv_obj_get_parent(obj);
   1a9de:	e8 3c fe ff ff       	callq  1a81f <lv_obj_get_parent>
    if(parent) {
   1a9e3:	48 85 c0             	test   %rax,%rax
    lv_obj_t * parent = lv_obj_get_parent(obj);
   1a9e6:	48 89 c2             	mov    %rax,%rdx
   1a9e9:	66 8b 43 22          	mov    0x22(%rbx),%ax
    if(parent) {
   1a9ed:	74 04                	je     1a9f3 <lv_obj_get_y+0x19>
        rel_y             = obj->coords.y1 - parent->coords.y1;
   1a9ef:	66 2b 42 22          	sub    0x22(%rdx),%ax
}
   1a9f3:	5b                   	pop    %rbx
   1a9f4:	c3                   	retq   

000000000001a9f5 <lv_obj_get_width>:
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1a9f5:	66 8b 47 24          	mov    0x24(%rdi),%ax
   1a9f9:	ff c0                	inc    %eax
   1a9fb:	66 2b 47 20          	sub    0x20(%rdi),%ax
}
   1a9ff:	c3                   	retq   

000000000001aa00 <lv_obj_get_height>:
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1aa00:	66 8b 47 26          	mov    0x26(%rdi),%ax
   1aa04:	ff c0                	inc    %eax
   1aa06:	66 2b 47 22          	sub    0x22(%rdi),%ax
}
   1aa0a:	c3                   	retq   

000000000001aa0b <lv_obj_get_auto_realign>:
}
   1aa0b:	31 c0                	xor    %eax,%eax
   1aa0d:	c3                   	retq   

000000000001aa0e <lv_obj_get_style_list>:
{
   1aa0e:	48 83 ec 28          	sub    $0x28,%rsp
   1aa12:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1aa19:	00 00 
   1aa1b:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1aa20:	31 c0                	xor    %eax,%eax
    if(part == LV_OBJ_PART_MAIN) return &((lv_obj_t *)obj)->style_list;
   1aa22:	40 84 f6             	test   %sil,%sil
   1aa25:	75 06                	jne    1aa2d <lv_obj_get_style_list+0x1f>
   1aa27:	48 83 c7 48          	add    $0x48,%rdi
   1aa2b:	eb 28                	jmp    1aa55 <lv_obj_get_style_list+0x47>
    res = lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STYLE, &info);
   1aa2d:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
    info.part = part;
   1aa32:	40 88 74 24 08       	mov    %sil,0x8(%rsp)
    res = lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STYLE, &info);
   1aa37:	be 08 00 00 00       	mov    $0x8,%esi
    info.result = NULL;
   1aa3c:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
   1aa43:	00 00 
    res = lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STYLE, &info);
   1aa45:	e8 8b fd ff ff       	callq  1a7d5 <lv_signal_send>
    if(res != LV_RES_OK) return NULL;
   1aa4a:	31 ff                	xor    %edi,%edi
   1aa4c:	fe c8                	dec    %al
   1aa4e:	75 05                	jne    1aa55 <lv_obj_get_style_list+0x47>
    return info.result;
   1aa50:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
}
   1aa55:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   1aa5a:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1aa61:	00 00 
   1aa63:	48 89 f8             	mov    %rdi,%rax
   1aa66:	74 05                	je     1aa6d <lv_obj_get_style_list+0x5f>
   1aa68:	e8 d3 9b fe ff       	callq  4640 <__stack_chk_fail@plt>
   1aa6d:	48 83 c4 28          	add    $0x28,%rsp
   1aa71:	c3                   	retq   

000000000001aa72 <lv_obj_clean_style_list>:
{
   1aa72:	48 83 ec 08          	sub    $0x8,%rsp
    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);
   1aa76:	40 0f b6 f6          	movzbl %sil,%esi
   1aa7a:	e8 8f ff ff ff       	callq  1aa0e <lv_obj_get_style_list>
    if(style_dsc == NULL) {
   1aa7f:	48 85 c0             	test   %rax,%rax
   1aa82:	75 26                	jne    1aaaa <lv_obj_clean_style_list+0x38>
}
   1aa84:	41 59                	pop    %r9
        LV_LOG_WARN("lv_obj_clean_style_list: can't find style with `part`");
   1aa86:	4c 8d 05 d5 89 01 00 	lea    0x189d5(%rip),%r8        # 33462 <__func__.5785+0x27fa>
   1aa8d:	48 8d 0d 5c 5e 01 00 	lea    0x15e5c(%rip),%rcx        # 308f0 <__func__.6190>
   1aa94:	48 8d 35 29 89 01 00 	lea    0x18929(%rip),%rsi        # 333c4 <__func__.5785+0x275c>
   1aa9b:	ba d5 04 00 00       	mov    $0x4d5,%edx
   1aaa0:	bf 02 00 00 00       	mov    $0x2,%edi
   1aaa5:	e9 ac b4 00 00       	jmpq   25f56 <_lv_log_add>
    _lv_style_list_reset(style_dsc);
   1aaaa:	48 89 c7             	mov    %rax,%rdi
}
   1aaad:	58                   	pop    %rax
    _lv_style_list_reset(style_dsc);
   1aaae:	e9 a2 3e 00 00       	jmpq   1e955 <_lv_style_list_reset>

000000000001aab3 <_lv_obj_disable_style_caching>:
{
   1aab3:	41 55                	push   %r13
   1aab5:	41 54                	push   %r12
        list->ignore_cache = dis;
   1aab7:	41 88 f5             	mov    %sil,%r13b
{
   1aaba:	55                   	push   %rbp
   1aabb:	53                   	push   %rbx
   1aabc:	48 89 fd             	mov    %rdi,%rbp
   1aabf:	41 88 f4             	mov    %sil,%r12b
   1aac2:	31 db                	xor    %ebx,%ebx
        list->ignore_cache = dis;
   1aac4:	41 83 e5 01          	and    $0x1,%r13d
{
   1aac8:	48 83 ec 08          	sub    $0x8,%rsp
        lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   1aacc:	89 de                	mov    %ebx,%esi
   1aace:	48 89 ef             	mov    %rbp,%rdi
   1aad1:	e8 38 ff ff ff       	callq  1aa0e <lv_obj_get_style_list>
        if(list == NULL) break;
   1aad6:	48 85 c0             	test   %rax,%rax
   1aad9:	75 0b                	jne    1aae6 <_lv_obj_disable_style_caching+0x33>
{
   1aadb:	bb 40 00 00 00       	mov    $0x40,%ebx
        list->ignore_cache = dis;
   1aae0:	41 83 e4 01          	and    $0x1,%r12d
   1aae4:	eb 39                	jmp    1ab1f <_lv_obj_disable_style_caching+0x6c>
        list->ignore_cache = dis;
   1aae6:	8a 50 09             	mov    0x9(%rax),%dl
   1aae9:	42 8d 0c ed 00 00 00 	lea    0x0(,%r13,8),%ecx
   1aaf0:	00 
   1aaf1:	ff c3                	inc    %ebx
   1aaf3:	83 e2 f7             	and    $0xfffffff7,%edx
   1aaf6:	09 ca                	or     %ecx,%edx
    for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {
   1aaf8:	83 fb 40             	cmp    $0x40,%ebx
        list->ignore_cache = dis;
   1aafb:	88 50 09             	mov    %dl,0x9(%rax)
    for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {
   1aafe:	75 cc                	jne    1aacc <_lv_obj_disable_style_caching+0x19>
   1ab00:	eb d9                	jmp    1aadb <_lv_obj_disable_style_caching+0x28>
        list->ignore_cache = dis;
   1ab02:	8a 50 09             	mov    0x9(%rax),%dl
   1ab05:	42 8d 0c e5 00 00 00 	lea    0x0(,%r12,8),%ecx
   1ab0c:	00 
   1ab0d:	ff c3                	inc    %ebx
   1ab0f:	83 e2 f7             	and    $0xfffffff7,%edx
   1ab12:	09 ca                	or     %ecx,%edx
    for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {
   1ab14:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
        list->ignore_cache = dis;
   1ab1a:	88 50 09             	mov    %dl,0x9(%rax)
    for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {
   1ab1d:	74 0f                	je     1ab2e <_lv_obj_disable_style_caching+0x7b>
        lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   1ab1f:	89 de                	mov    %ebx,%esi
   1ab21:	48 89 ef             	mov    %rbp,%rdi
   1ab24:	e8 e5 fe ff ff       	callq  1aa0e <lv_obj_get_style_list>
        if(list == NULL) break;
   1ab29:	48 85 c0             	test   %rax,%rax
   1ab2c:	75 d4                	jne    1ab02 <_lv_obj_disable_style_caching+0x4f>
}
   1ab2e:	58                   	pop    %rax
   1ab2f:	5b                   	pop    %rbx
   1ab30:	5d                   	pop    %rbp
   1ab31:	41 5c                	pop    %r12
   1ab33:	41 5d                	pop    %r13
   1ab35:	c3                   	retq   

000000000001ab36 <lv_obj_get_hidden>:
    return obj->hidden == 0 ? false : true;
   1ab36:	8a 47 5a             	mov    0x5a(%rdi),%al
   1ab39:	c0 e8 04             	shr    $0x4,%al
   1ab3c:	83 e0 01             	and    $0x1,%eax
}
   1ab3f:	c3                   	retq   

000000000001ab40 <lv_obj_area_is_visible>:
{
   1ab40:	41 56                	push   %r14
   1ab42:	41 55                	push   %r13
   1ab44:	49 89 f5             	mov    %rsi,%r13
   1ab47:	41 54                	push   %r12
   1ab49:	55                   	push   %rbp
   1ab4a:	48 89 fd             	mov    %rdi,%rbp
   1ab4d:	53                   	push   %rbx
    if(lv_obj_get_hidden(obj)) return false;
   1ab4e:	31 db                	xor    %ebx,%ebx
{
   1ab50:	48 83 ec 10          	sub    $0x10,%rsp
   1ab54:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1ab5b:	00 00 
   1ab5d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   1ab62:	31 c0                	xor    %eax,%eax
    if(lv_obj_get_hidden(obj)) return false;
   1ab64:	e8 cd ff ff ff       	callq  1ab36 <lv_obj_get_hidden>
   1ab69:	84 c0                	test   %al,%al
   1ab6b:	0f 85 bb 00 00 00    	jne    1ac2c <lv_obj_area_is_visible+0xec>
    lv_obj_t * obj_scr = lv_obj_get_screen(obj);
   1ab71:	48 89 ef             	mov    %rbp,%rdi
   1ab74:	88 c3                	mov    %al,%bl
   1ab76:	e8 a8 fc ff ff       	callq  1a823 <lv_obj_get_screen>
    lv_disp_t * disp   = lv_obj_get_disp(obj_scr);
   1ab7b:	48 89 c7             	mov    %rax,%rdi
    lv_obj_t * obj_scr = lv_obj_get_screen(obj);
   1ab7e:	49 89 c4             	mov    %rax,%r12
    lv_disp_t * disp   = lv_obj_get_disp(obj_scr);
   1ab81:	e8 b8 fc ff ff       	callq  1a83e <lv_obj_get_disp>
    if(obj_scr == lv_disp_get_scr_act(disp) ||
   1ab86:	48 89 c7             	mov    %rax,%rdi
    lv_disp_t * disp   = lv_obj_get_disp(obj_scr);
   1ab89:	49 89 c6             	mov    %rax,%r14
    if(obj_scr == lv_disp_get_scr_act(disp) ||
   1ab8c:	e8 c4 e6 ff ff       	callq  19255 <lv_disp_get_scr_act>
   1ab91:	4c 39 e0             	cmp    %r12,%rax
   1ab94:	75 39                	jne    1abcf <lv_obj_area_is_visible+0x8f>
        lv_area_copy(&obj_coords, &obj->coords);
   1ab96:	48 89 e2             	mov    %rsp,%rdx
   1ab99:	48 8d 75 20          	lea    0x20(%rbp),%rsi
        lv_coord_t ext_size = obj->ext_draw_pad;
   1ab9d:	8b 4d 58             	mov    0x58(%rbp),%ecx
        lv_area_copy(&obj_coords, &obj->coords);
   1aba0:	48 89 d7             	mov    %rdx,%rdi
   1aba3:	e8 de f9 ff ff       	callq  1a586 <lv_area_copy>
        is_common = _lv_area_intersect(area, area, &obj_coords);
   1aba8:	4c 89 ee             	mov    %r13,%rsi
   1abab:	4c 89 ef             	mov    %r13,%rdi
        obj_coords.x1 -= ext_size;
   1abae:	66 29 0c 24          	sub    %cx,(%rsp)
        obj_coords.y1 -= ext_size;
   1abb2:	66 29 4c 24 02       	sub    %cx,0x2(%rsp)
        obj_coords.x2 += ext_size;
   1abb7:	66 01 4c 24 04       	add    %cx,0x4(%rsp)
        obj_coords.y2 += ext_size;
   1abbc:	66 01 4c 24 06       	add    %cx,0x6(%rsp)
        is_common = _lv_area_intersect(area, area, &obj_coords);
   1abc1:	e8 56 a9 00 00       	callq  2551c <_lv_area_intersect>
        if(is_common == false) return false;  /*The area is not on the object*/
   1abc6:	84 c0                	test   %al,%al
        is_common = _lv_area_intersect(area, area, &obj_coords);
   1abc8:	41 88 c4             	mov    %al,%r12b
        if(is_common == false) return false;  /*The area is not on the object*/
   1abcb:	74 5f                	je     1ac2c <lv_obj_area_is_visible+0xec>
   1abcd:	eb 4a                	jmp    1ac19 <lv_obj_area_is_visible+0xd9>
       obj_scr == lv_disp_get_scr_prev(disp) ||
   1abcf:	4c 89 f7             	mov    %r14,%rdi
   1abd2:	e8 ca e6 ff ff       	callq  192a1 <lv_disp_get_scr_prev>
    if(obj_scr == lv_disp_get_scr_act(disp) ||
   1abd7:	4c 39 e0             	cmp    %r12,%rax
   1abda:	74 ba                	je     1ab96 <lv_obj_area_is_visible+0x56>
       obj_scr == lv_disp_get_layer_top(disp) ||
   1abdc:	4c 89 f7             	mov    %r14,%rdi
   1abdf:	e8 29 e7 ff ff       	callq  1930d <lv_disp_get_layer_top>
       obj_scr == lv_disp_get_scr_prev(disp) ||
   1abe4:	4c 39 e0             	cmp    %r12,%rax
   1abe7:	74 ad                	je     1ab96 <lv_obj_area_is_visible+0x56>
       obj_scr == lv_disp_get_layer_sys(disp)) {
   1abe9:	4c 89 f7             	mov    %r14,%rdi
   1abec:	e8 68 e7 ff ff       	callq  19359 <lv_disp_get_layer_sys>
       obj_scr == lv_disp_get_layer_top(disp) ||
   1abf1:	4c 39 e0             	cmp    %r12,%rax
   1abf4:	74 a0                	je     1ab96 <lv_obj_area_is_visible+0x56>
    return true;
   1abf6:	b3 01                	mov    $0x1,%bl
   1abf8:	eb 32                	jmp    1ac2c <lv_obj_area_is_visible+0xec>
            is_common = _lv_area_intersect(area, area, &par->coords);
   1abfa:	48 8d 55 20          	lea    0x20(%rbp),%rdx
   1abfe:	4c 89 ee             	mov    %r13,%rsi
   1ac01:	4c 89 ef             	mov    %r13,%rdi
   1ac04:	e8 13 a9 00 00       	callq  2551c <_lv_area_intersect>
            if(is_common == false) return false;       /*If no common parts with parent break;*/
   1ac09:	84 c0                	test   %al,%al
   1ac0b:	74 1f                	je     1ac2c <lv_obj_area_is_visible+0xec>
            if(lv_obj_get_hidden(par)) return false; /*If the parent is hidden then the child is hidden and won't be drawn*/
   1ac0d:	48 89 ef             	mov    %rbp,%rdi
   1ac10:	e8 21 ff ff ff       	callq  1ab36 <lv_obj_get_hidden>
   1ac15:	84 c0                	test   %al,%al
   1ac17:	75 13                	jne    1ac2c <lv_obj_area_is_visible+0xec>
            par = lv_obj_get_parent(par);
   1ac19:	48 89 ef             	mov    %rbp,%rdi
   1ac1c:	e8 fe fb ff ff       	callq  1a81f <lv_obj_get_parent>
        while(par != NULL) {
   1ac21:	48 85 c0             	test   %rax,%rax
            par = lv_obj_get_parent(par);
   1ac24:	48 89 c5             	mov    %rax,%rbp
        while(par != NULL) {
   1ac27:	75 d1                	jne    1abfa <lv_obj_area_is_visible+0xba>
    return true;
   1ac29:	44 88 e3             	mov    %r12b,%bl
}
   1ac2c:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
   1ac31:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1ac38:	00 00 
   1ac3a:	88 d8                	mov    %bl,%al
   1ac3c:	74 05                	je     1ac43 <lv_obj_area_is_visible+0x103>
   1ac3e:	e8 fd 99 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1ac43:	48 83 c4 10          	add    $0x10,%rsp
   1ac47:	5b                   	pop    %rbx
   1ac48:	5d                   	pop    %rbp
   1ac49:	41 5c                	pop    %r12
   1ac4b:	41 5d                	pop    %r13
   1ac4d:	41 5e                	pop    %r14
   1ac4f:	c3                   	retq   

000000000001ac50 <lv_obj_invalidate_area>:
{
   1ac50:	55                   	push   %rbp
   1ac51:	53                   	push   %rbx
   1ac52:	48 89 fd             	mov    %rdi,%rbp
   1ac55:	48 83 ec 18          	sub    $0x18,%rsp
    lv_area_copy(&area_tmp, area);
   1ac59:	48 89 e3             	mov    %rsp,%rbx
   1ac5c:	48 89 df             	mov    %rbx,%rdi
{
   1ac5f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1ac66:	00 00 
   1ac68:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   1ac6d:	31 c0                	xor    %eax,%eax
    lv_area_copy(&area_tmp, area);
   1ac6f:	e8 12 f9 ff ff       	callq  1a586 <lv_area_copy>
    bool visible = lv_obj_area_is_visible(obj, &area_tmp);
   1ac74:	48 89 de             	mov    %rbx,%rsi
   1ac77:	48 89 ef             	mov    %rbp,%rdi
   1ac7a:	e8 c1 fe ff ff       	callq  1ab40 <lv_obj_area_is_visible>
    if(visible) _lv_inv_area(lv_obj_get_disp(obj), &area_tmp);
   1ac7f:	84 c0                	test   %al,%al
   1ac81:	74 13                	je     1ac96 <lv_obj_invalidate_area+0x46>
   1ac83:	48 89 ef             	mov    %rbp,%rdi
   1ac86:	e8 b3 fb ff ff       	callq  1a83e <lv_obj_get_disp>
   1ac8b:	48 89 de             	mov    %rbx,%rsi
   1ac8e:	48 89 c7             	mov    %rax,%rdi
   1ac91:	e8 59 29 00 00       	callq  1d5ef <_lv_inv_area>
}
   1ac96:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   1ac9b:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1aca2:	00 00 
   1aca4:	74 05                	je     1acab <lv_obj_invalidate_area+0x5b>
   1aca6:	e8 95 99 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1acab:	48 83 c4 18          	add    $0x18,%rsp
   1acaf:	5b                   	pop    %rbx
   1acb0:	5d                   	pop    %rbp
   1acb1:	c3                   	retq   

000000000001acb2 <lv_obj_invalidate>:
{
   1acb2:	48 83 ec 18          	sub    $0x18,%rsp
    lv_area_copy(&obj_coords, &obj->coords);
   1acb6:	48 8d 77 20          	lea    0x20(%rdi),%rsi
    lv_coord_t ext_size = obj->ext_draw_pad;
   1acba:	8b 57 58             	mov    0x58(%rdi),%edx
    lv_area_copy(&obj_coords, &obj->coords);
   1acbd:	49 89 e0             	mov    %rsp,%r8
{
   1acc0:	48 89 f9             	mov    %rdi,%rcx
    lv_area_copy(&obj_coords, &obj->coords);
   1acc3:	4c 89 c7             	mov    %r8,%rdi
{
   1acc6:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1accd:	00 00 
   1accf:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   1acd4:	31 c0                	xor    %eax,%eax
    lv_area_copy(&obj_coords, &obj->coords);
   1acd6:	e8 ab f8 ff ff       	callq  1a586 <lv_area_copy>
    lv_obj_invalidate_area(obj, &obj_coords);
   1acdb:	4c 89 c6             	mov    %r8,%rsi
   1acde:	48 89 cf             	mov    %rcx,%rdi
    obj_coords.x1 -= ext_size;
   1ace1:	66 29 14 24          	sub    %dx,(%rsp)
    obj_coords.y1 -= ext_size;
   1ace5:	66 29 54 24 02       	sub    %dx,0x2(%rsp)
    obj_coords.x2 += ext_size;
   1acea:	66 01 54 24 04       	add    %dx,0x4(%rsp)
    obj_coords.y2 += ext_size;
   1acef:	66 01 54 24 06       	add    %dx,0x6(%rsp)
    lv_obj_invalidate_area(obj, &obj_coords);
   1acf4:	e8 57 ff ff ff       	callq  1ac50 <lv_obj_invalidate_area>
}
   1acf9:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   1acfe:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1ad05:	00 00 
   1ad07:	74 05                	je     1ad0e <lv_obj_invalidate+0x5c>
   1ad09:	e8 32 99 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1ad0e:	48 83 c4 18          	add    $0x18,%rsp
   1ad12:	c3                   	retq   

000000000001ad13 <lv_obj_del>:
{
   1ad13:	41 55                	push   %r13
   1ad15:	41 54                	push   %r12
   1ad17:	55                   	push   %rbp
   1ad18:	53                   	push   %rbx
   1ad19:	48 89 fb             	mov    %rdi,%rbx
   1ad1c:	48 83 ec 08          	sub    $0x8,%rsp
    lv_obj_invalidate(obj);
   1ad20:	e8 8d ff ff ff       	callq  1acb2 <lv_obj_invalidate>
    lv_obj_t * par = lv_obj_get_parent(obj);
   1ad25:	48 89 df             	mov    %rbx,%rdi
   1ad28:	e8 f2 fa ff ff       	callq  1a81f <lv_obj_get_parent>
    if(par == NULL) {
   1ad2d:	48 85 c0             	test   %rax,%rax
    lv_obj_t * par = lv_obj_get_parent(obj);
   1ad30:	49 89 c4             	mov    %rax,%r12
    if(par == NULL) {
   1ad33:	75 1d                	jne    1ad52 <lv_obj_del+0x3f>
        disp = lv_obj_get_disp(obj);
   1ad35:	48 89 df             	mov    %rbx,%rdi
   1ad38:	e8 01 fb ff ff       	callq  1a83e <lv_obj_get_disp>
        if(!disp) return LV_RES_INV;   /*Shouldn't happen*/
   1ad3d:	48 85 c0             	test   %rax,%rax
        disp = lv_obj_get_disp(obj);
   1ad40:	48 89 c5             	mov    %rax,%rbp
        if(!disp) return LV_RES_INV;   /*Shouldn't happen*/
   1ad43:	74 3e                	je     1ad83 <lv_obj_del+0x70>
        if(disp->act_scr == obj) act_scr_del = true;
   1ad45:	48 39 98 80 00 00 00 	cmp    %rbx,0x80(%rax)
   1ad4c:	41 0f 94 c5          	sete   %r13b
   1ad50:	eb 05                	jmp    1ad57 <lv_obj_del+0x44>
    bool act_scr_del = false;
   1ad52:	45 31 ed             	xor    %r13d,%r13d
    lv_disp_t * disp = NULL;
   1ad55:	31 ed                	xor    %ebp,%ebp
    obj_del_core(obj);
   1ad57:	48 89 df             	mov    %rbx,%rdi
   1ad5a:	e8 6a fb ff ff       	callq  1a8c9 <obj_del_core>
    if(par) {
   1ad5f:	4d 85 e4             	test   %r12,%r12
   1ad62:	74 0f                	je     1ad73 <lv_obj_del+0x60>
        par->signal_cb(par, LV_SIGNAL_CHILD_CHG, NULL);
   1ad64:	31 d2                	xor    %edx,%edx
   1ad66:	be 01 00 00 00       	mov    $0x1,%esi
   1ad6b:	4c 89 e7             	mov    %r12,%rdi
   1ad6e:	41 ff 54 24 30       	callq  *0x30(%r12)
    if(act_scr_del)  {
   1ad73:	45 84 ed             	test   %r13b,%r13b
   1ad76:	74 0b                	je     1ad83 <lv_obj_del+0x70>
        disp->act_scr = NULL;
   1ad78:	48 c7 85 80 00 00 00 	movq   $0x0,0x80(%rbp)
   1ad7f:	00 00 00 00 
}
   1ad83:	5a                   	pop    %rdx
   1ad84:	31 c0                	xor    %eax,%eax
   1ad86:	5b                   	pop    %rbx
   1ad87:	5d                   	pop    %rbp
   1ad88:	41 5c                	pop    %r12
   1ad8a:	41 5d                	pop    %r13
   1ad8c:	c3                   	retq   

000000000001ad8d <lv_obj_move_foreground>:
{
   1ad8d:	41 54                	push   %r12
   1ad8f:	55                   	push   %rbp
   1ad90:	48 89 fd             	mov    %rdi,%rbp
   1ad93:	53                   	push   %rbx
    lv_obj_t * parent = lv_obj_get_parent(obj);
   1ad94:	e8 86 fa ff ff       	callq  1a81f <lv_obj_get_parent>
    if(_lv_ll_get_head(&parent->child_ll) == obj) return;
   1ad99:	4c 8d 60 08          	lea    0x8(%rax),%r12
    lv_obj_t * parent = lv_obj_get_parent(obj);
   1ad9d:	48 89 c3             	mov    %rax,%rbx
    if(_lv_ll_get_head(&parent->child_ll) == obj) return;
   1ada0:	4c 89 e7             	mov    %r12,%rdi
   1ada3:	e8 c3 ae 00 00       	callq  25c6b <_lv_ll_get_head>
   1ada8:	48 39 e8             	cmp    %rbp,%rax
   1adab:	74 35                	je     1ade2 <lv_obj_move_foreground+0x55>
    lv_obj_invalidate(parent);
   1adad:	48 89 df             	mov    %rbx,%rdi
   1adb0:	e8 fd fe ff ff       	callq  1acb2 <lv_obj_invalidate>
    _lv_ll_chg_list(&parent->child_ll, &parent->child_ll, obj, true);
   1adb5:	48 89 ea             	mov    %rbp,%rdx
   1adb8:	4c 89 e6             	mov    %r12,%rsi
   1adbb:	4c 89 e7             	mov    %r12,%rdi
   1adbe:	b9 01 00 00 00       	mov    $0x1,%ecx
   1adc3:	e8 14 b0 00 00       	callq  25ddc <_lv_ll_chg_list>
    parent->signal_cb(parent, LV_SIGNAL_CHILD_CHG, obj);
   1adc8:	48 89 df             	mov    %rbx,%rdi
   1adcb:	48 89 ea             	mov    %rbp,%rdx
   1adce:	be 01 00 00 00       	mov    $0x1,%esi
   1add3:	ff 53 30             	callq  *0x30(%rbx)
    lv_obj_invalidate(parent);
   1add6:	48 89 df             	mov    %rbx,%rdi
}
   1add9:	5b                   	pop    %rbx
   1adda:	5d                   	pop    %rbp
   1addb:	41 5c                	pop    %r12
    lv_obj_invalidate(parent);
   1addd:	e9 d0 fe ff ff       	jmpq   1acb2 <lv_obj_invalidate>
}
   1ade2:	5b                   	pop    %rbx
   1ade3:	5d                   	pop    %rbp
   1ade4:	41 5c                	pop    %r12
   1ade6:	c3                   	retq   

000000000001ade7 <lv_obj_set_pos>:
{
   1ade7:	41 56                	push   %r14
   1ade9:	41 55                	push   %r13
   1adeb:	41 54                	push   %r12
   1aded:	55                   	push   %rbp
   1adee:	41 89 d4             	mov    %edx,%r12d
   1adf1:	53                   	push   %rbx
   1adf2:	89 f5                	mov    %esi,%ebp
   1adf4:	48 89 fb             	mov    %rdi,%rbx
   1adf7:	48 83 ec 10          	sub    $0x10,%rsp
    lv_obj_t * par = obj->parent;
   1adfb:	4c 8b 2f             	mov    (%rdi),%r13
{
   1adfe:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1ae05:	00 00 
   1ae07:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   1ae0c:	31 c0                	xor    %eax,%eax
    if(par) {
   1ae0e:	4d 85 ed             	test   %r13,%r13
   1ae11:	74 09                	je     1ae1c <lv_obj_set_pos+0x35>
        x = x + par->coords.x1;
   1ae13:	41 03 6d 20          	add    0x20(%r13),%ebp
        y = y + par->coords.y1;
   1ae17:	66 45 03 65 22       	add    0x22(%r13),%r12w
    diff.x = x - obj->coords.x1;
   1ae1c:	2b 6b 20             	sub    0x20(%rbx),%ebp
    diff.y = y - obj->coords.y1;
   1ae1f:	66 44 2b 63 22       	sub    0x22(%rbx),%r12w
    if(diff.x == 0 && diff.y == 0) return;
   1ae24:	89 e8                	mov    %ebp,%eax
   1ae26:	66 44 09 e0          	or     %r12w,%ax
   1ae2a:	74 61                	je     1ae8d <lv_obj_set_pos+0xa6>
    lv_obj_invalidate(obj);
   1ae2c:	48 89 df             	mov    %rbx,%rdi
    lv_obj_get_coords(obj, &ori);
   1ae2f:	49 89 e6             	mov    %rsp,%r14
    lv_obj_invalidate(obj);
   1ae32:	e8 7b fe ff ff       	callq  1acb2 <lv_obj_invalidate>
    lv_obj_get_coords(obj, &ori);
   1ae37:	4c 89 f6             	mov    %r14,%rsi
   1ae3a:	48 89 df             	mov    %rbx,%rdi
   1ae3d:	e8 70 fb ff ff       	callq  1a9b2 <lv_obj_get_coords>
    obj->coords.x1 += diff.x;
   1ae42:	66 01 6b 20          	add    %bp,0x20(%rbx)
    obj->coords.y1 += diff.y;
   1ae46:	66 44 01 63 22       	add    %r12w,0x22(%rbx)
    refresh_children_position(obj, diff.x, diff.y);
   1ae4b:	41 0f bf d4          	movswl %r12w,%edx
   1ae4f:	0f bf f5             	movswl %bp,%esi
   1ae52:	48 89 df             	mov    %rbx,%rdi
    obj->coords.x2 += diff.x;
   1ae55:	66 01 6b 24          	add    %bp,0x24(%rbx)
    obj->coords.y2 += diff.y;
   1ae59:	66 44 01 63 26       	add    %r12w,0x26(%rbx)
    refresh_children_position(obj, diff.x, diff.y);
   1ae5e:	e8 bf f6 ff ff       	callq  1a522 <refresh_children_position>
    obj->signal_cb(obj, LV_SIGNAL_COORD_CHG, &ori);
   1ae63:	4c 89 f2             	mov    %r14,%rdx
   1ae66:	be 02 00 00 00       	mov    $0x2,%esi
   1ae6b:	48 89 df             	mov    %rbx,%rdi
   1ae6e:	ff 53 30             	callq  *0x30(%rbx)
    if(par) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
   1ae71:	4d 85 ed             	test   %r13,%r13
   1ae74:	74 0f                	je     1ae85 <lv_obj_set_pos+0x9e>
   1ae76:	48 89 da             	mov    %rbx,%rdx
   1ae79:	be 01 00 00 00       	mov    $0x1,%esi
   1ae7e:	4c 89 ef             	mov    %r13,%rdi
   1ae81:	41 ff 55 30          	callq  *0x30(%r13)
    lv_obj_invalidate(obj);
   1ae85:	48 89 df             	mov    %rbx,%rdi
   1ae88:	e8 25 fe ff ff       	callq  1acb2 <lv_obj_invalidate>
}
   1ae8d:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   1ae92:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1ae99:	00 00 
   1ae9b:	74 05                	je     1aea2 <lv_obj_set_pos+0xbb>
   1ae9d:	e8 9e 97 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1aea2:	48 83 c4 10          	add    $0x10,%rsp
   1aea6:	5b                   	pop    %rbx
   1aea7:	5d                   	pop    %rbp
   1aea8:	41 5c                	pop    %r12
   1aeaa:	41 5d                	pop    %r13
   1aeac:	41 5e                	pop    %r14
   1aeae:	c3                   	retq   

000000000001aeaf <lv_obj_set_x>:
{
   1aeaf:	55                   	push   %rbp
   1aeb0:	53                   	push   %rbx
   1aeb1:	48 89 fd             	mov    %rdi,%rbp
   1aeb4:	89 f3                	mov    %esi,%ebx
   1aeb6:	48 83 ec 08          	sub    $0x8,%rsp
    lv_obj_set_pos(obj, x, lv_obj_get_y(obj));
   1aeba:	e8 1b fb ff ff       	callq  1a9da <lv_obj_get_y>
   1aebf:	0f bf f3             	movswl %bx,%esi
   1aec2:	0f bf d0             	movswl %ax,%edx
   1aec5:	48 89 ef             	mov    %rbp,%rdi
}
   1aec8:	58                   	pop    %rax
   1aec9:	5b                   	pop    %rbx
   1aeca:	5d                   	pop    %rbp
    lv_obj_set_pos(obj, x, lv_obj_get_y(obj));
   1aecb:	e9 17 ff ff ff       	jmpq   1ade7 <lv_obj_set_pos>

000000000001aed0 <lv_obj_set_y>:
{
   1aed0:	55                   	push   %rbp
   1aed1:	53                   	push   %rbx
   1aed2:	48 89 fd             	mov    %rdi,%rbp
   1aed5:	89 f3                	mov    %esi,%ebx
   1aed7:	48 83 ec 08          	sub    $0x8,%rsp
    lv_obj_set_pos(obj, lv_obj_get_x(obj), y);
   1aedb:	e8 e1 fa ff ff       	callq  1a9c1 <lv_obj_get_x>
   1aee0:	0f bf d3             	movswl %bx,%edx
   1aee3:	0f bf f0             	movswl %ax,%esi
   1aee6:	48 89 ef             	mov    %rbp,%rdi
}
   1aee9:	58                   	pop    %rax
   1aeea:	5b                   	pop    %rbx
   1aeeb:	5d                   	pop    %rbp
    lv_obj_set_pos(obj, lv_obj_get_x(obj), y);
   1aeec:	e9 f6 fe ff ff       	jmpq   1ade7 <lv_obj_set_pos>

000000000001aef1 <obj_align_core>:
{
   1aef1:	41 54                	push   %r12
   1aef3:	55                   	push   %rbp
   1aef4:	48 89 fd             	mov    %rdi,%rbp
   1aef7:	53                   	push   %rbx
   1aef8:	48 89 f7             	mov    %rsi,%rdi
   1aefb:	41 89 cc             	mov    %ecx,%r12d
    _lv_area_align(&base->coords, &obj->coords, align, &new_pos);
   1aefe:	48 8d 75 20          	lea    0x20(%rbp),%rsi
   1af02:	0f b6 d2             	movzbl %dl,%edx
   1af05:	48 83 c7 20          	add    $0x20,%rdi
{
   1af09:	48 83 ec 20          	sub    $0x20,%rsp
    _lv_area_align(&base->coords, &obj->coords, align, &new_pos);
   1af0d:	48 8d 4c 24 14       	lea    0x14(%rsp),%rcx
{
   1af12:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
   1af17:	44 89 4c 24 08       	mov    %r9d,0x8(%rsp)
   1af1c:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1af23:	00 00 
   1af25:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1af2a:	31 c0                	xor    %eax,%eax
   1af2c:	8b 5c 24 40          	mov    0x40(%rsp),%ebx
    _lv_area_align(&base->coords, &obj->coords, align, &new_pos);
   1af30:	e8 8a a9 00 00       	callq  258bf <_lv_area_align>
    lv_obj_t * par        = lv_obj_get_parent(obj);
   1af35:	48 89 ef             	mov    %rbp,%rdi
   1af38:	e8 e2 f8 ff ff       	callq  1a81f <lv_obj_get_parent>
    new_pos.x += x_ofs;
   1af3d:	44 8b 4c 24 08       	mov    0x8(%rsp),%r9d
    new_pos.y += y_ofs;
   1af42:	66 8b 54 24 16       	mov    0x16(%rsp),%dx
    lv_coord_t par_abs_y  = par->coords.y1;
   1af47:	66 8b 48 22          	mov    0x22(%rax),%cx
    if(x_set && y_set) lv_obj_set_pos(obj, new_pos.x, new_pos.y);
   1af4b:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
    new_pos.x += x_ofs;
   1af50:	44 89 ce             	mov    %r9d,%esi
   1af53:	03 74 24 14          	add    0x14(%rsp),%esi
    new_pos.y += y_ofs;
   1af57:	01 da                	add    %ebx,%edx
    new_pos.x -= par_abs_x;
   1af59:	2b 70 20             	sub    0x20(%rax),%esi
    new_pos.y -= par_abs_y;
   1af5c:	29 ca                	sub    %ecx,%edx
    if(x_set && y_set) lv_obj_set_pos(obj, new_pos.x, new_pos.y);
   1af5e:	45 84 e4             	test   %r12b,%r12b
    new_pos.y -= par_abs_y;
   1af61:	66 89 54 24 16       	mov    %dx,0x16(%rsp)
    new_pos.x -= par_abs_x;
   1af66:	66 89 74 24 14       	mov    %si,0x14(%rsp)
    if(x_set && y_set) lv_obj_set_pos(obj, new_pos.x, new_pos.y);
   1af6b:	74 1f                	je     1af8c <obj_align_core+0x9b>
   1af6d:	45 84 c0             	test   %r8b,%r8b
   1af70:	0f bf f6             	movswl %si,%esi
   1af73:	74 0d                	je     1af82 <obj_align_core+0x91>
   1af75:	0f bf d2             	movswl %dx,%edx
   1af78:	48 89 ef             	mov    %rbp,%rdi
   1af7b:	e8 67 fe ff ff       	callq  1ade7 <lv_obj_set_pos>
   1af80:	eb 1a                	jmp    1af9c <obj_align_core+0xab>
    else if(x_set) lv_obj_set_x(obj, new_pos.x);
   1af82:	48 89 ef             	mov    %rbp,%rdi
   1af85:	e8 25 ff ff ff       	callq  1aeaf <lv_obj_set_x>
   1af8a:	eb 10                	jmp    1af9c <obj_align_core+0xab>
    else if(y_set) lv_obj_set_y(obj, new_pos.y);
   1af8c:	45 84 c0             	test   %r8b,%r8b
   1af8f:	74 0b                	je     1af9c <obj_align_core+0xab>
   1af91:	0f bf f2             	movswl %dx,%esi
   1af94:	48 89 ef             	mov    %rbp,%rdi
   1af97:	e8 34 ff ff ff       	callq  1aed0 <lv_obj_set_y>
}
   1af9c:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
   1afa1:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1afa8:	00 00 
   1afaa:	74 05                	je     1afb1 <obj_align_core+0xc0>
   1afac:	e8 8f 96 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1afb1:	48 83 c4 20          	add    $0x20,%rsp
   1afb5:	5b                   	pop    %rbx
   1afb6:	5d                   	pop    %rbp
   1afb7:	41 5c                	pop    %r12
   1afb9:	c3                   	retq   

000000000001afba <lv_obj_align>:
{
   1afba:	41 54                	push   %r12
   1afbc:	55                   	push   %rbp
   1afbd:	41 89 cc             	mov    %ecx,%r12d
   1afc0:	53                   	push   %rbx
   1afc1:	48 89 fd             	mov    %rdi,%rbp
   1afc4:	89 d3                	mov    %edx,%ebx
   1afc6:	48 83 ec 10          	sub    $0x10,%rsp
    if(base == NULL) base = lv_obj_get_parent(obj);
   1afca:	48 85 f6             	test   %rsi,%rsi
   1afcd:	75 12                	jne    1afe1 <lv_obj_align+0x27>
   1afcf:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
   1afd4:	e8 46 f8 ff ff       	callq  1a81f <lv_obj_get_parent>
   1afd9:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
   1afde:	48 89 c6             	mov    %rax,%rsi
    obj_align_core(obj, base, align, true, true, x_ofs, y_ofs);
   1afe1:	48 83 ec 08          	sub    $0x8,%rsp
   1afe5:	45 0f bf c0          	movswl %r8w,%r8d
   1afe9:	0f b6 d3             	movzbl %bl,%edx
   1afec:	41 50                	push   %r8
   1afee:	45 0f bf cc          	movswl %r12w,%r9d
   1aff2:	48 89 ef             	mov    %rbp,%rdi
   1aff5:	41 b8 01 00 00 00    	mov    $0x1,%r8d
   1affb:	b9 01 00 00 00       	mov    $0x1,%ecx
   1b000:	e8 ec fe ff ff       	callq  1aef1 <obj_align_core>
}
   1b005:	48 83 c4 20          	add    $0x20,%rsp
   1b009:	5b                   	pop    %rbx
   1b00a:	5d                   	pop    %rbp
   1b00b:	41 5c                	pop    %r12
   1b00d:	c3                   	retq   

000000000001b00e <refresh_children_style>:
{
   1b00e:	55                   	push   %rbp
   1b00f:	53                   	push   %rbx
   1b010:	48 89 fd             	mov    %rdi,%rbp
    lv_obj_t * child = lv_obj_get_child(obj, NULL);
   1b013:	31 f6                	xor    %esi,%esi
{
   1b015:	48 83 ec 08          	sub    $0x8,%rsp
        child = lv_obj_get_child(obj, child);
   1b019:	e8 81 f9 ff ff       	callq  1a99f <lv_obj_get_child>
    while(child != NULL) {
   1b01e:	48 85 c0             	test   %rax,%rax
        child = lv_obj_get_child(obj, child);
   1b021:	48 89 c3             	mov    %rax,%rbx
    while(child != NULL) {
   1b024:	74 2d                	je     1b053 <refresh_children_style+0x45>
        lv_obj_invalidate(child);
   1b026:	48 89 df             	mov    %rbx,%rdi
   1b029:	e8 84 fc ff ff       	callq  1acb2 <lv_obj_invalidate>
        child->signal_cb(child, LV_SIGNAL_STYLE_CHG, NULL);
   1b02e:	be 04 00 00 00       	mov    $0x4,%esi
   1b033:	31 d2                	xor    %edx,%edx
   1b035:	48 89 df             	mov    %rbx,%rdi
   1b038:	ff 53 30             	callq  *0x30(%rbx)
        lv_obj_invalidate(child);
   1b03b:	48 89 df             	mov    %rbx,%rdi
   1b03e:	e8 6f fc ff ff       	callq  1acb2 <lv_obj_invalidate>
        refresh_children_style(child); /*Check children too*/
   1b043:	48 89 df             	mov    %rbx,%rdi
   1b046:	e8 c3 ff ff ff       	callq  1b00e <refresh_children_style>
        child = lv_obj_get_child(obj, child);
   1b04b:	48 89 de             	mov    %rbx,%rsi
   1b04e:	48 89 ef             	mov    %rbp,%rdi
   1b051:	eb c6                	jmp    1b019 <refresh_children_style+0xb>
}
   1b053:	58                   	pop    %rax
   1b054:	5b                   	pop    %rbx
   1b055:	5d                   	pop    %rbp
   1b056:	c3                   	retq   

000000000001b057 <lv_obj_get_click>:
    return obj->click == 0 ? false : true;
   1b057:	8a 47 5a             	mov    0x5a(%rdi),%al
   1b05a:	83 e0 01             	and    $0x1,%eax
}
   1b05d:	c3                   	retq   

000000000001b05e <lv_obj_get_drag>:
    return obj->drag == 0 ? false : true;
   1b05e:	8a 47 5a             	mov    0x5a(%rdi),%al
   1b061:	d0 e8                	shr    %al
   1b063:	83 e0 01             	and    $0x1,%eax
}
   1b066:	c3                   	retq   

000000000001b067 <lv_obj_get_drag_dir>:
    return obj->drag_dir;
   1b067:	8a 47 5b             	mov    0x5b(%rdi),%al
   1b06a:	c0 e8 02             	shr    $0x2,%al
   1b06d:	83 e0 07             	and    $0x7,%eax
}
   1b070:	c3                   	retq   

000000000001b071 <lv_obj_get_drag_throw>:
    return obj->drag_throw == 0 ? false : true;
   1b071:	8a 47 5a             	mov    0x5a(%rdi),%al
   1b074:	c0 e8 02             	shr    $0x2,%al
   1b077:	83 e0 01             	and    $0x1,%eax
}
   1b07a:	c3                   	retq   

000000000001b07b <lv_obj_get_drag_parent>:
    return obj->drag_parent == 0 ? false : true;
   1b07b:	8a 47 5a             	mov    0x5a(%rdi),%al
   1b07e:	c0 e8 03             	shr    $0x3,%al
   1b081:	83 e0 01             	and    $0x1,%eax
}
   1b084:	c3                   	retq   

000000000001b085 <lv_obj_get_gesture_parent>:
    return obj->gesture_parent == 0 ? false : true;
   1b085:	8a 47 5b             	mov    0x5b(%rdi),%al
   1b088:	83 e0 01             	and    $0x1,%eax
}
   1b08b:	c3                   	retq   

000000000001b08c <lv_obj_get_focus_parent>:
    return obj->focus_parent == 0 ? false : true;
   1b08c:	8a 47 5b             	mov    0x5b(%rdi),%al
   1b08f:	d0 e8                	shr    %al
   1b091:	83 e0 01             	and    $0x1,%eax
}
   1b094:	c3                   	retq   

000000000001b095 <lv_obj_get_base_dir>:
}
   1b095:	31 c0                	xor    %eax,%eax
   1b097:	c3                   	retq   

000000000001b098 <lv_obj_create>:
{
   1b098:	41 55                	push   %r13
   1b09a:	41 54                	push   %r12
   1b09c:	49 89 f4             	mov    %rsi,%r12
   1b09f:	55                   	push   %rbp
   1b0a0:	53                   	push   %rbx
   1b0a1:	48 89 fd             	mov    %rdi,%rbp
   1b0a4:	48 83 ec 08          	sub    $0x8,%rsp
    if(parent == NULL) {
   1b0a8:	48 85 ff             	test   %rdi,%rdi
   1b0ab:	0f 85 9d 00 00 00    	jne    1b14e <lv_obj_create+0xb6>
        lv_disp_t * disp = lv_disp_get_default();
   1b0b1:	e8 88 9f 00 00       	callq  2503e <lv_disp_get_default>
        if(!disp) {
   1b0b6:	48 85 c0             	test   %rax,%rax
   1b0b9:	75 26                	jne    1b0e1 <lv_obj_create+0x49>
            LV_LOG_WARN("lv_obj_create: not display created to so far. No place to assign the new screen");
   1b0bb:	4c 8d 05 d6 83 01 00 	lea    0x183d6(%rip),%r8        # 33498 <__func__.5785+0x2830>
   1b0c2:	48 8d 0d 07 5b 01 00 	lea    0x15b07(%rip),%rcx        # 30bd0 <__func__.5995>
   1b0c9:	48 8d 35 f4 82 01 00 	lea    0x182f4(%rip),%rsi        # 333c4 <__func__.5785+0x275c>
   1b0d0:	ba 0e 01 00 00       	mov    $0x10e,%edx
   1b0d5:	bf 02 00 00 00       	mov    $0x2,%edi
   1b0da:	e8 77 ae 00 00       	callq  25f56 <_lv_log_add>
   1b0df:	eb 11                	jmp    1b0f2 <lv_obj_create+0x5a>
        new_obj = _lv_ll_ins_head(&disp->scr_ll);
   1b0e1:	48 8d 78 68          	lea    0x68(%rax),%rdi
   1b0e5:	e8 dd aa 00 00       	callq  25bc7 <_lv_ll_ins_head>
        if(new_obj == NULL) return NULL;
   1b0ea:	48 85 c0             	test   %rax,%rax
        new_obj = _lv_ll_ins_head(&disp->scr_ll);
   1b0ed:	48 89 c3             	mov    %rax,%rbx
        if(new_obj == NULL) return NULL;
   1b0f0:	75 07                	jne    1b0f9 <lv_obj_create+0x61>
   1b0f2:	31 db                	xor    %ebx,%ebx
   1b0f4:	e9 7a 03 00 00       	jmpq   1b473 <lv_obj_create+0x3db>
        _lv_memset_00(new_obj, sizeof(lv_obj_t));
   1b0f9:	be 68 00 00 00       	mov    $0x68,%esi
   1b0fe:	48 89 c7             	mov    %rax,%rdi
   1b101:	e8 15 f4 ff ff       	callq  1a51b <_lv_memset_00>
        new_obj->signal_cb = lv_obj_signal;
   1b106:	48 8d 05 7a 21 00 00 	lea    0x217a(%rip),%rax        # 1d287 <lv_obj_signal>
        new_obj->base_dir     = LV_BIDI_DIR_LTR;
   1b10d:	80 63 5b 9f          	andb   $0x9f,0x5b(%rbx)
        new_obj->coords.x2    = lv_disp_get_hor_res(NULL) - 1;
   1b111:	31 ff                	xor    %edi,%edi
        new_obj->event_cb = NULL;
   1b113:	48 c7 43 28 00 00 00 	movq   $0x0,0x28(%rbx)
   1b11a:	00 
        new_obj->coords.x1    = 0;
   1b11b:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%rbx)
        new_obj->signal_cb = lv_obj_signal;
   1b122:	48 89 43 30          	mov    %rax,0x30(%rbx)
        new_obj->design_cb = lv_obj_design;
   1b126:	48 8d 05 57 13 00 00 	lea    0x1357(%rip),%rax        # 1c484 <lv_obj_design>
   1b12d:	48 89 43 38          	mov    %rax,0x38(%rbx)
        new_obj->coords.x2    = lv_disp_get_hor_res(NULL) - 1;
   1b131:	e8 10 9f 00 00       	callq  25046 <lv_disp_get_hor_res>
   1b136:	ff c8                	dec    %eax
        new_obj->coords.y2    = lv_disp_get_ver_res(NULL) - 1;
   1b138:	31 ff                	xor    %edi,%edi
        new_obj->coords.x2    = lv_disp_get_hor_res(NULL) - 1;
   1b13a:	66 89 43 24          	mov    %ax,0x24(%rbx)
        new_obj->coords.y2    = lv_disp_get_ver_res(NULL) - 1;
   1b13e:	e8 3c 9f 00 00       	callq  2507f <lv_disp_get_ver_res>
   1b143:	ff c8                	dec    %eax
   1b145:	66 89 43 26          	mov    %ax,0x26(%rbx)
   1b149:	e9 23 01 00 00       	jmpq   1b271 <lv_obj_create+0x1d9>
        new_obj = _lv_ll_ins_head(&parent->child_ll);
   1b14e:	48 8d 7f 08          	lea    0x8(%rdi),%rdi
   1b152:	e8 70 aa 00 00       	callq  25bc7 <_lv_ll_ins_head>
        if(new_obj == NULL) return NULL;
   1b157:	48 85 c0             	test   %rax,%rax
        new_obj = _lv_ll_ins_head(&parent->child_ll);
   1b15a:	48 89 c3             	mov    %rax,%rbx
        if(new_obj == NULL) return NULL;
   1b15d:	74 93                	je     1b0f2 <lv_obj_create+0x5a>
        _lv_memset_00(new_obj, sizeof(lv_obj_t));
   1b15f:	48 89 c7             	mov    %rax,%rdi
   1b162:	be 68 00 00 00       	mov    $0x68,%esi
   1b167:	e8 af f3 ff ff       	callq  1a51b <_lv_memset_00>
        new_obj->signal_cb = lv_obj_signal;
   1b16c:	48 8d 05 14 21 00 00 	lea    0x2114(%rip),%rax        # 1d287 <lv_obj_signal>
        new_obj->base_dir     = LV_BIDI_DIR_LTR;
   1b173:	80 63 5b 9f          	andb   $0x9f,0x5b(%rbx)
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
   1b177:	31 ff                	xor    %edi,%edi
        new_obj->parent = parent;
   1b179:	48 89 2b             	mov    %rbp,(%rbx)
        new_obj->event_cb = NULL;
   1b17c:	48 c7 43 28 00 00 00 	movq   $0x0,0x28(%rbx)
   1b183:	00 
        new_obj->signal_cb = lv_obj_signal;
   1b184:	48 89 43 30          	mov    %rax,0x30(%rbx)
        new_obj->design_cb = lv_obj_design;
   1b188:	48 8d 05 f5 12 00 00 	lea    0x12f5(%rip),%rax        # 1c484 <lv_obj_design>
   1b18f:	48 89 43 38          	mov    %rax,0x38(%rbx)
        new_obj->coords.y1    = parent->coords.y1;
   1b193:	66 8b 45 22          	mov    0x22(%rbp),%ax
   1b197:	66 89 43 22          	mov    %ax,0x22(%rbx)
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
   1b19b:	66 44 8b 6d 22       	mov    0x22(%rbp),%r13w
   1b1a0:	e8 13 9f 00 00       	callq  250b8 <lv_disp_get_dpi>
   1b1a5:	0f bf d0             	movswl %ax,%edx
   1b1a8:	b8 01 00 00 00       	mov    $0x1,%eax
   1b1ad:	6b d2 32             	imul   $0x32,%edx,%edx
   1b1b0:	83 c2 50             	add    $0x50,%edx
   1b1b3:	81 fa 3f 01 00 00    	cmp    $0x13f,%edx
   1b1b9:	7e 16                	jle    1b1d1 <lv_obj_create+0x139>
   1b1bb:	31 ff                	xor    %edi,%edi
   1b1bd:	e8 f6 9e 00 00       	callq  250b8 <lv_disp_get_dpi>
   1b1c2:	98                   	cwtl   
   1b1c3:	b9 a0 00 00 00       	mov    $0xa0,%ecx
   1b1c8:	6b c0 32             	imul   $0x32,%eax,%eax
   1b1cb:	83 c0 50             	add    $0x50,%eax
   1b1ce:	99                   	cltd   
   1b1cf:	f7 f9                	idiv   %ecx
   1b1d1:	44 01 e8             	add    %r13d,%eax
        if(lv_obj_get_base_dir(new_obj) == LV_BIDI_DIR_RTL) {
   1b1d4:	48 89 df             	mov    %rbx,%rdi
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
   1b1d7:	66 89 43 26          	mov    %ax,0x26(%rbx)
        if(lv_obj_get_base_dir(new_obj) == LV_BIDI_DIR_RTL) {
   1b1db:	e8 b5 fe ff ff       	callq  1b095 <lv_obj_get_base_dir>
   1b1e0:	fe c8                	dec    %al
   1b1e2:	75 48                	jne    1b22c <lv_obj_create+0x194>
            new_obj->coords.x2    = parent->coords.x2;
   1b1e4:	8b 45 24             	mov    0x24(%rbp),%eax
            new_obj->coords.x1    = parent->coords.x2 - LV_OBJ_DEF_WIDTH;
   1b1e7:	31 ff                	xor    %edi,%edi
            new_obj->coords.x2    = parent->coords.x2;
   1b1e9:	66 89 43 24          	mov    %ax,0x24(%rbx)
            new_obj->coords.x1    = parent->coords.x2 - LV_OBJ_DEF_WIDTH;
   1b1ed:	44 8b 6d 24          	mov    0x24(%rbp),%r13d
   1b1f1:	e8 c2 9e 00 00       	callq  250b8 <lv_disp_get_dpi>
   1b1f6:	0f bf d0             	movswl %ax,%edx
   1b1f9:	b8 01 00 00 00       	mov    $0x1,%eax
   1b1fe:	6b d2 64             	imul   $0x64,%edx,%edx
   1b201:	83 c2 50             	add    $0x50,%edx
   1b204:	81 fa 3f 01 00 00    	cmp    $0x13f,%edx
   1b20a:	7e 16                	jle    1b222 <lv_obj_create+0x18a>
   1b20c:	31 ff                	xor    %edi,%edi
   1b20e:	e8 a5 9e 00 00       	callq  250b8 <lv_disp_get_dpi>
   1b213:	98                   	cwtl   
   1b214:	b9 a0 00 00 00       	mov    $0xa0,%ecx
   1b219:	6b c0 64             	imul   $0x64,%eax,%eax
   1b21c:	83 c0 50             	add    $0x50,%eax
   1b21f:	99                   	cltd   
   1b220:	f7 f9                	idiv   %ecx
   1b222:	41 29 c5             	sub    %eax,%r13d
   1b225:	66 44 89 6b 20       	mov    %r13w,0x20(%rbx)
   1b22a:	eb 45                	jmp    1b271 <lv_obj_create+0x1d9>
            new_obj->coords.x1    = parent->coords.x1;
   1b22c:	8b 45 20             	mov    0x20(%rbp),%eax
            new_obj->coords.x2    = parent->coords.x1 + LV_OBJ_DEF_WIDTH;
   1b22f:	31 ff                	xor    %edi,%edi
            new_obj->coords.x1    = parent->coords.x1;
   1b231:	66 89 43 20          	mov    %ax,0x20(%rbx)
            new_obj->coords.x2    = parent->coords.x1 + LV_OBJ_DEF_WIDTH;
   1b235:	44 8b 6d 20          	mov    0x20(%rbp),%r13d
   1b239:	e8 7a 9e 00 00       	callq  250b8 <lv_disp_get_dpi>
   1b23e:	0f bf d0             	movswl %ax,%edx
   1b241:	b8 01 00 00 00       	mov    $0x1,%eax
   1b246:	6b d2 64             	imul   $0x64,%edx,%edx
   1b249:	83 c2 50             	add    $0x50,%edx
   1b24c:	81 fa 3f 01 00 00    	cmp    $0x13f,%edx
   1b252:	7e 16                	jle    1b26a <lv_obj_create+0x1d2>
   1b254:	31 ff                	xor    %edi,%edi
   1b256:	e8 5d 9e 00 00       	callq  250b8 <lv_disp_get_dpi>
   1b25b:	98                   	cwtl   
   1b25c:	b9 a0 00 00 00       	mov    $0xa0,%ecx
   1b261:	6b c0 64             	imul   $0x64,%eax,%eax
   1b264:	83 c0 50             	add    $0x50,%eax
   1b267:	99                   	cltd   
   1b268:	f7 f9                	idiv   %ecx
   1b26a:	44 01 e8             	add    %r13d,%eax
   1b26d:	66 89 43 24          	mov    %ax,0x24(%rbx)
    _lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
   1b271:	48 8d 7b 08          	lea    0x8(%rbx),%rdi
   1b275:	be 68 00 00 00       	mov    $0x68,%esi
    lv_style_list_init(&new_obj->style_list);
   1b27a:	4c 8d 6b 48          	lea    0x48(%rbx),%r13
    _lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
   1b27e:	e8 2b a9 00 00       	callq  25bae <_lv_ll_init>
    _lv_memset_00(&new_obj->user_data, sizeof(lv_obj_user_data_t));
   1b283:	48 8d 7b 60          	lea    0x60(%rbx),%rdi
   1b287:	be 08 00 00 00       	mov    $0x8,%esi
    new_obj->ext_draw_pad = 0;
   1b28c:	66 c7 43 58 00 00    	movw   $0x0,0x58(%rbx)
    _lv_memset_00(&new_obj->user_data, sizeof(lv_obj_user_data_t));
   1b292:	e8 84 f2 ff ff       	callq  1a51b <_lv_memset_00>
    new_obj->drag_dir     = LV_DRAG_DIR_BOTH;
   1b297:	8a 43 5b             	mov    0x5b(%rbx),%al
    new_obj->click        = 1;
   1b29a:	c6 43 5a 01          	movb   $0x1,0x5a(%rbx)
    lv_style_list_init(&new_obj->style_list);
   1b29e:	4c 89 ef             	mov    %r13,%rdi
    new_obj->protect      = LV_PROTECT_NONE;
   1b2a1:	66 c7 43 5c 00 00    	movw   $0x0,0x5c(%rbx)
    new_obj->ext_attr = NULL;
   1b2a7:	48 c7 43 40 00 00 00 	movq   $0x0,0x40(%rbx)
   1b2ae:	00 
    new_obj->drag_dir     = LV_DRAG_DIR_BOTH;
   1b2af:	83 e0 e2             	and    $0xffffffe2,%eax
    new_obj->gesture_parent = parent ? 1 : 0;
   1b2b2:	48 85 ed             	test   %rbp,%rbp
   1b2b5:	0f 95 c2             	setne  %dl
   1b2b8:	83 c8 0c             	or     $0xc,%eax
   1b2bb:	09 d0                	or     %edx,%eax
    new_obj->focus_parent  = 0;
   1b2bd:	83 e0 fd             	and    $0xfffffffd,%eax
   1b2c0:	88 43 5b             	mov    %al,0x5b(%rbx)
    lv_style_list_init(&new_obj->style_list);
   1b2c3:	e8 91 2f 00 00       	callq  1e259 <lv_style_list_init>
    if(copy == NULL) {
   1b2c8:	4d 85 e4             	test   %r12,%r12
   1b2cb:	75 29                	jne    1b2f6 <lv_obj_create+0x25e>
        if(parent != NULL) lv_theme_apply(new_obj, LV_THEME_OBJ);
   1b2cd:	48 85 ed             	test   %rbp,%rbp
   1b2d0:	74 12                	je     1b2e4 <lv_obj_create+0x24c>
   1b2d2:	be 02 00 00 00       	mov    $0x2,%esi
   1b2d7:	48 89 df             	mov    %rbx,%rdi
   1b2da:	e8 8a c2 00 00       	callq  27569 <lv_theme_apply>
   1b2df:	e9 53 01 00 00       	jmpq   1b437 <lv_obj_create+0x39f>
        else  lv_theme_apply(new_obj, LV_THEME_SCR);
   1b2e4:	be 01 00 00 00       	mov    $0x1,%esi
   1b2e9:	48 89 df             	mov    %rbx,%rdi
   1b2ec:	e8 78 c2 00 00       	callq  27569 <lv_theme_apply>
   1b2f1:	e9 57 01 00 00       	jmpq   1b44d <lv_obj_create+0x3b5>
        lv_style_list_copy(&new_obj->style_list, &copy->style_list);
   1b2f6:	49 8d 74 24 48       	lea    0x48(%r12),%rsi
   1b2fb:	4c 89 ef             	mov    %r13,%rdi
   1b2fe:	e8 cb 36 00 00       	callq  1e9ce <lv_style_list_copy>
        lv_area_copy(&new_obj->coords, &copy->coords);
   1b303:	49 8d 74 24 20       	lea    0x20(%r12),%rsi
   1b308:	48 8d 7b 20          	lea    0x20(%rbx),%rdi
   1b30c:	e8 75 f2 ff ff       	callq  1a586 <lv_area_copy>
        new_obj->ext_draw_pad = copy->ext_draw_pad;
   1b311:	41 8b 44 24 58       	mov    0x58(%r12),%eax
        new_obj->base_dir = copy->base_dir;
   1b316:	8a 53 5b             	mov    0x5b(%rbx),%dl
        if(lv_obj_get_parent(copy) != NULL && parent != NULL) {
   1b319:	4c 89 e7             	mov    %r12,%rdi
        new_obj->ext_draw_pad = copy->ext_draw_pad;
   1b31c:	66 89 43 58          	mov    %ax,0x58(%rbx)
   1b320:	49 8b 44 24 60       	mov    0x60(%r12),%rax
        new_obj->base_dir = copy->base_dir;
   1b325:	83 e2 9f             	and    $0xffffff9f,%edx
   1b328:	48 89 43 60          	mov    %rax,0x60(%rbx)
   1b32c:	41 8a 44 24 5b       	mov    0x5b(%r12),%al
   1b331:	83 e0 60             	and    $0x60,%eax
   1b334:	09 c2                	or     %eax,%edx
   1b336:	88 53 5b             	mov    %dl,0x5b(%rbx)
        new_obj->event_cb = copy->event_cb;
   1b339:	49 8b 44 24 28       	mov    0x28(%r12),%rax
        new_obj->drag_dir     = copy->drag_dir;
   1b33e:	83 e2 e3             	and    $0xffffffe3,%edx
        new_obj->adv_hittest  = copy->adv_hittest;
   1b341:	41 8a 4c 24 5a       	mov    0x5a(%r12),%cl
        new_obj->event_cb = copy->event_cb;
   1b346:	48 89 43 28          	mov    %rax,0x28(%rbx)
        new_obj->adv_hittest  = copy->adv_hittest;
   1b34a:	8a 43 5a             	mov    0x5a(%rbx),%al
   1b34d:	83 e1 80             	and    $0xffffff80,%ecx
   1b350:	83 e0 7f             	and    $0x7f,%eax
   1b353:	09 c8                	or     %ecx,%eax
   1b355:	88 43 5a             	mov    %al,0x5a(%rbx)
        new_obj->click        = copy->click;
   1b358:	41 8a 4c 24 5a       	mov    0x5a(%r12),%cl
   1b35d:	83 e0 fe             	and    $0xfffffffe,%eax
   1b360:	83 e1 01             	and    $0x1,%ecx
   1b363:	09 c8                	or     %ecx,%eax
   1b365:	88 43 5a             	mov    %al,0x5a(%rbx)
        new_obj->drag         = copy->drag;
   1b368:	41 8a 4c 24 5a       	mov    0x5a(%r12),%cl
   1b36d:	83 e0 fd             	and    $0xfffffffd,%eax
   1b370:	83 e1 02             	and    $0x2,%ecx
   1b373:	09 c8                	or     %ecx,%eax
   1b375:	88 43 5a             	mov    %al,0x5a(%rbx)
        new_obj->drag_dir     = copy->drag_dir;
   1b378:	41 8a 4c 24 5b       	mov    0x5b(%r12),%cl
        new_obj->drag_throw   = copy->drag_throw;
   1b37d:	83 e0 fb             	and    $0xfffffffb,%eax
        new_obj->drag_dir     = copy->drag_dir;
   1b380:	83 e1 1c             	and    $0x1c,%ecx
   1b383:	09 ca                	or     %ecx,%edx
   1b385:	88 53 5b             	mov    %dl,0x5b(%rbx)
        new_obj->drag_throw   = copy->drag_throw;
   1b388:	41 8a 4c 24 5a       	mov    0x5a(%r12),%cl
   1b38d:	83 e1 04             	and    $0x4,%ecx
   1b390:	09 c8                	or     %ecx,%eax
   1b392:	88 43 5a             	mov    %al,0x5a(%rbx)
        new_obj->drag_parent  = copy->drag_parent;
   1b395:	41 8a 4c 24 5a       	mov    0x5a(%r12),%cl
   1b39a:	83 e0 f7             	and    $0xfffffff7,%eax
   1b39d:	83 e1 08             	and    $0x8,%ecx
   1b3a0:	09 c8                	or     %ecx,%eax
   1b3a2:	88 43 5a             	mov    %al,0x5a(%rbx)
        new_obj->hidden       = copy->hidden;
   1b3a5:	41 8a 4c 24 5a       	mov    0x5a(%r12),%cl
   1b3aa:	83 e0 ef             	and    $0xffffffef,%eax
   1b3ad:	83 e1 10             	and    $0x10,%ecx
   1b3b0:	09 c8                	or     %ecx,%eax
   1b3b2:	88 43 5a             	mov    %al,0x5a(%rbx)
        new_obj->top          = copy->top;
   1b3b5:	41 8a 4c 24 5a       	mov    0x5a(%r12),%cl
   1b3ba:	83 e0 df             	and    $0xffffffdf,%eax
   1b3bd:	83 e1 20             	and    $0x20,%ecx
   1b3c0:	09 c8                	or     %ecx,%eax
   1b3c2:	88 43 5a             	mov    %al,0x5a(%rbx)
        new_obj->parent_event = copy->parent_event;
   1b3c5:	41 8a 4c 24 5a       	mov    0x5a(%r12),%cl
   1b3ca:	83 e0 bf             	and    $0xffffffbf,%eax
   1b3cd:	83 e1 40             	and    $0x40,%ecx
   1b3d0:	09 c8                	or     %ecx,%eax
   1b3d2:	88 43 5a             	mov    %al,0x5a(%rbx)
        new_obj->protect      = copy->protect;
   1b3d5:	41 8a 44 24 5c       	mov    0x5c(%r12),%al
   1b3da:	88 43 5c             	mov    %al,0x5c(%rbx)
        new_obj->gesture_parent = copy->gesture_parent;
   1b3dd:	41 8a 4c 24 5b       	mov    0x5b(%r12),%cl
   1b3e2:	88 d0                	mov    %dl,%al
   1b3e4:	83 e1 01             	and    $0x1,%ecx
   1b3e7:	83 e0 fe             	and    $0xfffffffe,%eax
   1b3ea:	09 c8                	or     %ecx,%eax
   1b3ec:	88 43 5b             	mov    %al,0x5b(%rbx)
        new_obj->focus_parent = copy->focus_parent;
   1b3ef:	41 8a 54 24 5b       	mov    0x5b(%r12),%dl
   1b3f4:	83 e0 fd             	and    $0xfffffffd,%eax
   1b3f7:	83 e2 02             	and    $0x2,%edx
   1b3fa:	09 d0                	or     %edx,%eax
   1b3fc:	88 43 5b             	mov    %al,0x5b(%rbx)
        if(lv_obj_get_parent(copy) != NULL && parent != NULL) {
   1b3ff:	e8 1b f4 ff ff       	callq  1a81f <lv_obj_get_parent>
   1b404:	48 85 c0             	test   %rax,%rax
   1b407:	74 29                	je     1b432 <lv_obj_create+0x39a>
   1b409:	48 85 ed             	test   %rbp,%rbp
   1b40c:	74 3f                	je     1b44d <lv_obj_create+0x3b5>
            lv_obj_set_pos(new_obj, lv_obj_get_x(copy), lv_obj_get_y(copy));
   1b40e:	4c 89 e7             	mov    %r12,%rdi
   1b411:	e8 c4 f5 ff ff       	callq  1a9da <lv_obj_get_y>
   1b416:	4c 89 e7             	mov    %r12,%rdi
   1b419:	41 89 c5             	mov    %eax,%r13d
   1b41c:	e8 a0 f5 ff ff       	callq  1a9c1 <lv_obj_get_x>
   1b421:	41 0f bf d5          	movswl %r13w,%edx
   1b425:	0f bf f0             	movswl %ax,%esi
   1b428:	48 89 df             	mov    %rbx,%rdi
   1b42b:	e8 b7 f9 ff ff       	callq  1ade7 <lv_obj_set_pos>
   1b430:	eb 05                	jmp    1b437 <lv_obj_create+0x39f>
    if(parent != NULL) {
   1b432:	48 85 ed             	test   %rbp,%rbp
   1b435:	74 16                	je     1b44d <lv_obj_create+0x3b5>
        parent->signal_cb(parent, LV_SIGNAL_CHILD_CHG, new_obj);
   1b437:	48 89 ef             	mov    %rbp,%rdi
   1b43a:	48 89 da             	mov    %rbx,%rdx
   1b43d:	be 01 00 00 00       	mov    $0x1,%esi
   1b442:	ff 55 30             	callq  *0x30(%rbp)
        lv_obj_invalidate(new_obj);
   1b445:	48 89 df             	mov    %rbx,%rdi
   1b448:	e8 65 f8 ff ff       	callq  1acb2 <lv_obj_invalidate>
    LV_LOG_INFO("Object create ready");
   1b44d:	4c 8d 05 94 80 01 00 	lea    0x18094(%rip),%r8        # 334e8 <__func__.5785+0x2880>
   1b454:	48 8d 0d 75 57 01 00 	lea    0x15775(%rip),%rcx        # 30bd0 <__func__.5995>
   1b45b:	48 8d 35 62 7f 01 00 	lea    0x17f62(%rip),%rsi        # 333c4 <__func__.5785+0x275c>
   1b462:	ba ca 01 00 00       	mov    $0x1ca,%edx
   1b467:	bf 01 00 00 00       	mov    $0x1,%edi
   1b46c:	31 c0                	xor    %eax,%eax
   1b46e:	e8 e3 aa 00 00       	callq  25f56 <_lv_log_add>
}
   1b473:	5a                   	pop    %rdx
   1b474:	48 89 d8             	mov    %rbx,%rax
   1b477:	5b                   	pop    %rbx
   1b478:	5d                   	pop    %rbp
   1b479:	41 5c                	pop    %r12
   1b47b:	41 5d                	pop    %r13
   1b47d:	c3                   	retq   

000000000001b47e <lv_obj_set_size>:
{
   1b47e:	41 55                	push   %r13
   1b480:	41 54                	push   %r12
   1b482:	41 89 d5             	mov    %edx,%r13d
   1b485:	55                   	push   %rbp
   1b486:	53                   	push   %rbx
   1b487:	89 f5                	mov    %esi,%ebp
   1b489:	48 89 fb             	mov    %rdi,%rbx
   1b48c:	48 83 ec 18          	sub    $0x18,%rsp
   1b490:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1b497:	00 00 
   1b499:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   1b49e:	31 c0                	xor    %eax,%eax
    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) {
   1b4a0:	e8 50 f5 ff ff       	callq  1a9f5 <lv_obj_get_width>
   1b4a5:	66 39 e8             	cmp    %bp,%ax
   1b4a8:	74 3f                	je     1b4e9 <lv_obj_set_size+0x6b>
    lv_obj_invalidate(obj);
   1b4aa:	48 89 df             	mov    %rbx,%rdi
    lv_obj_get_coords(obj, &ori);
   1b4ad:	49 89 e4             	mov    %rsp,%r12
    lv_obj_invalidate(obj);
   1b4b0:	e8 fd f7 ff ff       	callq  1acb2 <lv_obj_invalidate>
    lv_obj_get_coords(obj, &ori);
   1b4b5:	4c 89 e6             	mov    %r12,%rsi
   1b4b8:	48 89 df             	mov    %rbx,%rdi
   1b4bb:	e8 f2 f4 ff ff       	callq  1a9b2 <lv_obj_get_coords>
    obj->coords.y2 = obj->coords.y1 + h - 1;
   1b4c0:	66 8b 53 22          	mov    0x22(%rbx),%dx
    if(lv_obj_get_base_dir(obj) == LV_BIDI_DIR_RTL) {
   1b4c4:	48 89 df             	mov    %rbx,%rdi
    obj->coords.y2 = obj->coords.y1 + h - 1;
   1b4c7:	42 8d 54 2a ff       	lea    -0x1(%rdx,%r13,1),%edx
   1b4cc:	66 89 53 26          	mov    %dx,0x26(%rbx)
    if(lv_obj_get_base_dir(obj) == LV_BIDI_DIR_RTL) {
   1b4d0:	e8 c0 fb ff ff       	callq  1b095 <lv_obj_get_base_dir>
   1b4d5:	fe c8                	dec    %al
   1b4d7:	75 20                	jne    1b4f9 <lv_obj_set_size+0x7b>
        obj->coords.x1 = obj->coords.x2 - w + 1;
   1b4d9:	b8 01 00 00 00       	mov    $0x1,%eax
   1b4de:	29 e8                	sub    %ebp,%eax
   1b4e0:	03 43 24             	add    0x24(%rbx),%eax
   1b4e3:	66 89 43 20          	mov    %ax,0x20(%rbx)
   1b4e7:	eb 1b                	jmp    1b504 <lv_obj_set_size+0x86>
    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) {
   1b4e9:	48 89 df             	mov    %rbx,%rdi
   1b4ec:	e8 0f f5 ff ff       	callq  1aa00 <lv_obj_get_height>
   1b4f1:	66 44 39 e8          	cmp    %r13w,%ax
   1b4f5:	75 b3                	jne    1b4aa <lv_obj_set_size+0x2c>
   1b4f7:	eb 6b                	jmp    1b564 <lv_obj_set_size+0xe6>
        obj->coords.x2 = obj->coords.x1 + w - 1;
   1b4f9:	8b 73 20             	mov    0x20(%rbx),%esi
   1b4fc:	8d 74 2e ff          	lea    -0x1(%rsi,%rbp,1),%esi
   1b500:	66 89 73 24          	mov    %si,0x24(%rbx)
    obj->signal_cb(obj, LV_SIGNAL_COORD_CHG, &ori);
   1b504:	4c 89 e2             	mov    %r12,%rdx
   1b507:	be 02 00 00 00       	mov    $0x2,%esi
   1b50c:	48 89 df             	mov    %rbx,%rdi
   1b50f:	ff 53 30             	callq  *0x30(%rbx)
    lv_obj_t * par = lv_obj_get_parent(obj);
   1b512:	48 89 df             	mov    %rbx,%rdi
   1b515:	e8 05 f3 ff ff       	callq  1a81f <lv_obj_get_parent>
    if(par != NULL) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
   1b51a:	48 85 c0             	test   %rax,%rax
   1b51d:	74 0e                	je     1b52d <lv_obj_set_size+0xaf>
   1b51f:	48 89 da             	mov    %rbx,%rdx
   1b522:	be 01 00 00 00       	mov    $0x1,%esi
   1b527:	48 89 c7             	mov    %rax,%rdi
   1b52a:	ff 50 30             	callq  *0x30(%rax)
    _LV_LL_READ(obj->child_ll, i) {
   1b52d:	4c 8d 6b 08          	lea    0x8(%rbx),%r13
   1b531:	4c 89 ef             	mov    %r13,%rdi
   1b534:	e8 32 a7 00 00       	callq  25c6b <_lv_ll_get_head>
   1b539:	48 85 c0             	test   %rax,%rax
   1b53c:	48 89 c5             	mov    %rax,%rbp
   1b53f:	74 1b                	je     1b55c <lv_obj_set_size+0xde>
        i->signal_cb(i, LV_SIGNAL_PARENT_SIZE_CHG,  &ori);
   1b541:	48 89 ef             	mov    %rbp,%rdi
   1b544:	4c 89 e2             	mov    %r12,%rdx
   1b547:	be 03 00 00 00       	mov    $0x3,%esi
   1b54c:	ff 55 30             	callq  *0x30(%rbp)
    _LV_LL_READ(obj->child_ll, i) {
   1b54f:	48 89 ee             	mov    %rbp,%rsi
   1b552:	4c 89 ef             	mov    %r13,%rdi
   1b555:	e8 29 a7 00 00       	callq  25c83 <_lv_ll_get_next>
   1b55a:	eb dd                	jmp    1b539 <lv_obj_set_size+0xbb>
    lv_obj_invalidate(obj);
   1b55c:	48 89 df             	mov    %rbx,%rdi
   1b55f:	e8 4e f7 ff ff       	callq  1acb2 <lv_obj_invalidate>
}
   1b564:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   1b569:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1b570:	00 00 
   1b572:	74 05                	je     1b579 <lv_obj_set_size+0xfb>
   1b574:	e8 c7 90 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1b579:	48 83 c4 18          	add    $0x18,%rsp
   1b57d:	5b                   	pop    %rbx
   1b57e:	5d                   	pop    %rbp
   1b57f:	41 5c                	pop    %r12
   1b581:	41 5d                	pop    %r13
   1b583:	c3                   	retq   

000000000001b584 <lv_obj_set_width>:
{
   1b584:	55                   	push   %rbp
   1b585:	53                   	push   %rbx
   1b586:	48 89 fd             	mov    %rdi,%rbp
   1b589:	89 f3                	mov    %esi,%ebx
   1b58b:	48 83 ec 08          	sub    $0x8,%rsp
    lv_obj_set_size(obj, w, lv_obj_get_height(obj));
   1b58f:	e8 6c f4 ff ff       	callq  1aa00 <lv_obj_get_height>
   1b594:	0f bf f3             	movswl %bx,%esi
   1b597:	0f bf d0             	movswl %ax,%edx
   1b59a:	48 89 ef             	mov    %rbp,%rdi
}
   1b59d:	58                   	pop    %rax
   1b59e:	5b                   	pop    %rbx
   1b59f:	5d                   	pop    %rbp
    lv_obj_set_size(obj, w, lv_obj_get_height(obj));
   1b5a0:	e9 d9 fe ff ff       	jmpq   1b47e <lv_obj_set_size>

000000000001b5a5 <lv_obj_set_height>:
{
   1b5a5:	55                   	push   %rbp
   1b5a6:	53                   	push   %rbx
   1b5a7:	48 89 fd             	mov    %rdi,%rbp
   1b5aa:	89 f3                	mov    %esi,%ebx
   1b5ac:	48 83 ec 08          	sub    $0x8,%rsp
    lv_obj_set_size(obj, lv_obj_get_width(obj), h);
   1b5b0:	e8 40 f4 ff ff       	callq  1a9f5 <lv_obj_get_width>
   1b5b5:	0f bf d3             	movswl %bx,%edx
   1b5b8:	0f bf f0             	movswl %ax,%esi
   1b5bb:	48 89 ef             	mov    %rbp,%rdi
}
   1b5be:	58                   	pop    %rax
   1b5bf:	5b                   	pop    %rbx
   1b5c0:	5d                   	pop    %rbp
    lv_obj_set_size(obj, lv_obj_get_width(obj), h);
   1b5c1:	e9 b8 fe ff ff       	jmpq   1b47e <lv_obj_set_size>

000000000001b5c6 <lv_obj_is_protected>:
    return (obj->protect & prot) == 0 ? false : true;
   1b5c6:	40 84 77 5c          	test   %sil,0x5c(%rdi)
   1b5ca:	0f 95 c0             	setne  %al
}
   1b5cd:	c3                   	retq   

000000000001b5ce <lv_obj_get_state>:
{
   1b5ce:	48 83 ec 18          	sub    $0x18,%rsp
   1b5d2:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1b5d9:	00 00 
   1b5db:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   1b5e0:	31 c0                	xor    %eax,%eax
    if(part < _LV_OBJ_PART_REAL_LAST) return ((lv_obj_t *)obj)->state;
   1b5e2:	40 80 fe 3f          	cmp    $0x3f,%sil
   1b5e6:	77 05                	ja     1b5ed <lv_obj_get_state+0x1f>
   1b5e8:	8a 47 5d             	mov    0x5d(%rdi),%al
   1b5eb:	eb 1d                	jmp    1b60a <lv_obj_get_state+0x3c>
    lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STATE_DSC, &info);
   1b5ed:	48 8d 54 24 06       	lea    0x6(%rsp),%rdx
    info.part = part;
   1b5f2:	40 88 74 24 06       	mov    %sil,0x6(%rsp)
    lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STATE_DSC, &info);
   1b5f7:	be 09 00 00 00       	mov    $0x9,%esi
    info.result = LV_STATE_DEFAULT;
   1b5fc:	c6 44 24 07 00       	movb   $0x0,0x7(%rsp)
    lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STATE_DSC, &info);
   1b601:	e8 cf f1 ff ff       	callq  1a7d5 <lv_signal_send>
    return info.result;
   1b606:	8a 44 24 07          	mov    0x7(%rsp),%al
}
   1b60a:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
   1b60f:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1b616:	00 00 
   1b618:	74 05                	je     1b61f <lv_obj_get_state+0x51>
   1b61a:	e8 21 90 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1b61f:	48 83 c4 18          	add    $0x18,%rsp
   1b623:	c3                   	retq   

000000000001b624 <_lv_obj_get_style_color>:
{
   1b624:	41 57                	push   %r15
   1b626:	41 56                	push   %r14
   1b628:	41 55                	push   %r13
   1b62a:	41 54                	push   %r12
   1b62c:	41 89 d5             	mov    %edx,%r13d
   1b62f:	55                   	push   %rbp
   1b630:	53                   	push   %rbx
   1b631:	48 89 fd             	mov    %rdi,%rbp
   1b634:	41 88 f4             	mov    %sil,%r12b
    while(parent) {
   1b637:	89 d3                	mov    %edx,%ebx
{
   1b639:	48 83 ec 28          	sub    $0x28,%rsp
   1b63d:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1b644:	00 00 
   1b646:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1b64b:	31 c0                	xor    %eax,%eax
    attr = prop_ori >> 8;
   1b64d:	89 d0                	mov    %edx,%eax
        res = _lv_style_list_get_color(list, prop, &value_act);
   1b64f:	4c 8d 74 24 14       	lea    0x14(%rsp),%r14
    attr = prop_ori >> 8;
   1b654:	66 c1 e8 08          	shr    $0x8,%ax
   1b658:	66 89 44 24 0e       	mov    %ax,0xe(%rsp)
    while(parent) {
   1b65d:	48 85 ed             	test   %rbp,%rbp
   1b660:	74 56                	je     1b6b8 <_lv_obj_get_style_color+0x94>
        lv_style_list_t * list = lv_obj_get_style_list(parent, part);
   1b662:	41 0f b6 dc          	movzbl %r12b,%ebx
   1b666:	48 89 ef             	mov    %rbp,%rdi
   1b669:	89 de                	mov    %ebx,%esi
   1b66b:	e8 9e f3 ff ff       	callq  1aa0e <lv_obj_get_style_list>
        lv_state_t state = lv_obj_get_state(parent, part);
   1b670:	89 de                	mov    %ebx,%esi
   1b672:	48 89 ef             	mov    %rbp,%rdi
        lv_style_list_t * list = lv_obj_get_style_list(parent, part);
   1b675:	49 89 c7             	mov    %rax,%r15
        lv_state_t state = lv_obj_get_state(parent, part);
   1b678:	e8 51 ff ff ff       	callq  1b5ce <lv_obj_get_state>
        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);
   1b67d:	c1 e0 08             	shl    $0x8,%eax
        res = _lv_style_list_get_color(list, prop, &value_act);
   1b680:	4c 89 f2             	mov    %r14,%rdx
   1b683:	4c 89 ff             	mov    %r15,%rdi
        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);
   1b686:	42 8d 1c 28          	lea    (%rax,%r13,1),%ebx
        res = _lv_style_list_get_color(list, prop, &value_act);
   1b68a:	0f b7 f3             	movzwl %bx,%esi
   1b68d:	e8 7d 35 00 00       	callq  1ec0f <_lv_style_list_get_color>
        if(res == LV_RES_OK) return value_act;
   1b692:	fe c8                	dec    %al
   1b694:	75 06                	jne    1b69c <_lv_obj_get_style_color+0x78>
   1b696:	8b 44 24 14          	mov    0x14(%rsp),%eax
   1b69a:	eb 2d                	jmp    1b6c9 <_lv_obj_get_style_color+0xa5>
        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;
   1b69c:	80 7c 24 0e 00       	cmpb   $0x0,0xe(%rsp)
   1b6a1:	79 15                	jns    1b6b8 <_lv_obj_get_style_color+0x94>
        if(part != LV_OBJ_PART_MAIN) {
   1b6a3:	45 84 e4             	test   %r12b,%r12b
   1b6a6:	75 0b                	jne    1b6b3 <_lv_obj_get_style_color+0x8f>
        parent = lv_obj_get_parent(parent);
   1b6a8:	48 89 ef             	mov    %rbp,%rdi
   1b6ab:	e8 6f f1 ff ff       	callq  1a81f <lv_obj_get_parent>
   1b6b0:	48 89 c5             	mov    %rax,%rbp
   1b6b3:	45 31 e4             	xor    %r12d,%r12d
   1b6b6:	eb a5                	jmp    1b65d <_lv_obj_get_style_color+0x39>
    prop = prop & (~LV_STYLE_STATE_MASK);
   1b6b8:	80 e7 80             	and    $0x80,%bh
    switch(prop) {
   1b6bb:	83 eb 29             	sub    $0x29,%ebx
            return LV_COLOR_WHITE;
   1b6be:	66 83 fb 02          	cmp    $0x2,%bx
   1b6c2:	19 c0                	sbb    %eax,%eax
   1b6c4:	0d 00 00 00 ff       	or     $0xff000000,%eax
}
   1b6c9:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   1b6ce:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1b6d5:	00 00 
   1b6d7:	74 05                	je     1b6de <_lv_obj_get_style_color+0xba>
   1b6d9:	e8 62 8f fe ff       	callq  4640 <__stack_chk_fail@plt>
   1b6de:	48 83 c4 28          	add    $0x28,%rsp
   1b6e2:	5b                   	pop    %rbx
   1b6e3:	5d                   	pop    %rbp
   1b6e4:	41 5c                	pop    %r12
   1b6e6:	41 5d                	pop    %r13
   1b6e8:	41 5e                	pop    %r14
   1b6ea:	41 5f                	pop    %r15
   1b6ec:	c3                   	retq   

000000000001b6ed <_lv_obj_get_style_int>:
{
   1b6ed:	41 57                	push   %r15
   1b6ef:	41 56                	push   %r14
   1b6f1:	41 55                	push   %r13
   1b6f3:	41 54                	push   %r12
   1b6f5:	41 88 f4             	mov    %sil,%r12b
   1b6f8:	55                   	push   %rbp
   1b6f9:	53                   	push   %rbx
   1b6fa:	48 89 fd             	mov    %rdi,%rbp
    while(parent) {
   1b6fd:	89 d3                	mov    %edx,%ebx
{
   1b6ff:	48 83 ec 28          	sub    $0x28,%rsp
   1b703:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1b70a:	00 00 
   1b70c:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1b711:	31 c0                	xor    %eax,%eax
    attr = prop_ori >> 8;
   1b713:	89 d0                	mov    %edx,%eax
        res = _lv_style_list_get_int(list, prop, &value_act);
   1b715:	4c 8d 7c 24 16       	lea    0x16(%rsp),%r15
{
   1b71a:	66 89 54 24 0e       	mov    %dx,0xe(%rsp)
    attr = prop_ori >> 8;
   1b71f:	66 c1 e8 08          	shr    $0x8,%ax
   1b723:	66 89 44 24 0c       	mov    %ax,0xc(%rsp)
    while(parent) {
   1b728:	48 85 ed             	test   %rbp,%rbp
   1b72b:	0f 84 ad 01 00 00    	je     1b8de <_lv_obj_get_style_int+0x1f1>
        lv_style_list_t * list = lv_obj_get_style_list(parent, part);
   1b731:	45 0f b6 ec          	movzbl %r12b,%r13d
   1b735:	48 89 ef             	mov    %rbp,%rdi
   1b738:	44 89 ee             	mov    %r13d,%esi
   1b73b:	e8 ce f2 ff ff       	callq  1aa0e <lv_obj_get_style_list>
   1b740:	49 89 c6             	mov    %rax,%r14
        if(!list->ignore_cache && list->style_cnt > 0) {
   1b743:	8a 40 09             	mov    0x9(%rax),%al
   1b746:	a8 08                	test   $0x8,%al
   1b748:	0f 85 42 01 00 00    	jne    1b890 <_lv_obj_get_style_int+0x1a3>
   1b74e:	41 f6 46 08 3f       	testb  $0x3f,0x8(%r14)
   1b753:	0f 84 37 01 00 00    	je     1b890 <_lv_obj_get_style_int+0x1a3>
            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));
   1b759:	a8 04                	test   $0x4,%al
   1b75b:	75 13                	jne    1b770 <_lv_obj_get_style_int+0x83>
   1b75d:	89 da                	mov    %ebx,%edx
   1b75f:	44 89 ee             	mov    %r13d,%esi
   1b762:	48 89 ef             	mov    %rbp,%rdi
   1b765:	81 e2 ff 80 00 00    	and    $0x80ff,%edx
   1b76b:	e8 24 02 00 00       	callq  1b994 <update_style_cache>
            switch(prop  & (~LV_STYLE_STATE_MASK)) {
   1b770:	89 d8                	mov    %ebx,%eax
   1b772:	25 ff 80 00 00       	and    $0x80ff,%eax
   1b777:	83 f8 33             	cmp    $0x33,%eax
   1b77a:	0f 84 e4 00 00 00    	je     1b864 <_lv_obj_get_style_int+0x177>
   1b780:	0f 8f 80 00 00 00    	jg     1b806 <_lv_obj_get_style_int+0x119>
   1b786:	83 f8 13             	cmp    $0x13,%eax
   1b789:	7f 3c                	jg     1b7c7 <_lv_obj_get_style_int+0xda>
   1b78b:	83 f8 10             	cmp    $0x10,%eax
   1b78e:	0f 8d e7 00 00 00    	jge    1b87b <_lv_obj_get_style_int+0x18e>
   1b794:	83 f8 02             	cmp    $0x2,%eax
   1b797:	0f 84 b2 00 00 00    	je     1b84f <_lv_obj_get_style_int+0x162>
   1b79d:	7f 12                	jg     1b7b1 <_lv_obj_get_style_int+0xc4>
   1b79f:	ff c8                	dec    %eax
   1b7a1:	0f 85 e9 00 00 00    	jne    1b890 <_lv_obj_get_style_int+0x1a3>
                    if(list->radius_zero) def = true;
   1b7a7:	41 f6 46 09 10       	testb  $0x10,0x9(%r14)
   1b7ac:	e9 dd 00 00 00       	jmpq   1b88e <_lv_obj_get_style_int+0x1a1>
            switch(prop  & (~LV_STYLE_STATE_MASK)) {
   1b7b1:	83 e8 04             	sub    $0x4,%eax
   1b7b4:	83 f8 03             	cmp    $0x3,%eax
   1b7b7:	0f 87 d3 00 00 00    	ja     1b890 <_lv_obj_get_style_int+0x1a3>
                    if(list->transform_all_zero) def = true;
   1b7bd:	41 80 7e 09 00       	cmpb   $0x0,0x9(%r14)
   1b7c2:	e9 a2 00 00 00       	jmpq   1b869 <_lv_obj_get_style_int+0x17c>
            switch(prop  & (~LV_STYLE_STATE_MASK)) {
   1b7c7:	83 f8 20             	cmp    $0x20,%eax
   1b7ca:	0f 84 b2 00 00 00    	je     1b882 <_lv_obj_get_style_int+0x195>
   1b7d0:	7f 16                	jg     1b7e8 <_lv_obj_get_style_int+0xfb>
   1b7d2:	83 e8 15             	sub    $0x15,%eax
   1b7d5:	83 f8 03             	cmp    $0x3,%eax
   1b7d8:	0f 87 b2 00 00 00    	ja     1b890 <_lv_obj_get_style_int+0x1a3>
                    if(list->margin_all_zero) def = true;
   1b7de:	41 f6 46 0a 02       	testb  $0x2,0xa(%r14)
   1b7e3:	e9 a6 00 00 00       	jmpq   1b88e <_lv_obj_get_style_int+0x1a1>
            switch(prop  & (~LV_STYLE_STATE_MASK)) {
   1b7e8:	83 f8 31             	cmp    $0x31,%eax
   1b7eb:	74 70                	je     1b85d <_lv_obj_get_style_int+0x170>
   1b7ed:	0f 8f 8f 00 00 00    	jg     1b882 <_lv_obj_get_style_int+0x195>
   1b7f3:	83 f8 30             	cmp    $0x30,%eax
   1b7f6:	0f 85 94 00 00 00    	jne    1b890 <_lv_obj_get_style_int+0x1a3>
                    if(list->border_width_zero) def = true;
   1b7fc:	41 f6 46 0a 20       	testb  $0x20,0xa(%r14)
   1b801:	e9 88 00 00 00       	jmpq   1b88e <_lv_obj_get_style_int+0x1a1>
            switch(prop  & (~LV_STYLE_STATE_MASK)) {
   1b806:	83 f8 72             	cmp    $0x72,%eax
   1b809:	74 77                	je     1b882 <_lv_obj_get_style_int+0x195>
   1b80b:	7f 1b                	jg     1b828 <_lv_obj_get_style_int+0x13b>
   1b80d:	83 f8 50             	cmp    $0x50,%eax
   1b810:	74 62                	je     1b874 <_lv_obj_get_style_int+0x187>
   1b812:	7f 0a                	jg     1b81e <_lv_obj_get_style_int+0x131>
   1b814:	83 f8 40             	cmp    $0x40,%eax
   1b817:	74 54                	je     1b86d <_lv_obj_get_style_int+0x180>
   1b819:	83 f8 42             	cmp    $0x42,%eax
   1b81c:	eb 2d                	jmp    1b84b <_lv_obj_get_style_int+0x15e>
   1b81e:	83 f8 54             	cmp    $0x54,%eax
   1b821:	74 5f                	je     1b882 <_lv_obj_get_style_int+0x195>
   1b823:	83 f8 60             	cmp    $0x60,%eax
   1b826:	eb 23                	jmp    1b84b <_lv_obj_get_style_int+0x15e>
   1b828:	3d 81 80 00 00       	cmp    $0x8081,%eax
   1b82d:	7f 0e                	jg     1b83d <_lv_obj_get_style_int+0x150>
   1b82f:	3d 80 80 00 00       	cmp    $0x8080,%eax
   1b834:	7d 20                	jge    1b856 <_lv_obj_get_style_int+0x169>
   1b836:	3d 91 00 00 00       	cmp    $0x91,%eax
   1b83b:	eb 0e                	jmp    1b84b <_lv_obj_get_style_int+0x15e>
   1b83d:	3d 83 80 00 00       	cmp    $0x8083,%eax
   1b842:	74 3e                	je     1b882 <_lv_obj_get_style_int+0x195>
   1b844:	7c 43                	jl     1b889 <_lv_obj_get_style_int+0x19c>
   1b846:	3d a0 80 00 00       	cmp    $0x80a0,%eax
   1b84b:	75 43                	jne    1b890 <_lv_obj_get_style_int+0x1a3>
   1b84d:	eb 33                	jmp    1b882 <_lv_obj_get_style_int+0x195>
                    if(list->clip_corner_off) def = true;
   1b84f:	41 f6 46 09 40       	testb  $0x40,0x9(%r14)
   1b854:	eb 38                	jmp    1b88e <_lv_obj_get_style_int+0x1a1>
                    if(list->text_space_zero) def = true;
   1b856:	41 f6 46 0b 20       	testb  $0x20,0xb(%r14)
   1b85b:	eb 31                	jmp    1b88e <_lv_obj_get_style_int+0x1a1>
                    if(list->border_side_full) def = true;
   1b85d:	41 f6 46 0a 40       	testb  $0x40,0xa(%r14)
   1b862:	eb 2a                	jmp    1b88e <_lv_obj_get_style_int+0x1a1>
                    if(list->border_post_off) def = true;
   1b864:	41 80 7e 0a 00       	cmpb   $0x0,0xa(%r14)
   1b869:	79 25                	jns    1b890 <_lv_obj_get_style_int+0x1a3>
   1b86b:	eb 71                	jmp    1b8de <_lv_obj_get_style_int+0x1f1>
                    if(list->outline_width_zero) def = true;
   1b86d:	41 f6 46 0b 01       	testb  $0x1,0xb(%r14)
   1b872:	eb 1a                	jmp    1b88e <_lv_obj_get_style_int+0x1a1>
                    if(list->shadow_width_zero) def = true;
   1b874:	41 f6 46 0b 04       	testb  $0x4,0xb(%r14)
   1b879:	eb 13                	jmp    1b88e <_lv_obj_get_style_int+0x1a1>
                    if(list->pad_all_zero) def = true;
   1b87b:	41 f6 46 0a 01       	testb  $0x1,0xa(%r14)
   1b880:	eb 0c                	jmp    1b88e <_lv_obj_get_style_int+0x1a1>
                    if(list->blend_mode_all_normal) def = true;
   1b882:	41 f6 46 0a 04       	testb  $0x4,0xa(%r14)
   1b887:	eb 05                	jmp    1b88e <_lv_obj_get_style_int+0x1a1>
                    if(list->text_decor_none) def = true;
   1b889:	41 f6 46 0b 40       	testb  $0x40,0xb(%r14)
   1b88e:	75 4e                	jne    1b8de <_lv_obj_get_style_int+0x1f1>
        lv_state_t state = lv_obj_get_state(parent, part);
   1b890:	44 89 ee             	mov    %r13d,%esi
   1b893:	48 89 ef             	mov    %rbp,%rdi
   1b896:	e8 33 fd ff ff       	callq  1b5ce <lv_obj_get_state>
        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);
   1b89b:	66 8b 4c 24 0e       	mov    0xe(%rsp),%cx
   1b8a0:	c1 e0 08             	shl    $0x8,%eax
        res = _lv_style_list_get_int(list, prop, &value_act);
   1b8a3:	4c 89 fa             	mov    %r15,%rdx
   1b8a6:	4c 89 f7             	mov    %r14,%rdi
        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);
   1b8a9:	8d 1c 08             	lea    (%rax,%rcx,1),%ebx
        res = _lv_style_list_get_int(list, prop, &value_act);
   1b8ac:	0f b7 f3             	movzwl %bx,%esi
   1b8af:	e8 6d 32 00 00       	callq  1eb21 <_lv_style_list_get_int>
        if(res == LV_RES_OK) return value_act;
   1b8b4:	fe c8                	dec    %al
   1b8b6:	75 07                	jne    1b8bf <_lv_obj_get_style_int+0x1d2>
   1b8b8:	66 8b 44 24 16       	mov    0x16(%rsp),%ax
   1b8bd:	eb 5e                	jmp    1b91d <_lv_obj_get_style_int+0x230>
        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;
   1b8bf:	80 7c 24 0c 00       	cmpb   $0x0,0xc(%rsp)
   1b8c4:	79 18                	jns    1b8de <_lv_obj_get_style_int+0x1f1>
        if(part != LV_OBJ_PART_MAIN) {
   1b8c6:	45 84 e4             	test   %r12b,%r12b
   1b8c9:	75 0b                	jne    1b8d6 <_lv_obj_get_style_int+0x1e9>
        parent = lv_obj_get_parent(parent);
   1b8cb:	48 89 ef             	mov    %rbp,%rdi
   1b8ce:	e8 4c ef ff ff       	callq  1a81f <lv_obj_get_parent>
   1b8d3:	48 89 c5             	mov    %rax,%rbp
   1b8d6:	45 31 e4             	xor    %r12d,%r12d
   1b8d9:	e9 4a fe ff ff       	jmpq   1b728 <_lv_obj_get_style_int+0x3b>
    prop = prop & (~LV_STYLE_STATE_MASK);
   1b8de:	80 e7 80             	and    $0x80,%bh
            return 255;
   1b8e1:	b8 ff 00 00 00       	mov    $0xff,%eax
    switch(prop) {
   1b8e6:	66 83 fb 22          	cmp    $0x22,%bx
   1b8ea:	74 31                	je     1b91d <_lv_obj_get_style_int+0x230>
   1b8ec:	77 16                	ja     1b904 <_lv_obj_get_style_int+0x217>
   1b8ee:	66 83 fb 03          	cmp    $0x3,%bx
            return LV_DPI / 20;
   1b8f2:	b8 06 00 00 00       	mov    $0x6,%eax
    switch(prop) {
   1b8f7:	74 24                	je     1b91d <_lv_obj_get_style_int+0x230>
            return LV_IMG_ZOOM_NONE;
   1b8f9:	b8 00 01 00 00       	mov    $0x100,%eax
    switch(prop) {
   1b8fe:	66 83 fb 07          	cmp    $0x7,%bx
   1b902:	eb 15                	jmp    1b919 <_lv_obj_get_style_int+0x22c>
   1b904:	66 83 fb 31          	cmp    $0x31,%bx
            return LV_BORDER_SIDE_FULL;
   1b908:	b8 0f 00 00 00       	mov    $0xf,%eax
    switch(prop) {
   1b90d:	74 0e                	je     1b91d <_lv_obj_get_style_int+0x230>
            return LV_DPI / 8;
   1b90f:	b8 10 00 00 00       	mov    $0x10,%eax
    switch(prop) {
   1b914:	66 81 fb c0 00       	cmp    $0xc0,%bx
   1b919:	74 02                	je     1b91d <_lv_obj_get_style_int+0x230>
    return 0;
   1b91b:	31 c0                	xor    %eax,%eax
}
   1b91d:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   1b922:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1b929:	00 00 
   1b92b:	74 05                	je     1b932 <_lv_obj_get_style_int+0x245>
   1b92d:	e8 0e 8d fe ff       	callq  4640 <__stack_chk_fail@plt>
   1b932:	48 83 c4 28          	add    $0x28,%rsp
   1b936:	5b                   	pop    %rbx
   1b937:	5d                   	pop    %rbp
   1b938:	41 5c                	pop    %r12
   1b93a:	41 5d                	pop    %r13
   1b93c:	41 5e                	pop    %r14
   1b93e:	41 5f                	pop    %r15
   1b940:	c3                   	retq   

000000000001b941 <lv_obj_get_style_clip_corner>:
    _OBJ_GET_STYLE_##scalar(prop_name, func_name, value_type, style_type)                                               \
    _OBJ_SET_STYLE_LOCAL_##scalar(prop_name, func_name, value_type, style_type)                                         \
    _OBJ_SET_STYLE_##scalar(prop_name, func_name, value_type, style_type)

_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(CLIP_CORNER, clip_corner, bool, _int, scalar)
   1b941:	48 83 ec 08          	sub    $0x8,%rsp
   1b945:	ba 02 00 00 00       	mov    $0x2,%edx
   1b94a:	40 0f b6 f6          	movzbl %sil,%esi
   1b94e:	e8 9a fd ff ff       	callq  1b6ed <_lv_obj_get_style_int>
   1b953:	66 85 c0             	test   %ax,%ax
   1b956:	0f 95 c0             	setne  %al
   1b959:	5a                   	pop    %rdx
   1b95a:	c3                   	retq   

000000000001b95b <lv_obj_get_width_fit>:
{
   1b95b:	41 54                	push   %r12
   1b95d:	55                   	push   %rbp
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ANGLE, transform_angle, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ZOOM, transform_zoom, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(OPA_SCALE, opa_scale, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   1b95e:	ba 12 00 00 00       	mov    $0x12,%edx
   1b963:	53                   	push   %rbx
   1b964:	31 f6                	xor    %esi,%esi
   1b966:	48 89 fb             	mov    %rdi,%rbx
   1b969:	e8 7f fd ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   1b96e:	48 89 df             	mov    %rbx,%rdi
   1b971:	ba 13 00 00 00       	mov    $0x13,%edx
   1b976:	31 f6                	xor    %esi,%esi
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   1b978:	41 89 c4             	mov    %eax,%r12d
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   1b97b:	e8 6d fd ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    return lv_obj_get_width(obj) - left - right;
   1b980:	48 89 df             	mov    %rbx,%rdi
   1b983:	89 c5                	mov    %eax,%ebp
   1b985:	e8 6b f0 ff ff       	callq  1a9f5 <lv_obj_get_width>
   1b98a:	44 29 e0             	sub    %r12d,%eax
   1b98d:	29 e8                	sub    %ebp,%eax
}
   1b98f:	5b                   	pop    %rbx
   1b990:	5d                   	pop    %rbp
   1b991:	41 5c                	pop    %r12
   1b993:	c3                   	retq   

000000000001b994 <update_style_cache>:
 * @param obj pointer to an obejct
 * @param part the part of the object
 * @param prop the property which triggered the update
 */
static void update_style_cache(lv_obj_t * obj, uint8_t part, uint16_t prop)
{
   1b994:	41 55                	push   %r13
   1b996:	41 54                	push   %r12
   1b998:	49 89 fc             	mov    %rdi,%r12
   1b99b:	55                   	push   %rbp
   1b99c:	53                   	push   %rbx
    if(style_prop_is_cacheble(prop) == false) return;
   1b99d:	0f b7 fa             	movzwl %dx,%edi
{
   1b9a0:	48 83 ec 08          	sub    $0x8,%rsp
    if(style_prop_is_cacheble(prop) == false) return;
   1b9a4:	e8 a4 ea ff ff       	callq  1a44d <style_prop_is_cacheble>
   1b9a9:	84 c0                	test   %al,%al
   1b9ab:	0f 84 62 03 00 00    	je     1bd13 <update_style_cache+0x37f>
   1b9b1:	40 0f b6 ee          	movzbl %sil,%ebp

    lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   1b9b5:	4c 89 e7             	mov    %r12,%rdi
   1b9b8:	89 ee                	mov    %ebp,%esi
   1b9ba:	e8 4f f0 ff ff       	callq  1aa0e <lv_obj_get_style_list>
   1b9bf:	48 89 c3             	mov    %rax,%rbx

    bool ignore_cache_ori = list->ignore_cache;
   1b9c2:	8a 40 09             	mov    0x9(%rax),%al
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OPA, value_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_FONT, value_font, const lv_font_t *, _ptr, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_STR, value_str, const char *, _ptr, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_DECOR, text_decor, lv_text_decor_t, _int, scalar)
   1b9c5:	ba 82 80 00 00       	mov    $0x8082,%edx
   1b9ca:	89 ee                	mov    %ebp,%esi
   1b9cc:	4c 89 e7             	mov    %r12,%rdi
   1b9cf:	41 88 c5             	mov    %al,%r13b
    list->ignore_cache = 1;

#if LV_USE_OPA_SCALE
    list->opa_scale_cover    = lv_obj_get_style_opa_scale(obj, part) == LV_OPA_COVER ? 1 : 0;
#else
    list->opa_scale_cover    = 1;
   1b9d2:	83 c8 28             	or     $0x28,%eax
    bool ignore_cache_ori = list->ignore_cache;
   1b9d5:	41 c0 ed 03          	shr    $0x3,%r13b
    list->opa_scale_cover    = 1;
   1b9d9:	88 43 09             	mov    %al,0x9(%rbx)
   1b9dc:	e8 0c fd ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    bool ignore_cache_ori = list->ignore_cache;
   1b9e1:	41 83 e5 01          	and    $0x1,%r13d
#endif
    list->text_decor_none    = lv_obj_get_style_text_decor(obj, part) == LV_TEXT_DECOR_NONE ? 1 : 0;
   1b9e5:	84 c0                	test   %al,%al
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_BLEND_MODE, text_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_SEL_COLOR, text_sel_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_OPA, text_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
   1b9e7:	89 ee                	mov    %ebp,%esi
   1b9e9:	0f 94 c0             	sete   %al
   1b9ec:	4c 89 e7             	mov    %r12,%rdi
   1b9ef:	c1 e0 06             	shl    $0x6,%eax
   1b9f2:	88 c2                	mov    %al,%dl
   1b9f4:	8a 43 0b             	mov    0xb(%rbx),%al
   1b9f7:	83 e0 bf             	and    $0xffffffbf,%eax
   1b9fa:	09 d0                	or     %edx,%eax
   1b9fc:	ba 8e 80 00 00       	mov    $0x808e,%edx
   1ba01:	88 43 0b             	mov    %al,0xb(%rbx)
   1ba04:	e8 50 04 00 00       	callq  1be59 <_lv_obj_get_style_ptr>
    list->text_font_normal    = lv_obj_get_style_text_font(obj, part) == LV_THEME_DEFAULT_FONT_NORMAL ? 1 : 0;
   1ba09:	48 3b 05 c8 a5 21 00 	cmp    0x21a5c8(%rip),%rax        # 235fd8 <_GLOBAL_OFFSET_TABLE_+0x2f8>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
   1ba10:	89 ee                	mov    %ebp,%esi
   1ba12:	4c 89 e7             	mov    %r12,%rdi
   1ba15:	0f 94 c0             	sete   %al
   1ba18:	c1 e0 07             	shl    $0x7,%eax
   1ba1b:	88 c2                	mov    %al,%dl
   1ba1d:	8a 43 0b             	mov    0xb(%rbx),%al
   1ba20:	83 e0 7f             	and    $0x7f,%eax
   1ba23:	09 d0                	or     %edx,%eax
   1ba25:	ba 80 80 00 00       	mov    $0x8080,%edx

    list->text_space_zero = 1;
   1ba2a:	83 c8 20             	or     $0x20,%eax
   1ba2d:	88 43 0b             	mov    %al,0xb(%rbx)
   1ba30:	e8 b8 fc ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||
   1ba35:	66 85 c0             	test   %ax,%ax
   1ba38:	74 06                	je     1ba40 <update_style_cache+0xac>
       lv_obj_get_style_text_line_space(obj, part) != 0) {
        list->text_space_zero = 0;
   1ba3a:	80 63 0b df          	andb   $0xdf,0xb(%rbx)
   1ba3e:	eb 14                	jmp    1ba54 <update_style_cache+0xc0>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
   1ba40:	ba 81 80 00 00       	mov    $0x8081,%edx
   1ba45:	89 ee                	mov    %ebp,%esi
   1ba47:	4c 89 e7             	mov    %r12,%rdi
   1ba4a:	e8 9e fc ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||
   1ba4f:	66 85 c0             	test   %ax,%ax
   1ba52:	75 e6                	jne    1ba3a <update_style_cache+0xa6>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
   1ba54:	ba 2c 00 00 00       	mov    $0x2c,%edx
   1ba59:	89 ee                	mov    %ebp,%esi
   1ba5b:	4c 89 e7             	mov    %r12,%rdi
   1ba5e:	e8 b8 02 00 00       	callq  1bd1b <_lv_obj_get_style_opa>
    }


    lv_opa_t bg_opa = lv_obj_get_style_bg_opa(obj, part);
    list->bg_opa_transp    = bg_opa == LV_OPA_TRANSP ? 1 : 0;
   1ba63:	8a 53 0a             	mov    0xa(%rbx),%dl
   1ba66:	84 c0                	test   %al,%al
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_WIDTH, border_width, lv_style_int_t, _int, scalar)
   1ba68:	4c 89 e7             	mov    %r12,%rdi
   1ba6b:	40 0f 94 c6          	sete   %sil
   1ba6f:	c1 e6 03             	shl    $0x3,%esi
   1ba72:	83 e2 e7             	and    $0xffffffe7,%edx
    list->bg_opa_cover     = bg_opa == LV_OPA_COVER ? 1 : 0;
   1ba75:	fe c0                	inc    %al
   1ba77:	0f 94 c1             	sete   %cl
   1ba7a:	88 d0                	mov    %dl,%al
   1ba7c:	ba 30 00 00 00       	mov    $0x30,%edx
   1ba81:	c1 e1 04             	shl    $0x4,%ecx
   1ba84:	09 f0                	or     %esi,%eax
   1ba86:	89 ee                	mov    %ebp,%esi
   1ba88:	09 c8                	or     %ecx,%eax
   1ba8a:	88 43 0a             	mov    %al,0xa(%rbx)
   1ba8d:	e8 5b fc ff ff       	callq  1b6ed <_lv_obj_get_style_int>

    list->border_width_zero = lv_obj_get_style_border_width(obj, part) == 0 ? 1 : 0;
   1ba92:	66 85 c0             	test   %ax,%ax
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_SIDE, border_side, lv_border_side_t, _int, scalar)
   1ba95:	89 ee                	mov    %ebp,%esi
   1ba97:	4c 89 e7             	mov    %r12,%rdi
   1ba9a:	0f 94 c0             	sete   %al
   1ba9d:	c1 e0 05             	shl    $0x5,%eax
   1baa0:	88 c2                	mov    %al,%dl
   1baa2:	8a 43 0a             	mov    0xa(%rbx),%al
   1baa5:	83 e0 df             	and    $0xffffffdf,%eax
   1baa8:	09 d0                	or     %edx,%eax
   1baaa:	ba 31 00 00 00       	mov    $0x31,%edx
   1baaf:	88 43 0a             	mov    %al,0xa(%rbx)
   1bab2:	e8 36 fc ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    list->border_side_full = lv_obj_get_style_border_side(obj, part) == LV_BORDER_SIDE_FULL ? 1 : 0;
   1bab7:	3c 0f                	cmp    $0xf,%al
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_POST, border_post, bool, _int, scalar)
   1bab9:	89 ee                	mov    %ebp,%esi
   1babb:	4c 89 e7             	mov    %r12,%rdi
   1babe:	0f 94 c0             	sete   %al
   1bac1:	c1 e0 06             	shl    $0x6,%eax
   1bac4:	88 c2                	mov    %al,%dl
   1bac6:	8a 43 0a             	mov    0xa(%rbx),%al
   1bac9:	83 e0 bf             	and    $0xffffffbf,%eax
   1bacc:	09 d0                	or     %edx,%eax
   1bace:	ba 33 00 00 00       	mov    $0x33,%edx
   1bad3:	88 43 0a             	mov    %al,0xa(%rbx)
   1bad6:	e8 12 fc ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    list->border_post_off = lv_obj_get_style_border_post(obj, part) == 0 ? 1 : 0;
   1badb:	66 85 c0             	test   %ax,%ax
    list->clip_corner_off   = lv_obj_get_style_clip_corner(obj, part) == false ? 1 : 0;
   1bade:	89 ee                	mov    %ebp,%esi
   1bae0:	4c 89 e7             	mov    %r12,%rdi
    list->border_post_off = lv_obj_get_style_border_post(obj, part) == 0 ? 1 : 0;
   1bae3:	0f 94 c0             	sete   %al
   1bae6:	c1 e0 07             	shl    $0x7,%eax
   1bae9:	88 c2                	mov    %al,%dl
   1baeb:	8a 43 0a             	mov    0xa(%rbx),%al
   1baee:	83 e0 7f             	and    $0x7f,%eax
   1baf1:	09 d0                	or     %edx,%eax
   1baf3:	88 43 0a             	mov    %al,0xa(%rbx)
    list->clip_corner_off   = lv_obj_get_style_clip_corner(obj, part) == false ? 1 : 0;
   1baf6:	e8 46 fe ff ff       	callq  1b941 <lv_obj_get_style_clip_corner>
   1bafb:	8a 53 09             	mov    0x9(%rbx),%dl
   1bafe:	83 f0 01             	xor    $0x1,%eax
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_COLOR, line_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_OPA, line_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_BLEND_MODE, image_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR, image_recolor, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_OPA, image_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR_OPA, image_recolor_opa, lv_opa_t, _opa, scalar)
   1bb01:	89 ee                	mov    %ebp,%esi
   1bb03:	83 e0 01             	and    $0x1,%eax
   1bb06:	4c 89 e7             	mov    %r12,%rdi
   1bb09:	c1 e0 06             	shl    $0x6,%eax
   1bb0c:	83 e2 bf             	and    $0xffffffbf,%edx
   1bb0f:	09 d0                	or     %edx,%eax
   1bb11:	ba ad 80 00 00       	mov    $0x80ad,%edx
   1bb16:	88 43 09             	mov    %al,0x9(%rbx)
   1bb19:	e8 fd 01 00 00       	callq  1bd1b <_lv_obj_get_style_opa>
    list->img_recolor_opa_transp    = lv_obj_get_style_image_recolor_opa(obj, part) == LV_OPA_TRANSP ? 1 : 0;
   1bb1e:	84 c0                	test   %al,%al
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_WIDTH, outline_width, lv_style_int_t, _int, scalar)
   1bb20:	89 ee                	mov    %ebp,%esi
   1bb22:	4c 89 e7             	mov    %r12,%rdi
   1bb25:	0f 94 c0             	sete   %al
   1bb28:	c1 e0 04             	shl    $0x4,%eax
   1bb2b:	88 c2                	mov    %al,%dl
   1bb2d:	8a 43 0b             	mov    0xb(%rbx),%al
   1bb30:	83 e0 ef             	and    $0xffffffef,%eax
   1bb33:	09 d0                	or     %edx,%eax
   1bb35:	ba 40 00 00 00       	mov    $0x40,%edx
   1bb3a:	88 43 0b             	mov    %al,0xb(%rbx)
   1bb3d:	e8 ab fb ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    list->outline_width_zero    = lv_obj_get_style_outline_width(obj, part) == 0 ? 1 : 0;
   1bb42:	66 85 c0             	test   %ax,%ax
   1bb45:	8a 43 0b             	mov    0xb(%rbx),%al
_LV_OBJ_STYLE_SET_GET_DECLARE(PATTERN_IMAGE, pattern_image, const void *, _ptr, scalar)
   1bb48:	89 ee                	mov    %ebp,%esi
   1bb4a:	0f 94 c2             	sete   %dl
   1bb4d:	4c 89 e7             	mov    %r12,%rdi
   1bb50:	83 e0 fe             	and    $0xfffffffe,%eax
   1bb53:	09 d0                	or     %edx,%eax
   1bb55:	ba 6e 00 00 00       	mov    $0x6e,%edx
   1bb5a:	88 43 0b             	mov    %al,0xb(%rbx)
   1bb5d:	e8 f7 02 00 00       	callq  1be59 <_lv_obj_get_style_ptr>
    list->pattern_img_null    = lv_obj_get_style_pattern_image(obj, part) == NULL ? 1 : 0;
   1bb62:	48 85 c0             	test   %rax,%rax
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
   1bb65:	89 ee                	mov    %ebp,%esi
   1bb67:	4c 89 e7             	mov    %r12,%rdi
   1bb6a:	0f 94 c0             	sete   %al
   1bb6d:	8d 14 00             	lea    (%rax,%rax,1),%edx
   1bb70:	8a 43 0b             	mov    0xb(%rbx),%al
   1bb73:	83 e0 fd             	and    $0xfffffffd,%eax
   1bb76:	09 d0                	or     %edx,%eax
   1bb78:	ba 01 00 00 00       	mov    $0x1,%edx
   1bb7d:	88 43 0b             	mov    %al,0xb(%rbx)
   1bb80:	e8 68 fb ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    list->radius_zero    = lv_obj_get_style_radius(obj, part) == 0 ? 1 : 0;
   1bb85:	66 85 c0             	test   %ax,%ax
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_WIDTH, shadow_width, lv_style_int_t, _int, scalar)
   1bb88:	89 ee                	mov    %ebp,%esi
   1bb8a:	4c 89 e7             	mov    %r12,%rdi
   1bb8d:	0f 94 c0             	sete   %al
   1bb90:	c1 e0 04             	shl    $0x4,%eax
   1bb93:	88 c2                	mov    %al,%dl
   1bb95:	8a 43 09             	mov    0x9(%rbx),%al
   1bb98:	83 e0 ef             	and    $0xffffffef,%eax
   1bb9b:	09 d0                	or     %edx,%eax
   1bb9d:	ba 50 00 00 00       	mov    $0x50,%edx
   1bba2:	88 43 09             	mov    %al,0x9(%rbx)
   1bba5:	e8 43 fb ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    list->shadow_width_zero    = lv_obj_get_style_shadow_width(obj, part) == 0 ? 1 : 0;
   1bbaa:	66 85 c0             	test   %ax,%ax
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_STR, value_str, const char *, _ptr, scalar)
   1bbad:	89 ee                	mov    %ebp,%esi
   1bbaf:	4c 89 e7             	mov    %r12,%rdi
   1bbb2:	0f 94 c0             	sete   %al
   1bbb5:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
   1bbbc:	8a 43 0b             	mov    0xb(%rbx),%al
   1bbbf:	83 e0 fb             	and    $0xfffffffb,%eax
   1bbc2:	09 d0                	or     %edx,%eax
   1bbc4:	ba 7f 00 00 00       	mov    $0x7f,%edx
   1bbc9:	88 43 0b             	mov    %al,0xb(%rbx)
   1bbcc:	e8 88 02 00 00       	callq  1be59 <_lv_obj_get_style_ptr>
    list->value_txt_str    = lv_obj_get_style_value_str(obj, part) == NULL ? 1 : 0;
   1bbd1:	48 85 c0             	test   %rax,%rax
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ANGLE, transform_angle, lv_style_int_t, _int, scalar)
   1bbd4:	89 ee                	mov    %ebp,%esi
   1bbd6:	4c 89 e7             	mov    %r12,%rdi
   1bbd9:	0f 94 c0             	sete   %al


    list->transform_all_zero  = 1;
   1bbdc:	80 4b 09 80          	orb    $0x80,0x9(%rbx)
    list->value_txt_str    = lv_obj_get_style_value_str(obj, part) == NULL ? 1 : 0;
   1bbe0:	8d 14 c5 00 00 00 00 	lea    0x0(,%rax,8),%edx
   1bbe7:	8a 43 0b             	mov    0xb(%rbx),%al
   1bbea:	83 e0 f7             	and    $0xfffffff7,%eax
   1bbed:	09 d0                	or     %edx,%eax
   1bbef:	ba 06 00 00 00       	mov    $0x6,%edx
   1bbf4:	88 43 0b             	mov    %al,0xb(%rbx)
   1bbf7:	e8 f1 fa ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    if(lv_obj_get_style_transform_angle(obj, part) != 0 ||
   1bbfc:	66 85 c0             	test   %ax,%ax
   1bbff:	74 06                	je     1bc07 <update_style_cache+0x273>
       lv_obj_get_style_transform_width(obj, part) != 0 ||
       lv_obj_get_style_transform_height(obj, part) != 0 ||
       lv_obj_get_style_transform_zoom(obj, part) != LV_IMG_ZOOM_NONE) {
        list->transform_all_zero  = 0;
   1bc01:	80 63 09 7f          	andb   $0x7f,0x9(%rbx)
   1bc05:	eb 3d                	jmp    1bc44 <update_style_cache+0x2b0>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   1bc07:	ba 04 00 00 00       	mov    $0x4,%edx
   1bc0c:	89 ee                	mov    %ebp,%esi
   1bc0e:	4c 89 e7             	mov    %r12,%rdi
   1bc11:	e8 d7 fa ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    if(lv_obj_get_style_transform_angle(obj, part) != 0 ||
   1bc16:	66 85 c0             	test   %ax,%ax
   1bc19:	75 e6                	jne    1bc01 <update_style_cache+0x26d>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   1bc1b:	ba 05 00 00 00       	mov    $0x5,%edx
   1bc20:	89 ee                	mov    %ebp,%esi
   1bc22:	4c 89 e7             	mov    %r12,%rdi
   1bc25:	e8 c3 fa ff ff       	callq  1b6ed <_lv_obj_get_style_int>
       lv_obj_get_style_transform_width(obj, part) != 0 ||
   1bc2a:	66 85 c0             	test   %ax,%ax
   1bc2d:	75 d2                	jne    1bc01 <update_style_cache+0x26d>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ZOOM, transform_zoom, lv_style_int_t, _int, scalar)
   1bc2f:	ba 07 00 00 00       	mov    $0x7,%edx
   1bc34:	89 ee                	mov    %ebp,%esi
   1bc36:	4c 89 e7             	mov    %r12,%rdi
   1bc39:	e8 af fa ff ff       	callq  1b6ed <_lv_obj_get_style_int>
       lv_obj_get_style_transform_height(obj, part) != 0 ||
   1bc3e:	66 3d 00 01          	cmp    $0x100,%ax
   1bc42:	75 bd                	jne    1bc01 <update_style_cache+0x26d>
    }

    list->pad_all_zero  = 1;
   1bc44:	80 4b 0a 01          	orb    $0x1,0xa(%rbx)
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   1bc48:	ba 10 00 00 00       	mov    $0x10,%edx
   1bc4d:	89 ee                	mov    %ebp,%esi
   1bc4f:	4c 89 e7             	mov    %r12,%rdi
   1bc52:	e8 96 fa ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    if(lv_obj_get_style_pad_top(obj, part) != 0 ||
   1bc57:	66 85 c0             	test   %ax,%ax
   1bc5a:	74 06                	je     1bc62 <update_style_cache+0x2ce>
       lv_obj_get_style_pad_bottom(obj, part) != 0 ||
       lv_obj_get_style_pad_left(obj, part) != 0 ||
       lv_obj_get_style_pad_right(obj, part) != 0) {
        list->pad_all_zero  = 0;
   1bc5c:	80 63 0a fe          	andb   $0xfe,0xa(%rbx)
   1bc60:	eb 3c                	jmp    1bc9e <update_style_cache+0x30a>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   1bc62:	ba 11 00 00 00       	mov    $0x11,%edx
   1bc67:	89 ee                	mov    %ebp,%esi
   1bc69:	4c 89 e7             	mov    %r12,%rdi
   1bc6c:	e8 7c fa ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    if(lv_obj_get_style_pad_top(obj, part) != 0 ||
   1bc71:	66 85 c0             	test   %ax,%ax
   1bc74:	75 e6                	jne    1bc5c <update_style_cache+0x2c8>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   1bc76:	ba 12 00 00 00       	mov    $0x12,%edx
   1bc7b:	89 ee                	mov    %ebp,%esi
   1bc7d:	4c 89 e7             	mov    %r12,%rdi
   1bc80:	e8 68 fa ff ff       	callq  1b6ed <_lv_obj_get_style_int>
       lv_obj_get_style_pad_bottom(obj, part) != 0 ||
   1bc85:	66 85 c0             	test   %ax,%ax
   1bc88:	75 d2                	jne    1bc5c <update_style_cache+0x2c8>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   1bc8a:	ba 13 00 00 00       	mov    $0x13,%edx
   1bc8f:	89 ee                	mov    %ebp,%esi
   1bc91:	4c 89 e7             	mov    %r12,%rdi
   1bc94:	e8 54 fa ff ff       	callq  1b6ed <_lv_obj_get_style_int>
       lv_obj_get_style_pad_left(obj, part) != 0 ||
   1bc99:	66 85 c0             	test   %ax,%ax
   1bc9c:	75 be                	jne    1bc5c <update_style_cache+0x2c8>
    }

    list->margin_all_zero  = 1;
   1bc9e:	80 4b 0a 02          	orb    $0x2,0xa(%rbx)
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
   1bca2:	ba 15 00 00 00       	mov    $0x15,%edx
   1bca7:	89 ee                	mov    %ebp,%esi
   1bca9:	4c 89 e7             	mov    %r12,%rdi
   1bcac:	e8 3c fa ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    if(lv_obj_get_style_margin_top(obj, part) != 0 ||
   1bcb1:	66 85 c0             	test   %ax,%ax
   1bcb4:	74 06                	je     1bcbc <update_style_cache+0x328>
       lv_obj_get_style_margin_bottom(obj, part) != 0 ||
       lv_obj_get_style_margin_left(obj, part) != 0 ||
       lv_obj_get_style_margin_right(obj, part) != 0) {
        list->margin_all_zero  = 0;
   1bcb6:	80 63 0a fd          	andb   $0xfd,0xa(%rbx)
   1bcba:	eb 3c                	jmp    1bcf8 <update_style_cache+0x364>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
   1bcbc:	ba 16 00 00 00       	mov    $0x16,%edx
   1bcc1:	89 ee                	mov    %ebp,%esi
   1bcc3:	4c 89 e7             	mov    %r12,%rdi
   1bcc6:	e8 22 fa ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    if(lv_obj_get_style_margin_top(obj, part) != 0 ||
   1bccb:	66 85 c0             	test   %ax,%ax
   1bcce:	75 e6                	jne    1bcb6 <update_style_cache+0x322>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
   1bcd0:	ba 17 00 00 00       	mov    $0x17,%edx
   1bcd5:	89 ee                	mov    %ebp,%esi
   1bcd7:	4c 89 e7             	mov    %r12,%rdi
   1bcda:	e8 0e fa ff ff       	callq  1b6ed <_lv_obj_get_style_int>
       lv_obj_get_style_margin_bottom(obj, part) != 0 ||
   1bcdf:	66 85 c0             	test   %ax,%ax
   1bce2:	75 d2                	jne    1bcb6 <update_style_cache+0x322>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_RIGHT, margin_right, lv_style_int_t, _int, scalar)
   1bce4:	ba 18 00 00 00       	mov    $0x18,%edx
   1bce9:	89 ee                	mov    %ebp,%esi
   1bceb:	4c 89 e7             	mov    %r12,%rdi
   1bcee:	e8 fa f9 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
       lv_obj_get_style_margin_left(obj, part) != 0 ||
   1bcf3:	66 85 c0             	test   %ax,%ax
   1bcf6:	75 be                	jne    1bcb6 <update_style_cache+0x322>
       lv_obj_get_style_image_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||
       lv_obj_get_style_shadow_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL) {
        list->blend_mode_all_normal = 0;
    }
#endif
    list->ignore_cache = ignore_cache_ori;
   1bcf8:	8a 43 09             	mov    0x9(%rbx),%al
   1bcfb:	41 83 e5 01          	and    $0x1,%r13d
    list->blend_mode_all_normal = 1;
   1bcff:	80 4b 0a 04          	orb    $0x4,0xa(%rbx)
    list->ignore_cache = ignore_cache_ori;
   1bd03:	41 c1 e5 03          	shl    $0x3,%r13d
   1bd07:	83 e0 f7             	and    $0xfffffff7,%eax
   1bd0a:	44 09 e8             	or     %r13d,%eax
    list->valid_cache = 1;
   1bd0d:	83 c8 04             	or     $0x4,%eax
   1bd10:	88 43 09             	mov    %al,0x9(%rbx)
}
   1bd13:	58                   	pop    %rax
   1bd14:	5b                   	pop    %rbx
   1bd15:	5d                   	pop    %rbp
   1bd16:	41 5c                	pop    %r12
   1bd18:	41 5d                	pop    %r13
   1bd1a:	c3                   	retq   

000000000001bd1b <_lv_obj_get_style_opa>:
{
   1bd1b:	41 57                	push   %r15
   1bd1d:	41 56                	push   %r14
   1bd1f:	41 55                	push   %r13
   1bd21:	41 54                	push   %r12
   1bd23:	41 88 f4             	mov    %sil,%r12b
   1bd26:	55                   	push   %rbp
   1bd27:	53                   	push   %rbx
   1bd28:	48 89 fd             	mov    %rdi,%rbp
    while(parent) {
   1bd2b:	89 d3                	mov    %edx,%ebx
{
   1bd2d:	48 83 ec 28          	sub    $0x28,%rsp
   1bd31:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1bd38:	00 00 
   1bd3a:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1bd3f:	31 c0                	xor    %eax,%eax
    attr = prop_ori >> 8;
   1bd41:	89 d0                	mov    %edx,%eax
        res = _lv_style_list_get_opa(list, prop, &value_act);
   1bd43:	4c 8d 7c 24 17       	lea    0x17(%rsp),%r15
{
   1bd48:	66 89 54 24 0e       	mov    %dx,0xe(%rsp)
    attr = prop_ori >> 8;
   1bd4d:	66 c1 e8 08          	shr    $0x8,%ax
   1bd51:	66 89 44 24 0c       	mov    %ax,0xc(%rsp)
    while(parent) {
   1bd56:	48 85 ed             	test   %rbp,%rbp
   1bd59:	0f 84 ba 00 00 00    	je     1be19 <_lv_obj_get_style_opa+0xfe>
        lv_style_list_t * list = lv_obj_get_style_list(parent, part);
   1bd5f:	45 0f b6 ec          	movzbl %r12b,%r13d
   1bd63:	48 89 ef             	mov    %rbp,%rdi
   1bd66:	44 89 ee             	mov    %r13d,%esi
   1bd69:	e8 a0 ec ff ff       	callq  1aa0e <lv_obj_get_style_list>
   1bd6e:	49 89 c6             	mov    %rax,%r14
        if(!list->ignore_cache && list->style_cnt > 0) {
   1bd71:	8a 40 09             	mov    0x9(%rax),%al
   1bd74:	a8 08                	test   $0x8,%al
   1bd76:	75 54                	jne    1bdcc <_lv_obj_get_style_opa+0xb1>
   1bd78:	41 f6 46 08 3f       	testb  $0x3f,0x8(%r14)
   1bd7d:	74 4d                	je     1bdcc <_lv_obj_get_style_opa+0xb1>
            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));
   1bd7f:	a8 04                	test   $0x4,%al
   1bd81:	75 13                	jne    1bd96 <_lv_obj_get_style_opa+0x7b>
   1bd83:	89 da                	mov    %ebx,%edx
   1bd85:	44 89 ee             	mov    %r13d,%esi
   1bd88:	48 89 ef             	mov    %rbp,%rdi
   1bd8b:	81 e2 ff 80 00 00    	and    $0x80ff,%edx
   1bd91:	e8 fe fb ff ff       	callq  1b994 <update_style_cache>
            switch(prop & (~LV_STYLE_STATE_MASK)) {
   1bd96:	89 d8                	mov    %ebx,%eax
   1bd98:	25 ff 80 00 00       	and    $0x80ff,%eax
   1bd9d:	3d 0c 80 00 00       	cmp    $0x800c,%eax
   1bda2:	74 0e                	je     1bdb2 <_lv_obj_get_style_opa+0x97>
   1bda4:	3d ad 80 00 00       	cmp    $0x80ad,%eax
   1bda9:	74 1a                	je     1bdc5 <_lv_obj_get_style_opa+0xaa>
   1bdab:	83 f8 2c             	cmp    $0x2c,%eax
   1bdae:	75 1c                	jne    1bdcc <_lv_obj_get_style_opa+0xb1>
   1bdb0:	eb 07                	jmp    1bdb9 <_lv_obj_get_style_opa+0x9e>
                    if(list->opa_scale_cover) def = true;
   1bdb2:	41 f6 46 09 20       	testb  $0x20,0x9(%r14)
   1bdb7:	eb 11                	jmp    1bdca <_lv_obj_get_style_opa+0xaf>
                    if(list->bg_opa_cover) return LV_OPA_COVER;     /*Special case, not the default value is used*/
   1bdb9:	41 8a 46 0a          	mov    0xa(%r14),%al
   1bdbd:	a8 10                	test   $0x10,%al
   1bdbf:	75 6e                	jne    1be2f <_lv_obj_get_style_opa+0x114>
                    if(list->bg_opa_transp) def = true;
   1bdc1:	a8 08                	test   $0x8,%al
   1bdc3:	eb 05                	jmp    1bdca <_lv_obj_get_style_opa+0xaf>
                    if(list->img_recolor_opa_transp) def = true;
   1bdc5:	41 f6 46 0b 10       	testb  $0x10,0xb(%r14)
   1bdca:	75 4d                	jne    1be19 <_lv_obj_get_style_opa+0xfe>
        lv_state_t state = lv_obj_get_state(parent, part);
   1bdcc:	44 89 ee             	mov    %r13d,%esi
   1bdcf:	48 89 ef             	mov    %rbp,%rdi
   1bdd2:	e8 f7 f7 ff ff       	callq  1b5ce <lv_obj_get_state>
        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);
   1bdd7:	66 8b 4c 24 0e       	mov    0xe(%rsp),%cx
   1bddc:	c1 e0 08             	shl    $0x8,%eax
        res = _lv_style_list_get_opa(list, prop, &value_act);
   1bddf:	4c 89 fa             	mov    %r15,%rdx
   1bde2:	4c 89 f7             	mov    %r14,%rdi
        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);
   1bde5:	8d 1c 08             	lea    (%rax,%rcx,1),%ebx
        res = _lv_style_list_get_opa(list, prop, &value_act);
   1bde8:	0f b7 f3             	movzwl %bx,%esi
   1bdeb:	e8 0a 2f 00 00       	callq  1ecfa <_lv_style_list_get_opa>
        if(res == LV_RES_OK) return value_act;
   1bdf0:	fe c8                	dec    %al
   1bdf2:	75 06                	jne    1bdfa <_lv_obj_get_style_opa+0xdf>
   1bdf4:	8a 44 24 17          	mov    0x17(%rsp),%al
   1bdf8:	eb 3b                	jmp    1be35 <_lv_obj_get_style_opa+0x11a>
        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;
   1bdfa:	80 7c 24 0c 00       	cmpb   $0x0,0xc(%rsp)
   1bdff:	79 18                	jns    1be19 <_lv_obj_get_style_opa+0xfe>
        if(part != LV_OBJ_PART_MAIN) {
   1be01:	45 84 e4             	test   %r12b,%r12b
   1be04:	75 0b                	jne    1be11 <_lv_obj_get_style_opa+0xf6>
        parent = lv_obj_get_parent(parent);
   1be06:	48 89 ef             	mov    %rbp,%rdi
   1be09:	e8 11 ea ff ff       	callq  1a81f <lv_obj_get_parent>
   1be0e:	48 89 c5             	mov    %rax,%rbp
   1be11:	45 31 e4             	xor    %r12d,%r12d
   1be14:	e9 3d ff ff ff       	jmpq   1bd56 <_lv_obj_get_style_opa+0x3b>
    prop = prop & (~LV_STYLE_STATE_MASK);
   1be19:	80 e7 80             	and    $0x80,%bh
    switch(prop) {
   1be1c:	66 83 fb 6d          	cmp    $0x6d,%bx
   1be20:	74 11                	je     1be33 <_lv_obj_get_style_opa+0x118>
   1be22:	66 81 fb ad 80       	cmp    $0x80ad,%bx
   1be27:	74 0a                	je     1be33 <_lv_obj_get_style_opa+0x118>
   1be29:	66 83 fb 2c          	cmp    $0x2c,%bx
   1be2d:	74 04                	je     1be33 <_lv_obj_get_style_opa+0x118>
                    if(list->bg_opa_cover) return LV_OPA_COVER;     /*Special case, not the default value is used*/
   1be2f:	b0 ff                	mov    $0xff,%al
   1be31:	eb 02                	jmp    1be35 <_lv_obj_get_style_opa+0x11a>
            return LV_OPA_TRANSP;
   1be33:	31 c0                	xor    %eax,%eax
}
   1be35:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   1be3a:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1be41:	00 00 
   1be43:	74 05                	je     1be4a <_lv_obj_get_style_opa+0x12f>
   1be45:	e8 f6 87 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1be4a:	48 83 c4 28          	add    $0x28,%rsp
   1be4e:	5b                   	pop    %rbx
   1be4f:	5d                   	pop    %rbp
   1be50:	41 5c                	pop    %r12
   1be52:	41 5d                	pop    %r13
   1be54:	41 5e                	pop    %r14
   1be56:	41 5f                	pop    %r15
   1be58:	c3                   	retq   

000000000001be59 <_lv_obj_get_style_ptr>:
{
   1be59:	41 57                	push   %r15
   1be5b:	41 56                	push   %r14
   1be5d:	41 55                	push   %r13
   1be5f:	41 54                	push   %r12
   1be61:	41 88 f4             	mov    %sil,%r12b
   1be64:	55                   	push   %rbp
   1be65:	53                   	push   %rbx
   1be66:	48 89 fd             	mov    %rdi,%rbp
    while(parent) {
   1be69:	89 d3                	mov    %edx,%ebx
{
   1be6b:	48 83 ec 28          	sub    $0x28,%rsp
   1be6f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1be76:	00 00 
   1be78:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1be7d:	31 c0                	xor    %eax,%eax
    attr = prop_ori >> 8;
   1be7f:	89 d0                	mov    %edx,%eax
        res = _lv_style_list_get_ptr(list, prop, &value_act);
   1be81:	4c 8d 7c 24 10       	lea    0x10(%rsp),%r15
{
   1be86:	66 89 54 24 0e       	mov    %dx,0xe(%rsp)
    attr = prop_ori >> 8;
   1be8b:	66 c1 e8 08          	shr    $0x8,%ax
   1be8f:	66 89 44 24 0c       	mov    %ax,0xc(%rsp)
    while(parent) {
   1be94:	48 85 ed             	test   %rbp,%rbp
   1be97:	0f 84 b4 00 00 00    	je     1bf51 <_lv_obj_get_style_ptr+0xf8>
        lv_style_list_t * list = lv_obj_get_style_list(parent, part);
   1be9d:	45 0f b6 ec          	movzbl %r12b,%r13d
   1bea1:	48 89 ef             	mov    %rbp,%rdi
   1bea4:	44 89 ee             	mov    %r13d,%esi
   1bea7:	e8 62 eb ff ff       	callq  1aa0e <lv_obj_get_style_list>
   1beac:	49 89 c6             	mov    %rax,%r14
        if(!list->ignore_cache && list->style_cnt > 0) {
   1beaf:	8a 40 09             	mov    0x9(%rax),%al
   1beb2:	a8 08                	test   $0x8,%al
   1beb4:	75 4d                	jne    1bf03 <_lv_obj_get_style_ptr+0xaa>
   1beb6:	41 f6 46 08 3f       	testb  $0x3f,0x8(%r14)
   1bebb:	74 46                	je     1bf03 <_lv_obj_get_style_ptr+0xaa>
            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));
   1bebd:	a8 04                	test   $0x4,%al
   1bebf:	75 13                	jne    1bed4 <_lv_obj_get_style_ptr+0x7b>
   1bec1:	89 da                	mov    %ebx,%edx
   1bec3:	44 89 ee             	mov    %r13d,%esi
   1bec6:	48 89 ef             	mov    %rbp,%rdi
   1bec9:	81 e2 ff 80 00 00    	and    $0x80ff,%edx
   1becf:	e8 c0 fa ff ff       	callq  1b994 <update_style_cache>
            switch(prop  & (~LV_STYLE_STATE_MASK)) {
   1bed4:	89 d8                	mov    %ebx,%eax
   1bed6:	25 ff 80 00 00       	and    $0x80ff,%eax
   1bedb:	83 f8 7f             	cmp    $0x7f,%eax
   1bede:	74 13                	je     1bef3 <_lv_obj_get_style_ptr+0x9a>
   1bee0:	3d 8e 80 00 00       	cmp    $0x808e,%eax
   1bee5:	74 15                	je     1befc <_lv_obj_get_style_ptr+0xa3>
   1bee7:	83 f8 6e             	cmp    $0x6e,%eax
   1beea:	75 17                	jne    1bf03 <_lv_obj_get_style_ptr+0xaa>
                    if(list->pattern_img_null) def = true;
   1beec:	41 f6 46 0b 02       	testb  $0x2,0xb(%r14)
   1bef1:	eb 05                	jmp    1bef8 <_lv_obj_get_style_ptr+0x9f>
                    if(list->value_txt_str) def = true;
   1bef3:	41 f6 46 0b 08       	testb  $0x8,0xb(%r14)
                    if(list->pattern_img_null) def = true;
   1bef8:	74 09                	je     1bf03 <_lv_obj_get_style_ptr+0xaa>
   1befa:	eb 55                	jmp    1bf51 <_lv_obj_get_style_ptr+0xf8>
                    if(list->text_font_normal) def = true;
   1befc:	41 80 7e 0b 00       	cmpb   $0x0,0xb(%r14)
   1bf01:	78 4e                	js     1bf51 <_lv_obj_get_style_ptr+0xf8>
        lv_state_t state = lv_obj_get_state(parent, part);
   1bf03:	44 89 ee             	mov    %r13d,%esi
   1bf06:	48 89 ef             	mov    %rbp,%rdi
   1bf09:	e8 c0 f6 ff ff       	callq  1b5ce <lv_obj_get_state>
        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);
   1bf0e:	66 8b 4c 24 0e       	mov    0xe(%rsp),%cx
   1bf13:	c1 e0 08             	shl    $0x8,%eax
        res = _lv_style_list_get_ptr(list, prop, &value_act);
   1bf16:	4c 89 fa             	mov    %r15,%rdx
   1bf19:	4c 89 f7             	mov    %r14,%rdi
        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);
   1bf1c:	8d 1c 08             	lea    (%rax,%rcx,1),%ebx
        res = _lv_style_list_get_ptr(list, prop, &value_act);
   1bf1f:	0f b7 f3             	movzwl %bx,%esi
   1bf22:	e8 bb 2e 00 00       	callq  1ede2 <_lv_style_list_get_ptr>
        if(res == LV_RES_OK)  return value_act;
   1bf27:	fe c8                	dec    %al
   1bf29:	75 07                	jne    1bf32 <_lv_obj_get_style_ptr+0xd9>
   1bf2b:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
   1bf30:	eb 36                	jmp    1bf68 <_lv_obj_get_style_ptr+0x10f>
        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;
   1bf32:	80 7c 24 0c 00       	cmpb   $0x0,0xc(%rsp)
   1bf37:	79 18                	jns    1bf51 <_lv_obj_get_style_ptr+0xf8>
        if(part != LV_OBJ_PART_MAIN) {
   1bf39:	45 84 e4             	test   %r12b,%r12b
   1bf3c:	75 0b                	jne    1bf49 <_lv_obj_get_style_ptr+0xf0>
        parent = lv_obj_get_parent(parent);
   1bf3e:	48 89 ef             	mov    %rbp,%rdi
   1bf41:	e8 d9 e8 ff ff       	callq  1a81f <lv_obj_get_parent>
   1bf46:	48 89 c5             	mov    %rax,%rbp
   1bf49:	45 31 e4             	xor    %r12d,%r12d
   1bf4c:	e9 43 ff ff ff       	jmpq   1be94 <_lv_obj_get_style_ptr+0x3b>
    prop = prop & (~LV_STYLE_STATE_MASK);
   1bf51:	80 e7 80             	and    $0x80,%bh
    switch(prop) {
   1bf54:	66 83 fb 7e          	cmp    $0x7e,%bx
   1bf58:	74 09                	je     1bf63 <_lv_obj_get_style_ptr+0x10a>
    return NULL;
   1bf5a:	31 c0                	xor    %eax,%eax
    switch(prop) {
   1bf5c:	66 81 fb 8e 80       	cmp    $0x808e,%bx
   1bf61:	75 05                	jne    1bf68 <_lv_obj_get_style_ptr+0x10f>
            return lv_theme_get_font_normal();
   1bf63:	e8 2f b6 00 00       	callq  27597 <lv_theme_get_font_normal>
}
   1bf68:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   1bf6d:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1bf74:	00 00 
   1bf76:	74 05                	je     1bf7d <_lv_obj_get_style_ptr+0x124>
   1bf78:	e8 c3 86 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1bf7d:	48 83 c4 28          	add    $0x28,%rsp
   1bf81:	5b                   	pop    %rbx
   1bf82:	5d                   	pop    %rbp
   1bf83:	41 5c                	pop    %r12
   1bf85:	41 5d                	pop    %r13
   1bf87:	41 5e                	pop    %r14
   1bf89:	41 5f                	pop    %r15
   1bf8b:	c3                   	retq   

000000000001bf8c <update_style_cache_children>:
 * Update the cache of style list
 * @param obj pointer to an object
 * @param part the part of the object
 */
static void update_style_cache_children(lv_obj_t * obj)
{
   1bf8c:	41 56                	push   %r14
   1bf8e:	41 55                	push   %r13
   1bf90:	41 54                	push   %r12
   1bf92:	55                   	push   %rbp
   1bf93:	49 89 fc             	mov    %rdi,%r12
   1bf96:	53                   	push   %rbx
   1bf97:	31 ed                	xor    %ebp,%ebp
   1bf99:	48 83 ec 10          	sub    $0x10,%rsp
    uint8_t part;
    for(part = 0; part != _LV_OBJ_PART_REAL_LAST; part++) {
        lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   1bf9d:	89 ee                	mov    %ebp,%esi
   1bf9f:	4c 89 e7             	mov    %r12,%rdi
   1bfa2:	e8 67 ea ff ff       	callq  1aa0e <lv_obj_get_style_list>
        if(list == NULL) break;
   1bfa7:	48 85 c0             	test   %rax,%rax
        lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   1bfaa:	48 89 c3             	mov    %rax,%rbx
        if(list == NULL) break;
   1bfad:	0f 84 fe 00 00 00    	je     1c0b1 <update_style_cache_children+0x125>

        bool ignore_cache_ori = list->ignore_cache;
   1bfb3:	8a 40 09             	mov    0x9(%rax),%al
_LV_OBJ_STYLE_SET_GET_DECLARE(OPA_SCALE, opa_scale, lv_opa_t, _opa, scalar)
   1bfb6:	ba 0c 80 00 00       	mov    $0x800c,%edx
   1bfbb:	89 ee                	mov    %ebp,%esi
   1bfbd:	4c 89 e7             	mov    %r12,%rdi
   1bfc0:	41 88 c5             	mov    %al,%r13b
        list->ignore_cache = 1;
   1bfc3:	83 c8 08             	or     $0x8,%eax
        bool ignore_cache_ori = list->ignore_cache;
   1bfc6:	41 c0 ed 03          	shr    $0x3,%r13b
        list->ignore_cache = 1;
   1bfca:	88 43 09             	mov    %al,0x9(%rbx)
   1bfcd:	e8 49 fd ff ff       	callq  1bd1b <_lv_obj_get_style_opa>
        bool ignore_cache_ori = list->ignore_cache;
   1bfd2:	41 83 e5 01          	and    $0x1,%r13d

        list->opa_scale_cover    = lv_obj_get_style_opa_scale(obj, part) == LV_OPA_COVER ? 1 : 0;
   1bfd6:	fe c0                	inc    %al
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_DECOR, text_decor, lv_text_decor_t, _int, scalar)
   1bfd8:	89 ee                	mov    %ebp,%esi
   1bfda:	0f 94 c0             	sete   %al
   1bfdd:	4c 89 e7             	mov    %r12,%rdi
   1bfe0:	c1 e0 05             	shl    $0x5,%eax
   1bfe3:	88 c2                	mov    %al,%dl
   1bfe5:	8a 43 09             	mov    0x9(%rbx),%al
   1bfe8:	83 e0 df             	and    $0xffffffdf,%eax
   1bfeb:	09 d0                	or     %edx,%eax
   1bfed:	ba 82 80 00 00       	mov    $0x8082,%edx
   1bff2:	88 43 09             	mov    %al,0x9(%rbx)
   1bff5:	e8 f3 f6 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
        list->text_decor_none    = lv_obj_get_style_text_decor(obj, part) == LV_TEXT_DECOR_NONE ? 1 : 0;
   1bffa:	84 c0                	test   %al,%al
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
   1bffc:	89 ee                	mov    %ebp,%esi
   1bffe:	4c 89 e7             	mov    %r12,%rdi
   1c001:	0f 94 c0             	sete   %al
   1c004:	c1 e0 06             	shl    $0x6,%eax
   1c007:	88 c2                	mov    %al,%dl
   1c009:	8a 43 0b             	mov    0xb(%rbx),%al
   1c00c:	83 e0 bf             	and    $0xffffffbf,%eax
   1c00f:	09 d0                	or     %edx,%eax
   1c011:	ba 8e 80 00 00       	mov    $0x808e,%edx
   1c016:	88 43 0b             	mov    %al,0xb(%rbx)
   1c019:	e8 3b fe ff ff       	callq  1be59 <_lv_obj_get_style_ptr>
   1c01e:	49 89 c6             	mov    %rax,%r14
        list->text_font_normal    = lv_obj_get_style_text_font(obj, part) == lv_theme_get_font_normal() ? 1 : 0;
   1c021:	e8 71 b5 00 00       	callq  27597 <lv_theme_get_font_normal>
   1c026:	4c 39 f0             	cmp    %r14,%rax
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR_OPA, image_recolor_opa, lv_opa_t, _opa, scalar)
   1c029:	89 ee                	mov    %ebp,%esi
   1c02b:	4c 89 e7             	mov    %r12,%rdi
   1c02e:	0f 94 c0             	sete   %al
   1c031:	c1 e0 07             	shl    $0x7,%eax
   1c034:	88 c2                	mov    %al,%dl
   1c036:	8a 43 0b             	mov    0xb(%rbx),%al
   1c039:	83 e0 7f             	and    $0x7f,%eax
   1c03c:	09 d0                	or     %edx,%eax
   1c03e:	ba ad 80 00 00       	mov    $0x80ad,%edx
   1c043:	88 43 0b             	mov    %al,0xb(%rbx)
   1c046:	e8 d0 fc ff ff       	callq  1bd1b <_lv_obj_get_style_opa>
        list->img_recolor_opa_transp    = lv_obj_get_style_image_recolor_opa(obj, part) == LV_OPA_TRANSP ? 1 : 0;
   1c04b:	84 c0                	test   %al,%al
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
   1c04d:	89 ee                	mov    %ebp,%esi
   1c04f:	4c 89 e7             	mov    %r12,%rdi
   1c052:	0f 94 c0             	sete   %al
   1c055:	c1 e0 04             	shl    $0x4,%eax
   1c058:	88 c2                	mov    %al,%dl
   1c05a:	8a 43 0b             	mov    0xb(%rbx),%al
   1c05d:	83 e0 ef             	and    $0xffffffef,%eax
   1c060:	09 d0                	or     %edx,%eax
   1c062:	ba 80 80 00 00       	mov    $0x8080,%edx

        list->text_space_zero = 1;
   1c067:	83 c8 20             	or     $0x20,%eax
   1c06a:	88 43 0b             	mov    %al,0xb(%rbx)
   1c06d:	e8 7b f6 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
        if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||
   1c072:	66 85 c0             	test   %ax,%ax
   1c075:	74 06                	je     1c07d <update_style_cache_children+0xf1>
           lv_obj_get_style_text_line_space(obj, part) != 0) {
            list->text_space_zero = 0;
   1c077:	80 63 0b df          	andb   $0xdf,0xb(%rbx)
   1c07b:	eb 14                	jmp    1c091 <update_style_cache_children+0x105>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
   1c07d:	ba 81 80 00 00       	mov    $0x8081,%edx
   1c082:	89 ee                	mov    %ebp,%esi
   1c084:	4c 89 e7             	mov    %r12,%rdi
   1c087:	e8 61 f6 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
        if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||
   1c08c:	66 85 c0             	test   %ax,%ax
   1c08f:	75 e6                	jne    1c077 <update_style_cache_children+0xeb>
        }

        list->ignore_cache = ignore_cache_ori;
   1c091:	8a 43 09             	mov    0x9(%rbx),%al
   1c094:	41 83 e5 01          	and    $0x1,%r13d
   1c098:	ff c5                	inc    %ebp
   1c09a:	41 c1 e5 03          	shl    $0x3,%r13d
   1c09e:	83 e0 f7             	and    $0xfffffff7,%eax
   1c0a1:	41 09 c5             	or     %eax,%r13d
    for(part = 0; part != _LV_OBJ_PART_REAL_LAST; part++) {
   1c0a4:	83 fd 40             	cmp    $0x40,%ebp
        list->ignore_cache = ignore_cache_ori;
   1c0a7:	44 88 6b 09          	mov    %r13b,0x9(%rbx)
    for(part = 0; part != _LV_OBJ_PART_REAL_LAST; part++) {
   1c0ab:	0f 85 ec fe ff ff    	jne    1bf9d <update_style_cache_children+0x11>
    }

    lv_obj_t * child = lv_obj_get_child(obj, NULL);
   1c0b1:	31 f6                	xor    %esi,%esi
    while(child) {
        update_style_cache_children(child);
        child = lv_obj_get_child(obj, child);
   1c0b3:	4c 89 e7             	mov    %r12,%rdi
   1c0b6:	e8 e4 e8 ff ff       	callq  1a99f <lv_obj_get_child>
    while(child) {
   1c0bb:	48 85 c0             	test   %rax,%rax
   1c0be:	74 17                	je     1c0d7 <update_style_cache_children+0x14b>
        update_style_cache_children(child);
   1c0c0:	48 89 c7             	mov    %rax,%rdi
   1c0c3:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   1c0c8:	e8 bf fe ff ff       	callq  1bf8c <update_style_cache_children>
        child = lv_obj_get_child(obj, child);
   1c0cd:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   1c0d2:	48 89 c6             	mov    %rax,%rsi
   1c0d5:	eb dc                	jmp    1c0b3 <update_style_cache_children+0x127>
    }

}
   1c0d7:	48 83 c4 10          	add    $0x10,%rsp
   1c0db:	5b                   	pop    %rbx
   1c0dc:	5d                   	pop    %rbp
   1c0dd:	41 5c                	pop    %r12
   1c0df:	41 5d                	pop    %r13
   1c0e1:	41 5e                	pop    %r14
   1c0e3:	c3                   	retq   

000000000001c0e4 <lv_obj_refresh_style>:
{
   1c0e4:	41 54                	push   %r12
   1c0e6:	55                   	push   %rbp
   1c0e7:	48 89 fd             	mov    %rdi,%rbp
   1c0ea:	53                   	push   %rbx
    invalidate_style_cache(obj, part, prop);
   1c0eb:	0f b7 fa             	movzwl %dx,%edi
{
   1c0ee:	89 d3                	mov    %edx,%ebx
   1c0f0:	48 83 ec 10          	sub    $0x10,%rsp
 * The cache will be updated when a cached property asked nest time
 * @param obj pointer to an object
 */
static void invalidate_style_cache(lv_obj_t * obj, uint8_t part, lv_style_property_t prop)
{
    if(style_prop_is_cacheble(prop) == false) return;
   1c0f4:	e8 54 e3 ff ff       	callq  1a44d <style_prop_is_cacheble>
   1c0f9:	84 c0                	test   %al,%al
   1c0fb:	0f 85 c0 00 00 00    	jne    1c1c1 <lv_obj_refresh_style+0xdd>
    switch(prop) {
   1c101:	66 83 fb 71          	cmp    $0x71,%bx
   1c105:	77 5c                	ja     1c163 <lv_obj_refresh_style+0x7f>
   1c107:	66 83 fb 70          	cmp    $0x70,%bx
   1c10b:	0f 83 41 01 00 00    	jae    1c252 <lv_obj_refresh_style+0x16e>
   1c111:	66 83 fb 41          	cmp    $0x41,%bx
   1c115:	77 30                	ja     1c147 <lv_obj_refresh_style+0x63>
   1c117:	66 83 fb 40          	cmp    $0x40,%bx
   1c11b:	0f 83 31 01 00 00    	jae    1c252 <lv_obj_refresh_style+0x16e>
   1c121:	66 83 fb 02          	cmp    $0x2,%bx
   1c125:	0f 82 51 01 00 00    	jb     1c27c <lv_obj_refresh_style+0x198>
   1c12b:	66 83 fb 07          	cmp    $0x7,%bx
   1c12f:	0f 86 1d 01 00 00    	jbe    1c252 <lv_obj_refresh_style+0x16e>
   1c135:	8d 43 f0             	lea    -0x10(%rbx),%eax
   1c138:	66 83 f8 08          	cmp    $0x8,%ax
   1c13c:	0f 87 3a 01 00 00    	ja     1c27c <lv_obj_refresh_style+0x198>
   1c142:	e9 0b 01 00 00       	jmpq   1c252 <lv_obj_refresh_style+0x16e>
   1c147:	66 83 fb 53          	cmp    $0x53,%bx
   1c14b:	77 10                	ja     1c15d <lv_obj_refresh_style+0x79>
   1c14d:	66 83 fb 50          	cmp    $0x50,%bx
   1c151:	0f 83 fb 00 00 00    	jae    1c252 <lv_obj_refresh_style+0x16e>
   1c157:	66 83 fb 4c          	cmp    $0x4c,%bx
   1c15b:	eb 59                	jmp    1c1b6 <lv_obj_refresh_style+0xd2>
   1c15d:	66 83 fb 5c          	cmp    $0x5c,%bx
   1c161:	eb 53                	jmp    1c1b6 <lv_obj_refresh_style+0xd2>
   1c163:	66 83 fb 7f          	cmp    $0x7f,%bx
   1c167:	77 24                	ja     1c18d <lv_obj_refresh_style+0xa9>
   1c169:	66 83 fb 7e          	cmp    $0x7e,%bx
   1c16d:	0f 83 df 00 00 00    	jae    1c252 <lv_obj_refresh_style+0x16e>
   1c173:	66 83 fb 73          	cmp    $0x73,%bx
   1c177:	0f 82 ff 00 00 00    	jb     1c27c <lv_obj_refresh_style+0x198>
   1c17d:	66 83 fb 75          	cmp    $0x75,%bx
   1c181:	0f 86 cb 00 00 00    	jbe    1c252 <lv_obj_refresh_style+0x16e>
   1c187:	66 83 fb 7c          	cmp    $0x7c,%bx
   1c18b:	eb 29                	jmp    1c1b6 <lv_obj_refresh_style+0xd2>
   1c18d:	66 81 fb 81 80       	cmp    $0x8081,%bx
   1c192:	77 1d                	ja     1c1b1 <lv_obj_refresh_style+0xcd>
   1c194:	66 81 fb 80 80       	cmp    $0x8080,%bx
   1c199:	0f 83 b3 00 00 00    	jae    1c252 <lv_obj_refresh_style+0x16e>
   1c19f:	66 81 fb 90 00       	cmp    $0x90,%bx
   1c1a4:	0f 84 a8 00 00 00    	je     1c252 <lv_obj_refresh_style+0x16e>
   1c1aa:	66 81 fb ff 00       	cmp    $0xff,%bx
   1c1af:	eb 05                	jmp    1c1b6 <lv_obj_refresh_style+0xd2>
   1c1b1:	66 81 fb 8e 80       	cmp    $0x808e,%bx
   1c1b6:	0f 85 c0 00 00 00    	jne    1c27c <lv_obj_refresh_style+0x198>
   1c1bc:	e9 91 00 00 00       	jmpq   1c252 <lv_obj_refresh_style+0x16e>

    if(part != LV_OBJ_PART_ALL) {
   1c1c1:	45 31 e4             	xor    %r12d,%r12d
   1c1c4:	40 80 fe ff          	cmp    $0xff,%sil
   1c1c8:	74 28                	je     1c1f2 <lv_obj_refresh_style+0x10e>
    invalidate_style_cache(obj, part, prop);
   1c1ca:	40 0f b6 f6          	movzbl %sil,%esi
        lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   1c1ce:	48 89 ef             	mov    %rbp,%rdi
   1c1d1:	e8 38 e8 ff ff       	callq  1aa0e <lv_obj_get_style_list>
        if(list == NULL) return;
   1c1d6:	48 85 c0             	test   %rax,%rax
   1c1d9:	0f 84 22 ff ff ff    	je     1c101 <lv_obj_refresh_style+0x1d>
        list->valid_cache = 0;
   1c1df:	80 60 09 fb          	andb   $0xfb,0x9(%rax)
   1c1e3:	eb 43                	jmp    1c228 <lv_obj_refresh_style+0x144>
   1c1e5:	41 ff c4             	inc    %r12d
    else {

        for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {
            lv_style_list_t * list = lv_obj_get_style_list(obj, part);
            if(list == NULL) break;
            list->valid_cache = 0;
   1c1e8:	80 60 09 fb          	andb   $0xfb,0x9(%rax)
        for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {
   1c1ec:	41 83 fc 40          	cmp    $0x40,%r12d
   1c1f0:	74 10                	je     1c202 <lv_obj_refresh_style+0x11e>
            lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   1c1f2:	44 89 e6             	mov    %r12d,%esi
   1c1f5:	48 89 ef             	mov    %rbp,%rdi
   1c1f8:	e8 11 e8 ff ff       	callq  1aa0e <lv_obj_get_style_list>
            if(list == NULL) break;
   1c1fd:	48 85 c0             	test   %rax,%rax
   1c200:	75 e3                	jne    1c1e5 <lv_obj_refresh_style+0x101>
    if(part != LV_OBJ_PART_ALL) {
   1c202:	41 bc 40 00 00 00    	mov    $0x40,%r12d
        }
        for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {
            lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   1c208:	44 89 e6             	mov    %r12d,%esi
   1c20b:	48 89 ef             	mov    %rbp,%rdi
   1c20e:	e8 fb e7 ff ff       	callq  1aa0e <lv_obj_get_style_list>
            if(list == NULL) break;
   1c213:	48 85 c0             	test   %rax,%rax
   1c216:	74 10                	je     1c228 <lv_obj_refresh_style+0x144>
   1c218:	41 ff c4             	inc    %r12d
            list->valid_cache = 0;
   1c21b:	80 60 09 fb          	andb   $0xfb,0x9(%rax)
        for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {
   1c21f:	41 81 fc ff 00 00 00 	cmp    $0xff,%r12d
   1c226:	75 e0                	jne    1c208 <lv_obj_refresh_style+0x124>
        }
    }

    lv_obj_t * child = lv_obj_get_child(obj, NULL);
   1c228:	31 f6                	xor    %esi,%esi
    while(child) {
        update_style_cache_children(child);
        child = lv_obj_get_child(obj, child);
   1c22a:	48 89 ef             	mov    %rbp,%rdi
   1c22d:	e8 6d e7 ff ff       	callq  1a99f <lv_obj_get_child>
    while(child) {
   1c232:	48 85 c0             	test   %rax,%rax
   1c235:	0f 84 c6 fe ff ff    	je     1c101 <lv_obj_refresh_style+0x1d>
        update_style_cache_children(child);
   1c23b:	48 89 c7             	mov    %rax,%rdi
   1c23e:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   1c243:	e8 44 fd ff ff       	callq  1bf8c <update_style_cache_children>
        child = lv_obj_get_child(obj, child);
   1c248:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   1c24d:	48 89 c6             	mov    %rax,%rsi
   1c250:	eb d8                	jmp    1c22a <lv_obj_refresh_style+0x146>
        lv_obj_invalidate(obj);
   1c252:	48 89 ef             	mov    %rbp,%rdi
   1c255:	e8 58 ea ff ff       	callq  1acb2 <lv_obj_invalidate>
        obj->signal_cb(obj, LV_SIGNAL_STYLE_CHG, NULL);
   1c25a:	31 d2                	xor    %edx,%edx
   1c25c:	be 04 00 00 00       	mov    $0x4,%esi
   1c261:	48 89 ef             	mov    %rbp,%rdi
   1c264:	ff 55 30             	callq  *0x30(%rbp)
        switch(prop) {
   1c267:	66 83 fb 15          	cmp    $0x15,%bx
   1c26b:	72 35                	jb     1c2a2 <lv_obj_refresh_style+0x1be>
   1c26d:	66 83 fb 18          	cmp    $0x18,%bx
   1c271:	76 19                	jbe    1c28c <lv_obj_refresh_style+0x1a8>
   1c273:	66 81 fb ff 00       	cmp    $0xff,%bx
   1c278:	74 12                	je     1c28c <lv_obj_refresh_style+0x1a8>
   1c27a:	eb 26                	jmp    1c2a2 <lv_obj_refresh_style+0x1be>
}
   1c27c:	48 83 c4 10          	add    $0x10,%rsp
        lv_obj_invalidate(obj);
   1c280:	48 89 ef             	mov    %rbp,%rdi
}
   1c283:	5b                   	pop    %rbx
   1c284:	5d                   	pop    %rbp
   1c285:	41 5c                	pop    %r12
        lv_obj_invalidate(obj);
   1c287:	e9 26 ea ff ff       	jmpq   1acb2 <lv_obj_invalidate>
                if(obj->parent) obj->parent->signal_cb(obj->parent, LV_SIGNAL_CHILD_CHG, NULL);
   1c28c:	48 8b 45 00          	mov    0x0(%rbp),%rax
   1c290:	48 85 c0             	test   %rax,%rax
   1c293:	74 0d                	je     1c2a2 <lv_obj_refresh_style+0x1be>
   1c295:	31 d2                	xor    %edx,%edx
   1c297:	be 01 00 00 00       	mov    $0x1,%esi
   1c29c:	48 89 c7             	mov    %rax,%rdi
   1c29f:	ff 50 30             	callq  *0x30(%rax)
        lv_obj_invalidate(obj);
   1c2a2:	48 89 ef             	mov    %rbp,%rdi
   1c2a5:	e8 08 ea ff ff       	callq  1acb2 <lv_obj_invalidate>
        if(prop == LV_STYLE_PROP_ALL || (prop & LV_STYLE_INHERIT_MASK)) refresh_children_style(obj);
   1c2aa:	66 81 fb ff 00       	cmp    $0xff,%bx
   1c2af:	74 05                	je     1c2b6 <lv_obj_refresh_style+0x1d2>
   1c2b1:	66 85 db             	test   %bx,%bx
   1c2b4:	79 10                	jns    1c2c6 <lv_obj_refresh_style+0x1e2>
}
   1c2b6:	48 83 c4 10          	add    $0x10,%rsp
        if(prop == LV_STYLE_PROP_ALL || (prop & LV_STYLE_INHERIT_MASK)) refresh_children_style(obj);
   1c2ba:	48 89 ef             	mov    %rbp,%rdi
}
   1c2bd:	5b                   	pop    %rbx
   1c2be:	5d                   	pop    %rbp
   1c2bf:	41 5c                	pop    %r12
        if(prop == LV_STYLE_PROP_ALL || (prop & LV_STYLE_INHERIT_MASK)) refresh_children_style(obj);
   1c2c1:	e9 48 ed ff ff       	jmpq   1b00e <refresh_children_style>
}
   1c2c6:	48 83 c4 10          	add    $0x10,%rsp
   1c2ca:	5b                   	pop    %rbx
   1c2cb:	5d                   	pop    %rbp
   1c2cc:	41 5c                	pop    %r12
   1c2ce:	c3                   	retq   

000000000001c2cf <lv_obj_reset_style_list>:
{
   1c2cf:	55                   	push   %rbp
   1c2d0:	53                   	push   %rbx
    lv_obj_clean_style_list(obj, part);
   1c2d1:	40 0f b6 de          	movzbl %sil,%ebx
{
   1c2d5:	48 89 fd             	mov    %rdi,%rbp
    lv_obj_clean_style_list(obj, part);
   1c2d8:	89 de                	mov    %ebx,%esi
{
   1c2da:	48 83 ec 08          	sub    $0x8,%rsp
    lv_obj_clean_style_list(obj, part);
   1c2de:	e8 8f e7 ff ff       	callq  1aa72 <lv_obj_clean_style_list>
}
   1c2e3:	58                   	pop    %rax
    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);
   1c2e4:	89 de                	mov    %ebx,%esi
   1c2e6:	48 89 ef             	mov    %rbp,%rdi
   1c2e9:	ba ff 00 00 00       	mov    $0xff,%edx
}
   1c2ee:	5b                   	pop    %rbx
   1c2ef:	5d                   	pop    %rbp
    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);
   1c2f0:	e9 ef fd ff ff       	jmpq   1c0e4 <lv_obj_refresh_style>

000000000001c2f5 <lv_obj_get_signal_cb>:
    return obj->signal_cb;
   1c2f5:	48 8b 47 30          	mov    0x30(%rdi),%rax
}
   1c2f9:	c3                   	retq   

000000000001c2fa <lv_obj_get_design_cb>:
    return obj->design_cb;
   1c2fa:	48 8b 47 38          	mov    0x38(%rdi),%rax
}
   1c2fe:	c3                   	retq   

000000000001c2ff <lv_obj_get_ext_attr>:
    return obj->ext_attr;
   1c2ff:	48 8b 47 40          	mov    0x40(%rdi),%rax
}
   1c303:	c3                   	retq   

000000000001c304 <lv_obj_is_point_on_coords>:
    if(!_lv_area_is_point_on(&obj->coords, point, 0)) {
   1c304:	48 83 c7 20          	add    $0x20,%rdi
   1c308:	31 d2                	xor    %edx,%edx
   1c30a:	e9 ab 92 00 00       	jmpq   255ba <_lv_area_is_point_on>

000000000001c30f <lv_obj_hittest>:
{
   1c30f:	48 83 ec 28          	sub    $0x28,%rsp
   1c313:	48 89 f8             	mov    %rdi,%rax
   1c316:	64 48 8b 0c 25 28 00 	mov    %fs:0x28,%rcx
   1c31d:	00 00 
   1c31f:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
   1c324:	31 c9                	xor    %ecx,%ecx
    if(obj->adv_hittest) {
   1c326:	80 7f 5a 00          	cmpb   $0x0,0x5a(%rdi)
   1c32a:	79 1d                	jns    1c349 <lv_obj_hittest+0x3a>
        hit_info.point = point;
   1c32c:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
        hit_info.result = true;
   1c331:	c6 44 24 10 01       	movb   $0x1,0x10(%rsp)
        obj->signal_cb(obj, LV_SIGNAL_HIT_TEST, &hit_info);
   1c336:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
   1c33b:	be 0a 00 00 00       	mov    $0xa,%esi
   1c340:	ff 50 30             	callq  *0x30(%rax)
        return hit_info.result;
   1c343:	8a 44 24 10          	mov    0x10(%rsp),%al
   1c347:	eb 05                	jmp    1c34e <lv_obj_hittest+0x3f>
        return lv_obj_is_point_on_coords(obj, point);
   1c349:	e8 b6 ff ff ff       	callq  1c304 <lv_obj_is_point_on_coords>
}
   1c34e:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   1c353:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1c35a:	00 00 
   1c35c:	74 05                	je     1c363 <lv_obj_hittest+0x54>
   1c35e:	e8 dd 82 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1c363:	48 83 c4 28          	add    $0x28,%rsp
   1c367:	c3                   	retq   

000000000001c368 <lv_obj_handle_get_type_signal>:
{
   1c368:	31 c0                	xor    %eax,%eax
        if(buf->type[i] == NULL) break;
   1c36a:	48 83 3c c7 00       	cmpq   $0x0,(%rdi,%rax,8)
   1c36f:	0f b6 d0             	movzbl %al,%edx
   1c372:	74 0e                	je     1c382 <lv_obj_handle_get_type_signal+0x1a>
   1c374:	48 ff c0             	inc    %rax
    for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
   1c377:	48 83 f8 07          	cmp    $0x7,%rax
   1c37b:	75 ed                	jne    1c36a <lv_obj_handle_get_type_signal+0x2>
   1c37d:	ba 07 00 00 00       	mov    $0x7,%edx
    buf->type[i] = name;
   1c382:	48 89 34 d7          	mov    %rsi,(%rdi,%rdx,8)
}
   1c386:	b0 01                	mov    $0x1,%al
   1c388:	c3                   	retq   

000000000001c389 <lv_obj_init_draw_rect_dsc>:
{
   1c389:	41 54                	push   %r12
   1c38b:	55                   	push   %rbp
    draw_dsc->radius = lv_obj_get_style_radius(obj, part);
   1c38c:	40 0f b6 ee          	movzbl %sil,%ebp
{
   1c390:	53                   	push   %rbx
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
   1c391:	89 ee                	mov    %ebp,%esi
   1c393:	48 89 d3             	mov    %rdx,%rbx
   1c396:	ba 01 00 00 00       	mov    $0x1,%edx
   1c39b:	49 89 fc             	mov    %rdi,%r12
   1c39e:	e8 4a f3 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    if(draw_dsc->bg_opa != LV_OPA_TRANSP) {
   1c3a3:	80 7b 12 00          	cmpb   $0x0,0x12(%rbx)
    draw_dsc->radius = lv_obj_get_style_radius(obj, part);
   1c3a7:	66 89 03             	mov    %ax,(%rbx)
    if(draw_dsc->bg_opa != LV_OPA_TRANSP) {
   1c3aa:	74 76                	je     1c422 <lv_obj_init_draw_rect_dsc+0x99>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
   1c3ac:	ba 2c 00 00 00       	mov    $0x2c,%edx
   1c3b1:	89 ee                	mov    %ebp,%esi
   1c3b3:	4c 89 e7             	mov    %r12,%rdi
   1c3b6:	e8 60 f9 ff ff       	callq  1bd1b <_lv_obj_get_style_opa>
        if(draw_dsc->bg_opa > LV_OPA_MIN) {
   1c3bb:	3c 02                	cmp    $0x2,%al
        draw_dsc->bg_opa = lv_obj_get_style_bg_opa(obj, part);
   1c3bd:	88 43 12             	mov    %al,0x12(%rbx)
        if(draw_dsc->bg_opa > LV_OPA_MIN) {
   1c3c0:	76 60                	jbe    1c422 <lv_obj_init_draw_rect_dsc+0x99>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
   1c3c2:	ba 29 00 00 00       	mov    $0x29,%edx
   1c3c7:	89 ee                	mov    %ebp,%esi
   1c3c9:	4c 89 e7             	mov    %r12,%rdi
   1c3cc:	e8 53 f2 ff ff       	callq  1b624 <_lv_obj_get_style_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_DIR, bg_grad_dir, lv_grad_dir_t, _int, scalar)
   1c3d1:	ba 23 00 00 00       	mov    $0x23,%edx
            draw_dsc->bg_color = lv_obj_get_style_bg_color(obj, part);
   1c3d6:	89 43 04             	mov    %eax,0x4(%rbx)
   1c3d9:	89 ee                	mov    %ebp,%esi
   1c3db:	4c 89 e7             	mov    %r12,%rdi
   1c3de:	e8 0a f3 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
            if(draw_dsc->bg_grad_dir != LV_GRAD_DIR_NONE) {
   1c3e3:	84 c0                	test   %al,%al
            draw_dsc->bg_grad_dir =  lv_obj_get_style_bg_grad_dir(obj, part);
   1c3e5:	88 43 0c             	mov    %al,0xc(%rbx)
            if(draw_dsc->bg_grad_dir != LV_GRAD_DIR_NONE) {
   1c3e8:	74 38                	je     1c422 <lv_obj_init_draw_rect_dsc+0x99>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_COLOR, bg_grad_color, lv_color_t, _color, nonscalar)
   1c3ea:	ba 2a 00 00 00       	mov    $0x2a,%edx
   1c3ef:	89 ee                	mov    %ebp,%esi
   1c3f1:	4c 89 e7             	mov    %r12,%rdi
   1c3f4:	e8 2b f2 ff ff       	callq  1b624 <_lv_obj_get_style_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_MAIN_STOP, bg_main_stop, lv_style_int_t, _int, scalar)
   1c3f9:	ba 21 00 00 00       	mov    $0x21,%edx
   1c3fe:	89 ee                	mov    %ebp,%esi
   1c400:	4c 89 e7             	mov    %r12,%rdi
                draw_dsc->bg_grad_color = lv_obj_get_style_bg_grad_color(obj, part);
   1c403:	89 43 08             	mov    %eax,0x8(%rbx)
   1c406:	e8 e2 f2 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_STOP, bg_grad_stop, lv_style_int_t, _int, scalar)
   1c40b:	ba 22 00 00 00       	mov    $0x22,%edx
                draw_dsc->bg_main_color_stop =  lv_obj_get_style_bg_main_stop(obj, part);
   1c410:	66 89 43 0e          	mov    %ax,0xe(%rbx)
   1c414:	89 ee                	mov    %ebp,%esi
   1c416:	4c 89 e7             	mov    %r12,%rdi
   1c419:	e8 cf f2 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
                draw_dsc->bg_grad_color_stop =  lv_obj_get_style_bg_grad_stop(obj, part);
   1c41e:	66 89 43 10          	mov    %ax,0x10(%rbx)
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_WIDTH, border_width, lv_style_int_t, _int, scalar)
   1c422:	ba 30 00 00 00       	mov    $0x30,%edx
   1c427:	89 ee                	mov    %ebp,%esi
   1c429:	4c 89 e7             	mov    %r12,%rdi
   1c42c:	e8 bc f2 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    if(draw_dsc->border_width) {
   1c431:	66 85 c0             	test   %ax,%ax
    draw_dsc->border_width = lv_obj_get_style_border_width(obj, part);
   1c434:	66 89 43 18          	mov    %ax,0x18(%rbx)
    if(draw_dsc->border_width) {
   1c438:	74 45                	je     1c47f <lv_obj_init_draw_rect_dsc+0xf6>
        if(draw_dsc->border_opa != LV_OPA_TRANSP) {
   1c43a:	80 7b 1c 00          	cmpb   $0x0,0x1c(%rbx)
   1c43e:	74 3f                	je     1c47f <lv_obj_init_draw_rect_dsc+0xf6>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_OPA, border_opa, lv_opa_t, _opa, scalar)
   1c440:	ba 3c 00 00 00       	mov    $0x3c,%edx
   1c445:	89 ee                	mov    %ebp,%esi
   1c447:	4c 89 e7             	mov    %r12,%rdi
   1c44a:	e8 cc f8 ff ff       	callq  1bd1b <_lv_obj_get_style_opa>
            if(draw_dsc->border_opa > LV_OPA_MIN) {
   1c44f:	3c 02                	cmp    $0x2,%al
            draw_dsc->border_opa = lv_obj_get_style_border_opa(obj, part);
   1c451:	88 43 1c             	mov    %al,0x1c(%rbx)
            if(draw_dsc->border_opa > LV_OPA_MIN) {
   1c454:	76 29                	jbe    1c47f <lv_obj_init_draw_rect_dsc+0xf6>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_SIDE, border_side, lv_border_side_t, _int, scalar)
   1c456:	ba 31 00 00 00       	mov    $0x31,%edx
   1c45b:	89 ee                	mov    %ebp,%esi
   1c45d:	4c 89 e7             	mov    %r12,%rdi
   1c460:	e8 88 f2 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
                draw_dsc->border_side = lv_obj_get_style_border_side(obj, part);
   1c465:	66 25 ff 00          	and    $0xff,%ax
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_COLOR, border_color, lv_color_t, _color, nonscalar)
   1c469:	ba 39 00 00 00       	mov    $0x39,%edx
   1c46e:	89 ee                	mov    %ebp,%esi
   1c470:	66 89 43 1a          	mov    %ax,0x1a(%rbx)
   1c474:	4c 89 e7             	mov    %r12,%rdi
   1c477:	e8 a8 f1 ff ff       	callq  1b624 <_lv_obj_get_style_color>
                draw_dsc->border_color = lv_obj_get_style_border_color(obj, part);
   1c47c:	89 43 14             	mov    %eax,0x14(%rbx)
}
   1c47f:	5b                   	pop    %rbx
   1c480:	5d                   	pop    %rbp
   1c481:	41 5c                	pop    %r12
   1c483:	c3                   	retq   

000000000001c484 <lv_obj_design>:
{
   1c484:	41 56                	push   %r14
   1c486:	41 55                	push   %r13
   1c488:	41 54                	push   %r12
   1c48a:	55                   	push   %rbp
   1c48b:	48 89 f5             	mov    %rsi,%rbp
   1c48e:	53                   	push   %rbx
   1c48f:	48 89 fb             	mov    %rdi,%rbx
   1c492:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
   1c499:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1c4a0:	00 00 
   1c4a2:	48 89 84 24 98 00 00 	mov    %rax,0x98(%rsp)
   1c4a9:	00 
   1c4aa:	31 c0                	xor    %eax,%eax
    if(mode == LV_DESIGN_COVER_CHK) {
   1c4ac:	80 fa 02             	cmp    $0x2,%dl
   1c4af:	0f 85 db 00 00 00    	jne    1c590 <lv_obj_design+0x10c>
        if(lv_obj_get_style_clip_corner(obj, LV_OBJ_PART_MAIN)) return LV_DESIGN_RES_MASKED;
   1c4b5:	31 f6                	xor    %esi,%esi
   1c4b7:	e8 85 f4 ff ff       	callq  1b941 <lv_obj_get_style_clip_corner>
   1c4bc:	84 c0                	test   %al,%al
   1c4be:	b2 03                	mov    $0x3,%dl
   1c4c0:	0f 85 bf 02 00 00    	jne    1c785 <lv_obj_design+0x301>
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
   1c4c6:	31 f6                	xor    %esi,%esi
   1c4c8:	ba 01 00 00 00       	mov    $0x1,%edx
   1c4cd:	48 89 df             	mov    %rbx,%rdi
   1c4d0:	e8 18 f2 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   1c4d5:	31 f6                	xor    %esi,%esi
   1c4d7:	ba 04 00 00 00       	mov    $0x4,%edx
   1c4dc:	48 89 df             	mov    %rbx,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
   1c4df:	41 89 c4             	mov    %eax,%r12d
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   1c4e2:	e8 06 f2 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   1c4e7:	31 f6                	xor    %esi,%esi
   1c4e9:	ba 05 00 00 00       	mov    $0x5,%edx
   1c4ee:	48 89 df             	mov    %rbx,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   1c4f1:	41 89 c5             	mov    %eax,%r13d
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   1c4f4:	e8 f4 f1 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
        lv_area_copy(&coords, &obj->coords);
   1c4f9:	48 8d 4c 24 18       	lea    0x18(%rsp),%rcx
   1c4fe:	48 8d 73 20          	lea    0x20(%rbx),%rsi
   1c502:	89 c2                	mov    %eax,%edx
   1c504:	48 89 cf             	mov    %rcx,%rdi
   1c507:	e8 7a e0 ff ff       	callq  1a586 <lv_area_copy>
        if(_lv_area_is_in(clip_area, &coords, r) == false) return LV_DESIGN_RES_NOT_COVER;
   1c50c:	48 89 ef             	mov    %rbp,%rdi
        coords.y1 -= h;
   1c50f:	66 29 54 24 1a       	sub    %dx,0x1a(%rsp)
        coords.y2 += h;
   1c514:	66 01 54 24 1e       	add    %dx,0x1e(%rsp)
        if(_lv_area_is_in(clip_area, &coords, r) == false) return LV_DESIGN_RES_NOT_COVER;
   1c519:	48 89 ce             	mov    %rcx,%rsi
   1c51c:	41 0f bf d4          	movswl %r12w,%edx
        coords.x1 -= w;
   1c520:	66 44 29 6c 24 18    	sub    %r13w,0x18(%rsp)
        coords.x2 += w;
   1c526:	66 44 01 6c 24 1c    	add    %r13w,0x1c(%rsp)
        if(_lv_area_is_in(clip_area, &coords, r) == false) return LV_DESIGN_RES_NOT_COVER;
   1c52c:	e8 8a 92 00 00       	callq  257bb <_lv_area_is_in>
   1c531:	84 c0                	test   %al,%al
   1c533:	75 07                	jne    1c53c <lv_obj_design+0xb8>
   1c535:	b2 02                	mov    $0x2,%dl
   1c537:	e9 49 02 00 00       	jmpq   1c785 <lv_obj_design+0x301>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
   1c53c:	31 f6                	xor    %esi,%esi
   1c53e:	ba 2c 00 00 00       	mov    $0x2c,%edx
   1c543:	48 89 df             	mov    %rbx,%rdi
   1c546:	e8 d0 f7 ff ff       	callq  1bd1b <_lv_obj_get_style_opa>
        if(lv_obj_get_style_bg_opa(obj, LV_OBJ_PART_MAIN) < LV_OPA_MAX) return LV_DESIGN_RES_NOT_COVER;
   1c54b:	3c fc                	cmp    $0xfc,%al
   1c54d:	76 e6                	jbe    1c535 <lv_obj_design+0xb1>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_BLEND_MODE, bg_blend_mode, lv_blend_mode_t, _int, scalar)
   1c54f:	31 f6                	xor    %esi,%esi
   1c551:	ba 20 00 00 00       	mov    $0x20,%edx
   1c556:	48 89 df             	mov    %rbx,%rdi
   1c559:	e8 8f f1 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
        if(lv_obj_get_style_bg_blend_mode(obj, LV_OBJ_PART_MAIN) != LV_BLEND_MODE_NORMAL) return LV_DESIGN_RES_NOT_COVER;
   1c55e:	84 c0                	test   %al,%al
   1c560:	75 d3                	jne    1c535 <lv_obj_design+0xb1>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_BLEND_MODE, border_blend_mode, lv_blend_mode_t, _int, scalar)
   1c562:	31 f6                	xor    %esi,%esi
   1c564:	ba 32 00 00 00       	mov    $0x32,%edx
   1c569:	48 89 df             	mov    %rbx,%rdi
   1c56c:	e8 7c f1 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
        if(lv_obj_get_style_border_blend_mode(obj, LV_OBJ_PART_MAIN) != LV_BLEND_MODE_NORMAL) return LV_DESIGN_RES_NOT_COVER;
   1c571:	84 c0                	test   %al,%al
   1c573:	75 c0                	jne    1c535 <lv_obj_design+0xb1>
_LV_OBJ_STYLE_SET_GET_DECLARE(OPA_SCALE, opa_scale, lv_opa_t, _opa, scalar)
   1c575:	ba 0c 80 00 00       	mov    $0x800c,%edx
   1c57a:	31 f6                	xor    %esi,%esi
   1c57c:	48 89 df             	mov    %rbx,%rdi
   1c57f:	e8 97 f7 ff ff       	callq  1bd1b <_lv_obj_get_style_opa>
        if(lv_obj_get_style_opa_scale(obj, LV_OBJ_PART_MAIN) < LV_OPA_MAX) return LV_DESIGN_RES_NOT_COVER;
   1c584:	3c fc                	cmp    $0xfc,%al
        return  LV_DESIGN_RES_COVER;
   1c586:	b2 01                	mov    $0x1,%dl
        if(lv_obj_get_style_opa_scale(obj, LV_OBJ_PART_MAIN) < LV_OPA_MAX) return LV_DESIGN_RES_NOT_COVER;
   1c588:	0f 87 f7 01 00 00    	ja     1c785 <lv_obj_design+0x301>
   1c58e:	eb a5                	jmp    1c535 <lv_obj_design+0xb1>
    else if(mode == LV_DESIGN_DRAW_MAIN) {
   1c590:	84 d2                	test   %dl,%dl
   1c592:	0f 85 26 01 00 00    	jne    1c6be <lv_obj_design+0x23a>
        lv_draw_rect_dsc_init(&draw_dsc);
   1c598:	4c 8d 6c 24 18       	lea    0x18(%rsp),%r13
   1c59d:	4c 89 ef             	mov    %r13,%rdi
   1c5a0:	e8 9c 6b 00 00       	callq  23141 <lv_draw_rect_dsc_init>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_POST, border_post, bool, _int, scalar)
   1c5a5:	31 f6                	xor    %esi,%esi
   1c5a7:	ba 33 00 00 00       	mov    $0x33,%edx
   1c5ac:	48 89 df             	mov    %rbx,%rdi
   1c5af:	e8 39 f1 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
        if(lv_obj_get_style_border_post(obj, LV_OBJ_PART_MAIN)) {
   1c5b4:	66 85 c0             	test   %ax,%ax
   1c5b7:	74 05                	je     1c5be <lv_obj_design+0x13a>
            draw_dsc.border_post = 1;
   1c5b9:	80 4c 24 36 01       	orb    $0x1,0x36(%rsp)
        lv_obj_init_draw_rect_dsc(obj, LV_OBJ_PART_MAIN, &draw_dsc);
   1c5be:	31 f6                	xor    %esi,%esi
   1c5c0:	4c 89 ea             	mov    %r13,%rdx
   1c5c3:	48 89 df             	mov    %rbx,%rdi
   1c5c6:	e8 be fd ff ff       	callq  1c389 <lv_obj_init_draw_rect_dsc>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   1c5cb:	31 f6                	xor    %esi,%esi
   1c5cd:	ba 04 00 00 00       	mov    $0x4,%edx
   1c5d2:	48 89 df             	mov    %rbx,%rdi
   1c5d5:	e8 13 f1 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   1c5da:	31 f6                	xor    %esi,%esi
   1c5dc:	ba 05 00 00 00       	mov    $0x5,%edx
   1c5e1:	48 89 df             	mov    %rbx,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   1c5e4:	41 89 c6             	mov    %eax,%r14d
        lv_area_copy(&coords, &obj->coords);
   1c5e7:	4c 8d 63 20          	lea    0x20(%rbx),%r12
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   1c5eb:	e8 fd f0 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
   1c5f0:	48 8d 4c 24 08       	lea    0x8(%rsp),%rcx
   1c5f5:	4c 89 e6             	mov    %r12,%rsi
   1c5f8:	89 c2                	mov    %eax,%edx
   1c5fa:	48 89 cf             	mov    %rcx,%rdi
   1c5fd:	e8 84 df ff ff       	callq  1a586 <lv_area_copy>
        lv_draw_rect(&coords, clip_area, &draw_dsc);
   1c602:	48 89 ee             	mov    %rbp,%rsi
        coords.y1 -= h;
   1c605:	66 29 54 24 0a       	sub    %dx,0xa(%rsp)
        coords.y2 += h;
   1c60a:	66 01 54 24 0e       	add    %dx,0xe(%rsp)
        lv_draw_rect(&coords, clip_area, &draw_dsc);
   1c60f:	4c 89 ea             	mov    %r13,%rdx
        coords.x1 -= w;
   1c612:	66 44 29 74 24 08    	sub    %r14w,0x8(%rsp)
        coords.x2 += w;
   1c618:	66 44 01 74 24 0c    	add    %r14w,0xc(%rsp)
        lv_draw_rect(&coords, clip_area, &draw_dsc);
   1c61e:	e8 88 6b 00 00       	callq  231ab <lv_draw_rect>
        if(lv_obj_get_style_clip_corner(obj, LV_OBJ_PART_MAIN)) {
   1c623:	31 f6                	xor    %esi,%esi
   1c625:	48 89 df             	mov    %rbx,%rdi
   1c628:	e8 14 f3 ff ff       	callq  1b941 <lv_obj_get_style_clip_corner>
   1c62d:	84 c0                	test   %al,%al
   1c62f:	0f 84 4e 01 00 00    	je     1c783 <lv_obj_design+0x2ff>
            lv_draw_mask_radius_param_t * mp = _lv_mem_buf_get(sizeof(lv_draw_mask_radius_param_t));
   1c635:	bf 28 00 00 00       	mov    $0x28,%edi
   1c63a:	e8 9f 9b 00 00       	callq  261de <_lv_mem_buf_get>
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
   1c63f:	ba 01 00 00 00       	mov    $0x1,%edx
   1c644:	31 f6                	xor    %esi,%esi
   1c646:	48 89 df             	mov    %rbx,%rdi
   1c649:	48 89 c5             	mov    %rax,%rbp
   1c64c:	e8 9c f0 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
            if(draw_dsc.border_post && draw_dsc.border_opa >= LV_OPA_MIN && draw_dsc.border_width > 0) {
   1c651:	f6 44 24 36 01       	testb  $0x1,0x36(%rsp)
   1c656:	0f bf d0             	movswl %ax,%edx
   1c659:	74 42                	je     1c69d <lv_obj_design+0x219>
   1c65b:	80 7c 24 34 01       	cmpb   $0x1,0x34(%rsp)
   1c660:	76 3b                	jbe    1c69d <lv_obj_design+0x219>
   1c662:	66 83 7c 24 30 00    	cmpw   $0x0,0x30(%rsp)
   1c668:	7e 33                	jle    1c69d <lv_obj_design+0x219>
                cc_area.x1 = obj->coords.x1 + 1;
   1c66a:	8b 43 20             	mov    0x20(%rbx),%eax
                lv_draw_mask_radius_init(mp, &cc_area, r, false);
   1c66d:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
   1c672:	31 c9                	xor    %ecx,%ecx
                cc_area.x1 = obj->coords.x1 + 1;
   1c674:	ff c0                	inc    %eax
   1c676:	66 89 44 24 10       	mov    %ax,0x10(%rsp)
                cc_area.y1 = obj->coords.y1 + 1;
   1c67b:	66 8b 43 22          	mov    0x22(%rbx),%ax
   1c67f:	ff c0                	inc    %eax
   1c681:	66 89 44 24 12       	mov    %ax,0x12(%rsp)
                cc_area.x2 = obj->coords.x2 - 1;
   1c686:	8b 43 24             	mov    0x24(%rbx),%eax
   1c689:	ff c8                	dec    %eax
   1c68b:	66 89 44 24 14       	mov    %ax,0x14(%rsp)
                cc_area.y2 = obj->coords.y2 - 1;
   1c690:	66 8b 43 26          	mov    0x26(%rbx),%ax
   1c694:	ff c8                	dec    %eax
   1c696:	66 89 44 24 16       	mov    %ax,0x16(%rsp)
   1c69b:	eb 05                	jmp    1c6a2 <lv_obj_design+0x21e>
                lv_draw_mask_radius_init(mp, &obj->coords, r, false);
   1c69d:	31 c9                	xor    %ecx,%ecx
   1c69f:	4c 89 e6             	mov    %r12,%rsi
   1c6a2:	48 89 ef             	mov    %rbp,%rdi
   1c6a5:	e8 6f 69 00 00       	callq  23019 <lv_draw_mask_radius_init>
            lv_draw_mask_add(mp, obj + 8);
   1c6aa:	48 8d b3 40 03 00 00 	lea    0x340(%rbx),%rsi
   1c6b1:	48 89 ef             	mov    %rbp,%rdi
   1c6b4:	e8 a7 66 00 00       	callq  22d60 <lv_draw_mask_add>
   1c6b9:	e9 c5 00 00 00       	jmpq   1c783 <lv_obj_design+0x2ff>
    else if(mode == LV_DESIGN_DRAW_POST) {
   1c6be:	fe ca                	dec    %dl
   1c6c0:	0f 85 bd 00 00 00    	jne    1c783 <lv_obj_design+0x2ff>
        if(lv_obj_get_style_clip_corner(obj, LV_OBJ_PART_MAIN)) {
   1c6c6:	31 f6                	xor    %esi,%esi
   1c6c8:	e8 74 f2 ff ff       	callq  1b941 <lv_obj_get_style_clip_corner>
   1c6cd:	84 c0                	test   %al,%al
   1c6cf:	74 14                	je     1c6e5 <lv_obj_design+0x261>
            lv_draw_mask_radius_param_t * param = lv_draw_mask_remove_custom(obj + 8);
   1c6d1:	48 8d bb 40 03 00 00 	lea    0x340(%rbx),%rdi
   1c6d8:	e8 72 67 00 00       	callq  22e4f <lv_draw_mask_remove_custom>
            _lv_mem_buf_release(param);
   1c6dd:	48 89 c7             	mov    %rax,%rdi
   1c6e0:	e8 e8 9b 00 00       	callq  262cd <_lv_mem_buf_release>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_POST, border_post, bool, _int, scalar)
   1c6e5:	31 f6                	xor    %esi,%esi
   1c6e7:	ba 33 00 00 00       	mov    $0x33,%edx
   1c6ec:	48 89 df             	mov    %rbx,%rdi
   1c6ef:	e8 f9 ef ff ff       	callq  1b6ed <_lv_obj_get_style_int>
        if(lv_obj_get_style_border_post(obj, LV_OBJ_PART_MAIN)) {
   1c6f4:	66 85 c0             	test   %ax,%ax
   1c6f7:	0f 84 86 00 00 00    	je     1c783 <lv_obj_design+0x2ff>
            lv_draw_rect_dsc_init(&draw_dsc);
   1c6fd:	4c 8d 64 24 18       	lea    0x18(%rsp),%r12
   1c702:	4c 89 e7             	mov    %r12,%rdi
   1c705:	e8 37 6a 00 00       	callq  23141 <lv_draw_rect_dsc_init>
            lv_obj_init_draw_rect_dsc(obj, LV_OBJ_PART_MAIN, &draw_dsc);
   1c70a:	4c 89 e2             	mov    %r12,%rdx
   1c70d:	31 f6                	xor    %esi,%esi
   1c70f:	48 89 df             	mov    %rbx,%rdi
            draw_dsc.bg_opa = LV_OPA_TRANSP;
   1c712:	c6 44 24 2a 00       	movb   $0x0,0x2a(%rsp)
            draw_dsc.pattern_opa = LV_OPA_TRANSP;
   1c717:	c6 44 24 6c 00       	movb   $0x0,0x6c(%rsp)
            draw_dsc.shadow_opa = LV_OPA_TRANSP;
   1c71c:	c6 44 24 50 00       	movb   $0x0,0x50(%rsp)
            draw_dsc.value_opa = LV_OPA_TRANSP;
   1c721:	c6 84 24 80 00 00 00 	movb   $0x0,0x80(%rsp)
   1c728:	00 
            lv_obj_init_draw_rect_dsc(obj, LV_OBJ_PART_MAIN, &draw_dsc);
   1c729:	e8 5b fc ff ff       	callq  1c389 <lv_obj_init_draw_rect_dsc>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   1c72e:	ba 04 00 00 00       	mov    $0x4,%edx
   1c733:	31 f6                	xor    %esi,%esi
   1c735:	48 89 df             	mov    %rbx,%rdi
   1c738:	e8 b0 ef ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   1c73d:	ba 05 00 00 00       	mov    $0x5,%edx
   1c742:	31 f6                	xor    %esi,%esi
   1c744:	48 89 df             	mov    %rbx,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   1c747:	41 89 c5             	mov    %eax,%r13d
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   1c74a:	e8 9e ef ff ff       	callq  1b6ed <_lv_obj_get_style_int>
            lv_area_copy(&coords, &obj->coords);
   1c74f:	48 8d 4c 24 10       	lea    0x10(%rsp),%rcx
   1c754:	48 8d 73 20          	lea    0x20(%rbx),%rsi
   1c758:	89 c2                	mov    %eax,%edx
   1c75a:	48 89 cf             	mov    %rcx,%rdi
   1c75d:	e8 24 de ff ff       	callq  1a586 <lv_area_copy>
            lv_draw_rect(&coords, clip_area, &draw_dsc);
   1c762:	48 89 ee             	mov    %rbp,%rsi
            coords.y1 -= h;
   1c765:	66 29 54 24 12       	sub    %dx,0x12(%rsp)
            coords.y2 += h;
   1c76a:	66 01 54 24 16       	add    %dx,0x16(%rsp)
            lv_draw_rect(&coords, clip_area, &draw_dsc);
   1c76f:	4c 89 e2             	mov    %r12,%rdx
            coords.x1 -= w;
   1c772:	66 44 29 6c 24 10    	sub    %r13w,0x10(%rsp)
            coords.x2 += w;
   1c778:	66 44 01 6c 24 14    	add    %r13w,0x14(%rsp)
            lv_draw_rect(&coords, clip_area, &draw_dsc);
   1c77e:	e8 28 6a 00 00       	callq  231ab <lv_draw_rect>
    return LV_DESIGN_RES_OK;
   1c783:	31 d2                	xor    %edx,%edx
}
   1c785:	48 8b 8c 24 98 00 00 	mov    0x98(%rsp),%rcx
   1c78c:	00 
   1c78d:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1c794:	00 00 
   1c796:	88 d0                	mov    %dl,%al
   1c798:	74 05                	je     1c79f <lv_obj_design+0x31b>
   1c79a:	e8 a1 7e fe ff       	callq  4640 <__stack_chk_fail@plt>
   1c79f:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
   1c7a6:	5b                   	pop    %rbx
   1c7a7:	5d                   	pop    %rbp
   1c7a8:	41 5c                	pop    %r12
   1c7aa:	41 5d                	pop    %r13
   1c7ac:	41 5e                	pop    %r14
   1c7ae:	c3                   	retq   

000000000001c7af <lv_obj_init_draw_label_dsc>:
{
   1c7af:	41 54                	push   %r12
   1c7b1:	55                   	push   %rbp
    draw_dsc->opa = lv_obj_get_style_text_opa(obj, part);
   1c7b2:	40 0f b6 ee          	movzbl %sil,%ebp
{
   1c7b6:	53                   	push   %rbx
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_OPA, text_opa, lv_opa_t, _opa, scalar)
   1c7b7:	89 ee                	mov    %ebp,%esi
   1c7b9:	48 89 d3             	mov    %rdx,%rbx
   1c7bc:	ba 8c 80 00 00       	mov    $0x808c,%edx
   1c7c1:	49 89 fc             	mov    %rdi,%r12
   1c7c4:	e8 52 f5 ff ff       	callq  1bd1b <_lv_obj_get_style_opa>
    if(draw_dsc->opa <= LV_OPA_MIN) return;
   1c7c9:	3c 02                	cmp    $0x2,%al
    draw_dsc->opa = lv_obj_get_style_text_opa(obj, part);
   1c7cb:	88 43 10             	mov    %al,0x10(%rbx)
    if(draw_dsc->opa <= LV_OPA_MIN) return;
   1c7ce:	76 7f                	jbe    1c84f <lv_obj_init_draw_label_dsc+0xa0>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
   1c7d0:	ba 89 80 00 00       	mov    $0x8089,%edx
   1c7d5:	89 ee                	mov    %ebp,%esi
   1c7d7:	4c 89 e7             	mov    %r12,%rdi
   1c7da:	e8 45 ee ff ff       	callq  1b624 <_lv_obj_get_style_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
   1c7df:	ba 80 80 00 00       	mov    $0x8080,%edx
   1c7e4:	89 ee                	mov    %ebp,%esi
   1c7e6:	4c 89 e7             	mov    %r12,%rdi
    draw_dsc->color = lv_obj_get_style_text_color(obj, part);
   1c7e9:	89 03                	mov    %eax,(%rbx)
   1c7eb:	e8 fd ee ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
   1c7f0:	ba 81 80 00 00       	mov    $0x8081,%edx
   1c7f5:	89 ee                	mov    %ebp,%esi
   1c7f7:	4c 89 e7             	mov    %r12,%rdi
    draw_dsc->letter_space = lv_obj_get_style_text_letter_space(obj, part);
   1c7fa:	66 89 43 14          	mov    %ax,0x14(%rbx)
   1c7fe:	e8 ea ee ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_DECOR, text_decor, lv_text_decor_t, _int, scalar)
   1c803:	ba 82 80 00 00       	mov    $0x8082,%edx
   1c808:	89 ee                	mov    %ebp,%esi
   1c80a:	4c 89 e7             	mov    %r12,%rdi
    draw_dsc->line_space = lv_obj_get_style_text_line_space(obj, part);
   1c80d:	66 89 43 12          	mov    %ax,0x12(%rbx)
   1c811:	e8 d7 ee ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
   1c816:	ba 8e 80 00 00       	mov    $0x808e,%edx
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_DECOR, text_decor, lv_text_decor_t, _int, scalar)
   1c81b:	88 43 26             	mov    %al,0x26(%rbx)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
   1c81e:	89 ee                	mov    %ebp,%esi
   1c820:	4c 89 e7             	mov    %r12,%rdi
   1c823:	e8 31 f6 ff ff       	callq  1be59 <_lv_obj_get_style_ptr>
    if(draw_dsc->sel_start != LV_DRAW_LABEL_NO_TXT_SEL && draw_dsc->sel_end != LV_DRAW_LABEL_NO_TXT_SEL) {
   1c828:	81 7b 18 ff ff 00 00 	cmpl   $0xffff,0x18(%rbx)
    draw_dsc->font = lv_obj_get_style_text_font(obj, part);
   1c82f:	48 89 43 08          	mov    %rax,0x8(%rbx)
    if(draw_dsc->sel_start != LV_DRAW_LABEL_NO_TXT_SEL && draw_dsc->sel_end != LV_DRAW_LABEL_NO_TXT_SEL) {
   1c833:	74 1a                	je     1c84f <lv_obj_init_draw_label_dsc+0xa0>
   1c835:	81 7b 1c ff ff 00 00 	cmpl   $0xffff,0x1c(%rbx)
   1c83c:	74 11                	je     1c84f <lv_obj_init_draw_label_dsc+0xa0>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_SEL_COLOR, text_sel_color, lv_color_t, _color, nonscalar)
   1c83e:	ba 8a 80 00 00       	mov    $0x808a,%edx
   1c843:	89 ee                	mov    %ebp,%esi
   1c845:	4c 89 e7             	mov    %r12,%rdi
   1c848:	e8 d7 ed ff ff       	callq  1b624 <_lv_obj_get_style_color>
        draw_dsc->color = lv_obj_get_style_text_sel_color(obj, part);
   1c84d:	89 03                	mov    %eax,(%rbx)
}
   1c84f:	5b                   	pop    %rbx
   1c850:	5d                   	pop    %rbp
   1c851:	41 5c                	pop    %r12
   1c853:	c3                   	retq   

000000000001c854 <lv_obj_init_draw_img_dsc>:
{
   1c854:	41 54                	push   %r12
   1c856:	55                   	push   %rbp
   1c857:	48 89 d5             	mov    %rdx,%rbp
   1c85a:	53                   	push   %rbx
    draw_dsc->opa = lv_obj_get_style_image_opa(obj, part);
   1c85b:	40 0f b6 de          	movzbl %sil,%ebx
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_OPA, image_opa, lv_opa_t, _opa, scalar)
   1c85f:	ba ac 80 00 00       	mov    $0x80ac,%edx
   1c864:	89 de                	mov    %ebx,%esi
{
   1c866:	49 89 fc             	mov    %rdi,%r12
   1c869:	e8 ad f4 ff ff       	callq  1bd1b <_lv_obj_get_style_opa>
    if(draw_dsc->opa <= LV_OPA_MIN)  return;
   1c86e:	3c 02                	cmp    $0x2,%al
    draw_dsc->opa = lv_obj_get_style_image_opa(obj, part);
   1c870:	88 45 00             	mov    %al,0x0(%rbp)
    if(draw_dsc->opa <= LV_OPA_MIN)  return;
   1c873:	76 6f                	jbe    1c8e4 <lv_obj_init_draw_img_dsc+0x90>
    draw_dsc->angle = 0;
   1c875:	66 c7 45 02 00 00    	movw   $0x0,0x2(%rbp)
    draw_dsc->zoom = LV_IMG_ZOOM_NONE;
   1c87b:	66 c7 45 08 00 01    	movw   $0x100,0x8(%rbp)
    draw_dsc->pivot.x = lv_area_get_width(&obj->coords) / 2;
   1c881:	b9 02 00 00 00       	mov    $0x2,%ecx
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1c886:	66 41 8b 44 24 24    	mov    0x24(%r12),%ax
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR_OPA, image_recolor_opa, lv_opa_t, _opa, scalar)
   1c88c:	89 de                	mov    %ebx,%esi
   1c88e:	4c 89 e7             	mov    %r12,%rdi
   1c891:	ff c0                	inc    %eax
   1c893:	66 41 2b 44 24 20    	sub    0x20(%r12),%ax
   1c899:	89 c2                	mov    %eax,%edx
   1c89b:	66 c1 fa 0f          	sar    $0xf,%dx
   1c89f:	66 f7 f9             	idiv   %cx
   1c8a2:	66 89 45 04          	mov    %ax,0x4(%rbp)
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1c8a6:	66 41 8b 44 24 26    	mov    0x26(%r12),%ax
   1c8ac:	ff c0                	inc    %eax
   1c8ae:	66 41 2b 44 24 22    	sub    0x22(%r12),%ax
    draw_dsc->pivot.y = lv_area_get_height(&obj->coords) / 2;
   1c8b4:	89 c2                	mov    %eax,%edx
   1c8b6:	66 c1 fa 0f          	sar    $0xf,%dx
   1c8ba:	66 f7 f9             	idiv   %cx
   1c8bd:	ba ad 80 00 00       	mov    $0x80ad,%edx
   1c8c2:	66 89 45 06          	mov    %ax,0x6(%rbp)
   1c8c6:	e8 50 f4 ff ff       	callq  1bd1b <_lv_obj_get_style_opa>
    if(draw_dsc->recolor_opa > 0) {
   1c8cb:	84 c0                	test   %al,%al
    draw_dsc->recolor_opa = lv_obj_get_style_image_recolor_opa(obj, part);
   1c8cd:	88 45 0a             	mov    %al,0xa(%rbp)
    if(draw_dsc->recolor_opa > 0) {
   1c8d0:	74 12                	je     1c8e4 <lv_obj_init_draw_img_dsc+0x90>
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR, image_recolor, lv_color_t, _color, nonscalar)
   1c8d2:	ba a9 80 00 00       	mov    $0x80a9,%edx
   1c8d7:	89 de                	mov    %ebx,%esi
   1c8d9:	4c 89 e7             	mov    %r12,%rdi
   1c8dc:	e8 43 ed ff ff       	callq  1b624 <_lv_obj_get_style_color>
        draw_dsc->recolor = lv_obj_get_style_image_recolor(obj, part);
   1c8e1:	89 45 0c             	mov    %eax,0xc(%rbp)
}
   1c8e4:	5b                   	pop    %rbx
   1c8e5:	5d                   	pop    %rbp
   1c8e6:	41 5c                	pop    %r12
   1c8e8:	c3                   	retq   

000000000001c8e9 <lv_obj_init_draw_line_dsc>:
{
   1c8e9:	41 54                	push   %r12
   1c8eb:	55                   	push   %rbp
   1c8ec:	48 89 d5             	mov    %rdx,%rbp
   1c8ef:	53                   	push   %rbx
    draw_dsc->width = lv_obj_get_style_line_width(obj, part);
   1c8f0:	40 0f b6 de          	movzbl %sil,%ebx
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_WIDTH, line_width, lv_style_int_t, _int, scalar)
   1c8f4:	ba 90 00 00 00       	mov    $0x90,%edx
   1c8f9:	89 de                	mov    %ebx,%esi
{
   1c8fb:	49 89 fc             	mov    %rdi,%r12
   1c8fe:	e8 ea ed ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    if(draw_dsc->width == 0) return;
   1c903:	66 85 c0             	test   %ax,%ax
    draw_dsc->width = lv_obj_get_style_line_width(obj, part);
   1c906:	66 89 45 04          	mov    %ax,0x4(%rbp)
    if(draw_dsc->width == 0) return;
   1c90a:	74 7f                	je     1c98b <lv_obj_init_draw_line_dsc+0xa2>
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_OPA, line_opa, lv_opa_t, _opa, scalar)
   1c90c:	ba 9c 00 00 00       	mov    $0x9c,%edx
   1c911:	89 de                	mov    %ebx,%esi
   1c913:	4c 89 e7             	mov    %r12,%rdi
   1c916:	e8 00 f4 ff ff       	callq  1bd1b <_lv_obj_get_style_opa>
    if(draw_dsc->opa <= LV_OPA_MIN)  return;
   1c91b:	3c 02                	cmp    $0x2,%al
    draw_dsc->opa = lv_obj_get_style_line_opa(obj, part);
   1c91d:	88 45 0a             	mov    %al,0xa(%rbp)
    if(draw_dsc->opa <= LV_OPA_MIN)  return;
   1c920:	76 69                	jbe    1c98b <lv_obj_init_draw_line_dsc+0xa2>
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_COLOR, line_color, lv_color_t, _color, nonscalar)
   1c922:	ba 99 00 00 00       	mov    $0x99,%edx
   1c927:	89 de                	mov    %ebx,%esi
   1c929:	4c 89 e7             	mov    %r12,%rdi
   1c92c:	e8 f3 ec ff ff       	callq  1b624 <_lv_obj_get_style_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_DASH_WIDTH, line_dash_width, lv_style_int_t, _int, scalar)
   1c931:	ba 92 00 00 00       	mov    $0x92,%edx
    draw_dsc->color = lv_obj_get_style_line_color(obj, part);
   1c936:	89 45 00             	mov    %eax,0x0(%rbp)
   1c939:	89 de                	mov    %ebx,%esi
   1c93b:	4c 89 e7             	mov    %r12,%rdi
   1c93e:	e8 aa ed ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    if(draw_dsc->dash_width) {
   1c943:	66 85 c0             	test   %ax,%ax
    draw_dsc->dash_width = lv_obj_get_style_line_dash_width(obj, part);
   1c946:	66 89 45 06          	mov    %ax,0x6(%rbp)
    if(draw_dsc->dash_width) {
   1c94a:	74 13                	je     1c95f <lv_obj_init_draw_line_dsc+0x76>
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_DASH_GAP, line_dash_gap, lv_style_int_t, _int, scalar)
   1c94c:	ba 93 00 00 00       	mov    $0x93,%edx
   1c951:	89 de                	mov    %ebx,%esi
   1c953:	4c 89 e7             	mov    %r12,%rdi
   1c956:	e8 92 ed ff ff       	callq  1b6ed <_lv_obj_get_style_int>
        draw_dsc->dash_gap = lv_obj_get_style_line_dash_gap(obj, part);
   1c95b:	66 89 45 08          	mov    %ax,0x8(%rbp)
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_ROUNDED, line_rounded, bool, _int, scalar)
   1c95f:	ba 94 00 00 00       	mov    $0x94,%edx
   1c964:	89 de                	mov    %ebx,%esi
   1c966:	4c 89 e7             	mov    %r12,%rdi
   1c969:	e8 7f ed ff ff       	callq  1b6ed <_lv_obj_get_style_int>
   1c96e:	66 85 c0             	test   %ax,%ax
    draw_dsc->round_start = lv_obj_get_style_line_rounded(obj, part);
   1c971:	8a 45 0b             	mov    0xb(%rbp),%al
   1c974:	0f 95 c2             	setne  %dl
   1c977:	8d 0c 95 00 00 00 00 	lea    0x0(,%rdx,4),%ecx
    draw_dsc->round_end = draw_dsc->round_start;
   1c97e:	c1 e2 03             	shl    $0x3,%edx
    draw_dsc->round_start = lv_obj_get_style_line_rounded(obj, part);
   1c981:	83 e0 f3             	and    $0xfffffff3,%eax
    draw_dsc->round_end = draw_dsc->round_start;
   1c984:	09 c8                	or     %ecx,%eax
   1c986:	09 d0                	or     %edx,%eax
   1c988:	88 45 0b             	mov    %al,0xb(%rbp)
}
   1c98b:	5b                   	pop    %rbx
   1c98c:	5d                   	pop    %rbp
   1c98d:	41 5c                	pop    %r12
   1c98f:	c3                   	retq   

000000000001c990 <style_snapshot>:
    }
}

static void style_snapshot(lv_obj_t * obj, uint8_t part, style_snapshot_t * shot)
{
   1c990:	41 57                	push   %r15
   1c992:	41 56                	push   %r14
   1c994:	41 55                	push   %r13
   1c996:	41 54                	push   %r12
   1c998:	41 89 f4             	mov    %esi,%r12d
   1c99b:	55                   	push   %rbp
   1c99c:	53                   	push   %rbx
    _lv_obj_disable_style_caching(obj, true);
   1c99d:	be 01 00 00 00       	mov    $0x1,%esi
{
   1c9a2:	48 89 d3             	mov    %rdx,%rbx
   1c9a5:	48 89 fd             	mov    %rdi,%rbp
    lv_draw_rect_dsc_init(&shot->rect);
    lv_draw_label_dsc_init(&shot->label);
    lv_draw_img_dsc_init(&shot->img);
    lv_draw_line_dsc_init(&shot->line);

    lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   1c9a8:	45 0f b6 e4          	movzbl %r12b,%r12d
{
   1c9ac:	48 83 ec 18          	sub    $0x18,%rsp
    lv_draw_img_dsc_init(&shot->img);
   1c9b0:	4c 8d ab b4 00 00 00 	lea    0xb4(%rbx),%r13
    lv_draw_line_dsc_init(&shot->line);
   1c9b7:	4c 8d bb a8 00 00 00 	lea    0xa8(%rbx),%r15
    _lv_obj_disable_style_caching(obj, true);
   1c9be:	e8 f0 e0 ff ff       	callq  1aab3 <_lv_obj_disable_style_caching>
    _lv_memset_00(shot, sizeof(style_snapshot_t));
   1c9c3:	be f8 00 00 00       	mov    $0xf8,%esi
   1c9c8:	48 89 df             	mov    %rbx,%rdi
   1c9cb:	e8 4b db ff ff       	callq  1a51b <_lv_memset_00>
    lv_draw_rect_dsc_init(&shot->rect);
   1c9d0:	48 89 df             	mov    %rbx,%rdi
   1c9d3:	e8 69 67 00 00       	callq  23141 <lv_draw_rect_dsc_init>
    lv_draw_label_dsc_init(&shot->label);
   1c9d8:	4c 8d 83 80 00 00 00 	lea    0x80(%rbx),%r8
   1c9df:	4c 89 c7             	mov    %r8,%rdi
   1c9e2:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
   1c9e7:	e8 bd 3c 00 00       	callq  206a9 <lv_draw_label_dsc_init>
    lv_draw_img_dsc_init(&shot->img);
   1c9ec:	4c 89 ef             	mov    %r13,%rdi
   1c9ef:	e8 d6 38 00 00       	callq  202ca <lv_draw_img_dsc_init>
    lv_draw_line_dsc_init(&shot->line);
   1c9f4:	4c 89 ff             	mov    %r15,%rdi
   1c9f7:	e8 da 4a 00 00       	callq  214d6 <lv_draw_line_dsc_init>
    lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   1c9fc:	44 89 e6             	mov    %r12d,%esi
   1c9ff:	48 89 ef             	mov    %rbp,%rdi
   1ca02:	e8 07 e0 ff ff       	callq  1aa0e <lv_obj_get_style_list>
   1ca07:	49 89 c6             	mov    %rax,%r14
    bool trans_ori = list->skip_trans;
   1ca0a:	8a 40 09             	mov    0x9(%rax),%al
    list->skip_trans = 1;

    lv_obj_init_draw_rect_dsc(obj, part, &shot->rect);
   1ca0d:	48 89 da             	mov    %rbx,%rdx
   1ca10:	44 89 e6             	mov    %r12d,%esi
   1ca13:	48 89 ef             	mov    %rbp,%rdi
    bool trans_ori = list->skip_trans;
   1ca16:	88 c1                	mov    %al,%cl
    list->skip_trans = 1;
   1ca18:	83 c8 01             	or     $0x1,%eax
    bool trans_ori = list->skip_trans;
   1ca1b:	83 e1 01             	and    $0x1,%ecx
   1ca1e:	88 4c 24 07          	mov    %cl,0x7(%rsp)
    list->skip_trans = 1;
   1ca22:	41 88 46 09          	mov    %al,0x9(%r14)
    lv_obj_init_draw_rect_dsc(obj, part, &shot->rect);
   1ca26:	e8 5e f9 ff ff       	callq  1c389 <lv_obj_init_draw_rect_dsc>
    lv_obj_init_draw_label_dsc(obj, part, &shot->label);
   1ca2b:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
   1ca30:	44 89 e6             	mov    %r12d,%esi
   1ca33:	48 89 ef             	mov    %rbp,%rdi
   1ca36:	4c 89 c2             	mov    %r8,%rdx
   1ca39:	e8 71 fd ff ff       	callq  1c7af <lv_obj_init_draw_label_dsc>
    lv_obj_init_draw_img_dsc(obj, part, &shot->img);
   1ca3e:	4c 89 ea             	mov    %r13,%rdx
   1ca41:	44 89 e6             	mov    %r12d,%esi
   1ca44:	48 89 ef             	mov    %rbp,%rdi
   1ca47:	e8 08 fe ff ff       	callq  1c854 <lv_obj_init_draw_img_dsc>
    lv_obj_init_draw_line_dsc(obj, part, &shot->line);
   1ca4c:	4c 89 fa             	mov    %r15,%rdx
   1ca4f:	44 89 e6             	mov    %r12d,%esi
   1ca52:	48 89 ef             	mov    %rbp,%rdi
   1ca55:	e8 8f fe ff ff       	callq  1c8e9 <lv_obj_init_draw_line_dsc>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   1ca5a:	44 89 e6             	mov    %r12d,%esi
   1ca5d:	48 89 ef             	mov    %rbp,%rdi
   1ca60:	ba 10 00 00 00       	mov    $0x10,%edx
   1ca65:	e8 83 ec ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   1ca6a:	44 89 e6             	mov    %r12d,%esi
   1ca6d:	48 89 ef             	mov    %rbp,%rdi


    shot->pad_top = lv_obj_get_style_pad_top(obj, part);
   1ca70:	66 89 83 c8 00 00 00 	mov    %ax,0xc8(%rbx)
   1ca77:	ba 11 00 00 00       	mov    $0x11,%edx
   1ca7c:	e8 6c ec ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   1ca81:	44 89 e6             	mov    %r12d,%esi
   1ca84:	48 89 ef             	mov    %rbp,%rdi
    shot->pad_bottom = lv_obj_get_style_pad_bottom(obj, part);
   1ca87:	66 89 83 ca 00 00 00 	mov    %ax,0xca(%rbx)
   1ca8e:	ba 13 00 00 00       	mov    $0x13,%edx
   1ca93:	e8 55 ec ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   1ca98:	44 89 e6             	mov    %r12d,%esi
   1ca9b:	48 89 ef             	mov    %rbp,%rdi
    shot->pad_right = lv_obj_get_style_pad_right(obj, part);
   1ca9e:	66 89 83 cc 00 00 00 	mov    %ax,0xcc(%rbx)
   1caa5:	ba 12 00 00 00       	mov    $0x12,%edx
   1caaa:	e8 3e ec ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   1caaf:	44 89 e6             	mov    %r12d,%esi
   1cab2:	48 89 ef             	mov    %rbp,%rdi
    shot->pad_left = lv_obj_get_style_pad_left(obj, part);
   1cab5:	66 89 83 ce 00 00 00 	mov    %ax,0xce(%rbx)
   1cabc:	ba 14 00 00 00       	mov    $0x14,%edx
   1cac1:	e8 27 ec ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
   1cac6:	44 89 e6             	mov    %r12d,%esi
   1cac9:	48 89 ef             	mov    %rbp,%rdi
    shot->pad_inner = lv_obj_get_style_pad_inner(obj, part);
   1cacc:	66 89 83 d0 00 00 00 	mov    %ax,0xd0(%rbx)
   1cad3:	ba 15 00 00 00       	mov    $0x15,%edx
   1cad8:	e8 10 ec ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
   1cadd:	44 89 e6             	mov    %r12d,%esi
   1cae0:	48 89 ef             	mov    %rbp,%rdi
    shot->margin_top = lv_obj_get_style_margin_top(obj, part);
   1cae3:	66 89 83 d2 00 00 00 	mov    %ax,0xd2(%rbx)
   1caea:	ba 16 00 00 00       	mov    $0x16,%edx
   1caef:	e8 f9 eb ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
   1caf4:	44 89 e6             	mov    %r12d,%esi
   1caf7:	48 89 ef             	mov    %rbp,%rdi
    shot->margin_bottom = lv_obj_get_style_margin_bottom(obj, part);
   1cafa:	66 89 83 d4 00 00 00 	mov    %ax,0xd4(%rbx)
   1cb01:	ba 17 00 00 00       	mov    $0x17,%edx
   1cb06:	e8 e2 eb ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_RIGHT, margin_right, lv_style_int_t, _int, scalar)
   1cb0b:	44 89 e6             	mov    %r12d,%esi
   1cb0e:	48 89 ef             	mov    %rbp,%rdi
    shot->margin_left = lv_obj_get_style_margin_left(obj, part);
   1cb11:	66 89 83 d6 00 00 00 	mov    %ax,0xd6(%rbx)
   1cb18:	ba 18 00 00 00       	mov    $0x18,%edx
   1cb1d:	e8 cb eb ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SIZE, size, lv_style_int_t, _int, scalar)
   1cb22:	44 89 e6             	mov    %r12d,%esi
   1cb25:	48 89 ef             	mov    %rbp,%rdi
    shot->margin_right = lv_obj_get_style_margin_right(obj, part);
   1cb28:	66 89 83 d8 00 00 00 	mov    %ax,0xd8(%rbx)
   1cb2f:	ba 03 00 00 00       	mov    $0x3,%edx
   1cb34:	e8 b4 eb ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   1cb39:	44 89 e6             	mov    %r12d,%esi
   1cb3c:	48 89 ef             	mov    %rbp,%rdi
    shot->size = lv_obj_get_style_size(obj, part);
   1cb3f:	66 89 83 da 00 00 00 	mov    %ax,0xda(%rbx)
   1cb46:	ba 04 00 00 00       	mov    $0x4,%edx
   1cb4b:	e8 9d eb ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   1cb50:	44 89 e6             	mov    %r12d,%esi
   1cb53:	48 89 ef             	mov    %rbp,%rdi
    shot->transform_width = lv_obj_get_style_transform_width(obj, part);
   1cb56:	66 89 83 dc 00 00 00 	mov    %ax,0xdc(%rbx)
   1cb5d:	ba 05 00 00 00       	mov    $0x5,%edx
   1cb62:	e8 86 eb ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ANGLE, transform_angle, lv_style_int_t, _int, scalar)
   1cb67:	44 89 e6             	mov    %r12d,%esi
   1cb6a:	48 89 ef             	mov    %rbp,%rdi
    shot->transform_height = lv_obj_get_style_transform_height(obj, part);
   1cb6d:	66 89 83 de 00 00 00 	mov    %ax,0xde(%rbx)
   1cb74:	ba 06 00 00 00       	mov    $0x6,%edx
   1cb79:	e8 6f eb ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ZOOM, transform_zoom, lv_style_int_t, _int, scalar)
   1cb7e:	44 89 e6             	mov    %r12d,%esi
   1cb81:	48 89 ef             	mov    %rbp,%rdi
    shot->transform_angle = lv_obj_get_style_transform_angle(obj, part);
   1cb84:	66 89 83 e0 00 00 00 	mov    %ax,0xe0(%rbx)
   1cb8b:	ba 07 00 00 00       	mov    $0x7,%edx
   1cb90:	e8 58 eb ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PATH, transition_path, lv_anim_path_t *, _ptr, scalar)
#else
/*For compatibility*/
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PATH, transition_path, const void *, _ptr, scalar)
#endif
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_WIDTH, scale_width, lv_style_int_t, _int, scalar)
   1cb95:	44 89 e6             	mov    %r12d,%esi
   1cb98:	48 89 ef             	mov    %rbp,%rdi
    shot->transform_zoom = lv_obj_get_style_transform_zoom(obj, part);
   1cb9b:	66 89 83 e2 00 00 00 	mov    %ax,0xe2(%rbx)
   1cba2:	ba c0 00 00 00       	mov    $0xc0,%edx
   1cba7:	e8 41 eb ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_BORDER_WIDTH, scale_border_width, lv_style_int_t, _int, scalar)
   1cbac:	44 89 e6             	mov    %r12d,%esi
   1cbaf:	48 89 ef             	mov    %rbp,%rdi
    shot->scale_width = lv_obj_get_style_scale_width(obj, part);
   1cbb2:	66 89 83 e4 00 00 00 	mov    %ax,0xe4(%rbx)
   1cbb9:	ba c1 00 00 00       	mov    $0xc1,%edx
   1cbbe:	e8 2a eb ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_END_BORDER_WIDTH, scale_end_border_width, lv_style_int_t, _int, scalar)
   1cbc3:	44 89 e6             	mov    %r12d,%esi
   1cbc6:	48 89 ef             	mov    %rbp,%rdi
    shot->scale_border_width = lv_obj_get_style_scale_border_width(obj, part);
   1cbc9:	66 89 83 e6 00 00 00 	mov    %ax,0xe6(%rbx)
   1cbd0:	ba c2 00 00 00       	mov    $0xc2,%edx
   1cbd5:	e8 13 eb ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_END_LINE_WIDTH, scale_end_line_width, lv_style_int_t, _int, scalar)
   1cbda:	44 89 e6             	mov    %r12d,%esi
   1cbdd:	48 89 ef             	mov    %rbp,%rdi
    shot->scale_end_border_width = lv_obj_get_style_scale_end_border_width(obj, part);
   1cbe0:	66 89 83 e8 00 00 00 	mov    %ax,0xe8(%rbx)
   1cbe7:	ba c3 00 00 00       	mov    $0xc3,%edx
   1cbec:	e8 fc ea ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_GRAD_COLOR, scale_grad_color, lv_color_t, _color, nonscalar)
   1cbf1:	44 89 e6             	mov    %r12d,%esi
   1cbf4:	48 89 ef             	mov    %rbp,%rdi
    shot->scale_end_line_width = lv_obj_get_style_scale_end_line_width(obj, part);
   1cbf7:	66 89 83 ea 00 00 00 	mov    %ax,0xea(%rbx)
   1cbfe:	ba c9 00 00 00       	mov    $0xc9,%edx
   1cc03:	e8 1c ea ff ff       	callq  1b624 <_lv_obj_get_style_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_END_COLOR, scale_end_color, lv_color_t, _color, nonscalar)
   1cc08:	44 89 e6             	mov    %r12d,%esi
   1cc0b:	48 89 ef             	mov    %rbp,%rdi
    shot->scale_grad_color = lv_obj_get_style_scale_grad_color(obj, part);
   1cc0e:	89 83 ec 00 00 00    	mov    %eax,0xec(%rbx)
   1cc14:	ba ca 00 00 00       	mov    $0xca,%edx
   1cc19:	e8 06 ea ff ff       	callq  1b624 <_lv_obj_get_style_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(OPA_SCALE, opa_scale, lv_opa_t, _opa, scalar)
   1cc1e:	ba 0c 80 00 00       	mov    $0x800c,%edx
   1cc23:	44 89 e6             	mov    %r12d,%esi
   1cc26:	48 89 ef             	mov    %rbp,%rdi
    shot->scale_end_color = lv_obj_get_style_scale_end_color(obj, part);
   1cc29:	89 83 f0 00 00 00    	mov    %eax,0xf0(%rbx)
   1cc2f:	e8 e7 f0 ff ff       	callq  1bd1b <_lv_obj_get_style_opa>
    shot->opa_scale = lv_obj_get_style_opa_scale(obj, part);
    shot->clip_corder = lv_obj_get_style_clip_corner(obj, part);
   1cc34:	44 89 e6             	mov    %r12d,%esi
   1cc37:	48 89 ef             	mov    %rbp,%rdi
    shot->opa_scale = lv_obj_get_style_opa_scale(obj, part);
   1cc3a:	88 83 f4 00 00 00    	mov    %al,0xf4(%rbx)
    shot->clip_corder = lv_obj_get_style_clip_corner(obj, part);
   1cc40:	e8 fc ec ff ff       	callq  1b941 <lv_obj_get_style_clip_corner>
   1cc45:	83 e0 01             	and    $0x1,%eax
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_POST, border_post, bool, _int, scalar)
   1cc48:	44 89 e6             	mov    %r12d,%esi
   1cc4b:	48 89 ef             	mov    %rbp,%rdi
   1cc4e:	88 c2                	mov    %al,%dl
   1cc50:	8a 83 f5 00 00 00    	mov    0xf5(%rbx),%al
   1cc56:	83 e0 fe             	and    $0xfffffffe,%eax
   1cc59:	09 d0                	or     %edx,%eax
   1cc5b:	ba 33 00 00 00       	mov    $0x33,%edx
   1cc60:	88 83 f5 00 00 00    	mov    %al,0xf5(%rbx)
   1cc66:	e8 82 ea ff ff       	callq  1b6ed <_lv_obj_get_style_int>
   1cc6b:	66 85 c0             	test   %ax,%ax
    shot->border_post  = lv_obj_get_style_border_post(obj, part);

    _lv_obj_disable_style_caching(obj, false);
   1cc6e:	48 89 ef             	mov    %rbp,%rdi
    shot->border_post  = lv_obj_get_style_border_post(obj, part);
   1cc71:	0f 95 c0             	setne  %al
    _lv_obj_disable_style_caching(obj, false);
   1cc74:	31 f6                	xor    %esi,%esi
    shot->border_post  = lv_obj_get_style_border_post(obj, part);
   1cc76:	8d 14 00             	lea    (%rax,%rax,1),%edx
   1cc79:	8a 83 f5 00 00 00    	mov    0xf5(%rbx),%al
   1cc7f:	83 e0 fd             	and    $0xfffffffd,%eax
   1cc82:	09 d0                	or     %edx,%eax
   1cc84:	88 83 f5 00 00 00    	mov    %al,0xf5(%rbx)
    _lv_obj_disable_style_caching(obj, false);
   1cc8a:	e8 24 de ff ff       	callq  1aab3 <_lv_obj_disable_style_caching>
    list->skip_trans = trans_ori;
   1cc8f:	41 8a 46 09          	mov    0x9(%r14),%al
   1cc93:	83 e0 fe             	and    $0xfffffffe,%eax
   1cc96:	0a 44 24 07          	or     0x7(%rsp),%al
   1cc9a:	41 88 46 09          	mov    %al,0x9(%r14)
}
   1cc9e:	48 83 c4 18          	add    $0x18,%rsp
   1cca2:	5b                   	pop    %rbx
   1cca3:	5d                   	pop    %rbp
   1cca4:	41 5c                	pop    %r12
   1cca6:	41 5d                	pop    %r13
   1cca8:	41 5e                	pop    %r14
   1ccaa:	41 5f                	pop    %r15
   1ccac:	c3                   	retq   

000000000001ccad <lv_obj_set_state>:
{
   1ccad:	41 57                	push   %r15
   1ccaf:	41 56                	push   %r14
   1ccb1:	41 55                	push   %r13
   1ccb3:	41 54                	push   %r12
   1ccb5:	55                   	push   %rbp
   1ccb6:	53                   	push   %rbx
   1ccb7:	48 81 ec 28 02 00 00 	sub    $0x228,%rsp
    if(obj->state == new_state) return;
   1ccbe:	44 8a 6f 5d          	mov    0x5d(%rdi),%r13b
{
   1ccc2:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1ccc9:	00 00 
   1cccb:	48 89 84 24 18 02 00 	mov    %rax,0x218(%rsp)
   1ccd2:	00 
   1ccd3:	31 c0                	xor    %eax,%eax
   1ccd5:	40 88 74 24 17       	mov    %sil,0x17(%rsp)
    if(obj->state == new_state) return;
   1ccda:	41 38 f5             	cmp    %sil,%r13b
   1ccdd:	0f 84 4d 02 00 00    	je     1cf30 <lv_obj_set_state+0x283>
        style_snapshot(obj, part, &shot_pre);
   1cce3:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
   1cce8:	49 89 fe             	mov    %rdi,%r14
   1cceb:	41 89 f4             	mov    %esi,%r12d
   1ccee:	31 db                	xor    %ebx,%ebx
    style_snapshot_res_t cmp_res = STYLE_COMPARE_SAME;
   1ccf0:	45 31 ff             	xor    %r15d,%r15d
        style_snapshot(obj, part, &shot_pre);
   1ccf3:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
        lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);
   1ccf8:	89 de                	mov    %ebx,%esi
   1ccfa:	4c 89 f7             	mov    %r14,%rdi
   1ccfd:	40 88 dd             	mov    %bl,%bpl
   1cd00:	e8 09 dd ff ff       	callq  1aa0e <lv_obj_get_style_list>
        if(style_list == NULL) break;   /*No more style lists*/
   1cd05:	48 85 c0             	test   %rax,%rax
   1cd08:	0f 84 f6 01 00 00    	je     1cf04 <lv_obj_set_state+0x257>
        style_snapshot(obj, part, &shot_pre);
   1cd0e:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   1cd13:	89 de                	mov    %ebx,%esi
   1cd15:	4c 89 f7             	mov    %r14,%rdi
        obj->state = prev_state;
   1cd18:	45 88 6e 5d          	mov    %r13b,0x5d(%r14)
        style_snapshot(obj, part, &shot_pre);
   1cd1c:	e8 6f fc ff ff       	callq  1c990 <style_snapshot>
        obj->state = new_state;
   1cd21:	8a 44 24 17          	mov    0x17(%rsp),%al
        style_snapshot(obj, part, &shot_post);
   1cd25:	89 de                	mov    %ebx,%esi
   1cd27:	4c 89 f7             	mov    %r14,%rdi
        obj->state = new_state;
   1cd2a:	41 88 46 5d          	mov    %al,0x5d(%r14)
        style_snapshot(obj, part, &shot_post);
   1cd2e:	48 8d 84 24 20 01 00 	lea    0x120(%rsp),%rax
   1cd35:	00 
   1cd36:	48 89 c2             	mov    %rax,%rdx
   1cd39:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1cd3e:	e8 4d fc ff ff       	callq  1c990 <style_snapshot>

static style_snapshot_res_t style_snapshot_compare(style_snapshot_t * shot1, style_snapshot_t * shot2)
{
    if(memcmp(shot1, shot2, sizeof(style_snapshot_t)) == 0) return STYLE_COMPARE_SAME;
   1cd43:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
   1cd48:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   1cd4d:	ba f8 00 00 00       	mov    $0xf8,%edx
   1cd52:	48 89 c6             	mov    %rax,%rsi
   1cd55:	e8 e6 76 fe ff       	callq  4440 <memcmp@plt>
   1cd5a:	85 c0                	test   %eax,%eax
   1cd5c:	0f 84 8c 01 00 00    	je     1ceee <lv_obj_set_state+0x241>


    if(shot1->pad_top != shot2->pad_top) return STYLE_COMPARE_DIFF;
   1cd62:	8b 84 24 e8 01 00 00 	mov    0x1e8(%rsp),%eax
   1cd69:	66 39 84 24 f0 00 00 	cmp    %ax,0xf0(%rsp)
   1cd70:	00 
   1cd71:	0f 85 87 01 00 00    	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->pad_bottom != shot2->pad_bottom) return STYLE_COMPARE_DIFF;
   1cd77:	66 8b 84 24 ea 01 00 	mov    0x1ea(%rsp),%ax
   1cd7e:	00 
   1cd7f:	66 39 84 24 f2 00 00 	cmp    %ax,0xf2(%rsp)
   1cd86:	00 
   1cd87:	0f 85 71 01 00 00    	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->pad_left != shot2->pad_right) return STYLE_COMPARE_DIFF;
   1cd8d:	66 8b 84 24 f6 00 00 	mov    0xf6(%rsp),%ax
   1cd94:	00 
   1cd95:	66 3b 84 24 ec 01 00 	cmp    0x1ec(%rsp),%ax
   1cd9c:	00 
   1cd9d:	0f 85 5b 01 00 00    	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->pad_right != shot2->pad_right) return STYLE_COMPARE_DIFF;
   1cda3:	66 3b 84 24 f4 00 00 	cmp    0xf4(%rsp),%ax
   1cdaa:	00 
   1cdab:	0f 85 4d 01 00 00    	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->pad_top != shot2->pad_top) return STYLE_COMPARE_DIFF;
    if(shot1->pad_inner != shot2->pad_inner) return STYLE_COMPARE_DIFF;
   1cdb1:	8b 84 24 f0 01 00 00 	mov    0x1f0(%rsp),%eax
   1cdb8:	66 39 84 24 f8 00 00 	cmp    %ax,0xf8(%rsp)
   1cdbf:	00 
   1cdc0:	0f 85 38 01 00 00    	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->margin_top != shot2->margin_top) return STYLE_COMPARE_DIFF;
   1cdc6:	66 8b 84 24 f2 01 00 	mov    0x1f2(%rsp),%ax
   1cdcd:	00 
   1cdce:	66 39 84 24 fa 00 00 	cmp    %ax,0xfa(%rsp)
   1cdd5:	00 
   1cdd6:	0f 85 22 01 00 00    	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->margin_bottom != shot2->margin_bottom) return STYLE_COMPARE_DIFF;
   1cddc:	8b 84 24 f4 01 00 00 	mov    0x1f4(%rsp),%eax
   1cde3:	66 39 84 24 fc 00 00 	cmp    %ax,0xfc(%rsp)
   1cdea:	00 
   1cdeb:	0f 85 0d 01 00 00    	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->margin_left != shot2->margin_right) return STYLE_COMPARE_DIFF;
   1cdf1:	66 8b 84 24 fe 00 00 	mov    0xfe(%rsp),%ax
   1cdf8:	00 
   1cdf9:	66 3b 84 24 f8 01 00 	cmp    0x1f8(%rsp),%ax
   1ce00:	00 
   1ce01:	0f 85 f7 00 00 00    	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->margin_right != shot2->margin_right) return STYLE_COMPARE_DIFF;
   1ce07:	66 3b 84 24 00 01 00 	cmp    0x100(%rsp),%ax
   1ce0e:	00 
   1ce0f:	0f 85 e9 00 00 00    	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->margin_top != shot2->margin_top) return STYLE_COMPARE_DIFF;
    if(shot1->transform_width != shot2->transform_width) return STYLE_COMPARE_DIFF;
   1ce15:	8b 84 24 fc 01 00 00 	mov    0x1fc(%rsp),%eax
   1ce1c:	66 39 84 24 04 01 00 	cmp    %ax,0x104(%rsp)
   1ce23:	00 
   1ce24:	0f 85 d4 00 00 00    	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->transform_height != shot2->transform_height) return STYLE_COMPARE_DIFF;
   1ce2a:	66 8b 84 24 fe 01 00 	mov    0x1fe(%rsp),%ax
   1ce31:	00 
   1ce32:	66 39 84 24 06 01 00 	cmp    %ax,0x106(%rsp)
   1ce39:	00 
   1ce3a:	0f 85 be 00 00 00    	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->transform_angle != shot2->transform_angle) return STYLE_COMPARE_DIFF;
   1ce40:	8b 84 24 00 02 00 00 	mov    0x200(%rsp),%eax
   1ce47:	66 39 84 24 08 01 00 	cmp    %ax,0x108(%rsp)
   1ce4e:	00 
   1ce4f:	0f 85 a9 00 00 00    	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->transform_zoom != shot2->transform_zoom) return STYLE_COMPARE_DIFF;
   1ce55:	66 8b 84 24 02 02 00 	mov    0x202(%rsp),%ax
   1ce5c:	00 
   1ce5d:	66 39 84 24 0a 01 00 	cmp    %ax,0x10a(%rsp)
   1ce64:	00 
   1ce65:	0f 85 93 00 00 00    	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->rect.outline_width != shot2->rect.outline_width) return STYLE_COMPARE_DIFF;
   1ce6b:	8b 84 24 44 01 00 00 	mov    0x144(%rsp),%eax
   1ce72:	66 39 44 24 4c       	cmp    %ax,0x4c(%rsp)
   1ce77:	0f 85 81 00 00 00    	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->rect.outline_pad != shot2->rect.outline_pad) return STYLE_COMPARE_DIFF;
   1ce7d:	66 8b 84 24 46 01 00 	mov    0x146(%rsp),%ax
   1ce84:	00 
   1ce85:	66 39 44 24 4e       	cmp    %ax,0x4e(%rsp)
   1ce8a:	75 72                	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->rect.value_font != shot2->rect.value_font) return STYLE_COMPARE_DIFF;
   1ce8c:	48 8b 84 24 80 01 00 	mov    0x180(%rsp),%rax
   1ce93:	00 
   1ce94:	48 39 84 24 88 00 00 	cmp    %rax,0x88(%rsp)
   1ce9b:	00 
   1ce9c:	75 60                	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->rect.value_align != shot2->rect.value_align) return STYLE_COMPARE_DIFF;
   1ce9e:	8a 84 24 98 01 00 00 	mov    0x198(%rsp),%al
   1cea5:	38 84 24 a0 00 00 00 	cmp    %al,0xa0(%rsp)
   1ceac:	75 50                	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->rect.value_font != shot2->rect.value_font) return STYLE_COMPARE_DIFF;
    if(shot1->rect.shadow_spread != shot2->rect.shadow_spread) return STYLE_COMPARE_DIFF;
   1ceae:	66 8b 84 24 56 01 00 	mov    0x156(%rsp),%ax
   1ceb5:	00 
   1ceb6:	66 39 44 24 5e       	cmp    %ax,0x5e(%rsp)
   1cebb:	75 41                	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->rect.shadow_width != shot2->rect.shadow_width) return STYLE_COMPARE_DIFF;
   1cebd:	8b 84 24 50 01 00 00 	mov    0x150(%rsp),%eax
   1cec4:	66 39 44 24 58       	cmp    %ax,0x58(%rsp)
   1cec9:	75 33                	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->rect.shadow_ofs_x != shot2->rect.shadow_ofs_x) return STYLE_COMPARE_DIFF;
   1cecb:	66 8b 84 24 52 01 00 	mov    0x152(%rsp),%ax
   1ced2:	00 
   1ced3:	66 39 44 24 5a       	cmp    %ax,0x5a(%rsp)
   1ced8:	75 24                	jne    1cefe <lv_obj_set_state+0x251>
    if(shot1->rect.shadow_ofs_y != shot2->rect.shadow_ofs_y) return STYLE_COMPARE_DIFF;
   1ceda:	8b 84 24 54 01 00 00 	mov    0x154(%rsp),%eax
   1cee1:	66 39 44 24 5c       	cmp    %ax,0x5c(%rsp)
   1cee6:	75 16                	jne    1cefe <lv_obj_set_state+0x251>
            cmp_res = STYLE_COMPARE_VISUAL_DIFF;
   1cee8:	41 bf 01 00 00 00    	mov    $0x1,%r15d
   1ceee:	ff c3                	inc    %ebx
    for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {
   1cef0:	83 fb 40             	cmp    $0x40,%ebx
   1cef3:	0f 85 ff fd ff ff    	jne    1ccf8 <lv_obj_set_state+0x4b>
   1cef9:	40 b5 40             	mov    $0x40,%bpl
   1cefc:	eb 06                	jmp    1cf04 <lv_obj_set_state+0x257>
            cmp_res = STYLE_COMPARE_DIFF;
   1cefe:	41 bf 02 00 00 00    	mov    $0x2,%r15d
    if(cmp_res == STYLE_COMPARE_SAME) {
   1cf04:	45 85 ff             	test   %r15d,%r15d
    obj->state = new_state;
   1cf07:	45 88 66 5d          	mov    %r12b,0x5d(%r14)
    if(cmp_res == STYLE_COMPARE_SAME) {
   1cf0b:	74 23                	je     1cf30 <lv_obj_set_state+0x283>
    if(cmp_res == STYLE_COMPARE_DIFF) lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);
   1cf0d:	41 83 ff 02          	cmp    $0x2,%r15d
   1cf11:	75 0b                	jne    1cf1e <lv_obj_set_state+0x271>
   1cf13:	40 0f b6 f5          	movzbl %bpl,%esi
   1cf17:	ba ff 00 00 00       	mov    $0xff,%edx
   1cf1c:	eb 0a                	jmp    1cf28 <lv_obj_set_state+0x27b>
    else if(cmp_res == STYLE_COMPARE_VISUAL_DIFF) lv_obj_refresh_style(obj, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
   1cf1e:	ba ff 00 00 00       	mov    $0xff,%edx
   1cf23:	be ff 00 00 00       	mov    $0xff,%esi
   1cf28:	4c 89 f7             	mov    %r14,%rdi
   1cf2b:	e8 b4 f1 ff ff       	callq  1c0e4 <lv_obj_refresh_style>
}
   1cf30:	48 8b 84 24 18 02 00 	mov    0x218(%rsp),%rax
   1cf37:	00 
   1cf38:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1cf3f:	00 00 
   1cf41:	74 05                	je     1cf48 <lv_obj_set_state+0x29b>
   1cf43:	e8 f8 76 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1cf48:	48 81 c4 28 02 00 00 	add    $0x228,%rsp
   1cf4f:	5b                   	pop    %rbx
   1cf50:	5d                   	pop    %rbp
   1cf51:	41 5c                	pop    %r12
   1cf53:	41 5d                	pop    %r13
   1cf55:	41 5e                	pop    %r14
   1cf57:	41 5f                	pop    %r15
   1cf59:	c3                   	retq   

000000000001cf5a <lv_obj_add_state>:
    lv_state_t new_state = obj->state | state;
   1cf5a:	8a 47 5d             	mov    0x5d(%rdi),%al
   1cf5d:	09 c6                	or     %eax,%esi
    if(obj->state != new_state) {
   1cf5f:	40 38 f0             	cmp    %sil,%al
   1cf62:	74 09                	je     1cf6d <lv_obj_add_state+0x13>
        lv_obj_set_state(obj, new_state);
   1cf64:	40 0f b6 f6          	movzbl %sil,%esi
   1cf68:	e9 40 fd ff ff       	jmpq   1ccad <lv_obj_set_state>
}
   1cf6d:	c3                   	retq   

000000000001cf6e <lv_obj_clear_state>:
    lv_state_t new_state = obj->state & (~state);
   1cf6e:	8a 47 5d             	mov    0x5d(%rdi),%al
   1cf71:	f7 d6                	not    %esi
   1cf73:	21 c6                	and    %eax,%esi
    if(obj->state != new_state) {
   1cf75:	40 38 f0             	cmp    %sil,%al
   1cf78:	74 09                	je     1cf83 <lv_obj_clear_state+0x15>
        lv_obj_set_state(obj, new_state);
   1cf7a:	40 0f b6 f6          	movzbl %sil,%esi
   1cf7e:	e9 2a fd ff ff       	jmpq   1ccad <lv_obj_set_state>
}
   1cf83:	c3                   	retq   

000000000001cf84 <lv_obj_get_draw_rect_ext_pad_size>:
{
   1cf84:	41 57                	push   %r15
   1cf86:	41 56                	push   %r14
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_WIDTH, shadow_width, lv_style_int_t, _int, scalar)
   1cf88:	ba 50 00 00 00       	mov    $0x50,%edx
   1cf8d:	41 55                	push   %r13
   1cf8f:	41 54                	push   %r12
    lv_coord_t sh_width = lv_obj_get_style_shadow_width(obj, part);
   1cf91:	44 0f b6 e6          	movzbl %sil,%r12d
{
   1cf95:	55                   	push   %rbp
   1cf96:	53                   	push   %rbx
   1cf97:	44 89 e6             	mov    %r12d,%esi
   1cf9a:	48 89 fd             	mov    %rdi,%rbp
   1cf9d:	48 83 ec 28          	sub    $0x28,%rsp
   1cfa1:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1cfa8:	00 00 
   1cfaa:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1cfaf:	31 c0                	xor    %eax,%eax
   1cfb1:	e8 37 e7 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    if(sh_width) {
   1cfb6:	66 85 c0             	test   %ax,%ax
   1cfb9:	75 07                	jne    1cfc2 <lv_obj_get_draw_rect_ext_pad_size+0x3e>
    lv_coord_t s = 0;
   1cfbb:	31 db                	xor    %ebx,%ebx
   1cfbd:	e9 8d 00 00 00       	jmpq   1d04f <lv_obj_get_draw_rect_ext_pad_size+0xcb>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OPA, shadow_opa, lv_opa_t, _opa, scalar)
   1cfc2:	ba 5c 00 00 00       	mov    $0x5c,%edx
   1cfc7:	44 89 e6             	mov    %r12d,%esi
   1cfca:	48 89 ef             	mov    %rbp,%rdi
   1cfcd:	89 c3                	mov    %eax,%ebx
   1cfcf:	e8 47 ed ff ff       	callq  1bd1b <_lv_obj_get_style_opa>
        if(sh_opa > LV_OPA_MIN) {
   1cfd4:	3c 02                	cmp    $0x2,%al
   1cfd6:	76 e3                	jbe    1cfbb <lv_obj_get_draw_rect_ext_pad_size+0x37>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_SPREAD, shadow_spread, lv_style_int_t, _int, scalar)
   1cfd8:	ba 53 00 00 00       	mov    $0x53,%edx
   1cfdd:	44 89 e6             	mov    %r12d,%esi
   1cfe0:	48 89 ef             	mov    %rbp,%rdi
   1cfe3:	e8 05 e7 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
            sh_width = sh_width / 2;    /*THe blur adds only half width*/
   1cfe8:	89 da                	mov    %ebx,%edx
   1cfea:	b9 02 00 00 00       	mov    $0x2,%ecx
   1cfef:	41 89 c5             	mov    %eax,%r13d
   1cff2:	66 c1 fa 0f          	sar    $0xf,%dx
   1cff6:	89 d8                	mov    %ebx,%eax
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OFS_X, shadow_ofs_x, lv_style_int_t, _int, scalar)
   1cff8:	44 89 e6             	mov    %r12d,%esi
   1cffb:	66 f7 f9             	idiv   %cx
   1cffe:	48 89 ef             	mov    %rbp,%rdi
   1d001:	ba 51 00 00 00       	mov    $0x51,%edx
            sh_width += lv_obj_get_style_shadow_spread(obj, part);
   1d006:	45 8d 6c 05 01       	lea    0x1(%r13,%rax,1),%r13d
   1d00b:	e8 dd e6 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OFS_Y, shadow_ofs_y, lv_style_int_t, _int, scalar)
   1d010:	ba 52 00 00 00       	mov    $0x52,%edx
   1d015:	44 89 e6             	mov    %r12d,%esi
   1d018:	48 89 ef             	mov    %rbp,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OFS_X, shadow_ofs_x, lv_style_int_t, _int, scalar)
   1d01b:	41 89 c6             	mov    %eax,%r14d
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OFS_Y, shadow_ofs_y, lv_style_int_t, _int, scalar)
   1d01e:	e8 ca e6 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
            sh_width += LV_MATH_MAX(LV_MATH_ABS(sh_ofs_x), LV_MATH_ABS(sh_ofs_y));
   1d023:	0f bf d8             	movswl %ax,%ebx
   1d026:	89 d8                	mov    %ebx,%eax
   1d028:	c1 f8 1f             	sar    $0x1f,%eax
   1d02b:	31 c3                	xor    %eax,%ebx
   1d02d:	89 d9                	mov    %ebx,%ecx
   1d02f:	41 0f bf de          	movswl %r14w,%ebx
   1d033:	29 c1                	sub    %eax,%ecx
   1d035:	89 d8                	mov    %ebx,%eax
   1d037:	c1 f8 1f             	sar    $0x1f,%eax
   1d03a:	31 c3                	xor    %eax,%ebx
   1d03c:	29 c3                	sub    %eax,%ebx
            s = LV_MATH_MAX(s, sh_width);
   1d03e:	b8 00 00 00 00       	mov    $0x0,%eax
            sh_width += LV_MATH_MAX(LV_MATH_ABS(sh_ofs_x), LV_MATH_ABS(sh_ofs_y));
   1d043:	39 d9                	cmp    %ebx,%ecx
   1d045:	0f 4d d9             	cmovge %ecx,%ebx
            s = LV_MATH_MAX(s, sh_width);
   1d048:	66 44 01 eb          	add    %r13w,%bx
   1d04c:	0f 48 d8             	cmovs  %eax,%ebx
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_STR, value_str, const char *, _ptr, scalar)
   1d04f:	ba 7f 00 00 00       	mov    $0x7f,%edx
   1d054:	44 89 e6             	mov    %r12d,%esi
   1d057:	48 89 ef             	mov    %rbp,%rdi
   1d05a:	e8 fa ed ff ff       	callq  1be59 <_lv_obj_get_style_ptr>
    if(value_str) {
   1d05f:	48 85 c0             	test   %rax,%rax
   1d062:	49 89 c6             	mov    %rax,%r14
   1d065:	0f 84 4a 01 00 00    	je     1d1b5 <lv_obj_get_draw_rect_ext_pad_size+0x231>
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OPA, value_opa, lv_opa_t, _opa, scalar)
   1d06b:	ba 7c 00 00 00       	mov    $0x7c,%edx
   1d070:	44 89 e6             	mov    %r12d,%esi
   1d073:	48 89 ef             	mov    %rbp,%rdi
   1d076:	e8 a0 ec ff ff       	callq  1bd1b <_lv_obj_get_style_opa>
        if(value_opa > LV_OPA_MIN) {
   1d07b:	3c 02                	cmp    $0x2,%al
   1d07d:	0f 86 32 01 00 00    	jbe    1d1b5 <lv_obj_get_draw_rect_ext_pad_size+0x231>
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_LETTER_SPACE, value_letter_space, lv_style_int_t, _int, scalar)
   1d083:	ba 70 00 00 00       	mov    $0x70,%edx
   1d088:	44 89 e6             	mov    %r12d,%esi
   1d08b:	48 89 ef             	mov    %rbp,%rdi
   1d08e:	e8 5a e6 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
   1d093:	ba 70 00 00 00       	mov    $0x70,%edx
   1d098:	44 89 e6             	mov    %r12d,%esi
   1d09b:	48 89 ef             	mov    %rbp,%rdi
   1d09e:	41 89 c5             	mov    %eax,%r13d
            s = LV_MATH_MAX(s, obj->coords.x1 - value_area.x1);
   1d0a1:	0f bf db             	movswl %bx,%ebx
   1d0a4:	e8 44 e6 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_FONT, value_font, const lv_font_t *, _ptr, scalar)
   1d0a9:	ba 7e 00 00 00       	mov    $0x7e,%edx
   1d0ae:	44 89 e6             	mov    %r12d,%esi
   1d0b1:	48 89 ef             	mov    %rbp,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_LETTER_SPACE, value_letter_space, lv_style_int_t, _int, scalar)
   1d0b4:	41 89 c7             	mov    %eax,%r15d
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_FONT, value_font, const lv_font_t *, _ptr, scalar)
   1d0b7:	e8 9d ed ff ff       	callq  1be59 <_lv_obj_get_style_ptr>
            _lv_txt_get_size(&txt_size, value_str, font, letter_space, line_space, LV_COORD_MAX, LV_TXT_FLAG_NONE);
   1d0bc:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
   1d0c1:	48 83 ec 08          	sub    $0x8,%rsp
   1d0c5:	41 0f bf cd          	movswl %r13w,%ecx
   1d0c9:	6a 00                	pushq  $0x0
   1d0cb:	45 0f bf c7          	movswl %r15w,%r8d
   1d0cf:	41 b9 18 7c 00 00    	mov    $0x7c18,%r9d
   1d0d5:	48 89 c2             	mov    %rax,%rdx
   1d0d8:	4c 89 f6             	mov    %r14,%rsi
   1d0db:	e8 1a 9e 00 00       	callq  26efa <_lv_txt_get_size>
   1d0e0:	58                   	pop    %rax
   1d0e1:	5a                   	pop    %rdx
            value_area.x2 = txt_size.x - 1;
   1d0e2:	8b 44 24 08          	mov    0x8(%rsp),%eax
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_ALIGN, value_align, lv_align_t, _int, scalar)
   1d0e6:	ba 75 00 00 00       	mov    $0x75,%edx
   1d0eb:	44 89 e6             	mov    %r12d,%esi
   1d0ee:	48 89 ef             	mov    %rbp,%rdi
   1d0f1:	ff c8                	dec    %eax
            value_area.x1 = 0;
   1d0f3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%rsp)
   1d0fa:	00 
            value_area.x2 = txt_size.x - 1;
   1d0fb:	66 89 44 24 14       	mov    %ax,0x14(%rsp)
            value_area.y2 = txt_size.y - 1;
   1d100:	66 8b 44 24 0a       	mov    0xa(%rsp),%ax
   1d105:	ff c8                	dec    %eax
   1d107:	66 89 44 24 16       	mov    %ax,0x16(%rsp)
   1d10c:	e8 dc e5 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OFS_X, value_ofs_x, lv_style_int_t, _int, scalar)
   1d111:	ba 73 00 00 00       	mov    $0x73,%edx
   1d116:	44 89 e6             	mov    %r12d,%esi
   1d119:	48 89 ef             	mov    %rbp,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_ALIGN, value_align, lv_align_t, _int, scalar)
   1d11c:	41 89 c5             	mov    %eax,%r13d
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OFS_X, value_ofs_x, lv_style_int_t, _int, scalar)
   1d11f:	e8 c9 e5 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OFS_Y, value_ofs_y, lv_style_int_t, _int, scalar)
   1d124:	ba 74 00 00 00       	mov    $0x74,%edx
   1d129:	44 89 e6             	mov    %r12d,%esi
   1d12c:	48 89 ef             	mov    %rbp,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OFS_X, value_ofs_x, lv_style_int_t, _int, scalar)
   1d12f:	41 89 c7             	mov    %eax,%r15d
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OFS_Y, value_ofs_y, lv_style_int_t, _int, scalar)
   1d132:	e8 b6 e5 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
            _lv_area_align(&obj->coords, &value_area, align, &p_align);
   1d137:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx
   1d13c:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
   1d141:	48 8d 7d 20          	lea    0x20(%rbp),%rdi
   1d145:	41 0f b6 d5          	movzbl %r13b,%edx
   1d149:	41 89 c6             	mov    %eax,%r14d
   1d14c:	e8 6e 87 00 00       	callq  258bf <_lv_area_align>
            value_area.x1 += p_align.x + xofs;
   1d151:	44 89 fa             	mov    %r15d,%edx
   1d154:	03 54 24 0c          	add    0xc(%rsp),%edx
            s = LV_MATH_MAX(s, obj->coords.x1 - value_area.x1);
   1d158:	0f bf 4d 20          	movswl 0x20(%rbp),%ecx
            value_area.y1 += p_align.y + yofs;
   1d15c:	66 8b 44 24 0e       	mov    0xe(%rsp),%ax
            value_area.x1 += p_align.x + xofs;
   1d161:	89 d6                	mov    %edx,%esi
   1d163:	03 74 24 10          	add    0x10(%rsp),%esi
            value_area.y1 += p_align.y + yofs;
   1d167:	44 01 f0             	add    %r14d,%eax
            s = LV_MATH_MAX(s, obj->coords.x1 - value_area.x1);
   1d16a:	0f bf f6             	movswl %si,%esi
   1d16d:	29 f1                	sub    %esi,%ecx
            value_area.y1 += p_align.y + yofs;
   1d16f:	66 8b 74 24 12       	mov    0x12(%rsp),%si
            s = LV_MATH_MAX(s, obj->coords.x1 - value_area.x1);
   1d174:	39 d9                	cmp    %ebx,%ecx
   1d176:	0f 4c cb             	cmovl  %ebx,%ecx
            s = LV_MATH_MAX(s, obj->coords.y1 - value_area.y1);
   1d179:	0f bf 5d 22          	movswl 0x22(%rbp),%ebx
            value_area.y1 += p_align.y + yofs;
   1d17d:	01 c6                	add    %eax,%esi
            s = LV_MATH_MAX(s, obj->coords.y1 - value_area.y1);
   1d17f:	0f bf c9             	movswl %cx,%ecx
   1d182:	0f bf f6             	movswl %si,%esi
   1d185:	29 f3                	sub    %esi,%ebx
   1d187:	39 cb                	cmp    %ecx,%ebx
   1d189:	0f 4d cb             	cmovge %ebx,%ecx
            value_area.x2 += p_align.x + xofs;
   1d18c:	03 54 24 14          	add    0x14(%rsp),%edx
   1d190:	0f bf da             	movswl %dx,%ebx
            s = LV_MATH_MAX(s, value_area.x2 - obj->coords.x2);
   1d193:	0f bf 55 24          	movswl 0x24(%rbp),%edx
   1d197:	29 d3                	sub    %edx,%ebx
   1d199:	0f bf d1             	movswl %cx,%edx
   1d19c:	39 d3                	cmp    %edx,%ebx
   1d19e:	0f 4c da             	cmovl  %edx,%ebx
            value_area.y2 += p_align.y + yofs;
   1d1a1:	66 03 44 24 16       	add    0x16(%rsp),%ax
            s = LV_MATH_MAX(s, value_area.y2 - obj->coords.y2);
   1d1a6:	0f bf 55 26          	movswl 0x26(%rbp),%edx
   1d1aa:	0f bf db             	movswl %bx,%ebx
   1d1ad:	98                   	cwtl   
   1d1ae:	29 d0                	sub    %edx,%eax
   1d1b0:	39 d8                	cmp    %ebx,%eax
   1d1b2:	0f 4d d8             	cmovge %eax,%ebx
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_WIDTH, outline_width, lv_style_int_t, _int, scalar)
   1d1b5:	ba 40 00 00 00       	mov    $0x40,%edx
   1d1ba:	44 89 e6             	mov    %r12d,%esi
   1d1bd:	48 89 ef             	mov    %rbp,%rdi
   1d1c0:	e8 28 e5 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
   1d1c5:	44 0f bf e8          	movswl %ax,%r13d
    if(outline_width) {
   1d1c9:	66 45 85 ed          	test   %r13w,%r13w
   1d1cd:	74 32                	je     1d201 <lv_obj_get_draw_rect_ext_pad_size+0x27d>
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_OPA, outline_opa, lv_opa_t, _opa, scalar)
   1d1cf:	ba 4c 00 00 00       	mov    $0x4c,%edx
   1d1d4:	44 89 e6             	mov    %r12d,%esi
   1d1d7:	48 89 ef             	mov    %rbp,%rdi
   1d1da:	e8 3c eb ff ff       	callq  1bd1b <_lv_obj_get_style_opa>
        if(outline_opa > LV_OPA_MIN) {
   1d1df:	3c 02                	cmp    $0x2,%al
   1d1e1:	76 1e                	jbe    1d201 <lv_obj_get_draw_rect_ext_pad_size+0x27d>
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_PAD, outline_pad, lv_style_int_t, _int, scalar)
   1d1e3:	ba 41 00 00 00       	mov    $0x41,%edx
   1d1e8:	44 89 e6             	mov    %r12d,%esi
   1d1eb:	48 89 ef             	mov    %rbp,%rdi
   1d1ee:	e8 fa e4 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
            s = LV_MATH_MAX(s, outline_pad + outline_width);
   1d1f3:	0f bf d0             	movswl %ax,%edx
   1d1f6:	0f bf db             	movswl %bx,%ebx
   1d1f9:	44 01 ea             	add    %r13d,%edx
   1d1fc:	39 da                	cmp    %ebx,%edx
   1d1fe:	0f 4d da             	cmovge %edx,%ebx
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   1d201:	ba 04 00 00 00       	mov    $0x4,%edx
   1d206:	44 89 e6             	mov    %r12d,%esi
   1d209:	48 89 ef             	mov    %rbp,%rdi
   1d20c:	e8 dc e4 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   1d211:	ba 05 00 00 00       	mov    $0x5,%edx
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   1d216:	41 89 c5             	mov    %eax,%r13d
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   1d219:	44 89 e6             	mov    %r12d,%esi
   1d21c:	48 89 ef             	mov    %rbp,%rdi
   1d21f:	e8 c9 e4 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    lv_coord_t wh = LV_MATH_MAX(w, h);
   1d224:	66 44 39 e8          	cmp    %r13w,%ax
   1d228:	41 0f 4c c5          	cmovl  %r13d,%eax
    if(wh > 0) s += wh;
   1d22c:	66 85 c0             	test   %ax,%ax
   1d22f:	7e 02                	jle    1d233 <lv_obj_get_draw_rect_ext_pad_size+0x2af>
   1d231:	01 c3                	add    %eax,%ebx
}
   1d233:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
   1d238:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
   1d23f:	00 00 
   1d241:	89 d8                	mov    %ebx,%eax
   1d243:	74 05                	je     1d24a <lv_obj_get_draw_rect_ext_pad_size+0x2c6>
   1d245:	e8 f6 73 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1d24a:	48 83 c4 28          	add    $0x28,%rsp
   1d24e:	5b                   	pop    %rbx
   1d24f:	5d                   	pop    %rbp
   1d250:	41 5c                	pop    %r12
   1d252:	41 5d                	pop    %r13
   1d254:	41 5e                	pop    %r14
   1d256:	41 5f                	pop    %r15
   1d258:	c3                   	retq   

000000000001d259 <lv_obj_get_focused_obj>:
    if(obj == NULL) return NULL;
   1d259:	48 85 ff             	test   %rdi,%rdi
{
   1d25c:	53                   	push   %rbx
   1d25d:	48 89 fb             	mov    %rdi,%rbx
    if(obj == NULL) return NULL;
   1d260:	75 14                	jne    1d276 <lv_obj_get_focused_obj+0x1d>
   1d262:	31 db                	xor    %ebx,%ebx
   1d264:	eb 1c                	jmp    1d282 <lv_obj_get_focused_obj+0x29>
    while(lv_obj_get_focus_parent(focus_obj) != false && focus_obj != NULL) {
   1d266:	48 85 db             	test   %rbx,%rbx
   1d269:	74 f7                	je     1d262 <lv_obj_get_focused_obj+0x9>
        focus_obj = lv_obj_get_parent(focus_obj);
   1d26b:	48 89 df             	mov    %rbx,%rdi
   1d26e:	e8 ac d5 ff ff       	callq  1a81f <lv_obj_get_parent>
   1d273:	48 89 c3             	mov    %rax,%rbx
    while(lv_obj_get_focus_parent(focus_obj) != false && focus_obj != NULL) {
   1d276:	48 89 df             	mov    %rbx,%rdi
   1d279:	e8 0e de ff ff       	callq  1b08c <lv_obj_get_focus_parent>
   1d27e:	84 c0                	test   %al,%al
   1d280:	75 e4                	jne    1d266 <lv_obj_get_focused_obj+0xd>
}
   1d282:	48 89 d8             	mov    %rbx,%rax
   1d285:	5b                   	pop    %rbx
   1d286:	c3                   	retq   

000000000001d287 <lv_obj_signal>:
    if(sign == LV_SIGNAL_GET_STYLE) {
   1d287:	40 80 fe 08          	cmp    $0x8,%sil
{
   1d28b:	53                   	push   %rbx
    if(sign == LV_SIGNAL_GET_STYLE) {
   1d28c:	75 1f                	jne    1d2ad <lv_obj_signal+0x26>
        if(info->part == LV_OBJ_PART_MAIN) info->result = &obj->style_list;
   1d28e:	80 3a 00             	cmpb   $0x0,(%rdx)
   1d291:	75 0d                	jne    1d2a0 <lv_obj_signal+0x19>
   1d293:	48 8d 5f 48          	lea    0x48(%rdi),%rbx
   1d297:	48 89 5a 08          	mov    %rbx,0x8(%rdx)
   1d29b:	e9 d4 00 00 00       	jmpq   1d374 <lv_obj_signal+0xed>
        else info->result = NULL;
   1d2a0:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
   1d2a7:	00 
   1d2a8:	e9 c7 00 00 00       	jmpq   1d374 <lv_obj_signal+0xed>
    else if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
   1d2ad:	40 80 fe 07          	cmp    $0x7,%sil
   1d2b1:	75 10                	jne    1d2c3 <lv_obj_signal+0x3c>
}
   1d2b3:	5b                   	pop    %rbx
    else if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
   1d2b4:	48 8d 35 41 62 01 00 	lea    0x16241(%rip),%rsi        # 334fc <__func__.5785+0x2894>
   1d2bb:	48 89 d7             	mov    %rdx,%rdi
   1d2be:	e9 a5 f0 ff ff       	jmpq   1c368 <lv_obj_handle_get_type_signal>
    if(sign == LV_SIGNAL_CHILD_CHG) {
   1d2c3:	40 80 fe 01          	cmp    $0x1,%sil
   1d2c7:	48 89 fb             	mov    %rdi,%rbx
   1d2ca:	75 12                	jne    1d2de <lv_obj_signal+0x57>
        if(lv_obj_is_protected(obj, LV_PROTECT_CHILD_CHG) != false) res = LV_RES_INV;
   1d2cc:	be 01 00 00 00       	mov    $0x1,%esi
   1d2d1:	e8 f0 e2 ff ff       	callq  1b5c6 <lv_obj_is_protected>
   1d2d6:	83 f0 01             	xor    $0x1,%eax
   1d2d9:	e9 98 00 00 00       	jmpq   1d376 <lv_obj_signal+0xef>
    else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
   1d2de:	40 80 fe 06          	cmp    $0x6,%sil
   1d2e2:	75 16                	jne    1d2fa <lv_obj_signal+0x73>
        lv_coord_t d = lv_obj_get_draw_rect_ext_pad_size(obj, LV_OBJ_PART_MAIN);
   1d2e4:	31 f6                	xor    %esi,%esi
   1d2e6:	e8 99 fc ff ff       	callq  1cf84 <lv_obj_get_draw_rect_ext_pad_size>
        obj->ext_draw_pad = LV_MATH_MAX(obj->ext_draw_pad, d);
   1d2eb:	66 39 43 58          	cmp    %ax,0x58(%rbx)
   1d2ef:	66 0f 4d 43 58       	cmovge 0x58(%rbx),%ax
   1d2f4:	66 89 43 58          	mov    %ax,0x58(%rbx)
   1d2f8:	eb 7a                	jmp    1d374 <lv_obj_signal+0xed>
    else if(sign == LV_SIGNAL_STYLE_CHG) {
   1d2fa:	40 80 fe 04          	cmp    $0x4,%sil
   1d2fe:	75 07                	jne    1d307 <lv_obj_signal+0x80>
        lv_obj_refresh_ext_draw_pad(obj);
   1d300:	e8 07 d5 ff ff       	callq  1a80c <lv_obj_refresh_ext_draw_pad>
   1d305:	eb 6d                	jmp    1d374 <lv_obj_signal+0xed>
    else if(sign == LV_SIGNAL_PRESSED) {
   1d307:	40 80 fe 0b          	cmp    $0xb,%sil
   1d30b:	75 0c                	jne    1d319 <lv_obj_signal+0x92>
        lv_obj_add_state(obj, LV_STATE_PRESSED);
   1d30d:	be 10 00 00 00       	mov    $0x10,%esi
   1d312:	e8 43 fc ff ff       	callq  1cf5a <lv_obj_add_state>
   1d317:	eb 5b                	jmp    1d374 <lv_obj_signal+0xed>
    else if(sign == LV_SIGNAL_RELEASED || sign == LV_SIGNAL_PRESS_LOST) {
   1d319:	8d 46 f3             	lea    -0xd(%rsi),%eax
   1d31c:	3c 01                	cmp    $0x1,%al
   1d31e:	77 07                	ja     1d327 <lv_obj_signal+0xa0>
        lv_obj_clear_state(obj, LV_STATE_PRESSED);
   1d320:	be 10 00 00 00       	mov    $0x10,%esi
   1d325:	eb 20                	jmp    1d347 <lv_obj_signal+0xc0>
    else if(sign == LV_SIGNAL_FOCUS) {
   1d327:	40 80 fe 16          	cmp    $0x16,%sil
   1d32b:	75 1f                	jne    1d34c <lv_obj_signal+0xc5>
            obj = lv_obj_get_focused_obj(obj);
   1d32d:	e8 27 ff ff ff       	callq  1d259 <lv_obj_get_focused_obj>
            lv_obj_add_state(obj, LV_STATE_FOCUSED);
   1d332:	be 02 00 00 00       	mov    $0x2,%esi
   1d337:	48 89 c7             	mov    %rax,%rdi
            obj = lv_obj_get_focused_obj(obj);
   1d33a:	48 89 c3             	mov    %rax,%rbx
            lv_obj_add_state(obj, LV_STATE_FOCUSED);
   1d33d:	e8 18 fc ff ff       	callq  1cf5a <lv_obj_add_state>
            lv_obj_clear_state(obj, LV_STATE_EDITED);
   1d342:	be 04 00 00 00       	mov    $0x4,%esi
   1d347:	48 89 df             	mov    %rbx,%rdi
   1d34a:	eb 13                	jmp    1d35f <lv_obj_signal+0xd8>
    else if(sign == LV_SIGNAL_DEFOCUS) {
   1d34c:	40 80 fe 17          	cmp    $0x17,%sil
   1d350:	75 14                	jne    1d366 <lv_obj_signal+0xdf>
        obj = lv_obj_get_focused_obj(obj);
   1d352:	e8 02 ff ff ff       	callq  1d259 <lv_obj_get_focused_obj>
        lv_obj_clear_state(obj, LV_STATE_FOCUSED | LV_STATE_EDITED);
   1d357:	be 06 00 00 00       	mov    $0x6,%esi
   1d35c:	48 89 c7             	mov    %rax,%rdi
   1d35f:	e8 0a fc ff ff       	callq  1cf6e <lv_obj_clear_state>
   1d364:	eb 0e                	jmp    1d374 <lv_obj_signal+0xed>
    else if(sign == LV_SIGNAL_CLEANUP) {
   1d366:	40 84 f6             	test   %sil,%sil
   1d369:	b0 01                	mov    $0x1,%al
   1d36b:	75 09                	jne    1d376 <lv_obj_signal+0xef>
        lv_obj_clean_style_list(obj, LV_OBJ_PART_MAIN);
   1d36d:	31 f6                	xor    %esi,%esi
   1d36f:	e8 fe d6 ff ff       	callq  1aa72 <lv_obj_clean_style_list>
   1d374:	b0 01                	mov    $0x1,%al
}
   1d376:	5b                   	pop    %rbx
   1d377:	c3                   	retq   

000000000001d378 <lv_refr_get_top_obj>:
 * @param area_p pointer to an area
 * @param obj the first object to start the searching (typically a screen)
 * @return
 */
static lv_obj_t * lv_refr_get_top_obj(const lv_area_t * area_p, lv_obj_t * obj)
{
   1d378:	41 56                	push   %r14
   1d37a:	41 55                	push   %r13
    lv_obj_t * found_p = NULL;

    /*If this object is fully cover the draw area check the children too */
    if(_lv_area_is_in(area_p, &obj->coords, 0) && obj->hidden == 0) {
   1d37c:	31 d2                	xor    %edx,%edx
{
   1d37e:	41 54                	push   %r12
   1d380:	55                   	push   %rbp
   1d381:	49 89 fc             	mov    %rdi,%r12
   1d384:	53                   	push   %rbx
   1d385:	48 89 f3             	mov    %rsi,%rbx
    if(_lv_area_is_in(area_p, &obj->coords, 0) && obj->hidden == 0) {
   1d388:	48 83 c6 20          	add    $0x20,%rsi
   1d38c:	e8 2a 84 00 00       	callq  257bb <_lv_area_is_in>
   1d391:	84 c0                	test   %al,%al
   1d393:	75 04                	jne    1d399 <lv_refr_get_top_obj+0x21>
    lv_obj_t * found_p = NULL;
   1d395:	31 c0                	xor    %eax,%eax
   1d397:	eb 54                	jmp    1d3ed <lv_refr_get_top_obj+0x75>
    if(_lv_area_is_in(area_p, &obj->coords, 0) && obj->hidden == 0) {
   1d399:	f6 43 5a 10          	testb  $0x10,0x5a(%rbx)
   1d39d:	75 f6                	jne    1d395 <lv_refr_get_top_obj+0x1d>
        lv_design_res_t design_res = obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK);
   1d39f:	ba 02 00 00 00       	mov    $0x2,%edx
   1d3a4:	4c 89 e6             	mov    %r12,%rsi
   1d3a7:	48 89 df             	mov    %rbx,%rdi
   1d3aa:	ff 53 38             	callq  *0x38(%rbx)
        if(design_res == LV_DESIGN_RES_MASKED) return NULL;
   1d3ad:	3c 03                	cmp    $0x3,%al
        lv_design_res_t design_res = obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK);
   1d3af:	41 88 c5             	mov    %al,%r13b
        if(design_res == LV_DESIGN_RES_MASKED) return NULL;
   1d3b2:	74 e1                	je     1d395 <lv_refr_get_top_obj+0x1d>
            design_res = LV_DESIGN_RES_NOT_COVER;
        }
#endif

        lv_obj_t * i;
        _LV_LL_READ(obj->child_ll, i) {
   1d3b4:	4c 8d 73 08          	lea    0x8(%rbx),%r14
   1d3b8:	4c 89 f7             	mov    %r14,%rdi
   1d3bb:	e8 ab 88 00 00       	callq  25c6b <_lv_ll_get_head>
   1d3c0:	48 85 c0             	test   %rax,%rax
   1d3c3:	48 89 c5             	mov    %rax,%rbp
   1d3c6:	74 1d                	je     1d3e5 <lv_refr_get_top_obj+0x6d>
            found_p = lv_refr_get_top_obj(area_p, i);
   1d3c8:	48 89 ee             	mov    %rbp,%rsi
   1d3cb:	4c 89 e7             	mov    %r12,%rdi
   1d3ce:	e8 a5 ff ff ff       	callq  1d378 <lv_refr_get_top_obj>

            /*If a children is ok then break*/
            if(found_p != NULL) {
   1d3d3:	48 85 c0             	test   %rax,%rax
   1d3d6:	75 15                	jne    1d3ed <lv_refr_get_top_obj+0x75>
        _LV_LL_READ(obj->child_ll, i) {
   1d3d8:	48 89 ee             	mov    %rbp,%rsi
   1d3db:	4c 89 f7             	mov    %r14,%rdi
   1d3de:	e8 a0 88 00 00       	callq  25c83 <_lv_ll_get_next>
   1d3e3:	eb db                	jmp    1d3c0 <lv_refr_get_top_obj+0x48>
            }
        }

        /*If no better children use this object*/
        if(found_p == NULL) {
            if(design_res == LV_DESIGN_RES_COVER) {
   1d3e5:	41 fe cd             	dec    %r13b
   1d3e8:	48 89 d8             	mov    %rbx,%rax
   1d3eb:	75 a8                	jne    1d395 <lv_refr_get_top_obj+0x1d>
            }
        }
    }

    return found_p;
}
   1d3ed:	5b                   	pop    %rbx
   1d3ee:	5d                   	pop    %rbp
   1d3ef:	41 5c                	pop    %r12
   1d3f1:	41 5d                	pop    %r13
   1d3f3:	41 5e                	pop    %r14
   1d3f5:	c3                   	retq   

000000000001d3f6 <lv_refr_obj>:
 * Refresh an object an all of its children. (Called recursively)
 * @param obj pointer to an object to refresh
 * @param mask_ori_p pointer to an area, the objects will be drawn only here
 */
static void lv_refr_obj(lv_obj_t * obj, const lv_area_t * mask_ori_p)
{
   1d3f6:	41 57                	push   %r15
   1d3f8:	41 56                	push   %r14
   1d3fa:	41 55                	push   %r13
   1d3fc:	41 54                	push   %r12
   1d3fe:	55                   	push   %rbp
   1d3ff:	53                   	push   %rbx
   1d400:	48 83 ec 48          	sub    $0x48,%rsp
   1d404:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1d40b:	00 00 
   1d40d:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
   1d412:	31 c0                	xor    %eax,%eax
    /*Do not refresh hidden objects*/
    if(obj->hidden != 0) return;
   1d414:	f6 47 5a 10          	testb  $0x10,0x5a(%rdi)
   1d418:	0f 85 0c 01 00 00    	jne    1d52a <lv_refr_obj+0x134>
     * because the parent and its children are visible only here */
    lv_area_t obj_mask;
    lv_area_t obj_ext_mask;
    lv_area_t obj_area;
    lv_coord_t ext_size = obj->ext_draw_pad;
    lv_obj_get_coords(obj, &obj_area);
   1d41e:	48 8d 6c 24 20       	lea    0x20(%rsp),%rbp
   1d423:	49 89 f5             	mov    %rsi,%r13
    lv_coord_t ext_size = obj->ext_draw_pad;
   1d426:	44 8b 67 58          	mov    0x58(%rdi),%r12d
   1d42a:	48 89 fb             	mov    %rdi,%rbx
    lv_obj_get_coords(obj, &obj_area);
   1d42d:	48 89 ee             	mov    %rbp,%rsi
   1d430:	e8 7d d5 ff ff       	callq  1a9b2 <lv_obj_get_coords>
    obj_area.x1 -= ext_size;
   1d435:	66 44 29 64 24 20    	sub    %r12w,0x20(%rsp)
    obj_area.y1 -= ext_size;
   1d43b:	66 44 29 64 24 22    	sub    %r12w,0x22(%rsp)
    obj_area.x2 += ext_size;
    obj_area.y2 += ext_size;
    union_ok = _lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
   1d441:	48 89 ea             	mov    %rbp,%rdx
   1d444:	4c 89 ee             	mov    %r13,%rsi
    obj_area.x2 += ext_size;
   1d447:	66 44 01 64 24 24    	add    %r12w,0x24(%rsp)
    obj_area.y2 += ext_size;
   1d44d:	66 44 01 64 24 26    	add    %r12w,0x26(%rsp)
    union_ok = _lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
   1d453:	4c 8d 64 24 18       	lea    0x18(%rsp),%r12
   1d458:	4c 89 e7             	mov    %r12,%rdi
   1d45b:	e8 bc 80 00 00       	callq  2551c <_lv_area_intersect>

    /*Draw the parent and its children only if they ore on 'mask_parent'*/
    if(union_ok != false) {
   1d460:	84 c0                	test   %al,%al
   1d462:	0f 84 c2 00 00 00    	je     1d52a <lv_refr_obj+0x134>

        /* Redraw the object */
        if(obj->design_cb) obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_MAIN);
   1d468:	48 8b 43 38          	mov    0x38(%rbx),%rax
   1d46c:	48 85 c0             	test   %rax,%rax
   1d46f:	74 0a                	je     1d47b <lv_refr_obj+0x85>
   1d471:	31 d2                	xor    %edx,%edx
   1d473:	4c 89 e6             	mov    %r12,%rsi
   1d476:	48 89 df             	mov    %rbx,%rdi
   1d479:	ff d0                	callq  *%rax
        debug_color.ch.alpha = 0xff;
#endif
#endif
        /*Create a new 'obj_mask' without 'ext_size' because the children can't be visible there*/
        lv_obj_get_coords(obj, &obj_area);
        union_ok = _lv_area_intersect(&obj_mask, mask_ori_p, &obj_area);
   1d47b:	4c 8d 74 24 10       	lea    0x10(%rsp),%r14
        lv_obj_get_coords(obj, &obj_area);
   1d480:	48 89 ee             	mov    %rbp,%rsi
   1d483:	48 89 df             	mov    %rbx,%rdi
   1d486:	e8 27 d5 ff ff       	callq  1a9b2 <lv_obj_get_coords>
        union_ok = _lv_area_intersect(&obj_mask, mask_ori_p, &obj_area);
   1d48b:	48 89 ea             	mov    %rbp,%rdx
   1d48e:	4c 89 ee             	mov    %r13,%rsi
   1d491:	4c 89 f7             	mov    %r14,%rdi
   1d494:	e8 83 80 00 00       	callq  2551c <_lv_area_intersect>
        if(union_ok != false) {
   1d499:	84 c0                	test   %al,%al
   1d49b:	74 77                	je     1d514 <lv_refr_obj+0x11e>
            lv_area_t mask_child; /*Mask from obj and its child*/
            lv_obj_t * child_p;
            lv_area_t child_area;
            _LV_LL_READ_BACK(obj->child_ll, child_p) {
   1d49d:	4c 8d 6b 08          	lea    0x8(%rbx),%r13
                lv_obj_get_coords(child_p, &child_area);
   1d4a1:	4c 8d 7c 24 30       	lea    0x30(%rsp),%r15
            _LV_LL_READ_BACK(obj->child_ll, child_p) {
   1d4a6:	4c 89 ef             	mov    %r13,%rdi
   1d4a9:	e8 c9 87 00 00       	callq  25c77 <_lv_ll_get_tail>
   1d4ae:	48 89 c5             	mov    %rax,%rbp
   1d4b1:	48 85 ed             	test   %rbp,%rbp
   1d4b4:	74 5e                	je     1d514 <lv_refr_obj+0x11e>
                lv_obj_get_coords(child_p, &child_area);
   1d4b6:	4c 89 fe             	mov    %r15,%rsi
   1d4b9:	48 89 ef             	mov    %rbp,%rdi
   1d4bc:	e8 f1 d4 ff ff       	callq  1a9b2 <lv_obj_get_coords>
                child_area.y1 -= ext_size;
                child_area.x2 += ext_size;
                child_area.y2 += ext_size;
                /* Get the union (common parts) of original mask (from obj)
                 * and its child */
                union_ok = _lv_area_intersect(&mask_child, &obj_mask, &child_area);
   1d4c1:	48 8d 4c 24 28       	lea    0x28(%rsp),%rcx
   1d4c6:	4c 89 fa             	mov    %r15,%rdx
   1d4c9:	4c 89 f6             	mov    %r14,%rsi
                child_area.x1 -= ext_size;
   1d4cc:	8b 45 58             	mov    0x58(%rbp),%eax
   1d4cf:	66 29 44 24 30       	sub    %ax,0x30(%rsp)
                union_ok = _lv_area_intersect(&mask_child, &obj_mask, &child_area);
   1d4d4:	48 89 cf             	mov    %rcx,%rdi
                child_area.y1 -= ext_size;
   1d4d7:	66 29 44 24 32       	sub    %ax,0x32(%rsp)
                union_ok = _lv_area_intersect(&mask_child, &obj_mask, &child_area);
   1d4dc:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
                child_area.x2 += ext_size;
   1d4e1:	66 01 44 24 34       	add    %ax,0x34(%rsp)
                child_area.y2 += ext_size;
   1d4e6:	66 01 44 24 36       	add    %ax,0x36(%rsp)
                union_ok = _lv_area_intersect(&mask_child, &obj_mask, &child_area);
   1d4eb:	e8 2c 80 00 00       	callq  2551c <_lv_area_intersect>

                /*If the parent and the child has common area then refresh the child */
                if(union_ok) {
   1d4f0:	84 c0                	test   %al,%al
   1d4f2:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
   1d4f7:	74 0b                	je     1d504 <lv_refr_obj+0x10e>
                    /*Refresh the next children*/
                    lv_refr_obj(child_p, &mask_child);
   1d4f9:	48 89 ce             	mov    %rcx,%rsi
   1d4fc:	48 89 ef             	mov    %rbp,%rdi
   1d4ff:	e8 f2 fe ff ff       	callq  1d3f6 <lv_refr_obj>
            _LV_LL_READ_BACK(obj->child_ll, child_p) {
   1d504:	48 89 ee             	mov    %rbp,%rsi
   1d507:	4c 89 ef             	mov    %r13,%rdi
   1d50a:	e8 83 87 00 00       	callq  25c92 <_lv_ll_get_prev>
   1d50f:	48 89 c5             	mov    %rax,%rbp
   1d512:	eb 9d                	jmp    1d4b1 <lv_refr_obj+0xbb>
                }
            }
        }

        /* If all the children are redrawn make 'post draw' design */
        if(obj->design_cb) obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_POST);
   1d514:	48 8b 43 38          	mov    0x38(%rbx),%rax
   1d518:	48 85 c0             	test   %rax,%rax
   1d51b:	74 0d                	je     1d52a <lv_refr_obj+0x134>
   1d51d:	ba 01 00 00 00       	mov    $0x1,%edx
   1d522:	4c 89 e6             	mov    %r12,%rsi
   1d525:	48 89 df             	mov    %rbx,%rdi
   1d528:	ff d0                	callq  *%rax
    }
}
   1d52a:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
   1d52f:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1d536:	00 00 
   1d538:	74 05                	je     1d53f <lv_refr_obj+0x149>
   1d53a:	e8 01 71 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1d53f:	48 83 c4 48          	add    $0x48,%rsp
   1d543:	5b                   	pop    %rbx
   1d544:	5d                   	pop    %rbp
   1d545:	41 5c                	pop    %r12
   1d547:	41 5d                	pop    %r13
   1d549:	41 5e                	pop    %r14
   1d54b:	41 5f                	pop    %r15
   1d54d:	c3                   	retq   

000000000001d54e <lv_refr_obj_and_children>:
{
   1d54e:	41 55                	push   %r13
   1d550:	41 54                	push   %r12
   1d552:	49 89 f4             	mov    %rsi,%r12
   1d555:	55                   	push   %rbp
   1d556:	53                   	push   %rbx
   1d557:	48 89 fd             	mov    %rdi,%rbp
   1d55a:	48 83 ec 18          	sub    $0x18,%rsp
    if(top_p == NULL) top_p = lv_disp_get_scr_act(disp_refr);
   1d55e:	48 85 ff             	test   %rdi,%rdi
   1d561:	75 14                	jne    1d577 <lv_refr_obj_and_children+0x29>
   1d563:	48 8b 3d 6e aa 23 00 	mov    0x23aa6e(%rip),%rdi        # 257fd8 <disp_refr>
   1d56a:	e8 e6 bc ff ff       	callq  19255 <lv_disp_get_scr_act>
    if(top_p == NULL) return;  /*Shouldn't happen*/
   1d56f:	48 85 c0             	test   %rax,%rax
    if(top_p == NULL) top_p = lv_disp_get_scr_act(disp_refr);
   1d572:	48 89 c5             	mov    %rax,%rbp
    if(top_p == NULL) return;  /*Shouldn't happen*/
   1d575:	74 6c                	je     1d5e3 <lv_refr_obj_and_children+0x95>
    lv_refr_obj(top_p, mask_p);
   1d577:	48 89 ef             	mov    %rbp,%rdi
   1d57a:	4c 89 e6             	mov    %r12,%rsi
   1d57d:	e8 74 fe ff ff       	callq  1d3f6 <lv_refr_obj>
    par = lv_obj_get_parent(top_p);
   1d582:	48 89 ef             	mov    %rbp,%rdi
   1d585:	e8 95 d2 ff ff       	callq  1a81f <lv_obj_get_parent>
    while(par != NULL) {
   1d58a:	48 85 c0             	test   %rax,%rax
        par = lv_obj_get_parent(par);
   1d58d:	48 89 c3             	mov    %rax,%rbx
    while(par != NULL) {
   1d590:	74 51                	je     1d5e3 <lv_refr_obj_and_children+0x95>
        lv_obj_t * i = _lv_ll_get_prev(&(par->child_ll), border_p);
   1d592:	4c 8d 6b 08          	lea    0x8(%rbx),%r13
   1d596:	48 89 ee             	mov    %rbp,%rsi
            i = _lv_ll_get_prev(&(par->child_ll), i);
   1d599:	4c 89 ef             	mov    %r13,%rdi
   1d59c:	e8 f1 86 00 00       	callq  25c92 <_lv_ll_get_prev>
        while(i != NULL) {
   1d5a1:	48 85 c0             	test   %rax,%rax
   1d5a4:	74 1a                	je     1d5c0 <lv_refr_obj_and_children+0x72>
            lv_refr_obj(i, mask_p);
   1d5a6:	4c 89 e6             	mov    %r12,%rsi
   1d5a9:	48 89 c7             	mov    %rax,%rdi
   1d5ac:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   1d5b1:	e8 40 fe ff ff       	callq  1d3f6 <lv_refr_obj>
            i = _lv_ll_get_prev(&(par->child_ll), i);
   1d5b6:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   1d5bb:	48 89 c6             	mov    %rax,%rsi
   1d5be:	eb d9                	jmp    1d599 <lv_refr_obj_and_children+0x4b>
        if(par->design_cb) par->design_cb(par, mask_p, LV_DESIGN_DRAW_POST);
   1d5c0:	48 8b 43 38          	mov    0x38(%rbx),%rax
   1d5c4:	48 85 c0             	test   %rax,%rax
   1d5c7:	74 0d                	je     1d5d6 <lv_refr_obj_and_children+0x88>
   1d5c9:	ba 01 00 00 00       	mov    $0x1,%edx
   1d5ce:	4c 89 e6             	mov    %r12,%rsi
   1d5d1:	48 89 df             	mov    %rbx,%rdi
   1d5d4:	ff d0                	callq  *%rax
        par = lv_obj_get_parent(par);
   1d5d6:	48 89 df             	mov    %rbx,%rdi
   1d5d9:	48 89 dd             	mov    %rbx,%rbp
   1d5dc:	e8 3e d2 ff ff       	callq  1a81f <lv_obj_get_parent>
   1d5e1:	eb a7                	jmp    1d58a <lv_refr_obj_and_children+0x3c>
}
   1d5e3:	48 83 c4 18          	add    $0x18,%rsp
   1d5e7:	5b                   	pop    %rbx
   1d5e8:	5d                   	pop    %rbp
   1d5e9:	41 5c                	pop    %r12
   1d5eb:	41 5d                	pop    %r13
   1d5ed:	c3                   	retq   

000000000001d5ee <_lv_refr_init>:
}
   1d5ee:	c3                   	retq   

000000000001d5ef <_lv_inv_area>:
{
   1d5ef:	41 55                	push   %r13
   1d5f1:	41 54                	push   %r12
   1d5f3:	55                   	push   %rbp
   1d5f4:	53                   	push   %rbx
   1d5f5:	48 89 f5             	mov    %rsi,%rbp
   1d5f8:	48 89 fb             	mov    %rdi,%rbx
   1d5fb:	48 83 ec 28          	sub    $0x28,%rsp
   1d5ff:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1d606:	00 00 
   1d608:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1d60d:	31 c0                	xor    %eax,%eax
    if(!disp) disp = lv_disp_get_default();
   1d60f:	48 85 ff             	test   %rdi,%rdi
   1d612:	75 11                	jne    1d625 <_lv_inv_area+0x36>
   1d614:	e8 25 7a 00 00       	callq  2503e <lv_disp_get_default>
    if(!disp) return;
   1d619:	48 85 c0             	test   %rax,%rax
    if(!disp) disp = lv_disp_get_default();
   1d61c:	48 89 c3             	mov    %rax,%rbx
    if(!disp) return;
   1d61f:	0f 84 f5 00 00 00    	je     1d71a <_lv_inv_area+0x12b>
    if(area_p == NULL) {
   1d625:	48 85 ed             	test   %rbp,%rbp
   1d628:	75 0e                	jne    1d638 <_lv_inv_area+0x49>
        disp->inv_p = 0;
   1d62a:	66 81 a3 d2 01 00 00 	andw   $0xfc00,0x1d2(%rbx)
   1d631:	00 fc 
        return;
   1d633:	e9 e2 00 00 00       	jmpq   1d71a <_lv_inv_area+0x12b>
    scr_area.x2 = lv_disp_get_hor_res(disp) - 1;
   1d638:	48 89 df             	mov    %rbx,%rdi
    scr_area.x1 = 0;
   1d63b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
   1d642:	00 
    suc = _lv_area_intersect(&com_area, area_p, &scr_area);
   1d643:	4c 8d 6c 24 10       	lea    0x10(%rsp),%r13
    scr_area.x2 = lv_disp_get_hor_res(disp) - 1;
   1d648:	e8 f9 79 00 00       	callq  25046 <lv_disp_get_hor_res>
    scr_area.y2 = lv_disp_get_ver_res(disp) - 1;
   1d64d:	48 89 df             	mov    %rbx,%rdi
    scr_area.x2 = lv_disp_get_hor_res(disp) - 1;
   1d650:	ff c8                	dec    %eax
   1d652:	66 89 44 24 0c       	mov    %ax,0xc(%rsp)
    scr_area.y2 = lv_disp_get_ver_res(disp) - 1;
   1d657:	e8 23 7a 00 00       	callq  2507f <lv_disp_get_ver_res>
    suc = _lv_area_intersect(&com_area, area_p, &scr_area);
   1d65c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
    scr_area.y2 = lv_disp_get_ver_res(disp) - 1;
   1d661:	ff c8                	dec    %eax
    suc = _lv_area_intersect(&com_area, area_p, &scr_area);
   1d663:	48 89 ee             	mov    %rbp,%rsi
   1d666:	4c 89 ef             	mov    %r13,%rdi
    scr_area.y2 = lv_disp_get_ver_res(disp) - 1;
   1d669:	66 89 44 24 0e       	mov    %ax,0xe(%rsp)
    suc = _lv_area_intersect(&com_area, area_p, &scr_area);
   1d66e:	e8 a9 7e 00 00       	callq  2551c <_lv_area_intersect>
    if(suc != false) {
   1d673:	84 c0                	test   %al,%al
   1d675:	0f 84 9f 00 00 00    	je     1d71a <_lv_inv_area+0x12b>
        if(disp->driver.rounder_cb) disp->driver.rounder_cb(&disp->driver, &com_area);
   1d67b:	48 8b 43 20          	mov    0x20(%rbx),%rax
   1d67f:	48 85 c0             	test   %rax,%rax
   1d682:	74 08                	je     1d68c <_lv_inv_area+0x9d>
   1d684:	4c 89 ee             	mov    %r13,%rsi
   1d687:	48 89 df             	mov    %rbx,%rdi
   1d68a:	ff d0                	callq  *%rax
   1d68c:	4c 8d a3 b2 00 00 00 	lea    0xb2(%rbx),%r12
{
   1d693:	31 ed                	xor    %ebp,%ebp
        for(i = 0; i < disp->inv_p; i++) {
   1d695:	66 8b 93 d2 01 00 00 	mov    0x1d2(%rbx),%dx
   1d69c:	89 d0                	mov    %edx,%eax
   1d69e:	66 25 ff 03          	and    $0x3ff,%ax
   1d6a2:	66 39 e8             	cmp    %bp,%ax
   1d6a5:	76 19                	jbe    1d6c0 <_lv_inv_area+0xd1>
            if(_lv_area_is_in(&com_area, &disp->inv_areas[i], 0) != false) return;
   1d6a7:	31 d2                	xor    %edx,%edx
   1d6a9:	4c 89 e6             	mov    %r12,%rsi
   1d6ac:	4c 89 ef             	mov    %r13,%rdi
   1d6af:	e8 07 81 00 00       	callq  257bb <_lv_area_is_in>
   1d6b4:	49 83 c4 08          	add    $0x8,%r12
   1d6b8:	84 c0                	test   %al,%al
   1d6ba:	75 5e                	jne    1d71a <_lv_inv_area+0x12b>
        for(i = 0; i < disp->inv_p; i++) {
   1d6bc:	ff c5                	inc    %ebp
   1d6be:	eb d5                	jmp    1d695 <_lv_inv_area+0xa6>
        if(disp->inv_p < LV_INV_BUF_SIZE) {
   1d6c0:	66 83 f8 1f          	cmp    $0x1f,%ax
   1d6c4:	77 12                	ja     1d6d8 <_lv_inv_area+0xe9>
   1d6c6:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
            lv_area_copy(&disp->inv_areas[disp->inv_p], &com_area);
   1d6cb:	0f b7 c0             	movzwl %ax,%eax
   1d6ce:	48 89 94 c3 b2 00 00 	mov    %rdx,0xb2(%rbx,%rax,8)
   1d6d5:	00 
   1d6d6:	eb 18                	jmp    1d6f0 <_lv_inv_area+0x101>
   1d6d8:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
            disp->inv_p = 0;
   1d6dd:	66 81 e2 00 fc       	and    $0xfc00,%dx
   1d6e2:	66 89 93 d2 01 00 00 	mov    %dx,0x1d2(%rbx)
   1d6e9:	48 89 83 b2 00 00 00 	mov    %rax,0xb2(%rbx)
        disp->inv_p++;
   1d6f0:	66 8b 83 d2 01 00 00 	mov    0x1d2(%rbx),%ax
        lv_task_set_prio(disp->refr_task, LV_REFR_TASK_PRIO);
   1d6f7:	48 8b 7b 60          	mov    0x60(%rbx),%rdi
   1d6fb:	be 03 00 00 00       	mov    $0x3,%esi
        disp->inv_p++;
   1d700:	8d 50 01             	lea    0x1(%rax),%edx
   1d703:	66 25 00 fc          	and    $0xfc00,%ax
   1d707:	66 81 e2 ff 03       	and    $0x3ff,%dx
   1d70c:	09 d0                	or     %edx,%eax
   1d70e:	66 89 83 d2 01 00 00 	mov    %ax,0x1d2(%rbx)
        lv_task_set_prio(disp->refr_task, LV_REFR_TASK_PRIO);
   1d715:	e8 7c 8f 00 00       	callq  26696 <lv_task_set_prio>
}
   1d71a:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
   1d71f:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1d726:	00 00 
   1d728:	74 05                	je     1d72f <_lv_inv_area+0x140>
   1d72a:	e8 11 6f fe ff       	callq  4640 <__stack_chk_fail@plt>
   1d72f:	48 83 c4 28          	add    $0x28,%rsp
   1d733:	5b                   	pop    %rbx
   1d734:	5d                   	pop    %rbp
   1d735:	41 5c                	pop    %r12
   1d737:	41 5d                	pop    %r13
   1d739:	c3                   	retq   

000000000001d73a <_lv_refr_get_disp_refreshing>:
}
   1d73a:	48 8b 05 97 a8 23 00 	mov    0x23a897(%rip),%rax        # 257fd8 <disp_refr>
   1d741:	c3                   	retq   

000000000001d742 <lv_refr_vdb_flush>:

/**
 * Flush the content of the VDB
 */
static void lv_refr_vdb_flush(void)
{
   1d742:	55                   	push   %rbp
   1d743:	53                   	push   %rbx
   1d744:	48 83 ec 08          	sub    $0x8,%rsp
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
   1d748:	48 8b 3d 89 a8 23 00 	mov    0x23a889(%rip),%rdi        # 257fd8 <disp_refr>
   1d74f:	e8 ae 79 00 00       	callq  25102 <lv_disp_get_buf>

    /*In double buffered mode wait until the other buffer is flushed before flushing the current
     * one*/
    if(lv_disp_is_double_buf(disp_refr)) {
   1d754:	48 8b 3d 7d a8 23 00 	mov    0x23a87d(%rip),%rdi        # 257fd8 <disp_refr>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
   1d75b:	48 89 c3             	mov    %rax,%rbx
    if(lv_disp_is_double_buf(disp_refr)) {
   1d75e:	e8 df 79 00 00       	callq  25142 <lv_disp_is_double_buf>
   1d763:	84 c0                	test   %al,%al
   1d765:	75 31                	jne    1d798 <lv_refr_vdb_flush+0x56>
        }
    }

    vdb->flushing = 1;

    if(disp_refr->driver.buffer->last_area && disp_refr->driver.buffer->last_part) vdb->flushing_last = 1;
   1d767:	48 8b 05 6a a8 23 00 	mov    0x23a86a(%rip),%rax        # 257fd8 <disp_refr>
    vdb->flushing = 1;
   1d76e:	c7 43 24 01 00 00 00 	movl   $0x1,0x24(%rbx)
    if(disp_refr->driver.buffer->last_area && disp_refr->driver.buffer->last_part) vdb->flushing_last = 1;
   1d775:	48 8b 40 08          	mov    0x8(%rax),%rax
   1d779:	48 8b 50 28          	mov    0x28(%rax),%rdx
   1d77d:	48 0f ba e2 20       	bt     $0x20,%rdx
   1d782:	72 1d                	jb     1d7a1 <lv_refr_vdb_flush+0x5f>
   1d784:	eb 2f                	jmp    1d7b5 <lv_refr_vdb_flush+0x73>
        while(vdb->flushing) {
   1d786:	8b 43 24             	mov    0x24(%rbx),%eax
   1d789:	85 c0                	test   %eax,%eax
   1d78b:	74 da                	je     1d767 <lv_refr_vdb_flush+0x25>
            if(disp_refr->driver.wait_cb) disp_refr->driver.wait_cb(&disp_refr->driver);
   1d78d:	48 8b 47 38          	mov    0x38(%rdi),%rax
   1d791:	48 85 c0             	test   %rax,%rax
   1d794:	74 f0                	je     1d786 <lv_refr_vdb_flush+0x44>
   1d796:	ff d0                	callq  *%rax
   1d798:	48 8b 3d 39 a8 23 00 	mov    0x23a839(%rip),%rdi        # 257fd8 <disp_refr>
   1d79f:	eb e5                	jmp    1d786 <lv_refr_vdb_flush+0x44>
    if(disp_refr->driver.buffer->last_area && disp_refr->driver.buffer->last_part) vdb->flushing_last = 1;
   1d7a1:	48 8b 40 28          	mov    0x28(%rax),%rax
   1d7a5:	48 0f ba e0 21       	bt     $0x21,%rax
   1d7aa:	73 09                	jae    1d7b5 <lv_refr_vdb_flush+0x73>
   1d7ac:	c7 43 28 01 00 00 00 	movl   $0x1,0x28(%rbx)
   1d7b3:	eb 07                	jmp    1d7bc <lv_refr_vdb_flush+0x7a>
    else vdb->flushing_last = 0;
   1d7b5:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%rbx)

    /*Flush the rendered content to the display*/
    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
   1d7bc:	e8 79 ff ff ff       	callq  1d73a <_lv_refr_get_disp_refreshing>
   1d7c1:	48 89 c5             	mov    %rax,%rbp
    if(disp->driver.gpu_wait_cb) disp->driver.gpu_wait_cb(&disp->driver);
   1d7c4:	48 8b 40 48          	mov    0x48(%rax),%rax
   1d7c8:	48 85 c0             	test   %rax,%rax
   1d7cb:	74 05                	je     1d7d2 <lv_refr_vdb_flush+0x90>
   1d7cd:	48 89 ef             	mov    %rbp,%rdi
   1d7d0:	ff d0                	callq  *%rax

    if(disp->driver.flush_cb) disp->driver.flush_cb(&disp->driver, &vdb->area, vdb->buf_act);
   1d7d2:	48 8b 45 18          	mov    0x18(%rbp),%rax
   1d7d6:	48 85 c0             	test   %rax,%rax
   1d7d9:	74 0d                	je     1d7e8 <lv_refr_vdb_flush+0xa6>
   1d7db:	48 8b 53 10          	mov    0x10(%rbx),%rdx
   1d7df:	48 8d 73 1c          	lea    0x1c(%rbx),%rsi
   1d7e3:	48 89 ef             	mov    %rbp,%rdi
   1d7e6:	ff d0                	callq  *%rax

    if(vdb->buf1 && vdb->buf2) {
   1d7e8:	48 8b 03             	mov    (%rbx),%rax
   1d7eb:	48 85 c0             	test   %rax,%rax
   1d7ee:	74 19                	je     1d809 <lv_refr_vdb_flush+0xc7>
   1d7f0:	48 8b 53 08          	mov    0x8(%rbx),%rdx
   1d7f4:	48 85 d2             	test   %rdx,%rdx
   1d7f7:	74 10                	je     1d809 <lv_refr_vdb_flush+0xc7>
        if(vdb->buf_act == vdb->buf1)
   1d7f9:	48 3b 43 10          	cmp    0x10(%rbx),%rax
   1d7fd:	75 06                	jne    1d805 <lv_refr_vdb_flush+0xc3>
            vdb->buf_act = vdb->buf2;
   1d7ff:	48 89 53 10          	mov    %rdx,0x10(%rbx)
   1d803:	eb 04                	jmp    1d809 <lv_refr_vdb_flush+0xc7>
        else
            vdb->buf_act = vdb->buf1;
   1d805:	48 89 43 10          	mov    %rax,0x10(%rbx)
    }
}
   1d809:	58                   	pop    %rax
   1d80a:	5b                   	pop    %rbx
   1d80b:	5d                   	pop    %rbp
   1d80c:	c3                   	retq   

000000000001d80d <lv_refr_area_part>:
{
   1d80d:	41 56                	push   %r14
   1d80f:	41 55                	push   %r13
   1d811:	41 54                	push   %r12
   1d813:	55                   	push   %rbp
   1d814:	48 89 fd             	mov    %rdi,%rbp
   1d817:	53                   	push   %rbx
   1d818:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
   1d81f:	48 8b 3d b2 a7 23 00 	mov    0x23a7b2(%rip),%rdi        # 257fd8 <disp_refr>
{
   1d826:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1d82d:	00 00 
   1d82f:	48 89 84 24 98 00 00 	mov    %rax,0x98(%rsp)
   1d836:	00 
   1d837:	31 c0                	xor    %eax,%eax
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
   1d839:	e8 c4 78 00 00       	callq  25102 <lv_disp_get_buf>
    if(lv_disp_is_double_buf(disp_refr) == false) {
   1d83e:	48 8b 3d 93 a7 23 00 	mov    0x23a793(%rip),%rdi        # 257fd8 <disp_refr>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
   1d845:	48 89 c3             	mov    %rax,%rbx
    if(lv_disp_is_double_buf(disp_refr) == false) {
   1d848:	e8 f5 78 00 00       	callq  25142 <lv_disp_is_double_buf>
   1d84d:	84 c0                	test   %al,%al
   1d84f:	74 62                	je     1d8b3 <lv_refr_area_part+0xa6>
    _lv_area_intersect(&start_mask, area_p, &vdb->area);
   1d851:	48 8d 53 1c          	lea    0x1c(%rbx),%rdx
   1d855:	48 8d 5c 24 08       	lea    0x8(%rsp),%rbx
   1d85a:	48 89 ee             	mov    %rbp,%rsi
    lv_obj_t * top_prev_scr = NULL;
   1d85d:	31 ed                	xor    %ebp,%ebp
    _lv_area_intersect(&start_mask, area_p, &vdb->area);
   1d85f:	48 89 df             	mov    %rbx,%rdi
   1d862:	e8 b5 7c 00 00       	callq  2551c <_lv_area_intersect>
    top_act_scr = lv_refr_get_top_obj(&start_mask, lv_disp_get_scr_act(disp_refr));
   1d867:	48 8b 3d 6a a7 23 00 	mov    0x23a76a(%rip),%rdi        # 257fd8 <disp_refr>
   1d86e:	e8 e2 b9 ff ff       	callq  19255 <lv_disp_get_scr_act>
   1d873:	48 89 df             	mov    %rbx,%rdi
   1d876:	48 89 c6             	mov    %rax,%rsi
   1d879:	e8 fa fa ff ff       	callq  1d378 <lv_refr_get_top_obj>
   1d87e:	49 89 c4             	mov    %rax,%r12
    if(disp_refr->prev_scr) {
   1d881:	48 8b 05 50 a7 23 00 	mov    0x23a750(%rip),%rax        # 257fd8 <disp_refr>
   1d888:	48 8b b0 88 00 00 00 	mov    0x88(%rax),%rsi
   1d88f:	48 85 f6             	test   %rsi,%rsi
   1d892:	74 28                	je     1d8bc <lv_refr_area_part+0xaf>
        top_prev_scr = lv_refr_get_top_obj(&start_mask, disp_refr->prev_scr);
   1d894:	48 89 df             	mov    %rbx,%rdi
   1d897:	e8 dc fa ff ff       	callq  1d378 <lv_refr_get_top_obj>
   1d89c:	48 89 c5             	mov    %rax,%rbp
   1d89f:	eb 1b                	jmp    1d8bc <lv_refr_area_part+0xaf>
        while(vdb->flushing) {
   1d8a1:	8b 43 24             	mov    0x24(%rbx),%eax
   1d8a4:	85 c0                	test   %eax,%eax
   1d8a6:	74 a9                	je     1d851 <lv_refr_area_part+0x44>
            if(disp_refr->driver.wait_cb) disp_refr->driver.wait_cb(&disp_refr->driver);
   1d8a8:	48 8b 47 38          	mov    0x38(%rdi),%rax
   1d8ac:	48 85 c0             	test   %rax,%rax
   1d8af:	74 f0                	je     1d8a1 <lv_refr_area_part+0x94>
   1d8b1:	ff d0                	callq  *%rax
   1d8b3:	48 8b 3d 1e a7 23 00 	mov    0x23a71e(%rip),%rdi        # 257fd8 <disp_refr>
   1d8ba:	eb e5                	jmp    1d8a1 <lv_refr_area_part+0x94>
    if(top_act_scr == NULL && top_prev_scr == NULL) {
   1d8bc:	4d 85 e4             	test   %r12,%r12
   1d8bf:	0f 85 f9 00 00 00    	jne    1d9be <lv_refr_area_part+0x1b1>
   1d8c5:	48 85 ed             	test   %rbp,%rbp
   1d8c8:	0f 85 f0 00 00 00    	jne    1d9be <lv_refr_area_part+0x1b1>
        if(disp_refr->bg_img) {
   1d8ce:	48 8b 05 03 a7 23 00 	mov    0x23a703(%rip),%rax        # 257fd8 <disp_refr>
   1d8d5:	4c 8d 6c 24 18       	lea    0x18(%rsp),%r13
            lv_draw_img_dsc_init(&dsc);
   1d8da:	4c 89 ef             	mov    %r13,%rdi
        if(disp_refr->bg_img) {
   1d8dd:	48 83 b8 a8 00 00 00 	cmpq   $0x0,0xa8(%rax)
   1d8e4:	00 
   1d8e5:	0f 84 a5 00 00 00    	je     1d990 <lv_refr_area_part+0x183>
            lv_draw_img_dsc_init(&dsc);
   1d8eb:	e8 da 29 00 00       	callq  202ca <lv_draw_img_dsc_init>
            dsc.opa = disp_refr->bg_opa;
   1d8f0:	48 8b 05 e1 a6 23 00 	mov    0x23a6e1(%rip),%rax        # 257fd8 <disp_refr>
            res = lv_img_decoder_get_info(disp_refr->bg_img, &header);
   1d8f7:	48 8d 74 24 04       	lea    0x4(%rsp),%rsi
            dsc.opa = disp_refr->bg_opa;
   1d8fc:	8a 90 b0 00 00 00    	mov    0xb0(%rax),%dl
   1d902:	88 54 24 18          	mov    %dl,0x18(%rsp)
            res = lv_img_decoder_get_info(disp_refr->bg_img, &header);
   1d906:	48 8b b8 a8 00 00 00 	mov    0xa8(%rax),%rdi
   1d90d:	e8 62 74 00 00       	callq  24d74 <lv_img_decoder_get_info>
            if(res == LV_RES_OK) {
   1d912:	fe c8                	dec    %al
   1d914:	75 52                	jne    1d968 <lv_refr_area_part+0x15b>
                lv_area_set(&a, 0, 0, header.w - 1, header.h - 1);
   1d916:	8b 4c 24 04          	mov    0x4(%rsp),%ecx
   1d91a:	66 44 8b 44 24 06    	mov    0x6(%rsp),%r8w
   1d920:	4c 8d 74 24 10       	lea    0x10(%rsp),%r14
   1d925:	31 d2                	xor    %edx,%edx
   1d927:	31 f6                	xor    %esi,%esi
   1d929:	4c 89 f7             	mov    %r14,%rdi
   1d92c:	c1 e9 0a             	shr    $0xa,%ecx
   1d92f:	66 41 c1 e8 05       	shr    $0x5,%r8w
   1d934:	66 81 e1 ff 07       	and    $0x7ff,%cx
   1d939:	41 ff c8             	dec    %r8d
   1d93c:	ff c9                	dec    %ecx
   1d93e:	45 0f bf c0          	movswl %r8w,%r8d
   1d942:	0f bf c9             	movswl %cx,%ecx
   1d945:	e8 99 7b 00 00       	callq  254e3 <lv_area_set>
                lv_draw_img(&a, &start_mask, disp_refr->bg_img, &dsc);
   1d94a:	48 8b 05 87 a6 23 00 	mov    0x23a687(%rip),%rax        # 257fd8 <disp_refr>
   1d951:	4c 89 e9             	mov    %r13,%rcx
   1d954:	48 89 de             	mov    %rbx,%rsi
   1d957:	4c 89 f7             	mov    %r14,%rdi
   1d95a:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
   1d961:	e8 d7 29 00 00       	callq  2033d <lv_draw_img>
   1d966:	eb 56                	jmp    1d9be <lv_refr_area_part+0x1b1>
                LV_LOG_WARN("Can't draw the background image")
   1d968:	4c 8d 05 94 5b 01 00 	lea    0x15b94(%rip),%r8        # 33503 <__func__.5785+0x289b>
   1d96f:	48 8d 0d 9a 2f 01 00 	lea    0x12f9a(%rip),%rcx        # 30910 <__func__.5941>
   1d976:	48 8d 35 a6 5b 01 00 	lea    0x15ba6(%rip),%rsi        # 33523 <__func__.5785+0x28bb>
   1d97d:	ba 0a 02 00 00       	mov    $0x20a,%edx
   1d982:	bf 02 00 00 00       	mov    $0x2,%edi
   1d987:	31 c0                	xor    %eax,%eax
   1d989:	e8 c8 85 00 00       	callq  25f56 <_lv_log_add>
   1d98e:	eb 2e                	jmp    1d9be <lv_refr_area_part+0x1b1>
            lv_draw_rect_dsc_init(&dsc);
   1d990:	e8 ac 57 00 00       	callq  23141 <lv_draw_rect_dsc_init>
            dsc.bg_color = disp_refr->bg_color;
   1d995:	48 8b 05 3c a6 23 00 	mov    0x23a63c(%rip),%rax        # 257fd8 <disp_refr>
            lv_draw_rect(&start_mask, &start_mask, &dsc);
   1d99c:	48 89 de             	mov    %rbx,%rsi
   1d99f:	48 89 df             	mov    %rbx,%rdi
            dsc.bg_color = disp_refr->bg_color;
   1d9a2:	8b 90 a4 00 00 00    	mov    0xa4(%rax),%edx
   1d9a8:	89 54 24 1c          	mov    %edx,0x1c(%rsp)
            dsc.bg_opa = disp_refr->bg_opa;
   1d9ac:	8a 80 b0 00 00 00    	mov    0xb0(%rax),%al
            lv_draw_rect(&start_mask, &start_mask, &dsc);
   1d9b2:	4c 89 ea             	mov    %r13,%rdx
            dsc.bg_opa = disp_refr->bg_opa;
   1d9b5:	88 44 24 2a          	mov    %al,0x2a(%rsp)
            lv_draw_rect(&start_mask, &start_mask, &dsc);
   1d9b9:	e8 ed 57 00 00       	callq  231ab <lv_draw_rect>
    if(disp_refr->prev_scr) {
   1d9be:	48 8b 05 13 a6 23 00 	mov    0x23a613(%rip),%rax        # 257fd8 <disp_refr>
   1d9c5:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
   1d9cc:	48 85 c0             	test   %rax,%rax
   1d9cf:	74 12                	je     1d9e3 <lv_refr_area_part+0x1d6>
        if(top_prev_scr == NULL) {
   1d9d1:	48 85 ed             	test   %rbp,%rbp
        lv_refr_obj_and_children(top_prev_scr, &start_mask);
   1d9d4:	48 89 de             	mov    %rbx,%rsi
        if(top_prev_scr == NULL) {
   1d9d7:	48 0f 44 e8          	cmove  %rax,%rbp
        lv_refr_obj_and_children(top_prev_scr, &start_mask);
   1d9db:	48 89 ef             	mov    %rbp,%rdi
   1d9de:	e8 6b fb ff ff       	callq  1d54e <lv_refr_obj_and_children>
    if(top_act_scr == NULL) {
   1d9e3:	4d 85 e4             	test   %r12,%r12
   1d9e6:	75 0e                	jne    1d9f6 <lv_refr_area_part+0x1e9>
        top_act_scr = disp_refr->act_scr;
   1d9e8:	48 8b 05 e9 a5 23 00 	mov    0x23a5e9(%rip),%rax        # 257fd8 <disp_refr>
   1d9ef:	4c 8b a0 80 00 00 00 	mov    0x80(%rax),%r12
    lv_refr_obj_and_children(top_act_scr, &start_mask);
   1d9f6:	48 89 de             	mov    %rbx,%rsi
   1d9f9:	4c 89 e7             	mov    %r12,%rdi
   1d9fc:	e8 4d fb ff ff       	callq  1d54e <lv_refr_obj_and_children>
    lv_refr_obj_and_children(lv_disp_get_layer_top(disp_refr), &start_mask);
   1da01:	48 8b 3d d0 a5 23 00 	mov    0x23a5d0(%rip),%rdi        # 257fd8 <disp_refr>
   1da08:	e8 00 b9 ff ff       	callq  1930d <lv_disp_get_layer_top>
   1da0d:	48 89 de             	mov    %rbx,%rsi
   1da10:	48 89 c7             	mov    %rax,%rdi
   1da13:	e8 36 fb ff ff       	callq  1d54e <lv_refr_obj_and_children>
    lv_refr_obj_and_children(lv_disp_get_layer_sys(disp_refr), &start_mask);
   1da18:	48 8b 3d b9 a5 23 00 	mov    0x23a5b9(%rip),%rdi        # 257fd8 <disp_refr>
   1da1f:	e8 35 b9 ff ff       	callq  19359 <lv_disp_get_layer_sys>
   1da24:	48 89 de             	mov    %rbx,%rsi
   1da27:	48 89 c7             	mov    %rax,%rdi
   1da2a:	e8 1f fb ff ff       	callq  1d54e <lv_refr_obj_and_children>
    if(lv_disp_is_true_double_buf(disp_refr) == false) {
   1da2f:	48 8b 3d a2 a5 23 00 	mov    0x23a5a2(%rip),%rdi        # 257fd8 <disp_refr>
   1da36:	e8 1c 77 00 00       	callq  25157 <lv_disp_is_true_double_buf>
   1da3b:	84 c0                	test   %al,%al
   1da3d:	75 05                	jne    1da44 <lv_refr_area_part+0x237>
        lv_refr_vdb_flush();
   1da3f:	e8 fe fc ff ff       	callq  1d742 <lv_refr_vdb_flush>
}
   1da44:	48 8b 84 24 98 00 00 	mov    0x98(%rsp),%rax
   1da4b:	00 
   1da4c:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1da53:	00 00 
   1da55:	74 05                	je     1da5c <lv_refr_area_part+0x24f>
   1da57:	e8 e4 6b fe ff       	callq  4640 <__stack_chk_fail@plt>
   1da5c:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
   1da63:	5b                   	pop    %rbx
   1da64:	5d                   	pop    %rbp
   1da65:	41 5c                	pop    %r12
   1da67:	41 5d                	pop    %r13
   1da69:	41 5e                	pop    %r14
   1da6b:	c3                   	retq   

000000000001da6c <_lv_disp_refr_task>:
{
   1da6c:	41 57                	push   %r15
   1da6e:	41 56                	push   %r14
   1da70:	41 55                	push   %r13
   1da72:	41 54                	push   %r12
   1da74:	55                   	push   %rbp
   1da75:	53                   	push   %rbx
   1da76:	48 83 ec 48          	sub    $0x48,%rsp
   1da7a:	48 89 3c 24          	mov    %rdi,(%rsp)
   1da7e:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1da85:	00 00 
   1da87:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
   1da8c:	31 c0                	xor    %eax,%eax
    uint32_t start = lv_tick_get();
   1da8e:	e8 fb 79 00 00       	callq  2548e <lv_tick_get>
    disp_refr = task->user_data;
   1da93:	48 8b 3c 24          	mov    (%rsp),%rdi
    uint32_t start = lv_tick_get();
   1da97:	89 44 24 18          	mov    %eax,0x18(%rsp)
    lv_task_set_prio(task, LV_TASK_PRIO_OFF);
   1da9b:	31 f6                	xor    %esi,%esi
    disp_refr = task->user_data;
   1da9d:	48 8b 47 10          	mov    0x10(%rdi),%rax
   1daa1:	48 89 05 30 a5 23 00 	mov    %rax,0x23a530(%rip)        # 257fd8 <disp_refr>
    lv_task_set_prio(task, LV_TASK_PRIO_OFF);
   1daa8:	e8 e9 8b 00 00       	callq  26696 <lv_task_set_prio>
    if(disp_refr->act_scr == NULL) {
   1daad:	48 8b 05 24 a5 23 00 	mov    0x23a524(%rip),%rax        # 257fd8 <disp_refr>
   1dab4:	48 83 b8 80 00 00 00 	cmpq   $0x0,0x80(%rax)
   1dabb:	00 
   1dabc:	75 0e                	jne    1dacc <_lv_disp_refr_task+0x60>
        disp_refr->inv_p = 0;
   1dabe:	66 81 a0 d2 01 00 00 	andw   $0xfc00,0x1d2(%rax)
   1dac5:	00 fc 
        return;
   1dac7:	e9 ed 05 00 00       	jmpq   1e0b9 <_lv_disp_refr_task+0x64d>
   1dacc:	4c 8d 64 24 30       	lea    0x30(%rsp),%r12
   1dad1:	45 31 f6             	xor    %r14d,%r14d
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
   1dad4:	48 8b 15 fd a4 23 00 	mov    0x23a4fd(%rip),%rdx        # 257fd8 <disp_refr>
   1dadb:	44 89 34 24          	mov    %r14d,(%rsp)
   1dadf:	66 8b b2 d2 01 00 00 	mov    0x1d2(%rdx),%si
   1dae6:	66 81 e6 ff 03       	and    $0x3ff,%si
   1daeb:	0f b7 c6             	movzwl %si,%eax
   1daee:	41 39 c6             	cmp    %eax,%r14d
   1daf1:	0f 83 dc 00 00 00    	jae    1dbd3 <_lv_disp_refr_task+0x167>
        if(disp_refr->inv_area_joined[join_in] != 0) continue;
   1daf7:	44 89 f0             	mov    %r14d,%eax
   1dafa:	80 bc 02 b2 01 00 00 	cmpb   $0x0,0x1b2(%rdx,%rax,1)
   1db01:	00 
   1db02:	74 05                	je     1db09 <_lv_disp_refr_task+0x9d>
   1db04:	49 ff c6             	inc    %r14
   1db07:	eb cb                	jmp    1dad4 <_lv_disp_refr_task+0x68>
   1db09:	4a 8d 1c f5 b2 00 00 	lea    0xb2(,%r14,8),%rbx
   1db10:	00 
   1db11:	45 31 ff             	xor    %r15d,%r15d
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
   1db14:	48 8b 3d bd a4 23 00 	mov    0x23a4bd(%rip),%rdi        # 257fd8 <disp_refr>
   1db1b:	44 89 fa             	mov    %r15d,%edx
   1db1e:	66 8b 87 d2 01 00 00 	mov    0x1d2(%rdi),%ax
   1db25:	25 ff 03 00 00       	and    $0x3ff,%eax
   1db2a:	41 39 c7             	cmp    %eax,%r15d
   1db2d:	73 d5                	jae    1db04 <_lv_disp_refr_task+0x98>
            if(disp_refr->inv_area_joined[join_from] != 0 || join_in == join_from) {
   1db2f:	45 89 fd             	mov    %r15d,%r13d
   1db32:	42 80 bc 2f b2 01 00 	cmpb   $0x0,0x1b2(%rdi,%r13,1)
   1db39:	00 00 
   1db3b:	0f 85 8a 00 00 00    	jne    1dbcb <_lv_disp_refr_task+0x15f>
   1db41:	39 14 24             	cmp    %edx,(%rsp)
   1db44:	0f 84 81 00 00 00    	je     1dbcb <_lv_disp_refr_task+0x15f>
   1db4a:	4a 8d 2c fd b2 00 00 	lea    0xb2(,%r15,8),%rbp
   1db51:	00 
            if(_lv_area_is_on(&disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]) == false) {
   1db52:	48 8d 34 2f          	lea    (%rdi,%rbp,1),%rsi
   1db56:	48 01 df             	add    %rbx,%rdi
   1db59:	e8 33 7c 00 00       	callq  25791 <_lv_area_is_on>
   1db5e:	84 c0                	test   %al,%al
   1db60:	74 69                	je     1dbcb <_lv_disp_refr_task+0x15f>
            _lv_area_join(&joined_area, &disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]);
   1db62:	48 8b 35 6f a4 23 00 	mov    0x23a46f(%rip),%rsi        # 257fd8 <disp_refr>
   1db69:	4c 89 e7             	mov    %r12,%rdi
   1db6c:	48 8d 14 2e          	lea    (%rsi,%rbp,1),%rdx
   1db70:	48 01 de             	add    %rbx,%rsi
   1db73:	e8 01 7a 00 00       	callq  25579 <_lv_area_join>
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
   1db78:	4c 89 e7             	mov    %r12,%rdi
   1db7b:	e8 81 79 00 00       	callq  25501 <lv_area_get_size>
   1db80:	48 8b 3d 51 a4 23 00 	mov    0x23a451(%rip),%rdi        # 257fd8 <disp_refr>
   1db87:	89 44 24 0c          	mov    %eax,0xc(%rsp)
   1db8b:	48 01 df             	add    %rbx,%rdi
   1db8e:	e8 6e 79 00 00       	callq  25501 <lv_area_get_size>
                                                 lv_area_get_size(&disp_refr->inv_areas[join_from]))) {
   1db93:	48 8b 3d 3e a4 23 00 	mov    0x23a43e(%rip),%rdi        # 257fd8 <disp_refr>
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
   1db9a:	89 44 24 10          	mov    %eax,0x10(%rsp)
                                                 lv_area_get_size(&disp_refr->inv_areas[join_from]))) {
   1db9e:	48 01 ef             	add    %rbp,%rdi
   1dba1:	e8 5b 79 00 00       	callq  25501 <lv_area_get_size>
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
   1dba6:	8b 6c 24 10          	mov    0x10(%rsp),%ebp
   1dbaa:	01 c5                	add    %eax,%ebp
   1dbac:	39 6c 24 0c          	cmp    %ebp,0xc(%rsp)
   1dbb0:	73 19                	jae    1dbcb <_lv_disp_refr_task+0x15f>
                lv_area_copy(&disp_refr->inv_areas[join_in], &joined_area);
   1dbb2:	48 8b 05 1f a4 23 00 	mov    0x23a41f(%rip),%rax        # 257fd8 <disp_refr>
   1dbb9:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
   1dbbe:	48 89 14 18          	mov    %rdx,(%rax,%rbx,1)
                disp_refr->inv_area_joined[join_from] = 1;
   1dbc2:	42 c6 84 28 b2 01 00 	movb   $0x1,0x1b2(%rax,%r13,1)
   1dbc9:	00 01 
   1dbcb:	49 ff c7             	inc    %r15
   1dbce:	e9 41 ff ff ff       	jmpq   1db14 <_lv_disp_refr_task+0xa8>
    if(disp_refr->inv_p == 0) return;
   1dbd3:	66 85 f6             	test   %si,%si
    px_num = 0;
   1dbd6:	c7 05 bc 14 24 00 00 	movl   $0x0,0x2414bc(%rip)        # 25f09c <px_num>
   1dbdd:	00 00 00 
    if(disp_refr->inv_p == 0) return;
   1dbe0:	75 1b                	jne    1dbfd <_lv_disp_refr_task+0x191>
    if(disp_refr->inv_p != 0) {
   1dbe2:	48 8b 3d ef a3 23 00 	mov    0x23a3ef(%rip),%rdi        # 257fd8 <disp_refr>
   1dbe9:	66 f7 87 d2 01 00 00 	testw  $0x3ff,0x1d2(%rdi)
   1dbf0:	ff 03 
   1dbf2:	0f 84 b7 04 00 00    	je     1e0af <_lv_disp_refr_task+0x643>
   1dbf8:	e9 0e 03 00 00       	jmpq   1df0b <_lv_disp_refr_task+0x49f>
    for(i = disp_refr->inv_p - 1; i >= 0; i--) {
   1dbfd:	ff c8                	dec    %eax
   1dbff:	48 98                	cltq   
   1dc01:	83 f8 ff             	cmp    $0xffffffff,%eax
   1dc04:	89 44 24 0c          	mov    %eax,0xc(%rsp)
   1dc08:	74 0f                	je     1dc19 <_lv_disp_refr_task+0x1ad>
   1dc0a:	48 ff c8             	dec    %rax
        if(disp_refr->inv_area_joined[i] == 0) {
   1dc0d:	80 bc 02 b3 01 00 00 	cmpb   $0x0,0x1b3(%rdx,%rax,1)
   1dc14:	00 
   1dc15:	75 ea                	jne    1dc01 <_lv_disp_refr_task+0x195>
   1dc17:	eb 08                	jmp    1dc21 <_lv_disp_refr_task+0x1b5>
    int32_t last_i = 0;
   1dc19:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%rsp)
   1dc20:	00 
    disp_refr->driver.buffer->last_area = 0;
   1dc21:	48 8b 42 08          	mov    0x8(%rdx),%rax
    disp_refr->driver.buffer->last_part = 0;
   1dc25:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
   1dc2c:	00 
    disp_refr->driver.buffer->last_area = 0;
   1dc2d:	8a 50 2c             	mov    0x2c(%rax),%dl
   1dc30:	83 e2 fe             	and    $0xfffffffe,%edx
   1dc33:	88 50 2c             	mov    %dl,0x2c(%rax)
    disp_refr->driver.buffer->last_part = 0;
   1dc36:	8a 50 2c             	mov    0x2c(%rax),%dl
   1dc39:	83 e2 fd             	and    $0xfffffffd,%edx
   1dc3c:	88 50 2c             	mov    %dl,0x2c(%rax)
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
   1dc3f:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
   1dc44:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    for(i = 0; i < disp_refr->inv_p; i++) {
   1dc49:	4c 8b 25 88 a3 23 00 	mov    0x23a388(%rip),%r12        # 257fd8 <disp_refr>
   1dc50:	4c 63 3c 24          	movslq (%rsp),%r15
   1dc54:	66 41 8b 84 24 d2 01 	mov    0x1d2(%r12),%ax
   1dc5b:	00 00 
   1dc5d:	25 ff 03 00 00       	and    $0x3ff,%eax
   1dc62:	41 39 c7             	cmp    %eax,%r15d
   1dc65:	0f 8d 77 ff ff ff    	jge    1dbe2 <_lv_disp_refr_task+0x176>
        if(disp_refr->inv_area_joined[i] == 0) {
   1dc6b:	48 63 04 24          	movslq (%rsp),%rax
   1dc6f:	41 80 bc 04 b2 01 00 	cmpb   $0x0,0x1b2(%r12,%rax,1)
   1dc76:	00 00 
   1dc78:	0f 85 84 02 00 00    	jne    1df02 <_lv_disp_refr_task+0x496>
            if(i == last_i) disp_refr->driver.buffer->last_area = 1;
   1dc7e:	44 3b 7c 24 0c       	cmp    0xc(%rsp),%r15d
   1dc83:	49 8b 44 24 08       	mov    0x8(%r12),%rax
   1dc88:	75 09                	jne    1dc93 <_lv_disp_refr_task+0x227>
   1dc8a:	8a 50 2c             	mov    0x2c(%rax),%dl
   1dc8d:	83 ca 01             	or     $0x1,%edx
   1dc90:	88 50 2c             	mov    %dl,0x2c(%rax)
            disp_refr->driver.buffer->last_part = 0;
   1dc93:	8a 50 2c             	mov    0x2c(%rax),%dl
    if(lv_disp_is_true_double_buf(disp_refr)) {
   1dc96:	4c 89 e7             	mov    %r12,%rdi
            disp_refr->driver.buffer->last_part = 0;
   1dc99:	83 e2 fd             	and    $0xfffffffd,%edx
   1dc9c:	88 50 2c             	mov    %dl,0x2c(%rax)
   1dc9f:	48 8b 04 24          	mov    (%rsp),%rax
   1dca3:	48 8d 04 c5 b2 00 00 	lea    0xb2(,%rax,8),%rax
   1dcaa:	00 
   1dcab:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
            lv_refr_area(&disp_refr->inv_areas[i]);
   1dcb0:	4d 8d 2c 04          	lea    (%r12,%rax,1),%r13
    if(lv_disp_is_true_double_buf(disp_refr)) {
   1dcb4:	e8 9e 74 00 00       	callq  25157 <lv_disp_is_true_double_buf>
   1dcb9:	84 c0                	test   %al,%al
   1dcbb:	48 8b 3d 16 a3 23 00 	mov    0x23a316(%rip),%rdi        # 257fd8 <disp_refr>
   1dcc2:	74 3d                	je     1dd01 <_lv_disp_refr_task+0x295>
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
   1dcc4:	e8 39 74 00 00       	callq  25102 <lv_disp_get_buf>
        vdb->area.x2        = lv_disp_get_hor_res(disp_refr) - 1;
   1dcc9:	48 8b 3d 08 a3 23 00 	mov    0x23a308(%rip),%rdi        # 257fd8 <disp_refr>
        vdb->area.x1        = 0;
   1dcd0:	66 c7 40 1c 00 00    	movw   $0x0,0x1c(%rax)
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
   1dcd6:	48 89 c3             	mov    %rax,%rbx
        vdb->area.x2        = lv_disp_get_hor_res(disp_refr) - 1;
   1dcd9:	e8 68 73 00 00       	callq  25046 <lv_disp_get_hor_res>
        vdb->area.y2        = lv_disp_get_ver_res(disp_refr) - 1;
   1dcde:	48 8b 3d f3 a2 23 00 	mov    0x23a2f3(%rip),%rdi        # 257fd8 <disp_refr>
        vdb->area.x2        = lv_disp_get_hor_res(disp_refr) - 1;
   1dce5:	ff c8                	dec    %eax
        vdb->area.y1        = 0;
   1dce7:	66 c7 43 1e 00 00    	movw   $0x0,0x1e(%rbx)
        vdb->area.x2        = lv_disp_get_hor_res(disp_refr) - 1;
   1dced:	66 89 43 20          	mov    %ax,0x20(%rbx)
        vdb->area.y2        = lv_disp_get_ver_res(disp_refr) - 1;
   1dcf1:	e8 89 73 00 00       	callq  2507f <lv_disp_get_ver_res>
   1dcf6:	ff c8                	dec    %eax
   1dcf8:	66 89 43 22          	mov    %ax,0x22(%rbx)
   1dcfc:	e9 c7 01 00 00       	jmpq   1dec8 <_lv_disp_refr_task+0x45c>
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
   1dd01:	e8 fc 73 00 00       	callq  25102 <lv_disp_get_buf>
        lv_coord_t h = lv_area_get_height(area_p);
   1dd06:	66 41 8b 55 06       	mov    0x6(%r13),%dx
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
   1dd0b:	49 89 c6             	mov    %rax,%r14
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
   1dd0e:	48 8b 3d c3 a2 23 00 	mov    0x23a2c3(%rip),%rdi        # 257fd8 <disp_refr>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1dd15:	66 41 8b 45 04       	mov    0x4(%r13),%ax
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1dd1a:	8d 5a 01             	lea    0x1(%rdx),%ebx
   1dd1d:	89 54 24 1c          	mov    %edx,0x1c(%rsp)
   1dd21:	66 41 2b 5d 02       	sub    0x2(%r13),%bx
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1dd26:	8d 68 01             	lea    0x1(%rax),%ebp
   1dd29:	66 41 2b 6d 00       	sub    0x0(%r13),%bp
   1dd2e:	e8 4c 73 00 00       	callq  2507f <lv_disp_get_ver_res>
        lv_coord_t y2 =
   1dd33:	8b 54 24 1c          	mov    0x1c(%rsp),%edx
   1dd37:	66 39 c2             	cmp    %ax,%dx
   1dd3a:	7c 12                	jl     1dd4e <_lv_disp_refr_task+0x2e2>
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
   1dd3c:	48 8b 3d 95 a2 23 00 	mov    0x23a295(%rip),%rdi        # 257fd8 <disp_refr>
   1dd43:	e8 37 73 00 00       	callq  2507f <lv_disp_get_ver_res>
   1dd48:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
   1dd4c:	eb 0b                	jmp    1dd59 <_lv_disp_refr_task+0x2ed>
        lv_coord_t y2 =
   1dd4e:	49 63 c7             	movslq %r15d,%rax
   1dd51:	45 8b 84 c4 b8 00 00 	mov    0xb8(%r12,%rax,8),%r8d
   1dd58:	00 
        int32_t max_row = (uint32_t)vdb->size / w;
   1dd59:	41 8b 46 18          	mov    0x18(%r14),%eax
   1dd5d:	31 d2                	xor    %edx,%edx
   1dd5f:	0f bf ed             	movswl %bp,%ebp
        if(max_row > h) max_row = h;
   1dd62:	0f bf db             	movswl %bx,%ebx
        int32_t max_row = (uint32_t)vdb->size / w;
   1dd65:	f7 f5                	div    %ebp
   1dd67:	39 c3                	cmp    %eax,%ebx
   1dd69:	0f 4f d8             	cmovg  %eax,%ebx
        if(disp_refr->driver.rounder_cb) {
   1dd6c:	48 8b 05 65 a2 23 00 	mov    0x23a265(%rip),%rax        # 257fd8 <disp_refr>
   1dd73:	48 83 78 20 00       	cmpq   $0x0,0x20(%rax)
   1dd78:	0f 84 8d 00 00 00    	je     1de0b <_lv_disp_refr_task+0x39f>
            tmp.x1 = 0;
   1dd7e:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%rsp)
   1dd85:	00 
            tmp.y1 = 0;
   1dd86:	66 c7 44 24 34 00 00 	movw   $0x0,0x34(%rsp)
            lv_coord_t h_tmp = max_row;
   1dd8d:	89 dd                	mov    %ebx,%ebp
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
   1dd8f:	48 8b 05 42 a2 23 00 	mov    0x23a242(%rip),%rax        # 257fd8 <disp_refr>
   1dd96:	8d 55 ff             	lea    -0x1(%rbp),%edx
   1dd99:	44 89 44 24 28       	mov    %r8d,0x28(%rsp)
   1dd9e:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
                tmp.y2 = h_tmp - 1;
   1dda3:	66 89 54 24 36       	mov    %dx,0x36(%rsp)
   1dda8:	89 54 24 1c          	mov    %edx,0x1c(%rsp)
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
   1ddac:	48 89 c7             	mov    %rax,%rdi
   1ddaf:	ff 50 20             	callq  *0x20(%rax)
                if(lv_area_get_height(&tmp) <= max_row) break;
   1ddb2:	66 8b 74 24 36       	mov    0x36(%rsp),%si
   1ddb7:	44 8b 44 24 28       	mov    0x28(%rsp),%r8d
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1ddbc:	8d 46 01             	lea    0x1(%rsi),%eax
   1ddbf:	66 2b 44 24 32       	sub    0x32(%rsp),%ax
   1ddc4:	98                   	cwtl   
   1ddc5:	39 c3                	cmp    %eax,%ebx
   1ddc7:	7d 0d                	jge    1ddd6 <_lv_disp_refr_task+0x36a>
   1ddc9:	8b 54 24 1c          	mov    0x1c(%rsp),%edx
            } while(h_tmp > 0);
   1ddcd:	66 85 d2             	test   %dx,%dx
   1ddd0:	89 d5                	mov    %edx,%ebp
   1ddd2:	7f bb                	jg     1dd8f <_lv_disp_refr_task+0x323>
   1ddd4:	eb 05                	jmp    1dddb <_lv_disp_refr_task+0x36f>
            if(h_tmp <= 0) {
   1ddd6:	66 85 ed             	test   %bp,%bp
   1ddd9:	7f 2b                	jg     1de06 <_lv_disp_refr_task+0x39a>
                LV_LOG_WARN("Can't set VDB height using the round function. (Wrong round_cb or to "
   1dddb:	4c 8d 05 77 57 01 00 	lea    0x15777(%rip),%r8        # 33559 <__func__.5785+0x28f1>
   1dde2:	48 8d 0d ff 2d 01 00 	lea    0x12dff(%rip),%rcx        # 30be8 <__func__.5921>
   1dde9:	48 8d 35 33 57 01 00 	lea    0x15733(%rip),%rsi        # 33523 <__func__.5785+0x28bb>
   1ddf0:	ba b8 01 00 00       	mov    $0x1b8,%edx
   1ddf5:	bf 02 00 00 00       	mov    $0x2,%edi
   1ddfa:	31 c0                	xor    %eax,%eax
   1ddfc:	e8 55 81 00 00       	callq  25f56 <_lv_log_add>
   1de01:	e9 de 00 00 00       	jmpq   1dee4 <_lv_disp_refr_task+0x478>
                max_row = tmp.y2 + 1;
   1de06:	0f bf de             	movswl %si,%ebx
   1de09:	ff c3                	inc    %ebx
   1de0b:	4f 8d 24 fc          	lea    (%r12,%r15,8),%r12
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
   1de0f:	41 0f bf c0          	movswl %r8w,%eax
        lv_coord_t row_last = 0;
   1de13:	45 31 ff             	xor    %r15d,%r15d
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
   1de16:	89 44 24 28          	mov    %eax,0x28(%rsp)
   1de1a:	66 41 8b ac 24 b4 00 	mov    0xb4(%r12),%bp
   1de21:	00 00 
   1de23:	0f bf f5             	movswl %bp,%esi
   1de26:	8d 74 33 ff          	lea    -0x1(%rbx,%rsi,1),%esi
   1de2a:	3b 74 24 28          	cmp    0x28(%rsp),%esi
   1de2e:	7f 6c                	jg     1de9c <_lv_disp_refr_task+0x430>
            vdb->area.x1 = area_p->x1;
   1de30:	66 41 8b b4 24 b2 00 	mov    0xb2(%r12),%si
   1de37:	00 00 
   1de39:	44 8d 7c 1d ff       	lea    -0x1(%rbp,%rbx,1),%r15d
            vdb->area.y2 = row + max_row - 1;
   1de3e:	66 89 5c 24 1c       	mov    %bx,0x1c(%rsp)
   1de43:	66 45 39 f8          	cmp    %r15w,%r8w
            vdb->area.x1 = area_p->x1;
   1de47:	66 41 89 76 1c       	mov    %si,0x1c(%r14)
            vdb->area.x2 = area_p->x2;
   1de4c:	66 41 8b b4 24 b6 00 	mov    0xb6(%r12),%si
   1de53:	00 00 
            vdb->area.y2 = row + max_row - 1;
   1de55:	45 0f 4c f8          	cmovl  %r8d,%r15d
            if(y2 == row_last) disp_refr->driver.buffer->last_part = 1;
   1de59:	66 45 39 f8          	cmp    %r15w,%r8w
            vdb->area.y1 = row;
   1de5d:	66 41 89 6e 1e       	mov    %bp,0x1e(%r14)
            vdb->area.y2 = row + max_row - 1;
   1de62:	66 45 89 7e 22       	mov    %r15w,0x22(%r14)
            vdb->area.x2 = area_p->x2;
   1de67:	66 41 89 76 20       	mov    %si,0x20(%r14)
            if(y2 == row_last) disp_refr->driver.buffer->last_part = 1;
   1de6c:	75 16                	jne    1de84 <_lv_disp_refr_task+0x418>
   1de6e:	48 8b 35 63 a1 23 00 	mov    0x23a163(%rip),%rsi        # 257fd8 <disp_refr>
   1de75:	48 8b 7e 08          	mov    0x8(%rsi),%rdi
   1de79:	40 8a 77 2c          	mov    0x2c(%rdi),%sil
   1de7d:	83 ce 02             	or     $0x2,%esi
   1de80:	40 88 77 2c          	mov    %sil,0x2c(%rdi)
            lv_refr_area_part(area_p);
   1de84:	4c 89 ef             	mov    %r13,%rdi
   1de87:	44 89 44 24 2c       	mov    %r8d,0x2c(%rsp)
   1de8c:	e8 7c f9 ff ff       	callq  1d80d <lv_refr_area_part>
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
   1de91:	03 6c 24 1c          	add    0x1c(%rsp),%ebp
   1de95:	44 8b 44 24 2c       	mov    0x2c(%rsp),%r8d
   1de9a:	eb 87                	jmp    1de23 <_lv_disp_refr_task+0x3b7>
        if(y2 != row_last) {
   1de9c:	66 45 39 f8          	cmp    %r15w,%r8w
   1dea0:	74 42                	je     1dee4 <_lv_disp_refr_task+0x478>
            vdb->area.x1 = area_p->x1;
   1dea2:	66 41 8b b4 24 b2 00 	mov    0xb2(%r12),%si
   1dea9:	00 00 
   1deab:	66 41 89 76 1c       	mov    %si,0x1c(%r14)
            vdb->area.x2 = area_p->x2;
   1deb0:	66 41 8b 94 24 b6 00 	mov    0xb6(%r12),%dx
   1deb7:	00 00 
            vdb->area.y1 = row;
   1deb9:	66 41 89 6e 1e       	mov    %bp,0x1e(%r14)
            vdb->area.y2 = y2;
   1debe:	66 45 89 46 22       	mov    %r8w,0x22(%r14)
            vdb->area.x2 = area_p->x2;
   1dec3:	66 41 89 56 20       	mov    %dx,0x20(%r14)
            disp_refr->driver.buffer->last_part = 1;
   1dec8:	48 8b 05 09 a1 23 00 	mov    0x23a109(%rip),%rax        # 257fd8 <disp_refr>
            lv_refr_area_part(area_p);
   1decf:	4c 89 ef             	mov    %r13,%rdi
            disp_refr->driver.buffer->last_part = 1;
   1ded2:	48 8b 50 08          	mov    0x8(%rax),%rdx
   1ded6:	8a 42 2c             	mov    0x2c(%rdx),%al
   1ded9:	83 c8 02             	or     $0x2,%eax
   1dedc:	88 42 2c             	mov    %al,0x2c(%rdx)
            lv_refr_area_part(area_p);
   1dedf:	e8 29 f9 ff ff       	callq  1d80d <lv_refr_area_part>
            if(disp_refr->driver.monitor_cb) px_num += lv_area_get_size(&disp_refr->inv_areas[i]);
   1dee4:	48 8b 3d ed a0 23 00 	mov    0x23a0ed(%rip),%rdi        # 257fd8 <disp_refr>
   1deeb:	48 83 7f 30 00       	cmpq   $0x0,0x30(%rdi)
   1def0:	74 10                	je     1df02 <_lv_disp_refr_task+0x496>
   1def2:	48 03 7c 24 10       	add    0x10(%rsp),%rdi
   1def7:	e8 05 76 00 00       	callq  25501 <lv_area_get_size>
   1defc:	01 05 9a 11 24 00    	add    %eax,0x24119a(%rip)        # 25f09c <px_num>
   1df02:	48 ff 04 24          	incq   (%rsp)
   1df06:	e9 3e fd ff ff       	jmpq   1dc49 <_lv_disp_refr_task+0x1dd>
        if(lv_disp_is_true_double_buf(disp_refr)) {
   1df0b:	e8 47 72 00 00       	callq  25157 <lv_disp_is_true_double_buf>
   1df10:	84 c0                	test   %al,%al
   1df12:	0f 84 40 01 00 00    	je     1e058 <_lv_disp_refr_task+0x5ec>
            if(disp_refr->driver.set_px_cb) {
   1df18:	48 8b 3d b9 a0 23 00 	mov    0x23a0b9(%rip),%rdi        # 257fd8 <disp_refr>
   1df1f:	48 83 7f 28 00       	cmpq   $0x0,0x28(%rdi)
   1df24:	74 2b                	je     1df51 <_lv_disp_refr_task+0x4e5>
                LV_LOG_WARN("Can't handle 2 screen sized buffers with set_px_cb. Display is not refreshed.");
   1df26:	4c 8d 05 7c 56 01 00 	lea    0x1567c(%rip),%r8        # 335a9 <__func__.5785+0x2941>
   1df2d:	48 8d 0d fc 29 01 00 	lea    0x129fc(%rip),%rcx        # 30930 <__func__.5864>
   1df34:	48 8d 35 e8 55 01 00 	lea    0x155e8(%rip),%rsi        # 33523 <__func__.5785+0x28bb>
   1df3b:	ba cf 00 00 00       	mov    $0xcf,%edx
   1df40:	bf 02 00 00 00       	mov    $0x2,%edi
   1df45:	31 c0                	xor    %eax,%eax
   1df47:	e8 0a 80 00 00       	callq  25f56 <_lv_log_add>
   1df4c:	e9 07 01 00 00       	jmpq   1e058 <_lv_disp_refr_task+0x5ec>
                lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
   1df51:	e8 ac 71 00 00       	callq  25102 <lv_disp_get_buf>
   1df56:	49 89 c4             	mov    %rax,%r12
                lv_refr_vdb_flush();
   1df59:	e8 e4 f7 ff ff       	callq  1d742 <lv_refr_vdb_flush>
                while(vdb->flushing);
   1df5e:	41 8b 44 24 24       	mov    0x24(%r12),%eax
   1df63:	85 c0                	test   %eax,%eax
   1df65:	75 f7                	jne    1df5e <_lv_disp_refr_task+0x4f2>
                copy_buf = _lv_mem_buf_get(disp_refr->driver.hor_res * sizeof(lv_color_t));
   1df67:	48 8b 05 6a a0 23 00 	mov    0x23a06a(%rip),%rax        # 257fd8 <disp_refr>
   1df6e:	48 0f bf 38          	movswq (%rax),%rdi
   1df72:	c1 e7 02             	shl    $0x2,%edi
   1df75:	e8 64 82 00 00       	callq  261de <_lv_mem_buf_get>
                uint8_t * buf_act = (uint8_t *)vdb->buf_act;
   1df7a:	4d 8b 6c 24 10       	mov    0x10(%r12),%r13
                uint8_t * buf_ina = (uint8_t *)vdb->buf_act == vdb->buf1 ? vdb->buf2 : vdb->buf1;
   1df7f:	49 8b 2c 24          	mov    (%r12),%rbp
                copy_buf = _lv_mem_buf_get(disp_refr->driver.hor_res * sizeof(lv_color_t));
   1df83:	48 89 c3             	mov    %rax,%rbx
                uint8_t * buf_ina = (uint8_t *)vdb->buf_act == vdb->buf1 ? vdb->buf2 : vdb->buf1;
   1df86:	4c 39 ed             	cmp    %r13,%rbp
   1df89:	75 05                	jne    1df90 <_lv_disp_refr_task+0x524>
   1df8b:	49 8b 6c 24 08       	mov    0x8(%r12),%rbp
                lv_coord_t hres = lv_disp_get_hor_res(disp_refr);
   1df90:	48 8b 3d 41 a0 23 00 	mov    0x23a041(%rip),%rdi        # 257fd8 <disp_refr>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1df97:	41 be 01 00 00 00    	mov    $0x1,%r14d
   1df9d:	e8 a4 70 00 00       	callq  25046 <lv_disp_get_hor_res>
                            start_offs += hres * sizeof(lv_color_t);
   1dfa2:	4c 0f bf f8          	movswq %ax,%r15
                for(a = 0; a < disp_refr->inv_p; a++) {
   1dfa6:	45 31 c9             	xor    %r9d,%r9d
                            (hres * disp_refr->inv_areas[a].y1 + disp_refr->inv_areas[a].x1) * sizeof(lv_color_t);
   1dfa9:	98                   	cwtl   
                            start_offs += hres * sizeof(lv_color_t);
   1dfaa:	41 c1 e7 02          	shl    $0x2,%r15d
                for(a = 0; a < disp_refr->inv_p; a++) {
   1dfae:	48 8b 0d 23 a0 23 00 	mov    0x23a023(%rip),%rcx        # 257fd8 <disp_refr>
   1dfb5:	66 8b 91 d2 01 00 00 	mov    0x1d2(%rcx),%dx
   1dfbc:	66 81 e2 ff 03       	and    $0x3ff,%dx
   1dfc1:	66 44 39 ca          	cmp    %r9w,%dx
   1dfc5:	0f 86 80 00 00 00    	jbe    1e04b <_lv_disp_refr_task+0x5df>
                    if(disp_refr->inv_area_joined[a] == 0) {
   1dfcb:	49 63 d1             	movslq %r9d,%rdx
   1dfce:	80 bc 11 b2 01 00 00 	cmpb   $0x0,0x1b2(%rcx,%rdx,1)
   1dfd5:	00 
   1dfd6:	74 05                	je     1dfdd <_lv_disp_refr_task+0x571>
   1dfd8:	49 ff c1             	inc    %r9
   1dfdb:	eb d1                	jmp    1dfae <_lv_disp_refr_task+0x542>
   1dfdd:	4e 8d 24 c9          	lea    (%rcx,%r9,8),%r12
                            (hres * disp_refr->inv_areas[a].y1 + disp_refr->inv_areas[a].x1) * sizeof(lv_color_t);
   1dfe1:	45 0f bf 84 24 b4 00 	movswl 0xb4(%r12),%r8d
   1dfe8:	00 00 
   1dfea:	41 0f bf b4 24 b2 00 	movswl 0xb2(%r12),%esi
   1dff1:	00 00 
   1dff3:	45 89 c3             	mov    %r8d,%r11d
   1dff6:	89 f2                	mov    %esi,%edx
   1dff8:	44 0f af c0          	imul   %eax,%r8d
   1dffc:	41 01 f0             	add    %esi,%r8d
   1dfff:	44 89 f6             	mov    %r14d,%esi
   1e002:	29 d6                	sub    %edx,%esi
   1e004:	66 42 8b 94 c9 b6 00 	mov    0xb6(%rcx,%r9,8),%dx
   1e00b:	00 00 
                        uint32_t start_offs =
   1e00d:	41 c1 e0 02          	shl    $0x2,%r8d
   1e011:	01 f2                	add    %esi,%edx
                        uint32_t line_length = lv_area_get_width(&disp_refr->inv_areas[a]) * sizeof(lv_color_t);
   1e013:	48 0f bf d2          	movswq %dx,%rdx
   1e017:	c1 e2 02             	shl    $0x2,%edx
                        for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
   1e01a:	66 45 39 9c 24 b8 00 	cmp    %r11w,0xb8(%r12)
   1e021:	00 00 
   1e023:	7c b3                	jl     1dfd8 <_lv_disp_refr_task+0x56c>
                            _lv_memcpy(copy_buf, buf_ina + start_offs, line_length);
   1e025:	45 89 c2             	mov    %r8d,%r10d
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
   1e028:	48 89 df             	mov    %rbx,%rdi
   1e02b:	48 89 d1             	mov    %rdx,%rcx
   1e02e:	4a 8d 74 15 00       	lea    0x0(%rbp,%r10,1),%rsi
                            _lv_memcpy(buf_act + start_offs, copy_buf, line_length);
   1e033:	4d 01 ea             	add    %r13,%r10
                            start_offs += hres * sizeof(lv_color_t);
   1e036:	45 01 f8             	add    %r15d,%r8d
   1e039:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
   1e03b:	41 ff c3             	inc    %r11d
   1e03e:	4c 89 d7             	mov    %r10,%rdi
   1e041:	48 89 de             	mov    %rbx,%rsi
   1e044:	48 89 d1             	mov    %rdx,%rcx
   1e047:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
   1e049:	eb cf                	jmp    1e01a <_lv_disp_refr_task+0x5ae>
                if(copy_buf) _lv_mem_buf_release(copy_buf);
   1e04b:	48 85 db             	test   %rbx,%rbx
   1e04e:	74 08                	je     1e058 <_lv_disp_refr_task+0x5ec>
   1e050:	48 89 df             	mov    %rbx,%rdi
   1e053:	e8 75 82 00 00       	callq  262cd <_lv_mem_buf_release>
        _lv_memset_00(disp_refr->inv_areas, sizeof(disp_refr->inv_areas));
   1e058:	48 8b 15 79 9f 23 00 	mov    0x239f79(%rip),%rdx        # 257fd8 <disp_refr>
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
   1e05f:	31 c0                	xor    %eax,%eax
   1e061:	b9 40 00 00 00       	mov    $0x40,%ecx
   1e066:	48 8d b2 b2 00 00 00 	lea    0xb2(%rdx),%rsi
   1e06d:	48 89 f7             	mov    %rsi,%rdi
   1e070:	48 8d b2 b2 01 00 00 	lea    0x1b2(%rdx),%rsi
   1e077:	f3 ab                	rep stos %eax,%es:(%rdi)
   1e079:	48 89 f7             	mov    %rsi,%rdi
   1e07c:	b9 08 00 00 00       	mov    $0x8,%ecx
   1e081:	f3 ab                	rep stos %eax,%es:(%rdi)
        elaps = lv_tick_elaps(start);
   1e083:	8b 7c 24 18          	mov    0x18(%rsp),%edi
        disp_refr->inv_p = 0;
   1e087:	66 81 a2 d2 01 00 00 	andw   $0xfc00,0x1d2(%rdx)
   1e08e:	00 fc 
        elaps = lv_tick_elaps(start);
   1e090:	e8 0a 74 00 00       	callq  2549f <lv_tick_elaps>
        if(disp_refr->driver.monitor_cb) {
   1e095:	48 8b 3d 3c 9f 23 00 	mov    0x239f3c(%rip),%rdi        # 257fd8 <disp_refr>
   1e09c:	48 8b 4f 30          	mov    0x30(%rdi),%rcx
   1e0a0:	48 85 c9             	test   %rcx,%rcx
   1e0a3:	74 0a                	je     1e0af <_lv_disp_refr_task+0x643>
            disp_refr->driver.monitor_cb(&disp_refr->driver, elaps, px_num);
   1e0a5:	8b 15 f1 0f 24 00    	mov    0x240ff1(%rip),%edx        # 25f09c <px_num>
   1e0ab:	89 c6                	mov    %eax,%esi
   1e0ad:	ff d1                	callq  *%rcx
    _lv_mem_buf_free_all();
   1e0af:	e8 99 82 00 00       	callq  2634d <_lv_mem_buf_free_all>
    _lv_font_clean_up_fmt_txt();
   1e0b4:	e8 3b 94 00 00       	callq  274f4 <_lv_font_clean_up_fmt_txt>
}
   1e0b9:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
   1e0be:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1e0c5:	00 00 
   1e0c7:	74 05                	je     1e0ce <_lv_disp_refr_task+0x662>
   1e0c9:	e8 72 65 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1e0ce:	48 83 c4 48          	add    $0x48,%rsp
   1e0d2:	5b                   	pop    %rbx
   1e0d3:	5d                   	pop    %rbp
   1e0d4:	41 5c                	pop    %r12
   1e0d6:	41 5d                	pop    %r13
   1e0d8:	41 5e                	pop    %r14
   1e0da:	41 5f                	pop    %r15
   1e0dc:	c3                   	retq   

000000000001e0dd <lv_style_list_get_style>:
 */
void _lv_style_list_reset(lv_style_list_t * style_list);

static inline lv_style_t * lv_style_list_get_style(lv_style_list_t * list, uint8_t id)
{
    if(list->has_trans && list->skip_trans) id++;
   1e0dd:	8b 47 08             	mov    0x8(%rdi),%eax
{
   1e0e0:	40 88 f2             	mov    %sil,%dl
    if(list->has_trans && list->skip_trans) id++;
   1e0e3:	66 25 80 01          	and    $0x180,%ax
   1e0e7:	66 3d 80 01          	cmp    $0x180,%ax
   1e0eb:	75 03                	jne    1e0f0 <lv_style_list_get_style+0x13>
   1e0ed:	8d 56 01             	lea    0x1(%rsi),%edx
    if(list->style_cnt == 0 || id >= list->style_cnt) return NULL;
   1e0f0:	8a 4f 08             	mov    0x8(%rdi),%cl
   1e0f3:	31 c0                	xor    %eax,%eax
   1e0f5:	80 e1 3f             	and    $0x3f,%cl
   1e0f8:	74 0e                	je     1e108 <lv_style_list_get_style+0x2b>
   1e0fa:	38 d1                	cmp    %dl,%cl
   1e0fc:	76 0a                	jbe    1e108 <lv_style_list_get_style+0x2b>
    return list->style_list[id];
   1e0fe:	48 8b 07             	mov    (%rdi),%rax
   1e101:	0f b6 d2             	movzbl %dl,%edx
   1e104:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
}
   1e108:	c3                   	retq   

000000000001e109 <get_style_prop>:
 * @param style pointer to style.
 * @param idx index of the style in style->map
 * @return property in style->map + idx
 */
static inline lv_style_property_t get_style_prop(const lv_style_t * style, size_t idx)
{
   1e109:	48 83 ec 18          	sub    $0x18,%rsp
   1e10d:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1e114:	00 00 
   1e116:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   1e11b:	31 c0                	xor    %eax,%eax
    lv_style_property_t prop;
    uint8_t * prop_p = (uint8_t *)&prop;
    prop_p[0] = style->map[idx];
   1e11d:	48 8b 07             	mov    (%rdi),%rax
    prop_p[1] = style->map[idx + 1];
    return prop;
}
   1e120:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
   1e125:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1e12c:	00 00 
    prop_p[0] = style->map[idx];
   1e12e:	8a 14 30             	mov    (%rax,%rsi,1),%dl
    prop_p[1] = style->map[idx + 1];
   1e131:	8a 44 30 01          	mov    0x1(%rax,%rsi,1),%al
    prop_p[0] = style->map[idx];
   1e135:	88 54 24 06          	mov    %dl,0x6(%rsp)
    prop_p[1] = style->map[idx + 1];
   1e139:	88 44 24 07          	mov    %al,0x7(%rsp)
}
   1e13d:	66 8b 44 24 06       	mov    0x6(%rsp),%ax
   1e142:	74 05                	je     1e149 <get_style_prop+0x40>
   1e144:	e8 f7 64 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1e149:	48 83 c4 18          	add    $0x18,%rsp
   1e14d:	c3                   	retq   

000000000001e14e <get_style_prop_attr>:
 * @param style pointer to style.
 * @param idx index of the style in style->map
 * @return attribute of property in style->map + idx
 */
static inline uint8_t get_style_prop_attr(const lv_style_t * style, size_t idx)
{
   1e14e:	48 83 ec 08          	sub    $0x8,%rsp
    return ((get_style_prop(style, idx) >> 8) & 0xFFU);
   1e152:	e8 b2 ff ff ff       	callq  1e109 <get_style_prop>
}
   1e157:	5a                   	pop    %rdx
    return ((get_style_prop(style, idx) >> 8) & 0xFFU);
   1e158:	66 c1 e8 08          	shr    $0x8,%ax
}
   1e15c:	c3                   	retq   

000000000001e15d <get_prop_size>:
 * @param idx index of the style in style->map
 * @return attribute of property in style->map + idx
 */
static inline size_t get_prop_size(uint8_t prop_id)
{
    prop_id &= 0xF;
   1e15d:	83 e7 0f             	and    $0xf,%edi
    size_t size = sizeof(lv_style_property_t);
    if(prop_id < LV_STYLE_ID_COLOR) size += sizeof(lv_style_int_t);
   1e160:	b8 04 00 00 00       	mov    $0x4,%eax
   1e165:	40 80 ff 08          	cmp    $0x8,%dil
   1e169:	76 1a                	jbe    1e185 <get_prop_size+0x28>
    else if(prop_id < LV_STYLE_ID_OPA) size += sizeof(lv_color_t);
   1e16b:	40 80 ff 0b          	cmp    $0xb,%dil
   1e16f:	b8 06 00 00 00       	mov    $0x6,%eax
   1e174:	76 0f                	jbe    1e185 <get_prop_size+0x28>
    else if(prop_id < LV_STYLE_ID_PTR) size += sizeof(lv_opa_t);
    else size += sizeof(const void *);
   1e176:	40 80 ff 0e          	cmp    $0xe,%dil
   1e17a:	48 19 c0             	sbb    %rax,%rax
   1e17d:	48 83 e0 f9          	and    $0xfffffffffffffff9,%rax
   1e181:	48 83 c0 0a          	add    $0xa,%rax
    return size;
}
   1e185:	c3                   	retq   

000000000001e186 <get_property_index>:
    if(style->map == NULL) return -1;
   1e186:	83 c8 ff             	or     $0xffffffff,%eax
   1e189:	48 83 3f 00          	cmpq   $0x0,(%rdi)
   1e18d:	0f 84 a3 00 00 00    	je     1e236 <get_property_index+0xb0>
{
   1e193:	41 57                	push   %r15
   1e195:	41 56                	push   %r14
   1e197:	89 f0                	mov    %esi,%eax
   1e199:	41 55                	push   %r13
   1e19b:	41 54                	push   %r12
    attr = (prop >> 8) & 0xFF;
   1e19d:	0f b6 c4             	movzbl %ah,%eax
{
   1e1a0:	55                   	push   %rbp
   1e1a1:	53                   	push   %rbx
    int16_t id_guess = -1;
   1e1a2:	41 83 cd ff          	or     $0xffffffff,%r13d
   1e1a6:	49 89 fc             	mov    %rdi,%r12
    uint8_t id_to_find = prop & 0xFF;
   1e1a9:	41 88 f7             	mov    %sil,%r15b
    size_t i = 0;
   1e1ac:	31 db                	xor    %ebx,%ebx
{
   1e1ae:	48 83 ec 18          	sub    $0x18,%rsp
    int16_t weight = -1;
   1e1b2:	45 89 ee             	mov    %r13d,%r14d
    attr = (prop >> 8) & 0xFF;
   1e1b5:	89 44 24 08          	mov    %eax,0x8(%rsp)
            else if((LV_STYLE_ATTR_GET_STATE(attr_i) & (~LV_STYLE_ATTR_GET_STATE(attr))) == 0) {
   1e1b9:	8a 44 24 08          	mov    0x8(%rsp),%al
   1e1bd:	83 e0 7f             	and    $0x7f,%eax
   1e1c0:	88 44 24 0f          	mov    %al,0xf(%rsp)
    return get_style_prop(style, idx) & 0xFF;
   1e1c4:	48 89 de             	mov    %rbx,%rsi
   1e1c7:	4c 89 e7             	mov    %r12,%rdi
   1e1ca:	e8 3a ff ff ff       	callq  1e109 <get_style_prop>
    while((prop_id = get_style_prop_id(style, i)) != _LV_STYLE_CLOSEING_PROP) {
   1e1cf:	3c ff                	cmp    $0xff,%al
    return get_style_prop(style, idx) & 0xFF;
   1e1d1:	40 88 c5             	mov    %al,%bpl
    while((prop_id = get_style_prop_id(style, i)) != _LV_STYLE_CLOSEING_PROP) {
   1e1d4:	74 4d                	je     1e223 <get_property_index+0x9d>
        if(prop_id == id_to_find) {
   1e1d6:	41 38 ef             	cmp    %bpl,%r15b
   1e1d9:	75 3a                	jne    1e215 <get_property_index+0x8f>
            attr_i = get_style_prop_attr(style, i);
   1e1db:	48 89 de             	mov    %rbx,%rsi
   1e1de:	4c 89 e7             	mov    %r12,%rdi
   1e1e1:	e8 68 ff ff ff       	callq  1e14e <get_style_prop_attr>
            if(LV_STYLE_ATTR_GET_STATE(attr_i) == LV_STYLE_ATTR_GET_STATE(attr)) {
   1e1e6:	8a 4c 24 08          	mov    0x8(%rsp),%cl
   1e1ea:	31 c1                	xor    %eax,%ecx
   1e1ec:	80 e1 7f             	and    $0x7f,%cl
   1e1ef:	75 04                	jne    1e1f5 <get_property_index+0x6f>
                return i;
   1e1f1:	89 d8                	mov    %ebx,%eax
   1e1f3:	eb 32                	jmp    1e227 <get_property_index+0xa1>
            else if((LV_STYLE_ATTR_GET_STATE(attr_i) & (~LV_STYLE_ATTR_GET_STATE(attr))) == 0) {
   1e1f5:	0f b6 4c 24 0f       	movzbl 0xf(%rsp),%ecx
   1e1fa:	83 e0 7f             	and    $0x7f,%eax
   1e1fd:	0f b6 f0             	movzbl %al,%esi
   1e200:	f7 d1                	not    %ecx
   1e202:	85 f1                	test   %esi,%ecx
   1e204:	75 0f                	jne    1e215 <get_property_index+0x8f>
                if(LV_STYLE_ATTR_GET_STATE(attr_i) > weight) {
   1e206:	41 0f bf ce          	movswl %r14w,%ecx
   1e20a:	39 ce                	cmp    %ecx,%esi
   1e20c:	7e 07                	jle    1e215 <get_property_index+0x8f>
                    weight = LV_STYLE_ATTR_GET_STATE(attr_i);
   1e20e:	44 0f b6 f0          	movzbl %al,%r14d
                    id_guess = i;
   1e212:	41 89 dd             	mov    %ebx,%r13d
        i = get_next_prop_index(prop_id, i);
   1e215:	40 0f b6 fd          	movzbl %bpl,%edi
 * @param idx index of the style in style->map
 * @return index of next property in style->map
 */
static inline size_t get_next_prop_index(uint8_t prop_id, size_t idx)
{
    return idx + get_prop_size(prop_id);
   1e219:	e8 3f ff ff ff       	callq  1e15d <get_prop_size>
   1e21e:	48 01 c3             	add    %rax,%rbx
   1e221:	eb a1                	jmp    1e1c4 <get_property_index+0x3e>
    return id_guess;
   1e223:	41 0f bf c5          	movswl %r13w,%eax
}
   1e227:	48 83 c4 18          	add    $0x18,%rsp
   1e22b:	5b                   	pop    %rbx
   1e22c:	5d                   	pop    %rbp
   1e22d:	41 5c                	pop    %r12
   1e22f:	41 5d                	pop    %r13
   1e231:	41 5e                	pop    %r14
   1e233:	41 5f                	pop    %r15
   1e235:	c3                   	retq   
   1e236:	c3                   	retq   

000000000001e237 <_lv_memcpy>:
{
   1e237:	48 89 f8             	mov    %rdi,%rax
   1e23a:	48 89 d1             	mov    %rdx,%rcx
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
   1e23d:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
}
   1e23f:	c3                   	retq   

000000000001e240 <style_resize>:
{
   1e240:	53                   	push   %rbx
   1e241:	48 89 fb             	mov    %rdi,%rbx
    style->map = lv_mem_realloc(style->map, sz);
   1e244:	48 8b 3f             	mov    (%rdi),%rdi
   1e247:	e8 f1 7e 00 00       	callq  2613d <lv_mem_realloc>
   1e24c:	48 89 03             	mov    %rax,(%rbx)
}
   1e24f:	5b                   	pop    %rbx
   1e250:	c3                   	retq   

000000000001e251 <lv_style_init>:
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
   1e251:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
}
   1e258:	c3                   	retq   

000000000001e259 <lv_style_list_init>:
   1e259:	0f 57 c0             	xorps  %xmm0,%xmm0
   1e25c:	0f 11 07             	movups %xmm0,(%rdi)
}
   1e25f:	c3                   	retq   

000000000001e260 <_lv_style_list_remove_style>:
    if(list->style_cnt == 0) return;
   1e260:	8a 47 08             	mov    0x8(%rdi),%al
   1e263:	24 3f                	and    $0x3f,%al
   1e265:	0f 84 c7 00 00 00    	je     1e332 <_lv_style_list_remove_style+0xd2>
{
   1e26b:	41 54                	push   %r12
    for(i = 0; i < list->style_cnt; i++) {
   1e26d:	31 d2                	xor    %edx,%edx
{
   1e26f:	55                   	push   %rbp
   1e270:	53                   	push   %rbx
   1e271:	48 89 fb             	mov    %rdi,%rbx
    for(i = 0; i < list->style_cnt; i++) {
   1e274:	38 d0                	cmp    %dl,%al
   1e276:	0f 86 b1 00 00 00    	jbe    1e32d <_lv_style_list_remove_style+0xcd>
        if(list->style_list[i] == style) {
   1e27c:	48 8b 3b             	mov    (%rbx),%rdi
   1e27f:	4c 8b 24 d7          	mov    (%rdi,%rdx,8),%r12
   1e283:	48 ff c2             	inc    %rdx
   1e286:	49 39 f4             	cmp    %rsi,%r12
   1e289:	75 e9                	jne    1e274 <_lv_style_list_remove_style+0x14>
    if(list->style_cnt == 1) {
   1e28b:	3c 01                	cmp    $0x1,%al
   1e28d:	75 15                	jne    1e2a4 <_lv_style_list_remove_style+0x44>
        lv_mem_free(list->style_list);
   1e28f:	e8 70 7e 00 00       	callq  26104 <lv_mem_free>
        list->style_list = NULL;
   1e294:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
        list->has_local = 0;
   1e29b:	80 63 08 80          	andb   $0x80,0x8(%rbx)
        return;
   1e29f:	e9 89 00 00 00       	jmpq   1e32d <_lv_style_list_remove_style+0xcd>
    lv_style_t ** new_classes = lv_mem_alloc(sizeof(lv_style_t *) * (list->style_cnt - 1));
   1e2a4:	0f b6 c0             	movzbl %al,%eax
   1e2a7:	ff c8                	dec    %eax
   1e2a9:	48 98                	cltq   
   1e2ab:	48 8d 3c c5 00 00 00 	lea    0x0(,%rax,8),%rdi
   1e2b2:	00 
   1e2b3:	e8 d9 7d 00 00       	callq  26091 <lv_mem_alloc>
    if(new_classes == NULL) {
   1e2b8:	48 85 c0             	test   %rax,%rax
    lv_style_t ** new_classes = lv_mem_alloc(sizeof(lv_style_t *) * (list->style_cnt - 1));
   1e2bb:	48 89 c5             	mov    %rax,%rbp
    if(new_classes == NULL) {
   1e2be:	74 0f                	je     1e2cf <_lv_style_list_remove_style+0x6f>
    for(i = 0, j = 0; i < list->style_cnt; i++) {
   1e2c0:	8a 43 08             	mov    0x8(%rbx),%al
   1e2c3:	48 8b 3b             	mov    (%rbx),%rdi
   1e2c6:	31 d2                	xor    %edx,%edx
   1e2c8:	31 c9                	xor    %ecx,%ecx
   1e2ca:	83 e0 3f             	and    $0x3f,%eax
   1e2cd:	eb 41                	jmp    1e310 <_lv_style_list_remove_style+0xb0>
}
   1e2cf:	5b                   	pop    %rbx
   1e2d0:	5d                   	pop    %rbp
   1e2d1:	41 5c                	pop    %r12
        LV_LOG_WARN("lv_style_list_remove_style: couldn't reallocate class list");
   1e2d3:	4c 8d 05 1d 53 01 00 	lea    0x1531d(%rip),%r8        # 335f7 <__func__.5785+0x298f>
   1e2da:	48 8d 0d 6f 26 01 00 	lea    0x1266f(%rip),%rcx        # 30950 <__func__.5667>
   1e2e1:	48 8d 35 4a 53 01 00 	lea    0x1534a(%rip),%rsi        # 33632 <__func__.5785+0x29ca>
   1e2e8:	ba 07 01 00 00       	mov    $0x107,%edx
   1e2ed:	bf 02 00 00 00       	mov    $0x2,%edi
   1e2f2:	31 c0                	xor    %eax,%eax
   1e2f4:	e9 5d 7c 00 00       	jmpq   25f56 <_lv_log_add>
        if(list->style_list[i] == style) continue;
   1e2f9:	48 8b 34 d7          	mov    (%rdi,%rdx,8),%rsi
   1e2fd:	49 39 f4             	cmp    %rsi,%r12
   1e300:	74 0b                	je     1e30d <_lv_style_list_remove_style+0xad>
        new_classes[j] = list->style_list[i];
   1e302:	44 0f b6 c1          	movzbl %cl,%r8d
        j++;
   1e306:	ff c1                	inc    %ecx
        new_classes[j] = list->style_list[i];
   1e308:	4a 89 74 c5 00       	mov    %rsi,0x0(%rbp,%r8,8)
   1e30d:	48 ff c2             	inc    %rdx
    for(i = 0, j = 0; i < list->style_cnt; i++) {
   1e310:	38 d0                	cmp    %dl,%al
   1e312:	77 e5                	ja     1e2f9 <_lv_style_list_remove_style+0x99>
    lv_mem_free(list->style_list);
   1e314:	e8 eb 7d 00 00       	callq  26104 <lv_mem_free>
    list->style_cnt--;
   1e319:	8a 53 08             	mov    0x8(%rbx),%dl
    list->style_list = new_classes;
   1e31c:	48 89 2b             	mov    %rbp,(%rbx)
    list->style_cnt--;
   1e31f:	8d 42 3f             	lea    0x3f(%rdx),%eax
   1e322:	83 e2 c0             	and    $0xffffffc0,%edx
   1e325:	83 e0 3f             	and    $0x3f,%eax
   1e328:	09 c2                	or     %eax,%edx
   1e32a:	88 53 08             	mov    %dl,0x8(%rbx)
}
   1e32d:	5b                   	pop    %rbx
   1e32e:	5d                   	pop    %rbp
   1e32f:	41 5c                	pop    %r12
   1e331:	c3                   	retq   
   1e332:	c3                   	retq   

000000000001e333 <_lv_style_list_add_style>:
    if(list == NULL) return;
   1e333:	48 85 ff             	test   %rdi,%rdi
   1e336:	0f 84 b8 00 00 00    	je     1e3f4 <_lv_style_list_add_style+0xc1>
{
   1e33c:	55                   	push   %rbp
   1e33d:	53                   	push   %rbx
   1e33e:	48 89 fb             	mov    %rdi,%rbx
   1e341:	48 89 f5             	mov    %rsi,%rbp
   1e344:	48 83 ec 08          	sub    $0x8,%rsp
    _lv_style_list_remove_style(list, style);
   1e348:	e8 13 ff ff ff       	callq  1e260 <_lv_style_list_remove_style>
    if(list->style_cnt == 0) new_classes = lv_mem_alloc(sizeof(lv_style_t *));
   1e34d:	8a 43 08             	mov    0x8(%rbx),%al
   1e350:	24 3f                	and    $0x3f,%al
   1e352:	75 0c                	jne    1e360 <_lv_style_list_add_style+0x2d>
   1e354:	bf 08 00 00 00       	mov    $0x8,%edi
   1e359:	e8 33 7d 00 00       	callq  26091 <lv_mem_alloc>
   1e35e:	eb 16                	jmp    1e376 <_lv_style_list_add_style+0x43>
    else new_classes = lv_mem_realloc(list->style_list, sizeof(lv_style_t *) * (list->style_cnt + 1));
   1e360:	48 8d 34 c5 08 00 00 	lea    0x8(,%rax,8),%rsi
   1e367:	00 
   1e368:	48 8b 3b             	mov    (%rbx),%rdi
   1e36b:	81 e6 f8 03 00 00    	and    $0x3f8,%esi
   1e371:	e8 c7 7d 00 00       	callq  2613d <lv_mem_realloc>
    if(new_classes == NULL) {
   1e376:	48 85 c0             	test   %rax,%rax
   1e379:	75 28                	jne    1e3a3 <_lv_style_list_add_style+0x70>
}
   1e37b:	41 59                	pop    %r9
   1e37d:	5b                   	pop    %rbx
   1e37e:	5d                   	pop    %rbp
        LV_LOG_WARN("lv_style_list_add_style: couldn't add the class");
   1e37f:	4c 8d 05 e3 52 01 00 	lea    0x152e3(%rip),%r8        # 33669 <__func__.5785+0x2a01>
   1e386:	48 8d 0d e3 25 01 00 	lea    0x125e3(%rip),%rcx        # 30970 <__func__.5651>
   1e38d:	48 8d 35 9e 52 01 00 	lea    0x1529e(%rip),%rsi        # 33632 <__func__.5785+0x29ca>
   1e394:	ba d3 00 00 00       	mov    $0xd3,%edx
   1e399:	bf 02 00 00 00       	mov    $0x2,%edi
   1e39e:	e9 b3 7b 00 00       	jmpq   25f56 <_lv_log_add>
    if(list->has_trans) first_style++;
   1e3a3:	8a 53 08             	mov    0x8(%rbx),%dl
   1e3a6:	88 d1                	mov    %dl,%cl
   1e3a8:	c0 e9 07             	shr    $0x7,%cl
    if(list->has_local) first_style++;
   1e3ab:	f6 c2 40             	test   $0x40,%dl
   1e3ae:	40 0f 95 c6          	setne  %sil
    for(i = list->style_cnt; i > first_style; i--) {
   1e3b2:	83 e2 3f             	and    $0x3f,%edx
    if(list->has_local) first_style++;
   1e3b5:	01 f1                	add    %esi,%ecx
   1e3b7:	0f b6 f2             	movzbl %dl,%esi
    for(i = list->style_cnt; i > first_style; i--) {
   1e3ba:	40 88 d7             	mov    %dl,%dil
   1e3bd:	48 8d 74 f0 f8       	lea    -0x8(%rax,%rsi,8),%rsi
   1e3c2:	40 38 cf             	cmp    %cl,%dil
   1e3c5:	76 0f                	jbe    1e3d6 <_lv_style_list_add_style+0xa3>
        new_classes[i] = new_classes[i - 1];
   1e3c7:	4c 8b 06             	mov    (%rsi),%r8
    for(i = list->style_cnt; i > first_style; i--) {
   1e3ca:	ff cf                	dec    %edi
   1e3cc:	48 83 ee 08          	sub    $0x8,%rsi
        new_classes[i] = new_classes[i - 1];
   1e3d0:	4c 89 46 10          	mov    %r8,0x10(%rsi)
   1e3d4:	eb ec                	jmp    1e3c2 <_lv_style_list_add_style+0x8f>
    new_classes[first_style] = style;
   1e3d6:	0f b6 c9             	movzbl %cl,%ecx
    list->style_cnt++;
   1e3d9:	ff c2                	inc    %edx
    new_classes[first_style] = style;
   1e3db:	48 89 2c c8          	mov    %rbp,(%rax,%rcx,8)
    list->style_cnt++;
   1e3df:	8a 4b 08             	mov    0x8(%rbx),%cl
   1e3e2:	83 e2 3f             	and    $0x3f,%edx
    list->style_list = new_classes;
   1e3e5:	48 89 03             	mov    %rax,(%rbx)
    list->style_cnt++;
   1e3e8:	83 e1 c0             	and    $0xffffffc0,%ecx
   1e3eb:	09 ca                	or     %ecx,%edx
   1e3ed:	88 53 08             	mov    %dl,0x8(%rbx)
}
   1e3f0:	58                   	pop    %rax
   1e3f1:	5b                   	pop    %rbx
   1e3f2:	5d                   	pop    %rbp
   1e3f3:	c3                   	retq   
   1e3f4:	c3                   	retq   

000000000001e3f5 <get_alloc_local_style>:
    if(list->has_local) return lv_style_list_get_style(list, list->has_trans ? 1 : 0);
   1e3f5:	40 8a 77 08          	mov    0x8(%rdi),%sil
   1e3f9:	40 f6 c6 40          	test   $0x40,%sil
   1e3fd:	74 0d                	je     1e40c <get_alloc_local_style+0x17>
   1e3ff:	40 c0 ee 07          	shr    $0x7,%sil
   1e403:	40 0f b6 f6          	movzbl %sil,%esi
   1e407:	e9 d1 fc ff ff       	jmpq   1e0dd <lv_style_list_get_style>
{
   1e40c:	55                   	push   %rbp
   1e40d:	53                   	push   %rbx
   1e40e:	48 89 fb             	mov    %rdi,%rbx
    lv_style_t * local_style = lv_mem_alloc(sizeof(lv_style_t));
   1e411:	bf 08 00 00 00       	mov    $0x8,%edi
{
   1e416:	48 83 ec 08          	sub    $0x8,%rsp
    lv_style_t * local_style = lv_mem_alloc(sizeof(lv_style_t));
   1e41a:	e8 72 7c 00 00       	callq  26091 <lv_mem_alloc>
    if(local_style == NULL) {
   1e41f:	48 85 c0             	test   %rax,%rax
    lv_style_t * local_style = lv_mem_alloc(sizeof(lv_style_t));
   1e422:	48 89 c5             	mov    %rax,%rbp
    if(local_style == NULL) {
   1e425:	75 28                	jne    1e44f <get_alloc_local_style+0x5a>
        LV_LOG_WARN("get_local_style: couldn't create local style");
   1e427:	4c 8d 05 6b 52 01 00 	lea    0x1526b(%rip),%r8        # 33699 <__func__.5785+0x2a31>
   1e42e:	48 8d 0d 5b 25 01 00 	lea    0x1255b(%rip),%rcx        # 30990 <__func__.5893>
   1e435:	48 8d 35 f6 51 01 00 	lea    0x151f6(%rip),%rsi        # 33632 <__func__.5785+0x29ca>
   1e43c:	ba 58 04 00 00       	mov    $0x458,%edx
   1e441:	bf 02 00 00 00       	mov    $0x2,%edi
   1e446:	31 c0                	xor    %eax,%eax
   1e448:	e8 09 7b 00 00       	callq  25f56 <_lv_log_add>
   1e44d:	eb 17                	jmp    1e466 <get_alloc_local_style+0x71>
    lv_style_init(local_style);
   1e44f:	48 89 c7             	mov    %rax,%rdi
   1e452:	e8 fa fd ff ff       	callq  1e251 <lv_style_init>
    _lv_style_list_add_style(list, local_style);
   1e457:	48 89 ee             	mov    %rbp,%rsi
   1e45a:	48 89 df             	mov    %rbx,%rdi
   1e45d:	e8 d1 fe ff ff       	callq  1e333 <_lv_style_list_add_style>
    list->has_local = 1;
   1e462:	80 4b 08 40          	orb    $0x40,0x8(%rbx)
}
   1e466:	48 89 e8             	mov    %rbp,%rax
   1e469:	5a                   	pop    %rdx
   1e46a:	5b                   	pop    %rbx
   1e46b:	5d                   	pop    %rbp
   1e46c:	c3                   	retq   

000000000001e46d <lv_style_reset>:
{
   1e46d:	53                   	push   %rbx
   1e46e:	48 89 fb             	mov    %rdi,%rbx
    lv_mem_free(style->map);
   1e471:	48 8b 3f             	mov    (%rdi),%rdi
   1e474:	e8 8b 7c 00 00       	callq  26104 <lv_mem_free>
    style->map = NULL;
   1e479:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
}
   1e480:	5b                   	pop    %rbx
   1e481:	c3                   	retq   

000000000001e482 <_lv_style_get_mem_size>:
    if(style->map == NULL) return 0;
   1e482:	48 83 3f 00          	cmpq   $0x0,(%rdi)
   1e486:	74 2e                	je     1e4b6 <_lv_style_get_mem_size+0x34>
{
   1e488:	55                   	push   %rbp
   1e489:	53                   	push   %rbx
   1e48a:	48 89 fd             	mov    %rdi,%rbp
    size_t i = 0;
   1e48d:	31 db                	xor    %ebx,%ebx
{
   1e48f:	48 83 ec 08          	sub    $0x8,%rsp
    return get_style_prop(style, idx) & 0xFF;
   1e493:	48 89 de             	mov    %rbx,%rsi
   1e496:	48 89 ef             	mov    %rbp,%rdi
   1e499:	e8 6b fc ff ff       	callq  1e109 <get_style_prop>
    while((prop_id = get_style_prop_id(style, i)) != _LV_STYLE_CLOSEING_PROP) {
   1e49e:	3c ff                	cmp    $0xff,%al
   1e4a0:	74 0d                	je     1e4af <_lv_style_get_mem_size+0x2d>
        i = get_next_prop_index(prop_id, i);
   1e4a2:	0f b6 f8             	movzbl %al,%edi
    return idx + get_prop_size(prop_id);
   1e4a5:	e8 b3 fc ff ff       	callq  1e15d <get_prop_size>
   1e4aa:	48 01 c3             	add    %rax,%rbx
   1e4ad:	eb e4                	jmp    1e493 <_lv_style_get_mem_size+0x11>
    return i + sizeof(lv_style_property_t);
   1e4af:	8d 43 02             	lea    0x2(%rbx),%eax
}
   1e4b2:	5a                   	pop    %rdx
   1e4b3:	5b                   	pop    %rbx
   1e4b4:	5d                   	pop    %rbp
   1e4b5:	c3                   	retq   
   1e4b6:	31 c0                	xor    %eax,%eax
   1e4b8:	c3                   	retq   

000000000001e4b9 <lv_style_copy>:
    if(style_src == NULL) return;
   1e4b9:	48 85 f6             	test   %rsi,%rsi
   1e4bc:	74 39                	je     1e4f7 <lv_style_copy+0x3e>
    if(style_src->map == NULL) return;
   1e4be:	48 83 3e 00          	cmpq   $0x0,(%rsi)
   1e4c2:	74 33                	je     1e4f7 <lv_style_copy+0x3e>
{
   1e4c4:	41 54                	push   %r12
   1e4c6:	55                   	push   %rbp
   1e4c7:	49 89 fc             	mov    %rdi,%r12
   1e4ca:	53                   	push   %rbx
    uint16_t size = _lv_style_get_mem_size(style_src);
   1e4cb:	48 89 f7             	mov    %rsi,%rdi
   1e4ce:	48 89 f3             	mov    %rsi,%rbx
   1e4d1:	e8 ac ff ff ff       	callq  1e482 <_lv_style_get_mem_size>
    style_dest->map = lv_mem_alloc(size);
   1e4d6:	0f b7 e8             	movzwl %ax,%ebp
   1e4d9:	48 89 ef             	mov    %rbp,%rdi
   1e4dc:	e8 b0 7b 00 00       	callq  26091 <lv_mem_alloc>
    _lv_memcpy(style_dest->map, style_src->map, size);
   1e4e1:	48 89 ea             	mov    %rbp,%rdx
    style_dest->map = lv_mem_alloc(size);
   1e4e4:	49 89 04 24          	mov    %rax,(%r12)
    _lv_memcpy(style_dest->map, style_src->map, size);
   1e4e8:	48 8b 33             	mov    (%rbx),%rsi
}
   1e4eb:	5b                   	pop    %rbx
   1e4ec:	5d                   	pop    %rbp
   1e4ed:	41 5c                	pop    %r12
    _lv_memcpy(style_dest->map, style_src->map, size);
   1e4ef:	48 89 c7             	mov    %rax,%rdi
   1e4f2:	e9 40 fd ff ff       	jmpq   1e237 <_lv_memcpy>
   1e4f7:	c3                   	retq   

000000000001e4f8 <_lv_style_set_int>:
{
   1e4f8:	55                   	push   %rbp
   1e4f9:	53                   	push   %rbx
   1e4fa:	48 89 fd             	mov    %rdi,%rbp
   1e4fd:	48 83 ec 28          	sub    $0x28,%rsp
   1e501:	66 89 74 24 0c       	mov    %si,0xc(%rsp)
    int32_t id = get_property_index(style, prop);
   1e506:	0f b7 f6             	movzwl %si,%esi
{
   1e509:	66 89 54 24 08       	mov    %dx,0x8(%rsp)
   1e50e:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1e515:	00 00 
   1e517:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1e51c:	31 c0                	xor    %eax,%eax
    int32_t id = get_property_index(style, prop);
   1e51e:	e8 63 fc ff ff       	callq  1e186 <get_property_index>
    if(id >= 0) {
   1e523:	85 c0                	test   %eax,%eax
   1e525:	78 26                	js     1e54d <_lv_style_set_int+0x55>
        attr_found = get_style_prop_attr(style, id);
   1e527:	48 63 d8             	movslq %eax,%rbx
   1e52a:	48 89 ef             	mov    %rbp,%rdi
   1e52d:	48 89 de             	mov    %rbx,%rsi
   1e530:	e8 19 fc ff ff       	callq  1e14e <get_style_prop_attr>
        if(LV_STYLE_ATTR_GET_STATE(attr_found) == LV_STYLE_ATTR_GET_STATE(attr_goal)) {
   1e535:	32 44 24 0d          	xor    0xd(%rsp),%al
   1e539:	a8 7f                	test   $0x7f,%al
   1e53b:	75 10                	jne    1e54d <_lv_style_set_int+0x55>
            _lv_memcpy_small(style->map + id + sizeof(lv_style_property_t), &value, sizeof(lv_style_int_t));
   1e53d:	48 8b 45 00          	mov    0x0(%rbp),%rax
   1e541:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
   1e546:	48 8d 7c 18 02       	lea    0x2(%rax,%rbx,1),%rdi
   1e54b:	eb 6d                	jmp    1e5ba <_lv_style_set_int+0xc2>
    uint16_t size = _lv_style_get_mem_size(style);
   1e54d:	48 89 ef             	mov    %rbp,%rdi
    lv_style_property_t end_mark = _LV_STYLE_CLOSEING_PROP;
   1e550:	66 c7 44 24 16 ff 00 	movw   $0xff,0x16(%rsp)
    uint16_t size = _lv_style_get_mem_size(style);
   1e557:	e8 26 ff ff ff       	callq  1e482 <_lv_style_get_mem_size>
    if(size == 0) size += end_mark_size;
   1e55c:	66 85 c0             	test   %ax,%ax
   1e55f:	75 05                	jne    1e566 <_lv_style_set_int+0x6e>
   1e561:	b8 02 00 00 00       	mov    $0x2,%eax
    size += sizeof(lv_style_property_t) + sizeof(lv_style_int_t);
   1e566:	83 c0 04             	add    $0x4,%eax
    style_resize(style, size);
   1e569:	48 89 ef             	mov    %rbp,%rdi
   1e56c:	0f b7 d8             	movzwl %ax,%ebx
   1e56f:	48 89 de             	mov    %rbx,%rsi
   1e572:	e8 c9 fc ff ff       	callq  1e240 <style_resize>
    if(style == NULL) return;
   1e577:	48 85 ed             	test   %rbp,%rbp
   1e57a:	74 48                	je     1e5c4 <_lv_style_set_int+0xcc>
    _lv_memcpy_small(style->map + size - new_prop_size - end_mark_size, &prop, sizeof(lv_style_property_t));
   1e57c:	48 8b 45 00          	mov    0x0(%rbp),%rax
   1e580:	48 8d 74 24 0c       	lea    0xc(%rsp),%rsi
   1e585:	ba 02 00 00 00       	mov    $0x2,%edx
   1e58a:	48 8d 7c 18 fa       	lea    -0x6(%rax,%rbx,1),%rdi
   1e58f:	e8 a3 fc ff ff       	callq  1e237 <_lv_memcpy>
    _lv_memcpy_small(style->map + size - sizeof(lv_style_int_t) - end_mark_size, &value, sizeof(lv_style_int_t));
   1e594:	48 8b 45 00          	mov    0x0(%rbp),%rax
   1e598:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
   1e59d:	ba 02 00 00 00       	mov    $0x2,%edx
   1e5a2:	48 8d 7c 18 fc       	lea    -0x4(%rax,%rbx,1),%rdi
   1e5a7:	e8 8b fc ff ff       	callq  1e237 <_lv_memcpy>
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
   1e5ac:	48 8b 45 00          	mov    0x0(%rbp),%rax
   1e5b0:	48 8d 74 24 16       	lea    0x16(%rsp),%rsi
   1e5b5:	48 8d 7c 18 fe       	lea    -0x2(%rax,%rbx,1),%rdi
   1e5ba:	ba 02 00 00 00       	mov    $0x2,%edx
   1e5bf:	e8 73 fc ff ff       	callq  1e237 <_lv_memcpy>
}
   1e5c4:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
   1e5c9:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1e5d0:	00 00 
   1e5d2:	74 05                	je     1e5d9 <_lv_style_set_int+0xe1>
   1e5d4:	e8 67 60 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1e5d9:	48 83 c4 28          	add    $0x28,%rsp
   1e5dd:	5b                   	pop    %rbx
   1e5de:	5d                   	pop    %rbp
   1e5df:	c3                   	retq   

000000000001e5e0 <_lv_style_set_color>:
{
   1e5e0:	55                   	push   %rbp
   1e5e1:	53                   	push   %rbx
   1e5e2:	48 89 fd             	mov    %rdi,%rbp
   1e5e5:	48 83 ec 28          	sub    $0x28,%rsp
   1e5e9:	66 89 74 24 0c       	mov    %si,0xc(%rsp)
    int32_t id = get_property_index(style, prop);
   1e5ee:	0f b7 f6             	movzwl %si,%esi
{
   1e5f1:	89 54 24 08          	mov    %edx,0x8(%rsp)
   1e5f5:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1e5fc:	00 00 
   1e5fe:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1e603:	31 c0                	xor    %eax,%eax
    int32_t id = get_property_index(style, prop);
   1e605:	e8 7c fb ff ff       	callq  1e186 <get_property_index>
    if(id >= 0) {
   1e60a:	85 c0                	test   %eax,%eax
   1e60c:	78 2b                	js     1e639 <_lv_style_set_color+0x59>
        attr_found = get_style_prop_attr(style, id);
   1e60e:	48 63 d8             	movslq %eax,%rbx
   1e611:	48 89 ef             	mov    %rbp,%rdi
   1e614:	48 89 de             	mov    %rbx,%rsi
   1e617:	e8 32 fb ff ff       	callq  1e14e <get_style_prop_attr>
        if(LV_STYLE_ATTR_GET_STATE(attr_found) == LV_STYLE_ATTR_GET_STATE(attr_goal)) {
   1e61c:	32 44 24 0d          	xor    0xd(%rsp),%al
   1e620:	a8 7f                	test   $0x7f,%al
   1e622:	75 15                	jne    1e639 <_lv_style_set_color+0x59>
            _lv_memcpy_small(style->map + id + sizeof(lv_style_property_t), &color, sizeof(lv_color_t));
   1e624:	48 8b 45 00          	mov    0x0(%rbp),%rax
   1e628:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
   1e62d:	ba 04 00 00 00       	mov    $0x4,%edx
   1e632:	48 8d 7c 18 02       	lea    0x2(%rax,%rbx,1),%rdi
   1e637:	eb 72                	jmp    1e6ab <_lv_style_set_color+0xcb>
    uint16_t size = _lv_style_get_mem_size(style);
   1e639:	48 89 ef             	mov    %rbp,%rdi
    lv_style_property_t end_mark = _LV_STYLE_CLOSEING_PROP;
   1e63c:	66 c7 44 24 16 ff 00 	movw   $0xff,0x16(%rsp)
    uint16_t size = _lv_style_get_mem_size(style);
   1e643:	e8 3a fe ff ff       	callq  1e482 <_lv_style_get_mem_size>
    if(size == 0) size += end_mark_size;
   1e648:	66 85 c0             	test   %ax,%ax
   1e64b:	75 05                	jne    1e652 <_lv_style_set_color+0x72>
   1e64d:	b8 02 00 00 00       	mov    $0x2,%eax
    size += sizeof(lv_style_property_t) + sizeof(lv_color_t);
   1e652:	83 c0 06             	add    $0x6,%eax
    style_resize(style, size);
   1e655:	48 89 ef             	mov    %rbp,%rdi
   1e658:	0f b7 d8             	movzwl %ax,%ebx
   1e65b:	48 89 de             	mov    %rbx,%rsi
   1e65e:	e8 dd fb ff ff       	callq  1e240 <style_resize>
    if(style == NULL) return;
   1e663:	48 85 ed             	test   %rbp,%rbp
   1e666:	74 48                	je     1e6b0 <_lv_style_set_color+0xd0>
    _lv_memcpy_small(style->map + size - new_prop_size - end_mark_size, &prop, sizeof(lv_style_property_t));
   1e668:	48 8b 45 00          	mov    0x0(%rbp),%rax
   1e66c:	48 8d 74 24 0c       	lea    0xc(%rsp),%rsi
   1e671:	ba 02 00 00 00       	mov    $0x2,%edx
   1e676:	48 8d 7c 18 f8       	lea    -0x8(%rax,%rbx,1),%rdi
   1e67b:	e8 b7 fb ff ff       	callq  1e237 <_lv_memcpy>
    _lv_memcpy_small(style->map + size - sizeof(lv_color_t) - end_mark_size, &color, sizeof(lv_color_t));
   1e680:	48 8b 45 00          	mov    0x0(%rbp),%rax
   1e684:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
   1e689:	ba 04 00 00 00       	mov    $0x4,%edx
   1e68e:	48 8d 7c 18 fa       	lea    -0x6(%rax,%rbx,1),%rdi
   1e693:	e8 9f fb ff ff       	callq  1e237 <_lv_memcpy>
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
   1e698:	48 8b 45 00          	mov    0x0(%rbp),%rax
   1e69c:	48 8d 74 24 16       	lea    0x16(%rsp),%rsi
   1e6a1:	ba 02 00 00 00       	mov    $0x2,%edx
   1e6a6:	48 8d 7c 18 fe       	lea    -0x2(%rax,%rbx,1),%rdi
   1e6ab:	e8 87 fb ff ff       	callq  1e237 <_lv_memcpy>
}
   1e6b0:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
   1e6b5:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1e6bc:	00 00 
   1e6be:	74 05                	je     1e6c5 <_lv_style_set_color+0xe5>
   1e6c0:	e8 7b 5f fe ff       	callq  4640 <__stack_chk_fail@plt>
   1e6c5:	48 83 c4 28          	add    $0x28,%rsp
   1e6c9:	5b                   	pop    %rbx
   1e6ca:	5d                   	pop    %rbp
   1e6cb:	c3                   	retq   

000000000001e6cc <_lv_style_set_opa>:
{
   1e6cc:	55                   	push   %rbp
   1e6cd:	53                   	push   %rbx
   1e6ce:	48 89 fd             	mov    %rdi,%rbp
   1e6d1:	48 83 ec 28          	sub    $0x28,%rsp
   1e6d5:	66 89 74 24 0c       	mov    %si,0xc(%rsp)
    int32_t id = get_property_index(style, prop);
   1e6da:	0f b7 f6             	movzwl %si,%esi
{
   1e6dd:	88 54 24 08          	mov    %dl,0x8(%rsp)
   1e6e1:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1e6e8:	00 00 
   1e6ea:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1e6ef:	31 c0                	xor    %eax,%eax
    int32_t id = get_property_index(style, prop);
   1e6f1:	e8 90 fa ff ff       	callq  1e186 <get_property_index>
    if(id >= 0) {
   1e6f6:	85 c0                	test   %eax,%eax
   1e6f8:	78 2b                	js     1e725 <_lv_style_set_opa+0x59>
        attr_found = get_style_prop_attr(style, id);
   1e6fa:	48 63 d8             	movslq %eax,%rbx
   1e6fd:	48 89 ef             	mov    %rbp,%rdi
   1e700:	48 89 de             	mov    %rbx,%rsi
   1e703:	e8 46 fa ff ff       	callq  1e14e <get_style_prop_attr>
        if(LV_STYLE_ATTR_GET_STATE(attr_found) == LV_STYLE_ATTR_GET_STATE(attr_goal)) {
   1e708:	32 44 24 0d          	xor    0xd(%rsp),%al
   1e70c:	a8 7f                	test   $0x7f,%al
   1e70e:	75 15                	jne    1e725 <_lv_style_set_opa+0x59>
            _lv_memcpy_small(style->map + id + sizeof(lv_style_property_t), &opa, sizeof(lv_opa_t));
   1e710:	48 8b 45 00          	mov    0x0(%rbp),%rax
   1e714:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
   1e719:	ba 01 00 00 00       	mov    $0x1,%edx
   1e71e:	48 8d 7c 18 02       	lea    0x2(%rax,%rbx,1),%rdi
   1e723:	eb 72                	jmp    1e797 <_lv_style_set_opa+0xcb>
    uint16_t size = _lv_style_get_mem_size(style);
   1e725:	48 89 ef             	mov    %rbp,%rdi
    lv_style_property_t end_mark = _LV_STYLE_CLOSEING_PROP;
   1e728:	66 c7 44 24 16 ff 00 	movw   $0xff,0x16(%rsp)
    uint16_t size = _lv_style_get_mem_size(style);
   1e72f:	e8 4e fd ff ff       	callq  1e482 <_lv_style_get_mem_size>
    if(size == 0) size += end_mark_size;
   1e734:	66 85 c0             	test   %ax,%ax
   1e737:	75 05                	jne    1e73e <_lv_style_set_opa+0x72>
   1e739:	b8 02 00 00 00       	mov    $0x2,%eax
    size += sizeof(lv_style_property_t) + sizeof(lv_opa_t);
   1e73e:	83 c0 03             	add    $0x3,%eax
    style_resize(style, size);
   1e741:	48 89 ef             	mov    %rbp,%rdi
   1e744:	0f b7 d8             	movzwl %ax,%ebx
   1e747:	48 89 de             	mov    %rbx,%rsi
   1e74a:	e8 f1 fa ff ff       	callq  1e240 <style_resize>
    if(style == NULL) return;
   1e74f:	48 85 ed             	test   %rbp,%rbp
   1e752:	74 48                	je     1e79c <_lv_style_set_opa+0xd0>
    _lv_memcpy_small(style->map + size - new_prop_size - end_mark_size, &prop, sizeof(lv_style_property_t));
   1e754:	48 8b 45 00          	mov    0x0(%rbp),%rax
   1e758:	48 8d 74 24 0c       	lea    0xc(%rsp),%rsi
   1e75d:	ba 02 00 00 00       	mov    $0x2,%edx
   1e762:	48 8d 7c 18 fb       	lea    -0x5(%rax,%rbx,1),%rdi
   1e767:	e8 cb fa ff ff       	callq  1e237 <_lv_memcpy>
    _lv_memcpy_small(style->map + size - sizeof(lv_opa_t) - end_mark_size, &opa, sizeof(lv_opa_t));
   1e76c:	48 8b 45 00          	mov    0x0(%rbp),%rax
   1e770:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
   1e775:	ba 01 00 00 00       	mov    $0x1,%edx
   1e77a:	48 8d 7c 18 fd       	lea    -0x3(%rax,%rbx,1),%rdi
   1e77f:	e8 b3 fa ff ff       	callq  1e237 <_lv_memcpy>
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
   1e784:	48 8b 45 00          	mov    0x0(%rbp),%rax
   1e788:	48 8d 74 24 16       	lea    0x16(%rsp),%rsi
   1e78d:	ba 02 00 00 00       	mov    $0x2,%edx
   1e792:	48 8d 7c 18 fe       	lea    -0x2(%rax,%rbx,1),%rdi
   1e797:	e8 9b fa ff ff       	callq  1e237 <_lv_memcpy>
}
   1e79c:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
   1e7a1:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1e7a8:	00 00 
   1e7aa:	74 05                	je     1e7b1 <_lv_style_set_opa+0xe5>
   1e7ac:	e8 8f 5e fe ff       	callq  4640 <__stack_chk_fail@plt>
   1e7b1:	48 83 c4 28          	add    $0x28,%rsp
   1e7b5:	5b                   	pop    %rbx
   1e7b6:	5d                   	pop    %rbp
   1e7b7:	c3                   	retq   

000000000001e7b8 <_lv_style_get_int>:
    if(style == NULL) return -1;
   1e7b8:	48 85 ff             	test   %rdi,%rdi
   1e7bb:	74 54                	je     1e811 <_lv_style_get_int+0x59>
    if(style->map == NULL) return -1;
   1e7bd:	48 83 3f 00          	cmpq   $0x0,(%rdi)
   1e7c1:	74 4e                	je     1e811 <_lv_style_get_int+0x59>
{
   1e7c3:	41 54                	push   %r12
   1e7c5:	55                   	push   %rbp
   1e7c6:	89 f5                	mov    %esi,%ebp
   1e7c8:	53                   	push   %rbx
    int32_t id = get_property_index(style, prop);
   1e7c9:	0f b7 f6             	movzwl %si,%esi
   1e7cc:	49 89 d4             	mov    %rdx,%r12
   1e7cf:	48 89 fb             	mov    %rdi,%rbx
   1e7d2:	e8 af f9 ff ff       	callq  1e186 <get_property_index>
    if(id < 0) {
   1e7d7:	85 c0                	test   %eax,%eax
   1e7d9:	79 05                	jns    1e7e0 <_lv_style_get_int+0x28>
    if(style == NULL) return -1;
   1e7db:	83 c8 ff             	or     $0xffffffff,%eax
   1e7de:	eb 2c                	jmp    1e80c <_lv_style_get_int+0x54>
        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(lv_style_int_t));
   1e7e0:	4c 63 c0             	movslq %eax,%r8
   1e7e3:	48 8b 03             	mov    (%rbx),%rax
   1e7e6:	ba 02 00 00 00       	mov    $0x2,%edx
   1e7eb:	4c 89 e7             	mov    %r12,%rdi
        attr_goal = (prop >> 8) & 0xFF;
   1e7ee:	66 c1 ed 08          	shr    $0x8,%bp
        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(lv_style_int_t));
   1e7f2:	4a 8d 74 00 02       	lea    0x2(%rax,%r8,1),%rsi
   1e7f7:	e8 3b fa ff ff       	callq  1e237 <_lv_memcpy>
        attr_act = get_style_prop_attr(style, id);
   1e7fc:	48 89 df             	mov    %rbx,%rdi
   1e7ff:	4c 89 c6             	mov    %r8,%rsi
   1e802:	e8 47 f9 ff ff       	callq  1e14e <get_style_prop_attr>
        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);
   1e807:	83 e0 7f             	and    $0x7f,%eax
   1e80a:	21 e8                	and    %ebp,%eax
}
   1e80c:	5b                   	pop    %rbx
   1e80d:	5d                   	pop    %rbp
   1e80e:	41 5c                	pop    %r12
   1e810:	c3                   	retq   
    if(style == NULL) return -1;
   1e811:	83 c8 ff             	or     $0xffffffff,%eax
}
   1e814:	c3                   	retq   

000000000001e815 <_lv_style_get_opa>:
    if(style == NULL) return -1;
   1e815:	48 85 ff             	test   %rdi,%rdi
   1e818:	74 54                	je     1e86e <_lv_style_get_opa+0x59>
    if(style->map == NULL) return -1;
   1e81a:	48 83 3f 00          	cmpq   $0x0,(%rdi)
   1e81e:	74 4e                	je     1e86e <_lv_style_get_opa+0x59>
{
   1e820:	41 54                	push   %r12
   1e822:	55                   	push   %rbp
   1e823:	89 f5                	mov    %esi,%ebp
   1e825:	53                   	push   %rbx
    int32_t id = get_property_index(style, prop);
   1e826:	0f b7 f6             	movzwl %si,%esi
   1e829:	49 89 d4             	mov    %rdx,%r12
   1e82c:	48 89 fb             	mov    %rdi,%rbx
   1e82f:	e8 52 f9 ff ff       	callq  1e186 <get_property_index>
    if(id < 0) {
   1e834:	85 c0                	test   %eax,%eax
   1e836:	79 05                	jns    1e83d <_lv_style_get_opa+0x28>
    if(style == NULL) return -1;
   1e838:	83 c8 ff             	or     $0xffffffff,%eax
   1e83b:	eb 2c                	jmp    1e869 <_lv_style_get_opa+0x54>
        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(lv_opa_t));
   1e83d:	4c 63 c0             	movslq %eax,%r8
   1e840:	48 8b 03             	mov    (%rbx),%rax
   1e843:	ba 01 00 00 00       	mov    $0x1,%edx
   1e848:	4c 89 e7             	mov    %r12,%rdi
        attr_goal = (prop >> 8) & 0xFF;
   1e84b:	66 c1 ed 08          	shr    $0x8,%bp
        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(lv_opa_t));
   1e84f:	4a 8d 74 00 02       	lea    0x2(%rax,%r8,1),%rsi
   1e854:	e8 de f9 ff ff       	callq  1e237 <_lv_memcpy>
        attr_act = get_style_prop_attr(style, id);
   1e859:	48 89 df             	mov    %rbx,%rdi
   1e85c:	4c 89 c6             	mov    %r8,%rsi
   1e85f:	e8 ea f8 ff ff       	callq  1e14e <get_style_prop_attr>
        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);
   1e864:	83 e0 7f             	and    $0x7f,%eax
   1e867:	21 e8                	and    %ebp,%eax
}
   1e869:	5b                   	pop    %rbx
   1e86a:	5d                   	pop    %rbp
   1e86b:	41 5c                	pop    %r12
   1e86d:	c3                   	retq   
    if(style == NULL) return -1;
   1e86e:	83 c8 ff             	or     $0xffffffff,%eax
}
   1e871:	c3                   	retq   

000000000001e872 <_lv_style_get_color>:
    if(style == NULL) return -1;
   1e872:	48 85 ff             	test   %rdi,%rdi
   1e875:	74 54                	je     1e8cb <_lv_style_get_color+0x59>
    if(style->map == NULL) return -1;
   1e877:	48 83 3f 00          	cmpq   $0x0,(%rdi)
   1e87b:	74 4e                	je     1e8cb <_lv_style_get_color+0x59>
{
   1e87d:	41 54                	push   %r12
   1e87f:	55                   	push   %rbp
   1e880:	89 f5                	mov    %esi,%ebp
   1e882:	53                   	push   %rbx
    int32_t id = get_property_index(style, prop);
   1e883:	0f b7 f6             	movzwl %si,%esi
   1e886:	49 89 d4             	mov    %rdx,%r12
   1e889:	48 89 fb             	mov    %rdi,%rbx
   1e88c:	e8 f5 f8 ff ff       	callq  1e186 <get_property_index>
    if(id < 0) {
   1e891:	85 c0                	test   %eax,%eax
   1e893:	79 05                	jns    1e89a <_lv_style_get_color+0x28>
    if(style == NULL) return -1;
   1e895:	83 c8 ff             	or     $0xffffffff,%eax
   1e898:	eb 2c                	jmp    1e8c6 <_lv_style_get_color+0x54>
        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(lv_color_t));
   1e89a:	4c 63 c0             	movslq %eax,%r8
   1e89d:	48 8b 03             	mov    (%rbx),%rax
   1e8a0:	ba 04 00 00 00       	mov    $0x4,%edx
   1e8a5:	4c 89 e7             	mov    %r12,%rdi
        attr_goal = (prop >> 8) & 0xFF;
   1e8a8:	66 c1 ed 08          	shr    $0x8,%bp
        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(lv_color_t));
   1e8ac:	4a 8d 74 00 02       	lea    0x2(%rax,%r8,1),%rsi
   1e8b1:	e8 81 f9 ff ff       	callq  1e237 <_lv_memcpy>
        attr_act = get_style_prop_attr(style, id);
   1e8b6:	48 89 df             	mov    %rbx,%rdi
   1e8b9:	4c 89 c6             	mov    %r8,%rsi
   1e8bc:	e8 8d f8 ff ff       	callq  1e14e <get_style_prop_attr>
        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);
   1e8c1:	83 e0 7f             	and    $0x7f,%eax
   1e8c4:	21 e8                	and    %ebp,%eax
}
   1e8c6:	5b                   	pop    %rbx
   1e8c7:	5d                   	pop    %rbp
   1e8c8:	41 5c                	pop    %r12
   1e8ca:	c3                   	retq   
    if(style == NULL) return -1;
   1e8cb:	83 c8 ff             	or     $0xffffffff,%eax
}
   1e8ce:	c3                   	retq   

000000000001e8cf <_lv_style_get_ptr>:
    if(style == NULL) return -1;
   1e8cf:	48 85 ff             	test   %rdi,%rdi
   1e8d2:	74 54                	je     1e928 <_lv_style_get_ptr+0x59>
    if(style->map == NULL) return -1;
   1e8d4:	48 83 3f 00          	cmpq   $0x0,(%rdi)
   1e8d8:	74 4e                	je     1e928 <_lv_style_get_ptr+0x59>
{
   1e8da:	41 54                	push   %r12
   1e8dc:	55                   	push   %rbp
   1e8dd:	89 f5                	mov    %esi,%ebp
   1e8df:	53                   	push   %rbx
    int32_t id = get_property_index(style, prop);
   1e8e0:	0f b7 f6             	movzwl %si,%esi
   1e8e3:	49 89 d4             	mov    %rdx,%r12
   1e8e6:	48 89 fb             	mov    %rdi,%rbx
   1e8e9:	e8 98 f8 ff ff       	callq  1e186 <get_property_index>
    if(id < 0) {
   1e8ee:	85 c0                	test   %eax,%eax
   1e8f0:	79 05                	jns    1e8f7 <_lv_style_get_ptr+0x28>
    if(style == NULL) return -1;
   1e8f2:	83 c8 ff             	or     $0xffffffff,%eax
   1e8f5:	eb 2c                	jmp    1e923 <_lv_style_get_ptr+0x54>
        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(const void *));
   1e8f7:	4c 63 c0             	movslq %eax,%r8
   1e8fa:	48 8b 03             	mov    (%rbx),%rax
   1e8fd:	ba 08 00 00 00       	mov    $0x8,%edx
   1e902:	4c 89 e7             	mov    %r12,%rdi
        attr_goal = (prop >> 8) & 0xFF;
   1e905:	66 c1 ed 08          	shr    $0x8,%bp
        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(const void *));
   1e909:	4a 8d 74 00 02       	lea    0x2(%rax,%r8,1),%rsi
   1e90e:	e8 24 f9 ff ff       	callq  1e237 <_lv_memcpy>
        attr_act = get_style_prop_attr(style, id);
   1e913:	48 89 df             	mov    %rbx,%rdi
   1e916:	4c 89 c6             	mov    %r8,%rsi
   1e919:	e8 30 f8 ff ff       	callq  1e14e <get_style_prop_attr>
        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);
   1e91e:	83 e0 7f             	and    $0x7f,%eax
   1e921:	21 e8                	and    %ebp,%eax
}
   1e923:	5b                   	pop    %rbx
   1e924:	5d                   	pop    %rbp
   1e925:	41 5c                	pop    %r12
   1e927:	c3                   	retq   
    if(style == NULL) return -1;
   1e928:	83 c8 ff             	or     $0xffffffff,%eax
}
   1e92b:	c3                   	retq   

000000000001e92c <lv_style_list_get_local_style>:
    if(!list->has_local) return NULL;
   1e92c:	8a 57 08             	mov    0x8(%rdi),%dl
   1e92f:	31 c0                	xor    %eax,%eax
   1e931:	f6 c2 40             	test   $0x40,%dl
   1e934:	74 0f                	je     1e945 <lv_style_list_get_local_style+0x19>
    if(list->has_trans) return list->style_list[1];
   1e936:	84 d2                	test   %dl,%dl
   1e938:	48 8b 07             	mov    (%rdi),%rax
   1e93b:	79 05                	jns    1e942 <lv_style_list_get_local_style+0x16>
   1e93d:	48 8b 40 08          	mov    0x8(%rax),%rax
   1e941:	c3                   	retq   
    else return list->style_list[0];
   1e942:	48 8b 00             	mov    (%rax),%rax
}
   1e945:	c3                   	retq   

000000000001e946 <_lv_style_list_get_transition_style>:
    if(!list->has_trans) return NULL;
   1e946:	31 c0                	xor    %eax,%eax
   1e948:	80 7f 08 00          	cmpb   $0x0,0x8(%rdi)
   1e94c:	79 06                	jns    1e954 <_lv_style_list_get_transition_style+0xe>
    return list->style_list[0];
   1e94e:	48 8b 07             	mov    (%rdi),%rax
   1e951:	48 8b 00             	mov    (%rax),%rax
}
   1e954:	c3                   	retq   

000000000001e955 <_lv_style_list_reset>:
    if(list == NULL) return;
   1e955:	48 85 ff             	test   %rdi,%rdi
   1e958:	74 73                	je     1e9cd <_lv_style_list_reset+0x78>
{
   1e95a:	55                   	push   %rbp
   1e95b:	53                   	push   %rbx
   1e95c:	48 89 fb             	mov    %rdi,%rbx
   1e95f:	48 83 ec 08          	sub    $0x8,%rsp
    if(list->has_local) {
   1e963:	f6 47 08 40          	testb  $0x40,0x8(%rdi)
   1e967:	74 1d                	je     1e986 <_lv_style_list_reset+0x31>
        lv_style_t * local = lv_style_list_get_local_style(list);
   1e969:	e8 be ff ff ff       	callq  1e92c <lv_style_list_get_local_style>
        if(local) {
   1e96e:	48 85 c0             	test   %rax,%rax
        lv_style_t * local = lv_style_list_get_local_style(list);
   1e971:	48 89 c5             	mov    %rax,%rbp
        if(local) {
   1e974:	74 10                	je     1e986 <_lv_style_list_reset+0x31>
            lv_style_reset(local);
   1e976:	48 89 c7             	mov    %rax,%rdi
   1e979:	e8 ef fa ff ff       	callq  1e46d <lv_style_reset>
            lv_mem_free(local);
   1e97e:	48 89 ef             	mov    %rbp,%rdi
   1e981:	e8 7e 77 00 00       	callq  26104 <lv_mem_free>
    if(list->has_trans) {
   1e986:	80 7b 08 00          	cmpb   $0x0,0x8(%rbx)
   1e98a:	79 20                	jns    1e9ac <_lv_style_list_reset+0x57>
        lv_style_t * trans = _lv_style_list_get_transition_style(list);
   1e98c:	48 89 df             	mov    %rbx,%rdi
   1e98f:	e8 b2 ff ff ff       	callq  1e946 <_lv_style_list_get_transition_style>
        if(trans) {
   1e994:	48 85 c0             	test   %rax,%rax
        lv_style_t * trans = _lv_style_list_get_transition_style(list);
   1e997:	48 89 c5             	mov    %rax,%rbp
        if(trans) {
   1e99a:	74 10                	je     1e9ac <_lv_style_list_reset+0x57>
            lv_style_reset(trans);
   1e99c:	48 89 c7             	mov    %rax,%rdi
   1e99f:	e8 c9 fa ff ff       	callq  1e46d <lv_style_reset>
            lv_mem_free(trans);
   1e9a4:	48 89 ef             	mov    %rbp,%rdi
   1e9a7:	e8 58 77 00 00       	callq  26104 <lv_mem_free>
    if(list->style_cnt > 0) lv_mem_free(list->style_list);
   1e9ac:	f6 43 08 3f          	testb  $0x3f,0x8(%rbx)
   1e9b0:	74 08                	je     1e9ba <_lv_style_list_reset+0x65>
   1e9b2:	48 8b 3b             	mov    (%rbx),%rdi
   1e9b5:	e8 4a 77 00 00       	callq  26104 <lv_mem_free>
    list->skip_trans = 0;
   1e9ba:	80 63 09 fe          	andb   $0xfe,0x9(%rbx)
    list->style_list = NULL;
   1e9be:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
    list->has_trans = 0;
   1e9c5:	c6 43 08 00          	movb   $0x0,0x8(%rbx)
}
   1e9c9:	58                   	pop    %rax
   1e9ca:	5b                   	pop    %rbx
   1e9cb:	5d                   	pop    %rbp
   1e9cc:	c3                   	retq   
   1e9cd:	c3                   	retq   

000000000001e9ce <lv_style_list_copy>:
{
   1e9ce:	55                   	push   %rbp
   1e9cf:	53                   	push   %rbx
   1e9d0:	48 89 f3             	mov    %rsi,%rbx
   1e9d3:	48 89 fd             	mov    %rdi,%rbp
   1e9d6:	48 83 ec 08          	sub    $0x8,%rsp
    _lv_style_list_reset(list_dest);
   1e9da:	e8 76 ff ff ff       	callq  1e955 <_lv_style_list_reset>
    if(list_src->style_list == NULL) return;
   1e9df:	48 83 3b 00          	cmpq   $0x0,(%rbx)
   1e9e3:	0f 84 34 01 00 00    	je     1eb1d <lv_style_list_copy+0x14f>
    if(list_src->has_local == 0) {
   1e9e9:	8a 43 08             	mov    0x8(%rbx),%al
   1e9ec:	40 88 c7             	mov    %al,%dil
   1e9ef:	83 e7 3f             	and    $0x3f,%edi
   1e9f2:	a8 40                	test   $0x40,%al
   1e9f4:	75 7e                	jne    1ea74 <lv_style_list_copy+0xa6>
        if(list_src->has_trans) {
   1e9f6:	84 c0                	test   %al,%al
   1e9f8:	79 3c                	jns    1ea36 <lv_style_list_copy+0x68>
            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 1) * sizeof(lv_style_t *));
   1e9fa:	40 0f b6 ff          	movzbl %dil,%edi
   1e9fe:	ff cf                	dec    %edi
   1ea00:	48 63 ff             	movslq %edi,%rdi
   1ea03:	48 c1 e7 03          	shl    $0x3,%rdi
   1ea07:	e8 85 76 00 00       	callq  26091 <lv_mem_alloc>
            _lv_memcpy(list_dest->style_list, list_src->style_list + 1, (list_src->style_cnt - 1) * sizeof(lv_style_t *));
   1ea0c:	8a 53 08             	mov    0x8(%rbx),%dl
            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 1) * sizeof(lv_style_t *));
   1ea0f:	48 89 45 00          	mov    %rax,0x0(%rbp)
            _lv_memcpy(list_dest->style_list, list_src->style_list + 1, (list_src->style_cnt - 1) * sizeof(lv_style_t *));
   1ea13:	48 89 c7             	mov    %rax,%rdi
   1ea16:	48 8b 0b             	mov    (%rbx),%rcx
   1ea19:	83 e2 3f             	and    $0x3f,%edx
   1ea1c:	ff ca                	dec    %edx
   1ea1e:	48 8d 71 08          	lea    0x8(%rcx),%rsi
   1ea22:	48 63 d2             	movslq %edx,%rdx
   1ea25:	48 c1 e2 03          	shl    $0x3,%rdx
   1ea29:	e8 09 f8 ff ff       	callq  1e237 <_lv_memcpy>
            list_dest->style_cnt = list_src->style_cnt - 1;
   1ea2e:	8a 43 08             	mov    0x8(%rbx),%al
   1ea31:	83 c0 3f             	add    $0x3f,%eax
   1ea34:	eb 29                	jmp    1ea5f <lv_style_list_copy+0x91>
            list_dest->style_list = lv_mem_alloc(list_src->style_cnt * sizeof(lv_style_t *));
   1ea36:	40 0f b6 ff          	movzbl %dil,%edi
   1ea3a:	48 c1 e7 03          	shl    $0x3,%rdi
   1ea3e:	e8 4e 76 00 00       	callq  26091 <lv_mem_alloc>
            _lv_memcpy(list_dest->style_list, list_src->style_list, list_src->style_cnt * sizeof(lv_style_t *));
   1ea43:	8a 53 08             	mov    0x8(%rbx),%dl
            list_dest->style_list = lv_mem_alloc(list_src->style_cnt * sizeof(lv_style_t *));
   1ea46:	48 89 45 00          	mov    %rax,0x0(%rbp)
            _lv_memcpy(list_dest->style_list, list_src->style_list, list_src->style_cnt * sizeof(lv_style_t *));
   1ea4a:	48 89 c7             	mov    %rax,%rdi
   1ea4d:	48 8b 33             	mov    (%rbx),%rsi
   1ea50:	83 e2 3f             	and    $0x3f,%edx
   1ea53:	48 c1 e2 03          	shl    $0x3,%rdx
   1ea57:	e8 db f7 ff ff       	callq  1e237 <_lv_memcpy>
            list_dest->style_cnt = list_src->style_cnt;
   1ea5c:	8a 43 08             	mov    0x8(%rbx),%al
   1ea5f:	83 e0 3f             	and    $0x3f,%eax
   1ea62:	88 c2                	mov    %al,%dl
   1ea64:	8a 45 08             	mov    0x8(%rbp),%al
   1ea67:	83 e0 c0             	and    $0xffffffc0,%eax
   1ea6a:	09 d0                	or     %edx,%eax
   1ea6c:	88 45 08             	mov    %al,0x8(%rbp)
   1ea6f:	e9 a9 00 00 00       	jmpq   1eb1d <lv_style_list_copy+0x14f>
        if(list_src->has_trans) {
   1ea74:	84 c0                	test   %al,%al
   1ea76:	40 0f b6 ff          	movzbl %dil,%edi
   1ea7a:	79 3a                	jns    1eab6 <lv_style_list_copy+0xe8>
            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 2) * sizeof(lv_style_t *));
   1ea7c:	83 ef 02             	sub    $0x2,%edi
   1ea7f:	48 63 ff             	movslq %edi,%rdi
   1ea82:	48 c1 e7 03          	shl    $0x3,%rdi
   1ea86:	e8 06 76 00 00       	callq  26091 <lv_mem_alloc>
            _lv_memcpy(list_dest->style_list, list_src->style_list + 2, (list_src->style_cnt - 2) * sizeof(lv_style_t *));
   1ea8b:	8a 53 08             	mov    0x8(%rbx),%dl
            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 2) * sizeof(lv_style_t *));
   1ea8e:	48 89 45 00          	mov    %rax,0x0(%rbp)
            _lv_memcpy(list_dest->style_list, list_src->style_list + 2, (list_src->style_cnt - 2) * sizeof(lv_style_t *));
   1ea92:	48 89 c7             	mov    %rax,%rdi
   1ea95:	48 8b 0b             	mov    (%rbx),%rcx
   1ea98:	83 e2 3f             	and    $0x3f,%edx
   1ea9b:	83 ea 02             	sub    $0x2,%edx
   1ea9e:	48 8d 71 10          	lea    0x10(%rcx),%rsi
   1eaa2:	48 63 d2             	movslq %edx,%rdx
   1eaa5:	48 c1 e2 03          	shl    $0x3,%rdx
   1eaa9:	e8 89 f7 ff ff       	callq  1e237 <_lv_memcpy>
            list_dest->style_cnt = list_src->style_cnt - 2;
   1eaae:	8a 43 08             	mov    0x8(%rbx),%al
   1eab1:	83 c0 3e             	add    $0x3e,%eax
   1eab4:	eb 36                	jmp    1eaec <lv_style_list_copy+0x11e>
            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 1) * sizeof(lv_style_t *));
   1eab6:	ff cf                	dec    %edi
   1eab8:	48 63 ff             	movslq %edi,%rdi
   1eabb:	48 c1 e7 03          	shl    $0x3,%rdi
   1eabf:	e8 cd 75 00 00       	callq  26091 <lv_mem_alloc>
            _lv_memcpy(list_dest->style_list, list_src->style_list + 1, (list_src->style_cnt - 1) * sizeof(lv_style_t *));
   1eac4:	8a 53 08             	mov    0x8(%rbx),%dl
            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 1) * sizeof(lv_style_t *));
   1eac7:	48 89 45 00          	mov    %rax,0x0(%rbp)
            _lv_memcpy(list_dest->style_list, list_src->style_list + 1, (list_src->style_cnt - 1) * sizeof(lv_style_t *));
   1eacb:	48 89 c7             	mov    %rax,%rdi
   1eace:	48 8b 0b             	mov    (%rbx),%rcx
   1ead1:	83 e2 3f             	and    $0x3f,%edx
   1ead4:	ff ca                	dec    %edx
   1ead6:	48 8d 71 08          	lea    0x8(%rcx),%rsi
   1eada:	48 63 d2             	movslq %edx,%rdx
   1eadd:	48 c1 e2 03          	shl    $0x3,%rdx
   1eae1:	e8 51 f7 ff ff       	callq  1e237 <_lv_memcpy>
            list_dest->style_cnt = list_src->style_cnt - 1;
   1eae6:	8a 43 08             	mov    0x8(%rbx),%al
   1eae9:	83 c0 3f             	add    $0x3f,%eax
   1eaec:	83 e0 3f             	and    $0x3f,%eax
        lv_style_t * local_style = get_alloc_local_style(list_dest);
   1eaef:	48 89 ef             	mov    %rbp,%rdi
            list_dest->style_cnt = list_src->style_cnt - 1;
   1eaf2:	88 c2                	mov    %al,%dl
   1eaf4:	8a 45 08             	mov    0x8(%rbp),%al
   1eaf7:	83 e0 c0             	and    $0xffffffc0,%eax
   1eafa:	09 d0                	or     %edx,%eax
   1eafc:	88 45 08             	mov    %al,0x8(%rbp)
        lv_style_t * local_style = get_alloc_local_style(list_dest);
   1eaff:	e8 f1 f8 ff ff       	callq  1e3f5 <get_alloc_local_style>
        lv_style_copy(local_style, get_alloc_local_style((lv_style_list_t *)list_src));
   1eb04:	48 89 df             	mov    %rbx,%rdi
        lv_style_t * local_style = get_alloc_local_style(list_dest);
   1eb07:	48 89 c5             	mov    %rax,%rbp
        lv_style_copy(local_style, get_alloc_local_style((lv_style_list_t *)list_src));
   1eb0a:	e8 e6 f8 ff ff       	callq  1e3f5 <get_alloc_local_style>
}
   1eb0f:	5a                   	pop    %rdx
        lv_style_copy(local_style, get_alloc_local_style((lv_style_list_t *)list_src));
   1eb10:	48 89 ef             	mov    %rbp,%rdi
   1eb13:	48 89 c6             	mov    %rax,%rsi
}
   1eb16:	5b                   	pop    %rbx
   1eb17:	5d                   	pop    %rbp
        lv_style_copy(local_style, get_alloc_local_style((lv_style_list_t *)list_src));
   1eb18:	e9 9c f9 ff ff       	jmpq   1e4b9 <lv_style_copy>
}
   1eb1d:	58                   	pop    %rax
   1eb1e:	5b                   	pop    %rbx
   1eb1f:	5d                   	pop    %rbp
   1eb20:	c3                   	retq   

000000000001eb21 <_lv_style_list_get_int>:
{
   1eb21:	41 57                	push   %r15
   1eb23:	41 56                	push   %r14
   1eb25:	41 55                	push   %r13
   1eb27:	41 54                	push   %r12
   1eb29:	55                   	push   %rbp
   1eb2a:	53                   	push   %rbx
   1eb2b:	48 83 ec 28          	sub    $0x28,%rsp
   1eb2f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1eb36:	00 00 
   1eb38:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1eb3d:	31 c0                	xor    %eax,%eax
    if(list == NULL) return LV_RES_INV;
   1eb3f:	48 85 ff             	test   %rdi,%rdi
   1eb42:	0f 84 a3 00 00 00    	je     1ebeb <_lv_style_list_get_int+0xca>
    if(list->style_list == NULL) return LV_RES_INV;
   1eb48:	48 83 3f 00          	cmpq   $0x0,(%rdi)
   1eb4c:	48 89 fd             	mov    %rdi,%rbp
   1eb4f:	0f 84 96 00 00 00    	je     1ebeb <_lv_style_list_get_int+0xca>
    attr = prop >> 8;
   1eb55:	89 f0                	mov    %esi,%eax
        int16_t weight_act = _lv_style_get_int(class, prop, &value_act);
   1eb57:	4c 8d 7c 24 16       	lea    0x16(%rsp),%r15
   1eb5c:	49 89 d5             	mov    %rdx,%r13
    attr = prop >> 8;
   1eb5f:	66 c1 e8 08          	shr    $0x8,%ax
   1eb63:	41 89 f6             	mov    %esi,%r14d
    lv_style_int_t value_act = 0;
   1eb66:	66 c7 44 24 16 00 00 	movw   $0x0,0x16(%rsp)
    attr = prop >> 8;
   1eb6d:	66 89 44 24 0e       	mov    %ax,0xe(%rsp)
    for(ci = 0; ci < list->style_cnt; ci++) {
   1eb72:	45 31 e4             	xor    %r12d,%r12d
    int16_t weight = -1;
   1eb75:	83 cb ff             	or     $0xffffffff,%ebx
    for(ci = 0; ci < list->style_cnt; ci++) {
   1eb78:	8a 45 08             	mov    0x8(%rbp),%al
   1eb7b:	41 0f bf d4          	movswl %r12w,%edx
   1eb7f:	83 e0 3f             	and    $0x3f,%eax
   1eb82:	39 c2                	cmp    %eax,%edx
   1eb84:	7d 5d                	jge    1ebe3 <_lv_style_list_get_int+0xc2>
        lv_style_t * class = lv_style_list_get_style(list, ci);
   1eb86:	41 0f b6 f4          	movzbl %r12b,%esi
   1eb8a:	48 89 ef             	mov    %rbp,%rdi
   1eb8d:	e8 4b f5 ff ff       	callq  1e0dd <lv_style_list_get_style>
        int16_t weight_act = _lv_style_get_int(class, prop, &value_act);
   1eb92:	41 0f b7 f6          	movzwl %r14w,%esi
   1eb96:	4c 89 fa             	mov    %r15,%rdx
   1eb99:	48 89 c7             	mov    %rax,%rdi
   1eb9c:	e8 17 fc ff ff       	callq  1e7b8 <_lv_style_get_int>
        if(weight_act == weight_goal) {
   1eba1:	66 39 44 24 0e       	cmp    %ax,0xe(%rsp)
   1eba6:	75 0e                	jne    1ebb6 <_lv_style_list_get_int+0x95>
            *res = value_act;
   1eba8:	66 8b 44 24 16       	mov    0x16(%rsp),%ax
   1ebad:	66 41 89 45 00       	mov    %ax,0x0(%r13)
            return LV_RES_OK;
   1ebb2:	b0 01                	mov    $0x1,%al
   1ebb4:	eb 35                	jmp    1ebeb <_lv_style_list_get_int+0xca>
        else if(list->has_trans && weight_act >= 0 && ci == 0 && !list->skip_trans) {
   1ebb6:	80 7d 08 00          	cmpb   $0x0,0x8(%rbp)
   1ebba:	79 11                	jns    1ebcd <_lv_style_list_get_int+0xac>
   1ebbc:	66 85 c0             	test   %ax,%ax
   1ebbf:	78 0c                	js     1ebcd <_lv_style_list_get_int+0xac>
   1ebc1:	66 45 85 e4          	test   %r12w,%r12w
   1ebc5:	75 06                	jne    1ebcd <_lv_style_list_get_int+0xac>
   1ebc7:	f6 45 09 01          	testb  $0x1,0x9(%rbp)
   1ebcb:	74 db                	je     1eba8 <_lv_style_list_get_int+0x87>
        else if(weight_act > weight) {
   1ebcd:	66 39 c3             	cmp    %ax,%bx
   1ebd0:	7d 0c                	jge    1ebde <_lv_style_list_get_int+0xbd>
            *res = value_act;
   1ebd2:	66 8b 54 24 16       	mov    0x16(%rsp),%dx
   1ebd7:	89 c3                	mov    %eax,%ebx
   1ebd9:	66 41 89 55 00       	mov    %dx,0x0(%r13)
   1ebde:	41 ff c4             	inc    %r12d
   1ebe1:	eb 95                	jmp    1eb78 <_lv_style_list_get_int+0x57>
    if(weight >= 0) return LV_RES_OK;
   1ebe3:	89 d8                	mov    %ebx,%eax
   1ebe5:	f7 d0                	not    %eax
    if(list == NULL) return LV_RES_INV;
   1ebe7:	66 c1 e8 0f          	shr    $0xf,%ax
}
   1ebeb:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   1ebf0:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1ebf7:	00 00 
   1ebf9:	74 05                	je     1ec00 <_lv_style_list_get_int+0xdf>
   1ebfb:	e8 40 5a fe ff       	callq  4640 <__stack_chk_fail@plt>
   1ec00:	48 83 c4 28          	add    $0x28,%rsp
   1ec04:	5b                   	pop    %rbx
   1ec05:	5d                   	pop    %rbp
   1ec06:	41 5c                	pop    %r12
   1ec08:	41 5d                	pop    %r13
   1ec0a:	41 5e                	pop    %r14
   1ec0c:	41 5f                	pop    %r15
   1ec0e:	c3                   	retq   

000000000001ec0f <_lv_style_list_get_color>:
{
   1ec0f:	41 57                	push   %r15
   1ec11:	41 56                	push   %r14
   1ec13:	41 55                	push   %r13
   1ec15:	41 54                	push   %r12
   1ec17:	55                   	push   %rbp
   1ec18:	53                   	push   %rbx
   1ec19:	48 83 ec 28          	sub    $0x28,%rsp
   1ec1d:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1ec24:	00 00 
   1ec26:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1ec2b:	31 c0                	xor    %eax,%eax
    if(list == NULL) return LV_RES_INV;
   1ec2d:	48 85 ff             	test   %rdi,%rdi
   1ec30:	0f 84 a0 00 00 00    	je     1ecd6 <_lv_style_list_get_color+0xc7>
    if(list->style_list == NULL) return LV_RES_INV;
   1ec36:	48 83 3f 00          	cmpq   $0x0,(%rdi)
   1ec3a:	48 89 fd             	mov    %rdi,%rbp
   1ec3d:	0f 84 93 00 00 00    	je     1ecd6 <_lv_style_list_get_color+0xc7>
    attr = prop >> 8;
   1ec43:	89 f0                	mov    %esi,%eax
        int16_t weight_act = _lv_style_get_color(class, prop, &value_act);
   1ec45:	4c 8d 7c 24 14       	lea    0x14(%rsp),%r15
   1ec4a:	49 89 d5             	mov    %rdx,%r13
    attr = prop >> 8;
   1ec4d:	66 c1 e8 08          	shr    $0x8,%ax
   1ec51:	41 89 f6             	mov    %esi,%r14d
    value_act.full = 0;
   1ec54:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%rsp)
   1ec5b:	00 
    attr = prop >> 8;
   1ec5c:	66 89 44 24 0e       	mov    %ax,0xe(%rsp)
    for(ci = 0; ci < list->style_cnt; ci++) {
   1ec61:	45 31 e4             	xor    %r12d,%r12d
    int16_t weight = -1;
   1ec64:	83 cb ff             	or     $0xffffffff,%ebx
    for(ci = 0; ci < list->style_cnt; ci++) {
   1ec67:	8a 45 08             	mov    0x8(%rbp),%al
   1ec6a:	41 0f bf d4          	movswl %r12w,%edx
   1ec6e:	83 e0 3f             	and    $0x3f,%eax
   1ec71:	39 c2                	cmp    %eax,%edx
   1ec73:	7d 59                	jge    1ecce <_lv_style_list_get_color+0xbf>
        lv_style_t * class = lv_style_list_get_style(list, ci);
   1ec75:	41 0f b6 f4          	movzbl %r12b,%esi
   1ec79:	48 89 ef             	mov    %rbp,%rdi
   1ec7c:	e8 5c f4 ff ff       	callq  1e0dd <lv_style_list_get_style>
        int16_t weight_act = _lv_style_get_color(class, prop, &value_act);
   1ec81:	41 0f b7 f6          	movzwl %r14w,%esi
   1ec85:	4c 89 fa             	mov    %r15,%rdx
   1ec88:	48 89 c7             	mov    %rax,%rdi
   1ec8b:	e8 e2 fb ff ff       	callq  1e872 <_lv_style_get_color>
        if(weight_act == weight_goal) {
   1ec90:	66 39 44 24 0e       	cmp    %ax,0xe(%rsp)
   1ec95:	75 0c                	jne    1eca3 <_lv_style_list_get_color+0x94>
            *res = value_act;
   1ec97:	8b 44 24 14          	mov    0x14(%rsp),%eax
   1ec9b:	41 89 45 00          	mov    %eax,0x0(%r13)
            return LV_RES_OK;
   1ec9f:	b0 01                	mov    $0x1,%al
   1eca1:	eb 33                	jmp    1ecd6 <_lv_style_list_get_color+0xc7>
        else if(list->has_trans && weight_act >= 0 && ci == 0 && !list->skip_trans) {
   1eca3:	80 7d 08 00          	cmpb   $0x0,0x8(%rbp)
   1eca7:	79 11                	jns    1ecba <_lv_style_list_get_color+0xab>
   1eca9:	66 85 c0             	test   %ax,%ax
   1ecac:	78 0c                	js     1ecba <_lv_style_list_get_color+0xab>
   1ecae:	66 45 85 e4          	test   %r12w,%r12w
   1ecb2:	75 06                	jne    1ecba <_lv_style_list_get_color+0xab>
   1ecb4:	f6 45 09 01          	testb  $0x1,0x9(%rbp)
   1ecb8:	74 dd                	je     1ec97 <_lv_style_list_get_color+0x88>
        else if(weight_act > weight) {
   1ecba:	66 39 c3             	cmp    %ax,%bx
   1ecbd:	7d 0a                	jge    1ecc9 <_lv_style_list_get_color+0xba>
            *res = value_act;
   1ecbf:	8b 54 24 14          	mov    0x14(%rsp),%edx
   1ecc3:	89 c3                	mov    %eax,%ebx
   1ecc5:	41 89 55 00          	mov    %edx,0x0(%r13)
   1ecc9:	41 ff c4             	inc    %r12d
   1eccc:	eb 99                	jmp    1ec67 <_lv_style_list_get_color+0x58>
    if(weight >= 0)  return LV_RES_OK;
   1ecce:	89 d8                	mov    %ebx,%eax
   1ecd0:	f7 d0                	not    %eax
    if(list == NULL) return LV_RES_INV;
   1ecd2:	66 c1 e8 0f          	shr    $0xf,%ax
}
   1ecd6:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   1ecdb:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1ece2:	00 00 
   1ece4:	74 05                	je     1eceb <_lv_style_list_get_color+0xdc>
   1ece6:	e8 55 59 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1eceb:	48 83 c4 28          	add    $0x28,%rsp
   1ecef:	5b                   	pop    %rbx
   1ecf0:	5d                   	pop    %rbp
   1ecf1:	41 5c                	pop    %r12
   1ecf3:	41 5d                	pop    %r13
   1ecf5:	41 5e                	pop    %r14
   1ecf7:	41 5f                	pop    %r15
   1ecf9:	c3                   	retq   

000000000001ecfa <_lv_style_list_get_opa>:
{
   1ecfa:	41 57                	push   %r15
   1ecfc:	41 56                	push   %r14
   1ecfe:	41 55                	push   %r13
   1ed00:	41 54                	push   %r12
   1ed02:	55                   	push   %rbp
   1ed03:	53                   	push   %rbx
   1ed04:	48 83 ec 28          	sub    $0x28,%rsp
   1ed08:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1ed0f:	00 00 
   1ed11:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1ed16:	31 c0                	xor    %eax,%eax
    if(list == NULL) return LV_RES_INV;
   1ed18:	48 85 ff             	test   %rdi,%rdi
   1ed1b:	0f 84 9d 00 00 00    	je     1edbe <_lv_style_list_get_opa+0xc4>
    if(list->style_list == NULL) return LV_RES_INV;
   1ed21:	48 83 3f 00          	cmpq   $0x0,(%rdi)
   1ed25:	48 89 fd             	mov    %rdi,%rbp
   1ed28:	0f 84 90 00 00 00    	je     1edbe <_lv_style_list_get_opa+0xc4>
    attr = prop >> 8;
   1ed2e:	89 f0                	mov    %esi,%eax
        int16_t weight_act = _lv_style_get_opa(class, prop, &value_act);
   1ed30:	4c 8d 7c 24 17       	lea    0x17(%rsp),%r15
   1ed35:	49 89 d5             	mov    %rdx,%r13
    attr = prop >> 8;
   1ed38:	66 c1 e8 08          	shr    $0x8,%ax
   1ed3c:	41 89 f6             	mov    %esi,%r14d
    lv_opa_t value_act = LV_OPA_TRANSP;
   1ed3f:	c6 44 24 17 00       	movb   $0x0,0x17(%rsp)
    attr = prop >> 8;
   1ed44:	66 89 44 24 0e       	mov    %ax,0xe(%rsp)
    for(ci = 0; ci < list->style_cnt; ci++) {
   1ed49:	45 31 e4             	xor    %r12d,%r12d
    int16_t weight = -1;
   1ed4c:	83 cb ff             	or     $0xffffffff,%ebx
    for(ci = 0; ci < list->style_cnt; ci++) {
   1ed4f:	8a 45 08             	mov    0x8(%rbp),%al
   1ed52:	41 0f bf d4          	movswl %r12w,%edx
   1ed56:	83 e0 3f             	and    $0x3f,%eax
   1ed59:	39 c2                	cmp    %eax,%edx
   1ed5b:	7d 59                	jge    1edb6 <_lv_style_list_get_opa+0xbc>
        lv_style_t * class = lv_style_list_get_style(list, ci);
   1ed5d:	41 0f b6 f4          	movzbl %r12b,%esi
   1ed61:	48 89 ef             	mov    %rbp,%rdi
   1ed64:	e8 74 f3 ff ff       	callq  1e0dd <lv_style_list_get_style>
        int16_t weight_act = _lv_style_get_opa(class, prop, &value_act);
   1ed69:	41 0f b7 f6          	movzwl %r14w,%esi
   1ed6d:	4c 89 fa             	mov    %r15,%rdx
   1ed70:	48 89 c7             	mov    %rax,%rdi
   1ed73:	e8 9d fa ff ff       	callq  1e815 <_lv_style_get_opa>
        if(weight_act == weight_goal) {
   1ed78:	66 39 44 24 0e       	cmp    %ax,0xe(%rsp)
   1ed7d:	75 0c                	jne    1ed8b <_lv_style_list_get_opa+0x91>
            *res = value_act;
   1ed7f:	8a 44 24 17          	mov    0x17(%rsp),%al
   1ed83:	41 88 45 00          	mov    %al,0x0(%r13)
            return LV_RES_OK;
   1ed87:	b0 01                	mov    $0x1,%al
   1ed89:	eb 33                	jmp    1edbe <_lv_style_list_get_opa+0xc4>
        else if(list->has_trans && weight_act >= 0 && ci == 0 && !list->skip_trans) {
   1ed8b:	80 7d 08 00          	cmpb   $0x0,0x8(%rbp)
   1ed8f:	79 11                	jns    1eda2 <_lv_style_list_get_opa+0xa8>
   1ed91:	66 85 c0             	test   %ax,%ax
   1ed94:	78 0c                	js     1eda2 <_lv_style_list_get_opa+0xa8>
   1ed96:	66 45 85 e4          	test   %r12w,%r12w
   1ed9a:	75 06                	jne    1eda2 <_lv_style_list_get_opa+0xa8>
   1ed9c:	f6 45 09 01          	testb  $0x1,0x9(%rbp)
   1eda0:	74 dd                	je     1ed7f <_lv_style_list_get_opa+0x85>
        else if(weight_act > weight) {
   1eda2:	66 39 c3             	cmp    %ax,%bx
   1eda5:	7d 0a                	jge    1edb1 <_lv_style_list_get_opa+0xb7>
            *res = value_act;
   1eda7:	8a 54 24 17          	mov    0x17(%rsp),%dl
   1edab:	89 c3                	mov    %eax,%ebx
   1edad:	41 88 55 00          	mov    %dl,0x0(%r13)
   1edb1:	41 ff c4             	inc    %r12d
   1edb4:	eb 99                	jmp    1ed4f <_lv_style_list_get_opa+0x55>
    if(weight >= 0)  return LV_RES_OK;
   1edb6:	89 d8                	mov    %ebx,%eax
   1edb8:	f7 d0                	not    %eax
    if(list == NULL) return LV_RES_INV;
   1edba:	66 c1 e8 0f          	shr    $0xf,%ax
}
   1edbe:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   1edc3:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1edca:	00 00 
   1edcc:	74 05                	je     1edd3 <_lv_style_list_get_opa+0xd9>
   1edce:	e8 6d 58 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1edd3:	48 83 c4 28          	add    $0x28,%rsp
   1edd7:	5b                   	pop    %rbx
   1edd8:	5d                   	pop    %rbp
   1edd9:	41 5c                	pop    %r12
   1eddb:	41 5d                	pop    %r13
   1eddd:	41 5e                	pop    %r14
   1eddf:	41 5f                	pop    %r15
   1ede1:	c3                   	retq   

000000000001ede2 <_lv_style_list_get_ptr>:
{
   1ede2:	41 57                	push   %r15
   1ede4:	41 56                	push   %r14
   1ede6:	41 55                	push   %r13
   1ede8:	41 54                	push   %r12
   1edea:	55                   	push   %rbp
   1edeb:	53                   	push   %rbx
   1edec:	48 83 ec 28          	sub    $0x28,%rsp
   1edf0:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1edf7:	00 00 
   1edf9:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   1edfe:	31 c0                	xor    %eax,%eax
    if(list == NULL) return LV_RES_INV;
   1ee00:	48 85 ff             	test   %rdi,%rdi
   1ee03:	0f 84 9a 00 00 00    	je     1eea3 <_lv_style_list_get_ptr+0xc1>
    if(list->style_list == NULL) return LV_RES_INV;
   1ee09:	48 83 3f 00          	cmpq   $0x0,(%rdi)
   1ee0d:	48 89 fd             	mov    %rdi,%rbp
   1ee10:	0f 84 8d 00 00 00    	je     1eea3 <_lv_style_list_get_ptr+0xc1>
    attr = prop >> 8;
   1ee16:	89 f0                	mov    %esi,%eax
        int16_t weight_act = _lv_style_get_ptr(class, prop, &value_act);
   1ee18:	4c 8d 7c 24 10       	lea    0x10(%rsp),%r15
   1ee1d:	49 89 d5             	mov    %rdx,%r13
    attr = prop >> 8;
   1ee20:	66 c1 e8 08          	shr    $0x8,%ax
   1ee24:	41 89 f6             	mov    %esi,%r14d
    for(ci = 0; ci < list->style_cnt; ci++) {
   1ee27:	45 31 e4             	xor    %r12d,%r12d
    attr = prop >> 8;
   1ee2a:	66 89 44 24 0e       	mov    %ax,0xe(%rsp)
    int16_t weight = -1;
   1ee2f:	83 cb ff             	or     $0xffffffff,%ebx
    for(ci = 0; ci < list->style_cnt; ci++) {
   1ee32:	8a 45 08             	mov    0x8(%rbp),%al
   1ee35:	41 0f bf d4          	movswl %r12w,%edx
   1ee39:	83 e0 3f             	and    $0x3f,%eax
   1ee3c:	39 c2                	cmp    %eax,%edx
   1ee3e:	7d 5b                	jge    1ee9b <_lv_style_list_get_ptr+0xb9>
        lv_style_t * class = lv_style_list_get_style(list, ci);
   1ee40:	41 0f b6 f4          	movzbl %r12b,%esi
   1ee44:	48 89 ef             	mov    %rbp,%rdi
   1ee47:	e8 91 f2 ff ff       	callq  1e0dd <lv_style_list_get_style>
        int16_t weight_act = _lv_style_get_ptr(class, prop, &value_act);
   1ee4c:	41 0f b7 f6          	movzwl %r14w,%esi
   1ee50:	4c 89 fa             	mov    %r15,%rdx
   1ee53:	48 89 c7             	mov    %rax,%rdi
   1ee56:	e8 74 fa ff ff       	callq  1e8cf <_lv_style_get_ptr>
        if(weight_act == weight_goal) {
   1ee5b:	66 39 44 24 0e       	cmp    %ax,0xe(%rsp)
   1ee60:	75 0d                	jne    1ee6f <_lv_style_list_get_ptr+0x8d>
            *res = value_act;
   1ee62:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
   1ee67:	49 89 45 00          	mov    %rax,0x0(%r13)
            return LV_RES_OK;
   1ee6b:	b0 01                	mov    $0x1,%al
   1ee6d:	eb 34                	jmp    1eea3 <_lv_style_list_get_ptr+0xc1>
        else if(list->has_trans && weight_act >= 0 && ci == 0 && !list->skip_trans) {
   1ee6f:	80 7d 08 00          	cmpb   $0x0,0x8(%rbp)
   1ee73:	79 11                	jns    1ee86 <_lv_style_list_get_ptr+0xa4>
   1ee75:	66 85 c0             	test   %ax,%ax
   1ee78:	78 0c                	js     1ee86 <_lv_style_list_get_ptr+0xa4>
   1ee7a:	66 45 85 e4          	test   %r12w,%r12w
   1ee7e:	75 06                	jne    1ee86 <_lv_style_list_get_ptr+0xa4>
   1ee80:	f6 45 09 01          	testb  $0x1,0x9(%rbp)
   1ee84:	74 dc                	je     1ee62 <_lv_style_list_get_ptr+0x80>
        else if(weight_act > weight) {
   1ee86:	66 39 c3             	cmp    %ax,%bx
   1ee89:	7d 0b                	jge    1ee96 <_lv_style_list_get_ptr+0xb4>
            *res = value_act;
   1ee8b:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
   1ee90:	89 c3                	mov    %eax,%ebx
   1ee92:	49 89 55 00          	mov    %rdx,0x0(%r13)
   1ee96:	41 ff c4             	inc    %r12d
   1ee99:	eb 97                	jmp    1ee32 <_lv_style_list_get_ptr+0x50>
    if(weight >= 0)  return LV_RES_OK;
   1ee9b:	89 d8                	mov    %ebx,%eax
   1ee9d:	f7 d0                	not    %eax
    if(list == NULL) return LV_RES_INV;
   1ee9f:	66 c1 e8 0f          	shr    $0xf,%ax
}
   1eea3:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   1eea8:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   1eeaf:	00 00 
   1eeb1:	74 05                	je     1eeb8 <_lv_style_list_get_ptr+0xd6>
   1eeb3:	e8 88 57 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1eeb8:	48 83 c4 28          	add    $0x28,%rsp
   1eebc:	5b                   	pop    %rbx
   1eebd:	5d                   	pop    %rbp
   1eebe:	41 5c                	pop    %r12
   1eec0:	41 5d                	pop    %r13
   1eec2:	41 5e                	pop    %r14
   1eec4:	41 5f                	pop    %r15
   1eec6:	c3                   	retq   

000000000001eec7 <lv_color_mix>:
LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
{
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   1eec7:	89 f9                	mov    %edi,%ecx
   1eec9:	0f b6 d2             	movzbl %dl,%edx
   1eecc:	41 b9 ff 00 00 00    	mov    $0xff,%r9d
   1eed2:	c1 e9 10             	shr    $0x10,%ecx
   1eed5:	41 29 d1             	sub    %edx,%r9d
   1eed8:	0f b6 c9             	movzbl %cl,%ecx
   1eedb:	89 c8                	mov    %ecx,%eax
   1eedd:	89 f1                	mov    %esi,%ecx
   1eedf:	c1 e9 10             	shr    $0x10,%ecx
   1eee2:	0f b6 c9             	movzbl %cl,%ecx
   1eee5:	0f af c2             	imul   %edx,%eax
   1eee8:	41 0f af c9          	imul   %r9d,%ecx
   1eeec:	01 c1                	add    %eax,%ecx
                                        (255 - mix) + LV_COLOR_MIX_ROUND_OFS));
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   1eeee:	89 f8                	mov    %edi,%eax
                                        (255 - mix) + LV_COLOR_MIX_ROUND_OFS));
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   1eef0:	40 0f b6 ff          	movzbl %dil,%edi
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   1eef4:	0f b6 c4             	movzbl %ah,%eax
   1eef7:	0f af c2             	imul   %edx,%eax
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   1eefa:	0f af d7             	imul   %edi,%edx
   1eefd:	40 0f b6 fe          	movzbl %sil,%edi
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   1ef01:	41 89 c0             	mov    %eax,%r8d
   1ef04:	89 f0                	mov    %esi,%eax
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   1ef06:	41 0f af f9          	imul   %r9d,%edi
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   1ef0a:	0f b6 c4             	movzbl %ah,%eax
   1ef0d:	41 0f af c1          	imul   %r9d,%eax
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   1ef11:	01 d7                	add    %edx,%edi
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
   1ef13:	31 d2                	xor    %edx,%edx
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   1ef15:	44 01 c0             	add    %r8d,%eax
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   1ef18:	69 ff 81 80 00 00    	imul   $0x8081,%edi,%edi
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   1ef1e:	69 c0 81 80 00 00    	imul   $0x8081,%eax,%eax
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   1ef24:	c1 ef 17             	shr    $0x17,%edi
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   1ef27:	69 c9 81 80 00 00    	imul   $0x8081,%ecx,%ecx
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   1ef2d:	c1 e8 17             	shr    $0x17,%eax
    return ret;
   1ef30:	40 88 fa             	mov    %dil,%dl
   1ef33:	88 c6                	mov    %al,%dh
   1ef35:	89 d0                	mov    %edx,%eax
   1ef37:	c1 e9 07             	shr    $0x7,%ecx
   1ef3a:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   1ef3f:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
   1ef45:	09 c8                	or     %ecx,%eax
   1ef47:	0d 00 00 00 ff       	or     $0xff000000,%eax
}
   1ef4c:	c3                   	retq   

000000000001ef4d <_lv_blend_fill>:
 * @param mode blend mode from `lv_blend_mode_t`
 */
LV_ATTRIBUTE_FAST_MEM void _lv_blend_fill(const lv_area_t * clip_area, const lv_area_t * fill_area,
                                          lv_color_t color, lv_opa_t * mask, lv_draw_mask_res_t mask_res, lv_opa_t opa,
                                          lv_blend_mode_t mode)
{
   1ef4d:	41 57                	push   %r15
   1ef4f:	41 56                	push   %r14
   1ef51:	41 55                	push   %r13
   1ef53:	41 54                	push   %r12
   1ef55:	55                   	push   %rbp
   1ef56:	53                   	push   %rbx
   1ef57:	48 83 ec 48          	sub    $0x48,%rsp
   1ef5b:	44 89 44 24 24       	mov    %r8d,0x24(%rsp)
   1ef60:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
   1ef65:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1ef6c:	00 00 
   1ef6e:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
   1ef73:	31 c0                	xor    %eax,%eax
    /*Do not draw transparent things*/
    if(opa < LV_OPA_MIN) return;
    if(mask_res == LV_DRAW_MASK_RES_TRANSP) return;
   1ef75:	80 7c 24 24 00       	cmpb   $0x0,0x24(%rsp)
{
   1ef7a:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
   1ef7f:	44 8b b4 24 80 00 00 	mov    0x80(%rsp),%r14d
   1ef86:	00 
   1ef87:	44 88 4c 24 28       	mov    %r9b,0x28(%rsp)
    if(mask_res == LV_DRAW_MASK_RES_TRANSP) return;
   1ef8c:	0f 84 6b 05 00 00    	je     1f4fd <_lv_blend_fill+0x5b0>
   1ef92:	41 80 f9 01          	cmp    $0x1,%r9b
   1ef96:	44 89 cd             	mov    %r9d,%ebp
   1ef99:	0f 86 5e 05 00 00    	jbe    1f4fd <_lv_blend_fill+0x5b0>
   1ef9f:	89 d3                	mov    %edx,%ebx
   1efa1:	49 89 cf             	mov    %rcx,%r15

    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
   1efa4:	e8 91 e7 ff ff       	callq  1d73a <_lv_refr_get_disp_refreshing>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   1efa9:	48 89 c7             	mov    %rax,%rdi
    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
   1efac:	49 89 c4             	mov    %rax,%r12
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   1efaf:	e8 4e 61 00 00       	callq  25102 <lv_disp_get_buf>
   1efb4:	49 89 c5             	mov    %rax,%r13
    const lv_area_t * disp_area = &vdb->area;
    lv_color_t * disp_buf = vdb->buf_act;
   1efb7:	48 8b 40 10          	mov    0x10(%rax),%rax
   1efbb:	48 89 44 24 10       	mov    %rax,0x10(%rsp)

    if(disp->driver.gpu_wait_cb) disp->driver.gpu_wait_cb(&disp->driver);
   1efc0:	49 8b 44 24 48       	mov    0x48(%r12),%rax
   1efc5:	48 85 c0             	test   %rax,%rax
   1efc8:	74 05                	je     1efcf <_lv_blend_fill+0x82>
   1efca:	4c 89 e7             	mov    %r12,%rdi
   1efcd:	ff d0                	callq  *%rax

    /* Get clipped fill area which is the real draw area.
     * It is always the same or inside `fill_area` */
    lv_area_t draw_area;
    bool is_common;
    is_common = _lv_area_intersect(&draw_area, clip_area, fill_area);
   1efcf:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
   1efd4:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   1efd9:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
   1efde:	e8 39 65 00 00       	callq  2551c <_lv_area_intersect>
    if(!is_common) return;
   1efe3:	84 c0                	test   %al,%al
   1efe5:	0f 84 12 05 00 00    	je     1f4fd <_lv_blend_fill+0x5b0>

    /* Now `draw_area` has absolute coordinates.
     * Make it relative to `disp_area` to simplify draw to `disp_buf`*/
    draw_area.x1 -= disp_area->x1;
   1efeb:	66 41 8b 4d 1c       	mov    0x1c(%r13),%cx
   1eff0:	8b 54 24 30          	mov    0x30(%rsp),%edx
    draw_area.y1 -= disp_area->y1;
    draw_area.x2 -= disp_area->x1;
   1eff4:	44 8b 5c 24 34       	mov    0x34(%rsp),%r11d
    draw_area.y1 -= disp_area->y1;
   1eff9:	66 41 8b 45 1e       	mov    0x1e(%r13),%ax
   1effe:	66 44 8b 54 24 32    	mov    0x32(%rsp),%r10w
    draw_area.x1 -= disp_area->x1;
   1f004:	29 ca                	sub    %ecx,%edx
    draw_area.x2 -= disp_area->x1;
   1f006:	41 29 cb             	sub    %ecx,%r11d
    draw_area.y2 -= disp_area->y1;
   1f009:	66 8b 4c 24 36       	mov    0x36(%rsp),%cx
    draw_area.x1 -= disp_area->x1;
   1f00e:	66 89 54 24 30       	mov    %dx,0x30(%rsp)
    draw_area.y1 -= disp_area->y1;
   1f013:	41 29 c2             	sub    %eax,%r10d
    draw_area.x2 -= disp_area->x1;
   1f016:	66 44 89 5c 24 34    	mov    %r11w,0x34(%rsp)
    draw_area.y1 -= disp_area->y1;
   1f01c:	66 44 89 54 24 32    	mov    %r10w,0x32(%rsp)
    draw_area.y2 -= disp_area->y1;
   1f022:	29 c1                	sub    %eax,%ecx

    /*Round the values in the mask if anti-aliasing is disabled*/
#if LV_ANTIALIAS
    if(mask && disp->driver.antialiasing == 0)
#else
    if(mask)
   1f024:	4d 85 ff             	test   %r15,%r15
    draw_area.y2 -= disp_area->y1;
   1f027:	66 89 4c 24 36       	mov    %cx,0x36(%rsp)
    if(mask)
   1f02c:	75 0d                	jne    1f03b <_lv_blend_fill+0xee>
        int32_t mask_w = lv_area_get_width(&draw_area);
        int32_t i;
        for(i = 0; i < mask_w; i++)  mask[i] = mask[i] > 128 ? LV_OPA_COVER : LV_OPA_TRANSP;
    }

    if(disp->driver.set_px_cb) {
   1f02e:	49 83 7c 24 28 00    	cmpq   $0x0,0x28(%r12)
   1f034:	75 28                	jne    1f05e <_lv_blend_fill+0x111>
   1f036:	e9 38 01 00 00       	jmpq   1f173 <_lv_blend_fill+0x226>
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1f03b:	41 8d 73 01          	lea    0x1(%r11),%esi
        for(i = 0; i < mask_w; i++)  mask[i] = mask[i] > 128 ? LV_OPA_COVER : LV_OPA_TRANSP;
   1f03f:	31 c0                	xor    %eax,%eax
   1f041:	29 d6                	sub    %edx,%esi
        int32_t mask_w = lv_area_get_width(&draw_area);
   1f043:	0f bf f6             	movswl %si,%esi
        for(i = 0; i < mask_w; i++)  mask[i] = mask[i] > 128 ? LV_OPA_COVER : LV_OPA_TRANSP;
   1f046:	39 c6                	cmp    %eax,%esi
   1f048:	7e e4                	jle    1f02e <_lv_blend_fill+0xe1>
   1f04a:	41 80 3c 07 80       	cmpb   $0x80,(%r15,%rax,1)
   1f04f:	40 0f 97 c7          	seta   %dil
   1f053:	f7 df                	neg    %edi
   1f055:	41 88 3c 07          	mov    %dil,(%r15,%rax,1)
   1f059:	48 ff c0             	inc    %rax
   1f05c:	eb e8                	jmp    1f046 <_lv_blend_fill+0xf9>
static void fill_set_px(const lv_area_t * disp_area, lv_color_t * disp_buf,  const lv_area_t * draw_area,
                        lv_color_t color, lv_opa_t opa,
                        const lv_opa_t * mask, lv_draw_mask_res_t mask_res)
{

    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
   1f05e:	e8 d7 e6 ff ff       	callq  1d73a <_lv_refr_get_disp_refreshing>
   1f063:	49 89 c6             	mov    %rax,%r14
   1f066:	66 41 8b 45 20       	mov    0x20(%r13),%ax
   1f06b:	44 8d 60 01          	lea    0x1(%rax),%r12d
   1f06f:	66 45 2b 65 1c       	sub    0x1c(%r13),%r12w
    int32_t disp_w = lv_area_get_width(disp_area);

    int32_t x;
    int32_t y;

    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
   1f074:	80 7c 24 24 01       	cmpb   $0x1,0x24(%rsp)
   1f079:	0f bf 44 24 32       	movswl 0x32(%rsp),%eax
    int32_t disp_w = lv_area_get_width(disp_area);
   1f07e:	45 0f bf e4          	movswl %r12w,%r12d
    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
   1f082:	75 4c                	jne    1f0d0 <_lv_blend_fill+0x183>
        fill_set_px(disp_area, disp_buf, &draw_area, color, opa, mask, mask_res);
   1f084:	44 0f b6 fd          	movzbl %bpl,%r15d
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
   1f088:	89 c5                	mov    %eax,%ebp
   1f08a:	0f bf 44 24 36       	movswl 0x36(%rsp),%eax
   1f08f:	39 c5                	cmp    %eax,%ebp
   1f091:	0f 8f 66 04 00 00    	jg     1f4fd <_lv_blend_fill+0x5b0>
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   1f097:	44 0f bf 6c 24 30    	movswl 0x30(%rsp),%r13d
   1f09d:	0f bf 44 24 34       	movswl 0x34(%rsp),%eax
   1f0a2:	41 39 c5             	cmp    %eax,%r13d
   1f0a5:	7f 25                	jg     1f0cc <_lv_blend_fill+0x17f>
                disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, color, opa);
   1f0a7:	48 83 ec 08          	sub    $0x8,%rsp
   1f0ab:	44 89 e9             	mov    %r13d,%ecx
   1f0ae:	41 89 d9             	mov    %ebx,%r9d
   1f0b1:	41 57                	push   %r15
   1f0b3:	41 89 e8             	mov    %ebp,%r8d
   1f0b6:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
   1f0bb:	44 89 e2             	mov    %r12d,%edx
   1f0be:	4c 89 f7             	mov    %r14,%rdi
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   1f0c1:	41 ff c5             	inc    %r13d
                disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, color, opa);
   1f0c4:	41 ff 56 28          	callq  *0x28(%r14)
   1f0c8:	59                   	pop    %rcx
   1f0c9:	5e                   	pop    %rsi
   1f0ca:	eb d1                	jmp    1f09d <_lv_blend_fill+0x150>
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
   1f0cc:	ff c5                	inc    %ebp
   1f0ce:	eb ba                	jmp    1f08a <_lv_blend_fill+0x13d>
    }
    else {
        /* The mask is relative to the clipped area.
         * In the cycles below mask will be indexed from `draw_area.x1`
         * but it corresponds to zero index. So prepare `mask_tmp` accordingly. */
        const lv_opa_t * mask_tmp = mask - draw_area->x1;
   1f0d0:	48 0f bf 54 24 30    	movswq 0x30(%rsp),%rdx
   1f0d6:	8b 7c 24 34          	mov    0x34(%rsp),%edi

        /*Get the width of the `draw_area` it will be used to go to the next line of the mask*/
        int32_t draw_area_w = lv_area_get_width(draw_area);

        for(y = draw_area->y1; y <= draw_area->y2; y++) {
   1f0da:	89 c5                	mov    %eax,%ebp
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
                if(mask_tmp[x]) {
                    disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, color,
                                           (uint32_t)((uint32_t)opa * mask_tmp[x]) >> 8);
   1f0dc:	0f b6 44 24 28       	movzbl 0x28(%rsp),%eax
        const lv_opa_t * mask_tmp = mask - draw_area->x1;
   1f0e1:	48 89 d1             	mov    %rdx,%rcx
   1f0e4:	49 29 d7             	sub    %rdx,%r15
   1f0e7:	8d 57 01             	lea    0x1(%rdi),%edx
                                           (uint32_t)((uint32_t)opa * mask_tmp[x]) >> 8);
   1f0ea:	89 44 24 18          	mov    %eax,0x18(%rsp)
   1f0ee:	29 ca                	sub    %ecx,%edx
   1f0f0:	66 89 54 24 08       	mov    %dx,0x8(%rsp)
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
   1f0f5:	0f bf 44 24 36       	movswl 0x36(%rsp),%eax
   1f0fa:	39 c5                	cmp    %eax,%ebp
   1f0fc:	0f 8f fb 03 00 00    	jg     1f4fd <_lv_blend_fill+0x5b0>
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   1f102:	44 0f bf 54 24 30    	movswl 0x30(%rsp),%r10d
   1f108:	45 31 ed             	xor    %r13d,%r13d
   1f10b:	44 89 d0             	mov    %r10d,%eax
   1f10e:	0f bf 54 24 34       	movswl 0x34(%rsp),%edx
   1f113:	43 8d 0c 2a          	lea    (%r10,%r13,1),%ecx
   1f117:	39 ca                	cmp    %ecx,%edx
   1f119:	7c 4b                	jl     1f166 <_lv_blend_fill+0x219>
                if(mask_tmp[x]) {
   1f11b:	48 0f bf d0          	movswq %ax,%rdx
   1f11f:	4c 01 fa             	add    %r15,%rdx
   1f122:	42 0f b6 14 2a       	movzbl (%rdx,%r13,1),%edx
   1f127:	84 d2                	test   %dl,%dl
   1f129:	74 36                	je     1f161 <_lv_blend_fill+0x214>
   1f12b:	44 89 54 24 28       	mov    %r10d,0x28(%rsp)
   1f130:	89 44 24 24          	mov    %eax,0x24(%rsp)
                    disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, color,
   1f134:	48 83 ec 08          	sub    $0x8,%rsp
                                           (uint32_t)((uint32_t)opa * mask_tmp[x]) >> 8);
   1f138:	0f af 54 24 20       	imul   0x20(%rsp),%edx
                    disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, color,
   1f13d:	41 89 d9             	mov    %ebx,%r9d
   1f140:	41 89 e8             	mov    %ebp,%r8d
   1f143:	4c 89 f7             	mov    %r14,%rdi
                                           (uint32_t)((uint32_t)opa * mask_tmp[x]) >> 8);
   1f146:	c1 ea 08             	shr    $0x8,%edx
                    disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, color,
   1f149:	52                   	push   %rdx
   1f14a:	44 89 e2             	mov    %r12d,%edx
   1f14d:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
   1f152:	41 ff 56 28          	callq  *0x28(%r14)
   1f156:	58                   	pop    %rax
   1f157:	5a                   	pop    %rdx
   1f158:	44 8b 54 24 28       	mov    0x28(%rsp),%r10d
   1f15d:	8b 44 24 24          	mov    0x24(%rsp),%eax
   1f161:	49 ff c5             	inc    %r13
   1f164:	eb a8                	jmp    1f10e <_lv_blend_fill+0x1c1>
                }
            }
            mask_tmp += draw_area_w;
   1f166:	48 0f bf 44 24 08    	movswq 0x8(%rsp),%rax
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
   1f16c:	ff c5                	inc    %ebp
            mask_tmp += draw_area_w;
   1f16e:	49 01 c7             	add    %rax,%r15
   1f171:	eb 82                	jmp    1f0f5 <_lv_blend_fill+0x1a8>
    else if(mode == LV_BLEND_MODE_NORMAL) {
   1f173:	45 84 f6             	test   %r14b,%r14b
   1f176:	0f 85 81 03 00 00    	jne    1f4fd <_lv_blend_fill+0x5b0>
   1f17c:	66 41 8b 45 20       	mov    0x20(%r13),%ax
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1f181:	ff c1                	inc    %ecx
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1f183:	41 ff c3             	inc    %r11d
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1f186:	44 29 d1             	sub    %r10d,%ecx

    int32_t draw_area_w = lv_area_get_width(draw_area);
    int32_t draw_area_h = lv_area_get_height(draw_area);

    /*Create a temp. disp_buf which always point to the first pixel of the destination area*/
    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;
   1f189:	45 0f bf d2          	movswl %r10w,%r10d
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1f18d:	41 29 d3             	sub    %edx,%r11d
    int32_t draw_area_h = lv_area_get_height(draw_area);
   1f190:	0f bf f9             	movswl %cx,%edi
    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;
   1f193:	48 0f bf d2          	movswq %dx,%rdx
    int32_t draw_area_w = lv_area_get_width(draw_area);
   1f197:	41 0f bf f3          	movswl %r11w,%esi
   1f19b:	ff c0                	inc    %eax
   1f19d:	66 41 2b 45 1c       	sub    0x1c(%r13),%ax
   1f1a2:	89 74 24 08          	mov    %esi,0x8(%rsp)
    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;
   1f1a6:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
    int32_t draw_area_h = lv_area_get_height(draw_area);
   1f1ab:	89 7c 24 18          	mov    %edi,0x18(%rsp)
    int32_t disp_w = lv_area_get_width(disp_area);
   1f1af:	0f bf c8             	movswl %ax,%ecx
   1f1b2:	48 0f bf c0          	movswq %ax,%rax
    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;
   1f1b6:	41 0f af ca          	imul   %r10d,%ecx
   1f1ba:	48 c1 e0 02          	shl    $0x2,%rax
   1f1be:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
   1f1c3:	48 63 c9             	movslq %ecx,%rcx
   1f1c6:	48 01 ca             	add    %rcx,%rdx

    int32_t x;
    int32_t y;

    /*Simple fill (maybe with opacity), no masking*/
    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
   1f1c9:	80 7c 24 24 01       	cmpb   $0x1,0x24(%rsp)
    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;
   1f1ce:	4c 8d 24 96          	lea    (%rsi,%rdx,4),%r12
    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
   1f1d2:	0f 85 f6 00 00 00    	jne    1f2ce <_lv_blend_fill+0x381>
                lv_gpu_stm32_dma2d_fill(disp_buf_first, disp_w, color, draw_area_w, draw_area_h);
                return;
            }
#endif
            /*Software rendering*/
            for(y = 0; y < draw_area_h; y++) {
   1f1d8:	45 31 ed             	xor    %r13d,%r13d
        if(opa > LV_OPA_MAX) {
   1f1db:	40 80 fd fd          	cmp    $0xfd,%bpl
   1f1df:	76 23                	jbe    1f204 <_lv_blend_fill+0x2b7>
            for(y = 0; y < draw_area_h; y++) {
   1f1e1:	44 39 6c 24 18       	cmp    %r13d,0x18(%rsp)
   1f1e6:	0f 8e 11 03 00 00    	jle    1f4fd <_lv_blend_fill+0x5b0>
                lv_color_fill(disp_buf_first, color, draw_area_w);
   1f1ec:	8b 54 24 08          	mov    0x8(%rsp),%edx
   1f1f0:	4c 89 e7             	mov    %r12,%rdi
   1f1f3:	89 de                	mov    %ebx,%esi
            for(y = 0; y < draw_area_h; y++) {
   1f1f5:	41 ff c5             	inc    %r13d
                lv_color_fill(disp_buf_first, color, draw_area_w);
   1f1f8:	e8 49 69 00 00       	callq  25b46 <lv_color_fill>
                disp_buf_first += disp_w;
   1f1fd:	4c 03 64 24 10       	add    0x10(%rsp),%r12
   1f202:	eb dd                	jmp    1f1e1 <_lv_blend_fill+0x294>
                }

                return;
            }
#endif
            lv_color_t last_dest_color = LV_COLOR_BLACK;
   1f204:	41 ba 00 00 00 ff    	mov    $0xff000000,%r10d
        fill_normal(disp_area, disp_buf, &draw_area, color, opa, mask, mask_res);
   1f20a:	40 0f b6 d5          	movzbl %bpl,%edx
            lv_color_t last_res_color = lv_color_mix(color, last_dest_color, opa);
   1f20e:	89 df                	mov    %ebx,%edi
   1f210:	44 89 d6             	mov    %r10d,%esi
   1f213:	e8 af fc ff ff       	callq  1eec7 <lv_color_mix>
   1f218:	89 c2                	mov    %eax,%edx
   1f21a:	88 c1                	mov    %al,%cl
   1f21c:	0f b6 f4             	movzbl %ah,%esi
   1f21f:	c1 e8 18             	shr    $0x18,%eax

LV_ATTRIBUTE_FAST_MEM static inline void lv_color_premult(lv_color_t c, uint8_t mix, uint16_t * out)
{
#if LV_COLOR_DEPTH != 1
    out[0] = (uint16_t) LV_COLOR_GET_R(c) * mix;
    out[1] = (uint16_t) LV_COLOR_GET_G(c) * mix;
   1f222:	0f b6 ff             	movzbl %bh,%edi
   1f225:	c1 ea 10             	shr    $0x10,%edx
   1f228:	41 89 c0             	mov    %eax,%r8d
    out[0] = (uint16_t) LV_COLOR_GET_R(c) * mix;
   1f22b:	89 d8                	mov    %ebx,%eax

            uint16_t color_premult[3];
            lv_color_premult(color, opa, color_premult);
            lv_opa_t opa_inv = 255 - opa;

            for(y = 0; y < draw_area_h; y++) {
   1f22d:	45 31 db             	xor    %r11d,%r11d
   1f230:	c1 e8 10             	shr    $0x10,%eax
   1f233:	40 f6 e5             	mul    %bpl
   1f236:	44 0f b7 f0          	movzwl %ax,%r14d
    out[1] = (uint16_t) LV_COLOR_GET_G(c) * mix;
   1f23a:	40 88 f8             	mov    %dil,%al
   1f23d:	40 f6 e5             	mul    %bpl
   1f240:	44 0f b7 e8          	movzwl %ax,%r13d
    out[2] = (uint16_t) LV_COLOR_GET_B(c) * mix;
   1f244:	88 d8                	mov    %bl,%al
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) premult_c1[0] + LV_COLOR_GET_R(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1f246:	b3 ff                	mov    $0xff,%bl
    out[2] = (uint16_t) LV_COLOR_GET_B(c) * mix;
   1f248:	40 f6 e5             	mul    %bpl
            lv_opa_t opa_inv = 255 - opa;
   1f24b:	f7 d5                	not    %ebp
                                                    &last_res_color.ch.alpha);
                        }
                        else
#endif
                        {
                            last_res_color = lv_color_mix_premult(color_premult, disp_buf_first[x], opa_inv);
   1f24d:	40 0f b6 ed          	movzbl %bpl,%ebp
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1f251:	0f b7 c0             	movzwl %ax,%eax
            for(y = 0; y < draw_area_h; y++) {
   1f254:	44 39 5c 24 18       	cmp    %r11d,0x18(%rsp)
   1f259:	0f 8e 9e 02 00 00    	jle    1f4fd <_lv_blend_fill+0x5b0>
   1f25f:	4c 89 e7             	mov    %r12,%rdi
                for(x = 0; x < draw_area_w; x++) {
   1f262:	45 31 c9             	xor    %r9d,%r9d
   1f265:	44 39 4c 24 08       	cmp    %r9d,0x8(%rsp)
   1f26a:	7e 58                	jle    1f2c4 <_lv_blend_fill+0x377>
                    if(last_dest_color.full != disp_buf_first[x].full) {
   1f26c:	44 3b 17             	cmp    (%rdi),%r10d
   1f26f:	74 3d                	je     1f2ae <_lv_blend_fill+0x361>
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) premult_c1[0] + LV_COLOR_GET_R(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1f271:	0f b6 57 02          	movzbl 0x2(%rdi),%edx
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1f275:	0f b6 77 01          	movzbl 0x1(%rdi),%esi
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1f279:	41 88 d8             	mov    %bl,%r8b
   1f27c:	0f b6 0f             	movzbl (%rdi),%ecx
                        last_dest_color = disp_buf_first[x];
   1f27f:	44 8b 17             	mov    (%rdi),%r10d
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) premult_c1[0] + LV_COLOR_GET_R(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1f282:	0f af d5             	imul   %ebp,%edx
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1f285:	0f af f5             	imul   %ebp,%esi
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) premult_c1[0] + LV_COLOR_GET_R(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1f288:	44 01 f2             	add    %r14d,%edx
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1f28b:	0f af cd             	imul   %ebp,%ecx
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1f28e:	44 01 ee             	add    %r13d,%esi
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) premult_c1[0] + LV_COLOR_GET_R(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1f291:	69 d2 81 80 00 00    	imul   $0x8081,%edx,%edx
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1f297:	01 c1                	add    %eax,%ecx
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1f299:	69 f6 81 80 00 00    	imul   $0x8081,%esi,%esi
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) premult_c1[0] + LV_COLOR_GET_R(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1f29f:	c1 ea 17             	shr    $0x17,%edx
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1f2a2:	69 c9 81 80 00 00    	imul   $0x8081,%ecx,%ecx
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1f2a8:	c1 ee 17             	shr    $0x17,%esi
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1f2ab:	c1 e9 17             	shr    $0x17,%ecx
                        }
                    }
                    disp_buf_first[x] = last_res_color;
   1f2ae:	88 0f                	mov    %cl,(%rdi)
   1f2b0:	40 88 77 01          	mov    %sil,0x1(%rdi)
                for(x = 0; x < draw_area_w; x++) {
   1f2b4:	41 ff c1             	inc    %r9d
                    disp_buf_first[x] = last_res_color;
   1f2b7:	88 57 02             	mov    %dl,0x2(%rdi)
   1f2ba:	44 88 47 03          	mov    %r8b,0x3(%rdi)
   1f2be:	48 83 c7 04          	add    $0x4,%rdi
   1f2c2:	eb a1                	jmp    1f265 <_lv_blend_fill+0x318>
                }
                disp_buf_first += disp_w;
   1f2c4:	4c 03 64 24 10       	add    0x10(%rsp),%r12
            for(y = 0; y < draw_area_h; y++) {
   1f2c9:	41 ff c3             	inc    %r11d
   1f2cc:	eb 86                	jmp    1f254 <_lv_blend_fill+0x307>
        last_res_color.full = disp_buf_first[0].full;

        int32_t x_end4 = draw_area_w - 4;

        /*Only the mask matters*/
        if(opa > LV_OPA_MAX) {
   1f2ce:	40 80 fd fd          	cmp    $0xfd,%bpl
   1f2d2:	77 14                	ja     1f2e8 <_lv_blend_fill+0x39b>
        last_dest_color.full = disp_buf_first[0].full;
   1f2d4:	41 8b 34 24          	mov    (%r12),%esi
                mask += draw_area_w;
            }
        }
        /*Handle opa and mask values too*/
        else {
            lv_opa_t opa_tmp = LV_OPA_TRANSP;
   1f2d8:	31 c9                	xor    %ecx,%ecx
        lv_opa_t last_mask = LV_OPA_TRANSP;
   1f2da:	31 ff                	xor    %edi,%edi
            for(y = draw_area->y1; y <= draw_area->y2; y++) {
                const lv_opa_t * mask_tmp_x = mask;
                for(x = 0; x < draw_area_w; x++) {
                    if(*mask_tmp_x) {
                        if(*mask_tmp_x != last_mask) opa_tmp = *mask_tmp_x == LV_OPA_COVER ? opa :
                                                                   (uint32_t)((uint32_t)(*mask_tmp_x) * opa) >> 8;
   1f2dc:	0f b6 6c 24 28       	movzbl 0x28(%rsp),%ebp
        last_res_color.full = disp_buf_first[0].full;
   1f2e1:	89 f0                	mov    %esi,%eax
   1f2e3:	e9 c4 01 00 00       	jmpq   1f4ac <_lv_blend_fill+0x55f>
        int32_t x_end4 = draw_area_w - 4;
   1f2e8:	41 0f bf c3          	movswl %r11w,%eax
            for(y = 0; y < draw_area_h; y++) {
   1f2ec:	31 ed                	xor    %ebp,%ebp
        int32_t x_end4 = draw_area_w - 4;
   1f2ee:	83 e8 04             	sub    $0x4,%eax
   1f2f1:	89 44 24 24          	mov    %eax,0x24(%rsp)
                mask += draw_area_w;
   1f2f5:	49 0f bf c3          	movswq %r11w,%rax
   1f2f9:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
            for(y = 0; y < draw_area_h; y++) {
   1f2fe:	39 6c 24 18          	cmp    %ebp,0x18(%rsp)
   1f302:	0f 8e f5 01 00 00    	jle    1f4fd <_lv_blend_fill+0x5b0>
   1f308:	4d 89 e2             	mov    %r12,%r10
                const lv_opa_t * mask_tmp_x = mask;
   1f30b:	4d 89 fe             	mov    %r15,%r14
   1f30e:	45 89 fd             	mov    %r15d,%r13d
                for(x = 0; x < draw_area_w && ((lv_uintptr_t)mask_tmp_x & 0x3); x++) {
   1f311:	44 89 f0             	mov    %r14d,%eax
   1f314:	44 29 f8             	sub    %r15d,%eax
   1f317:	39 44 24 08          	cmp    %eax,0x8(%rsp)
   1f31b:	7e 39                	jle    1f356 <_lv_blend_fill+0x409>
   1f31d:	41 f6 c6 03          	test   $0x3,%r14b
   1f321:	74 33                	je     1f356 <_lv_blend_fill+0x409>
                    FILL_NORMAL_MASK_PX(x, color)
   1f323:	41 0f b6 16          	movzbl (%r14),%edx
   1f327:	84 d2                	test   %dl,%dl
   1f329:	74 17                	je     1f342 <_lv_blend_fill+0x3f5>
   1f32b:	80 fa ff             	cmp    $0xff,%dl
   1f32e:	75 05                	jne    1f335 <_lv_blend_fill+0x3e8>
   1f330:	41 89 1a             	mov    %ebx,(%r10)
   1f333:	eb 0d                	jmp    1f342 <_lv_blend_fill+0x3f5>
   1f335:	41 8b 32             	mov    (%r10),%esi
   1f338:	89 df                	mov    %ebx,%edi
   1f33a:	e8 88 fb ff ff       	callq  1eec7 <lv_color_mix>
   1f33f:	41 89 02             	mov    %eax,(%r10)
   1f342:	49 ff c6             	inc    %r14
   1f345:	49 83 c2 04          	add    $0x4,%r10
   1f349:	eb c6                	jmp    1f311 <_lv_blend_fill+0x3c4>
                    if(*mask32) {
   1f34b:	41 8b 06             	mov    (%r14),%eax
   1f34e:	85 c0                	test   %eax,%eax
   1f350:	75 16                	jne    1f368 <_lv_blend_fill+0x41b>
                    mask32++;
   1f352:	49 83 c6 04          	add    $0x4,%r14
   1f356:	45 89 f2             	mov    %r14d,%r10d
   1f359:	45 29 ea             	sub    %r13d,%r10d
                for(; x <= x_end4; x += 4) {
   1f35c:	44 39 54 24 24       	cmp    %r10d,0x24(%rsp)
   1f361:	7d e8                	jge    1f34b <_lv_blend_fill+0x3fe>
   1f363:	e9 ce 00 00 00       	jmpq   1f436 <_lv_blend_fill+0x4e9>
                        if((*mask32) == 0xFFFFFFFF) {
   1f368:	ff c0                	inc    %eax
   1f36a:	75 20                	jne    1f38c <_lv_blend_fill+0x43f>
                            disp_buf_first[x] = color;
   1f36c:	4d 63 d2             	movslq %r10d,%r10
   1f36f:	4a 8d 04 95 00 00 00 	lea    0x0(,%r10,4),%rax
   1f376:	00 
   1f377:	43 89 1c 94          	mov    %ebx,(%r12,%r10,4)
                            disp_buf_first[x + 1] = color;
   1f37b:	41 89 5c 04 04       	mov    %ebx,0x4(%r12,%rax,1)
                            disp_buf_first[x + 2] = color;
   1f380:	41 89 5c 04 08       	mov    %ebx,0x8(%r12,%rax,1)
                            disp_buf_first[x + 3] = color;
   1f385:	41 89 5c 04 0c       	mov    %ebx,0xc(%r12,%rax,1)
   1f38a:	eb c6                	jmp    1f352 <_lv_blend_fill+0x405>
                            FILL_NORMAL_MASK_PX(x, color)
   1f38c:	41 0f b6 16          	movzbl (%r14),%edx
   1f390:	84 d2                	test   %dl,%dl
   1f392:	74 1e                	je     1f3b2 <_lv_blend_fill+0x465>
   1f394:	49 63 c2             	movslq %r10d,%rax
   1f397:	80 fa ff             	cmp    $0xff,%dl
   1f39a:	4d 8d 1c 84          	lea    (%r12,%rax,4),%r11
   1f39e:	75 05                	jne    1f3a5 <_lv_blend_fill+0x458>
   1f3a0:	41 89 1b             	mov    %ebx,(%r11)
   1f3a3:	eb 0d                	jmp    1f3b2 <_lv_blend_fill+0x465>
   1f3a5:	41 8b 33             	mov    (%r11),%esi
   1f3a8:	89 df                	mov    %ebx,%edi
   1f3aa:	e8 18 fb ff ff       	callq  1eec7 <lv_color_mix>
   1f3af:	41 89 03             	mov    %eax,(%r11)
                            FILL_NORMAL_MASK_PX(x + 1, color)
   1f3b2:	41 0f b6 56 01       	movzbl 0x1(%r14),%edx
   1f3b7:	84 d2                	test   %dl,%dl
   1f3b9:	74 1f                	je     1f3da <_lv_blend_fill+0x48d>
   1f3bb:	49 63 c2             	movslq %r10d,%rax
   1f3be:	80 fa ff             	cmp    $0xff,%dl
   1f3c1:	4d 8d 5c 84 04       	lea    0x4(%r12,%rax,4),%r11
   1f3c6:	75 05                	jne    1f3cd <_lv_blend_fill+0x480>
   1f3c8:	41 89 1b             	mov    %ebx,(%r11)
   1f3cb:	eb 0d                	jmp    1f3da <_lv_blend_fill+0x48d>
   1f3cd:	41 8b 33             	mov    (%r11),%esi
   1f3d0:	89 df                	mov    %ebx,%edi
   1f3d2:	e8 f0 fa ff ff       	callq  1eec7 <lv_color_mix>
   1f3d7:	41 89 03             	mov    %eax,(%r11)
                            FILL_NORMAL_MASK_PX(x + 2, color)
   1f3da:	41 0f b6 56 02       	movzbl 0x2(%r14),%edx
   1f3df:	84 d2                	test   %dl,%dl
   1f3e1:	74 1f                	je     1f402 <_lv_blend_fill+0x4b5>
   1f3e3:	49 63 c2             	movslq %r10d,%rax
   1f3e6:	80 fa ff             	cmp    $0xff,%dl
   1f3e9:	4d 8d 5c 84 08       	lea    0x8(%r12,%rax,4),%r11
   1f3ee:	75 05                	jne    1f3f5 <_lv_blend_fill+0x4a8>
   1f3f0:	41 89 1b             	mov    %ebx,(%r11)
   1f3f3:	eb 0d                	jmp    1f402 <_lv_blend_fill+0x4b5>
   1f3f5:	41 8b 33             	mov    (%r11),%esi
   1f3f8:	89 df                	mov    %ebx,%edi
   1f3fa:	e8 c8 fa ff ff       	callq  1eec7 <lv_color_mix>
   1f3ff:	41 89 03             	mov    %eax,(%r11)
                            FILL_NORMAL_MASK_PX(x + 3, color)
   1f402:	41 0f b6 56 03       	movzbl 0x3(%r14),%edx
   1f407:	84 d2                	test   %dl,%dl
   1f409:	0f 84 43 ff ff ff    	je     1f352 <_lv_blend_fill+0x405>
   1f40f:	4d 63 d2             	movslq %r10d,%r10
   1f412:	80 fa ff             	cmp    $0xff,%dl
   1f415:	4f 8d 54 94 0c       	lea    0xc(%r12,%r10,4),%r10
   1f41a:	75 08                	jne    1f424 <_lv_blend_fill+0x4d7>
   1f41c:	41 89 1a             	mov    %ebx,(%r10)
   1f41f:	e9 2e ff ff ff       	jmpq   1f352 <_lv_blend_fill+0x405>
   1f424:	41 8b 32             	mov    (%r10),%esi
   1f427:	89 df                	mov    %ebx,%edi
   1f429:	e8 99 fa ff ff       	callq  1eec7 <lv_color_mix>
   1f42e:	41 89 02             	mov    %eax,(%r10)
   1f431:	e9 1c ff ff ff       	jmpq   1f352 <_lv_blend_fill+0x405>
   1f436:	4d 63 d2             	movslq %r10d,%r10
   1f439:	4f 8d 14 94          	lea    (%r12,%r10,4),%r10
                for(; x < draw_area_w ; x++) {
   1f43d:	44 89 f0             	mov    %r14d,%eax
   1f440:	44 29 e8             	sub    %r13d,%eax
   1f443:	39 44 24 08          	cmp    %eax,0x8(%rsp)
   1f447:	7e 28                	jle    1f471 <_lv_blend_fill+0x524>
                    FILL_NORMAL_MASK_PX(x, color)
   1f449:	41 0f b6 16          	movzbl (%r14),%edx
   1f44d:	84 d2                	test   %dl,%dl
   1f44f:	74 17                	je     1f468 <_lv_blend_fill+0x51b>
   1f451:	80 fa ff             	cmp    $0xff,%dl
   1f454:	75 05                	jne    1f45b <_lv_blend_fill+0x50e>
   1f456:	41 89 1a             	mov    %ebx,(%r10)
   1f459:	eb 0d                	jmp    1f468 <_lv_blend_fill+0x51b>
   1f45b:	41 8b 32             	mov    (%r10),%esi
   1f45e:	89 df                	mov    %ebx,%edi
   1f460:	e8 62 fa ff ff       	callq  1eec7 <lv_color_mix>
   1f465:	41 89 02             	mov    %eax,(%r10)
   1f468:	49 ff c6             	inc    %r14
   1f46b:	49 83 c2 04          	add    $0x4,%r10
   1f46f:	eb cc                	jmp    1f43d <_lv_blend_fill+0x4f0>
                disp_buf_first += disp_w;
   1f471:	4c 03 64 24 10       	add    0x10(%rsp),%r12
                mask += draw_area_w;
   1f476:	4c 03 7c 24 28       	add    0x28(%rsp),%r15
            for(y = 0; y < draw_area_h; y++) {
   1f47b:	ff c5                	inc    %ebp
   1f47d:	e9 7c fe ff ff       	jmpq   1f2fe <_lv_blend_fill+0x3b1>
                    if(*mask_tmp_x) {
   1f482:	41 0f b6 16          	movzbl (%r14),%edx
   1f486:	84 d2                	test   %dl,%dl
   1f488:	75 34                	jne    1f4be <_lv_blend_fill+0x571>
                            last_mask = *mask_tmp_x;
                            last_dest_color.full = disp_buf_first[x].full;
                        }
                        disp_buf_first[x] = last_res_color;
                    }
                    mask_tmp_x++;
   1f48a:	49 ff c6             	inc    %r14
   1f48d:	49 83 c5 04          	add    $0x4,%r13
                for(x = 0; x < draw_area_w; x++) {
   1f491:	44 89 f2             	mov    %r14d,%edx
   1f494:	44 29 fa             	sub    %r15d,%edx
   1f497:	39 54 24 08          	cmp    %edx,0x8(%rsp)
   1f49b:	7f e5                	jg     1f482 <_lv_blend_fill+0x535>
                }
                disp_buf_first += disp_w;
   1f49d:	4c 03 64 24 10       	add    0x10(%rsp),%r12
                mask += draw_area_w;
   1f4a2:	49 0f bf d3          	movswq %r11w,%rdx
            for(y = draw_area->y1; y <= draw_area->y2; y++) {
   1f4a6:	41 ff c2             	inc    %r10d
                mask += draw_area_w;
   1f4a9:	49 01 d7             	add    %rdx,%r15
            for(y = draw_area->y1; y <= draw_area->y2; y++) {
   1f4ac:	0f bf 54 24 36       	movswl 0x36(%rsp),%edx
   1f4b1:	41 39 d2             	cmp    %edx,%r10d
   1f4b4:	7f 47                	jg     1f4fd <_lv_blend_fill+0x5b0>
   1f4b6:	4d 89 e5             	mov    %r12,%r13
                const lv_opa_t * mask_tmp_x = mask;
   1f4b9:	4d 89 fe             	mov    %r15,%r14
   1f4bc:	eb d3                	jmp    1f491 <_lv_blend_fill+0x544>
                        if(*mask_tmp_x != last_mask) opa_tmp = *mask_tmp_x == LV_OPA_COVER ? opa :
   1f4be:	40 38 fa             	cmp    %dil,%dl
   1f4c1:	74 32                	je     1f4f5 <_lv_blend_fill+0x5a8>
   1f4c3:	80 fa ff             	cmp    $0xff,%dl
   1f4c6:	8a 4c 24 28          	mov    0x28(%rsp),%cl
   1f4ca:	74 06                	je     1f4d2 <_lv_blend_fill+0x585>
                                                                   (uint32_t)((uint32_t)(*mask_tmp_x) * opa) >> 8;
   1f4cc:	0f af d5             	imul   %ebp,%edx
                        if(*mask_tmp_x != last_mask) opa_tmp = *mask_tmp_x == LV_OPA_COVER ? opa :
   1f4cf:	0f b6 ce             	movzbl %dh,%ecx
                                else last_res_color = lv_color_mix(color, disp_buf_first[x], opa_tmp);
   1f4d2:	41 8b 75 00          	mov    0x0(%r13),%esi
   1f4d6:	0f b6 d1             	movzbl %cl,%edx
   1f4d9:	89 df                	mov    %ebx,%edi
   1f4db:	88 4c 24 18          	mov    %cl,0x18(%rsp)
   1f4df:	e8 e3 f9 ff ff       	callq  1eec7 <lv_color_mix>
                            last_mask = *mask_tmp_x;
   1f4e4:	41 8a 3e             	mov    (%r14),%dil
                            last_dest_color.full = disp_buf_first[x].full;
   1f4e7:	41 8b 75 00          	mov    0x0(%r13),%esi
   1f4eb:	8a 4c 24 18          	mov    0x18(%rsp),%cl
                        disp_buf_first[x] = last_res_color;
   1f4ef:	41 89 45 00          	mov    %eax,0x0(%r13)
   1f4f3:	eb 95                	jmp    1f48a <_lv_blend_fill+0x53d>
                        if(*mask_tmp_x != last_mask || last_dest_color.full != disp_buf_first[x].full) {
   1f4f5:	41 39 75 00          	cmp    %esi,0x0(%r13)
   1f4f9:	75 d7                	jne    1f4d2 <_lv_blend_fill+0x585>
   1f4fb:	eb f2                	jmp    1f4ef <_lv_blend_fill+0x5a2>
}
   1f4fd:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
   1f502:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1f509:	00 00 
   1f50b:	74 05                	je     1f512 <_lv_blend_fill+0x5c5>
   1f50d:	e8 2e 51 fe ff       	callq  4640 <__stack_chk_fail@plt>
   1f512:	48 83 c4 48          	add    $0x48,%rsp
   1f516:	5b                   	pop    %rbx
   1f517:	5d                   	pop    %rbp
   1f518:	41 5c                	pop    %r12
   1f51a:	41 5d                	pop    %r13
   1f51c:	41 5e                	pop    %r14
   1f51e:	41 5f                	pop    %r15
   1f520:	c3                   	retq   

000000000001f521 <_lv_blend_map>:
{
   1f521:	41 57                	push   %r15
   1f523:	41 56                	push   %r14
   1f525:	48 89 f8             	mov    %rdi,%rax
   1f528:	41 55                	push   %r13
   1f52a:	41 54                	push   %r12
   1f52c:	55                   	push   %rbp
   1f52d:	53                   	push   %rbx
   1f52e:	48 83 ec 68          	sub    $0x68,%rsp
   1f532:	44 89 44 24 20       	mov    %r8d,0x20(%rsp)
   1f537:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
   1f53c:	64 48 8b 3c 25 28 00 	mov    %fs:0x28,%rdi
   1f543:	00 00 
   1f545:	48 89 7c 24 58       	mov    %rdi,0x58(%rsp)
   1f54a:	31 ff                	xor    %edi,%edi
    if(mask_res == LV_DRAW_MASK_RES_TRANSP) return;
   1f54c:	80 7c 24 20 00       	cmpb   $0x0,0x20(%rsp)
{
   1f551:	8b ac 24 a0 00 00 00 	mov    0xa0(%rsp),%ebp
   1f558:	44 88 4c 24 30       	mov    %r9b,0x30(%rsp)
    if(mask_res == LV_DRAW_MASK_RES_TRANSP) return;
   1f55d:	0f 84 27 06 00 00    	je     1fb8a <_lv_blend_map+0x669>
   1f563:	41 80 f9 01          	cmp    $0x1,%r9b
   1f567:	45 89 ce             	mov    %r9d,%r14d
   1f56a:	0f 86 1a 06 00 00    	jbe    1fb8a <_lv_blend_map+0x669>
    is_common = _lv_area_intersect(&draw_area, clip_area, map_area);
   1f570:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
   1f575:	48 89 f2             	mov    %rsi,%rdx
   1f578:	49 89 f7             	mov    %rsi,%r15
   1f57b:	48 89 c6             	mov    %rax,%rsi
   1f57e:	48 89 cb             	mov    %rcx,%rbx
   1f581:	e8 96 5f 00 00       	callq  2551c <_lv_area_intersect>
    if(!is_common) return;
   1f586:	84 c0                	test   %al,%al
   1f588:	0f 84 fc 05 00 00    	je     1fb8a <_lv_blend_map+0x669>
    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
   1f58e:	e8 a7 e1 ff ff       	callq  1d73a <_lv_refr_get_disp_refreshing>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   1f593:	48 89 c7             	mov    %rax,%rdi
    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
   1f596:	49 89 c4             	mov    %rax,%r12
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   1f599:	e8 64 5b 00 00       	callq  25102 <lv_disp_get_buf>
   1f59e:	49 89 c5             	mov    %rax,%r13
    lv_color_t * disp_buf = vdb->buf_act;
   1f5a1:	48 8b 40 10          	mov    0x10(%rax),%rax
   1f5a5:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    if(disp->driver.gpu_wait_cb) disp->driver.gpu_wait_cb(&disp->driver);
   1f5aa:	49 8b 44 24 48       	mov    0x48(%r12),%rax
   1f5af:	48 85 c0             	test   %rax,%rax
   1f5b2:	74 05                	je     1f5b9 <_lv_blend_map+0x98>
   1f5b4:	4c 89 e7             	mov    %r12,%rdi
   1f5b7:	ff d0                	callq  *%rax
    draw_area.x1 -= disp_area->x1;
   1f5b9:	66 41 8b 45 1c       	mov    0x1c(%r13),%ax
    draw_area.x2 -= disp_area->x1;
   1f5be:	8b 74 24 54          	mov    0x54(%rsp),%esi
    draw_area.x1 -= disp_area->x1;
   1f5c2:	8b 4c 24 50          	mov    0x50(%rsp),%ecx
    draw_area.y1 -= disp_area->y1;
   1f5c6:	66 41 8b 7d 1e       	mov    0x1e(%r13),%di
   1f5cb:	66 8b 54 24 52       	mov    0x52(%rsp),%dx
    draw_area.x2 -= disp_area->x1;
   1f5d0:	29 c6                	sub    %eax,%esi
    draw_area.x1 -= disp_area->x1;
   1f5d2:	29 c1                	sub    %eax,%ecx
    draw_area.x2 -= disp_area->x1;
   1f5d4:	66 89 74 24 54       	mov    %si,0x54(%rsp)
   1f5d9:	89 f0                	mov    %esi,%eax
    draw_area.y2 -= disp_area->y1;
   1f5db:	66 8b 74 24 56       	mov    0x56(%rsp),%si
    draw_area.y1 -= disp_area->y1;
   1f5e0:	29 fa                	sub    %edi,%edx
    draw_area.x1 -= disp_area->x1;
   1f5e2:	66 89 4c 24 50       	mov    %cx,0x50(%rsp)
    draw_area.y1 -= disp_area->y1;
   1f5e7:	66 89 54 24 52       	mov    %dx,0x52(%rsp)
    draw_area.y2 -= disp_area->y1;
   1f5ec:	29 fe                	sub    %edi,%esi
    if(mask)
   1f5ee:	48 85 db             	test   %rbx,%rbx
    draw_area.y2 -= disp_area->y1;
   1f5f1:	89 f7                	mov    %esi,%edi
   1f5f3:	66 89 74 24 56       	mov    %si,0x56(%rsp)
    if(mask)
   1f5f8:	75 0d                	jne    1f607 <_lv_blend_map+0xe6>
    if(disp->driver.set_px_cb) {
   1f5fa:	49 83 7c 24 28 00    	cmpq   $0x0,0x28(%r12)
   1f600:	75 2d                	jne    1f62f <_lv_blend_map+0x10e>
   1f602:	e9 b6 01 00 00       	jmpq   1f7bd <_lv_blend_map+0x29c>
   1f607:	44 8d 48 01          	lea    0x1(%rax),%r9d
        for(i = 0; i < mask_w; i++)  mask[i] = mask[i] > 128 ? LV_OPA_COVER : LV_OPA_TRANSP;
   1f60b:	45 31 c0             	xor    %r8d,%r8d
   1f60e:	41 29 c9             	sub    %ecx,%r9d
        int32_t mask_w = lv_area_get_width(&draw_area);
   1f611:	45 0f bf c9          	movswl %r9w,%r9d
        for(i = 0; i < mask_w; i++)  mask[i] = mask[i] > 128 ? LV_OPA_COVER : LV_OPA_TRANSP;
   1f615:	45 39 c1             	cmp    %r8d,%r9d
   1f618:	7e e0                	jle    1f5fa <_lv_blend_map+0xd9>
   1f61a:	42 80 3c 03 80       	cmpb   $0x80,(%rbx,%r8,1)
   1f61f:	41 0f 97 c2          	seta   %r10b
   1f623:	41 f7 da             	neg    %r10d
   1f626:	46 88 14 03          	mov    %r10b,(%rbx,%r8,1)
   1f62a:	49 ff c0             	inc    %r8
   1f62d:	eb e6                	jmp    1f615 <_lv_blend_map+0xf4>
static void map_set_px(const lv_area_t * disp_area, lv_color_t * disp_buf,  const lv_area_t * draw_area,
                       const lv_area_t * map_area, const lv_color_t * map_buf, lv_opa_t opa,
                       const lv_opa_t * mask, lv_draw_mask_res_t mask_res)

{
    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
   1f62f:	e8 06 e1 ff ff       	callq  1d73a <_lv_refr_get_disp_refreshing>
   1f634:	66 41 8b 7d 20       	mov    0x20(%r13),%di

    /*Get the width of the `disp_area` it will be used to go to the next line*/
    int32_t disp_w = lv_area_get_width(disp_area);
   1f639:	45 0f bf 45 1c       	movswl 0x1c(%r13),%r8d

    /*Get the width of the `mask_area` it will be used to go to the next line*/
    int32_t map_w = lv_area_get_width(map_area);

    /*Create a temp. map_buf which always point to current line to draw*/
    const lv_color_t * map_buf_tmp = map_buf + map_w * (draw_area->y1 - (map_area->y1 - disp_area->y1));
   1f63e:	41 0f bf 75 1e       	movswl 0x1e(%r13),%esi
   1f643:	66 41 8b 4f 04       	mov    0x4(%r15),%cx
   1f648:	44 0f bf 64 24 52    	movswl 0x52(%rsp),%r12d
   1f64e:	45 0f bf 4f 02       	movswl 0x2(%r15),%r9d
   1f653:	8d 57 01             	lea    0x1(%rdi),%edx
   1f656:	8d 69 01             	lea    0x1(%rcx),%ebp
   1f659:	44 29 c2             	sub    %r8d,%edx
    int32_t disp_w = lv_area_get_width(disp_area);
   1f65c:	0f bf fa             	movswl %dx,%edi
    const lv_color_t * map_buf_tmp = map_buf + map_w * (draw_area->y1 - (map_area->y1 - disp_area->y1));
   1f65f:	41 29 f1             	sub    %esi,%r9d
   1f662:	45 89 e3             	mov    %r12d,%r11d
    int32_t disp_w = lv_area_get_width(disp_area);
   1f665:	89 7c 24 0c          	mov    %edi,0xc(%rsp)
    int32_t map_w = lv_area_get_width(map_area);
   1f669:	41 0f bf 3f          	movswl (%r15),%edi
    const lv_color_t * map_buf_tmp = map_buf + map_w * (draw_area->y1 - (map_area->y1 - disp_area->y1));
   1f66d:	45 29 cb             	sub    %r9d,%r11d
   1f670:	44 89 de             	mov    %r11d,%esi
    int32_t draw_area_w = lv_area_get_width(draw_area);
   1f673:	8b 54 24 50          	mov    0x50(%rsp),%edx
   1f677:	29 fd                	sub    %edi,%ebp

    map_buf_tmp += (draw_area->x1 - (map_area->x1 - disp_area->x1));
   1f679:	44 29 c7             	sub    %r8d,%edi
    map_buf_tmp -= draw_area->x1;
   1f67c:	48 0f bf ca          	movswq %dx,%rcx
    int32_t map_w = lv_area_get_width(map_area);
   1f680:	44 0f bf cd          	movswl %bp,%r9d
   1f684:	48 0f bf ed          	movswq %bp,%rbp
    const lv_color_t * map_buf_tmp = map_buf + map_w * (draw_area->y1 - (map_area->y1 - disp_area->y1));
   1f688:	41 0f af f1          	imul   %r9d,%esi
   1f68c:	4c 63 ce             	movslq %esi,%r9
    map_buf_tmp += (draw_area->x1 - (map_area->x1 - disp_area->x1));
   1f68f:	0f bf f2             	movswl %dx,%esi
   1f692:	29 fe                	sub    %edi,%esi
    map_buf_tmp -= draw_area->x1;
   1f694:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
    map_buf_tmp += (draw_area->x1 - (map_area->x1 - disp_area->x1));
   1f699:	48 63 f6             	movslq %esi,%rsi
    map_buf_tmp -= draw_area->x1;
   1f69c:	4c 01 ce             	add    %r9,%rsi
   1f69f:	48 29 ce             	sub    %rcx,%rsi
    int32_t x;
    int32_t y;

    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
   1f6a2:	80 7c 24 20 01       	cmpb   $0x1,0x20(%rsp)
    map_buf_tmp -= draw_area->x1;
   1f6a7:	4c 8d 2c b7          	lea    (%rdi,%rsi,4),%r13
    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
   1f6ab:	75 63                	jne    1f710 <_lv_blend_map+0x1ef>
        map_set_px(disp_area, disp_buf, &draw_area, map_area, map_buf, opa, mask, mask_res);
   1f6ad:	45 0f b6 f6          	movzbl %r14b,%r14d
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
                disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, map_buf_tmp[x], opa);
            }
            map_buf_tmp += map_w;
   1f6b1:	48 c1 e5 02          	shl    $0x2,%rbp
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
   1f6b5:	0f bf 54 24 56       	movswl 0x56(%rsp),%edx
   1f6ba:	41 39 d4             	cmp    %edx,%r12d
   1f6bd:	0f 8f c7 04 00 00    	jg     1fb8a <_lv_blend_map+0x669>
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   1f6c3:	48 0f bf 5c 24 50    	movswq 0x50(%rsp),%rbx
   1f6c9:	4d 8d 7c 9d 00       	lea    0x0(%r13,%rbx,4),%r15
   1f6ce:	0f bf 54 24 54       	movswl 0x54(%rsp),%edx
   1f6d3:	39 d3                	cmp    %edx,%ebx
   1f6d5:	7f 31                	jg     1f708 <_lv_blend_map+0x1e7>
                disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, map_buf_tmp[x], opa);
   1f6d7:	48 83 ec 08          	sub    $0x8,%rsp
   1f6db:	89 d9                	mov    %ebx,%ecx
   1f6dd:	48 89 c7             	mov    %rax,%rdi
   1f6e0:	41 56                	push   %r14
   1f6e2:	45 89 e0             	mov    %r12d,%r8d
   1f6e5:	8b 54 24 1c          	mov    0x1c(%rsp),%edx
   1f6e9:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
   1f6ee:	45 8b 0f             	mov    (%r15),%r9d
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   1f6f1:	ff c3                	inc    %ebx
                disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, map_buf_tmp[x], opa);
   1f6f3:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
   1f6f8:	49 83 c7 04          	add    $0x4,%r15
   1f6fc:	ff 50 28             	callq  *0x28(%rax)
   1f6ff:	59                   	pop    %rcx
   1f700:	5e                   	pop    %rsi
   1f701:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
   1f706:	eb c6                	jmp    1f6ce <_lv_blend_map+0x1ad>
            map_buf_tmp += map_w;
   1f708:	49 01 ed             	add    %rbp,%r13
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
   1f70b:	41 ff c4             	inc    %r12d
   1f70e:	eb a5                	jmp    1f6b5 <_lv_blend_map+0x194>
   1f710:	8b 7c 24 54          	mov    0x54(%rsp),%edi
    }
    else {
        /* The mask is relative to the clipped area.
         * In the cycles below mask will be indexed from `draw_area.x1`
         * but it corresponds to zero index. So prepare `mask_tmp` accordingly. */
        const lv_opa_t * mask_tmp = mask - draw_area->x1;
   1f714:	48 29 cb             	sub    %rcx,%rbx
                    disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, map_buf_tmp[x],
                                           (uint32_t)((uint32_t)opa * mask_tmp[x]) >> 8);
                }
            }
            mask_tmp += draw_area_w;
            map_buf_tmp += map_w;
   1f717:	48 8d 0c ad 00 00 00 	lea    0x0(,%rbp,4),%rcx
   1f71e:	00 
   1f71f:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
   1f724:	8d 77 01             	lea    0x1(%rdi),%esi
   1f727:	29 d6                	sub    %edx,%esi
   1f729:	66 89 74 24 18       	mov    %si,0x18(%rsp)
                                           (uint32_t)((uint32_t)opa * mask_tmp[x]) >> 8);
   1f72e:	0f b6 74 24 30       	movzbl 0x30(%rsp),%esi
   1f733:	89 74 24 28          	mov    %esi,0x28(%rsp)
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
   1f737:	0f bf 54 24 56       	movswl 0x56(%rsp),%edx
   1f73c:	41 39 d4             	cmp    %edx,%r12d
   1f73f:	0f 8f 45 04 00 00    	jg     1fb8a <_lv_blend_map+0x669>
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   1f745:	0f bf 6c 24 50       	movswl 0x50(%rsp),%ebp
   1f74a:	45 31 f6             	xor    %r14d,%r14d
   1f74d:	41 89 ef             	mov    %ebp,%r15d
   1f750:	0f bf 54 24 54       	movswl 0x54(%rsp),%edx
   1f755:	42 8d 4c 35 00       	lea    0x0(%rbp,%r14,1),%ecx
   1f75a:	39 ca                	cmp    %ecx,%edx
   1f75c:	7c 49                	jl     1f7a7 <_lv_blend_map+0x286>
   1f75e:	49 0f bf f7          	movswq %r15w,%rsi
                if(mask_tmp[x]) {
   1f762:	48 8d 14 33          	lea    (%rbx,%rsi,1),%rdx
   1f766:	42 0f b6 14 32       	movzbl (%rdx,%r14,1),%edx
   1f76b:	84 d2                	test   %dl,%dl
   1f76d:	74 33                	je     1f7a2 <_lv_blend_map+0x281>
                    disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, map_buf_tmp[x],
   1f76f:	48 83 ec 08          	sub    $0x8,%rsp
   1f773:	4c 01 f6             	add    %r14,%rsi
   1f776:	48 89 c7             	mov    %rax,%rdi
                                           (uint32_t)((uint32_t)opa * mask_tmp[x]) >> 8);
   1f779:	0f af 54 24 30       	imul   0x30(%rsp),%edx
                    disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, map_buf_tmp[x],
   1f77e:	45 89 e0             	mov    %r12d,%r8d
                                           (uint32_t)((uint32_t)opa * mask_tmp[x]) >> 8);
   1f781:	c1 ea 08             	shr    $0x8,%edx
                    disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, map_buf_tmp[x],
   1f784:	52                   	push   %rdx
   1f785:	8b 54 24 1c          	mov    0x1c(%rsp),%edx
   1f789:	45 8b 4c b5 00       	mov    0x0(%r13,%rsi,4),%r9d
   1f78e:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
   1f793:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
   1f798:	ff 50 28             	callq  *0x28(%rax)
   1f79b:	58                   	pop    %rax
   1f79c:	5a                   	pop    %rdx
   1f79d:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
   1f7a2:	49 ff c6             	inc    %r14
   1f7a5:	eb a9                	jmp    1f750 <_lv_blend_map+0x22f>
            mask_tmp += draw_area_w;
   1f7a7:	48 0f bf 54 24 18    	movswq 0x18(%rsp),%rdx
            map_buf_tmp += map_w;
   1f7ad:	4c 03 6c 24 20       	add    0x20(%rsp),%r13
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
   1f7b2:	41 ff c4             	inc    %r12d
            mask_tmp += draw_area_w;
   1f7b5:	48 01 d3             	add    %rdx,%rbx
   1f7b8:	e9 7a ff ff ff       	jmpq   1f737 <_lv_blend_map+0x216>
    else if(mode == LV_BLEND_MODE_NORMAL) {
   1f7bd:	40 84 ed             	test   %bpl,%bpl
   1f7c0:	0f 85 c4 03 00 00    	jne    1fb8a <_lv_blend_map+0x669>
   1f7c6:	66 41 8b 75 20       	mov    0x20(%r13),%si
                                             const lv_area_t * map_area, const lv_color_t * map_buf, lv_opa_t opa,
                                             const lv_opa_t * mask, lv_draw_mask_res_t mask_res)
{

    /*Get the width of the `disp_area` it will be used to go to the next line*/
    int32_t disp_w = lv_area_get_width(disp_area);
   1f7cb:	45 0f bf 45 1c       	movswl 0x1c(%r13),%r8d
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1f7d0:	ff c7                	inc    %edi
   1f7d2:	29 d7                	sub    %edx,%edi

    /*Get the width of the `mask_area` it will be used to go to the next line*/
    int32_t map_w = lv_area_get_width(map_area);

    /*Create a temp. disp_buf which always point to first pixel to draw*/
    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;
   1f7d4:	0f bf d2             	movswl %dx,%edx
   1f7d7:	4c 0f bf d9          	movswq %cx,%r11
    int32_t draw_area_h = lv_area_get_height(draw_area);
   1f7db:	0f bf ff             	movswl %di,%edi
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1f7de:	ff c0                	inc    %eax
        map_normal(disp_area, disp_buf, &draw_area, map_area, map_buf, opa, mask, mask_res);
   1f7e0:	41 0f b6 ee          	movzbl %r14b,%ebp
   1f7e4:	44 8d 4e 01          	lea    0x1(%rsi),%r9d
   1f7e8:	66 41 8b 77 04       	mov    0x4(%r15),%si
    int32_t draw_area_h = lv_area_get_height(draw_area);
   1f7ed:	89 7c 24 0c          	mov    %edi,0xc(%rsp)
   1f7f1:	29 c8                	sub    %ecx,%eax

    /*Create a temp. map_buf which always point to first pixel to draw from the map*/
    const lv_color_t * map_buf_first = map_buf + map_w * (draw_area->y1 - (map_area->y1 - disp_area->y1));
    map_buf_first += (draw_area->x1 - (map_area->x1 - disp_area->x1));
   1f7f3:	0f bf c9             	movswl %cx,%ecx
   1f7f6:	45 29 c1             	sub    %r8d,%r9d
    int32_t draw_area_w = lv_area_get_width(draw_area);
   1f7f9:	44 0f bf e0          	movswl %ax,%r12d
   1f7fd:	66 44 89 4c 24 18    	mov    %r9w,0x18(%rsp)
    int32_t disp_w = lv_area_get_width(disp_area);
   1f803:	44 0f bf 54 24 18    	movswl 0x18(%rsp),%r10d
   1f809:	8d 7e 01             	lea    0x1(%rsi),%edi
    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;
   1f80c:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
    int32_t map_w = lv_area_get_width(map_area);
   1f811:	45 0f bf 0f          	movswl (%r15),%r9d
    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;
   1f815:	44 0f af d2          	imul   %edx,%r10d
   1f819:	44 29 cf             	sub    %r9d,%edi
    map_buf_first += (draw_area->x1 - (map_area->x1 - disp_area->x1));
   1f81c:	45 29 c1             	sub    %r8d,%r9d
   1f81f:	44 29 c9             	sub    %r9d,%ecx
    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;
   1f822:	4d 63 d2             	movslq %r10d,%r10
    map_buf_first += (draw_area->x1 - (map_area->x1 - disp_area->x1));
   1f825:	48 63 c9             	movslq %ecx,%rcx
    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;
   1f828:	4d 01 da             	add    %r11,%r10
    const lv_color_t * map_buf_first = map_buf + map_w * (draw_area->y1 - (map_area->y1 - disp_area->y1));
   1f82b:	45 0f bf 5f 02       	movswl 0x2(%r15),%r11d
    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;
   1f830:	4e 8d 14 96          	lea    (%rsi,%r10,4),%r10
    const lv_color_t * map_buf_first = map_buf + map_w * (draw_area->y1 - (map_area->y1 - disp_area->y1));
   1f834:	41 0f bf 75 1e       	movswl 0x1e(%r13),%esi
   1f839:	41 29 f3             	sub    %esi,%r11d
    int32_t map_w = lv_area_get_width(map_area);
   1f83c:	0f bf f7             	movswl %di,%esi
   1f83f:	48 0f bf ff          	movswq %di,%rdi
    const lv_color_t * map_buf_first = map_buf + map_w * (draw_area->y1 - (map_area->y1 - disp_area->y1));
   1f843:	44 29 da             	sub    %r11d,%edx
   1f846:	48 c1 e7 02          	shl    $0x2,%rdi
   1f84a:	0f af d6             	imul   %esi,%edx
   1f84d:	48 63 d2             	movslq %edx,%rdx
    map_buf_first += (draw_area->x1 - (map_area->x1 - disp_area->x1));
   1f850:	48 01 ca             	add    %rcx,%rdx
   1f853:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx

    int32_t x;
    int32_t y;

    /*Simple fill (maybe with opacity), no masking*/
    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
   1f858:	80 7c 24 20 01       	cmpb   $0x1,0x20(%rsp)
    map_buf_first += (draw_area->x1 - (map_area->x1 - disp_area->x1));
   1f85d:	4c 8d 1c 91          	lea    (%rcx,%rdx,4),%r11
   1f861:	48 0f bf 54 24 18    	movswq 0x18(%rsp),%rdx
   1f867:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
   1f86c:	48 8d 0c 95 00 00 00 	lea    0x0(,%rdx,4),%rcx
   1f873:	00 
   1f874:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
   1f879:	75 71                	jne    1f8ec <_lv_blend_map+0x3cb>
            }
            return;
        }
#endif

        if(opa > LV_OPA_MAX) {
   1f87b:	41 80 fe fd          	cmp    $0xfd,%r14b
   1f87f:	76 2d                	jbe    1f8ae <_lv_blend_map+0x38d>
            }
#endif

            /*Software rendering*/
            for(y = 0; y < draw_area_h; y++) {
                _lv_memcpy(disp_buf_first, map_buf_first, draw_area_w * sizeof(lv_color_t));
   1f881:	48 0f bf c0          	movswq %ax,%rax
            for(y = 0; y < draw_area_h; y++) {
   1f885:	31 d2                	xor    %edx,%edx
                _lv_memcpy(disp_buf_first, map_buf_first, draw_area_w * sizeof(lv_color_t));
   1f887:	48 c1 e0 02          	shl    $0x2,%rax
            for(y = 0; y < draw_area_h; y++) {
   1f88b:	39 54 24 0c          	cmp    %edx,0xc(%rsp)
   1f88f:	0f 8e f5 02 00 00    	jle    1fb8a <_lv_blend_map+0x669>
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
   1f895:	4c 89 d7             	mov    %r10,%rdi
   1f898:	4c 89 de             	mov    %r11,%rsi
   1f89b:	48 89 c1             	mov    %rax,%rcx
                disp_buf_first += disp_w;
   1f89e:	4c 03 54 24 10       	add    0x10(%rsp),%r10
                map_buf_first += map_w;
   1f8a3:	4c 03 5c 24 18       	add    0x18(%rsp),%r11
            for(y = 0; y < draw_area_h; y++) {
   1f8a8:	ff c2                	inc    %edx
   1f8aa:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
   1f8ac:	eb dd                	jmp    1f88b <_lv_blend_map+0x36a>
            }
#endif

            /*Software rendering*/

            for(y = 0; y < draw_area_h; y++) {
   1f8ae:	45 31 ed             	xor    %r13d,%r13d
   1f8b1:	44 39 6c 24 0c       	cmp    %r13d,0xc(%rsp)
   1f8b6:	0f 8e ce 02 00 00    	jle    1fb8a <_lv_blend_map+0x669>
   1f8bc:	31 db                	xor    %ebx,%ebx
                for(x = 0; x < draw_area_w; x++) {
   1f8be:	41 39 dc             	cmp    %ebx,%r12d
   1f8c1:	7e 1a                	jle    1f8dd <_lv_blend_map+0x3bc>
   1f8c3:	4d 8d 34 9a          	lea    (%r10,%rbx,4),%r14
                                                &disp_buf_first[x].ch.alpha);
                    }
                    else
#endif
                    {
                        disp_buf_first[x] = lv_color_mix(map_buf_first[x], disp_buf_first[x], opa);
   1f8c7:	41 8b 3c 9b          	mov    (%r11,%rbx,4),%edi
   1f8cb:	89 ea                	mov    %ebp,%edx
   1f8cd:	48 ff c3             	inc    %rbx
   1f8d0:	41 8b 36             	mov    (%r14),%esi
   1f8d3:	e8 ef f5 ff ff       	callq  1eec7 <lv_color_mix>
   1f8d8:	41 89 06             	mov    %eax,(%r14)
   1f8db:	eb e1                	jmp    1f8be <_lv_blend_map+0x39d>
                    }
                }
                disp_buf_first += disp_w;
   1f8dd:	4c 03 54 24 10       	add    0x10(%rsp),%r10
                map_buf_first += map_w;
   1f8e2:	4c 03 5c 24 18       	add    0x18(%rsp),%r11
            for(y = 0; y < draw_area_h; y++) {
   1f8e7:	41 ff c5             	inc    %r13d
   1f8ea:	eb c5                	jmp    1f8b1 <_lv_blend_map+0x390>
        }
    }
    /*Masked*/
    else {
        /*Only the mask matters*/
        if(opa > LV_OPA_MAX) {
   1f8ec:	41 80 fe fd          	cmp    $0xfd,%r14b
   1f8f0:	0f 86 1f 02 00 00    	jbe    1fb15 <_lv_blend_map+0x5f4>
            /*Go to the first pixel of the row */

            int32_t x_end4 = draw_area_w - 4;
   1f8f6:	41 8d 7c 24 fc       	lea    -0x4(%r12),%edi
                    MAP_NORMAL_MASK_PX(x)
#endif
                }
#endif
                disp_buf_first += disp_w;
                mask += draw_area_w;
   1f8fb:	48 0f bf c0          	movswq %ax,%rax
            for(y = 0; y < draw_area_h; y++) {
   1f8ff:	45 31 f6             	xor    %r14d,%r14d
                mask += draw_area_w;
   1f902:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
            int32_t x_end4 = draw_area_w - 4;
   1f907:	89 7c 24 28          	mov    %edi,0x28(%rsp)
            for(y = 0; y < draw_area_h; y++) {
   1f90b:	44 39 74 24 0c       	cmp    %r14d,0xc(%rsp)
   1f910:	0f 8e 74 02 00 00    	jle    1fb8a <_lv_blend_map+0x669>
   1f916:	4d 89 d7             	mov    %r10,%r15
   1f919:	4c 89 d9             	mov    %r11,%rcx
                const lv_opa_t * mask_tmp_x = mask;
   1f91c:	48 89 dd             	mov    %rbx,%rbp
   1f91f:	41 89 ed             	mov    %ebp,%r13d
   1f922:	41 29 dd             	sub    %ebx,%r13d
                for(x = 0; x < draw_area_w && ((lv_uintptr_t)mask_tmp_x & 0x3); x++) {
   1f925:	45 39 ec             	cmp    %r13d,%r12d
   1f928:	7e 4d                	jle    1f977 <_lv_blend_map+0x456>
   1f92a:	40 f6 c5 03          	test   $0x3,%bpl
   1f92e:	74 47                	je     1f977 <_lv_blend_map+0x456>
                    MAP_NORMAL_MASK_PX(x)
   1f930:	0f b6 55 00          	movzbl 0x0(%rbp),%edx
   1f934:	84 d2                	test   %dl,%dl
   1f936:	74 23                	je     1f95b <_lv_blend_map+0x43a>
   1f938:	80 fa ff             	cmp    $0xff,%dl
   1f93b:	75 07                	jne    1f944 <_lv_blend_map+0x423>
   1f93d:	8b 01                	mov    (%rcx),%eax
   1f93f:	41 89 07             	mov    %eax,(%r15)
   1f942:	eb 17                	jmp    1f95b <_lv_blend_map+0x43a>
   1f944:	8b 39                	mov    (%rcx),%edi
   1f946:	41 8b 37             	mov    (%r15),%esi
   1f949:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
   1f94e:	e8 74 f5 ff ff       	callq  1eec7 <lv_color_mix>
   1f953:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
   1f958:	41 89 07             	mov    %eax,(%r15)
   1f95b:	48 ff c5             	inc    %rbp
   1f95e:	48 83 c1 04          	add    $0x4,%rcx
   1f962:	49 83 c7 04          	add    $0x4,%r15
   1f966:	eb b7                	jmp    1f91f <_lv_blend_map+0x3fe>
                    if(*mask32) {
   1f968:	8b 45 00             	mov    0x0(%rbp),%eax
   1f96b:	85 c0                	test   %eax,%eax
   1f96d:	75 14                	jne    1f983 <_lv_blend_map+0x462>
                    mask32++;
   1f96f:	48 83 c5 04          	add    $0x4,%rbp
                for(; x < x_end4; x += 4) {
   1f973:	41 83 c5 04          	add    $0x4,%r13d
   1f977:	44 39 6c 24 28       	cmp    %r13d,0x28(%rsp)
   1f97c:	7f ea                	jg     1f968 <_lv_blend_map+0x447>
   1f97e:	e9 fc 00 00 00       	jmpq   1fa7f <_lv_blend_map+0x55e>
                        if((*mask32) == 0xFFFFFFFF) {
   1f983:	ff c0                	inc    %eax
   1f985:	75 33                	jne    1f9ba <_lv_blend_map+0x499>
                            disp_buf_first[x] = map_buf_first[x];
   1f987:	49 63 d5             	movslq %r13d,%rdx
   1f98a:	41 8b 0c 93          	mov    (%r11,%rdx,4),%ecx
   1f98e:	48 8d 04 95 00 00 00 	lea    0x0(,%rdx,4),%rax
   1f995:	00 
   1f996:	41 89 0c 92          	mov    %ecx,(%r10,%rdx,4)
                            disp_buf_first[x + 1] = map_buf_first[x + 1];
   1f99a:	41 8b 54 03 04       	mov    0x4(%r11,%rax,1),%edx
   1f99f:	41 89 54 02 04       	mov    %edx,0x4(%r10,%rax,1)
                            disp_buf_first[x + 2] = map_buf_first[x + 2];
   1f9a4:	41 8b 54 03 08       	mov    0x8(%r11,%rax,1),%edx
   1f9a9:	41 89 54 02 08       	mov    %edx,0x8(%r10,%rax,1)
                            disp_buf_first[x + 3] = map_buf_first[x + 3];
   1f9ae:	41 8b 54 03 0c       	mov    0xc(%r11,%rax,1),%edx
   1f9b3:	41 89 54 02 0c       	mov    %edx,0xc(%r10,%rax,1)
   1f9b8:	eb b5                	jmp    1f96f <_lv_blend_map+0x44e>
                            MAP_NORMAL_MASK_PX(x)
   1f9ba:	0f b6 55 00          	movzbl 0x0(%rbp),%edx
   1f9be:	84 d2                	test   %dl,%dl
   1f9c0:	74 24                	je     1f9e6 <_lv_blend_map+0x4c5>
   1f9c2:	4d 63 fd             	movslq %r13d,%r15
   1f9c5:	49 c1 e7 02          	shl    $0x2,%r15
   1f9c9:	4b 8d 04 3b          	lea    (%r11,%r15,1),%rax
   1f9cd:	4d 01 d7             	add    %r10,%r15
   1f9d0:	80 fa ff             	cmp    $0xff,%dl
   1f9d3:	75 04                	jne    1f9d9 <_lv_blend_map+0x4b8>
   1f9d5:	8b 00                	mov    (%rax),%eax
   1f9d7:	eb 0a                	jmp    1f9e3 <_lv_blend_map+0x4c2>
   1f9d9:	41 8b 37             	mov    (%r15),%esi
   1f9dc:	8b 38                	mov    (%rax),%edi
   1f9de:	e8 e4 f4 ff ff       	callq  1eec7 <lv_color_mix>
   1f9e3:	41 89 07             	mov    %eax,(%r15)
                            MAP_NORMAL_MASK_PX(x + 1)
   1f9e6:	0f b6 55 01          	movzbl 0x1(%rbp),%edx
   1f9ea:	84 d2                	test   %dl,%dl
   1f9ec:	74 28                	je     1fa16 <_lv_blend_map+0x4f5>
   1f9ee:	49 63 c5             	movslq %r13d,%rax
   1f9f1:	4c 8d 3c 85 04 00 00 	lea    0x4(,%rax,4),%r15
   1f9f8:	00 
   1f9f9:	4b 8d 04 3b          	lea    (%r11,%r15,1),%rax
   1f9fd:	4d 01 d7             	add    %r10,%r15
   1fa00:	80 fa ff             	cmp    $0xff,%dl
   1fa03:	75 04                	jne    1fa09 <_lv_blend_map+0x4e8>
   1fa05:	8b 00                	mov    (%rax),%eax
   1fa07:	eb 0a                	jmp    1fa13 <_lv_blend_map+0x4f2>
   1fa09:	41 8b 37             	mov    (%r15),%esi
   1fa0c:	8b 38                	mov    (%rax),%edi
   1fa0e:	e8 b4 f4 ff ff       	callq  1eec7 <lv_color_mix>
   1fa13:	41 89 07             	mov    %eax,(%r15)
                            MAP_NORMAL_MASK_PX(x + 2)
   1fa16:	0f b6 55 02          	movzbl 0x2(%rbp),%edx
   1fa1a:	84 d2                	test   %dl,%dl
   1fa1c:	74 28                	je     1fa46 <_lv_blend_map+0x525>
   1fa1e:	49 63 c5             	movslq %r13d,%rax
   1fa21:	4c 8d 3c 85 08 00 00 	lea    0x8(,%rax,4),%r15
   1fa28:	00 
   1fa29:	4b 8d 04 3b          	lea    (%r11,%r15,1),%rax
   1fa2d:	4d 01 d7             	add    %r10,%r15
   1fa30:	80 fa ff             	cmp    $0xff,%dl
   1fa33:	75 04                	jne    1fa39 <_lv_blend_map+0x518>
   1fa35:	8b 00                	mov    (%rax),%eax
   1fa37:	eb 0a                	jmp    1fa43 <_lv_blend_map+0x522>
   1fa39:	41 8b 37             	mov    (%r15),%esi
   1fa3c:	8b 38                	mov    (%rax),%edi
   1fa3e:	e8 84 f4 ff ff       	callq  1eec7 <lv_color_mix>
   1fa43:	41 89 07             	mov    %eax,(%r15)
                            MAP_NORMAL_MASK_PX(x + 3)
   1fa46:	0f b6 55 03          	movzbl 0x3(%rbp),%edx
   1fa4a:	84 d2                	test   %dl,%dl
   1fa4c:	0f 84 1d ff ff ff    	je     1f96f <_lv_blend_map+0x44e>
   1fa52:	49 63 c5             	movslq %r13d,%rax
   1fa55:	4c 8d 3c 85 0c 00 00 	lea    0xc(,%rax,4),%r15
   1fa5c:	00 
   1fa5d:	4b 8d 04 3b          	lea    (%r11,%r15,1),%rax
   1fa61:	4d 01 d7             	add    %r10,%r15
   1fa64:	80 fa ff             	cmp    $0xff,%dl
   1fa67:	75 04                	jne    1fa6d <_lv_blend_map+0x54c>
   1fa69:	8b 00                	mov    (%rax),%eax
   1fa6b:	eb 0a                	jmp    1fa77 <_lv_blend_map+0x556>
   1fa6d:	41 8b 37             	mov    (%r15),%esi
   1fa70:	8b 38                	mov    (%rax),%edi
   1fa72:	e8 50 f4 ff ff       	callq  1eec7 <lv_color_mix>
   1fa77:	41 89 07             	mov    %eax,(%r15)
   1fa7a:	e9 f0 fe ff ff       	jmpq   1f96f <_lv_blend_map+0x44e>
   1fa7f:	4d 63 c5             	movslq %r13d,%r8
                for(; x < x_end4; x += 4) {
   1fa82:	45 31 ff             	xor    %r15d,%r15d
   1fa85:	4a 8d 04 85 00 00 00 	lea    0x0(,%r8,4),%rax
   1fa8c:	00 
   1fa8d:	4d 8d 0c 03          	lea    (%r11,%rax,1),%r9
   1fa91:	4c 01 d0             	add    %r10,%rax
   1fa94:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
   1fa99:	43 8d 44 3d 00       	lea    0x0(%r13,%r15,1),%eax
                for(; x < draw_area_w ; x++) {
   1fa9e:	44 39 e0             	cmp    %r12d,%eax
   1faa1:	7d 5b                	jge    1fafe <_lv_blend_map+0x5dd>
                    MAP_NORMAL_MASK_PX(x)
   1faa3:	42 0f b6 54 3d 00    	movzbl 0x0(%rbp,%r15,1),%edx
   1faa9:	84 d2                	test   %dl,%dl
   1faab:	74 4c                	je     1faf9 <_lv_blend_map+0x5d8>
   1faad:	4b 8d 0c 38          	lea    (%r8,%r15,1),%rcx
   1fab1:	48 c1 e1 02          	shl    $0x2,%rcx
   1fab5:	49 8d 04 0b          	lea    (%r11,%rcx,1),%rax
   1fab9:	4c 01 d1             	add    %r10,%rcx
   1fabc:	80 fa ff             	cmp    $0xff,%dl
   1fabf:	75 0f                	jne    1fad0 <_lv_blend_map+0x5af>
   1fac1:	43 8b 04 b9          	mov    (%r9,%r15,4),%eax
   1fac5:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
   1faca:	42 89 04 b9          	mov    %eax,(%rcx,%r15,4)
   1face:	eb 29                	jmp    1faf9 <_lv_blend_map+0x5d8>
   1fad0:	8b 31                	mov    (%rcx),%esi
   1fad2:	8b 38                	mov    (%rax),%edi
   1fad4:	4c 89 44 24 48       	mov    %r8,0x48(%rsp)
   1fad9:	4c 89 4c 24 40       	mov    %r9,0x40(%rsp)
   1fade:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
   1fae3:	e8 df f3 ff ff       	callq  1eec7 <lv_color_mix>
   1fae8:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
   1faed:	4c 8b 44 24 48       	mov    0x48(%rsp),%r8
   1faf2:	4c 8b 4c 24 40       	mov    0x40(%rsp),%r9
   1faf7:	89 01                	mov    %eax,(%rcx)
   1faf9:	49 ff c7             	inc    %r15
   1fafc:	eb 9b                	jmp    1fa99 <_lv_blend_map+0x578>
                disp_buf_first += disp_w;
   1fafe:	4c 03 54 24 10       	add    0x10(%rsp),%r10
                mask += draw_area_w;
   1fb03:	48 03 5c 24 30       	add    0x30(%rsp),%rbx
            for(y = 0; y < draw_area_h; y++) {
   1fb08:	41 ff c6             	inc    %r14d
                map_buf_first += map_w;
   1fb0b:	4c 03 5c 24 18       	add    0x18(%rsp),%r11
   1fb10:	e9 f6 fd ff ff       	jmpq   1f90b <_lv_blend_map+0x3ea>
                            disp_buf_first[x] = lv_color_mix(map_buf_first[x], disp_buf_first[x], opa_tmp);
                        }
                    }
                }
                disp_buf_first += disp_w;
                mask += draw_area_w;
   1fb15:	48 0f bf c0          	movswq %ax,%rax
            for(y = 0; y < draw_area_h; y++) {
   1fb19:	31 c9                	xor    %ecx,%ecx
                mask += draw_area_w;
   1fb1b:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
            for(y = 0; y < draw_area_h; y++) {
   1fb20:	39 4c 24 0c          	cmp    %ecx,0xc(%rsp)
   1fb24:	7e 64                	jle    1fb8a <_lv_blend_map+0x669>
   1fb26:	49 89 df             	mov    %rbx,%r15
   1fb29:	4d 89 d5             	mov    %r10,%r13
   1fb2c:	4d 89 de             	mov    %r11,%r14
                for(x = 0; x < draw_area_w; x++) {
   1fb2f:	44 89 f8             	mov    %r15d,%eax
   1fb32:	29 d8                	sub    %ebx,%eax
   1fb34:	41 39 c4             	cmp    %eax,%r12d
   1fb37:	7e 3e                	jle    1fb77 <_lv_blend_map+0x656>
                    if(mask[x]) {
   1fb39:	41 0f b6 07          	movzbl (%r15),%eax
   1fb3d:	84 c0                	test   %al,%al
   1fb3f:	74 29                	je     1fb6a <_lv_blend_map+0x649>
                        lv_opa_t opa_tmp = mask[x] >= LV_OPA_MAX ? opa : ((opa * mask[x]) >> 8);
   1fb41:	3c fc                	cmp    $0xfc,%al
   1fb43:	8a 54 24 30          	mov    0x30(%rsp),%dl
   1fb47:	77 06                	ja     1fb4f <_lv_blend_map+0x62e>
   1fb49:	0f af c5             	imul   %ebp,%eax
   1fb4c:	0f b6 d4             	movzbl %ah,%edx
                            disp_buf_first[x] = lv_color_mix(map_buf_first[x], disp_buf_first[x], opa_tmp);
   1fb4f:	41 8b 75 00          	mov    0x0(%r13),%esi
   1fb53:	41 8b 3e             	mov    (%r14),%edi
   1fb56:	0f b6 d2             	movzbl %dl,%edx
   1fb59:	89 4c 24 28          	mov    %ecx,0x28(%rsp)
   1fb5d:	e8 65 f3 ff ff       	callq  1eec7 <lv_color_mix>
   1fb62:	8b 4c 24 28          	mov    0x28(%rsp),%ecx
   1fb66:	41 89 45 00          	mov    %eax,0x0(%r13)
   1fb6a:	49 ff c7             	inc    %r15
   1fb6d:	49 83 c5 04          	add    $0x4,%r13
   1fb71:	49 83 c6 04          	add    $0x4,%r14
   1fb75:	eb b8                	jmp    1fb2f <_lv_blend_map+0x60e>
                disp_buf_first += disp_w;
   1fb77:	4c 03 54 24 10       	add    0x10(%rsp),%r10
                mask += draw_area_w;
   1fb7c:	48 03 5c 24 20       	add    0x20(%rsp),%rbx
            for(y = 0; y < draw_area_h; y++) {
   1fb81:	ff c1                	inc    %ecx
                map_buf_first += map_w;
   1fb83:	4c 03 5c 24 18       	add    0x18(%rsp),%r11
   1fb88:	eb 96                	jmp    1fb20 <_lv_blend_map+0x5ff>
}
   1fb8a:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
   1fb8f:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1fb96:	00 00 
   1fb98:	74 05                	je     1fb9f <_lv_blend_map+0x67e>
   1fb9a:	e8 a1 4a fe ff       	callq  4640 <__stack_chk_fail@plt>
   1fb9f:	48 83 c4 68          	add    $0x68,%rsp
   1fba3:	5b                   	pop    %rbx
   1fba4:	5d                   	pop    %rbp
   1fba5:	41 5c                	pop    %r12
   1fba7:	41 5d                	pop    %r13
   1fba9:	41 5e                	pop    %r14
   1fbab:	41 5f                	pop    %r15
   1fbad:	c3                   	retq   

000000000001fbae <show_error>:
        }
    }
}

static void show_error(const lv_area_t * coords, const lv_area_t * clip_area, const char * msg)
{
   1fbae:	41 55                	push   %r13
   1fbb0:	41 54                	push   %r12
   1fbb2:	49 89 d5             	mov    %rdx,%r13
   1fbb5:	55                   	push   %rbp
   1fbb6:	53                   	push   %rbx
   1fbb7:	48 89 f5             	mov    %rsi,%rbp
   1fbba:	48 89 fb             	mov    %rdi,%rbx
   1fbbd:	48 81 ec b8 00 00 00 	sub    $0xb8,%rsp
    lv_draw_rect_dsc_t rect_dsc;
    lv_draw_rect_dsc_init(&rect_dsc);
   1fbc4:	4c 8d 64 24 28       	lea    0x28(%rsp),%r12
{
   1fbc9:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1fbd0:	00 00 
   1fbd2:	48 89 84 24 a8 00 00 	mov    %rax,0xa8(%rsp)
   1fbd9:	00 
   1fbda:	31 c0                	xor    %eax,%eax
    lv_draw_rect_dsc_init(&rect_dsc);
   1fbdc:	4c 89 e7             	mov    %r12,%rdi
   1fbdf:	e8 5d 35 00 00       	callq  23141 <lv_draw_rect_dsc_init>
    rect_dsc.bg_color = LV_COLOR_WHITE;
    lv_draw_rect(coords, clip_area, &rect_dsc);
   1fbe4:	4c 89 e2             	mov    %r12,%rdx
   1fbe7:	48 89 ee             	mov    %rbp,%rsi
   1fbea:	48 89 df             	mov    %rbx,%rdi

    lv_draw_label_dsc_t label_dsc;
    lv_draw_label_dsc_init(&label_dsc);
   1fbed:	49 89 e4             	mov    %rsp,%r12
    rect_dsc.bg_color = LV_COLOR_WHITE;
   1fbf0:	c7 44 24 2c ff ff ff 	movl   $0xffffffff,0x2c(%rsp)
   1fbf7:	ff 
    lv_draw_rect(coords, clip_area, &rect_dsc);
   1fbf8:	e8 ae 35 00 00       	callq  231ab <lv_draw_rect>
    lv_draw_label_dsc_init(&label_dsc);
   1fbfd:	4c 89 e7             	mov    %r12,%rdi
   1fc00:	e8 a4 0a 00 00       	callq  206a9 <lv_draw_label_dsc_init>
    lv_draw_label(coords, clip_area, &label_dsc, msg, NULL);
   1fc05:	45 31 c0             	xor    %r8d,%r8d
   1fc08:	4c 89 e9             	mov    %r13,%rcx
   1fc0b:	4c 89 e2             	mov    %r12,%rdx
   1fc0e:	48 89 ee             	mov    %rbp,%rsi
   1fc11:	48 89 df             	mov    %rbx,%rdi
   1fc14:	e8 ce 0a 00 00       	callq  206e7 <lv_draw_label>
}
   1fc19:	48 8b 84 24 a8 00 00 	mov    0xa8(%rsp),%rax
   1fc20:	00 
   1fc21:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   1fc28:	00 00 
   1fc2a:	74 05                	je     1fc31 <show_error+0x83>
   1fc2c:	e8 0f 4a fe ff       	callq  4640 <__stack_chk_fail@plt>
   1fc31:	48 81 c4 b8 00 00 00 	add    $0xb8,%rsp
   1fc38:	5b                   	pop    %rbx
   1fc39:	5d                   	pop    %rbp
   1fc3a:	41 5c                	pop    %r12
   1fc3c:	41 5d                	pop    %r13
   1fc3e:	c3                   	retq   

000000000001fc3f <lv_draw_map>:
{
   1fc3f:	41 57                	push   %r15
   1fc41:	41 56                	push   %r14
   1fc43:	49 89 ce             	mov    %rcx,%r14
   1fc46:	41 55                	push   %r13
   1fc48:	41 54                	push   %r12
   1fc4a:	49 89 fc             	mov    %rdi,%r12
   1fc4d:	55                   	push   %rbp
   1fc4e:	53                   	push   %rbx
   1fc4f:	48 83 ec 78          	sub    $0x78,%rsp
   1fc53:	44 89 44 24 24       	mov    %r8d,0x24(%rsp)
   1fc58:	8a 44 24 24          	mov    0x24(%rsp),%al
   1fc5c:	44 89 4c 24 30       	mov    %r9d,0x30(%rsp)
   1fc61:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
   1fc66:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
   1fc6b:	88 44 24 46          	mov    %al,0x46(%rsp)
   1fc6f:	8a 44 24 30          	mov    0x30(%rsp),%al
   1fc73:	88 44 24 47          	mov    %al,0x47(%rsp)
   1fc77:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   1fc7e:	00 00 
   1fc80:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
   1fc85:	31 c0                	xor    %eax,%eax
   1fc87:	48 8b 06             	mov    (%rsi),%rax
   1fc8a:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
   1fc8f:	e8 a6 da ff ff       	callq  1d73a <_lv_refr_get_disp_refreshing>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   1fc94:	48 89 c7             	mov    %rax,%rdi
   1fc97:	e8 66 54 00 00       	callq  25102 <lv_disp_get_buf>
    draw_area.x1 -= disp_area->x1;
   1fc9c:	66 8b 48 1c          	mov    0x1c(%rax),%cx
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   1fca0:	49 89 c5             	mov    %rax,%r13
    draw_area.x1 -= disp_area->x1;
   1fca3:	66 29 4c 24 58       	sub    %cx,0x58(%rsp)
    draw_area.y1 -= disp_area->y1;
   1fca8:	66 8b 40 1e          	mov    0x1e(%rax),%ax
    draw_area.x2 -= disp_area->x1;
   1fcac:	66 29 4c 24 5c       	sub    %cx,0x5c(%rsp)
    draw_area.y1 -= disp_area->y1;
   1fcb1:	66 29 44 24 5a       	sub    %ax,0x5a(%rsp)
    draw_area.y2 -= disp_area->y1;
   1fcb6:	66 29 44 24 5e       	sub    %ax,0x5e(%rsp)
    uint8_t other_mask_cnt = lv_draw_mask_get_cnt();
   1fcbb:	e8 c4 31 00 00       	callq  22e84 <lv_draw_mask_get_cnt>
    if(other_mask_cnt == 0 && draw_dsc->angle == 0 && draw_dsc->zoom == LV_IMG_ZOOM_NONE &&
   1fcc0:	84 c0                	test   %al,%al
    uint8_t other_mask_cnt = lv_draw_mask_get_cnt();
   1fcc2:	88 44 24 35          	mov    %al,0x35(%rsp)
    if(other_mask_cnt == 0 && draw_dsc->angle == 0 && draw_dsc->zoom == LV_IMG_ZOOM_NONE &&
   1fcc6:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   1fccb:	75 51                	jne    1fd1e <lv_draw_map+0xdf>
   1fccd:	66 41 83 7e 02 00    	cmpw   $0x0,0x2(%r14)
   1fcd3:	75 49                	jne    1fd1e <lv_draw_map+0xdf>
   1fcd5:	66 41 81 7e 08 00 01 	cmpw   $0x100,0x8(%r14)
   1fcdc:	75 40                	jne    1fd1e <lv_draw_map+0xdf>
       chroma_key == false && alpha_byte == false && draw_dsc->recolor_opa == LV_OPA_TRANSP) {
   1fcde:	80 7c 24 24 00       	cmpb   $0x0,0x24(%rsp)
   1fce3:	75 39                	jne    1fd1e <lv_draw_map+0xdf>
   1fce5:	80 7c 24 30 00       	cmpb   $0x0,0x30(%rsp)
   1fcea:	75 32                	jne    1fd1e <lv_draw_map+0xdf>
   1fcec:	41 80 7e 0a 00       	cmpb   $0x0,0xa(%r14)
   1fcf1:	75 2b                	jne    1fd1e <lv_draw_map+0xdf>
        _lv_blend_map(clip_area, map_area, (lv_color_t *)map_p, NULL, LV_DRAW_MASK_RES_FULL_COVER, draw_dsc->opa,
   1fcf3:	41 0f b6 46 10       	movzbl 0x10(%r14),%eax
   1fcf8:	48 83 ec 08          	sub    $0x8,%rsp
   1fcfc:	45 0f b6 0e          	movzbl (%r14),%r9d
   1fd00:	41 b8 01 00 00 00    	mov    $0x1,%r8d
   1fd06:	31 c9                	xor    %ecx,%ecx
   1fd08:	4c 89 e6             	mov    %r12,%rsi
   1fd0b:	50                   	push   %rax
   1fd0c:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
   1fd11:	e8 0b f8 ff ff       	callq  1f521 <_lv_blend_map>
   1fd16:	41 5b                	pop    %r11
   1fd18:	5b                   	pop    %rbx
   1fd19:	e9 88 05 00 00       	jmpq   202a6 <lv_draw_map+0x667>
   1fd1e:	66 41 8b 44 24 04    	mov    0x4(%r12),%ax
        int32_t map_w = lv_area_get_width(map_area);
   1fd24:	41 0f bf 0c 24       	movswl (%r12),%ecx
        map_buf_tmp += map_w * (draw_area.y1 - (map_area->y1 - disp_area->y1)) * px_size_byte;
   1fd29:	45 0f bf 44 24 02    	movswl 0x2(%r12),%r8d
   1fd2f:	45 0f bf 4d 1e       	movswl 0x1e(%r13),%r9d
        map_buf_tmp += (draw_area.x1 - (map_area->x1 - disp_area->x1)) * px_size_byte;
   1fd34:	66 45 8b 7d 1c       	mov    0x1c(%r13),%r15w
   1fd39:	0f bf 6c 24 58       	movswl 0x58(%rsp),%ebp
   1fd3e:	8d 58 01             	lea    0x1(%rax),%ebx
        map_buf_tmp += map_w * (draw_area.y1 - (map_area->y1 - disp_area->y1)) * px_size_byte;
   1fd41:	0f bf 44 24 5a       	movswl 0x5a(%rsp),%eax
   1fd46:	29 cb                	sub    %ecx,%ebx
   1fd48:	45 29 c8             	sub    %r9d,%r8d
        int32_t map_w = lv_area_get_width(map_area);
   1fd4b:	0f bf db             	movswl %bx,%ebx
        map_buf_tmp += (draw_area.x1 - (map_area->x1 - disp_area->x1)) * px_size_byte;
   1fd4e:	89 ef                	mov    %ebp,%edi
        map_buf_tmp += map_w * (draw_area.y1 - (map_area->y1 - disp_area->y1)) * px_size_byte;
   1fd50:	89 c6                	mov    %eax,%esi
   1fd52:	44 29 c0             	sub    %r8d,%eax
        map_buf_tmp += (draw_area.x1 - (map_area->x1 - disp_area->x1)) * px_size_byte;
   1fd55:	45 0f bf c7          	movswl %r15w,%r8d
        map_buf_tmp += map_w * (draw_area.y1 - (map_area->y1 - disp_area->y1)) * px_size_byte;
   1fd59:	0f af c3             	imul   %ebx,%eax
        map_buf_tmp += (draw_area.x1 - (map_area->x1 - disp_area->x1)) * px_size_byte;
   1fd5c:	44 29 c1             	sub    %r8d,%ecx
        blend_area.x1 = draw_area.x1 + disp_area->x1;
   1fd5f:	41 01 ff             	add    %edi,%r15d
        map_buf_tmp += (draw_area.x1 - (map_area->x1 - disp_area->x1)) * px_size_byte;
   1fd62:	29 cd                	sub    %ecx,%ebp
        blend_area.x1 = draw_area.x1 + disp_area->x1;
   1fd64:	66 44 89 7c 24 60    	mov    %r15w,0x60(%rsp)
        map_buf_tmp += (draw_area.x1 - (map_area->x1 - disp_area->x1)) * px_size_byte;
   1fd6a:	c1 e5 02             	shl    $0x2,%ebp
        map_buf_tmp += map_w * (draw_area.y1 - (map_area->y1 - disp_area->y1)) * px_size_byte;
   1fd6d:	c1 e0 02             	shl    $0x2,%eax
        map_buf_tmp += (draw_area.x1 - (map_area->x1 - disp_area->x1)) * px_size_byte;
   1fd70:	48 63 ed             	movslq %ebp,%rbp
        map_buf_tmp += map_w * (draw_area.y1 - (map_area->y1 - disp_area->y1)) * px_size_byte;
   1fd73:	48 98                	cltq   
        map_buf_tmp += (draw_area.x1 - (map_area->x1 - disp_area->x1)) * px_size_byte;
   1fd75:	48 01 c5             	add    %rax,%rbp
   1fd78:	8b 44 24 5c          	mov    0x5c(%rsp),%eax
   1fd7c:	48 01 d5             	add    %rdx,%rbp
   1fd7f:	ff c0                	inc    %eax
   1fd81:	29 f8                	sub    %edi,%eax
        blend_area.x2 = blend_area.x1 + lv_area_get_width(&draw_area) - 1;
   1fd83:	45 8d 7c 07 ff       	lea    -0x1(%r15,%rax,1),%r15d
   1fd88:	66 89 44 24 22       	mov    %ax,0x22(%rsp)
        blend_area.y1 = disp_area->y1 + draw_area.y1;
   1fd8d:	66 41 8b 45 1e       	mov    0x1e(%r13),%ax
        blend_area.x2 = blend_area.x1 + lv_area_get_width(&draw_area) - 1;
   1fd92:	66 44 89 7c 24 64    	mov    %r15w,0x64(%rsp)
   1fd98:	4c 8d 7c 24 58       	lea    0x58(%rsp),%r15
        blend_area.y1 = disp_area->y1 + draw_area.y1;
   1fd9d:	01 f0                	add    %esi,%eax
   1fd9f:	66 89 44 24 62       	mov    %ax,0x62(%rsp)
        blend_area.y2 = blend_area.y1;
   1fda4:	66 89 44 24 66       	mov    %ax,0x66(%rsp)
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1fda9:	66 8b 44 24 5e       	mov    0x5e(%rsp),%ax
   1fdae:	44 8d 60 01          	lea    0x1(%rax),%r12d
   1fdb2:	41 29 f4             	sub    %esi,%r12d
        if(other_mask_cnt == 0 && !transform && !chroma_key && draw_dsc->recolor_opa == LV_OPA_TRANSP && alpha_byte) {
   1fdb5:	80 7c 24 35 00       	cmpb   $0x0,0x35(%rsp)
   1fdba:	0f 85 84 01 00 00    	jne    1ff44 <lv_draw_map+0x305>
   1fdc0:	80 7c 24 24 00       	cmpb   $0x0,0x24(%rsp)
   1fdc5:	0f 85 79 01 00 00    	jne    1ff44 <lv_draw_map+0x305>
   1fdcb:	41 80 7e 0a 00       	cmpb   $0x0,0xa(%r14)
   1fdd0:	0f 85 6e 01 00 00    	jne    1ff44 <lv_draw_map+0x305>
   1fdd6:	80 7c 24 30 00       	cmpb   $0x0,0x30(%rsp)
   1fddb:	0f 84 63 01 00 00    	je     1ff44 <lv_draw_map+0x305>
            uint32_t mask_buf_size = lv_area_get_size(&draw_area) > LV_HOR_RES_MAX ? LV_HOR_RES_MAX : lv_area_get_size(&draw_area);
   1fde1:	4c 89 ff             	mov    %r15,%rdi
   1fde4:	41 bd e0 01 00 00    	mov    $0x1e0,%r13d
   1fdea:	e8 12 57 00 00       	callq  25501 <lv_area_get_size>
   1fdef:	3d e0 01 00 00       	cmp    $0x1e0,%eax
   1fdf4:	77 0b                	ja     1fe01 <lv_draw_map+0x1c2>
   1fdf6:	4c 89 ff             	mov    %r15,%rdi
   1fdf9:	e8 03 57 00 00       	callq  25501 <lv_area_get_size>
   1fdfe:	41 89 c5             	mov    %eax,%r13d
            lv_color_t * map2 = _lv_mem_buf_get(mask_buf_size * sizeof(lv_color_t));
   1fe01:	42 8d 3c ad 00 00 00 	lea    0x0(,%r13,4),%edi
   1fe08:	00 
                map_buf_tmp += map_w * px_size_byte;
   1fe09:	c1 e3 02             	shl    $0x2,%ebx
            for(y = 0; y < draw_area_h; y++) {
   1fe0c:	45 0f bf e4          	movswl %r12w,%r12d
            lv_color_t * map2 = _lv_mem_buf_get(mask_buf_size * sizeof(lv_color_t));
   1fe10:	e8 c9 63 00 00       	callq  261de <_lv_mem_buf_get>
            lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
   1fe15:	44 89 ef             	mov    %r13d,%edi
            lv_color_t * map2 = _lv_mem_buf_get(mask_buf_size * sizeof(lv_color_t));
   1fe18:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
            lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
   1fe1d:	e8 bc 63 00 00       	callq  261de <_lv_mem_buf_get>
   1fe22:	49 89 c7             	mov    %rax,%r15
                map_buf_tmp += map_w * px_size_byte;
   1fe25:	48 63 c3             	movslq %ebx,%rax
        uint32_t px_i = 0;
   1fe28:	31 c9                	xor    %ecx,%ecx
                map_buf_tmp += map_w * px_size_byte;
   1fe2a:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
            for(y = 0; y < draw_area_h; y++) {
   1fe2f:	31 db                	xor    %ebx,%ebx
   1fe31:	41 39 dc             	cmp    %ebx,%r12d
   1fe34:	0f 8e b7 00 00 00    	jle    1fef1 <lv_draw_map+0x2b2>
                for(x = 0; x < draw_area_w; x++, map_px += px_size_byte, px_i++) {
   1fe3a:	44 0f bf 44 24 22    	movswl 0x22(%rsp),%r8d
   1fe40:	31 d2                	xor    %edx,%edx
   1fe42:	41 39 d0             	cmp    %edx,%r8d
   1fe45:	8d 34 11             	lea    (%rcx,%rdx,1),%esi
   1fe48:	7e 26                	jle    1fe70 <lv_draw_map+0x231>
                    lv_opa_t px_opa = map_px[LV_IMG_PX_SIZE_ALPHA_BYTE - 1];
   1fe4a:	40 8a 7c 95 03       	mov    0x3(%rbp,%rdx,4),%dil
   1fe4f:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
                    if(px_opa) {
   1fe54:	40 84 ff             	test   %dil,%dil
                    mask_buf[px_i] = px_opa;
   1fe57:	41 88 3c 37          	mov    %dil,(%r15,%rsi,1)
   1fe5b:	48 8d 34 b0          	lea    (%rax,%rsi,4),%rsi
                    if(px_opa) {
   1fe5f:	74 06                	je     1fe67 <lv_draw_map+0x228>
                        map2[px_i].full =  *((uint32_t *)map_px);
   1fe61:	8b 7c 95 00          	mov    0x0(%rbp,%rdx,4),%edi
   1fe65:	89 3e                	mov    %edi,(%rsi)
                    map2[px_i].ch.alpha = 0xFF;
   1fe67:	c6 46 03 ff          	movb   $0xff,0x3(%rsi)
   1fe6b:	48 ff c2             	inc    %rdx
   1fe6e:	eb d2                	jmp    1fe42 <lv_draw_map+0x203>
   1fe70:	66 83 7c 24 22 00    	cmpw   $0x0,0x22(%rsp)
   1fe76:	ba 00 00 00 00       	mov    $0x0,%edx
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1fe7b:	8b 44 24 5c          	mov    0x5c(%rsp),%eax
   1fe7f:	66 0f 49 54 24 22    	cmovns 0x22(%rsp),%dx
                map_buf_tmp += map_w * px_size_byte;
   1fe85:	48 03 6c 24 10       	add    0x10(%rsp),%rbp
   1fe8a:	0f bf d2             	movswl %dx,%edx
   1fe8d:	01 d1                	add    %edx,%ecx
   1fe8f:	8d 50 01             	lea    0x1(%rax),%edx
   1fe92:	2b 54 24 58          	sub    0x58(%rsp),%edx
                if(px_i + lv_area_get_width(&draw_area) < mask_buf_size) {
   1fe96:	0f bf d2             	movswl %dx,%edx
   1fe99:	01 ca                	add    %ecx,%edx
   1fe9b:	44 39 ea             	cmp    %r13d,%edx
   1fe9e:	73 07                	jae    1fea7 <lv_draw_map+0x268>
                    blend_area.y2 ++;
   1fea0:	66 ff 44 24 66       	incw   0x66(%rsp)
   1fea5:	eb 43                	jmp    1feea <lv_draw_map+0x2ab>
                    _lv_blend_map(clip_area, &blend_area, map2, mask_buf, LV_DRAW_MASK_RES_CHANGED, draw_dsc->opa, draw_dsc->blend_mode);
   1fea7:	41 0f b6 56 10       	movzbl 0x10(%r14),%edx
   1feac:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
   1feb1:	45 0f b6 0e          	movzbl (%r14),%r9d
   1feb5:	48 83 ec 08          	sub    $0x8,%rsp
   1feb9:	4c 89 f9             	mov    %r15,%rcx
   1febc:	41 b8 02 00 00 00    	mov    $0x2,%r8d
   1fec2:	52                   	push   %rdx
   1fec3:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
   1fec8:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
   1fecd:	e8 4f f6 ff ff       	callq  1f521 <_lv_blend_map>
   1fed2:	41 59                	pop    %r9
   1fed4:	41 5a                	pop    %r10
                    blend_area.y1 = blend_area.y2 + 1;
   1fed6:	66 8b 44 24 66       	mov    0x66(%rsp),%ax
                    px_i = 0;
   1fedb:	31 c9                	xor    %ecx,%ecx
                    blend_area.y1 = blend_area.y2 + 1;
   1fedd:	8d 50 01             	lea    0x1(%rax),%edx
   1fee0:	66 89 54 24 62       	mov    %dx,0x62(%rsp)
                    blend_area.y2 = blend_area.y1;
   1fee5:	66 89 54 24 66       	mov    %dx,0x66(%rsp)
            for(y = 0; y < draw_area_h; y++) {
   1feea:	ff c3                	inc    %ebx
   1feec:	e9 40 ff ff ff       	jmpq   1fe31 <lv_draw_map+0x1f2>
            if(blend_area.y1 != blend_area.y2) {
   1fef1:	66 8b 44 24 66       	mov    0x66(%rsp),%ax
   1fef6:	66 39 44 24 62       	cmp    %ax,0x62(%rsp)
   1fefb:	74 35                	je     1ff32 <lv_draw_map+0x2f3>
                blend_area.y2--;
   1fefd:	ff c8                	dec    %eax
                _lv_blend_map(clip_area, &blend_area, map2, mask_buf, LV_DRAW_MASK_RES_CHANGED, draw_dsc->opa, draw_dsc->blend_mode);
   1feff:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
   1ff04:	45 0f b6 0e          	movzbl (%r14),%r9d
                blend_area.y2--;
   1ff08:	66 89 44 24 66       	mov    %ax,0x66(%rsp)
                _lv_blend_map(clip_area, &blend_area, map2, mask_buf, LV_DRAW_MASK_RES_CHANGED, draw_dsc->opa, draw_dsc->blend_mode);
   1ff0d:	41 0f b6 46 10       	movzbl 0x10(%r14),%eax
   1ff12:	48 83 ec 08          	sub    $0x8,%rsp
   1ff16:	41 b8 02 00 00 00    	mov    $0x2,%r8d
   1ff1c:	4c 89 f9             	mov    %r15,%rcx
   1ff1f:	50                   	push   %rax
   1ff20:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
   1ff25:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
   1ff2a:	e8 f2 f5 ff ff       	callq  1f521 <_lv_blend_map>
   1ff2f:	5f                   	pop    %rdi
   1ff30:	41 58                	pop    %r8
            _lv_mem_buf_release(mask_buf);
   1ff32:	4c 89 ff             	mov    %r15,%rdi
   1ff35:	e8 93 63 00 00       	callq  262cd <_lv_mem_buf_release>
            _lv_mem_buf_release(map2);
   1ff3a:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   1ff3f:	e9 5d 03 00 00       	jmpq   202a1 <lv_draw_map+0x662>
            uint32_t mask_buf_size = lv_area_get_size(&draw_area) > LV_HOR_RES_MAX ? LV_HOR_RES_MAX : lv_area_get_size(&draw_area);
   1ff44:	4c 89 ff             	mov    %r15,%rdi
   1ff47:	e8 b5 55 00 00       	callq  25501 <lv_area_get_size>
   1ff4c:	3d e0 01 00 00       	cmp    $0x1e0,%eax
   1ff51:	c7 44 24 10 e0 01 00 	movl   $0x1e0,0x10(%rsp)
   1ff58:	00 
   1ff59:	77 0c                	ja     1ff67 <lv_draw_map+0x328>
   1ff5b:	4c 89 ff             	mov    %r15,%rdi
   1ff5e:	e8 9e 55 00 00       	callq  25501 <lv_area_get_size>
   1ff63:	89 44 24 10          	mov    %eax,0x10(%rsp)
            lv_color_t * map2 = _lv_mem_buf_get(mask_buf_size * sizeof(lv_color_t));
   1ff67:	8b 44 24 10          	mov    0x10(%rsp),%eax
   1ff6b:	8d 3c 85 00 00 00 00 	lea    0x0(,%rax,4),%edi
   1ff72:	e8 67 62 00 00       	callq  261de <_lv_mem_buf_get>
            lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
   1ff77:	8b 7c 24 10          	mov    0x10(%rsp),%edi
            lv_color_t * map2 = _lv_mem_buf_get(mask_buf_size * sizeof(lv_color_t));
   1ff7b:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
            lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
   1ff80:	e8 59 62 00 00       	callq  261de <_lv_mem_buf_get>
            lv_opa_t recolor_opa_inv = 255 - draw_dsc->recolor_opa;
   1ff85:	41 8a 56 0a          	mov    0xa(%r14),%dl
            lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
   1ff89:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
            lv_opa_t recolor_opa_inv = 255 - draw_dsc->recolor_opa;
   1ff8e:	88 d0                	mov    %dl,%al
            if(draw_dsc->recolor_opa != 0) {
   1ff90:	84 d2                	test   %dl,%dl
            lv_opa_t recolor_opa_inv = 255 - draw_dsc->recolor_opa;
   1ff92:	f7 d0                	not    %eax
   1ff94:	88 44 24 45          	mov    %al,0x45(%rsp)
            if(draw_dsc->recolor_opa != 0) {
   1ff98:	74 23                	je     1ffbd <lv_draw_map+0x37e>
    out[0] = (uint16_t) LV_COLOR_GET_R(c) * mix;
   1ff9a:	88 d0                	mov    %dl,%al
   1ff9c:	41 f6 66 0e          	mulb   0xe(%r14)
   1ffa0:	66 89 44 24 40       	mov    %ax,0x40(%rsp)
    out[1] = (uint16_t) LV_COLOR_GET_G(c) * mix;
   1ffa5:	88 d0                	mov    %dl,%al
   1ffa7:	41 f6 66 0d          	mulb   0xd(%r14)
   1ffab:	66 89 44 24 36       	mov    %ax,0x36(%rsp)
    out[2] = (uint16_t) LV_COLOR_GET_B(c) * mix;
   1ffb0:	88 d0                	mov    %dl,%al
   1ffb2:	41 f6 66 0c          	mulb   0xc(%r14)
   1ffb6:	66 89 44 24 42       	mov    %ax,0x42(%rsp)
   1ffbb:	eb 15                	jmp    1ffd2 <lv_draw_map+0x393>
            uint16_t recolor_premult[3] = {0};
   1ffbd:	66 c7 44 24 42 00 00 	movw   $0x0,0x42(%rsp)
   1ffc4:	66 c7 44 24 36 00 00 	movw   $0x0,0x36(%rsp)
   1ffcb:	66 c7 44 24 40 00 00 	movw   $0x0,0x40(%rsp)
            mask_res = (alpha_byte || chroma_key || draw_dsc->angle ||
   1ffd2:	8a 44 24 30          	mov    0x30(%rsp),%al
   1ffd6:	0a 44 24 24          	or     0x24(%rsp),%al
   1ffda:	41 b7 02             	mov    $0x2,%r15b
   1ffdd:	88 44 24 44          	mov    %al,0x44(%rsp)
   1ffe1:	75 16                	jne    1fff9 <lv_draw_map+0x3ba>
   1ffe3:	66 41 83 7e 02 00    	cmpw   $0x0,0x2(%r14)
   1ffe9:	75 0e                	jne    1fff9 <lv_draw_map+0x3ba>
   1ffeb:	66 41 81 7e 08 00 01 	cmpw   $0x100,0x8(%r14)
   1fff2:	41 0f 95 c7          	setne  %r15b
   1fff6:	41 ff c7             	inc    %r15d
            if(other_mask_cnt) {
   1fff9:	80 7c 24 35 00       	cmpb   $0x0,0x35(%rsp)
   1fffe:	74 0d                	je     2000d <lv_draw_map+0x3ce>
                _lv_memset_ff(mask_buf, mask_buf_size);
   20000:	8b 4c 24 10          	mov    0x10(%rsp),%ecx
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
   20004:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   20009:	b0 ff                	mov    $0xff,%al
   2000b:	f3 aa                	rep stos %al,%es:(%rdi)
                map_buf_tmp += map_w * px_size_byte;
   2000d:	c1 e3 02             	shl    $0x2,%ebx
   20010:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%rsp)
   20017:	00 
   20018:	48 63 c3             	movslq %ebx,%rax
   2001b:	31 db                	xor    %ebx,%ebx
   2001d:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
            for(y = 0; y < draw_area_h; y++) {
   20022:	41 0f bf c4          	movswl %r12w,%eax
   20026:	89 44 24 48          	mov    %eax,0x48(%rsp)
   2002a:	8b 74 24 30          	mov    0x30(%rsp),%esi
   2002e:	39 74 24 48          	cmp    %esi,0x48(%rsp)
   20032:	0f 8e 1a 02 00 00    	jle    20252 <lv_draw_map+0x613>
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   20038:	0f b7 44 24 36       	movzwl 0x36(%rsp),%eax
                for(x = 0; x < draw_area_w; x++, map_px += px_size_byte, px_i++) {
   2003d:	44 0f bf 5c 24 22    	movswl 0x22(%rsp),%r11d
                            if(c.full == chroma_keyed_color.full) {
   20043:	31 c9                	xor    %ecx,%ecx
                        c = lv_color_mix_premult(recolor_premult, c, recolor_opa_inv);
   20045:	0f b6 74 24 45       	movzbl 0x45(%rsp),%esi
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   2004a:	44 0f b7 64 24 42    	movzwl 0x42(%rsp),%r12d
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) premult_c1[0] + LV_COLOR_GET_R(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   20050:	44 0f b7 54 24 40    	movzwl 0x40(%rsp),%r10d
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   20056:	89 44 24 4c          	mov    %eax,0x4c(%rsp)
                for(x = 0; x < draw_area_w; x++, map_px += px_size_byte, px_i++) {
   2005a:	41 39 cb             	cmp    %ecx,%r11d
   2005d:	8d 04 0b             	lea    (%rbx,%rcx,1),%eax
   20060:	0f 8e d0 00 00 00    	jle    20136 <lv_draw_map+0x4f7>
   20066:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
                        if(alpha_byte) {
   2006b:	80 7c 24 47 00       	cmpb   $0x0,0x47(%rsp)
   20070:	4c 8d 04 07          	lea    (%rdi,%rax,1),%r8
   20074:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
   20079:	48 8d 3c 87          	lea    (%rdi,%rax,4),%rdi
   2007d:	74 0d                	je     2008c <lv_draw_map+0x44d>
                            lv_opa_t px_opa = map_px[LV_IMG_PX_SIZE_ALPHA_BYTE - 1];
   2007f:	8a 44 8d 03          	mov    0x3(%rbp,%rcx,4),%al
                            if(px_opa == 0) {
   20083:	84 c0                	test   %al,%al
                            mask_buf[px_i] = px_opa;
   20085:	41 88 00             	mov    %al,(%r8)
                            if(px_opa == 0) {
   20088:	75 06                	jne    20090 <lv_draw_map+0x451>
   2008a:	eb 2d                	jmp    200b9 <lv_draw_map+0x47a>
                            mask_buf[px_i] = 0xFF;
   2008c:	41 c6 00 ff          	movb   $0xff,(%r8)
                        c.full =  *((uint32_t *)map_px);
   20090:	8b 44 8d 00          	mov    0x0(%rbp,%rcx,4),%eax
                        c.ch.alpha = 0xFF;
   20094:	41 89 c1             	mov    %eax,%r9d
                        c.full =  *((uint32_t *)map_px);
   20097:	89 44 24 24          	mov    %eax,0x24(%rsp)
                        c.ch.alpha = 0xFF;
   2009b:	41 81 c9 00 00 00 ff 	or     $0xff000000,%r9d
                        if(chroma_key) {
   200a2:	80 7c 24 46 00       	cmpb   $0x0,0x46(%rsp)
                        c.ch.alpha = 0xFF;
   200a7:	44 89 ca             	mov    %r9d,%edx
                        if(chroma_key) {
   200aa:	74 15                	je     200c1 <lv_draw_map+0x482>
                            if(c.full == chroma_keyed_color.full) {
   200ac:	41 81 f9 00 ff 00 ff 	cmp    $0xff00ff00,%r9d
   200b3:	75 0c                	jne    200c1 <lv_draw_map+0x482>
                                mask_buf[px_i] = LV_OPA_TRANSP;
   200b5:	41 c6 00 00          	movb   $0x0,(%r8)
                                map2[px_i].full = 0;
   200b9:	c7 07 00 00 00 00    	movl   $0x0,(%rdi)
                                continue;
   200bf:	eb 6d                	jmp    2012e <lv_draw_map+0x4ef>
                    if(draw_dsc->recolor_opa != 0) {
   200c1:	41 80 7e 0a 00       	cmpb   $0x0,0xa(%r14)
   200c6:	74 64                	je     2012c <lv_draw_map+0x4ed>
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   200c8:	44 0f b6 44 24 24    	movzbl 0x24(%rsp),%r8d
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   200ce:	8b 44 24 24          	mov    0x24(%rsp),%eax
   200d2:	0f b6 c4             	movzbl %ah,%eax
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   200d5:	44 0f af c6          	imul   %esi,%r8d
   200d9:	45 01 e0             	add    %r12d,%r8d
   200dc:	45 69 c0 81 80 00 00 	imul   $0x8081,%r8d,%r8d
   200e3:	41 c1 e8 17          	shr    $0x17,%r8d
   200e7:	44 88 c2             	mov    %r8b,%dl
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   200ea:	41 89 c0             	mov    %eax,%r8d
   200ed:	44 0f af c6          	imul   %esi,%r8d
   200f1:	44 03 44 24 4c       	add    0x4c(%rsp),%r8d
   200f6:	45 69 c0 81 80 00 00 	imul   $0x8081,%r8d,%r8d
   200fd:	41 c1 e8 17          	shr    $0x17,%r8d
   20101:	44 89 c0             	mov    %r8d,%eax
   20104:	88 c6                	mov    %al,%dh
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) premult_c1[0] + LV_COLOR_GET_R(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   20106:	8b 44 24 24          	mov    0x24(%rsp),%eax
   2010a:	81 e2 ff ff 00 ff    	and    $0xff00ffff,%edx
   20110:	c1 e8 10             	shr    $0x10,%eax
   20113:	0f b6 c0             	movzbl %al,%eax
   20116:	0f af c6             	imul   %esi,%eax
   20119:	44 01 d0             	add    %r10d,%eax
   2011c:	69 c0 81 80 00 00    	imul   $0x8081,%eax,%eax
   20122:	c1 e8 07             	shr    $0x7,%eax
   20125:	25 00 00 ff 00       	and    $0xff0000,%eax
   2012a:	09 c2                	or     %eax,%edx
                    map2[px_i].full = c.full;
   2012c:	89 17                	mov    %edx,(%rdi)
   2012e:	48 ff c1             	inc    %rcx
   20131:	e9 24 ff ff ff       	jmpq   2005a <lv_draw_map+0x41b>
   20136:	66 83 7c 24 22 00    	cmpw   $0x0,0x22(%rsp)
   2013c:	41 bc 00 00 00 00    	mov    $0x0,%r12d
   20142:	66 44 0f 49 64 24 22 	cmovns 0x22(%rsp),%r12w
   20149:	45 0f bf e4          	movswl %r12w,%r12d
   2014d:	41 01 dc             	add    %ebx,%r12d
                if(other_mask_cnt) {
   20150:	80 7c 24 35 00       	cmpb   $0x0,0x35(%rsp)
   20155:	74 5a                	je     201b1 <lv_draw_map+0x572>
                    mask_res_sub = lv_draw_mask_apply(mask_buf + px_i_start, draw_area.x1 + vdb->area.x1, y + draw_area.y1 + vdb->area.y1,
   20157:	8b 44 24 5c          	mov    0x5c(%rsp),%eax
   2015b:	8b 74 24 58          	mov    0x58(%rsp),%esi
   2015f:	66 41 8b 55 1e       	mov    0x1e(%r13),%dx
   20164:	66 03 54 24 5a       	add    0x5a(%rsp),%dx
   20169:	48 03 5c 24 08       	add    0x8(%rsp),%rbx
   2016e:	03 54 24 30          	add    0x30(%rsp),%edx
   20172:	8d 48 01             	lea    0x1(%rax),%ecx
   20175:	29 f1                	sub    %esi,%ecx
   20177:	41 03 75 1c          	add    0x1c(%r13),%esi
   2017b:	0f bf c9             	movswl %cx,%ecx
   2017e:	0f bf d2             	movswl %dx,%edx
   20181:	48 89 df             	mov    %rbx,%rdi
   20184:	0f bf f6             	movswl %si,%esi
   20187:	e8 38 2c 00 00       	callq  22dc4 <lv_draw_mask_apply>
                    if(mask_res_sub == LV_DRAW_MASK_RES_TRANSP) {
   2018c:	84 c0                	test   %al,%al
   2018e:	75 19                	jne    201a9 <lv_draw_map+0x56a>
   20190:	8b 74 24 5c          	mov    0x5c(%rsp),%esi
   20194:	48 89 df             	mov    %rbx,%rdi
                        mask_res = LV_DRAW_MASK_RES_CHANGED;
   20197:	41 b7 02             	mov    $0x2,%r15b
   2019a:	8d 4e 01             	lea    0x1(%rsi),%ecx
   2019d:	2b 4c 24 58          	sub    0x58(%rsp),%ecx
                        _lv_memset_00(mask_buf + px_i_start, lv_area_get_width(&draw_area));
   201a1:	48 0f bf c9          	movswq %cx,%rcx
   201a5:	f3 aa                	rep stos %al,%es:(%rdi)
   201a7:	eb 08                	jmp    201b1 <lv_draw_map+0x572>
                        mask_res = LV_DRAW_MASK_RES_CHANGED;
   201a9:	3c 02                	cmp    $0x2,%al
   201ab:	b0 02                	mov    $0x2,%al
   201ad:	44 0f 44 f8          	cmove  %eax,%r15d
   201b1:	8b 44 24 5c          	mov    0x5c(%rsp),%eax
                map_buf_tmp += map_w * px_size_byte;
   201b5:	48 03 6c 24 38       	add    0x38(%rsp),%rbp
   201ba:	ff c0                	inc    %eax
   201bc:	2b 44 24 58          	sub    0x58(%rsp),%eax
                if(px_i + lv_area_get_width(&draw_area) < mask_buf_size) {
   201c0:	98                   	cwtl   
   201c1:	44 01 e0             	add    %r12d,%eax
   201c4:	3b 44 24 10          	cmp    0x10(%rsp),%eax
   201c8:	73 07                	jae    201d1 <lv_draw_map+0x592>
                    blend_area.y2 ++;
   201ca:	66 ff 44 24 66       	incw   0x66(%rsp)
   201cf:	eb 75                	jmp    20246 <lv_draw_map+0x607>
                    _lv_blend_map(clip_area, &blend_area, map2, mask_buf, mask_res, draw_dsc->opa, draw_dsc->blend_mode);
   201d1:	41 0f b6 46 10       	movzbl 0x10(%r14),%eax
   201d6:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
   201db:	45 0f b6 0e          	movzbl (%r14),%r9d
   201df:	48 83 ec 08          	sub    $0x8,%rsp
   201e3:	45 0f b6 c7          	movzbl %r15b,%r8d
                    mask_res = (alpha_byte || chroma_key || draw_dsc->angle ||
   201e7:	41 b7 02             	mov    $0x2,%r15b
                    _lv_blend_map(clip_area, &blend_area, map2, mask_buf, mask_res, draw_dsc->opa, draw_dsc->blend_mode);
   201ea:	50                   	push   %rax
   201eb:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   201f0:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
   201f5:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
   201fa:	e8 22 f3 ff ff       	callq  1f521 <_lv_blend_map>
   201ff:	59                   	pop    %rcx
   20200:	5e                   	pop    %rsi
                    blend_area.y1 = blend_area.y2 + 1;
   20201:	66 8b 44 24 66       	mov    0x66(%rsp),%ax
   20206:	ff c0                	inc    %eax
                    mask_res = (alpha_byte || chroma_key || draw_dsc->angle ||
   20208:	80 7c 24 44 00       	cmpb   $0x0,0x44(%rsp)
                    blend_area.y1 = blend_area.y2 + 1;
   2020d:	66 89 44 24 62       	mov    %ax,0x62(%rsp)
                    blend_area.y2 = blend_area.y1;
   20212:	66 89 44 24 66       	mov    %ax,0x66(%rsp)
                    mask_res = (alpha_byte || chroma_key || draw_dsc->angle ||
   20217:	75 16                	jne    2022f <lv_draw_map+0x5f0>
   20219:	66 41 83 7e 02 00    	cmpw   $0x0,0x2(%r14)
   2021f:	75 0e                	jne    2022f <lv_draw_map+0x5f0>
   20221:	66 41 81 7e 08 00 01 	cmpw   $0x100,0x8(%r14)
   20228:	41 0f 95 c7          	setne  %r15b
   2022c:	41 ff c7             	inc    %r15d
                    px_i = 0;
   2022f:	45 31 e4             	xor    %r12d,%r12d
                    if(other_mask_cnt) {
   20232:	80 7c 24 35 00       	cmpb   $0x0,0x35(%rsp)
   20237:	74 0d                	je     20246 <lv_draw_map+0x607>
                        _lv_memset_ff(mask_buf, mask_buf_size);
   20239:	8b 4c 24 10          	mov    0x10(%rsp),%ecx
   2023d:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   20242:	b0 ff                	mov    $0xff,%al
   20244:	f3 aa                	rep stos %al,%es:(%rdi)
            for(y = 0; y < draw_area_h; y++) {
   20246:	ff 44 24 30          	incl   0x30(%rsp)
   2024a:	44 89 e3             	mov    %r12d,%ebx
   2024d:	e9 d8 fd ff ff       	jmpq   2002a <lv_draw_map+0x3eb>
            if(blend_area.y1 != blend_area.y2) {
   20252:	66 8b 44 24 66       	mov    0x66(%rsp),%ax
   20257:	66 39 44 24 62       	cmp    %ax,0x62(%rsp)
   2025c:	74 34                	je     20292 <lv_draw_map+0x653>
                blend_area.y2--;
   2025e:	ff c8                	dec    %eax
                _lv_blend_map(clip_area, &blend_area, map2, mask_buf, mask_res, draw_dsc->opa, draw_dsc->blend_mode);
   20260:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
   20265:	45 0f b6 0e          	movzbl (%r14),%r9d
                blend_area.y2--;
   20269:	66 89 44 24 66       	mov    %ax,0x66(%rsp)
                _lv_blend_map(clip_area, &blend_area, map2, mask_buf, mask_res, draw_dsc->opa, draw_dsc->blend_mode);
   2026e:	41 0f b6 46 10       	movzbl 0x10(%r14),%eax
   20273:	48 83 ec 08          	sub    $0x8,%rsp
   20277:	45 0f b6 c7          	movzbl %r15b,%r8d
   2027b:	50                   	push   %rax
   2027c:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   20281:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
   20286:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
   2028b:	e8 91 f2 ff ff       	callq  1f521 <_lv_blend_map>
   20290:	58                   	pop    %rax
   20291:	5a                   	pop    %rdx
            _lv_mem_buf_release(mask_buf);
   20292:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   20297:	e8 31 60 00 00       	callq  262cd <_lv_mem_buf_release>
            _lv_mem_buf_release(map2);
   2029c:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
   202a1:	e8 27 60 00 00       	callq  262cd <_lv_mem_buf_release>
}
   202a6:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
   202ab:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   202b2:	00 00 
   202b4:	74 05                	je     202bb <lv_draw_map+0x67c>
   202b6:	e8 85 43 fe ff       	callq  4640 <__stack_chk_fail@plt>
   202bb:	48 83 c4 78          	add    $0x78,%rsp
   202bf:	5b                   	pop    %rbx
   202c0:	5d                   	pop    %rbp
   202c1:	41 5c                	pop    %r12
   202c3:	41 5d                	pop    %r13
   202c5:	41 5e                	pop    %r14
   202c7:	41 5f                	pop    %r15
   202c9:	c3                   	retq   

00000000000202ca <lv_draw_img_dsc_init>:
{
   202ca:	48 89 fa             	mov    %rdi,%rdx
   202cd:	b9 05 00 00 00       	mov    $0x5,%ecx
   202d2:	31 c0                	xor    %eax,%eax
   202d4:	f3 ab                	rep stos %eax,%es:(%rdi)
    dsc->recolor = LV_COLOR_BLACK;
   202d6:	c7 42 0c 00 00 00 ff 	movl   $0xff000000,0xc(%rdx)
    dsc->opa = LV_OPA_COVER;
   202dd:	c6 02 ff             	movb   $0xff,(%rdx)
    dsc->zoom = LV_IMG_ZOOM_NONE;
   202e0:	66 c7 42 08 00 01    	movw   $0x100,0x8(%rdx)
    dsc->antialias = LV_ANTIALIAS;
   202e6:	c6 42 11 00          	movb   $0x0,0x11(%rdx)
}
   202ea:	c3                   	retq   

00000000000202eb <lv_img_cf_get_px_size>:
{
   202eb:	83 ef 04             	sub    $0x4,%edi
   202ee:	31 c0                	xor    %eax,%eax
   202f0:	40 80 ff 0a          	cmp    $0xa,%dil
   202f4:	77 0e                	ja     20304 <lv_img_cf_get_px_size+0x19>
   202f6:	48 8d 05 fb 08 01 00 	lea    0x108fb(%rip),%rax        # 30bf8 <CSWTCH.26>
   202fd:	40 0f b6 ff          	movzbl %dil,%edi
   20301:	8a 04 38             	mov    (%rax,%rdi,1),%al
}
   20304:	c3                   	retq   

0000000000020305 <lv_img_cf_is_chroma_keyed>:
            is_chroma_keyed = false;
   20305:	31 c0                	xor    %eax,%eax
   20307:	40 80 ff 0a          	cmp    $0xa,%dil
   2030b:	77 13                	ja     20320 <lv_img_cf_is_chroma_keyed+0x1b>
   2030d:	b8 01 00 00 00       	mov    $0x1,%eax
   20312:	40 88 f9             	mov    %dil,%cl
   20315:	48 d3 e0             	shl    %cl,%rax
   20318:	a9 c8 07 00 00       	test   $0x7c8,%eax
   2031d:	0f 95 c0             	setne  %al
}
   20320:	c3                   	retq   

0000000000020321 <lv_img_cf_has_alpha>:
            has_alpha = false;
   20321:	31 c0                	xor    %eax,%eax
   20323:	40 80 ff 0e          	cmp    $0xe,%dil
   20327:	77 13                	ja     2033c <lv_img_cf_has_alpha+0x1b>
   20329:	b8 01 00 00 00       	mov    $0x1,%eax
   2032e:	40 88 f9             	mov    %dil,%cl
   20331:	48 d3 e0             	shl    %cl,%rax
   20334:	a9 a4 7f 00 00       	test   $0x7fa4,%eax
   20339:	0f 95 c0             	setne  %al
}
   2033c:	c3                   	retq   

000000000002033d <lv_draw_img>:
{
   2033d:	41 57                	push   %r15
   2033f:	41 56                	push   %r14
   20341:	41 55                	push   %r13
   20343:	41 54                	push   %r12
   20345:	49 89 f5             	mov    %rsi,%r13
   20348:	55                   	push   %rbp
   20349:	53                   	push   %rbx
   2034a:	48 89 fb             	mov    %rdi,%rbx
   2034d:	48 83 ec 48          	sub    $0x48,%rsp
   20351:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   20358:	00 00 
   2035a:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
   2035f:	31 c0                	xor    %eax,%eax
    if(src == NULL) {
   20361:	48 85 d2             	test   %rdx,%rdx
   20364:	75 24                	jne    2038a <lv_draw_img+0x4d>
        LV_LOG_WARN("Image draw: src is NULL");
   20366:	4c 8d 05 59 33 01 00 	lea    0x13359(%rip),%r8        # 336c6 <__func__.5785+0x2a5e>
   2036d:	48 8d 0d 94 08 01 00 	lea    0x10894(%rip),%rcx        # 30c08 <__func__.5676>
   20374:	ba 49 00 00 00       	mov    $0x49,%edx
   20379:	48 8d 35 5e 33 01 00 	lea    0x1335e(%rip),%rsi        # 336de <__func__.5785+0x2a76>
   20380:	bf 02 00 00 00       	mov    $0x2,%edi
   20385:	e9 9e 02 00 00       	jmpq   20628 <lv_draw_img+0x2eb>
    if(dsc->opa <= LV_OPA_MIN) return;
   2038a:	80 39 02             	cmpb   $0x2,(%rcx)
   2038d:	49 89 cc             	mov    %rcx,%r12
   20390:	0f 86 a9 02 00 00    	jbe    2063f <lv_draw_img+0x302>
    lv_img_cache_entry_t * cdsc = _lv_img_cache_open(src, draw_dsc->recolor);
   20396:	8b 71 0c             	mov    0xc(%rcx),%esi
   20399:	48 89 d7             	mov    %rdx,%rdi
   2039c:	e8 d4 3f 00 00       	callq  24375 <_lv_img_cache_open>
    if(cdsc == NULL) return LV_RES_INV;
   203a1:	48 85 c0             	test   %rax,%rax
    lv_img_cache_entry_t * cdsc = _lv_img_cache_open(src, draw_dsc->recolor);
   203a4:	48 89 c5             	mov    %rax,%rbp
    if(cdsc == NULL) return LV_RES_INV;
   203a7:	0f 84 5a 02 00 00    	je     20607 <lv_draw_img+0x2ca>
    bool chroma_keyed = lv_img_cf_is_chroma_keyed(cdsc->dec_dsc.header.cf);
   203ad:	40 8a 78 18          	mov    0x18(%rax),%dil
   203b1:	83 e7 1f             	and    $0x1f,%edi
   203b4:	e8 4c ff ff ff       	callq  20305 <lv_img_cf_is_chroma_keyed>
    bool alpha_byte   = lv_img_cf_has_alpha(cdsc->dec_dsc.header.cf);
   203b9:	40 8a 7d 18          	mov    0x18(%rbp),%dil
    bool chroma_keyed = lv_img_cf_is_chroma_keyed(cdsc->dec_dsc.header.cf);
   203bd:	88 44 24 02          	mov    %al,0x2(%rsp)
    bool alpha_byte   = lv_img_cf_has_alpha(cdsc->dec_dsc.header.cf);
   203c1:	83 e7 1f             	and    $0x1f,%edi
   203c4:	e8 58 ff ff ff       	callq  20321 <lv_img_cf_has_alpha>
    if(cdsc->dec_dsc.error_msg != NULL) {
   203c9:	48 83 7d 30 00       	cmpq   $0x0,0x30(%rbp)
    bool alpha_byte   = lv_img_cf_has_alpha(cdsc->dec_dsc.header.cf);
   203ce:	88 44 24 03          	mov    %al,0x3(%rsp)
    if(cdsc->dec_dsc.error_msg != NULL) {
   203d2:	74 2f                	je     20403 <lv_draw_img+0xc6>
        LV_LOG_WARN("Image draw error");
   203d4:	4c 8d 05 45 33 01 00 	lea    0x13345(%rip),%r8        # 33720 <__func__.5785+0x2ab8>
   203db:	48 8d 0d ce 05 01 00 	lea    0x105ce(%rip),%rcx        # 309b0 <__func__.5740>
   203e2:	48 8d 35 f5 32 01 00 	lea    0x132f5(%rip),%rsi        # 336de <__func__.5785+0x2a76>
   203e9:	ba f3 00 00 00       	mov    $0xf3,%edx
   203ee:	bf 02 00 00 00       	mov    $0x2,%edi
   203f3:	31 c0                	xor    %eax,%eax
   203f5:	e8 5c 5b 00 00       	callq  25f56 <_lv_log_add>
        show_error(coords, clip_area, cdsc->dec_dsc.error_msg);
   203fa:	48 8b 55 30          	mov    0x30(%rbp),%rdx
   203fe:	e9 31 02 00 00       	jmpq   20634 <lv_draw_img+0x2f7>
    else if(cdsc->dec_dsc.img_data) {
   20403:	48 83 7d 20 00       	cmpq   $0x0,0x20(%rbp)
   20408:	0f 84 a7 00 00 00    	je     204b5 <lv_draw_img+0x178>
        if(draw_dsc->angle || draw_dsc->zoom != LV_IMG_ZOOM_NONE) {
   2040e:	41 0f bf 4c 24 02    	movswl 0x2(%r12),%ecx
   20414:	48 8b 03             	mov    (%rbx),%rax
   20417:	4c 8d 74 24 28       	lea    0x28(%rsp),%r14
   2041c:	45 0f b7 44 24 08    	movzwl 0x8(%r12),%r8d
   20422:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
   20427:	66 85 c9             	test   %cx,%cx
   2042a:	75 08                	jne    20434 <lv_draw_img+0xf7>
   2042c:	66 41 81 f8 00 01    	cmp    $0x100,%r8w
   20432:	74 43                	je     20477 <lv_draw_img+0x13a>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   20434:	66 8b 43 06          	mov    0x6(%rbx),%ax
            _lv_img_buf_get_transformed_area(&map_area_rot, w, h, draw_dsc->angle, draw_dsc->zoom, &draw_dsc->pivot);
   20438:	4d 8d 4c 24 04       	lea    0x4(%r12),%r9
   2043d:	4c 89 f7             	mov    %r14,%rdi
   20440:	8d 50 01             	lea    0x1(%rax),%edx
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   20443:	66 8b 43 04          	mov    0x4(%rbx),%ax
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   20447:	66 2b 53 02          	sub    0x2(%rbx),%dx
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   2044b:	8d 70 01             	lea    0x1(%rax),%esi
   2044e:	66 2b 33             	sub    (%rbx),%si
            int32_t h = lv_area_get_height(coords);
   20451:	0f bf d2             	movswl %dx,%edx
            int32_t w = lv_area_get_width(coords);
   20454:	0f bf f6             	movswl %si,%esi
            _lv_img_buf_get_transformed_area(&map_area_rot, w, h, draw_dsc->angle, draw_dsc->zoom, &draw_dsc->pivot);
   20457:	e8 ff 3e 00 00       	callq  2435b <_lv_img_buf_get_transformed_area>
            map_area_rot.x1 += coords->x1;
   2045c:	66 8b 13             	mov    (%rbx),%dx
            map_area_rot.y1 += coords->y1;
   2045f:	66 8b 43 02          	mov    0x2(%rbx),%ax
            map_area_rot.x1 += coords->x1;
   20463:	66 01 54 24 28       	add    %dx,0x28(%rsp)
            map_area_rot.y1 += coords->y1;
   20468:	66 01 44 24 2a       	add    %ax,0x2a(%rsp)
            map_area_rot.x2 += coords->x1;
   2046d:	66 01 54 24 2c       	add    %dx,0x2c(%rsp)
            map_area_rot.y2 += coords->y1;
   20472:	66 01 44 24 2e       	add    %ax,0x2e(%rsp)
        union_ok = _lv_area_intersect(&mask_com, clip_area, &map_area_rot);
   20477:	4c 8d 7c 24 30       	lea    0x30(%rsp),%r15
   2047c:	4c 89 f2             	mov    %r14,%rdx
   2047f:	4c 89 ee             	mov    %r13,%rsi
   20482:	4c 89 ff             	mov    %r15,%rdi
   20485:	e8 92 50 00 00       	callq  2551c <_lv_area_intersect>
        if(union_ok == false) {
   2048a:	84 c0                	test   %al,%al
   2048c:	0f 84 ad 01 00 00    	je     2063f <lv_draw_img+0x302>
        lv_draw_map(coords, &mask_com, cdsc->dec_dsc.img_data, draw_dsc, chroma_keyed, alpha_byte);
   20492:	44 0f b6 4c 24 03    	movzbl 0x3(%rsp),%r9d
   20498:	44 0f b6 44 24 02    	movzbl 0x2(%rsp),%r8d
   2049e:	4c 89 e1             	mov    %r12,%rcx
   204a1:	48 8b 55 20          	mov    0x20(%rbp),%rdx
   204a5:	4c 89 fe             	mov    %r15,%rsi
   204a8:	48 89 df             	mov    %rbx,%rdi
   204ab:	e8 8f f7 ff ff       	callq  1fc3f <lv_draw_map>
   204b0:	e9 8a 01 00 00       	jmpq   2063f <lv_draw_img+0x302>
        union_ok = _lv_area_intersect(&mask_com, clip_area, coords);
   204b5:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
   204ba:	48 89 da             	mov    %rbx,%rdx
   204bd:	4c 89 ee             	mov    %r13,%rsi
   204c0:	e8 57 50 00 00       	callq  2551c <_lv_area_intersect>
        if(union_ok == false) {
   204c5:	84 c0                	test   %al,%al
   204c7:	0f 84 72 01 00 00    	je     2063f <lv_draw_img+0x302>
   204cd:	8b 44 24 24          	mov    0x24(%rsp),%eax
   204d1:	ff c0                	inc    %eax
   204d3:	2b 44 24 20          	sub    0x20(%rsp),%eax
        int32_t width = lv_area_get_width(&mask_com);
   204d7:	98                   	cwtl   
        uint8_t  * buf = _lv_mem_buf_get(lv_area_get_width(&mask_com) *
   204d8:	8d 3c 85 00 00 00 00 	lea    0x0(,%rax,4),%edi
        int32_t width = lv_area_get_width(&mask_com);
   204df:	89 44 24 04          	mov    %eax,0x4(%rsp)
        uint8_t  * buf = _lv_mem_buf_get(lv_area_get_width(&mask_com) *
   204e3:	e8 f6 5c 00 00       	callq  261de <_lv_mem_buf_get>
   204e8:	49 89 c6             	mov    %rax,%r14
   204eb:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
        lv_area_set_height(&line, 1);
   204f0:	be 01 00 00 00       	mov    $0x1,%esi
   204f5:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
   204fa:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
   204ff:	48 89 c7             	mov    %rax,%rdi
   20502:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   20507:	e8 e8 4f 00 00       	callq  254f4 <lv_area_set_height>
        int32_t x = mask_com.x1 - coords->x1;
   2050c:	8b 44 24 20          	mov    0x20(%rsp),%eax
        int32_t y = mask_com.y1 - coords->y1;
   20510:	44 0f bf 7c 24 22    	movswl 0x22(%rsp),%r15d
   20516:	0f bf 53 02          	movswl 0x2(%rbx),%edx
        int32_t x = mask_com.x1 - coords->x1;
   2051a:	66 89 44 24 1c       	mov    %ax,0x1c(%rsp)
   2051f:	66 8b 03             	mov    (%rbx),%ax
   20522:	66 89 44 24 1e       	mov    %ax,0x1e(%rsp)
        int32_t y = mask_com.y1 - coords->y1;
   20527:	44 89 f8             	mov    %r15d,%eax
   2052a:	29 d0                	sub    %edx,%eax
   2052c:	89 44 24 18          	mov    %eax,0x18(%rsp)
            union_ok = _lv_area_intersect(&mask_line, clip_area, &line);
   20530:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   20535:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
        for(row = mask_com.y1; row <= mask_com.y2; row++) {
   2053a:	0f bf 44 24 26       	movswl 0x26(%rsp),%eax
   2053f:	41 39 c7             	cmp    %eax,%r15d
   20542:	0f 8f b5 00 00 00    	jg     205fd <lv_draw_img+0x2c0>
            union_ok = _lv_area_intersect(&mask_line, clip_area, &line);
   20548:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
   2054d:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
   20552:	4c 89 ee             	mov    %r13,%rsi
   20555:	48 89 c7             	mov    %rax,%rdi
   20558:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   2055d:	e8 ba 4f 00 00       	callq  2551c <_lv_area_intersect>
            if(union_ok == false) continue;
   20562:	84 c0                	test   %al,%al
   20564:	0f 84 8b 00 00 00    	je     205f5 <lv_draw_img+0x2b8>
            read_res = lv_img_decoder_read_line(&cdsc->dec_dsc, x, y, width, buf);
   2056a:	8b 74 24 1c          	mov    0x1c(%rsp),%esi
   2056e:	66 2b 74 24 1e       	sub    0x1e(%rsp),%si
   20573:	4d 89 f0             	mov    %r14,%r8
   20576:	0f bf 54 24 18       	movswl 0x18(%rsp),%edx
   2057b:	8b 4c 24 04          	mov    0x4(%rsp),%ecx
   2057f:	48 89 ef             	mov    %rbp,%rdi
   20582:	0f bf f6             	movswl %si,%esi
   20585:	e8 31 49 00 00       	callq  24ebb <lv_img_decoder_read_line>
            if(read_res != LV_RES_OK) {
   2058a:	fe c8                	dec    %al
   2058c:	74 38                	je     205c6 <lv_draw_img+0x289>
                lv_img_decoder_close(&cdsc->dec_dsc);
   2058e:	48 89 ef             	mov    %rbp,%rdi
   20591:	e8 4c 49 00 00       	callq  24ee2 <lv_img_decoder_close>
                LV_LOG_WARN("Image draw can't read the line");
   20596:	4c 8d 05 94 31 01 00 	lea    0x13194(%rip),%r8        # 33731 <__func__.5785+0x2ac9>
   2059d:	48 8d 0d 0c 04 01 00 	lea    0x1040c(%rip),%rcx        # 309b0 <__func__.5740>
   205a4:	48 8d 35 33 31 01 00 	lea    0x13133(%rip),%rsi        # 336de <__func__.5785+0x2a76>
   205ab:	ba 30 01 00 00       	mov    $0x130,%edx
   205b0:	bf 02 00 00 00       	mov    $0x2,%edi
   205b5:	31 c0                	xor    %eax,%eax
   205b7:	e8 9a 59 00 00       	callq  25f56 <_lv_log_add>
                _lv_mem_buf_release(buf);
   205bc:	4c 89 f7             	mov    %r14,%rdi
   205bf:	e8 09 5d 00 00       	callq  262cd <_lv_mem_buf_release>
   205c4:	eb 41                	jmp    20607 <lv_draw_img+0x2ca>
            lv_draw_map(&line, &mask_line, buf, draw_dsc, chroma_keyed, alpha_byte);
   205c6:	44 0f b6 4c 24 03    	movzbl 0x3(%rsp),%r9d
   205cc:	44 0f b6 44 24 02    	movzbl 0x2(%rsp),%r8d
   205d2:	4c 89 e1             	mov    %r12,%rcx
   205d5:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   205da:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   205df:	4c 89 f2             	mov    %r14,%rdx
   205e2:	e8 58 f6 ff ff       	callq  1fc3f <lv_draw_map>
            line.y1++;
   205e7:	66 ff 44 24 2a       	incw   0x2a(%rsp)
            line.y2++;
   205ec:	66 ff 44 24 2e       	incw   0x2e(%rsp)
            y++;
   205f1:	ff 44 24 18          	incl   0x18(%rsp)
        for(row = mask_com.y1; row <= mask_com.y2; row++) {
   205f5:	41 ff c7             	inc    %r15d
   205f8:	e9 3d ff ff ff       	jmpq   2053a <lv_draw_img+0x1fd>
        _lv_mem_buf_release(buf);
   205fd:	4c 89 f7             	mov    %r14,%rdi
   20600:	e8 c8 5c 00 00       	callq  262cd <_lv_mem_buf_release>
   20605:	eb 38                	jmp    2063f <lv_draw_img+0x302>
        LV_LOG_WARN("Image draw error");
   20607:	4c 8d 05 12 31 01 00 	lea    0x13112(%rip),%r8        # 33720 <__func__.5785+0x2ab8>
   2060e:	48 8d 0d f3 05 01 00 	lea    0x105f3(%rip),%rcx        # 30c08 <__func__.5676>
   20615:	48 8d 35 c2 30 01 00 	lea    0x130c2(%rip),%rsi        # 336de <__func__.5785+0x2a76>
   2061c:	ba 54 00 00 00       	mov    $0x54,%edx
   20621:	bf 02 00 00 00       	mov    $0x2,%edi
   20626:	31 c0                	xor    %eax,%eax
   20628:	e8 29 59 00 00       	callq  25f56 <_lv_log_add>
        show_error(coords, mask, "No\ndata");
   2062d:	48 8d 15 e4 30 01 00 	lea    0x130e4(%rip),%rdx        # 33718 <__func__.5785+0x2ab0>
   20634:	4c 89 ee             	mov    %r13,%rsi
   20637:	48 89 df             	mov    %rbx,%rdi
   2063a:	e8 6f f5 ff ff       	callq  1fbae <show_error>
}
   2063f:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
   20644:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   2064b:	00 00 
   2064d:	74 05                	je     20654 <lv_draw_img+0x317>
   2064f:	e8 ec 3f fe ff       	callq  4640 <__stack_chk_fail@plt>
   20654:	48 83 c4 48          	add    $0x48,%rsp
   20658:	5b                   	pop    %rbx
   20659:	5d                   	pop    %rbp
   2065a:	41 5c                	pop    %r12
   2065c:	41 5d                	pop    %r13
   2065e:	41 5e                	pop    %r14
   20660:	41 5f                	pop    %r15
   20662:	c3                   	retq   

0000000000020663 <lv_img_src_get_type>:
    if(src == NULL) return img_src_type;
   20663:	48 85 ff             	test   %rdi,%rdi
   20666:	b0 03                	mov    $0x3,%al
   20668:	74 13                	je     2067d <lv_img_src_get_type+0x1a>
    if(u8_p[0] >= 0x20 && u8_p[0] <= 0x7F) {
   2066a:	8a 17                	mov    (%rdi),%dl
        img_src_type = LV_IMG_SRC_FILE; /*If it's an ASCII character then it's file name*/
   2066c:	b0 01                	mov    $0x1,%al
    if(u8_p[0] >= 0x20 && u8_p[0] <= 0x7F) {
   2066e:	8d 4a e0             	lea    -0x20(%rdx),%ecx
   20671:	80 f9 5f             	cmp    $0x5f,%cl
   20674:	76 07                	jbe    2067d <lv_img_src_get_type+0x1a>
        img_src_type = LV_IMG_SRC_SYMBOL; /*Symbols begins after 0x7F*/
   20676:	88 d0                	mov    %dl,%al
   20678:	c0 e8 07             	shr    $0x7,%al
   2067b:	01 c0                	add    %eax,%eax
}
   2067d:	c3                   	retq   

000000000002067e <hex_char_to_num>:
 */
static uint8_t hex_char_to_num(char hex)
{
    uint8_t result = 0;

    if(hex >= '0' && hex <= '9') {
   2067e:	8d 47 d0             	lea    -0x30(%rdi),%eax
{
   20681:	40 88 fa             	mov    %dil,%dl
    if(hex >= '0' && hex <= '9') {
   20684:	3c 09                	cmp    $0x9,%al
   20686:	76 20                	jbe    206a8 <hex_char_to_num+0x2a>
        result = hex - '0';
    }
    else {
        if(hex >= 'a') hex -= 'a' - 'A'; /*Convert to upper case*/
   20688:	40 80 ff 60          	cmp    $0x60,%dil
   2068c:	7e 03                	jle    20691 <hex_char_to_num+0x13>
   2068e:	8d 57 e0             	lea    -0x20(%rdi),%edx
   20691:	83 ea 41             	sub    $0x41,%edx

        switch(hex) {
   20694:	31 c0                	xor    %eax,%eax
   20696:	80 fa 05             	cmp    $0x5,%dl
   20699:	77 0d                	ja     206a8 <hex_char_to_num+0x2a>
   2069b:	48 8d 05 a9 31 01 00 	lea    0x131a9(%rip),%rax        # 3384b <CSWTCH.36>
   206a2:	0f b6 d2             	movzbl %dl,%edx
   206a5:	8a 04 10             	mov    (%rax,%rdx,1),%al
                break;
        }
    }

    return result;
}
   206a8:	c3                   	retq   

00000000000206a9 <lv_draw_label_dsc_init>:
   206a9:	48 8d 77 10          	lea    0x10(%rdi),%rsi
{
   206ad:	48 89 fa             	mov    %rdi,%rdx
   206b0:	31 c0                	xor    %eax,%eax
   206b2:	b9 06 00 00 00       	mov    $0x6,%ecx
   206b7:	48 89 f7             	mov    %rsi,%rdi
   206ba:	f3 ab                	rep stos %eax,%es:(%rdi)
    dsc->font = LV_THEME_DEFAULT_FONT_NORMAL;
   206bc:	48 8d 05 1d 62 21 00 	lea    0x21621d(%rip),%rax        # 2368e0 <lv_font_montserrat_14>
    dsc->opa = LV_OPA_COVER;
   206c3:	c6 42 10 ff          	movb   $0xff,0x10(%rdx)
    dsc->font = LV_THEME_DEFAULT_FONT_NORMAL;
   206c7:	48 89 42 08          	mov    %rax,0x8(%rdx)
    dsc->sel_start = LV_DRAW_LABEL_NO_TXT_SEL;
   206cb:	48 b8 ff ff 00 00 ff 	movabs $0xffff0000ffff,%rax
   206d2:	ff 00 00 
   206d5:	48 89 42 18          	mov    %rax,0x18(%rdx)
    dsc->color = LV_COLOR_BLACK;
   206d9:	48 b8 00 00 00 ff ff 	movabs $0xff0000ffff000000,%rax
   206e0:	00 00 ff 
   206e3:	48 89 02             	mov    %rax,(%rdx)
}
   206e6:	c3                   	retq   

00000000000206e7 <lv_draw_label>:
{
   206e7:	41 57                	push   %r15
   206e9:	41 56                	push   %r14
   206eb:	41 55                	push   %r13
   206ed:	41 54                	push   %r12
   206ef:	55                   	push   %rbp
   206f0:	53                   	push   %rbx
   206f1:	48 81 ec 78 01 00 00 	sub    $0x178,%rsp
   206f8:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   206ff:	00 00 
   20701:	48 89 84 24 68 01 00 	mov    %rax,0x168(%rsp)
   20708:	00 
   20709:	31 c0                	xor    %eax,%eax
    if(dsc->opa <= LV_OPA_MIN) return;
   2070b:	80 7a 10 02          	cmpb   $0x2,0x10(%rdx)
{
   2070f:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
   20714:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
    if(dsc->opa <= LV_OPA_MIN) return;
   20719:	0f 86 8d 0d 00 00    	jbe    214ac <lv_draw_label+0xdc5>
    if(txt[0] == '\0')  return;
   2071f:	80 39 00             	cmpb   $0x0,(%rcx)
   20722:	0f 84 84 0d 00 00    	je     214ac <lv_draw_label+0xdc5>
    const lv_font_t * font = dsc->font;
   20728:	48 8b 42 08          	mov    0x8(%rdx),%rax
   2072c:	49 89 ff             	mov    %rdi,%r15
    bool clip_ok = _lv_area_intersect(&clipped_area, coords, mask);
   2072f:	48 8d bc 24 b8 00 00 	lea    0xb8(%rsp),%rdi
   20736:	00 
   20737:	48 89 d3             	mov    %rdx,%rbx
   2073a:	48 89 f2             	mov    %rsi,%rdx
   2073d:	4c 89 fe             	mov    %r15,%rsi
   20740:	4d 89 c6             	mov    %r8,%r14
    const lv_font_t * font = dsc->font;
   20743:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    bool clip_ok = _lv_area_intersect(&clipped_area, coords, mask);
   20748:	e8 cf 4d 00 00       	callq  2551c <_lv_area_intersect>
    if(!clip_ok) return;
   2074d:	84 c0                	test   %al,%al
   2074f:	0f 84 57 0d 00 00    	je     214ac <lv_draw_label+0xdc5>
    if((dsc->flag & LV_TXT_FLAG_EXPAND) == 0) {
   20755:	0f b6 43 25          	movzbl 0x25(%rbx),%eax
   20759:	a8 02                	test   $0x2,%al
   2075b:	75 0e                	jne    2076b <lv_draw_label+0x84>
   2075d:	66 41 8b 47 04       	mov    0x4(%r15),%ax
   20762:	ff c0                	inc    %eax
   20764:	66 41 2b 07          	sub    (%r15),%ax
        w = lv_area_get_width(coords);
   20768:	98                   	cwtl   
   20769:	eb 35                	jmp    207a0 <lv_draw_label+0xb9>
        _lv_txt_get_size(&p, txt, dsc->font, dsc->letter_space, dsc->line_space, LV_COORD_MAX,
   2076b:	48 8d bc 24 e0 00 00 	lea    0xe0(%rsp),%rdi
   20772:	00 
   20773:	0f bf 4b 14          	movswl 0x14(%rbx),%ecx
   20777:	48 83 ec 08          	sub    $0x8,%rsp
   2077b:	44 0f bf 43 12       	movswl 0x12(%rbx),%r8d
   20780:	48 8b 53 08          	mov    0x8(%rbx),%rdx
   20784:	41 b9 18 7c 00 00    	mov    $0x7c18,%r9d
   2078a:	50                   	push   %rax
   2078b:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
   20790:	e8 65 67 00 00       	callq  26efa <_lv_txt_get_size>
   20795:	5f                   	pop    %rdi
   20796:	41 58                	pop    %r8
        w = p.x;
   20798:	0f bf 84 24 e0 00 00 	movswl 0xe0(%rsp),%eax
   2079f:	00 
   207a0:	89 44 24 64          	mov    %eax,0x64(%rsp)
    int32_t line_height_font = lv_font_get_line_height(font);
   207a4:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    int32_t line_height = line_height_font + dsc->line_space;
   207a9:	44 0f bf 6b 12       	movswl 0x12(%rbx),%r13d
    x_ofs = dsc->ofs_x;
   207ae:	8b 73 20             	mov    0x20(%rbx),%esi
    y_ofs = dsc->ofs_y;
   207b1:	66 8b 53 22          	mov    0x22(%rbx),%dx
    int32_t line_height_font = lv_font_get_line_height(font);
   207b5:	44 0f bf 60 10       	movswl 0x10(%rax),%r12d
    pos.x = coords->x1;
   207ba:	66 41 8b 07          	mov    (%r15),%ax
    x_ofs = dsc->ofs_x;
   207be:	66 89 b4 24 90 00 00 	mov    %si,0x90(%rsp)
   207c5:	00 
    pos.x = coords->x1;
   207c6:	66 89 44 24 36       	mov    %ax,0x36(%rsp)
    pos.y = coords->y1;
   207cb:	41 0f bf 47 02       	movswl 0x2(%r15),%eax
    int32_t line_height = line_height_font + dsc->line_space;
   207d0:	45 01 e5             	add    %r12d,%r13d
    if(hint && y_ofs == 0 && coords->y1 < 0) {
   207d3:	4d 85 f6             	test   %r14,%r14
   207d6:	40 0f 95 c5          	setne  %bpl
   207da:	89 c6                	mov    %eax,%esi
    pos.y += y_ofs;
   207dc:	8d 0c 10             	lea    (%rax,%rdx,1),%ecx
    if(hint && y_ofs == 0 && coords->y1 < 0) {
   207df:	66 c1 ee 0f          	shr    $0xf,%si
   207e3:	40 84 f5             	test   %sil,%bpl
   207e6:	74 2c                	je     20814 <lv_draw_label+0x12d>
   207e8:	66 85 d2             	test   %dx,%dx
   207eb:	75 27                	jne    20814 <lv_draw_label+0x12d>
        if(LV_MATH_ABS(hint->coord_y - coords->y1) > LV_LABEL_HINT_UPDATE_TH - 2 * line_height) {
   207ed:	41 8b 76 08          	mov    0x8(%r14),%esi
   207f1:	29 c6                	sub    %eax,%esi
   207f3:	89 f0                	mov    %esi,%eax
   207f5:	99                   	cltd   
   207f6:	31 d0                	xor    %edx,%eax
   207f8:	29 d0                	sub    %edx,%eax
   207fa:	ba 00 02 00 00       	mov    $0x200,%edx
   207ff:	44 29 ea             	sub    %r13d,%edx
   20802:	01 d2                	add    %edx,%edx
   20804:	39 d0                	cmp    %edx,%eax
   20806:	7e 07                	jle    2080f <lv_draw_label+0x128>
            hint->line_start = -1;
   20808:	41 c7 06 ff ff ff ff 	movl   $0xffffffff,(%r14)
        last_line_start = hint->line_start;
   2080f:	41 8b 06             	mov    (%r14),%eax
   20812:	eb 03                	jmp    20817 <lv_draw_label+0x130>
    int32_t last_line_start = -1;
   20814:	83 c8 ff             	or     $0xffffffff,%eax
    if(hint && last_line_start >= 0) {
   20817:	85 c0                	test   %eax,%eax
   20819:	78 05                	js     20820 <lv_draw_label+0x139>
   2081b:	40 84 ed             	test   %bpl,%bpl
   2081e:	75 0f                	jne    2082f <lv_draw_label+0x148>
    pos.y += y_ofs;
   20820:	66 89 4c 24 30       	mov    %cx,0x30(%rsp)
    uint32_t line_start     = 0;
   20825:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%rsp)
   2082c:	00 
   2082d:	eb 0d                	jmp    2083c <lv_draw_label+0x155>
        pos.y += hint->y;
   2082f:	41 03 4e 04          	add    0x4(%r14),%ecx
        line_start = last_line_start;
   20833:	89 44 24 20          	mov    %eax,0x20(%rsp)
        pos.y += hint->y;
   20837:	66 89 4c 24 30       	mov    %cx,0x30(%rsp)
    uint32_t line_end = line_start + _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);
   2083c:	8b 7c 24 20          	mov    0x20(%rsp),%edi
   20840:	0f bf 53 14          	movswl 0x14(%rbx),%edx
   20844:	48 03 7c 24 28       	add    0x28(%rsp),%rdi
   20849:	44 0f b6 43 25       	movzbl 0x25(%rbx),%r8d
   2084e:	8b 4c 24 64          	mov    0x64(%rsp),%ecx
   20852:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   20857:	e8 cd 63 00 00       	callq  26c29 <_lv_txt_get_next_line>
   2085c:	03 44 24 20          	add    0x20(%rsp),%eax
    while(pos.y + line_height_font < mask->y1) {
   20860:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   20865:	0f bf 54 24 30       	movswl 0x30(%rsp),%edx
   2086a:	44 0f b6 43 25       	movzbl 0x25(%rbx),%r8d
        line_end += _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);
   2086f:	89 44 24 1c          	mov    %eax,0x1c(%rsp)
    while(pos.y + line_height_font < mask->y1) {
   20873:	0f bf 4f 02          	movswl 0x2(%rdi),%ecx
   20877:	44 01 e2             	add    %r12d,%edx
   2087a:	44 89 c0             	mov    %r8d,%eax
   2087d:	39 ca                	cmp    %ecx,%edx
   2087f:	7d 7c                	jge    208fd <lv_draw_label+0x216>
        line_end += _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);
   20881:	8b 44 24 1c          	mov    0x1c(%rsp),%eax
   20885:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
   2088a:	0f bf 53 14          	movswl 0x14(%rbx),%edx
   2088e:	8b 4c 24 64          	mov    0x64(%rsp),%ecx
   20892:	4c 8d 0c 06          	lea    (%rsi,%rax,1),%r9
   20896:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   2089b:	4c 89 cf             	mov    %r9,%rdi
   2089e:	4c 89 4c 24 20       	mov    %r9,0x20(%rsp)
   208a3:	e8 81 63 00 00       	callq  26c29 <_lv_txt_get_next_line>
   208a8:	66 44 01 6c 24 30    	add    %r13w,0x30(%rsp)
   208ae:	03 44 24 1c          	add    0x1c(%rsp),%eax
        if(hint && pos.y >= -LV_LABEL_HINT_UPDATE_TH && hint->line_start < 0) {
   208b2:	66 81 7c 24 30 00 fc 	cmpw   $0xfc00,0x30(%rsp)
   208b9:	4c 8b 4c 24 20       	mov    0x20(%rsp),%r9
   208be:	7c 26                	jl     208e6 <lv_draw_label+0x1ff>
   208c0:	40 84 ed             	test   %bpl,%bpl
   208c3:	74 21                	je     208e6 <lv_draw_label+0x1ff>
   208c5:	41 83 3e 00          	cmpl   $0x0,(%r14)
   208c9:	79 1b                	jns    208e6 <lv_draw_label+0x1ff>
            hint->y          = pos.y - coords->y1;
   208cb:	41 0f bf 4f 02       	movswl 0x2(%r15),%ecx
   208d0:	0f bf 54 24 30       	movswl 0x30(%rsp),%edx
            hint->line_start = line_start;
   208d5:	8b 7c 24 1c          	mov    0x1c(%rsp),%edi
            hint->y          = pos.y - coords->y1;
   208d9:	29 ca                	sub    %ecx,%edx
            hint->line_start = line_start;
   208db:	41 89 3e             	mov    %edi,(%r14)
            hint->coord_y    = coords->y1;
   208de:	41 89 4e 08          	mov    %ecx,0x8(%r14)
            hint->y          = pos.y - coords->y1;
   208e2:	41 89 56 04          	mov    %edx,0x4(%r14)
        if(txt[line_start] == '\0') return;
   208e6:	41 80 39 00          	cmpb   $0x0,(%r9)
   208ea:	8b 7c 24 1c          	mov    0x1c(%rsp),%edi
   208ee:	89 7c 24 20          	mov    %edi,0x20(%rsp)
   208f2:	0f 85 68 ff ff ff    	jne    20860 <lv_draw_label+0x179>
   208f8:	e9 af 0b 00 00       	jmpq   214ac <lv_draw_label+0xdc5>
   208fd:	8b 7c 24 20          	mov    0x20(%rsp),%edi
   20901:	48 03 7c 24 28       	add    0x28(%rsp),%rdi
    if(dsc->flag & LV_TXT_FLAG_CENTER) {
   20906:	a8 04                	test   $0x4,%al
   20908:	74 39                	je     20943 <lv_draw_label+0x25c>
        line_width = _lv_txt_get_width(&txt[line_start], line_end - line_start, font, dsc->letter_space, dsc->flag);
   2090a:	0f bf 4b 14          	movswl 0x14(%rbx),%ecx
   2090e:	8b 74 24 1c          	mov    0x1c(%rsp),%esi
   20912:	2b 74 24 20          	sub    0x20(%rsp),%esi
   20916:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   2091b:	e8 0d 62 00 00       	callq  26b2d <_lv_txt_get_width>
   20920:	66 41 8b 7f 04       	mov    0x4(%r15),%di
   20925:	98                   	cwtl   
        pos.x += (lv_area_get_width(coords) - line_width) / 2;
   20926:	b9 02 00 00 00       	mov    $0x2,%ecx
   2092b:	8d 57 01             	lea    0x1(%rdi),%edx
   2092e:	66 41 2b 17          	sub    (%r15),%dx
   20932:	0f bf d2             	movswl %dx,%edx
   20935:	29 c2                	sub    %eax,%edx
   20937:	89 d0                	mov    %edx,%eax
   20939:	99                   	cltd   
   2093a:	f7 f9                	idiv   %ecx
   2093c:	66 01 44 24 36       	add    %ax,0x36(%rsp)
   20941:	eb 32                	jmp    20975 <lv_draw_label+0x28e>
    else if(dsc->flag & LV_TXT_FLAG_RIGHT) {
   20943:	a8 08                	test   $0x8,%al
   20945:	74 2e                	je     20975 <lv_draw_label+0x28e>
        line_width = _lv_txt_get_width(&txt[line_start], line_end - line_start, font, dsc->letter_space, dsc->flag);
   20947:	8b 74 24 1c          	mov    0x1c(%rsp),%esi
   2094b:	0f bf 4b 14          	movswl 0x14(%rbx),%ecx
   2094f:	2b 74 24 20          	sub    0x20(%rsp),%esi
   20953:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   20958:	e8 d0 61 00 00       	callq  26b2d <_lv_txt_get_width>
   2095d:	66 41 8b 7f 04       	mov    0x4(%r15),%di
   20962:	8d 57 01             	lea    0x1(%rdi),%edx
   20965:	66 41 2b 17          	sub    (%r15),%dx
        pos.x += lv_area_get_width(coords) - line_width;
   20969:	66 03 54 24 36       	add    0x36(%rsp),%dx
   2096e:	29 c2                	sub    %eax,%edx
   20970:	66 89 54 24 36       	mov    %dx,0x36(%rsp)
    lv_opa_t opa = dsc->opa;
   20975:	8a 43 10             	mov    0x10(%rbx),%al
   20978:	88 84 24 92 00 00 00 	mov    %al,0x92(%rsp)
    uint32_t sel_start = dsc->sel_start;
   2097f:	8b 43 18             	mov    0x18(%rbx),%eax
   20982:	89 44 24 40          	mov    %eax,0x40(%rsp)
    uint32_t sel_end = dsc->sel_end;
   20986:	8b 43 1c             	mov    0x1c(%rbx),%eax
    if(sel_start > sel_end) {
   20989:	39 44 24 40          	cmp    %eax,0x40(%rsp)
    uint32_t sel_end = dsc->sel_end;
   2098d:	89 44 24 3c          	mov    %eax,0x3c(%rsp)
    if(sel_start > sel_end) {
   20991:	77 0c                	ja     2099f <lv_draw_label+0x2b8>
   20993:	8b 74 24 40          	mov    0x40(%rsp),%esi
   20997:	89 44 24 40          	mov    %eax,0x40(%rsp)
   2099b:	89 74 24 3c          	mov    %esi,0x3c(%rsp)
    if((dsc->decor & LV_TEXT_DECOR_UNDERLINE) || (dsc->decor & LV_TEXT_DECOR_STRIKETHROUGH)) {
   2099f:	f6 43 26 03          	testb  $0x3,0x26(%rbx)
   209a3:	74 54                	je     209f9 <lv_draw_label+0x312>
        lv_draw_line_dsc_init(&line_dsc);
   209a5:	48 8d bc 24 c8 00 00 	lea    0xc8(%rsp),%rdi
   209ac:	00 
   209ad:	e8 24 0b 00 00       	callq  214d6 <lv_draw_line_dsc_init>
        line_dsc.color = dsc->color;
   209b2:	8b 03                	mov    (%rbx),%eax
   209b4:	89 84 24 c8 00 00 00 	mov    %eax,0xc8(%rsp)
        line_dsc.width = font->underline_thickness ? font->underline_thickness : 1;
   209bb:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   209c0:	66 0f be 40 16       	movsbw 0x16(%rax),%ax
   209c5:	84 c0                	test   %al,%al
   209c7:	75 05                	jne    209ce <lv_draw_label+0x2e7>
   209c9:	b8 01 00 00 00       	mov    $0x1,%eax
   209ce:	66 89 84 24 cc 00 00 	mov    %ax,0xcc(%rsp)
   209d5:	00 
        line_dsc.opa = dsc->opa;
   209d6:	8a 43 10             	mov    0x10(%rbx),%al
        line_dsc.blend_mode = dsc->blend_mode;
   209d9:	8a 53 27             	mov    0x27(%rbx),%dl
        line_dsc.opa = dsc->opa;
   209dc:	88 84 24 d2 00 00 00 	mov    %al,0xd2(%rsp)
        line_dsc.blend_mode = dsc->blend_mode;
   209e3:	8a 84 24 d3 00 00 00 	mov    0xd3(%rsp),%al
   209ea:	83 e2 03             	and    $0x3,%edx
   209ed:	83 e0 fc             	and    $0xfffffffc,%eax
   209f0:	09 d0                	or     %edx,%eax
   209f2:	88 84 24 d3 00 00 00 	mov    %al,0xd3(%rsp)
    lv_draw_rect_dsc_init(&draw_dsc_sel);
   209f9:	48 8d bc 24 e0 00 00 	lea    0xe0(%rsp),%rdi
   20a00:	00 
   20a01:	e8 3b 27 00 00       	callq  23141 <lv_draw_rect_dsc_init>
    draw_dsc_sel.bg_color = dsc->sel_color;
   20a06:	8b 43 04             	mov    0x4(%rbx),%eax
   20a09:	80 bc 24 92 00 00 00 	cmpb   $0xfd,0x92(%rsp)
   20a10:	fd 
   20a11:	0f b6 bc 24 92 00 00 	movzbl 0x92(%rsp),%edi
   20a18:	00 
    while(txt[line_start] != '\0') {
   20a19:	66 44 8b 64 24 36    	mov    0x36(%rsp),%r12w
   20a1f:	66 44 89 6c 24 7c    	mov    %r13w,0x7c(%rsp)
    uint32_t par_start = 0;
   20a25:	c7 44 24 6c 00 00 00 	movl   $0x0,0x6c(%rsp)
   20a2c:	00 
    draw_dsc_sel.bg_color = dsc->sel_color;
   20a2d:	89 84 24 e4 00 00 00 	mov    %eax,0xe4(%rsp)
   20a34:	b8 ff 00 00 00       	mov    $0xff,%eax
   20a39:	0f 46 c7             	cmovbe %edi,%eax
   20a3c:	88 44 24 69          	mov    %al,0x69(%rsp)
        draw_letter_normal(pos_x, pos_y, &g, clip_area, map_p, color, opa, blend_mode);
   20a40:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%rsp)
   20a47:	8b 44 24 30          	mov    0x30(%rsp),%eax
   20a4b:	66 89 44 24 7e       	mov    %ax,0x7e(%rsp)
    while(txt[line_start] != '\0') {
   20a50:	8b 44 24 20          	mov    0x20(%rsp),%eax
   20a54:	48 03 44 24 28       	add    0x28(%rsp),%rax
   20a59:	80 38 00             	cmpb   $0x0,(%rax)
   20a5c:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
   20a61:	0f 84 45 0a 00 00    	je     214ac <lv_draw_label+0xdc5>
        pos.x += x_ofs;
   20a67:	44 03 a4 24 90 00 00 	add    0x90(%rsp),%r12d
   20a6e:	00 
        i         = 0;
   20a6f:	c7 84 24 b4 00 00 00 	movl   $0x0,0xb4(%rsp)
   20a76:	00 00 00 00 
        pos.x += x_ofs;
   20a7a:	66 44 89 64 24 34    	mov    %r12w,0x34(%rsp)
                        cmd_state = CMD_STATE_WAIT;
   20a80:	c6 44 24 33 00       	movb   $0x0,0x33(%rsp)
        while(i < line_end - line_start) {
   20a85:	8b 44 24 1c          	mov    0x1c(%rsp),%eax
   20a89:	2b 44 24 20          	sub    0x20(%rsp),%eax
   20a8d:	8b b4 24 b4 00 00 00 	mov    0xb4(%rsp),%esi
   20a94:	39 f0                	cmp    %esi,%eax
   20a96:	0f 86 9b 02 00 00    	jbe    20d37 <lv_draw_label+0x650>
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
   20a9c:	81 7c 24 3c ff ff 00 	cmpl   $0xffff,0x3c(%rsp)
   20aa3:	00 
   20aa4:	41 0f 95 c4          	setne  %r12b
   20aa8:	81 7c 24 40 ff ff 00 	cmpl   $0xffff,0x40(%rsp)
   20aaf:	00 
   20ab0:	0f 95 c0             	setne  %al
            uint32_t logical_char_pos = 0;
   20ab3:	45 31 ed             	xor    %r13d,%r13d
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
   20ab6:	41 20 c4             	and    %al,%r12b
   20ab9:	74 15                	je     20ad0 <lv_draw_label+0x3e9>
                logical_char_pos = _lv_txt_encoded_get_char_id(txt, line_start + i);
   20abb:	48 8d 05 be 5f 21 00 	lea    0x215fbe(%rip),%rax        # 236a80 <_lv_txt_encoded_get_char_id>
   20ac2:	03 74 24 20          	add    0x20(%rsp),%esi
   20ac6:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
   20acb:	ff 10                	callq  *(%rax)
   20acd:	41 89 c5             	mov    %eax,%r13d
            uint32_t letter      = _lv_txt_encoded_next(bidi_txt, &i);
   20ad0:	4c 8d 35 c1 5f 21 00 	lea    0x215fc1(%rip),%r14        # 236a98 <_lv_txt_encoded_next>
   20ad7:	48 8d b4 24 b4 00 00 	lea    0xb4(%rsp),%rsi
   20ade:	00 
   20adf:	48 8b 7c 24 58       	mov    0x58(%rsp),%rdi
   20ae4:	41 ff 16             	callq  *(%r14)
            uint32_t letter_next = _lv_txt_encoded_next(&bidi_txt[i], NULL);
   20ae7:	8b bc 24 b4 00 00 00 	mov    0xb4(%rsp),%edi
   20aee:	31 f6                	xor    %esi,%esi
            uint32_t letter      = _lv_txt_encoded_next(bidi_txt, &i);
   20af0:	89 c5                	mov    %eax,%ebp
            uint32_t letter_next = _lv_txt_encoded_next(&bidi_txt[i], NULL);
   20af2:	48 03 7c 24 58       	add    0x58(%rsp),%rdi
   20af7:	41 ff 16             	callq  *(%r14)
            if((dsc->flag & LV_TXT_FLAG_RECOLOR) != 0) {
   20afa:	f6 43 25 01          	testb  $0x1,0x25(%rbx)
   20afe:	0f 84 3a 01 00 00    	je     20c3e <lv_draw_label+0x557>
                if(letter == (uint32_t)LV_TXT_COLOR_CMD[0]) {
   20b04:	83 fd 23             	cmp    $0x23,%ebp
   20b07:	75 37                	jne    20b40 <lv_draw_label+0x459>
                    if(cmd_state == CMD_STATE_WAIT) { /*Start char*/
   20b09:	80 7c 24 33 00       	cmpb   $0x0,0x33(%rsp)
   20b0e:	75 15                	jne    20b25 <lv_draw_label+0x43e>
                        par_start = i;
   20b10:	8b 84 24 b4 00 00 00 	mov    0xb4(%rsp),%eax
                        cmd_state = CMD_STATE_PAR;
   20b17:	c6 44 24 33 01       	movb   $0x1,0x33(%rsp)
                        par_start = i;
   20b1c:	89 44 24 6c          	mov    %eax,0x6c(%rsp)
                        continue;
   20b20:	e9 60 ff ff ff       	jmpq   20a85 <lv_draw_label+0x39e>
                    else if(cmd_state == CMD_STATE_PAR) {   /*Other start char in parameter escaped cmd. char */
   20b25:	80 7c 24 33 01       	cmpb   $0x1,0x33(%rsp)
   20b2a:	0f 84 01 01 00 00    	je     20c31 <lv_draw_label+0x54a>
                    else if(cmd_state == CMD_STATE_IN) {   /*Command end */
   20b30:	80 7c 24 33 02       	cmpb   $0x2,0x33(%rsp)
   20b35:	0f 85 03 01 00 00    	jne    20c3e <lv_draw_label+0x557>
   20b3b:	e9 40 ff ff ff       	jmpq   20a80 <lv_draw_label+0x399>
                if(cmd_state == CMD_STATE_PAR) {
   20b40:	80 7c 24 33 01       	cmpb   $0x1,0x33(%rsp)
   20b45:	0f 85 f3 00 00 00    	jne    20c3e <lv_draw_label+0x557>
                    if(letter == ' ') {
   20b4b:	83 fd 20             	cmp    $0x20,%ebp
   20b4e:	0f 85 31 ff ff ff    	jne    20a85 <lv_draw_label+0x39e>
                        if(i - par_start == LABEL_RECOLOR_PAR_LENGTH + 1) {
   20b54:	8b 84 24 b4 00 00 00 	mov    0xb4(%rsp),%eax
   20b5b:	2b 44 24 6c          	sub    0x6c(%rsp),%eax
   20b5f:	83 f8 07             	cmp    $0x7,%eax
   20b62:	0f 85 b6 00 00 00    	jne    20c1e <lv_draw_label+0x537>
                            _lv_memcpy_small(buf, &bidi_txt[par_start], LABEL_RECOLOR_PAR_LENGTH);
   20b68:	8b 44 24 6c          	mov    0x6c(%rsp),%eax
   20b6c:	48 03 44 24 58       	add    0x58(%rsp),%rax
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
   20b71:	8b 38                	mov    (%rax),%edi
   20b73:	66 8b 40 04          	mov    0x4(%rax),%ax
   20b77:	89 bc 24 61 01 00 00 	mov    %edi,0x161(%rsp)
                            r       = (hex_char_to_num(buf[0]) << 4) + hex_char_to_num(buf[1]);
   20b7e:	40 0f be ff          	movsbl %dil,%edi
   20b82:	41 88 c1             	mov    %al,%r9b
   20b85:	66 89 84 24 65 01 00 	mov    %ax,0x165(%rsp)
   20b8c:	00 
   20b8d:	e8 ec fa ff ff       	callq  2067e <hex_char_to_num>
   20b92:	0f be bc 24 62 01 00 	movsbl 0x162(%rsp),%edi
   20b99:	00 
   20b9a:	0f b6 f0             	movzbl %al,%esi
   20b9d:	e8 dc fa ff ff       	callq  2067e <hex_char_to_num>
                            g       = (hex_char_to_num(buf[2]) << 4) + hex_char_to_num(buf[3]);
   20ba2:	0f be bc 24 63 01 00 	movsbl 0x163(%rsp),%edi
   20ba9:	00 
                            r       = (hex_char_to_num(buf[0]) << 4) + hex_char_to_num(buf[1]);
   20baa:	c1 e6 04             	shl    $0x4,%esi
   20bad:	0f b6 c8             	movzbl %al,%ecx
   20bb0:	01 f1                	add    %esi,%ecx
                            g       = (hex_char_to_num(buf[2]) << 4) + hex_char_to_num(buf[3]);
   20bb2:	e8 c7 fa ff ff       	callq  2067e <hex_char_to_num>
   20bb7:	0f be bc 24 64 01 00 	movsbl 0x164(%rsp),%edi
   20bbe:	00 
   20bbf:	44 0f b6 c0          	movzbl %al,%r8d
   20bc3:	e8 b6 fa ff ff       	callq  2067e <hex_char_to_num>
   20bc8:	41 c1 e0 04          	shl    $0x4,%r8d
                            b       = (hex_char_to_num(buf[4]) << 4) + hex_char_to_num(buf[5]);
   20bcc:	41 0f be f9          	movsbl %r9b,%edi
                            g       = (hex_char_to_num(buf[2]) << 4) + hex_char_to_num(buf[3]);
   20bd0:	0f b6 f0             	movzbl %al,%esi
   20bd3:	44 01 c6             	add    %r8d,%esi
                            b       = (hex_char_to_num(buf[4]) << 4) + hex_char_to_num(buf[5]);
   20bd6:	e8 a3 fa ff ff       	callq  2067e <hex_char_to_num>
   20bdb:	0f be bc 24 66 01 00 	movsbl 0x166(%rsp),%edi
   20be2:	00 
   20be3:	44 0f b6 c0          	movzbl %al,%r8d
   20be7:	e8 92 fa ff ff       	callq  2067e <hex_char_to_num>
   20bec:	0f b6 c0             	movzbl %al,%eax
   20bef:	41 c1 e0 04          	shl    $0x4,%r8d
   20bf3:	89 f2                	mov    %esi,%edx
   20bf5:	41 01 c0             	add    %eax,%r8d
   20bf8:	0f b6 c9             	movzbl %cl,%ecx
   20bfb:	44 88 44 24 60       	mov    %r8b,0x60(%rsp)
   20c00:	8b 44 24 60          	mov    0x60(%rsp),%eax
   20c04:	c1 e1 10             	shl    $0x10,%ecx
   20c07:	88 d4                	mov    %dl,%ah
   20c09:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   20c0e:	09 c1                	or     %eax,%ecx
   20c10:	81 c9 00 00 00 ff    	or     $0xff000000,%ecx
   20c16:	89 4c 24 60          	mov    %ecx,0x60(%rsp)
   20c1a:	89 c8                	mov    %ecx,%eax
   20c1c:	eb 02                	jmp    20c20 <lv_draw_label+0x539>
                            recolor.full = dsc->color.full;
   20c1e:	8b 03                	mov    (%rbx),%eax
   20c20:	89 84 24 80 00 00 00 	mov    %eax,0x80(%rsp)
                        cmd_state = CMD_STATE_IN; /*After the parameter the text is in the command*/
   20c27:	c6 44 24 33 02       	movb   $0x2,0x33(%rsp)
   20c2c:	e9 54 fe ff ff       	jmpq   20a85 <lv_draw_label+0x39e>
            lv_color_t color = dsc->color;
   20c31:	8b 33                	mov    (%rbx),%esi
                        cmd_state = CMD_STATE_WAIT;
   20c33:	c6 44 24 33 00       	movb   $0x0,0x33(%rsp)
            lv_color_t color = dsc->color;
   20c38:	89 74 24 78          	mov    %esi,0x78(%rsp)
   20c3c:	eb 13                	jmp    20c51 <lv_draw_label+0x56a>
            if(cmd_state == CMD_STATE_IN) color = recolor;
   20c3e:	80 7c 24 33 02       	cmpb   $0x2,0x33(%rsp)
   20c43:	8b bc 24 80 00 00 00 	mov    0x80(%rsp),%edi
   20c4a:	0f 45 3b             	cmovne (%rbx),%edi
   20c4d:	89 7c 24 78          	mov    %edi,0x78(%rsp)
            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
   20c51:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   20c56:	89 c2                	mov    %eax,%edx
   20c58:	89 ee                	mov    %ebp,%esi
   20c5a:	e8 81 64 00 00       	callq  270e0 <lv_font_get_glyph_width>
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
   20c5f:	45 84 e4             	test   %r12b,%r12b
            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
   20c62:	66 89 44 24 6a       	mov    %ax,0x6a(%rsp)
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
   20c67:	74 6c                	je     20cd5 <lv_draw_label+0x5ee>
                if(logical_char_pos >= sel_start && logical_char_pos < sel_end) {
   20c69:	44 39 6c 24 3c       	cmp    %r13d,0x3c(%rsp)
   20c6e:	77 65                	ja     20cd5 <lv_draw_label+0x5ee>
   20c70:	44 39 6c 24 40       	cmp    %r13d,0x40(%rsp)
   20c75:	76 5e                	jbe    20cd5 <lv_draw_label+0x5ee>
                    sel_coords.x1 = pos.x;
   20c77:	8b 44 24 34          	mov    0x34(%rsp),%eax
                    sel_coords.x2 = pos.x + letter_w + dsc->letter_space - 1;
   20c7b:	8b 74 24 34          	mov    0x34(%rsp),%esi
                    lv_draw_rect(&sel_coords, mask, &draw_dsc_sel);
   20c7f:	48 8d 94 24 e0 00 00 	lea    0xe0(%rsp),%rdx
   20c86:	00 
   20c87:	48 8d bc 24 d4 00 00 	lea    0xd4(%rsp),%rdi
   20c8e:	00 
                    sel_coords.x1 = pos.x;
   20c8f:	66 89 84 24 d4 00 00 	mov    %ax,0xd4(%rsp)
   20c96:	00 
                    sel_coords.y1 = pos.y;
   20c97:	8b 44 24 30          	mov    0x30(%rsp),%eax
   20c9b:	66 89 84 24 d6 00 00 	mov    %ax,0xd6(%rsp)
   20ca2:	00 
                    sel_coords.x2 = pos.x + letter_w + dsc->letter_space - 1;
   20ca3:	8b 43 14             	mov    0x14(%rbx),%eax
   20ca6:	8d 44 06 ff          	lea    -0x1(%rsi,%rax,1),%eax
   20caa:	66 03 44 24 6a       	add    0x6a(%rsp),%ax
                    sel_coords.y2 = pos.y + line_height - 1;
   20caf:	8b 74 24 7c          	mov    0x7c(%rsp),%esi
                    sel_coords.x2 = pos.x + letter_w + dsc->letter_space - 1;
   20cb3:	66 89 84 24 d8 00 00 	mov    %ax,0xd8(%rsp)
   20cba:	00 
                    sel_coords.y2 = pos.y + line_height - 1;
   20cbb:	8b 44 24 30          	mov    0x30(%rsp),%eax
   20cbf:	8d 44 30 ff          	lea    -0x1(%rax,%rsi,1),%eax
                    lv_draw_rect(&sel_coords, mask, &draw_dsc_sel);
   20cc3:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
                    sel_coords.y2 = pos.y + line_height - 1;
   20cc8:	66 89 84 24 da 00 00 	mov    %ax,0xda(%rsp)
   20ccf:	00 
                    lv_draw_rect(&sel_coords, mask, &draw_dsc_sel);
   20cd0:	e8 d6 24 00 00       	callq  231ab <lv_draw_rect>
    if(opa < LV_OPA_MIN) return;
   20cd5:	80 bc 24 92 00 00 00 	cmpb   $0x1,0x92(%rsp)
   20cdc:	01 
   20cdd:	76 36                	jbe    20d15 <lv_draw_label+0x62e>
            lv_draw_letter(&pos, mask, font, letter, color, opa, dsc->blend_mode);
   20cdf:	8a 43 27             	mov    0x27(%rbx),%al
    bool g_ret = lv_font_get_glyph_dsc(font_p, &g, letter, '\0');
   20ce2:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   20ce7:	48 8d b4 24 d4 00 00 	lea    0xd4(%rsp),%rsi
   20cee:	00 
   20cef:	31 c9                	xor    %ecx,%ecx
   20cf1:	89 ea                	mov    %ebp,%edx
            lv_draw_letter(&pos, mask, font, letter, color, opa, dsc->blend_mode);
   20cf3:	88 44 24 48          	mov    %al,0x48(%rsp)
    bool g_ret = lv_font_get_glyph_dsc(font_p, &g, letter, '\0');
   20cf7:	e8 e2 63 00 00       	callq  270de <lv_font_get_glyph_dsc>
    if(g_ret == false)  {
   20cfc:	84 c0                	test   %al,%al
   20cfe:	0f 84 ec 01 00 00    	je     20ef0 <lv_draw_label+0x809>
    if((g.box_h == 0) || (g.box_w == 0)) return;
   20d04:	0f b7 84 24 d8 00 00 	movzwl 0xd8(%rsp),%eax
   20d0b:	00 
   20d0c:	66 85 c0             	test   %ax,%ax
   20d0f:	0f 85 fc 01 00 00    	jne    20f11 <lv_draw_label+0x82a>
            if(letter_w > 0) {
   20d15:	66 83 7c 24 6a 00    	cmpw   $0x0,0x6a(%rsp)
   20d1b:	0f 84 64 fd ff ff    	je     20a85 <lv_draw_label+0x39e>
                pos.x += letter_w + dsc->letter_space;
   20d21:	8b 44 24 34          	mov    0x34(%rsp),%eax
   20d25:	03 43 14             	add    0x14(%rbx),%eax
   20d28:	66 03 44 24 6a       	add    0x6a(%rsp),%ax
   20d2d:	66 89 44 24 34       	mov    %ax,0x34(%rsp)
   20d32:	e9 4e fd ff ff       	jmpq   20a85 <lv_draw_label+0x39e>
        if(dsc->decor & LV_TEXT_DECOR_STRIKETHROUGH) {
   20d37:	f6 43 26 02          	testb  $0x2,0x26(%rbx)
   20d3b:	74 79                	je     20db6 <lv_draw_label+0x6cf>
            p1.x = pos_x_start;
   20d3d:	66 8b 44 24 36       	mov    0x36(%rsp),%ax
            p1.y = pos.y + (dsc->font->line_height / 2)  + line_dsc.width / 2;
   20d42:	be 02 00 00 00       	mov    $0x2,%esi
            p2.x = pos.x;
   20d47:	8b 7c 24 34          	mov    0x34(%rsp),%edi
            p1.x = pos_x_start;
   20d4b:	66 89 84 24 c0 00 00 	mov    %ax,0xc0(%rsp)
   20d52:	00 
            p1.y = pos.y + (dsc->font->line_height / 2)  + line_dsc.width / 2;
   20d53:	48 8b 43 08          	mov    0x8(%rbx),%rax
   20d57:	8b 40 10             	mov    0x10(%rax),%eax
            p2.x = pos.x;
   20d5a:	66 89 bc 24 d4 00 00 	mov    %di,0xd4(%rsp)
   20d61:	00 
            lv_draw_line(&p1, &p2, mask, &line_dsc);
   20d62:	48 8d bc 24 c0 00 00 	lea    0xc0(%rsp),%rdi
   20d69:	00 
            p1.y = pos.y + (dsc->font->line_height / 2)  + line_dsc.width / 2;
   20d6a:	89 c2                	mov    %eax,%edx
   20d6c:	66 c1 fa 0f          	sar    $0xf,%dx
   20d70:	66 f7 fe             	idiv   %si
   20d73:	89 c1                	mov    %eax,%ecx
   20d75:	8b 84 24 cc 00 00 00 	mov    0xcc(%rsp),%eax
   20d7c:	89 c2                	mov    %eax,%edx
   20d7e:	66 c1 fa 0f          	sar    $0xf,%dx
   20d82:	66 f7 fe             	idiv   %si
            lv_draw_line(&p1, &p2, mask, &line_dsc);
   20d85:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
   20d8a:	48 8d b4 24 d4 00 00 	lea    0xd4(%rsp),%rsi
   20d91:	00 
            p1.y = pos.y + (dsc->font->line_height / 2)  + line_dsc.width / 2;
   20d92:	01 c8                	add    %ecx,%eax
   20d94:	66 03 44 24 7e       	add    0x7e(%rsp),%ax
            lv_draw_line(&p1, &p2, mask, &line_dsc);
   20d99:	48 8d 8c 24 c8 00 00 	lea    0xc8(%rsp),%rcx
   20da0:	00 
            p1.y = pos.y + (dsc->font->line_height / 2)  + line_dsc.width / 2;
   20da1:	66 89 84 24 c2 00 00 	mov    %ax,0xc2(%rsp)
   20da8:	00 
            p2.y = p1.y;
   20da9:	66 89 84 24 d6 00 00 	mov    %ax,0xd6(%rsp)
   20db0:	00 
            lv_draw_line(&p1, &p2, mask, &line_dsc);
   20db1:	e8 44 07 00 00       	callq  214fa <lv_draw_line>
        if(dsc->decor  & LV_TEXT_DECOR_UNDERLINE) {
   20db6:	f6 43 26 01          	testb  $0x1,0x26(%rbx)
   20dba:	74 69                	je     20e25 <lv_draw_label+0x73e>
            p1.x = pos_x_start;
   20dbc:	66 8b 44 24 36       	mov    0x36(%rsp),%ax
            p1.y = pos.y + dsc->font->line_height - dsc->font->base_line - font->underline_position;
   20dc1:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   20dc6:	66 8b 7c 24 7e       	mov    0x7e(%rsp),%di
            p2.x = pos.x;
   20dcb:	8b 4c 24 34          	mov    0x34(%rsp),%ecx
            p1.x = pos_x_start;
   20dcf:	66 89 84 24 c0 00 00 	mov    %ax,0xc0(%rsp)
   20dd6:	00 
            p1.y = pos.y + dsc->font->line_height - dsc->font->base_line - font->underline_position;
   20dd7:	48 8b 43 08          	mov    0x8(%rbx),%rax
   20ddb:	66 0f be 56 15       	movsbw 0x15(%rsi),%dx
            lv_draw_line(&p1, &p2, mask, &line_dsc);
   20de0:	48 8d b4 24 d4 00 00 	lea    0xd4(%rsp),%rsi
   20de7:	00 
            p1.y = pos.y + dsc->font->line_height - dsc->font->base_line - font->underline_position;
   20de8:	03 78 10             	add    0x10(%rax),%edi
   20deb:	66 03 50 12          	add    0x12(%rax),%dx
            p2.x = pos.x;
   20def:	66 89 8c 24 d4 00 00 	mov    %cx,0xd4(%rsp)
   20df6:	00 
            lv_draw_line(&p1, &p2, mask, &line_dsc);
   20df7:	48 8d 8c 24 c8 00 00 	lea    0xc8(%rsp),%rcx
   20dfe:	00 
            p1.y = pos.y + dsc->font->line_height - dsc->font->base_line - font->underline_position;
   20dff:	89 f8                	mov    %edi,%eax
            lv_draw_line(&p1, &p2, mask, &line_dsc);
   20e01:	48 8d bc 24 c0 00 00 	lea    0xc0(%rsp),%rdi
   20e08:	00 
            p1.y = pos.y + dsc->font->line_height - dsc->font->base_line - font->underline_position;
   20e09:	29 d0                	sub    %edx,%eax
            lv_draw_line(&p1, &p2, mask, &line_dsc);
   20e0b:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
            p1.y = pos.y + dsc->font->line_height - dsc->font->base_line - font->underline_position;
   20e10:	66 89 84 24 c2 00 00 	mov    %ax,0xc2(%rsp)
   20e17:	00 
            p2.y = p1.y;
   20e18:	66 89 84 24 d6 00 00 	mov    %ax,0xd6(%rsp)
   20e1f:	00 
            lv_draw_line(&p1, &p2, mask, &line_dsc);
   20e20:	e8 d5 06 00 00       	callq  214fa <lv_draw_line>
        line_end += _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);
   20e25:	44 8b 6c 24 1c       	mov    0x1c(%rsp),%r13d
   20e2a:	0f bf 53 14          	movswl 0x14(%rbx),%edx
   20e2e:	4c 03 6c 24 28       	add    0x28(%rsp),%r13
   20e33:	44 0f b6 43 25       	movzbl 0x25(%rbx),%r8d
   20e38:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   20e3d:	8b 4c 24 64          	mov    0x64(%rsp),%ecx
   20e41:	4c 89 ef             	mov    %r13,%rdi
   20e44:	e8 e0 5d 00 00       	callq  26c29 <_lv_txt_get_next_line>
        if(dsc->flag & LV_TXT_FLAG_CENTER) {
   20e49:	44 0f b6 43 25       	movzbl 0x25(%rbx),%r8d
        line_end += _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);
   20e4e:	89 c6                	mov    %eax,%esi
   20e50:	8b 44 24 1c          	mov    0x1c(%rsp),%eax
        pos.x = coords->x1;
   20e54:	66 45 8b 27          	mov    (%r15),%r12w
        line_end += _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);
   20e58:	8d 2c 30             	lea    (%rax,%rsi,1),%ebp
        if(dsc->flag & LV_TXT_FLAG_CENTER) {
   20e5b:	41 f6 c0 04          	test   $0x4,%r8b
   20e5f:	44 89 c2             	mov    %r8d,%edx
   20e62:	74 32                	je     20e96 <lv_draw_label+0x7af>
                _lv_txt_get_width(&txt[line_start], line_end - line_start, font, dsc->letter_space, dsc->flag);
   20e64:	0f bf 4b 14          	movswl 0x14(%rbx),%ecx
   20e68:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   20e6d:	4c 89 ef             	mov    %r13,%rdi
   20e70:	e8 b8 5c 00 00       	callq  26b2d <_lv_txt_get_width>
   20e75:	66 41 8b 7f 04       	mov    0x4(%r15),%di
            line_width =
   20e7a:	98                   	cwtl   
            pos.x += (lv_area_get_width(coords) - line_width) / 2;
   20e7b:	b9 02 00 00 00       	mov    $0x2,%ecx
   20e80:	8d 57 01             	lea    0x1(%rdi),%edx
   20e83:	66 41 2b 17          	sub    (%r15),%dx
   20e87:	0f bf d2             	movswl %dx,%edx
   20e8a:	29 c2                	sub    %eax,%edx
   20e8c:	89 d0                	mov    %edx,%eax
   20e8e:	99                   	cltd   
   20e8f:	f7 f9                	idiv   %ecx
   20e91:	41 01 c4             	add    %eax,%r12d
   20e94:	eb 28                	jmp    20ebe <lv_draw_label+0x7d7>
        else if(dsc->flag & LV_TXT_FLAG_RIGHT) {
   20e96:	80 e2 08             	and    $0x8,%dl
   20e99:	74 23                	je     20ebe <lv_draw_label+0x7d7>
                _lv_txt_get_width(&txt[line_start], line_end - line_start, font, dsc->letter_space, dsc->flag);
   20e9b:	0f bf 4b 14          	movswl 0x14(%rbx),%ecx
   20e9f:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   20ea4:	4c 89 ef             	mov    %r13,%rdi
   20ea7:	e8 81 5c 00 00       	callq  26b2d <_lv_txt_get_width>
   20eac:	66 41 8b 77 04       	mov    0x4(%r15),%si
   20eb1:	8d 56 01             	lea    0x1(%rsi),%edx
   20eb4:	66 41 2b 17          	sub    (%r15),%dx
            pos.x += lv_area_get_width(coords) - line_width;
   20eb8:	41 01 d4             	add    %edx,%r12d
   20ebb:	41 29 c4             	sub    %eax,%r12d
        line_start = line_end;
   20ebe:	8b 44 24 1c          	mov    0x1c(%rsp),%eax
   20ec2:	8b 4c 24 7c          	mov    0x7c(%rsp),%ecx
   20ec6:	66 01 4c 24 30       	add    %cx,0x30(%rsp)
   20ecb:	66 01 4c 24 7e       	add    %cx,0x7e(%rsp)
        if(pos.y > mask->y2) return;
   20ed0:	8b 74 24 30          	mov    0x30(%rsp),%esi
        line_start = line_end;
   20ed4:	89 44 24 20          	mov    %eax,0x20(%rsp)
        if(pos.y > mask->y2) return;
   20ed8:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
   20edd:	66 39 70 06          	cmp    %si,0x6(%rax)
   20ee1:	0f 8c c5 05 00 00    	jl     214ac <lv_draw_label+0xdc5>
        line_end += _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);
   20ee7:	89 6c 24 1c          	mov    %ebp,0x1c(%rsp)
   20eeb:	e9 60 fb ff ff       	jmpq   20a50 <lv_draw_label+0x369>
        if(letter >= 0x20) {
   20ef0:	83 fd 1f             	cmp    $0x1f,%ebp
   20ef3:	0f 86 1c fe ff ff    	jbe    20d15 <lv_draw_label+0x62e>
            LV_LOG_WARN("lv_draw_letter: glyph dsc. not found");
   20ef9:	4c 8d 05 50 28 01 00 	lea    0x12850(%rip),%r8        # 33750 <__func__.5785+0x2ae8>
   20f00:	48 8d 0d 11 fd 00 00 	lea    0xfd11(%rip),%rcx        # 30c18 <__func__.5716>
   20f07:	ba a3 01 00 00       	mov    $0x1a3,%edx
   20f0c:	e9 d7 00 00 00       	jmpq   20fe8 <lv_draw_label+0x901>
    if((g.box_h == 0) || (g.box_w == 0)) return;
   20f11:	0f b7 94 24 d6 00 00 	movzwl 0xd6(%rsp),%edx
   20f18:	00 
   20f19:	66 85 d2             	test   %dx,%dx
   20f1c:	0f 84 f3 fd ff ff    	je     20d15 <lv_draw_label+0x62e>
    int32_t pos_x = pos_p->x + g.ofs_x;
   20f22:	0f bf 4c 24 34       	movswl 0x34(%rsp),%ecx
   20f27:	44 0f bf ac 24 da 00 	movswl 0xda(%rsp),%r13d
   20f2e:	00 00 
    if(pos_x + g.box_w < clip_area->x1 ||
   20f30:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
    int32_t pos_x = pos_p->x + g.ofs_x;
   20f35:	41 01 cd             	add    %ecx,%r13d
    if(pos_x + g.box_w < clip_area->x1 ||
   20f38:	0f bf 0e             	movswl (%rsi),%ecx
   20f3b:	44 01 ea             	add    %r13d,%edx
   20f3e:	39 ca                	cmp    %ecx,%edx
   20f40:	0f 8c cf fd ff ff    	jl     20d15 <lv_draw_label+0x62e>
       pos_x > clip_area->x2 ||
   20f46:	0f bf 56 04          	movswl 0x4(%rsi),%edx
    if(pos_x + g.box_w < clip_area->x1 ||
   20f4a:	41 39 d5             	cmp    %edx,%r13d
   20f4d:	0f 8f c2 fd ff ff    	jg     20d15 <lv_draw_label+0x62e>
    int32_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
   20f53:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   20f58:	0f bf 4e 12          	movswl 0x12(%rsi),%ecx
   20f5c:	0f bf 56 10          	movswl 0x10(%rsi),%edx
   20f60:	48 89 f7             	mov    %rsi,%rdi
       pos_y + g.box_h < clip_area->y1 ||
   20f63:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
    int32_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
   20f68:	29 ca                	sub    %ecx,%edx
   20f6a:	0f bf 4c 24 30       	movswl 0x30(%rsp),%ecx
   20f6f:	01 ca                	add    %ecx,%edx
   20f71:	0f bf 8c 24 dc 00 00 	movswl 0xdc(%rsp),%ecx
   20f78:	00 
   20f79:	29 c2                	sub    %eax,%edx
   20f7b:	29 ca                	sub    %ecx,%edx
       pos_y + g.box_h < clip_area->y1 ||
   20f7d:	01 d0                	add    %edx,%eax
    int32_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
   20f7f:	89 54 24 44          	mov    %edx,0x44(%rsp)
       pos_y + g.box_h < clip_area->y1 ||
   20f83:	0f bf 56 02          	movswl 0x2(%rsi),%edx
       pos_x > clip_area->x2 ||
   20f87:	39 d0                	cmp    %edx,%eax
   20f89:	0f 8c 86 fd ff ff    	jl     20d15 <lv_draw_label+0x62e>
       pos_y > clip_area->y2)  {
   20f8f:	0f bf 46 06          	movswl 0x6(%rsi),%eax
       pos_y + g.box_h < clip_area->y1 ||
   20f93:	39 44 24 44          	cmp    %eax,0x44(%rsp)
   20f97:	0f 8f 78 fd ff ff    	jg     20d15 <lv_draw_label+0x62e>
    const uint8_t * map_p = lv_font_get_glyph_bitmap(font_p, letter);
   20f9d:	89 ee                	mov    %ebp,%esi
   20f9f:	e8 37 61 00 00       	callq  270db <lv_font_get_glyph_bitmap>
    if(map_p == NULL) {
   20fa4:	48 85 c0             	test   %rax,%rax
   20fa7:	75 21                	jne    20fca <lv_draw_label+0x8e3>
        LV_LOG_WARN("lv_draw_letter: character's bitmap not found");
   20fa9:	4c 8d 05 01 28 01 00 	lea    0x12801(%rip),%r8        # 337b1 <__func__.5785+0x2b49>
   20fb0:	48 8d 0d 61 fc 00 00 	lea    0xfc61(%rip),%rcx        # 30c18 <__func__.5716>
   20fb7:	ba b9 01 00 00       	mov    $0x1b9,%edx
   20fbc:	48 8d 35 b2 27 01 00 	lea    0x127b2(%rip),%rsi        # 33775 <__func__.5785+0x2b0d>
   20fc3:	bf 02 00 00 00       	mov    $0x2,%edi
   20fc8:	eb 2c                	jmp    20ff6 <lv_draw_label+0x90f>
    if(font_p->subpx) {
   20fca:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   20fcf:	f6 46 14 03          	testb  $0x3,0x14(%rsi)
   20fd3:	74 2b                	je     21000 <lv_draw_label+0x919>
    LV_LOG_WARN("Can't draw sub-pixel rendered letter because LV_USE_FONT_SUBPX == 0 in lv_conf.h");
   20fd5:	4c 8d 05 02 28 01 00 	lea    0x12802(%rip),%r8        # 337de <__func__.5785+0x2b76>
   20fdc:	48 8d 0d 0d fa 00 00 	lea    0xfa0d(%rip),%rcx        # 309f0 <__func__.5788>
   20fe3:	ba 2d 03 00 00       	mov    $0x32d,%edx
   20fe8:	48 8d 35 86 27 01 00 	lea    0x12786(%rip),%rsi        # 33775 <__func__.5785+0x2b0d>
   20fef:	bf 02 00 00 00       	mov    $0x2,%edi
   20ff4:	31 c0                	xor    %eax,%eax
   20ff6:	e8 5b 4f 00 00       	callq  25f56 <_lv_log_add>
   20ffb:	e9 15 fd ff ff       	jmpq   20d15 <lv_draw_label+0x62e>
    uint32_t bpp = g->bpp;
   21000:	8a 94 24 de 00 00 00 	mov    0xde(%rsp),%dl
        draw_letter_normal(pos_x, pos_y, &g, clip_area, map_p, color, opa, blend_mode);
   21007:	0f bf 74 24 44       	movswl 0x44(%rsp),%esi
   2100c:	41 0f bf fd          	movswl %r13w,%edi
    if(bpp == 3) bpp = 4;
   21010:	80 fa 03             	cmp    $0x3,%dl
   21013:	74 65                	je     2107a <lv_draw_label+0x993>
    switch(bpp) {
   21015:	80 fa 02             	cmp    $0x2,%dl
   21018:	74 2d                	je     21047 <lv_draw_label+0x960>
   2101a:	77 06                	ja     21022 <lv_draw_label+0x93b>
   2101c:	fe ca                	dec    %dl
   2101e:	74 75                	je     21095 <lv_draw_label+0x9ae>
   21020:	eb 40                	jmp    21062 <lv_draw_label+0x97b>
   21022:	80 fa 04             	cmp    $0x4,%dl
   21025:	74 53                	je     2107a <lv_draw_label+0x993>
   21027:	80 fa 08             	cmp    $0x8,%dl
   2102a:	75 36                	jne    21062 <lv_draw_label+0x97b>
        case 8:
   2102c:	41 bc 08 00 00 00    	mov    $0x8,%r12d
            shades = 256;
   21032:	41 b8 00 01 00 00    	mov    $0x100,%r8d
            bitmask_init  = 0xFF;
   21038:	41 bb ff 00 00 00    	mov    $0xff,%r11d
            bpp_opa_table_p = _lv_bpp8_opa_table;
   2103e:	4c 8d 15 5b c1 00 00 	lea    0xc15b(%rip),%r10        # 2d1a0 <_lv_bpp8_opa_table>
   21045:	eb 67                	jmp    210ae <lv_draw_label+0x9c7>
    switch(bpp) {
   21047:	41 bc 02 00 00 00    	mov    $0x2,%r12d
            shades = 4;
   2104d:	41 b8 04 00 00 00    	mov    $0x4,%r8d
            bitmask_init  = 0xC0;
   21053:	41 bb c0 00 00 00    	mov    $0xc0,%r11d
            bpp_opa_table_p = _lv_bpp2_opa_table;
   21059:	4c 8d 15 f1 27 01 00 	lea    0x127f1(%rip),%r10        # 33851 <_lv_bpp2_opa_table>
   21060:	eb 4c                	jmp    210ae <lv_draw_label+0x9c7>
            LV_LOG_WARN("lv_draw_letter: invalid bpp");
   21062:	4c 8d 05 c6 27 01 00 	lea    0x127c6(%rip),%r8        # 3382f <__func__.5785+0x2bc7>
   21069:	48 8d 0d 60 f9 00 00 	lea    0xf960(%rip),%rcx        # 309d0 <__func__.5743>
   21070:	ba e7 01 00 00       	mov    $0x1e7,%edx
   21075:	e9 6e ff ff ff       	jmpq   20fe8 <lv_draw_label+0x901>
    if(bpp == 3) bpp = 4;
   2107a:	41 bc 04 00 00 00    	mov    $0x4,%r12d
            shades = 16;
   21080:	41 b8 10 00 00 00    	mov    $0x10,%r8d
            bitmask_init  = 0xF0;
   21086:	41 bb f0 00 00 00    	mov    $0xf0,%r11d
            bpp_opa_table_p = _lv_bpp4_opa_table;
   2108c:	4c 8d 15 7d f9 00 00 	lea    0xf97d(%rip),%r10        # 30a10 <_lv_bpp4_opa_table>
   21093:	eb 19                	jmp    210ae <lv_draw_label+0x9c7>
            bpp_opa_table_p = _lv_bpp1_opa_table;
   21095:	4c 8d 15 b9 27 01 00 	lea    0x127b9(%rip),%r10        # 33855 <_lv_bpp1_opa_table>
    switch(bpp) {
   2109c:	41 bc 01 00 00 00    	mov    $0x1,%r12d
            shades = 2;
   210a2:	41 b8 02 00 00 00    	mov    $0x2,%r8d
            bitmask_init  = 0x80;
   210a8:	41 bb 80 00 00 00    	mov    $0x80,%r11d
    if(opa < LV_OPA_MAX) {
   210ae:	80 7c 24 69 fc       	cmpb   $0xfc,0x69(%rsp)
   210b3:	77 63                	ja     21118 <lv_draw_label+0xa31>
        if(prev_opa != opa || prev_bpp != bpp) {
   210b5:	31 c9                	xor    %ecx,%ecx
   210b7:	8a 54 24 69          	mov    0x69(%rsp),%dl
   210bb:	38 15 2b e0 23 00    	cmp    %dl,0x23e02b(%rip)        # 25f0ec <prev_opa.5745>
   210c1:	75 36                	jne    210f9 <lv_draw_label+0xa12>
   210c3:	44 39 25 d6 df 23 00 	cmp    %r12d,0x23dfd6(%rip)        # 25f0a0 <prev_bpp.5746>
   210ca:	75 2d                	jne    210f9 <lv_draw_label+0xa12>
        prev_opa = opa;
   210cc:	8a 4c 24 69          	mov    0x69(%rsp),%cl
        prev_bpp = bpp;
   210d0:	44 89 25 c9 df 23 00 	mov    %r12d,0x23dfc9(%rip)        # 25f0a0 <prev_bpp.5746>
        bpp_opa_table_p = opa_table;
   210d7:	4c 8d 15 c2 65 23 00 	lea    0x2365c2(%rip),%r10        # 2576a0 <opa_table.5744>
        prev_opa = opa;
   210de:	88 0d 08 e0 23 00    	mov    %cl,0x23e008(%rip)        # 25f0ec <prev_opa.5745>
   210e4:	eb 32                	jmp    21118 <lv_draw_label+0xa31>
                opa_table[i] = bpp_opa_table_p[i] == LV_OPA_COVER ? opa : ((bpp_opa_table_p[i] * opa) >> 8);
   210e6:	48 8d 15 b3 65 23 00 	lea    0x2365b3(%rip),%rdx        # 2576a0 <opa_table.5744>
   210ed:	44 88 0c 0a          	mov    %r9b,(%rdx,%rcx,1)
   210f1:	48 ff c1             	inc    %rcx
            for(i = 0; i < shades; i++) {
   210f4:	41 39 c8             	cmp    %ecx,%r8d
   210f7:	76 d3                	jbe    210cc <lv_draw_label+0x9e5>
                opa_table[i] = bpp_opa_table_p[i] == LV_OPA_COVER ? opa : ((bpp_opa_table_p[i] * opa) >> 8);
   210f9:	41 0f b6 14 0a       	movzbl (%r10,%rcx,1),%edx
   210fe:	44 8a 4c 24 69       	mov    0x69(%rsp),%r9b
   21103:	80 fa ff             	cmp    $0xff,%dl
   21106:	74 de                	je     210e6 <lv_draw_label+0x9ff>
   21108:	0f af 94 24 8c 00 00 	imul   0x8c(%rsp),%edx
   2110f:	00 
   21110:	0f b6 d6             	movzbl %dh,%edx
   21113:	41 89 d1             	mov    %edx,%r9d
   21116:	eb ce                	jmp    210e6 <lv_draw_label+0x9ff>
    int32_t col_start = pos_x >= clip_area->x1 ? 0 : clip_area->x1 - pos_x;
   21118:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
    int32_t box_w = g->box_w;
   2111d:	0f b7 94 24 d6 00 00 	movzwl 0xd6(%rsp),%edx
   21124:	00 
    int32_t box_h = g->box_h;
   21125:	44 0f b7 b4 24 d8 00 	movzwl 0xd8(%rsp),%r14d
   2112c:	00 00 
    int32_t col_start = pos_x >= clip_area->x1 ? 0 : clip_area->x1 - pos_x;
   2112e:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%rsp)
   21135:	00 
   21136:	0f bf 09             	movswl (%rcx),%ecx
    int32_t width_bit = box_w * bpp; /*Letter width in bits*/
   21139:	89 d5                	mov    %edx,%ebp
   2113b:	41 0f af ec          	imul   %r12d,%ebp
    int32_t col_start = pos_x >= clip_area->x1 ? 0 : clip_area->x1 - pos_x;
   2113f:	66 41 39 cd          	cmp    %cx,%r13w
   21143:	7d 06                	jge    2114b <lv_draw_label+0xa64>
   21145:	29 f9                	sub    %edi,%ecx
   21147:	89 4c 24 38          	mov    %ecx,0x38(%rsp)
    int32_t col_end   = pos_x + box_w <= clip_area->x2 ? box_w : clip_area->x2 - pos_x + 1;
   2114b:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
   21150:	44 8d 04 17          	lea    (%rdi,%rdx,1),%r8d
   21154:	89 54 24 54          	mov    %edx,0x54(%rsp)
   21158:	0f bf 49 04          	movswl 0x4(%rcx),%ecx
   2115c:	41 39 c8             	cmp    %ecx,%r8d
   2115f:	7e 09                	jle    2116a <lv_draw_label+0xa83>
   21161:	29 f9                	sub    %edi,%ecx
   21163:	8d 79 01             	lea    0x1(%rcx),%edi
   21166:	89 7c 24 54          	mov    %edi,0x54(%rsp)
    int32_t row_start = pos_y >= clip_area->y1 ? 0 : clip_area->y1 - pos_y;
   2116a:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   2116f:	c7 44 24 50 00 00 00 	movl   $0x0,0x50(%rsp)
   21176:	00 
   21177:	0f bf 4f 02          	movswl 0x2(%rdi),%ecx
   2117b:	66 39 4c 24 44       	cmp    %cx,0x44(%rsp)
   21180:	7d 06                	jge    21188 <lv_draw_label+0xaa1>
   21182:	29 f1                	sub    %esi,%ecx
   21184:	89 4c 24 50          	mov    %ecx,0x50(%rsp)
    int32_t row_end   = pos_y + box_h <= clip_area->y2 ? box_h : clip_area->y2 - pos_y + 1;
   21188:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   2118d:	44 89 b4 24 88 00 00 	mov    %r14d,0x88(%rsp)
   21194:	00 
   21195:	0f bf 4f 06          	movswl 0x6(%rdi),%ecx
   21199:	42 8d 3c 36          	lea    (%rsi,%r14,1),%edi
   2119d:	39 cf                	cmp    %ecx,%edi
   2119f:	7e 0c                	jle    211ad <lv_draw_label+0xac6>
   211a1:	29 f1                	sub    %esi,%ecx
   211a3:	8d 71 01             	lea    0x1(%rcx),%esi
   211a6:	89 b4 24 88 00 00 00 	mov    %esi,0x88(%rsp)
    uint32_t bit_ofs = (row_start * width_bit) + (col_start * bpp);
   211ad:	0f af 6c 24 50       	imul   0x50(%rsp),%ebp
   211b2:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
            lv_draw_letter(&pos, mask, font, letter, color, opa, dsc->blend_mode);
   211b6:	0f b6 74 24 48       	movzbl 0x48(%rsp),%esi
    uint32_t mask_buf_size = box_w * box_h > LV_HOR_RES_MAX ? LV_HOR_RES_MAX : box_w * box_h;
   211bb:	44 0f af f2          	imul   %edx,%r14d
   211bf:	44 89 9c 24 a8 00 00 	mov    %r11d,0xa8(%rsp)
   211c6:	00 
   211c7:	4c 89 94 24 a0 00 00 	mov    %r10,0xa0(%rsp)
   211ce:	00 
   211cf:	89 94 24 94 00 00 00 	mov    %edx,0x94(%rsp)
    uint32_t bit_ofs = (row_start * width_bit) + (col_start * bpp);
   211d6:	41 0f af cc          	imul   %r12d,%ecx
            lv_draw_letter(&pos, mask, font, letter, color, opa, dsc->blend_mode);
   211da:	89 b4 24 84 00 00 00 	mov    %esi,0x84(%rsp)
    uint32_t bit_ofs = (row_start * width_bit) + (col_start * bpp);
   211e1:	01 cd                	add    %ecx,%ebp
    map_p += bit_ofs >> 3;
   211e3:	89 e9                	mov    %ebp,%ecx
    col_bit = bit_ofs & 0x7; /* "& 0x7" equals to "% 8" just faster */
   211e5:	83 e5 07             	and    $0x7,%ebp
    map_p += bit_ofs >> 3;
   211e8:	c1 e9 03             	shr    $0x3,%ecx
   211eb:	48 01 c8             	add    %rcx,%rax
    uint32_t mask_buf_size = box_w * box_h > LV_HOR_RES_MAX ? LV_HOR_RES_MAX : box_w * box_h;
   211ee:	41 81 fe e0 01 00 00 	cmp    $0x1e0,%r14d
    map_p += bit_ofs >> 3;
   211f5:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
    uint32_t mask_buf_size = box_w * box_h > LV_HOR_RES_MAX ? LV_HOR_RES_MAX : box_w * box_h;
   211fa:	b8 e0 01 00 00       	mov    $0x1e0,%eax
   211ff:	44 0f 4f f0          	cmovg  %eax,%r14d
    lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
   21203:	44 89 f7             	mov    %r14d,%edi
   21206:	e8 d3 4f 00 00       	callq  261de <_lv_mem_buf_get>
   2120b:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    fill_area.x1 = col_start + pos_x;
   21210:	8b 44 24 38          	mov    0x38(%rsp),%eax
   21214:	44 01 e8             	add    %r13d,%eax
   21217:	66 89 84 24 c0 00 00 	mov    %ax,0xc0(%rsp)
   2121e:	00 
    fill_area.x2 = col_end  + pos_x - 1;
   2121f:	8b 44 24 54          	mov    0x54(%rsp),%eax
   21223:	45 8d 6c 05 ff       	lea    -0x1(%r13,%rax,1),%r13d
    fill_area.y1 = row_start + pos_y;
   21228:	8b 44 24 44          	mov    0x44(%rsp),%eax
   2122c:	03 44 24 50          	add    0x50(%rsp),%eax
    fill_area.x2 = col_end  + pos_x - 1;
   21230:	66 44 89 ac 24 c4 00 	mov    %r13w,0xc4(%rsp)
   21237:	00 00 
    int32_t mask_p = 0;
   21239:	45 31 ed             	xor    %r13d,%r13d
    fill_area.y1 = row_start + pos_y;
   2123c:	66 89 84 24 c2 00 00 	mov    %ax,0xc2(%rsp)
   21243:	00 
    fill_area.y2 = fill_area.y1;
   21244:	66 89 84 24 c6 00 00 	mov    %ax,0xc6(%rsp)
   2124b:	00 
    uint8_t other_mask_cnt = lv_draw_mask_get_cnt();
   2124c:	e8 33 1c 00 00       	callq  22e84 <lv_draw_mask_get_cnt>
    uint32_t col_bit_row_ofs = (box_w + col_start - col_end) * bpp;
   21251:	8b 94 24 94 00 00 00 	mov    0x94(%rsp),%edx
   21258:	03 54 24 38          	add    0x38(%rsp),%edx
   2125c:	2b 54 24 54          	sub    0x54(%rsp),%edx
    uint8_t other_mask_cnt = lv_draw_mask_get_cnt();
   21260:	88 84 24 93 00 00 00 	mov    %al,0x93(%rsp)
    uint32_t col_bit_max = 8 - bpp;
   21267:	b8 08 00 00 00       	mov    $0x8,%eax
   2126c:	44 29 e0             	sub    %r12d,%eax
   2126f:	4c 8b 94 24 a0 00 00 	mov    0xa0(%rsp),%r10
   21276:	00 
   21277:	44 8b 9c 24 a8 00 00 	mov    0xa8(%rsp),%r11d
   2127e:	00 
   2127f:	89 44 24 44          	mov    %eax,0x44(%rsp)
            _lv_blend_fill(clip_area, &fill_area,
   21283:	48 8d 84 24 c0 00 00 	lea    0xc0(%rsp),%rax
   2128a:	00 
    uint32_t col_bit_row_ofs = (box_w + col_start - col_end) * bpp;
   2128b:	41 0f af d4          	imul   %r12d,%edx
            _lv_blend_fill(clip_area, &fill_area,
   2128f:	48 89 84 24 98 00 00 	mov    %rax,0x98(%rsp)
   21296:	00 
    uint32_t col_bit_row_ofs = (box_w + col_start - col_end) * bpp;
   21297:	89 94 24 94 00 00 00 	mov    %edx,0x94(%rsp)
    for(row = row_start ; row < row_end; row++) {
   2129e:	8b bc 24 88 00 00 00 	mov    0x88(%rsp),%edi
   212a5:	39 7c 24 50          	cmp    %edi,0x50(%rsp)
   212a9:	0f 8d 9a 01 00 00    	jge    21449 <lv_draw_label+0xd62>
        for(col = col_start; col < col_end; col++) {
   212af:	8b 74 24 38          	mov    0x38(%rsp),%esi
        bitmask = bitmask_init >> col_bit;
   212b3:	44 89 da             	mov    %r11d,%edx
   212b6:	40 88 e9             	mov    %bpl,%cl
   212b9:	d3 ea                	shr    %cl,%edx
   212bb:	45 89 e8             	mov    %r13d,%r8d
        for(col = col_start; col < col_end; col++) {
   212be:	44 29 ee             	sub    %r13d,%esi
   212c1:	42 8d 04 06          	lea    (%rsi,%r8,1),%eax
   212c5:	39 44 24 54          	cmp    %eax,0x54(%rsp)
   212c9:	7e 4b                	jle    21316 <lv_draw_label+0xc2f>
            letter_px = (*map_p & bitmask) >> (col_bit_max - col_bit);
   212cb:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
   212d0:	8b 4c 24 44          	mov    0x44(%rsp),%ecx
   212d4:	0f b6 00             	movzbl (%rax),%eax
   212d7:	29 e9                	sub    %ebp,%ecx
   212d9:	21 d0                	and    %edx,%eax
   212db:	d3 e8                	shr    %cl,%eax
   212dd:	49 63 c8             	movslq %r8d,%rcx
   212e0:	48 03 4c 24 48       	add    0x48(%rsp),%rcx
            if(letter_px) {
   212e5:	84 c0                	test   %al,%al
   212e7:	74 0b                	je     212f4 <lv_draw_label+0xc0d>
                mask_buf[mask_p] = bpp_opa_table_p[letter_px];
   212e9:	0f b6 c0             	movzbl %al,%eax
   212ec:	41 8a 04 02          	mov    (%r10,%rax,1),%al
   212f0:	88 01                	mov    %al,(%rcx)
   212f2:	eb 03                	jmp    212f7 <lv_draw_label+0xc10>
                mask_buf[mask_p] = 0;
   212f4:	c6 01 00             	movb   $0x0,(%rcx)
            if(col_bit < col_bit_max) {
   212f7:	39 6c 24 44          	cmp    %ebp,0x44(%rsp)
   212fb:	76 0a                	jbe    21307 <lv_draw_label+0xc20>
                bitmask = bitmask >> bpp;
   212fd:	44 88 e1             	mov    %r12b,%cl
                col_bit += bpp;
   21300:	44 01 e5             	add    %r12d,%ebp
                bitmask = bitmask >> bpp;
   21303:	d3 ea                	shr    %cl,%edx
   21305:	eb 0a                	jmp    21311 <lv_draw_label+0xc2a>
                map_p++;
   21307:	48 ff 44 24 70       	incq   0x70(%rsp)
                bitmask = bitmask_init;
   2130c:	44 89 da             	mov    %r11d,%edx
                col_bit = 0;
   2130f:	31 ed                	xor    %ebp,%ebp
            mask_p++;
   21311:	41 ff c0             	inc    %r8d
   21314:	eb ab                	jmp    212c1 <lv_draw_label+0xbda>
        if(other_mask_cnt) {
   21316:	80 bc 24 93 00 00 00 	cmpb   $0x0,0x93(%rsp)
   2131d:	00 
   2131e:	74 7a                	je     2139a <lv_draw_label+0xcb3>
   21320:	8b 84 24 c4 00 00 00 	mov    0xc4(%rsp),%eax
                                                             lv_area_get_width(&fill_area));
   21327:	0f bf b4 24 c0 00 00 	movswl 0xc0(%rsp),%esi
   2132e:	00 
            lv_draw_mask_res_t mask_res = lv_draw_mask_apply(mask_buf + mask_p_start, fill_area.x1, fill_area.y2,
   2132f:	4c 03 6c 24 48       	add    0x48(%rsp),%r13
   21334:	0f bf 94 24 c6 00 00 	movswl 0xc6(%rsp),%edx
   2133b:	00 
   2133c:	44 89 84 24 ac 00 00 	mov    %r8d,0xac(%rsp)
   21343:	00 
   21344:	44 89 9c 24 a8 00 00 	mov    %r11d,0xa8(%rsp)
   2134b:	00 
   2134c:	8d 48 01             	lea    0x1(%rax),%ecx
   2134f:	4c 89 94 24 a0 00 00 	mov    %r10,0xa0(%rsp)
   21356:	00 
   21357:	29 f1                	sub    %esi,%ecx
   21359:	4c 89 ef             	mov    %r13,%rdi
   2135c:	0f bf c9             	movswl %cx,%ecx
   2135f:	e8 60 1a 00 00       	callq  22dc4 <lv_draw_mask_apply>
            if(mask_res == LV_DRAW_MASK_RES_TRANSP) {
   21364:	84 c0                	test   %al,%al
   21366:	4c 8b 94 24 a0 00 00 	mov    0xa0(%rsp),%r10
   2136d:	00 
   2136e:	44 8b 9c 24 a8 00 00 	mov    0xa8(%rsp),%r11d
   21375:	00 
   21376:	44 8b 84 24 ac 00 00 	mov    0xac(%rsp),%r8d
   2137d:	00 
   2137e:	75 1a                	jne    2139a <lv_draw_label+0xcb3>
   21380:	8b b4 24 c4 00 00 00 	mov    0xc4(%rsp),%esi
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
   21387:	4c 89 ef             	mov    %r13,%rdi
   2138a:	8d 4e 01             	lea    0x1(%rsi),%ecx
   2138d:	2b 8c 24 c0 00 00 00 	sub    0xc0(%rsp),%ecx
                _lv_memset_00(mask_buf + mask_p_start, lv_area_get_width(&fill_area));
   21394:	48 0f bf c9          	movswq %cx,%rcx
   21398:	f3 aa                	rep stos %al,%es:(%rdi)
        if((uint32_t) mask_p + (col_end - col_start) < mask_buf_size) {
   2139a:	8b 44 24 54          	mov    0x54(%rsp),%eax
   2139e:	2b 44 24 38          	sub    0x38(%rsp),%eax
   213a2:	44 01 c0             	add    %r8d,%eax
   213a5:	41 39 c6             	cmp    %eax,%r14d
   213a8:	76 0a                	jbe    213b4 <lv_draw_label+0xccd>
            fill_area.y2 ++;
   213aa:	66 ff 84 24 c6 00 00 	incw   0xc6(%rsp)
   213b1:	00 
   213b2:	eb 75                	jmp    21429 <lv_draw_label+0xd42>
   213b4:	44 89 9c 24 a8 00 00 	mov    %r11d,0xa8(%rsp)
   213bb:	00 
   213bc:	4c 89 94 24 a0 00 00 	mov    %r10,0xa0(%rsp)
   213c3:	00 
            _lv_blend_fill(clip_area, &fill_area,
   213c4:	48 83 ec 08          	sub    $0x8,%rsp
   213c8:	8b 84 24 8c 00 00 00 	mov    0x8c(%rsp),%eax
   213cf:	41 b8 02 00 00 00    	mov    $0x2,%r8d
   213d5:	41 b9 ff 00 00 00    	mov    $0xff,%r9d
   213db:	50                   	push   %rax
   213dc:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
   213e1:	8b 94 24 88 00 00 00 	mov    0x88(%rsp),%edx
   213e8:	48 8b b4 24 a8 00 00 	mov    0xa8(%rsp),%rsi
   213ef:	00 
   213f0:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
   213f5:	e8 53 db ff ff       	callq  1ef4d <_lv_blend_fill>
   213fa:	59                   	pop    %rcx
   213fb:	5e                   	pop    %rsi
            fill_area.y1 = fill_area.y2 + 1;
   213fc:	66 8b 84 24 c6 00 00 	mov    0xc6(%rsp),%ax
   21403:	00 
            mask_p = 0;
   21404:	44 8b 9c 24 a8 00 00 	mov    0xa8(%rsp),%r11d
   2140b:	00 
   2140c:	45 31 c0             	xor    %r8d,%r8d
   2140f:	4c 8b 94 24 a0 00 00 	mov    0xa0(%rsp),%r10
   21416:	00 
            fill_area.y1 = fill_area.y2 + 1;
   21417:	ff c0                	inc    %eax
   21419:	66 89 84 24 c2 00 00 	mov    %ax,0xc2(%rsp)
   21420:	00 
            fill_area.y2 = fill_area.y1;
   21421:	66 89 84 24 c6 00 00 	mov    %ax,0xc6(%rsp)
   21428:	00 
        col_bit += col_bit_row_ofs;
   21429:	03 ac 24 94 00 00 00 	add    0x94(%rsp),%ebp
    for(row = row_start ; row < row_end; row++) {
   21430:	ff 44 24 50          	incl   0x50(%rsp)
   21434:	4d 63 e8             	movslq %r8d,%r13
        map_p += (col_bit >> 3);
   21437:	89 e8                	mov    %ebp,%eax
        col_bit = col_bit & 0x7;
   21439:	83 e5 07             	and    $0x7,%ebp
        map_p += (col_bit >> 3);
   2143c:	c1 e8 03             	shr    $0x3,%eax
   2143f:	48 01 44 24 70       	add    %rax,0x70(%rsp)
   21444:	e9 55 fe ff ff       	jmpq   2129e <lv_draw_label+0xbb7>
    if(fill_area.y1 != fill_area.y2) {
   21449:	66 8b 84 24 c6 00 00 	mov    0xc6(%rsp),%ax
   21450:	00 
   21451:	66 39 84 24 c2 00 00 	cmp    %ax,0xc2(%rsp)
   21458:	00 
   21459:	74 42                	je     2149d <lv_draw_label+0xdb6>
        fill_area.y2--;
   2145b:	ff c8                	dec    %eax
        _lv_blend_fill(clip_area, &fill_area,
   2145d:	48 8d b4 24 c0 00 00 	lea    0xc0(%rsp),%rsi
   21464:	00 
   21465:	48 83 ec 08          	sub    $0x8,%rsp
        fill_area.y2--;
   21469:	66 89 84 24 ce 00 00 	mov    %ax,0xce(%rsp)
   21470:	00 
        _lv_blend_fill(clip_area, &fill_area,
   21471:	8b 84 24 8c 00 00 00 	mov    0x8c(%rsp),%eax
   21478:	41 b9 ff 00 00 00    	mov    $0xff,%r9d
   2147e:	41 b8 02 00 00 00    	mov    $0x2,%r8d
   21484:	50                   	push   %rax
   21485:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
   2148a:	8b 94 24 88 00 00 00 	mov    0x88(%rsp),%edx
   21491:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
   21496:	e8 b2 da ff ff       	callq  1ef4d <_lv_blend_fill>
   2149b:	58                   	pop    %rax
   2149c:	5a                   	pop    %rdx
    _lv_mem_buf_release(mask_buf);
   2149d:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
   214a2:	e8 26 4e 00 00       	callq  262cd <_lv_mem_buf_release>
   214a7:	e9 69 f8 ff ff       	jmpq   20d15 <lv_draw_label+0x62e>
}
   214ac:	48 8b 84 24 68 01 00 	mov    0x168(%rsp),%rax
   214b3:	00 
   214b4:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   214bb:	00 00 
   214bd:	74 05                	je     214c4 <lv_draw_label+0xddd>
   214bf:	e8 7c 31 fe ff       	callq  4640 <__stack_chk_fail@plt>
   214c4:	48 81 c4 78 01 00 00 	add    $0x178,%rsp
   214cb:	5b                   	pop    %rbx
   214cc:	5d                   	pop    %rbp
   214cd:	41 5c                	pop    %r12
   214cf:	41 5d                	pop    %r13
   214d1:	41 5e                	pop    %r14
   214d3:	41 5f                	pop    %r15
   214d5:	c3                   	retq   

00000000000214d6 <lv_draw_line_dsc_init>:
   214d6:	48 8d 77 06          	lea    0x6(%rdi),%rsi
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

LV_ATTRIBUTE_FAST_MEM void lv_draw_line_dsc_init(lv_draw_line_dsc_t * dsc)
{
   214da:	48 89 fa             	mov    %rdi,%rdx
   214dd:	b9 06 00 00 00       	mov    $0x6,%ecx
   214e2:	31 c0                	xor    %eax,%eax
   214e4:	48 89 f7             	mov    %rsi,%rdi
   214e7:	f3 aa                	rep stos %al,%es:(%rdi)
    _lv_memset_00(dsc, sizeof(lv_draw_line_dsc_t));
    dsc->width = 1;
    dsc->opa = LV_OPA_COVER;
   214e9:	c6 42 0a ff          	movb   $0xff,0xa(%rdx)
    dsc->color = LV_COLOR_BLACK;
   214ed:	c7 02 00 00 00 ff    	movl   $0xff000000,(%rdx)
   214f3:	66 c7 42 04 01 00    	movw   $0x1,0x4(%rdx)
}
   214f9:	c3                   	retq   

00000000000214fa <lv_draw_line>:
 * @param clip the line will be drawn only in this area
 * @param dsc pointer to an initialized `lv_draw_line_dsc_t` variable
 */
LV_ATTRIBUTE_FAST_MEM void lv_draw_line(const lv_point_t * point1, const lv_point_t * point2, const lv_area_t * clip,
                                        const lv_draw_line_dsc_t * dsc)
{
   214fa:	41 57                	push   %r15
   214fc:	41 56                	push   %r14
   214fe:	41 55                	push   %r13
   21500:	41 54                	push   %r12
   21502:	55                   	push   %rbp
   21503:	53                   	push   %rbx
   21504:	48 81 ec c8 01 00 00 	sub    $0x1c8,%rsp
   2150b:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   21512:	00 00 
   21514:	48 89 84 24 b8 01 00 	mov    %rax,0x1b8(%rsp)
   2151b:	00 
   2151c:	31 c0                	xor    %eax,%eax
    if(dsc->width == 0) return;
   2151e:	8b 41 04             	mov    0x4(%rcx),%eax
{
   21521:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
   21526:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
   2152b:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    if(dsc->width == 0) return;
   21530:	66 85 c0             	test   %ax,%ax
   21533:	0f 84 4b 0b 00 00    	je     22084 <lv_draw_line+0xb8a>
    if(dsc->opa <= LV_OPA_MIN) return;
   21539:	80 79 0a 02          	cmpb   $0x2,0xa(%rcx)
   2153d:	49 89 cf             	mov    %rcx,%r15
   21540:	0f 86 3e 0b 00 00    	jbe    22084 <lv_draw_line+0xb8a>

    if(point1->x == point2->x && point1->y == point2->y) return;
   21546:	48 8b 5c 24 10       	mov    0x10(%rsp),%rbx
   2154b:	66 8b 37             	mov    (%rdi),%si
   2154e:	66 8b 4f 02          	mov    0x2(%rdi),%cx
   21552:	66 44 8b 03          	mov    (%rbx),%r8w
   21556:	48 8b 5c 24 10       	mov    0x10(%rsp),%rbx
   2155b:	66 44 39 c6          	cmp    %r8w,%si
   2155f:	66 8b 7b 02          	mov    0x2(%rbx),%di
   21563:	75 09                	jne    2156e <lv_draw_line+0x74>
   21565:	66 39 f9             	cmp    %di,%cx
   21568:	0f 84 16 0b 00 00    	je     22084 <lv_draw_line+0xb8a>

    lv_area_t clip_line;
    clip_line.x1 = LV_MATH_MIN(point1->x, point2->x) - dsc->width / 2;
   2156e:	89 c2                	mov    %eax,%edx
   21570:	41 b9 02 00 00 00    	mov    $0x2,%r9d
    clip_line.x2 = LV_MATH_MAX(point1->x, point2->x) + dsc->width / 2;
    clip_line.y1 = LV_MATH_MIN(point1->y, point2->y) - dsc->width / 2;
    clip_line.y2 = LV_MATH_MAX(point1->y, point2->y) + dsc->width / 2;

    bool is_common;
    is_common = _lv_area_intersect(&clip_line, &clip_line, clip);
   21576:	48 8d 6c 24 58       	lea    0x58(%rsp),%rbp
    clip_line.x1 = LV_MATH_MIN(point1->x, point2->x) - dsc->width / 2;
   2157b:	66 c1 fa 0f          	sar    $0xf,%dx
   2157f:	66 41 f7 f9          	idiv   %r9w
   21583:	66 44 39 c6          	cmp    %r8w,%si
   21587:	44 89 c2             	mov    %r8d,%edx
   2158a:	0f 4e d6             	cmovle %esi,%edx
   2158d:	29 c2                	sub    %eax,%edx
    clip_line.x2 = LV_MATH_MAX(point1->x, point2->x) + dsc->width / 2;
   2158f:	66 44 39 c6          	cmp    %r8w,%si
   21593:	41 0f 4c f0          	cmovl  %r8d,%esi
    clip_line.x1 = LV_MATH_MIN(point1->x, point2->x) - dsc->width / 2;
   21597:	66 89 54 24 58       	mov    %dx,0x58(%rsp)
    clip_line.y1 = LV_MATH_MIN(point1->y, point2->y) - dsc->width / 2;
   2159c:	89 fa                	mov    %edi,%edx
    clip_line.x2 = LV_MATH_MAX(point1->x, point2->x) + dsc->width / 2;
   2159e:	01 c6                	add    %eax,%esi
    clip_line.y1 = LV_MATH_MIN(point1->y, point2->y) - dsc->width / 2;
   215a0:	66 39 f9             	cmp    %di,%cx
   215a3:	0f 4e d1             	cmovle %ecx,%edx
    clip_line.x2 = LV_MATH_MAX(point1->x, point2->x) + dsc->width / 2;
   215a6:	66 89 74 24 5c       	mov    %si,0x5c(%rsp)
    is_common = _lv_area_intersect(&clip_line, &clip_line, clip);
   215ab:	48 89 ee             	mov    %rbp,%rsi
    clip_line.y1 = LV_MATH_MIN(point1->y, point2->y) - dsc->width / 2;
   215ae:	29 c2                	sub    %eax,%edx
    clip_line.y2 = LV_MATH_MAX(point1->y, point2->y) + dsc->width / 2;
   215b0:	66 39 f9             	cmp    %di,%cx
    clip_line.y1 = LV_MATH_MIN(point1->y, point2->y) - dsc->width / 2;
   215b3:	66 89 54 24 5a       	mov    %dx,0x5a(%rsp)
    is_common = _lv_area_intersect(&clip_line, &clip_line, clip);
   215b8:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    clip_line.y2 = LV_MATH_MAX(point1->y, point2->y) + dsc->width / 2;
   215bd:	0f 4c cf             	cmovl  %edi,%ecx
   215c0:	01 c8                	add    %ecx,%eax
    is_common = _lv_area_intersect(&clip_line, &clip_line, clip);
   215c2:	48 89 ef             	mov    %rbp,%rdi
    clip_line.y2 = LV_MATH_MAX(point1->y, point2->y) + dsc->width / 2;
   215c5:	66 89 44 24 5e       	mov    %ax,0x5e(%rsp)
    is_common = _lv_area_intersect(&clip_line, &clip_line, clip);
   215ca:	e8 4d 3f 00 00       	callq  2551c <_lv_area_intersect>
    if(!is_common) return;
   215cf:	84 c0                	test   %al,%al
   215d1:	0f 84 ad 0a 00 00    	je     22084 <lv_draw_line+0xb8a>

    if(point1->y == point2->y) draw_line_hor(point1, point2, &clip_line, dsc);
   215d7:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   215dc:	66 44 8b 60 02       	mov    0x2(%rax),%r12w
   215e1:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
   215e6:	66 44 8b 68 02       	mov    0x2(%rax),%r13w
   215eb:	66 45 39 ec          	cmp    %r13w,%r12w
   215ef:	0f 85 54 02 00 00    	jne    21849 <lv_draw_line+0x34f>

LV_ATTRIBUTE_FAST_MEM static void draw_line_hor(const lv_point_t * point1, const lv_point_t * point2,
                                                const lv_area_t * clip,
                                                const lv_draw_line_dsc_t * dsc)
{
    lv_opa_t opa = dsc->opa;
   215f5:	41 8a 47 0a          	mov    0xa(%r15),%al

    int32_t w = dsc->width - 1;
    int32_t w_half0 = w >> 1;
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/

    bool dashed = dsc->dash_gap && dsc->dash_width ? true : false;
   215f9:	45 31 ed             	xor    %r13d,%r13d
    lv_opa_t opa = dsc->opa;
   215fc:	88 04 24             	mov    %al,(%rsp)
    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
   215ff:	e8 36 c1 ff ff       	callq  1d73a <_lv_refr_get_disp_refreshing>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   21604:	48 89 c7             	mov    %rax,%rdi
   21607:	e8 f6 3a 00 00       	callq  25102 <lv_disp_get_buf>
    int32_t w = dsc->width - 1;
   2160c:	41 0f bf 5f 04       	movswl 0x4(%r15),%ebx
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   21611:	49 89 c4             	mov    %rax,%r12
    int32_t w = dsc->width - 1;
   21614:	ff cb                	dec    %ebx
    int32_t w_half0 = w >> 1;
   21616:	41 89 de             	mov    %ebx,%r14d
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/
   21619:	83 e3 01             	and    $0x1,%ebx
    int32_t w_half0 = w >> 1;
   2161c:	41 d1 fe             	sar    %r14d
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/
   2161f:	44 01 f3             	add    %r14d,%ebx
    bool dashed = dsc->dash_gap && dsc->dash_width ? true : false;
   21622:	66 41 83 7f 08 00    	cmpw   $0x0,0x8(%r15)
   21628:	74 0d                	je     21637 <lv_draw_line+0x13d>
   2162a:	45 31 ed             	xor    %r13d,%r13d
   2162d:	66 41 83 7f 06 00    	cmpw   $0x0,0x6(%r15)
   21633:	41 0f 95 c5          	setne  %r13b

    bool simple_mode = true;
    if(lv_draw_mask_get_cnt()) simple_mode = false;
   21637:	e8 48 18 00 00       	callq  22e84 <lv_draw_mask_get_cnt>
    else if(dashed) simple_mode = false;

    lv_area_t draw_area;
    draw_area.x1 = LV_MATH_MIN(point1->x, point2->x);
   2163c:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
   21641:	48 8d bc 24 f0 00 00 	lea    0xf0(%rsp),%rdi
   21648:	00 
   21649:	66 8b 16             	mov    (%rsi),%dx
   2164c:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   21651:	66 8b 0e             	mov    (%rsi),%cx
   21654:	66 39 ca             	cmp    %cx,%dx
   21657:	89 ce                	mov    %ecx,%esi
   21659:	0f 4e f2             	cmovle %edx,%esi
    draw_area.x2 = LV_MATH_MAX(point1->x, point2->x)  - 1;
   2165c:	0f 4c d1             	cmovl  %ecx,%edx
    draw_area.x1 = LV_MATH_MIN(point1->x, point2->x);
   2165f:	66 89 b4 24 f0 00 00 	mov    %si,0xf0(%rsp)
   21666:	00 
    draw_area.y1 = point1->y - w_half1;
   21667:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    draw_area.x2 = LV_MATH_MAX(point1->x, point2->x)  - 1;
   2166c:	ff ca                	dec    %edx
   2166e:	66 89 94 24 f4 00 00 	mov    %dx,0xf4(%rsp)
   21675:	00 
    draw_area.y1 = point1->y - w_half1;
   21676:	66 8b 56 02          	mov    0x2(%rsi),%dx
   2167a:	89 d1                	mov    %edx,%ecx
    draw_area.y2 = point1->y + w_half0;
   2167c:	41 01 d6             	add    %edx,%r14d
    draw_area.y1 = point1->y - w_half1;
   2167f:	29 d9                	sub    %ebx,%ecx

    /*If there is no mask then simply draw a rectangle*/
    if(simple_mode) {
   21681:	84 c0                	test   %al,%al
    draw_area.y2 = point1->y + w_half0;
   21683:	66 44 89 b4 24 f6 00 	mov    %r14w,0xf6(%rsp)
   2168a:	00 00 
    draw_area.y1 = point1->y - w_half1;
   2168c:	66 89 8c 24 f2 00 00 	mov    %cx,0xf2(%rsp)
   21693:	00 
    if(simple_mode) {
   21694:	75 09                	jne    2169f <lv_draw_line+0x1a5>
   21696:	45 85 ed             	test   %r13d,%r13d
   21699:	0f 84 69 02 00 00    	je     21908 <lv_draw_line+0x40e>
    /*If there other mask apply it*/
    else {
        /* Get clipped fill area which is the real draw area.
         * It is always the same or inside `fill_area` */
        bool is_common;
        is_common = _lv_area_intersect(&draw_area, clip, &draw_area);
   2169f:	48 89 fa             	mov    %rdi,%rdx
   216a2:	48 89 ee             	mov    %rbp,%rsi
   216a5:	e8 72 3e 00 00       	callq  2551c <_lv_area_intersect>
        if(!is_common) return;
   216aa:	84 c0                	test   %al,%al
   216ac:	0f 84 c9 08 00 00    	je     21f7b <lv_draw_line+0xa81>

        /* Now `draw_area` has absolute coordinates.
         * Make it relative to `disp_area` to simplify draw to `disp_buf`*/
        draw_area.x1 -= disp_area->x1;
        draw_area.y1 -= disp_area->y1;
   216b2:	66 8b b4 24 f2 00 00 	mov    0xf2(%rsp),%si
   216b9:	00 
   216ba:	66 45 8b 4c 24 1e    	mov    0x1e(%r12),%r9w
        fill_area.x1 = draw_area.x1 + disp_area->x1;
        fill_area.x2 = draw_area.x2 + disp_area->x1;
        fill_area.y1 = draw_area.y1 + disp_area->y1;
        fill_area.y2 = fill_area.y1;

        lv_style_int_t dash_start = 0;
   216c0:	45 31 f6             	xor    %r14d,%r14d
        draw_area.x1 -= disp_area->x1;
   216c3:	41 0f bf 44 24 1c    	movswl 0x1c(%r12),%eax
        draw_area.x2 -= disp_area->x1;
   216c9:	8b bc 24 f4 00 00 00 	mov    0xf4(%rsp),%edi
        draw_area.x1 -= disp_area->x1;
   216d0:	44 8b 84 24 f0 00 00 	mov    0xf0(%rsp),%r8d
   216d7:	00 
        draw_area.y2 -= disp_area->y1;
   216d8:	66 44 29 8c 24 f6 00 	sub    %r9w,0xf6(%rsp)
   216df:	00 00 
        draw_area.y1 -= disp_area->y1;
   216e1:	89 f1                	mov    %esi,%ecx
        fill_area.y1 = draw_area.y1 + disp_area->y1;
   216e3:	66 89 b4 24 32 01 00 	mov    %si,0x132(%rsp)
   216ea:	00 
        fill_area.y2 = fill_area.y1;
   216eb:	66 89 b4 24 36 01 00 	mov    %si,0x136(%rsp)
   216f2:	00 
        draw_area.y1 -= disp_area->y1;
   216f3:	44 29 c9             	sub    %r9d,%ecx
        fill_area.x2 = draw_area.x2 + disp_area->x1;
   216f6:	66 89 bc 24 34 01 00 	mov    %di,0x134(%rsp)
   216fd:	00 
        draw_area.y1 -= disp_area->y1;
   216fe:	66 89 8c 24 f2 00 00 	mov    %cx,0xf2(%rsp)
   21705:	00 
        draw_area.x2 -= disp_area->x1;
   21706:	89 f9                	mov    %edi,%ecx
        draw_area.x1 -= disp_area->x1;
   21708:	44 89 c2             	mov    %r8d,%edx
        draw_area.x2 -= disp_area->x1;
   2170b:	29 c1                	sub    %eax,%ecx
        draw_area.x1 -= disp_area->x1;
   2170d:	29 c2                	sub    %eax,%edx
        fill_area.x1 = draw_area.x1 + disp_area->x1;
   2170f:	66 44 89 84 24 30 01 	mov    %r8w,0x130(%rsp)
   21716:	00 00 
        draw_area.x2 -= disp_area->x1;
   21718:	66 89 8c 24 f4 00 00 	mov    %cx,0xf4(%rsp)
   2171f:	00 
   21720:	ff c1                	inc    %ecx
        draw_area.x1 -= disp_area->x1;
   21722:	66 89 94 24 f0 00 00 	mov    %dx,0xf0(%rsp)
   21729:	00 
   2172a:	29 d1                	sub    %edx,%ecx
        if(dashed) {
   2172c:	45 85 ed             	test   %r13d,%r13d
        int32_t draw_area_w = lv_area_get_width(&draw_area);
   2172f:	0f bf d9             	movswl %cx,%ebx
   21732:	66 89 0c 24          	mov    %cx,(%rsp)
   21736:	89 5c 24 18          	mov    %ebx,0x18(%rsp)
        if(dashed) {
   2173a:	74 17                	je     21753 <lv_draw_line+0x259>
            dash_start = (vdb->area.x1 + draw_area.x1) % (dsc->dash_gap + dsc->dash_width);
   2173c:	0f bf d2             	movswl %dx,%edx
   2173f:	41 0f bf 4f 08       	movswl 0x8(%r15),%ecx
   21744:	01 d0                	add    %edx,%eax
   21746:	41 0f bf 57 06       	movswl 0x6(%r15),%edx
   2174b:	01 d1                	add    %edx,%ecx
   2174d:	99                   	cltd   
   2174e:	f7 f9                	idiv   %ecx
   21750:	41 89 d6             	mov    %edx,%r14d
        }

        lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   21753:	8b 7c 24 18          	mov    0x18(%rsp),%edi
   21757:	e8 82 4a 00 00       	callq  261de <_lv_mem_buf_get>
   2175c:	48 89 c3             	mov    %rax,%rbx
        int32_t h;
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
            _lv_memset_ff(mask_buf, draw_area_w);
   2175f:	48 0f bf 04 24       	movswq (%rsp),%rax
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   21764:	0f bf ac 24 f2 00 00 	movswl 0xf2(%rsp),%ebp
   2176b:	00 
            _lv_memset_ff(mask_buf, draw_area_w);
   2176c:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   21771:	0f bf 84 24 f6 00 00 	movswl 0xf6(%rsp),%eax
   21778:	00 
   21779:	39 c5                	cmp    %eax,%ebp
   2177b:	0f 8f c0 00 00 00    	jg     21841 <lv_draw_line+0x347>
   21781:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
   21786:	b0 ff                	mov    $0xff,%al
   21788:	48 89 df             	mov    %rbx,%rdi
   2178b:	f3 aa                	rep stos %al,%es:(%rdi)
            lv_draw_mask_res_t mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
   2178d:	8b 4c 24 18          	mov    0x18(%rsp),%ecx
   21791:	48 89 df             	mov    %rbx,%rdi
   21794:	66 41 8b 54 24 1e    	mov    0x1e(%r12),%dx
   2179a:	8b b4 24 f0 00 00 00 	mov    0xf0(%rsp),%esi
   217a1:	41 03 74 24 1c       	add    0x1c(%r12),%esi
   217a6:	01 ea                	add    %ebp,%edx
   217a8:	0f bf d2             	movswl %dx,%edx
   217ab:	0f bf f6             	movswl %si,%esi
   217ae:	e8 11 16 00 00       	callq  22dc4 <lv_draw_mask_apply>

            if(dashed) {
   217b3:	45 85 ed             	test   %r13d,%r13d
   217b6:	74 42                	je     217fa <lv_draw_line+0x300>
                if(mask_res != LV_DRAW_MASK_RES_TRANSP) {
   217b8:	84 c0                	test   %al,%al
   217ba:	74 3e                	je     217fa <lv_draw_line+0x300>
                    lv_style_int_t dash_cnt = dash_start;
   217bc:	44 89 f1             	mov    %r14d,%ecx
                    lv_coord_t i;
                    for(i = 0; i < draw_area_w; i++, dash_cnt++) {
   217bf:	31 c0                	xor    %eax,%eax
   217c1:	66 39 04 24          	cmp    %ax,(%rsp)
   217c5:	7e 31                	jle    217f8 <lv_draw_line+0x2fe>
                        if(dash_cnt <= dsc->dash_width) {
   217c7:	41 0f bf 57 06       	movswl 0x6(%r15),%edx
   217cc:	66 39 ca             	cmp    %cx,%dx
   217cf:	7c 06                	jl     217d7 <lv_draw_line+0x2dd>
                            int16_t diff = dsc->dash_width - dash_cnt;
                            i += diff;
   217d1:	01 d0                	add    %edx,%eax
   217d3:	29 c8                	sub    %ecx,%eax
   217d5:	eb 1a                	jmp    217f1 <lv_draw_line+0x2f7>
                            dash_cnt += diff;
                        }
                        else if(dash_cnt >= dsc->dash_gap + dsc->dash_width) {
   217d7:	41 0f bf 77 08       	movswl 0x8(%r15),%esi
   217dc:	0f bf f9             	movswl %cx,%edi
   217df:	01 d6                	add    %edx,%esi
                            dash_cnt = 0;
   217e1:	31 d2                	xor    %edx,%edx
                        else if(dash_cnt >= dsc->dash_gap + dsc->dash_width) {
   217e3:	39 f7                	cmp    %esi,%edi
   217e5:	7d 0a                	jge    217f1 <lv_draw_line+0x2f7>
                        }
                        else {
                            mask_buf[i] = 0x00;
   217e7:	48 0f bf d0          	movswq %ax,%rdx
   217eb:	c6 04 13 00          	movb   $0x0,(%rbx,%rdx,1)
   217ef:	89 ca                	mov    %ecx,%edx
                    for(i = 0; i < draw_area_w; i++, dash_cnt++) {
   217f1:	ff c0                	inc    %eax
   217f3:	8d 4a 01             	lea    0x1(%rdx),%ecx
   217f6:	eb c9                	jmp    217c1 <lv_draw_line+0x2c7>
                        }
                    }

                    mask_res = LV_DRAW_MASK_RES_CHANGED;
   217f8:	b0 02                	mov    $0x2,%al
                }
            }

            _lv_blend_fill(clip, &fill_area,
                           dsc->color, mask_buf, mask_res, dsc->opa,
                           dsc->blend_mode);
   217fa:	41 8a 57 0b          	mov    0xb(%r15),%dl
            _lv_blend_fill(clip, &fill_area,
   217fe:	48 8d b4 24 30 01 00 	lea    0x130(%rsp),%rsi
   21805:	00 
   21806:	48 8d 7c 24 58       	lea    0x58(%rsp),%rdi
   2180b:	48 83 ec 08          	sub    $0x8,%rsp
   2180f:	44 0f b6 c0          	movzbl %al,%r8d
   21813:	48 89 d9             	mov    %rbx,%rcx
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   21816:	ff c5                	inc    %ebp
            _lv_blend_fill(clip, &fill_area,
   21818:	83 e2 03             	and    $0x3,%edx
   2181b:	52                   	push   %rdx
   2181c:	45 0f b6 4f 0a       	movzbl 0xa(%r15),%r9d
   21821:	41 8b 17             	mov    (%r15),%edx
   21824:	e8 24 d7 ff ff       	callq  1ef4d <_lv_blend_fill>
   21829:	41 5b                	pop    %r11
   2182b:	58                   	pop    %rax

            fill_area.y1++;
   2182c:	66 ff 84 24 32 01 00 	incw   0x132(%rsp)
   21833:	00 
            fill_area.y2++;
   21834:	66 ff 84 24 36 01 00 	incw   0x136(%rsp)
   2183b:	00 
   2183c:	e9 30 ff ff ff       	jmpq   21771 <lv_draw_line+0x277>
        }
        _lv_mem_buf_release(mask_buf);
   21841:	48 89 df             	mov    %rbx,%rdi
   21844:	e9 6f 02 00 00       	jmpq   21ab8 <lv_draw_line+0x5be>
    else if(point1->x == point2->x) draw_line_ver(point1, point2, &clip_line, dsc);
   21849:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   2184e:	66 8b 18             	mov    (%rax),%bx
   21851:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
   21856:	66 8b 00             	mov    (%rax),%ax
   21859:	66 39 c3             	cmp    %ax,%bx
   2185c:	66 89 04 24          	mov    %ax,(%rsp)
   21860:	0f 85 5c 02 00 00    	jne    21ac2 <lv_draw_line+0x5c8>

LV_ATTRIBUTE_FAST_MEM static void draw_line_ver(const lv_point_t * point1, const lv_point_t * point2,
                                                const lv_area_t * clip,
                                                const lv_draw_line_dsc_t * dsc)
{
    lv_opa_t opa = dsc->opa;
   21866:	41 8a 47 0a          	mov    0xa(%r15),%al

    int32_t w = dsc->width - 1;
    int32_t w_half0 = w >> 1;
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/

    bool dashed = dsc->dash_gap && dsc->dash_width ? true : false;
   2186a:	45 31 ed             	xor    %r13d,%r13d
    lv_opa_t opa = dsc->opa;
   2186d:	88 04 24             	mov    %al,(%rsp)
    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
   21870:	e8 c5 be ff ff       	callq  1d73a <_lv_refr_get_disp_refreshing>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   21875:	48 89 c7             	mov    %rax,%rdi
   21878:	e8 85 38 00 00       	callq  25102 <lv_disp_get_buf>
    int32_t w = dsc->width - 1;
   2187d:	41 0f bf 5f 04       	movswl 0x4(%r15),%ebx
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   21882:	49 89 c4             	mov    %rax,%r12
    int32_t w = dsc->width - 1;
   21885:	ff cb                	dec    %ebx
    int32_t w_half0 = w >> 1;
   21887:	41 89 de             	mov    %ebx,%r14d
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/
   2188a:	83 e3 01             	and    $0x1,%ebx
    int32_t w_half0 = w >> 1;
   2188d:	41 d1 fe             	sar    %r14d
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/
   21890:	44 01 f3             	add    %r14d,%ebx
    bool dashed = dsc->dash_gap && dsc->dash_width ? true : false;
   21893:	66 41 83 7f 08 00    	cmpw   $0x0,0x8(%r15)
   21899:	74 0d                	je     218a8 <lv_draw_line+0x3ae>
   2189b:	45 31 ed             	xor    %r13d,%r13d
   2189e:	66 41 83 7f 06 00    	cmpw   $0x0,0x6(%r15)
   218a4:	41 0f 95 c5          	setne  %r13b

    bool simple_mode = true;
    if(lv_draw_mask_get_cnt()) simple_mode = false;
   218a8:	e8 d7 15 00 00       	callq  22e84 <lv_draw_mask_get_cnt>
    else if(dashed) simple_mode = false;

    lv_area_t draw_area;
    draw_area.x1 = point1->x - w_half1;
   218ad:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   218b2:	48 8d bc 24 f0 00 00 	lea    0xf0(%rsp),%rdi
   218b9:	00 
   218ba:	66 8b 16             	mov    (%rsi),%dx
   218bd:	89 d1                	mov    %edx,%ecx
    draw_area.x2 = point1->x + w_half0;
   218bf:	41 01 d6             	add    %edx,%r14d
    draw_area.x1 = point1->x - w_half1;
   218c2:	29 d9                	sub    %ebx,%ecx
    draw_area.y1 = LV_MATH_MIN(point1->y, point2->y);
   218c4:	48 8b 5c 24 10       	mov    0x10(%rsp),%rbx
    draw_area.x2 = point1->x + w_half0;
   218c9:	66 44 89 b4 24 f4 00 	mov    %r14w,0xf4(%rsp)
   218d0:	00 00 
    draw_area.x1 = point1->x - w_half1;
   218d2:	66 89 8c 24 f0 00 00 	mov    %cx,0xf0(%rsp)
   218d9:	00 
    draw_area.y1 = LV_MATH_MIN(point1->y, point2->y);
   218da:	66 8b 4e 02          	mov    0x2(%rsi),%cx
   218de:	66 8b 53 02          	mov    0x2(%rbx),%dx
   218e2:	89 ce                	mov    %ecx,%esi
   218e4:	66 39 ca             	cmp    %cx,%dx
   218e7:	0f 4e f2             	cmovle %edx,%esi
    draw_area.y2 = LV_MATH_MAX(point1->y, point2->y) - 1;
   218ea:	0f 4c d1             	cmovl  %ecx,%edx
   218ed:	ff ca                	dec    %edx

    /*If there is no mask then simply draw a rectangle*/
    if(simple_mode) {
   218ef:	84 c0                	test   %al,%al
    draw_area.y1 = LV_MATH_MIN(point1->y, point2->y);
   218f1:	66 89 b4 24 f2 00 00 	mov    %si,0xf2(%rsp)
   218f8:	00 
    draw_area.y2 = LV_MATH_MAX(point1->y, point2->y) - 1;
   218f9:	66 89 94 24 f6 00 00 	mov    %dx,0xf6(%rsp)
   21900:	00 
    if(simple_mode) {
   21901:	75 36                	jne    21939 <lv_draw_line+0x43f>
   21903:	45 85 ed             	test   %r13d,%r13d
   21906:	75 31                	jne    21939 <lv_draw_line+0x43f>
        _lv_blend_fill(clip, &draw_area,
                       dsc->color,  NULL, LV_DRAW_MASK_RES_FULL_COVER, opa,
                       dsc->blend_mode);
   21908:	41 8a 47 0b          	mov    0xb(%r15),%al
        _lv_blend_fill(clip, &draw_area,
   2190c:	48 83 ec 08          	sub    $0x8,%rsp
   21910:	48 89 fe             	mov    %rdi,%rsi
   21913:	41 b8 01 00 00 00    	mov    $0x1,%r8d
   21919:	31 c9                	xor    %ecx,%ecx
   2191b:	48 89 ef             	mov    %rbp,%rdi
   2191e:	83 e0 03             	and    $0x3,%eax
   21921:	50                   	push   %rax
   21922:	44 0f b6 4c 24 10    	movzbl 0x10(%rsp),%r9d
   21928:	41 8b 17             	mov    (%r15),%edx
   2192b:	e8 1d d6 ff ff       	callq  1ef4d <_lv_blend_fill>
   21930:	41 59                	pop    %r9
   21932:	41 5a                	pop    %r10
   21934:	e9 42 06 00 00       	jmpq   21f7b <lv_draw_line+0xa81>
    /*If there other mask apply it*/
    else {
        /* Get clipped fill area which is the real draw area.
         * It is always the same or inside `fill_area` */
        bool is_common;
        is_common = _lv_area_intersect(&draw_area, clip, &draw_area);
   21939:	48 89 fa             	mov    %rdi,%rdx
   2193c:	48 89 ee             	mov    %rbp,%rsi
   2193f:	e8 d8 3b 00 00       	callq  2551c <_lv_area_intersect>
        if(!is_common) return;
   21944:	84 c0                	test   %al,%al
   21946:	0f 84 2f 06 00 00    	je     21f7b <lv_draw_line+0xa81>

        /* Now `draw_area` has absolute coordinates.
         * Make it relative to `disp_area` to simplify draw to `disp_buf`*/
        draw_area.x1 -= vdb->area.x1;
        draw_area.y1 -= vdb->area.y1;
   2194c:	66 8b 84 24 f2 00 00 	mov    0xf2(%rsp),%ax
   21953:	00 
   21954:	66 41 8b 7c 24 1e    	mov    0x1e(%r12),%di
        fill_area.y1 = draw_area.y1 + disp_area->y1;
        fill_area.y2 = fill_area.y1;

        lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);

        lv_style_int_t dash_start = 0;
   2195a:	45 31 f6             	xor    %r14d,%r14d
        draw_area.x1 -= vdb->area.x1;
   2195d:	45 8b 44 24 1c       	mov    0x1c(%r12),%r8d
   21962:	8b 8c 24 f0 00 00 00 	mov    0xf0(%rsp),%ecx
        draw_area.y2 -= vdb->area.y1;
   21969:	66 29 bc 24 f6 00 00 	sub    %di,0xf6(%rsp)
   21970:	00 
        draw_area.y1 -= vdb->area.y1;
   21971:	89 c2                	mov    %eax,%edx
        fill_area.y1 = draw_area.y1 + disp_area->y1;
   21973:	66 89 84 24 32 01 00 	mov    %ax,0x132(%rsp)
   2197a:	00 
        fill_area.y2 = fill_area.y1;
   2197b:	66 89 84 24 36 01 00 	mov    %ax,0x136(%rsp)
   21982:	00 
        draw_area.y1 -= vdb->area.y1;
   21983:	29 fa                	sub    %edi,%edx
        draw_area.x1 -= vdb->area.x1;
   21985:	89 ce                	mov    %ecx,%esi
        fill_area.x1 = draw_area.x1 + disp_area->x1;
   21987:	66 89 8c 24 30 01 00 	mov    %cx,0x130(%rsp)
   2198e:	00 
        draw_area.y1 -= vdb->area.y1;
   2198f:	66 89 94 24 f2 00 00 	mov    %dx,0xf2(%rsp)
   21996:	00 
        draw_area.x1 -= vdb->area.x1;
   21997:	44 29 c6             	sub    %r8d,%esi
        draw_area.x2 -= vdb->area.x1;
   2199a:	8b 94 24 f4 00 00 00 	mov    0xf4(%rsp),%edx
        draw_area.x1 -= vdb->area.x1;
   219a1:	66 89 b4 24 f0 00 00 	mov    %si,0xf0(%rsp)
   219a8:	00 
        draw_area.x2 -= vdb->area.x1;
   219a9:	89 d5                	mov    %edx,%ebp
        fill_area.x2 = draw_area.x2 + disp_area->x1;
   219ab:	66 89 94 24 34 01 00 	mov    %dx,0x134(%rsp)
   219b2:	00 
        draw_area.x2 -= vdb->area.x1;
   219b3:	44 29 c5             	sub    %r8d,%ebp
   219b6:	66 89 ac 24 f4 00 00 	mov    %bp,0xf4(%rsp)
   219bd:	00 
   219be:	ff c5                	inc    %ebp
   219c0:	29 f5                	sub    %esi,%ebp
        int32_t draw_area_w = lv_area_get_width(&draw_area);
   219c2:	0f bf dd             	movswl %bp,%ebx
        lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   219c5:	89 df                	mov    %ebx,%edi
        int32_t draw_area_w = lv_area_get_width(&draw_area);
   219c7:	89 5c 24 18          	mov    %ebx,0x18(%rsp)
        lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   219cb:	e8 0e 48 00 00       	callq  261de <_lv_mem_buf_get>
        if(dashed) {
   219d0:	45 85 ed             	test   %r13d,%r13d
        lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   219d3:	48 89 04 24          	mov    %rax,(%rsp)
   219d7:	0f bf 9c 24 f2 00 00 	movswl 0xf2(%rsp),%ebx
   219de:	00 
        if(dashed) {
   219df:	74 1a                	je     219fb <lv_draw_line+0x501>
            dash_start = (vdb->area.y1 + draw_area.y1) % (dsc->dash_gap + dsc->dash_width);
   219e1:	41 0f bf 44 24 1e    	movswl 0x1e(%r12),%eax
   219e7:	41 0f bf 57 06       	movswl 0x6(%r15),%edx
   219ec:	41 0f bf 4f 08       	movswl 0x8(%r15),%ecx
   219f1:	01 d8                	add    %ebx,%eax
   219f3:	01 d1                	add    %edx,%ecx
   219f5:	99                   	cltd   
   219f6:	f7 f9                	idiv   %ecx
   219f8:	41 89 d6             	mov    %edx,%r14d

        lv_style_int_t dash_cnt = dash_start;

        int32_t h;
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
            _lv_memset_ff(mask_buf, draw_area_w);
   219fb:	48 0f bf ed          	movswq %bp,%rbp
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   219ff:	0f bf 84 24 f6 00 00 	movswl 0xf6(%rsp),%eax
   21a06:	00 
   21a07:	39 c3                	cmp    %eax,%ebx
   21a09:	0f 8f a5 00 00 00    	jg     21ab4 <lv_draw_line+0x5ba>
   21a0f:	48 8b 3c 24          	mov    (%rsp),%rdi
   21a13:	b0 ff                	mov    $0xff,%al
   21a15:	48 89 e9             	mov    %rbp,%rcx
   21a18:	f3 aa                	rep stos %al,%es:(%rdi)
            lv_draw_mask_res_t mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
   21a1a:	8b 4c 24 18          	mov    0x18(%rsp),%ecx
   21a1e:	48 8b 3c 24          	mov    (%rsp),%rdi
   21a22:	66 41 8b 54 24 1e    	mov    0x1e(%r12),%dx
   21a28:	8b b4 24 f0 00 00 00 	mov    0xf0(%rsp),%esi
   21a2f:	41 03 74 24 1c       	add    0x1c(%r12),%esi
   21a34:	01 da                	add    %ebx,%edx
   21a36:	0f bf d2             	movswl %dx,%edx
   21a39:	0f bf f6             	movswl %si,%esi
   21a3c:	e8 83 13 00 00       	callq  22dc4 <lv_draw_mask_apply>

            if(dashed) {
   21a41:	45 85 ed             	test   %r13d,%r13d
   21a44:	74 2b                	je     21a71 <lv_draw_line+0x577>
                if(mask_res != LV_DRAW_MASK_RES_TRANSP) {
   21a46:	84 c0                	test   %al,%al
   21a48:	74 24                	je     21a6e <lv_draw_line+0x574>
                    if(dash_cnt > dsc->dash_width) {
   21a4a:	41 0f bf 57 06       	movswl 0x6(%r15),%edx
                        mask_res = LV_DRAW_MASK_RES_TRANSP;
   21a4f:	b1 00                	mov    $0x0,%cl
                    }

                    if(dash_cnt >= dsc->dash_gap + dsc->dash_width) {
   21a51:	41 0f bf f6          	movswl %r14w,%esi
                        mask_res = LV_DRAW_MASK_RES_TRANSP;
   21a55:	66 44 39 f2          	cmp    %r14w,%dx
   21a59:	0f 4c c1             	cmovl  %ecx,%eax
                    if(dash_cnt >= dsc->dash_gap + dsc->dash_width) {
   21a5c:	41 0f bf 4f 08       	movswl 0x8(%r15),%ecx
   21a61:	01 ca                	add    %ecx,%edx
                        dash_cnt = 0;
   21a63:	39 d6                	cmp    %edx,%esi
   21a65:	ba 00 00 00 00       	mov    $0x0,%edx
   21a6a:	44 0f 4d f2          	cmovge %edx,%r14d
                    }
                }
                dash_cnt ++;
   21a6e:	41 ff c6             	inc    %r14d
            }

            _lv_blend_fill(clip, &fill_area,
   21a71:	48 8d 7c 24 58       	lea    0x58(%rsp),%rdi
   21a76:	48 8d b4 24 30 01 00 	lea    0x130(%rsp),%rsi
   21a7d:	00 
   21a7e:	48 83 ec 08          	sub    $0x8,%rsp
   21a82:	6a 00                	pushq  $0x0
   21a84:	45 0f b6 4f 0a       	movzbl 0xa(%r15),%r9d
   21a89:	44 0f b6 c0          	movzbl %al,%r8d
   21a8d:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
   21a92:	41 8b 17             	mov    (%r15),%edx
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   21a95:	ff c3                	inc    %ebx
            _lv_blend_fill(clip, &fill_area,
   21a97:	e8 b1 d4 ff ff       	callq  1ef4d <_lv_blend_fill>
   21a9c:	5f                   	pop    %rdi
   21a9d:	41 58                	pop    %r8
                           dsc->color, mask_buf, mask_res, dsc->opa,
                           LV_BLEND_MODE_NORMAL);

            fill_area.y1++;
   21a9f:	66 ff 84 24 32 01 00 	incw   0x132(%rsp)
   21aa6:	00 
            fill_area.y2++;
   21aa7:	66 ff 84 24 36 01 00 	incw   0x136(%rsp)
   21aae:	00 
   21aaf:	e9 4b ff ff ff       	jmpq   219ff <lv_draw_line+0x505>
        }
        _lv_mem_buf_release(mask_buf);
   21ab4:	48 8b 3c 24          	mov    (%rsp),%rdi
   21ab8:	e8 10 48 00 00       	callq  262cd <_lv_mem_buf_release>
   21abd:	e9 b9 04 00 00       	jmpq   21f7b <lv_draw_line+0xa81>
                                                 const lv_draw_line_dsc_t * dsc)
{
    /*Keep the great y in p1*/
    lv_point_t p1;
    lv_point_t p2;
    if(point1->y < point2->y) {
   21ac2:	66 45 39 ec          	cmp    %r13w,%r12w
   21ac6:	7d 12                	jge    21ada <lv_draw_line+0x5e0>
   21ac8:	44 89 e8             	mov    %r13d,%eax
   21acb:	45 89 e5             	mov    %r12d,%r13d
   21ace:	41 89 c4             	mov    %eax,%r12d
   21ad1:	8b 04 24             	mov    (%rsp),%eax
   21ad4:	66 89 1c 24          	mov    %bx,(%rsp)
   21ad8:	89 c3                	mov    %eax,%ebx
        p2.y = point1->y;
        p1.x = point2->x;
        p2.x = point1->x;
    }

    int32_t xdiff = p2.x - p1.x;
   21ada:	0f bf c3             	movswl %bx,%eax
        143, 145, 147, 149, 151, 153, 155, 158,
        160, 162, 165, 167, 170, 173, 175, 178,
        181,
    };

    int32_t w = dsc->width;
   21add:	41 0f bf 77 04       	movswl 0x4(%r15),%esi
    int32_t xdiff = p2.x - p1.x;
   21ae2:	89 44 24 40          	mov    %eax,0x40(%rsp)
   21ae6:	0f bf 04 24          	movswl (%rsp),%eax
   21aea:	89 44 24 18          	mov    %eax,0x18(%rsp)
   21aee:	0f bf c3             	movswl %bx,%eax
   21af1:	2b 44 24 18          	sub    0x18(%rsp),%eax
   21af5:	89 44 24 20          	mov    %eax,0x20(%rsp)
    int32_t ydiff = p2.y - p1.y;
   21af9:	41 0f bf c4          	movswl %r12w,%eax
    bool flat = LV_MATH_ABS(xdiff) > LV_MATH_ABS(ydiff) ? true : false;
   21afd:	8b 4c 24 20          	mov    0x20(%rsp),%ecx
    int32_t ydiff = p2.y - p1.y;
   21b01:	89 44 24 44          	mov    %eax,0x44(%rsp)
   21b05:	41 0f bf c5          	movswl %r13w,%eax
   21b09:	89 44 24 38          	mov    %eax,0x38(%rsp)
   21b0d:	41 0f bf c4          	movswl %r12w,%eax
   21b11:	2b 44 24 38          	sub    0x38(%rsp),%eax
   21b15:	89 44 24 2c          	mov    %eax,0x2c(%rsp)
    bool flat = LV_MATH_ABS(xdiff) > LV_MATH_ABS(ydiff) ? true : false;
   21b19:	8b 44 24 20          	mov    0x20(%rsp),%eax
   21b1d:	44 8b 44 24 2c       	mov    0x2c(%rsp),%r8d
   21b22:	c1 f8 1f             	sar    $0x1f,%eax
   21b25:	31 c1                	xor    %eax,%ecx
   21b27:	29 c1                	sub    %eax,%ecx
   21b29:	8b 44 24 2c          	mov    0x2c(%rsp),%eax
   21b2d:	c1 f8 1f             	sar    $0x1f,%eax
   21b30:	41 31 c0             	xor    %eax,%r8d
   21b33:	41 29 c0             	sub    %eax,%r8d
    int32_t wcorr_i = 0;
    if(flat) wcorr_i = (LV_MATH_ABS(ydiff) << 5) / LV_MATH_ABS(xdiff);
   21b36:	44 39 c1             	cmp    %r8d,%ecx
   21b39:	7e 0b                	jle    21b46 <lv_draw_line+0x64c>
   21b3b:	44 89 c0             	mov    %r8d,%eax
   21b3e:	c1 e0 05             	shl    $0x5,%eax
   21b41:	99                   	cltd   
   21b42:	f7 f9                	idiv   %ecx
   21b44:	eb 09                	jmp    21b4f <lv_draw_line+0x655>
    else wcorr_i = (LV_MATH_ABS(xdiff) << 5) / LV_MATH_ABS(ydiff);
   21b46:	89 c8                	mov    %ecx,%eax
   21b48:	c1 e0 05             	shl    $0x5,%eax
   21b4b:	99                   	cltd   
   21b4c:	41 f7 f8             	idiv   %r8d

    w = (w * wcorr[wcorr_i] + 63) >> 7;     /*+ 63 for rounding*/
   21b4f:	48 8d 15 4a b7 00 00 	lea    0xb74a(%rip),%rdx        # 2d2a0 <wcorr.6203>
   21b56:	48 98                	cltq   
    draw_area.y2 = LV_MATH_MAX(p1.y, p2.y) + w;

    /* Get the union of `coords` and `clip`*/
    /* `clip` is already truncated to the `vdb` size
     * in 'lv_refr_area' function */
    bool is_common = _lv_area_intersect(&draw_area, &draw_area, clip);
   21b58:	48 8d 7c 24 60       	lea    0x60(%rsp),%rdi
   21b5d:	44 89 44 24 48       	mov    %r8d,0x48(%rsp)
   21b62:	89 4c 24 3c          	mov    %ecx,0x3c(%rsp)
    w = (w * wcorr[wcorr_i] + 63) >> 7;     /*+ 63 for rounding*/
   21b66:	44 0f b6 34 02       	movzbl (%rdx,%rax,1),%r14d
    draw_area.x1 = LV_MATH_MIN(p1.x, p2.x) - w;
   21b6b:	8b 04 24             	mov    (%rsp),%eax
    bool is_common = _lv_area_intersect(&draw_area, &draw_area, clip);
   21b6e:	48 8d 54 24 58       	lea    0x58(%rsp),%rdx
    w = (w * wcorr[wcorr_i] + 63) >> 7;     /*+ 63 for rounding*/
   21b73:	44 0f af f6          	imul   %esi,%r14d
    bool is_common = _lv_area_intersect(&draw_area, &draw_area, clip);
   21b77:	48 89 fe             	mov    %rdi,%rsi
    w = (w * wcorr[wcorr_i] + 63) >> 7;     /*+ 63 for rounding*/
   21b7a:	41 83 c6 3f          	add    $0x3f,%r14d
   21b7e:	44 89 f5             	mov    %r14d,%ebp
   21b81:	c1 fd 07             	sar    $0x7,%ebp
    draw_area.x1 = LV_MATH_MIN(p1.x, p2.x) - w;
   21b84:	66 3b 1c 24          	cmp    (%rsp),%bx
   21b88:	0f 4e c3             	cmovle %ebx,%eax
   21b8b:	29 e8                	sub    %ebp,%eax
    draw_area.x2 = LV_MATH_MAX(p1.x, p2.x) + w;
   21b8d:	66 3b 1c 24          	cmp    (%rsp),%bx
    draw_area.x1 = LV_MATH_MIN(p1.x, p2.x) - w;
   21b91:	66 89 44 24 60       	mov    %ax,0x60(%rsp)
    draw_area.x2 = LV_MATH_MAX(p1.x, p2.x) + w;
   21b96:	8b 04 24             	mov    (%rsp),%eax
   21b99:	0f 4d c3             	cmovge %ebx,%eax
   21b9c:	01 e8                	add    %ebp,%eax
    draw_area.y1 = LV_MATH_MIN(p1.y, p2.y) - w;
   21b9e:	66 45 39 ec          	cmp    %r13w,%r12w
    draw_area.x2 = LV_MATH_MAX(p1.x, p2.x) + w;
   21ba2:	66 89 44 24 64       	mov    %ax,0x64(%rsp)
    draw_area.y1 = LV_MATH_MIN(p1.y, p2.y) - w;
   21ba7:	44 89 e8             	mov    %r13d,%eax
   21baa:	41 0f 4e c4          	cmovle %r12d,%eax
   21bae:	29 e8                	sub    %ebp,%eax
    draw_area.y2 = LV_MATH_MAX(p1.y, p2.y) + w;
   21bb0:	66 45 39 ec          	cmp    %r13w,%r12w
    draw_area.y1 = LV_MATH_MIN(p1.y, p2.y) - w;
   21bb4:	66 89 44 24 62       	mov    %ax,0x62(%rsp)
    draw_area.y2 = LV_MATH_MAX(p1.y, p2.y) + w;
   21bb9:	44 89 e8             	mov    %r13d,%eax
   21bbc:	41 0f 4d c4          	cmovge %r12d,%eax
   21bc0:	01 e8                	add    %ebp,%eax
   21bc2:	66 89 44 24 66       	mov    %ax,0x66(%rsp)
    bool is_common = _lv_area_intersect(&draw_area, &draw_area, clip);
   21bc7:	e8 50 39 00 00       	callq  2551c <_lv_area_intersect>
    if(is_common == false) return;
   21bcc:	84 c0                	test   %al,%al
   21bce:	0f 84 a7 03 00 00    	je     21f7b <lv_draw_line+0xa81>
    lv_draw_mask_line_param_t mask_left_param;
    lv_draw_mask_line_param_t mask_right_param;
    lv_draw_mask_line_param_t mask_top_param;
    lv_draw_mask_line_param_t mask_bottom_param;

    if(flat) {
   21bd4:	8b 4c 24 3c          	mov    0x3c(%rsp),%ecx
   21bd8:	44 8b 44 24 48       	mov    0x48(%rsp),%r8d
    int32_t w_half0 = w >> 1;
   21bdd:	41 c1 fe 08          	sar    $0x8,%r14d
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/
   21be1:	83 e5 01             	and    $0x1,%ebp
   21be4:	44 01 f5             	add    %r14d,%ebp
    if(flat) {
   21be7:	44 39 c1             	cmp    %r8d,%ecx
   21bea:	0f 8e 9b 00 00 00    	jle    21c8b <lv_draw_line+0x791>
   21bf0:	44 89 e2             	mov    %r12d,%edx
   21bf3:	44 89 ee             	mov    %r13d,%esi
   21bf6:	41 8d 04 2c          	lea    (%r12,%rbp,1),%eax
   21bfa:	44 29 f2             	sub    %r14d,%edx
   21bfd:	44 01 ed             	add    %r13d,%ebp
   21c00:	44 29 f6             	sub    %r14d,%esi
        if(xdiff > 0) {
   21c03:	83 7c 24 20 00       	cmpl   $0x0,0x20(%rsp)
   21c08:	98                   	cwtl   
   21c09:	0f bf ed             	movswl %bp,%ebp
   21c0c:	44 0f bf d2          	movswl %dx,%r10d
   21c10:	44 0f bf f6          	movswl %si,%r14d
   21c14:	48 8d 7c 24 70       	lea    0x70(%rsp),%rdi
   21c19:	7e 35                	jle    21c50 <lv_draw_line+0x756>
            lv_draw_mask_line_points_init(&mask_left_param, p1.x, p1.y - w_half0, p2.x, p2.y - w_half0,
   21c1b:	8b 74 24 18          	mov    0x18(%rsp),%esi
   21c1f:	45 31 c9             	xor    %r9d,%r9d
   21c22:	45 89 d0             	mov    %r10d,%r8d
   21c25:	0f bf cb             	movswl %bx,%ecx
   21c28:	44 89 f2             	mov    %r14d,%edx
   21c2b:	89 44 24 3c          	mov    %eax,0x3c(%rsp)
   21c2f:	e8 72 12 00 00       	callq  22ea6 <lv_draw_mask_line_points_init>
                                          LV_DRAW_MASK_LINE_SIDE_LEFT);
            lv_draw_mask_line_points_init(&mask_right_param, p1.x, p1.y + w_half1, p2.x, p2.y + w_half1,
   21c34:	8b 44 24 3c          	mov    0x3c(%rsp),%eax
   21c38:	48 8d bc 24 b0 00 00 	lea    0xb0(%rsp),%rdi
   21c3f:	00 
   21c40:	41 b9 01 00 00 00    	mov    $0x1,%r9d
   21c46:	0f bf cb             	movswl %bx,%ecx
   21c49:	89 ea                	mov    %ebp,%edx
   21c4b:	41 89 c0             	mov    %eax,%r8d
   21c4e:	eb 35                	jmp    21c85 <lv_draw_line+0x78b>
                                          LV_DRAW_MASK_LINE_SIDE_RIGHT);
        }
        else {
            lv_draw_mask_line_points_init(&mask_left_param, p1.x, p1.y + w_half1, p2.x, p2.y + w_half1,
   21c50:	8b 74 24 18          	mov    0x18(%rsp),%esi
   21c54:	45 31 c9             	xor    %r9d,%r9d
   21c57:	41 89 c0             	mov    %eax,%r8d
   21c5a:	0f bf cb             	movswl %bx,%ecx
   21c5d:	89 ea                	mov    %ebp,%edx
   21c5f:	44 89 54 24 3c       	mov    %r10d,0x3c(%rsp)
   21c64:	e8 3d 12 00 00       	callq  22ea6 <lv_draw_mask_line_points_init>
                                          LV_DRAW_MASK_LINE_SIDE_LEFT);
            lv_draw_mask_line_points_init(&mask_right_param, p1.x, p1.y - w_half0, p2.x, p2.y - w_half0,
   21c69:	44 8b 54 24 3c       	mov    0x3c(%rsp),%r10d
   21c6e:	48 8d bc 24 b0 00 00 	lea    0xb0(%rsp),%rdi
   21c75:	00 
   21c76:	41 b9 01 00 00 00    	mov    $0x1,%r9d
   21c7c:	0f bf cb             	movswl %bx,%ecx
   21c7f:	44 89 f2             	mov    %r14d,%edx
   21c82:	45 89 d0             	mov    %r10d,%r8d
   21c85:	8b 74 24 18          	mov    0x18(%rsp),%esi
   21c89:	eb 48                	jmp    21cd3 <lv_draw_line+0x7d9>
                                          LV_DRAW_MASK_LINE_SIDE_RIGHT);
        }
    }
    else {
        lv_draw_mask_line_points_init(&mask_left_param, p1.x + w_half1, p1.y, p2.x + w_half1, p2.y,
   21c8b:	8d 0c 2b             	lea    (%rbx,%rbp,1),%ecx
   21c8e:	03 2c 24             	add    (%rsp),%ebp
   21c91:	48 8d 7c 24 70       	lea    0x70(%rsp),%rdi
   21c96:	45 31 c9             	xor    %r9d,%r9d
   21c99:	45 0f bf c4          	movswl %r12w,%r8d
   21c9d:	41 0f bf d5          	movswl %r13w,%edx
   21ca1:	0f bf c9             	movswl %cx,%ecx
   21ca4:	0f bf f5             	movswl %bp,%esi
   21ca7:	e8 fa 11 00 00       	callq  22ea6 <lv_draw_mask_line_points_init>
                                      LV_DRAW_MASK_LINE_SIDE_LEFT);
        lv_draw_mask_line_points_init(&mask_right_param, p1.x - w_half0, p1.y, p2.x - w_half0, p2.y,
   21cac:	8b 34 24             	mov    (%rsp),%esi
   21caf:	89 d9                	mov    %ebx,%ecx
   21cb1:	48 8d bc 24 b0 00 00 	lea    0xb0(%rsp),%rdi
   21cb8:	00 
   21cb9:	44 29 f1             	sub    %r14d,%ecx
   21cbc:	41 b9 01 00 00 00    	mov    $0x1,%r9d
   21cc2:	45 0f bf c4          	movswl %r12w,%r8d
   21cc6:	0f bf c9             	movswl %cx,%ecx
   21cc9:	41 0f bf d5          	movswl %r13w,%edx
   21ccd:	44 29 f6             	sub    %r14d,%esi
   21cd0:	0f bf f6             	movswl %si,%esi
   21cd3:	e8 ce 11 00 00       	callq  22ea6 <lv_draw_mask_line_points_init>
                                      LV_DRAW_MASK_LINE_SIDE_RIGHT);
    }

    /*Use the normal vector for the endings*/

    int16_t mask_left_id = lv_draw_mask_add(&mask_left_param, NULL);
   21cd8:	48 8d 7c 24 70       	lea    0x70(%rsp),%rdi
   21cdd:	31 f6                	xor    %esi,%esi
    int16_t mask_right_id = lv_draw_mask_add(&mask_right_param, NULL);
    int16_t mask_top_id = LV_MASK_ID_INV;
    int16_t mask_bottom_id = LV_MASK_ID_INV;
   21cdf:	83 cd ff             	or     $0xffffffff,%ebp
    int16_t mask_left_id = lv_draw_mask_add(&mask_left_param, NULL);
   21ce2:	e8 79 10 00 00       	callq  22d60 <lv_draw_mask_add>
    int16_t mask_right_id = lv_draw_mask_add(&mask_right_param, NULL);
   21ce7:	48 8d bc 24 b0 00 00 	lea    0xb0(%rsp),%rdi
   21cee:	00 
   21cef:	31 f6                	xor    %esi,%esi
    int16_t mask_left_id = lv_draw_mask_add(&mask_left_param, NULL);
   21cf1:	66 89 44 24 48       	mov    %ax,0x48(%rsp)
    int16_t mask_right_id = lv_draw_mask_add(&mask_right_param, NULL);
   21cf6:	e8 65 10 00 00       	callq  22d60 <lv_draw_mask_add>

    if(!dsc->raw_end) {
   21cfb:	41 f6 47 0b 10       	testb  $0x10,0xb(%r15)
    int16_t mask_right_id = lv_draw_mask_add(&mask_right_param, NULL);
   21d00:	66 89 44 24 4e       	mov    %ax,0x4e(%rsp)
    int16_t mask_top_id = LV_MASK_ID_INV;
   21d05:	66 89 6c 24 3c       	mov    %bp,0x3c(%rsp)
    if(!dsc->raw_end) {
   21d0a:	0f 85 81 00 00 00    	jne    21d91 <lv_draw_line+0x897>
        lv_draw_mask_line_points_init(&mask_top_param, p1.x, p1.y, p1.x - ydiff, p1.y + xdiff, LV_DRAW_MASK_LINE_SIDE_BOTTOM);
   21d10:	8b 44 24 20          	mov    0x20(%rsp),%eax
   21d14:	8b 0c 24             	mov    (%rsp),%ecx
   21d17:	48 8d ac 24 f0 00 00 	lea    0xf0(%rsp),%rbp
   21d1e:	00 
   21d1f:	2b 4c 24 2c          	sub    0x2c(%rsp),%ecx
   21d23:	8b 54 24 38          	mov    0x38(%rsp),%edx
   21d27:	41 b9 03 00 00 00    	mov    $0x3,%r9d
   21d2d:	8b 74 24 18          	mov    0x18(%rsp),%esi
   21d31:	48 89 ef             	mov    %rbp,%rdi
   21d34:	45 8d 44 05 00       	lea    0x0(%r13,%rax,1),%r8d
   21d39:	0f bf c9             	movswl %cx,%ecx
   21d3c:	45 0f bf c0          	movswl %r8w,%r8d
   21d40:	e8 61 11 00 00       	callq  22ea6 <lv_draw_mask_line_points_init>
        lv_draw_mask_line_points_init(&mask_bottom_param, p2.x, p2.y, p2.x - ydiff, p2.y + xdiff,  LV_DRAW_MASK_LINE_SIDE_TOP);
   21d45:	2b 5c 24 2c          	sub    0x2c(%rsp),%ebx
   21d49:	44 8b 44 24 20       	mov    0x20(%rsp),%r8d
   21d4e:	41 b9 02 00 00 00    	mov    $0x2,%r9d
   21d54:	8b 54 24 44          	mov    0x44(%rsp),%edx
   21d58:	8b 74 24 40          	mov    0x40(%rsp),%esi
   21d5c:	45 01 e0             	add    %r12d,%r8d
   21d5f:	0f bf cb             	movswl %bx,%ecx
   21d62:	48 8d 9c 24 30 01 00 	lea    0x130(%rsp),%rbx
   21d69:	00 
   21d6a:	45 0f bf c0          	movswl %r8w,%r8d
   21d6e:	48 89 df             	mov    %rbx,%rdi
   21d71:	e8 30 11 00 00       	callq  22ea6 <lv_draw_mask_line_points_init>
        mask_top_id = lv_draw_mask_add(&mask_top_param, NULL);
   21d76:	48 89 ef             	mov    %rbp,%rdi
   21d79:	31 f6                	xor    %esi,%esi
   21d7b:	e8 e0 0f 00 00       	callq  22d60 <lv_draw_mask_add>
        mask_bottom_id = lv_draw_mask_add(&mask_bottom_param, NULL);
   21d80:	31 f6                	xor    %esi,%esi
   21d82:	48 89 df             	mov    %rbx,%rdi
        mask_top_id = lv_draw_mask_add(&mask_top_param, NULL);
   21d85:	66 89 44 24 3c       	mov    %ax,0x3c(%rsp)
        mask_bottom_id = lv_draw_mask_add(&mask_bottom_param, NULL);
   21d8a:	e8 d1 0f 00 00       	callq  22d60 <lv_draw_mask_add>
   21d8f:	89 c5                	mov    %eax,%ebp
    }

    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
   21d91:	e8 a4 b9 ff ff       	callq  1d73a <_lv_refr_get_disp_refreshing>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   21d96:	48 89 c7             	mov    %rax,%rdi
     * So deal with it only with steep lines. */
    int32_t draw_area_w = lv_area_get_width(&draw_area);

    /*Draw the background line by line*/
    int32_t h;
    size_t mask_buf_size = LV_MATH_MIN(lv_area_get_size(&draw_area), LV_HOR_RES_MAX);
   21d99:	4c 8d 64 24 60       	lea    0x60(%rsp),%r12
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   21d9e:	e8 5f 33 00 00       	callq  25102 <lv_disp_get_buf>
    draw_area.x2 -= disp_area->x1;
   21da3:	8b 5c 24 64          	mov    0x64(%rsp),%ebx
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   21da7:	49 89 c5             	mov    %rax,%r13
    draw_area.x1 -= disp_area->x1;
   21daa:	66 8b 40 1c          	mov    0x1c(%rax),%ax
   21dae:	8b 54 24 60          	mov    0x60(%rsp),%edx
    size_t mask_buf_size = LV_MATH_MIN(lv_area_get_size(&draw_area), LV_HOR_RES_MAX);
   21db2:	4c 89 e7             	mov    %r12,%rdi
    draw_area.y1 -= disp_area->y1;
   21db5:	66 41 8b 4d 1e       	mov    0x1e(%r13),%cx
   21dba:	66 29 4c 24 62       	sub    %cx,0x62(%rsp)
    draw_area.y2 -= disp_area->y1;
   21dbf:	66 29 4c 24 66       	sub    %cx,0x66(%rsp)
    draw_area.x2 -= disp_area->x1;
   21dc4:	29 c3                	sub    %eax,%ebx
    draw_area.x1 -= disp_area->x1;
   21dc6:	29 c2                	sub    %eax,%edx
    draw_area.x2 -= disp_area->x1;
   21dc8:	89 d8                	mov    %ebx,%eax
   21dca:	66 89 5c 24 64       	mov    %bx,0x64(%rsp)
   21dcf:	ff c0                	inc    %eax
    size_t mask_buf_size = LV_MATH_MIN(lv_area_get_size(&draw_area), LV_HOR_RES_MAX);
   21dd1:	bb e0 01 00 00       	mov    $0x1e0,%ebx
   21dd6:	29 d0                	sub    %edx,%eax
   21dd8:	66 89 04 24          	mov    %ax,(%rsp)
    int32_t draw_area_w = lv_area_get_width(&draw_area);
   21ddc:	98                   	cwtl   
    draw_area.x1 -= disp_area->x1;
   21ddd:	66 89 54 24 60       	mov    %dx,0x60(%rsp)
    int32_t draw_area_w = lv_area_get_width(&draw_area);
   21de2:	89 44 24 20          	mov    %eax,0x20(%rsp)
    size_t mask_buf_size = LV_MATH_MIN(lv_area_get_size(&draw_area), LV_HOR_RES_MAX);
   21de6:	e8 16 37 00 00       	callq  25501 <lv_area_get_size>
   21deb:	3d df 01 00 00       	cmp    $0x1df,%eax
   21df0:	77 0a                	ja     21dfc <lv_draw_line+0x902>
   21df2:	4c 89 e7             	mov    %r12,%rdi
   21df5:	e8 07 37 00 00       	callq  25501 <lv_area_get_size>
   21dfa:	89 c3                	mov    %eax,%ebx
    lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
   21dfc:	89 df                	mov    %ebx,%edi
   21dfe:	e8 db 43 00 00       	callq  261de <_lv_mem_buf_get>
   21e03:	49 89 c4             	mov    %rax,%r12

    lv_area_t fill_area;
    fill_area.x1 = draw_area.x1 + disp_area->x1;
   21e06:	66 41 8b 45 1c       	mov    0x1c(%r13),%ax
   21e0b:	48 89 d9             	mov    %rbx,%rcx
   21e0e:	4c 89 e7             	mov    %r12,%rdi
    fill_area.y1 = draw_area.y1 + disp_area->y1;
    fill_area.y2 = fill_area.y1;

    int32_t x = vdb->area.x1 + draw_area.x1;

    uint32_t mask_p = 0;
   21e11:	45 31 c0             	xor    %r8d,%r8d
    fill_area.x1 = draw_area.x1 + disp_area->x1;
   21e14:	89 c2                	mov    %eax,%edx
    fill_area.x2 = draw_area.x2 + disp_area->x1;
   21e16:	03 44 24 64          	add    0x64(%rsp),%eax
    fill_area.x1 = draw_area.x1 + disp_area->x1;
   21e1a:	03 54 24 60          	add    0x60(%rsp),%edx
    fill_area.x2 = draw_area.x2 + disp_area->x1;
   21e1e:	66 89 44 24 6c       	mov    %ax,0x6c(%rsp)
    fill_area.y1 = draw_area.y1 + disp_area->y1;
   21e23:	66 41 8b 45 1e       	mov    0x1e(%r13),%ax
   21e28:	66 03 44 24 62       	add    0x62(%rsp),%ax
    fill_area.x1 = draw_area.x1 + disp_area->x1;
   21e2d:	66 89 54 24 68       	mov    %dx,0x68(%rsp)
    fill_area.y1 = draw_area.y1 + disp_area->y1;
   21e32:	66 89 44 24 6a       	mov    %ax,0x6a(%rsp)
    fill_area.y2 = fill_area.y1;
   21e37:	66 89 44 24 6e       	mov    %ax,0x6e(%rsp)
   21e3c:	b0 ff                	mov    $0xff,%al
   21e3e:	f3 aa                	rep stos %al,%es:(%rdi)

    _lv_memset_ff(mask_buf, mask_buf_size);
    /*Fill the first row with 'color'*/
    for(h = draw_area.y1 + disp_area->y1; h <= draw_area.y2 + disp_area->y1; h++) {
   21e40:	0f bf 44 24 62       	movswl 0x62(%rsp),%eax
   21e45:	45 0f bf 75 1e       	movswl 0x1e(%r13),%r14d
   21e4a:	41 01 c6             	add    %eax,%r14d

        lv_draw_mask_res_t mask_res = lv_draw_mask_apply(&mask_buf[mask_p], x, h, draw_area_w);
   21e4d:	0f bf c2             	movswl %dx,%eax
   21e50:	89 44 24 2c          	mov    %eax,0x2c(%rsp)
    for(h = draw_area.y1 + disp_area->y1; h <= draw_area.y2 + disp_area->y1; h++) {
   21e54:	0f bf 44 24 66       	movswl 0x66(%rsp),%eax
   21e59:	41 0f bf 55 1e       	movswl 0x1e(%r13),%edx
   21e5e:	01 d0                	add    %edx,%eax
   21e60:	41 39 c6             	cmp    %eax,%r14d
   21e63:	0f 8f a3 00 00 00    	jg     21f0c <lv_draw_line+0xa12>
        lv_draw_mask_res_t mask_res = lv_draw_mask_apply(&mask_buf[mask_p], x, h, draw_area_w);
   21e69:	44 89 c0             	mov    %r8d,%eax
   21e6c:	8b 4c 24 20          	mov    0x20(%rsp),%ecx
   21e70:	8b 74 24 2c          	mov    0x2c(%rsp),%esi
   21e74:	4c 01 e0             	add    %r12,%rax
   21e77:	41 0f bf d6          	movswl %r14w,%edx
   21e7b:	44 89 44 24 38       	mov    %r8d,0x38(%rsp)
   21e80:	48 89 c7             	mov    %rax,%rdi
   21e83:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   21e88:	e8 37 0f 00 00       	callq  22dc4 <lv_draw_mask_apply>
        if(mask_res == LV_DRAW_MASK_RES_TRANSP) {
   21e8d:	84 c0                	test   %al,%al
   21e8f:	44 8b 44 24 38       	mov    0x38(%rsp),%r8d
   21e94:	75 0c                	jne    21ea2 <lv_draw_line+0x9a8>
            _lv_memset_00(&mask_buf[mask_p], draw_area_w);
   21e96:	48 0f bf 0c 24       	movswq (%rsp),%rcx
   21e9b:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
   21ea0:	f3 aa                	rep stos %al,%es:(%rdi)
        }

        mask_p += draw_area_w;
   21ea2:	0f bf 04 24          	movswl (%rsp),%eax
   21ea6:	41 01 c0             	add    %eax,%r8d
        if((uint32_t) mask_p + draw_area_w < mask_buf_size) {
   21ea9:	44 01 c0             	add    %r8d,%eax
   21eac:	48 39 c3             	cmp    %rax,%rbx
   21eaf:	76 07                	jbe    21eb8 <lv_draw_line+0x9be>
            fill_area.y2 ++;
   21eb1:	66 ff 44 24 6e       	incw   0x6e(%rsp)
   21eb6:	eb 4c                	jmp    21f04 <lv_draw_line+0xa0a>
        }
        else {
            _lv_blend_fill(&fill_area, clip,
                           dsc->color, mask_buf, LV_DRAW_MASK_RES_CHANGED, dsc->opa,
                           dsc->blend_mode);
   21eb8:	41 8a 47 0b          	mov    0xb(%r15),%al
            _lv_blend_fill(&fill_area, clip,
   21ebc:	48 8d 74 24 58       	lea    0x58(%rsp),%rsi
   21ec1:	48 8d 7c 24 68       	lea    0x68(%rsp),%rdi
   21ec6:	48 83 ec 08          	sub    $0x8,%rsp
   21eca:	41 b8 02 00 00 00    	mov    $0x2,%r8d
   21ed0:	4c 89 e1             	mov    %r12,%rcx
   21ed3:	83 e0 03             	and    $0x3,%eax
   21ed6:	50                   	push   %rax
   21ed7:	45 0f b6 4f 0a       	movzbl 0xa(%r15),%r9d
   21edc:	41 8b 17             	mov    (%r15),%edx
   21edf:	e8 69 d0 ff ff       	callq  1ef4d <_lv_blend_fill>
   21ee4:	59                   	pop    %rcx
   21ee5:	5e                   	pop    %rsi

            fill_area.y1 = fill_area.y2 + 1;
   21ee6:	66 8b 44 24 6e       	mov    0x6e(%rsp),%ax
   21eeb:	4c 89 e7             	mov    %r12,%rdi
   21eee:	48 89 d9             	mov    %rbx,%rcx
            fill_area.y2 = fill_area.y1;
            mask_p = 0;
   21ef1:	45 31 c0             	xor    %r8d,%r8d
            fill_area.y1 = fill_area.y2 + 1;
   21ef4:	ff c0                	inc    %eax
   21ef6:	66 89 44 24 6a       	mov    %ax,0x6a(%rsp)
            fill_area.y2 = fill_area.y1;
   21efb:	66 89 44 24 6e       	mov    %ax,0x6e(%rsp)
   21f00:	b0 ff                	mov    $0xff,%al
   21f02:	f3 aa                	rep stos %al,%es:(%rdi)
    for(h = draw_area.y1 + disp_area->y1; h <= draw_area.y2 + disp_area->y1; h++) {
   21f04:	41 ff c6             	inc    %r14d
   21f07:	e9 48 ff ff ff       	jmpq   21e54 <lv_draw_line+0x95a>
            _lv_memset_ff(mask_buf, mask_buf_size);
        }
    }

    /*Flush the last part*/
    if(fill_area.y1 != fill_area.y2) {
   21f0c:	66 8b 44 24 6e       	mov    0x6e(%rsp),%ax
   21f11:	66 39 44 24 6a       	cmp    %ax,0x6a(%rsp)
   21f16:	74 35                	je     21f4d <lv_draw_line+0xa53>
        fill_area.y2--;
   21f18:	ff c8                	dec    %eax
        _lv_blend_fill(&fill_area, clip,
   21f1a:	48 8d 74 24 58       	lea    0x58(%rsp),%rsi
   21f1f:	48 8d 7c 24 68       	lea    0x68(%rsp),%rdi
        fill_area.y2--;
   21f24:	66 89 44 24 6e       	mov    %ax,0x6e(%rsp)
                       dsc->color, mask_buf, LV_DRAW_MASK_RES_CHANGED, dsc->opa,
                       dsc->blend_mode);
   21f29:	41 8a 47 0b          	mov    0xb(%r15),%al
        _lv_blend_fill(&fill_area, clip,
   21f2d:	48 83 ec 08          	sub    $0x8,%rsp
   21f31:	41 b8 02 00 00 00    	mov    $0x2,%r8d
   21f37:	4c 89 e1             	mov    %r12,%rcx
   21f3a:	83 e0 03             	and    $0x3,%eax
   21f3d:	50                   	push   %rax
   21f3e:	45 0f b6 4f 0a       	movzbl 0xa(%r15),%r9d
   21f43:	41 8b 17             	mov    (%r15),%edx
   21f46:	e8 02 d0 ff ff       	callq  1ef4d <_lv_blend_fill>
   21f4b:	58                   	pop    %rax
   21f4c:	5a                   	pop    %rdx

    }

    _lv_mem_buf_release(mask_buf);
   21f4d:	4c 89 e7             	mov    %r12,%rdi
   21f50:	e8 78 43 00 00       	callq  262cd <_lv_mem_buf_release>

    lv_draw_mask_remove_id(mask_left_id);
   21f55:	0f bf 7c 24 48       	movswl 0x48(%rsp),%edi
   21f5a:	e8 c6 0e 00 00       	callq  22e25 <lv_draw_mask_remove_id>
    lv_draw_mask_remove_id(mask_right_id);
   21f5f:	0f bf 7c 24 4e       	movswl 0x4e(%rsp),%edi
   21f64:	e8 bc 0e 00 00       	callq  22e25 <lv_draw_mask_remove_id>
    lv_draw_mask_remove_id(mask_top_id);
   21f69:	0f bf 7c 24 3c       	movswl 0x3c(%rsp),%edi
   21f6e:	e8 b2 0e 00 00       	callq  22e25 <lv_draw_mask_remove_id>
    lv_draw_mask_remove_id(mask_bottom_id);
   21f73:	0f bf fd             	movswl %bp,%edi
   21f76:	e8 aa 0e 00 00       	callq  22e25 <lv_draw_mask_remove_id>
    if(dsc->round_end || dsc->round_start) {
   21f7b:	41 f6 47 0b 0c       	testb  $0xc,0xb(%r15)
   21f80:	0f 84 fe 00 00 00    	je     22084 <lv_draw_line+0xb8a>
        lv_draw_rect_dsc_init(&cir_dsc);
   21f86:	48 8d ac 24 30 01 00 	lea    0x130(%rsp),%rbp
   21f8d:	00 
   21f8e:	48 89 ef             	mov    %rbp,%rdi
   21f91:	e8 ab 11 00 00       	callq  23141 <lv_draw_rect_dsc_init>
        int32_t r = (dsc->width >> 1);
   21f96:	45 8b 67 04          	mov    0x4(%r15),%r12d
        cir_dsc.bg_color = dsc->color;
   21f9a:	41 8b 07             	mov    (%r15),%eax
        cir_dsc.radius = LV_RADIUS_CIRCLE;
   21f9d:	66 c7 84 24 30 01 00 	movw   $0x7fff,0x130(%rsp)
   21fa4:	00 ff 7f 
        int32_t r = (dsc->width >> 1);
   21fa7:	44 89 e3             	mov    %r12d,%ebx
   21faa:	41 f7 d4             	not    %r12d
        cir_dsc.bg_color = dsc->color;
   21fad:	89 84 24 34 01 00 00 	mov    %eax,0x134(%rsp)
        int32_t r = (dsc->width >> 1);
   21fb4:	66 d1 fb             	sar    %bx
   21fb7:	41 83 e4 01          	and    $0x1,%r12d
        if(dsc->round_start) {
   21fbb:	41 f6 47 0b 04       	testb  $0x4,0xb(%r15)
        cir_dsc.bg_opa = dsc->opa;
   21fc0:	41 8a 47 0a          	mov    0xa(%r15),%al
   21fc4:	88 84 24 42 01 00 00 	mov    %al,0x142(%rsp)
        if(dsc->round_start) {
   21fcb:	74 58                	je     22025 <lv_draw_line+0xb2b>
            cir_area.x1 = point1->x - r;
   21fcd:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
            lv_draw_rect(&cir_area, clip, &cir_dsc);
   21fd2:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
   21fd7:	48 8d bc 24 f0 00 00 	lea    0xf0(%rsp),%rdi
   21fde:	00 
            cir_area.x1 = point1->x - r;
   21fdf:	66 8b 10             	mov    (%rax),%dx
   21fe2:	89 d0                	mov    %edx,%eax
            cir_area.x2 = point1->x + r - r_corr;
   21fe4:	01 da                	add    %ebx,%edx
            cir_area.x1 = point1->x - r;
   21fe6:	29 d8                	sub    %ebx,%eax
            cir_area.x2 = point1->x + r - r_corr;
   21fe8:	44 29 e2             	sub    %r12d,%edx
            cir_area.x1 = point1->x - r;
   21feb:	66 89 84 24 f0 00 00 	mov    %ax,0xf0(%rsp)
   21ff2:	00 
            cir_area.y1 = point1->y - r;
   21ff3:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
            cir_area.x2 = point1->x + r - r_corr;
   21ff8:	66 89 94 24 f4 00 00 	mov    %dx,0xf4(%rsp)
   21fff:	00 
            lv_draw_rect(&cir_area, clip, &cir_dsc);
   22000:	48 89 ea             	mov    %rbp,%rdx
            cir_area.y1 = point1->y - r;
   22003:	66 8b 40 02          	mov    0x2(%rax),%ax
   22007:	89 c1                	mov    %eax,%ecx
            cir_area.y2 = point1->y + r - r_corr ;
   22009:	01 d8                	add    %ebx,%eax
            cir_area.y1 = point1->y - r;
   2200b:	29 d9                	sub    %ebx,%ecx
            cir_area.y2 = point1->y + r - r_corr ;
   2200d:	44 29 e0             	sub    %r12d,%eax
            cir_area.y1 = point1->y - r;
   22010:	66 89 8c 24 f2 00 00 	mov    %cx,0xf2(%rsp)
   22017:	00 
            cir_area.y2 = point1->y + r - r_corr ;
   22018:	66 89 84 24 f6 00 00 	mov    %ax,0xf6(%rsp)
   2201f:	00 
            lv_draw_rect(&cir_area, clip, &cir_dsc);
   22020:	e8 86 11 00 00       	callq  231ab <lv_draw_rect>
        if(dsc->round_end) {
   22025:	41 f6 47 0b 08       	testb  $0x8,0xb(%r15)
   2202a:	74 58                	je     22084 <lv_draw_line+0xb8a>
            cir_area.x1 = point2->x - r;
   2202c:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
            cir_area.y1 = point2->y - r;
   22031:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
            lv_draw_rect(&cir_area, clip, &cir_dsc);
   22036:	48 8d bc 24 f0 00 00 	lea    0xf0(%rsp),%rdi
   2203d:	00 
            cir_area.x1 = point2->x - r;
   2203e:	66 8b 00             	mov    (%rax),%ax
   22041:	89 c2                	mov    %eax,%edx
            cir_area.x2 = point2->x + r - r_corr;
   22043:	01 d8                	add    %ebx,%eax
            cir_area.x1 = point2->x - r;
   22045:	29 da                	sub    %ebx,%edx
            cir_area.x2 = point2->x + r - r_corr;
   22047:	44 29 e0             	sub    %r12d,%eax
            cir_area.x1 = point2->x - r;
   2204a:	66 89 94 24 f0 00 00 	mov    %dx,0xf0(%rsp)
   22051:	00 
            cir_area.y1 = point2->y - r;
   22052:	66 8b 56 02          	mov    0x2(%rsi),%dx
            lv_draw_rect(&cir_area, clip, &cir_dsc);
   22056:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
            cir_area.x2 = point2->x + r - r_corr;
   2205b:	66 89 84 24 f4 00 00 	mov    %ax,0xf4(%rsp)
   22062:	00 
            cir_area.y1 = point2->y - r;
   22063:	89 d1                	mov    %edx,%ecx
   22065:	29 d9                	sub    %ebx,%ecx
            cir_area.y2 = point2->y + r - r_corr ;
   22067:	01 d3                	add    %edx,%ebx
            lv_draw_rect(&cir_area, clip, &cir_dsc);
   22069:	48 89 ea             	mov    %rbp,%rdx
            cir_area.y2 = point2->y + r - r_corr ;
   2206c:	44 29 e3             	sub    %r12d,%ebx
            cir_area.y1 = point2->y - r;
   2206f:	66 89 8c 24 f2 00 00 	mov    %cx,0xf2(%rsp)
   22076:	00 
            cir_area.y2 = point2->y + r - r_corr ;
   22077:	66 89 9c 24 f6 00 00 	mov    %bx,0xf6(%rsp)
   2207e:	00 
            lv_draw_rect(&cir_area, clip, &cir_dsc);
   2207f:	e8 27 11 00 00       	callq  231ab <lv_draw_rect>
}
   22084:	48 8b 84 24 b8 01 00 	mov    0x1b8(%rsp),%rax
   2208b:	00 
   2208c:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   22093:	00 00 
   22095:	74 05                	je     2209c <lv_draw_line+0xba2>
   22097:	e8 a4 25 fe ff       	callq  4640 <__stack_chk_fail@plt>
   2209c:	48 81 c4 c8 01 00 00 	add    $0x1c8,%rsp
   220a3:	5b                   	pop    %rbx
   220a4:	5d                   	pop    %rbp
   220a5:	41 5c                	pop    %r12
   220a7:	41 5d                	pop    %r13
   220a9:	41 5e                	pop    %r14
   220ab:	41 5f                	pop    %r15
   220ad:	c3                   	retq   

00000000000220ae <_lv_memset_00>:
 * Wrapper for the standard memset with fixed 0x00 value
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
static inline void _lv_memset_00(void * dst, size_t len)
{
   220ae:	48 89 f1             	mov    %rsi,%rcx
   220b1:	31 c0                	xor    %eax,%eax
   220b3:	f3 aa                	rep stos %al,%es:(%rdi)
    memset(dst, 0x00, len);
}
   220b5:	c3                   	retq   

00000000000220b6 <mask_mix>:
}


LV_ATTRIBUTE_FAST_MEM static inline lv_opa_t mask_mix(lv_opa_t mask_act, lv_opa_t mask_new)
{
    if(mask_new >= LV_OPA_MAX) return mask_act;
   220b6:	40 80 fe fc          	cmp    $0xfc,%sil
{
   220ba:	40 88 f8             	mov    %dil,%al
    if(mask_new >= LV_OPA_MAX) return mask_act;
   220bd:	77 1d                	ja     220dc <mask_mix+0x26>
    if(mask_new <= LV_OPA_MIN) return 0;

    return LV_MATH_UDIV255(mask_act * mask_new);// >> 8);
   220bf:	40 0f b6 c7          	movzbl %dil,%eax
   220c3:	40 0f b6 fe          	movzbl %sil,%edi
   220c7:	b2 00                	mov    $0x0,%dl
   220c9:	0f af c7             	imul   %edi,%eax
   220cc:	69 c0 81 80 00 00    	imul   $0x8081,%eax,%eax
   220d2:	c1 e8 17             	shr    $0x17,%eax
   220d5:	40 80 fe 02          	cmp    $0x2,%sil
   220d9:	0f 46 c2             	cmovbe %edx,%eax
}
   220dc:	c3                   	retq   

00000000000220dd <lv_draw_mask_line>:
{
   220dd:	41 8a 40 30          	mov    0x30(%r8),%al
    abs_y -= p->origo.y;
   220e1:	41 2b 50 1c          	sub    0x1c(%r8),%edx
{
   220e5:	49 89 fa             	mov    %rdi,%r10
    abs_x -= p->origo.x;
   220e8:	66 41 2b 70 1a       	sub    0x1a(%r8),%si
{
   220ed:	55                   	push   %rbp
   220ee:	53                   	push   %rbx
   220ef:	41 88 c1             	mov    %al,%r9b
   220f2:	41 83 e1 01          	and    $0x1,%r9d
    if(p->steep == 0) {
   220f6:	41 83 78 28 00       	cmpl   $0x0,0x28(%r8)
   220fb:	0f 85 b2 00 00 00    	jne    221b3 <lv_draw_mask_line+0xd6>
   22101:	41 8a 78 18          	mov    0x18(%r8),%dil
   22105:	83 e7 03             	and    $0x3,%edi
        if(p->flat) {
   22108:	45 84 c9             	test   %r9b,%r9b
   2210b:	74 2a                	je     22137 <lv_draw_mask_line+0x5a>
            if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_LEFT ||
   2210d:	40 80 ff 01          	cmp    $0x1,%dil
               p->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT) return LV_DRAW_MASK_RES_FULL_COVER;
   22111:	b0 01                	mov    $0x1,%al
            if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_LEFT ||
   22113:	0f 86 c8 04 00 00    	jbe    225e1 <lv_draw_mask_line+0x504>
            else if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_TOP && abs_y + 1 < 0) return LV_DRAW_MASK_RES_FULL_COVER;
   22119:	40 80 ff 02          	cmp    $0x2,%dil
   2211d:	75 0d                	jne    2212c <lv_draw_mask_line+0x4f>
   2211f:	0f bf c2             	movswl %dx,%eax
   22122:	ff c0                	inc    %eax
               p->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT) return LV_DRAW_MASK_RES_FULL_COVER;
   22124:	c1 e8 1f             	shr    $0x1f,%eax
   22127:	e9 b5 04 00 00       	jmpq   225e1 <lv_draw_mask_line+0x504>
            else if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_BOTTOM && abs_y > 0) return LV_DRAW_MASK_RES_FULL_COVER;
   2212c:	66 85 d2             	test   %dx,%dx
   2212f:	0f 9f c0             	setg   %al
   22132:	e9 aa 04 00 00       	jmpq   225e1 <lv_draw_mask_line+0x504>
            if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_TOP ||
   22137:	8d 57 fe             	lea    -0x2(%rdi),%edx
               p->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT) return LV_DRAW_MASK_RES_FULL_COVER;
   2213a:	b0 01                	mov    $0x1,%al
            if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_TOP ||
   2213c:	80 fa 01             	cmp    $0x1,%dl
   2213f:	0f 86 9c 04 00 00    	jbe    225e1 <lv_draw_mask_line+0x504>
            else if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT && abs_x > 0) return LV_DRAW_MASK_RES_FULL_COVER;
   22145:	40 fe cf             	dec    %dil
   22148:	75 0b                	jne    22155 <lv_draw_mask_line+0x78>
   2214a:	66 85 f6             	test   %si,%si
   2214d:	0f 8f 8e 04 00 00    	jg     225e1 <lv_draw_mask_line+0x504>
   22153:	eb 3a                	jmp    2218f <lv_draw_mask_line+0xb2>
   22155:	0f bf c9             	movswl %cx,%ecx
   22158:	0f bf f6             	movswl %si,%esi
               p->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT) return LV_DRAW_MASK_RES_FULL_COVER;
   2215b:	b0 01                	mov    $0x1,%al
                if(abs_x + len < 0) return LV_DRAW_MASK_RES_FULL_COVER;
   2215d:	89 ca                	mov    %ecx,%edx
   2215f:	01 f2                	add    %esi,%edx
   22161:	0f 88 7a 04 00 00    	js     225e1 <lv_draw_mask_line+0x504>
                    int32_t k = - abs_x;
   22167:	89 f0                	mov    %esi,%eax
   22169:	f7 d8                	neg    %eax
                    if(k < 0) return LV_DRAW_MASK_RES_TRANSP;
   2216b:	85 c0                	test   %eax,%eax
   2216d:	79 07                	jns    22176 <lv_draw_mask_line+0x99>
   2216f:	31 c0                	xor    %eax,%eax
   22171:	e9 6b 04 00 00       	jmpq   225e1 <lv_draw_mask_line+0x504>
                    if(k >= 0 && k < len) _lv_memset_00(&mask_buf[k], len - k);
   22176:	39 c8                	cmp    %ecx,%eax
   22178:	7d 0e                	jge    22188 <lv_draw_mask_line+0xab>
   2217a:	48 63 f2             	movslq %edx,%rsi
   2217d:	48 63 f8             	movslq %eax,%rdi
   22180:	4c 01 d7             	add    %r10,%rdi
   22183:	e8 26 ff ff ff       	callq  220ae <_lv_memset_00>
                    return  LV_DRAW_MASK_RES_CHANGED;
   22188:	b0 02                	mov    $0x2,%al
   2218a:	e9 52 04 00 00       	jmpq   225e1 <lv_draw_mask_line+0x504>
                if(abs_x + len < 0) return LV_DRAW_MASK_RES_TRANSP;
   2218f:	0f bf f6             	movswl %si,%esi
   22192:	0f bf c9             	movswl %cx,%ecx
   22195:	89 f0                	mov    %esi,%eax
   22197:	01 c8                	add    %ecx,%eax
   22199:	78 d4                	js     2216f <lv_draw_mask_line+0x92>
                    int32_t k = - abs_x;
   2219b:	f7 de                	neg    %esi
   2219d:	b8 00 00 00 00       	mov    $0x0,%eax
   221a2:	85 f6                	test   %esi,%esi
   221a4:	0f 48 f0             	cmovs  %eax,%esi
                    if(k >= len) return LV_DRAW_MASK_RES_TRANSP;
   221a7:	39 f1                	cmp    %esi,%ecx
   221a9:	7e c4                	jle    2216f <lv_draw_mask_line+0x92>
                    else if(k >= 0 && k < len) _lv_memset_00(&mask_buf[0], k);
   221ab:	48 63 f6             	movslq %esi,%rsi
   221ae:	e9 64 02 00 00       	jmpq   22417 <lv_draw_mask_line+0x33a>
   221b3:	83 e0 02             	and    $0x2,%eax
    if(p->flat) {
   221b6:	45 84 c9             	test   %r9b,%r9b
   221b9:	0f bf c9             	movswl %cx,%ecx
   221bc:	0f bf d2             	movswl %dx,%edx
   221bf:	44 0f bf de          	movswl %si,%r11d
   221c3:	0f 84 8d 01 00 00    	je     22356 <lv_draw_mask_line+0x279>
    y_at_x = (int32_t)((int32_t)p->yx_steep * abs_x) >> 10;
   221c9:	41 8b 78 24          	mov    0x24(%r8),%edi
   221cd:	89 fe                	mov    %edi,%esi
   221cf:	41 0f af f3          	imul   %r11d,%esi
   221d3:	c1 fe 0a             	sar    $0xa,%esi
    if(p->yx_steep > 0) {
   221d6:	85 ff                	test   %edi,%edi
   221d8:	7e 09                	jle    221e3 <lv_draw_mask_line+0x106>
        if(y_at_x > abs_y) {
   221da:	39 d6                	cmp    %edx,%esi
   221dc:	7e 0d                	jle    221eb <lv_draw_mask_line+0x10e>
   221de:	e9 8d 01 00 00       	jmpq   22370 <lv_draw_mask_line+0x293>
        if(y_at_x < abs_y) {
   221e3:	39 d6                	cmp    %edx,%esi
   221e5:	0f 8c 85 01 00 00    	jl     22370 <lv_draw_mask_line+0x293>
    y_at_x = (int32_t)((int32_t)p->yx_steep * (abs_x + len)) >> 10;
   221eb:	41 8d 34 0b          	lea    (%r11,%rcx,1),%esi
   221ef:	0f af f7             	imul   %edi,%esi
   221f2:	c1 fe 0a             	sar    $0xa,%esi
    if(p->yx_steep > 0) {
   221f5:	85 ff                	test   %edi,%edi
   221f7:	7e 09                	jle    22202 <lv_draw_mask_line+0x125>
        if(y_at_x < abs_y) {
   221f9:	39 f2                	cmp    %esi,%edx
   221fb:	7e 0f                	jle    2220c <lv_draw_mask_line+0x12f>
   221fd:	e9 80 01 00 00       	jmpq   22382 <lv_draw_mask_line+0x2a5>
        if(y_at_x > abs_y) {
   22202:	39 f2                	cmp    %esi,%edx
   22204:	0f 8c 78 01 00 00    	jl     22382 <lv_draw_mask_line+0x2a5>
    else xe = (((abs_y + 1) << 8) * p->xy_steep) >> 10;
   2220a:	ff c2                	inc    %edx
   2220c:	c1 e2 08             	shl    $0x8,%edx
    if(xef == 0) px_h = 255;
   2220f:	bb ff 00 00 00       	mov    $0xff,%ebx
    else xe = (((abs_y + 1) << 8) * p->xy_steep) >> 10;
   22214:	41 0f af 50 20       	imul   0x20(%r8),%edx
   22219:	c1 fa 0a             	sar    $0xa,%edx
    int32_t xei = xe >> 8;
   2221c:	89 d6                	mov    %edx,%esi
   2221e:	c1 fe 08             	sar    $0x8,%esi
    if(xef == 0) px_h = 255;
   22221:	81 e2 ff 00 00 00    	and    $0xff,%edx
   22227:	74 0e                	je     22237 <lv_draw_mask_line+0x15a>
    else px_h = 255 - (((255 - xef) * p->spx) >> 8);
   22229:	89 df                	mov    %ebx,%edi
   2222b:	29 d7                	sub    %edx,%edi
   2222d:	41 0f af 78 2c       	imul   0x2c(%r8),%edi
   22232:	c1 ff 08             	sar    $0x8,%edi
   22235:	29 fb                	sub    %edi,%ebx
    int32_t k = xei - abs_x;
   22237:	44 29 de             	sub    %r11d,%esi
    if(xef) {
   2223a:	85 d2                	test   %edx,%edx
    int32_t k = xei - abs_x;
   2223c:	41 89 f3             	mov    %esi,%r11d
   2223f:	41 89 f1             	mov    %esi,%r9d
    if(xef) {
   22242:	74 3e                	je     22282 <lv_draw_mask_line+0x1a5>
        if(k >= 0 && k < len) {
   22244:	39 ce                	cmp    %ecx,%esi
   22246:	7d 36                	jge    2227e <lv_draw_mask_line+0x1a1>
   22248:	85 f6                	test   %esi,%esi
   2224a:	78 32                	js     2227e <lv_draw_mask_line+0x1a1>
            m = 255 - (((255 - xef) * (255 - px_h)) >> 9);
   2224c:	be ff 00 00 00       	mov    $0xff,%esi
   22251:	89 f7                	mov    %esi,%edi
   22253:	29 de                	sub    %ebx,%esi
   22255:	29 d7                	sub    %edx,%edi
   22257:	89 fa                	mov    %edi,%edx
   22259:	0f af d6             	imul   %esi,%edx
   2225c:	c1 fa 09             	sar    $0x9,%edx
            if(p->inv) m = 255 - m;
   2225f:	84 c0                	test   %al,%al
            m = 255 - (((255 - xef) * (255 - px_h)) >> 9);
   22261:	40 88 d6             	mov    %dl,%sil
            if(p->inv) m = 255 - m;
   22264:	75 02                	jne    22268 <lv_draw_mask_line+0x18b>
            m = 255 - (((255 - xef) * (255 - px_h)) >> 9);
   22266:	f7 d6                	not    %esi
            mask_buf[k] = mask_mix(mask_buf[k], m);
   22268:	4d 63 cb             	movslq %r11d,%r9
   2226b:	40 0f b6 f6          	movzbl %sil,%esi
   2226f:	4d 01 d1             	add    %r10,%r9
   22272:	41 0f b6 39          	movzbl (%r9),%edi
   22276:	e8 3b fe ff ff       	callq  220b6 <mask_mix>
   2227b:	41 88 01             	mov    %al,(%r9)
        k++;
   2227e:	45 8d 4b 01          	lea    0x1(%r11),%r9d
   22282:	49 63 e9             	movslq %r9d,%rbp
   22285:	4c 01 d5             	add    %r10,%rbp
   22288:	44 89 ca             	mov    %r9d,%edx
   2228b:	41 39 c9             	cmp    %ecx,%r9d
    while(px_h > p->spx) {
   2228e:	41 8b 70 2c          	mov    0x2c(%r8),%esi
   22292:	f7 d2                	not    %edx
   22294:	0f 9c c0             	setl   %al
   22297:	c1 ea 1f             	shr    $0x1f,%edx
   2229a:	21 d0                	and    %edx,%eax
   2229c:	41 8a 50 30          	mov    0x30(%r8),%dl
   222a0:	83 e2 02             	and    $0x2,%edx
   222a3:	39 f3                	cmp    %esi,%ebx
   222a5:	7e 34                	jle    222db <lv_draw_mask_line+0x1fe>
        if(k >= 0 && k < len) {
   222a7:	84 c0                	test   %al,%al
   222a9:	74 1f                	je     222ca <lv_draw_mask_line+0x1ed>
            m = px_h - (p->spx >> 1);
   222ab:	d1 fe                	sar    %esi
   222ad:	88 d8                	mov    %bl,%al
   222af:	29 f0                	sub    %esi,%eax
            if(p->inv) m = 255 - m;
   222b1:	84 d2                	test   %dl,%dl
            m = px_h - (p->spx >> 1);
   222b3:	40 88 c6             	mov    %al,%sil
            if(p->inv) m = 255 - m;
   222b6:	74 02                	je     222ba <lv_draw_mask_line+0x1dd>
   222b8:	f7 d6                	not    %esi
            mask_buf[k] = mask_mix(mask_buf[k], m);
   222ba:	0f b6 7d 00          	movzbl 0x0(%rbp),%edi
   222be:	40 0f b6 f6          	movzbl %sil,%esi
   222c2:	e8 ef fd ff ff       	callq  220b6 <mask_mix>
   222c7:	88 45 00             	mov    %al,0x0(%rbp)
        k++;
   222ca:	41 ff c1             	inc    %r9d
        px_h -= p->spx;
   222cd:	41 2b 58 2c          	sub    0x2c(%r8),%ebx
   222d1:	48 ff c5             	inc    %rbp
        if(k >= len) break;
   222d4:	41 39 c9             	cmp    %ecx,%r9d
   222d7:	7c af                	jl     22288 <lv_draw_mask_line+0x1ab>
   222d9:	eb 3a                	jmp    22315 <lv_draw_mask_line+0x238>
    if(k < len && k >= 0) {
   222db:	84 c0                	test   %al,%al
   222dd:	74 36                	je     22315 <lv_draw_mask_line+0x238>
        int32_t x_inters = (px_h * p->xy_steep) >> 10;
   222df:	41 8b 40 20          	mov    0x20(%r8),%eax
   222e3:	0f af c3             	imul   %ebx,%eax
   222e6:	c1 f8 0a             	sar    $0xa,%eax
        m = (x_inters * px_h) >> 9;
   222e9:	0f af c3             	imul   %ebx,%eax
   222ec:	c1 f8 09             	sar    $0x9,%eax
        if(p->yx_steep < 0) m = 255 - m;
   222ef:	41 83 78 24 00       	cmpl   $0x0,0x24(%r8)
        m = (x_inters * px_h) >> 9;
   222f4:	40 88 c6             	mov    %al,%sil
        if(p->yx_steep < 0) m = 255 - m;
   222f7:	79 02                	jns    222fb <lv_draw_mask_line+0x21e>
   222f9:	f7 d6                	not    %esi
        if(p->inv) m = 255 - m;
   222fb:	84 d2                	test   %dl,%dl
   222fd:	74 02                	je     22301 <lv_draw_mask_line+0x224>
   222ff:	f7 d6                	not    %esi
        mask_buf[k] = mask_mix(mask_buf[k], m);
   22301:	49 63 d9             	movslq %r9d,%rbx
   22304:	40 0f b6 f6          	movzbl %sil,%esi
   22308:	4c 01 d3             	add    %r10,%rbx
   2230b:	0f b6 3b             	movzbl (%rbx),%edi
   2230e:	e8 a3 fd ff ff       	callq  220b6 <mask_mix>
   22313:	88 03                	mov    %al,(%rbx)
    if(p->inv) {
   22315:	41 f6 40 30 02       	testb  $0x2,0x30(%r8)
   2231a:	74 1a                	je     22336 <lv_draw_mask_line+0x259>
        if(k > len) {
   2231c:	41 39 cb             	cmp    %ecx,%r11d
   2231f:	0f 8f 4a fe ff ff    	jg     2216f <lv_draw_mask_line+0x92>
        if(k >= 0) {
   22325:	45 85 db             	test   %r11d,%r11d
            _lv_memset_00(&mask_buf[0], k);
   22328:	49 63 f3             	movslq %r11d,%rsi
        if(k >= 0) {
   2232b:	0f 88 57 fe ff ff    	js     22188 <lv_draw_mask_line+0xab>
   22331:	e9 e1 00 00 00       	jmpq   22417 <lv_draw_mask_line+0x33a>
        if(k < 0) {
   22336:	44 89 cf             	mov    %r9d,%edi
   22339:	ff c7                	inc    %edi
   2233b:	0f 88 2e fe ff ff    	js     2216f <lv_draw_mask_line+0x92>
        if(k <= len) {
   22341:	39 cf                	cmp    %ecx,%edi
   22343:	0f 8f 3f fe ff ff    	jg     22188 <lv_draw_mask_line+0xab>
            _lv_memset_00(&mask_buf[k], len - k);
   22349:	29 f9                	sub    %edi,%ecx
   2234b:	48 63 ff             	movslq %edi,%rdi
   2234e:	48 63 f1             	movslq %ecx,%rsi
   22351:	e9 2a fe ff ff       	jmpq   22180 <lv_draw_mask_line+0xa3>
    x_at_y = (int32_t)((int32_t)p->xy_steep * abs_y) >> 10;
   22356:	41 8b 68 20          	mov    0x20(%r8),%ebp
   2235a:	89 d6                	mov    %edx,%esi
   2235c:	0f af f5             	imul   %ebp,%esi
   2235f:	c1 fe 0a             	sar    $0xa,%esi
    if(p->xy_steep > 0) x_at_y++;
   22362:	85 ed                	test   %ebp,%ebp
    x_at_y = (int32_t)((int32_t)p->xy_steep * abs_y) >> 10;
   22364:	89 f7                	mov    %esi,%edi
    if(p->xy_steep > 0) x_at_y++;
   22366:	7e 03                	jle    2236b <lv_draw_mask_line+0x28e>
   22368:	8d 7e 01             	lea    0x1(%rsi),%edi
    if(x_at_y < abs_x) {
   2236b:	44 39 df             	cmp    %r11d,%edi
   2236e:	7d 0a                	jge    2237a <lv_draw_mask_line+0x29d>
        if(p->inv) {
   22370:	84 c0                	test   %al,%al
   22372:	0f 95 c0             	setne  %al
   22375:	e9 67 02 00 00       	jmpq   225e1 <lv_draw_mask_line+0x504>
    if(x_at_y > abs_x + len) {
   2237a:	41 8d 3c 0b          	lea    (%r11,%rcx,1),%edi
   2237e:	39 fe                	cmp    %edi,%esi
   22380:	7e 0a                	jle    2238c <lv_draw_mask_line+0x2af>
        if(p->inv) {
   22382:	84 c0                	test   %al,%al
   22384:	0f 94 c0             	sete   %al
   22387:	e9 55 02 00 00       	jmpq   225e1 <lv_draw_mask_line+0x504>
    int32_t xs = ((abs_y << 8) * p->xy_steep) >> 10;
   2238c:	89 d6                	mov    %edx,%esi
    int32_t xe = (((abs_y + 1) << 8) * p->xy_steep) >> 10;
   2238e:	ff c2                	inc    %edx
    int32_t xs = ((abs_y << 8) * p->xy_steep) >> 10;
   22390:	c1 e6 08             	shl    $0x8,%esi
    int32_t xe = (((abs_y + 1) << 8) * p->xy_steep) >> 10;
   22393:	c1 e2 08             	shl    $0x8,%edx
    int32_t xs = ((abs_y << 8) * p->xy_steep) >> 10;
   22396:	0f af f5             	imul   %ebp,%esi
    int32_t xe = (((abs_y + 1) << 8) * p->xy_steep) >> 10;
   22399:	0f af d5             	imul   %ebp,%edx
    int32_t xsi = xs >> 8;
   2239c:	89 f7                	mov    %esi,%edi
    int32_t xs = ((abs_y << 8) * p->xy_steep) >> 10;
   2239e:	c1 fe 0a             	sar    $0xa,%esi
    int32_t xsi = xs >> 8;
   223a1:	c1 ff 12             	sar    $0x12,%edi
    int32_t xei = xe >> 8;
   223a4:	89 d3                	mov    %edx,%ebx
    int32_t xsf = xs & 0xFF;
   223a6:	40 0f b6 f6          	movzbl %sil,%esi
    int32_t xei = xe >> 8;
   223aa:	c1 fb 12             	sar    $0x12,%ebx
    k = xsi - abs_x;
   223ad:	41 89 f9             	mov    %edi,%r9d
   223b0:	45 29 d9             	sub    %r11d,%r9d
    if(xsi != xei && (p->xy_steep < 0 && xsf == 0)) {
   223b3:	39 df                	cmp    %ebx,%edi
   223b5:	74 10                	je     223c7 <lv_draw_mask_line+0x2ea>
   223b7:	85 ed                	test   %ebp,%ebp
   223b9:	79 69                	jns    22424 <lv_draw_mask_line+0x347>
   223bb:	85 f6                	test   %esi,%esi
   223bd:	75 65                	jne    22424 <lv_draw_mask_line+0x347>
        k--;
   223bf:	41 ff c9             	dec    %r9d
        xsf = 0xFF;
   223c2:	be ff 00 00 00       	mov    $0xff,%esi
        if(k >= 0 && k < len) {
   223c7:	45 85 c9             	test   %r9d,%r9d
   223ca:	78 2e                	js     223fa <lv_draw_mask_line+0x31d>
   223cc:	44 39 c9             	cmp    %r9d,%ecx
   223cf:	7e 29                	jle    223fa <lv_draw_mask_line+0x31d>
    int32_t xe = (((abs_y + 1) << 8) * p->xy_steep) >> 10;
   223d1:	c1 fa 0a             	sar    $0xa,%edx
    int32_t xef = xe & 0xFF;
   223d4:	0f b6 d2             	movzbl %dl,%edx
            m = (xsf + xef) >> 1;
   223d7:	01 f2                	add    %esi,%edx
   223d9:	d1 fa                	sar    %edx
            if(p->inv) m = 255 - m;
   223db:	84 c0                	test   %al,%al
            m = (xsf + xef) >> 1;
   223dd:	40 88 d6             	mov    %dl,%sil
            if(p->inv) m = 255 - m;
   223e0:	74 02                	je     223e4 <lv_draw_mask_line+0x307>
   223e2:	f7 d6                	not    %esi
            mask_buf[k] = mask_mix(mask_buf[k], m);
   223e4:	49 63 e9             	movslq %r9d,%rbp
   223e7:	40 0f b6 f6          	movzbl %sil,%esi
   223eb:	4c 01 d5             	add    %r10,%rbp
   223ee:	0f b6 7d 00          	movzbl 0x0(%rbp),%edi
   223f2:	e8 bf fc ff ff       	callq  220b6 <mask_mix>
   223f7:	88 45 00             	mov    %al,0x0(%rbp)
        if(p->inv) {
   223fa:	41 f6 40 30 02       	testb  $0x2,0x30(%r8)
   223ff:	74 1e                	je     2241f <lv_draw_mask_line+0x342>
            k = xsi - abs_x;
   22401:	44 29 db             	sub    %r11d,%ebx
            if(k >= len) {
   22404:	39 cb                	cmp    %ecx,%ebx
   22406:	0f 8d 63 fd ff ff    	jge    2216f <lv_draw_mask_line+0x92>
            if(k >= 0) _lv_memset_00(&mask_buf[0], k);
   2240c:	85 db                	test   %ebx,%ebx
   2240e:	0f 88 74 fd ff ff    	js     22188 <lv_draw_mask_line+0xab>
                else if(k > 0) _lv_memset_00(&mask_buf[0],  k);
   22414:	48 63 f3             	movslq %ebx,%rsi
                if(k >= 0) _lv_memset_00(&mask_buf[0],  k);
   22417:	4c 89 d7             	mov    %r10,%rdi
   2241a:	e9 64 fd ff ff       	jmpq   22183 <lv_draw_mask_line+0xa6>
        k++;
   2241f:	41 ff c1             	inc    %r9d
   22422:	eb 4a                	jmp    2246e <lv_draw_mask_line+0x391>
   22424:	44 89 cf             	mov    %r9d,%edi
   22427:	45 8b 58 24          	mov    0x24(%r8),%r11d
   2242b:	f7 d7                	not    %edi
   2242d:	c1 ef 1f             	shr    $0x1f,%edi
   22430:	41 39 c9             	cmp    %ecx,%r9d
   22433:	0f 9c c2             	setl   %dl
   22436:	21 d7                	and    %edx,%edi
        if(p->xy_steep < 0) {
   22438:	85 ed                	test   %ebp,%ebp
   2243a:	78 57                	js     22493 <lv_draw_mask_line+0x3b6>
            y_inters = ((255 - xsf) * p->yx_steep) >> 10;
   2243c:	ba ff 00 00 00       	mov    $0xff,%edx
   22441:	29 f2                	sub    %esi,%edx
   22443:	44 0f af da          	imul   %edx,%r11d
   22447:	41 c1 fb 0a          	sar    $0xa,%r11d
            if(k >= 0 && k < len) {
   2244b:	40 84 ff             	test   %dil,%dil
   2244e:	0f 85 03 01 00 00    	jne    22557 <lv_draw_mask_line+0x47a>
            if(k >= 0 && k < len) {
   22454:	44 89 ca             	mov    %r9d,%edx
   22457:	ff c2                	inc    %edx
   22459:	0f 89 21 01 00 00    	jns    22580 <lv_draw_mask_line+0x4a3>
            if(p->inv) {
   2245f:	41 f6 40 30 02       	testb  $0x2,0x30(%r8)
   22464:	0f 85 5d 01 00 00    	jne    225c7 <lv_draw_mask_line+0x4ea>
            k++;
   2246a:	41 83 c1 02          	add    $0x2,%r9d
   2246e:	41 39 c9             	cmp    %ecx,%r9d
   22471:	44 0f 4f c9          	cmovg  %ecx,%r9d
                if(k == 0) return LV_DRAW_MASK_RES_TRANSP;
   22475:	41 83 f9 00          	cmp    $0x0,%r9d
   22479:	0f 84 f0 fc ff ff    	je     2216f <lv_draw_mask_line+0x92>
                else if(k > 0) _lv_memset_00(&mask_buf[k],  len - k);
   2247f:	0f 8e 03 fd ff ff    	jle    22188 <lv_draw_mask_line+0xab>
   22485:	44 29 c9             	sub    %r9d,%ecx
   22488:	49 63 f9             	movslq %r9d,%rdi
   2248b:	48 63 f1             	movslq %ecx,%rsi
   2248e:	e9 ed fc ff ff       	jmpq   22180 <lv_draw_mask_line+0xa3>
            y_inters = (xsf * (-p->yx_steep)) >> 10;
   22493:	41 f7 db             	neg    %r11d
   22496:	44 0f af de          	imul   %esi,%r11d
   2249a:	41 c1 fb 0a          	sar    $0xa,%r11d
            if(k >= 0 && k < len) {
   2249e:	40 84 ff             	test   %dil,%dil
   224a1:	74 26                	je     224c9 <lv_draw_mask_line+0x3ec>
                m = (y_inters * xsf) >> 9;
   224a3:	89 f2                	mov    %esi,%edx
   224a5:	41 0f af d3          	imul   %r11d,%edx
   224a9:	c1 fa 09             	sar    $0x9,%edx
                if(p->inv) m = 255 - m;
   224ac:	84 c0                	test   %al,%al
                m = (y_inters * xsf) >> 9;
   224ae:	40 88 d7             	mov    %dl,%dil
                if(p->inv) m = 255 - m;
   224b1:	74 02                	je     224b5 <lv_draw_mask_line+0x3d8>
   224b3:	f7 d7                	not    %edi
                mask_buf[k] = mask_mix(mask_buf[k], m);
   224b5:	49 63 d9             	movslq %r9d,%rbx
   224b8:	40 0f b6 f7          	movzbl %dil,%esi
   224bc:	4c 01 d3             	add    %r10,%rbx
   224bf:	0f b6 3b             	movzbl (%rbx),%edi
   224c2:	e8 ef fb ff ff       	callq  220b6 <mask_mix>
   224c7:	88 03                	mov    %al,(%rbx)
            if(k >= 0 && k < len) {
   224c9:	44 89 cb             	mov    %r9d,%ebx
   224cc:	ff cb                	dec    %ebx
   224ce:	78 42                	js     22512 <lv_draw_mask_line+0x435>
   224d0:	39 cb                	cmp    %ecx,%ebx
   224d2:	7d 3e                	jge    22512 <lv_draw_mask_line+0x435>
            int32_t x_inters = ((255 - y_inters) * (-p->xy_steep)) >> 10;
   224d4:	b8 ff 00 00 00       	mov    $0xff,%eax
   224d9:	44 29 d8             	sub    %r11d,%eax
   224dc:	89 c2                	mov    %eax,%edx
   224de:	41 8b 40 20          	mov    0x20(%r8),%eax
   224e2:	f7 d8                	neg    %eax
   224e4:	0f af c2             	imul   %edx,%eax
   224e7:	c1 f8 0a             	sar    $0xa,%eax
                m = 255 - (((255 - y_inters) * x_inters) >> 9);
   224ea:	0f af c2             	imul   %edx,%eax
   224ed:	c1 f8 09             	sar    $0x9,%eax
                if(p->inv) m = 255 - m;
   224f0:	41 f6 40 30 02       	testb  $0x2,0x30(%r8)
                m = 255 - (((255 - y_inters) * x_inters) >> 9);
   224f5:	40 88 c6             	mov    %al,%sil
                if(p->inv) m = 255 - m;
   224f8:	75 02                	jne    224fc <lv_draw_mask_line+0x41f>
                m = 255 - (((255 - y_inters) * x_inters) >> 9);
   224fa:	f7 d6                	not    %esi
                mask_buf[k] = mask_mix(mask_buf[k], m);
   224fc:	4c 63 db             	movslq %ebx,%r11
   224ff:	40 0f b6 f6          	movzbl %sil,%esi
   22503:	4d 01 d3             	add    %r10,%r11
   22506:	41 0f b6 3b          	movzbl (%r11),%edi
   2250a:	e8 a7 fb ff ff       	callq  220b6 <mask_mix>
   2250f:	41 88 03             	mov    %al,(%r11)
            if(p->inv) {
   22512:	41 f6 40 30 02       	testb  $0x2,0x30(%r8)
   22517:	74 15                	je     2252e <lv_draw_mask_line+0x451>
                else if(k > 0) _lv_memset_00(&mask_buf[0],  k);
   22519:	85 db                	test   %ebx,%ebx
   2251b:	0f 8e 67 fc ff ff    	jle    22188 <lv_draw_mask_line+0xab>
   22521:	39 cb                	cmp    %ecx,%ebx
   22523:	0f 8f 5f fc ff ff    	jg     22188 <lv_draw_mask_line+0xab>
   22529:	e9 e6 fe ff ff       	jmpq   22414 <lv_draw_mask_line+0x337>
            k += 2;
   2252e:	41 ff c1             	inc    %r9d
                if(k > len) return LV_DRAW_MASK_RES_FULL_COVER;
   22531:	b0 01                	mov    $0x1,%al
   22533:	41 39 c9             	cmp    %ecx,%r9d
   22536:	0f 8f a5 00 00 00    	jg     225e1 <lv_draw_mask_line+0x504>
                if(k >= 0) _lv_memset_00(&mask_buf[k],  len - k);
   2253c:	45 85 c9             	test   %r9d,%r9d
   2253f:	0f 88 43 fc ff ff    	js     22188 <lv_draw_mask_line+0xab>
   22545:	44 29 c9             	sub    %r9d,%ecx
   22548:	4d 63 c9             	movslq %r9d,%r9
   2254b:	48 63 f1             	movslq %ecx,%rsi
   2254e:	4b 8d 3c 0a          	lea    (%r10,%r9,1),%rdi
   22552:	e9 2c fc ff ff       	jmpq   22183 <lv_draw_mask_line+0xa6>
                m = 255 - ((y_inters * (255 - xsf)) >> 9);
   22557:	41 0f af d3          	imul   %r11d,%edx
   2255b:	c1 fa 09             	sar    $0x9,%edx
                if(p->inv) m = 255 - m;
   2255e:	84 c0                	test   %al,%al
                m = 255 - ((y_inters * (255 - xsf)) >> 9);
   22560:	40 88 d6             	mov    %dl,%sil
                if(p->inv) m = 255 - m;
   22563:	75 02                	jne    22567 <lv_draw_mask_line+0x48a>
                m = 255 - ((y_inters * (255 - xsf)) >> 9);
   22565:	f7 d6                	not    %esi
                mask_buf[k] = mask_mix(mask_buf[k], m);
   22567:	49 63 d9             	movslq %r9d,%rbx
   2256a:	40 0f b6 f6          	movzbl %sil,%esi
   2256e:	4c 01 d3             	add    %r10,%rbx
   22571:	0f b6 3b             	movzbl (%rbx),%edi
   22574:	e8 3d fb ff ff       	callq  220b6 <mask_mix>
   22579:	88 03                	mov    %al,(%rbx)
   2257b:	e9 d4 fe ff ff       	jmpq   22454 <lv_draw_mask_line+0x377>
            if(k >= 0 && k < len) {
   22580:	39 ca                	cmp    %ecx,%edx
   22582:	0f 8d d7 fe ff ff    	jge    2245f <lv_draw_mask_line+0x382>
            int32_t x_inters = ((255 - y_inters) * p->xy_steep) >> 10;
   22588:	b8 ff 00 00 00       	mov    $0xff,%eax
   2258d:	44 29 d8             	sub    %r11d,%eax
   22590:	89 c6                	mov    %eax,%esi
   22592:	41 0f af 40 20       	imul   0x20(%r8),%eax
   22597:	c1 f8 0a             	sar    $0xa,%eax
                m = ((255 - y_inters) * x_inters) >> 9;
   2259a:	0f af c6             	imul   %esi,%eax
   2259d:	c1 f8 09             	sar    $0x9,%eax
                if(p->inv) m = 255 - m;
   225a0:	41 f6 40 30 02       	testb  $0x2,0x30(%r8)
                m = ((255 - y_inters) * x_inters) >> 9;
   225a5:	40 88 c6             	mov    %al,%sil
                if(p->inv) m = 255 - m;
   225a8:	74 02                	je     225ac <lv_draw_mask_line+0x4cf>
   225aa:	f7 d6                	not    %esi
                mask_buf[k] = mask_mix(mask_buf[k], m);
   225ac:	4c 63 da             	movslq %edx,%r11
   225af:	40 0f b6 f6          	movzbl %sil,%esi
   225b3:	4d 01 d3             	add    %r10,%r11
   225b6:	41 0f b6 3b          	movzbl (%r11),%edi
   225ba:	e8 f7 fa ff ff       	callq  220b6 <mask_mix>
   225bf:	41 88 03             	mov    %al,(%r11)
   225c2:	e9 98 fe ff ff       	jmpq   2245f <lv_draw_mask_line+0x382>
                if(k > len)  return LV_DRAW_MASK_RES_TRANSP;
   225c7:	41 39 c9             	cmp    %ecx,%r9d
   225ca:	0f 8f 9f fb ff ff    	jg     2216f <lv_draw_mask_line+0x92>
                if(k >= 0) _lv_memset_00(&mask_buf[0],  k);
   225d0:	45 85 c9             	test   %r9d,%r9d
   225d3:	0f 88 af fb ff ff    	js     22188 <lv_draw_mask_line+0xab>
   225d9:	49 63 f1             	movslq %r9d,%rsi
   225dc:	e9 36 fe ff ff       	jmpq   22417 <lv_draw_mask_line+0x33a>
}
   225e1:	5b                   	pop    %rbx
   225e2:	5d                   	pop    %rbp
   225e3:	c3                   	retq   

00000000000225e4 <lv_draw_mask_radius>:
{
   225e4:	41 57                	push   %r15
   225e6:	41 56                	push   %r14
   225e8:	41 55                	push   %r13
   225ea:	41 54                	push   %r12
   225ec:	55                   	push   %rbp
   225ed:	53                   	push   %rbx
   225ee:	48 89 fd             	mov    %rdi,%rbp
   225f1:	48 83 ec 48          	sub    $0x48,%rsp
   225f5:	4d 8b 48 10          	mov    0x10(%r8),%r9
    if(outer == false) {
   225f9:	45 8a 78 1a          	mov    0x1a(%r8),%r15b
{
   225fd:	89 0c 24             	mov    %ecx,(%rsp)
   22600:	8b 04 24             	mov    (%rsp),%eax
   22603:	45 89 cb             	mov    %r9d,%r11d
   22606:	66 89 44 24 1e       	mov    %ax,0x1e(%rsp)
   2260b:	41 c1 fb 10          	sar    $0x10,%r11d
   2260f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   22616:	00 00 
   22618:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
   2261d:	31 c0                	xor    %eax,%eax
    if(outer == false) {
   2261f:	41 80 e7 01          	and    $0x1,%r15b
   22623:	75 1b                	jne    22640 <lv_draw_mask_radius+0x5c>
        if(abs_y < rect.y1 || abs_y > rect.y2) {
   22625:	66 44 39 da          	cmp    %r11w,%dx
   22629:	0f 8c 51 03 00 00    	jl     22980 <lv_draw_mask_radius+0x39c>
   2262f:	4c 89 c8             	mov    %r9,%rax
   22632:	48 c1 f8 30          	sar    $0x30,%rax
   22636:	66 39 c2             	cmp    %ax,%dx
   22639:	7e 1e                	jle    22659 <lv_draw_mask_radius+0x75>
   2263b:	e9 40 03 00 00       	jmpq   22980 <lv_draw_mask_radius+0x39c>
        if(abs_y < rect.y1 || abs_y > rect.y2) {
   22640:	66 44 39 da          	cmp    %r11w,%dx
   22644:	7d 07                	jge    2264d <lv_draw_mask_radius+0x69>
            return LV_DRAW_MASK_RES_FULL_COVER;
   22646:	b0 01                	mov    $0x1,%al
   22648:	e9 ef 06 00 00       	jmpq   22d3c <lv_draw_mask_radius+0x758>
        if(abs_y < rect.y1 || abs_y > rect.y2) {
   2264d:	4c 89 c8             	mov    %r9,%rax
   22650:	48 c1 f8 30          	sar    $0x30,%rax
   22654:	66 39 c2             	cmp    %ax,%dx
   22657:	7f ed                	jg     22646 <lv_draw_mask_radius+0x62>
    int32_t radius = p->cfg.radius;
   22659:	41 0f bf 40 18       	movswl 0x18(%r8),%eax
    if((abs_x >= rect.x1 + radius && abs_x + len <= rect.x2 - radius) ||
   2265e:	41 0f bf d9          	movswl %r9w,%ebx
   22662:	44 0f bf d6          	movswl %si,%r10d
   22666:	8d 0c 03             	lea    (%rbx,%rax,1),%ecx
    int32_t radius = p->cfg.radius;
   22669:	89 c7                	mov    %eax,%edi
    if((abs_x >= rect.x1 + radius && abs_x + len <= rect.x2 - radius) ||
   2266b:	41 39 ca             	cmp    %ecx,%r10d
   2266e:	7c 18                	jl     22688 <lv_draw_mask_radius+0xa4>
   22670:	0f bf 34 24          	movswl (%rsp),%esi
   22674:	4c 89 c9             	mov    %r9,%rcx
   22677:	48 c1 e1 10          	shl    $0x10,%rcx
   2267b:	48 c1 f9 30          	sar    $0x30,%rcx
   2267f:	29 c1                	sub    %eax,%ecx
   22681:	44 01 d6             	add    %r10d,%esi
   22684:	39 ce                	cmp    %ecx,%esi
   22686:	7e 26                	jle    226ae <lv_draw_mask_radius+0xca>
       (abs_y >= rect.y1 + radius && abs_y <= rect.y2 - radius)) {
   22688:	45 8d 24 03          	lea    (%r11,%rax,1),%r12d
   2268c:	0f bf f2             	movswl %dx,%esi
   2268f:	4c 89 c9             	mov    %r9,%rcx
   22692:	48 c1 f9 30          	sar    $0x30,%rcx
    if((abs_x >= rect.x1 + radius && abs_x + len <= rect.x2 - radius) ||
   22696:	44 39 e6             	cmp    %r12d,%esi
   22699:	0f 8c b9 00 00 00    	jl     22758 <lv_draw_mask_radius+0x174>
       (abs_y >= rect.y1 + radius && abs_y <= rect.y2 - radius)) {
   2269f:	41 89 cc             	mov    %ecx,%r12d
   226a2:	41 29 c4             	sub    %eax,%r12d
   226a5:	44 39 e6             	cmp    %r12d,%esi
   226a8:	0f 8f aa 00 00 00    	jg     22758 <lv_draw_mask_radius+0x174>
   226ae:	44 29 d3             	sub    %r10d,%ebx
        if(outer == false) {
   226b1:	45 84 ff             	test   %r15b,%r15b
   226b4:	0f bf 14 24          	movswl (%rsp),%edx
   226b8:	75 57                	jne    22711 <lv_draw_mask_radius+0x12d>
            if(last > len) return LV_DRAW_MASK_RES_TRANSP;
   226ba:	39 da                	cmp    %ebx,%edx
   226bc:	0f 8c be 02 00 00    	jl     22980 <lv_draw_mask_radius+0x39c>
            if(last >= 0) {
   226c2:	85 db                	test   %ebx,%ebx
   226c4:	78 0b                	js     226d1 <lv_draw_mask_radius+0xed>
                _lv_memset_00(&mask_buf[0], last);
   226c6:	48 63 f3             	movslq %ebx,%rsi
   226c9:	48 89 ef             	mov    %rbp,%rdi
   226cc:	e8 dd f9 ff ff       	callq  220ae <_lv_memset_00>
            int32_t first = rect.x2 - abs_x + 1;
   226d1:	49 c1 e1 10          	shl    $0x10,%r9
   226d5:	49 c1 f9 30          	sar    $0x30,%r9
   226d9:	45 29 d1             	sub    %r10d,%r9d
   226dc:	41 ff c1             	inc    %r9d
            if(first <= 0) return LV_DRAW_MASK_RES_TRANSP;
   226df:	45 85 c9             	test   %r9d,%r9d
   226e2:	0f 8e 98 02 00 00    	jle    22980 <lv_draw_mask_radius+0x39c>
            else if(first < len) {
   226e8:	41 39 d1             	cmp    %edx,%r9d
   226eb:	7d 0e                	jge    226fb <lv_draw_mask_radius+0x117>
                _lv_memset_00(&mask_buf[first], len - first);
   226ed:	44 29 ca             	sub    %r9d,%edx
   226f0:	49 63 f9             	movslq %r9d,%rdi
   226f3:	48 63 f2             	movslq %edx,%rsi
   226f6:	e9 81 01 00 00       	jmpq   2287c <lv_draw_mask_radius+0x298>
            if(last == 0 && first == len) return LV_DRAW_MASK_RES_FULL_COVER;
   226fb:	85 db                	test   %ebx,%ebx
   226fd:	0f 85 81 01 00 00    	jne    22884 <lv_draw_mask_radius+0x2a0>
   22703:	41 39 d1             	cmp    %edx,%r9d
   22706:	0f 84 3a ff ff ff    	je     22646 <lv_draw_mask_radius+0x62>
   2270c:	e9 73 01 00 00       	jmpq   22884 <lv_draw_mask_radius+0x2a0>
   22711:	85 db                	test   %ebx,%ebx
   22713:	bf 00 00 00 00       	mov    $0x0,%edi
   22718:	0f 48 df             	cmovs  %edi,%ebx
            if(first <= len) {
   2271b:	39 d3                	cmp    %edx,%ebx
   2271d:	0f 8f 61 01 00 00    	jg     22884 <lv_draw_mask_radius+0x2a0>
                int32_t last =  rect.x2 - abs_x - first + 1;
   22723:	4c 89 ce             	mov    %r9,%rsi
   22726:	48 c1 e6 10          	shl    $0x10,%rsi
   2272a:	48 c1 fe 30          	sar    $0x30,%rsi
   2272e:	44 29 d6             	sub    %r10d,%esi
   22731:	29 de                	sub    %ebx,%esi
   22733:	ff c6                	inc    %esi
                if(first + last > len) last = len - first;
   22735:	8d 04 1e             	lea    (%rsi,%rbx,1),%eax
   22738:	39 d0                	cmp    %edx,%eax
   2273a:	7e 04                	jle    22740 <lv_draw_mask_radius+0x15c>
   2273c:	29 da                	sub    %ebx,%edx
   2273e:	89 d6                	mov    %edx,%esi
                if(last >= 0) {
   22740:	85 f6                	test   %esi,%esi
   22742:	0f 88 3c 01 00 00    	js     22884 <lv_draw_mask_radius+0x2a0>
                    _lv_memset_00(&mask_buf[first], last);
   22748:	48 63 db             	movslq %ebx,%rbx
   2274b:	48 63 f6             	movslq %esi,%rsi
   2274e:	48 8d 7c 1d 00       	lea    0x0(%rbp,%rbx,1),%rdi
   22753:	e9 27 01 00 00       	jmpq   2287f <lv_draw_mask_radius+0x29b>
   22758:	4d 89 cc             	mov    %r9,%r12
    uint32_t r2 = p->cfg.radius * p->cfg.radius;
   2275b:	89 c6                	mov    %eax,%esi
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   2275d:	ff c1                	inc    %ecx
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   2275f:	49 c1 e4 10          	shl    $0x10,%r12
    abs_y -= rect.y1;
   22763:	44 29 da             	sub    %r11d,%edx
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   22766:	44 29 d9             	sub    %r11d,%ecx
    uint32_t r2 = p->cfg.radius * p->cfg.radius;
   22769:	0f af f0             	imul   %eax,%esi
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   2276c:	49 c1 fc 30          	sar    $0x30,%r12
    int32_t k = rect.x1 - abs_x; /*First relevant coordinate on the of the mask*/
   22770:	44 29 d3             	sub    %r10d,%ebx
   22773:	45 29 cc             	sub    %r9d,%r12d
    int32_t h = lv_area_get_height(&rect);
   22776:	0f bf c9             	movswl %cx,%ecx
   22779:	41 ff c4             	inc    %r12d
    if(abs_y < radius || abs_y > h - radius - 1) {
   2277c:	66 39 d7             	cmp    %dx,%di
    uint32_t r2 = p->cfg.radius * p->cfg.radius;
   2277f:	89 74 24 04          	mov    %esi,0x4(%rsp)
    int32_t w = lv_area_get_width(&rect);
   22783:	45 0f bf e4          	movswl %r12w,%r12d
    if(abs_y < radius || abs_y > h - radius - 1) {
   22787:	0f bf f2             	movswl %dx,%esi
   2278a:	0f 8f fb 00 00 00    	jg     2288b <lv_draw_mask_radius+0x2a7>
   22790:	89 ca                	mov    %ecx,%edx
   22792:	29 c2                	sub    %eax,%edx
   22794:	ff ca                	dec    %edx
   22796:	39 d6                	cmp    %edx,%esi
   22798:	0f 8f f5 04 00 00    	jg     22c93 <lv_draw_mask_radius+0x6af>
   2279e:	e9 e1 00 00 00       	jmpq   22884 <lv_draw_mask_radius+0x2a0>
 */
LV_ATTRIBUTE_FAST_MEM static inline void sqrt_approx(lv_sqrt_res_t * q, lv_sqrt_res_t * ref, uint32_t x)
{
    x = x << 8; /*Upscale for extra precision*/

    uint32_t raw = (ref->i << 4) + (ref->f >> 4);
   227a3:	89 f7                	mov    %esi,%edi
                sqrt_approx(&y_next, &y_prev, r2 - (i * i));
   227a5:	8b 44 24 04          	mov    0x4(%rsp),%eax
    uint32_t raw = (ref->i << 4) + (ref->f >> 4);
   227a9:	66 c1 ef 04          	shr    $0x4,%di
   227ad:	0f b7 ff             	movzwl %di,%edi
   227b0:	03 7c 24 10          	add    0x10(%rsp),%edi
                sqrt_approx(&y_next, &y_prev, r2 - (i * i));
   227b4:	0f af d2             	imul   %edx,%edx
   227b7:	29 d0                	sub    %edx,%eax
    uint32_t raw2 = raw * raw;
   227b9:	89 fa                	mov    %edi,%edx

    int32_t d = x - raw2;
    d = (int32_t)d / (int32_t)(2 * raw) + raw;
   227bb:	44 8d 1c 3f          	lea    (%rdi,%rdi,1),%r11d
    uint32_t raw2 = raw * raw;
   227bf:	0f af d7             	imul   %edi,%edx
    x = x << 8; /*Upscale for extra precision*/
   227c2:	c1 e0 08             	shl    $0x8,%eax
    int32_t d = x - raw2;
   227c5:	29 d0                	sub    %edx,%eax
    d = (int32_t)d / (int32_t)(2 * raw) + raw;
   227c7:	99                   	cltd   
   227c8:	41 f7 fb             	idiv   %r11d
   227cb:	44 8d 0c 38          	lea    (%rax,%rdi,1),%r9d

    q->i = d >> 4;
    q->f = (d & 0xF) << 4;
   227cf:	44 89 c8             	mov    %r9d,%eax
    q->i = d >> 4;
   227d2:	45 89 cb             	mov    %r9d,%r11d
    q->f = (d & 0xF) << 4;
   227d5:	c1 e0 04             	shl    $0x4,%eax
    q->i = d >> 4;
   227d8:	41 c1 fb 04          	sar    $0x4,%r11d
    q->f = (d & 0xF) << 4;
   227dc:	0f b6 c0             	movzbl %al,%eax
                m = (y_prev.f + y_next.f) >> 1;
   227df:	01 c6                	add    %eax,%esi
    q->f = (d & 0xF) << 4;
   227e1:	41 89 c1             	mov    %eax,%r9d
                m = (y_prev.f + y_next.f) >> 1;
   227e4:	d1 fe                	sar    %esi
                if(outer) m = 255 - m;
   227e6:	45 84 ff             	test   %r15b,%r15b
                m = (y_prev.f + y_next.f) >> 1;
   227e9:	41 88 f5             	mov    %sil,%r13b
                if(outer) m = 255 - m;
   227ec:	74 03                	je     227f1 <lv_draw_mask_radius+0x20d>
   227ee:	41 f7 d5             	not    %r13d
                if(kl >= 0 && kl < len) mask_buf[kl] = mask_mix(mask_buf[kl], m);
   227f1:	85 c9                	test   %ecx,%ecx
   227f3:	0f 89 ee 03 00 00    	jns    22be7 <lv_draw_mask_radius+0x603>
                if(kr >= 0 && kr < len) mask_buf[kr] = mask_mix(mask_buf[kr], m);
   227f9:	45 85 c0             	test   %r8d,%r8d
   227fc:	0f 89 07 04 00 00    	jns    22c09 <lv_draw_mask_radius+0x625>
   22802:	49 ff c2             	inc    %r10
   22805:	b0 01                	mov    $0x1,%al
                y_prev.f = y_next.f;
   22807:	41 0f b7 f1          	movzwl %r9w,%esi
   2280b:	8b 4c 24 18          	mov    0x18(%rsp),%ecx
   2280f:	43 8d 14 14          	lea    (%r12,%r10,1),%edx
   22813:	46 8d 04 13          	lea    (%rbx,%r10,1),%r8d
   22817:	44 29 d1             	sub    %r10d,%ecx
            for(; i <= x1.i; i++) {
   2281a:	39 54 24 08          	cmp    %edx,0x8(%rsp)
   2281e:	73 83                	jae    227a3 <lv_draw_mask_radius+0x1bf>
   22820:	84 c0                	test   %al,%al
   22822:	74 11                	je     22835 <lv_draw_mask_radius+0x251>
   22824:	66 89 74 24 32       	mov    %si,0x32(%rsp)
   22829:	66 44 89 5c 24 34    	mov    %r11w,0x34(%rsp)
   2282f:	66 44 89 4c 24 36    	mov    %r9w,0x36(%rsp)
            if(y_prev.f) {
   22835:	0f b7 54 24 32       	movzwl 0x32(%rsp),%edx
   2283a:	66 85 d2             	test   %dx,%dx
   2283d:	0f 85 ea 03 00 00    	jne    22c2d <lv_draw_mask_radius+0x649>
            if(outer == 0) {
   22843:	45 84 ff             	test   %r15b,%r15b
   22846:	75 3c                	jne    22884 <lv_draw_mask_radius+0x2a0>
                if(kl > len) {
   22848:	0f bf 14 24          	movswl (%rsp),%edx
                kl++;
   2284c:	ff c1                	inc    %ecx
                if(kl > len) {
   2284e:	39 ca                	cmp    %ecx,%edx
   22850:	0f 8c 2a 01 00 00    	jl     22980 <lv_draw_mask_radius+0x39c>
                if(kl >= 0) _lv_memset_00(&mask_buf[0], kl);
   22856:	85 c9                	test   %ecx,%ecx
   22858:	78 0b                	js     22865 <lv_draw_mask_radius+0x281>
   2285a:	48 63 f1             	movslq %ecx,%rsi
   2285d:	48 89 ef             	mov    %rbp,%rdi
   22860:	e8 49 f8 ff ff       	callq  220ae <_lv_memset_00>
                if(kr < 0) {
   22865:	45 85 c0             	test   %r8d,%r8d
   22868:	0f 88 12 01 00 00    	js     22980 <lv_draw_mask_radius+0x39c>
                if(kr < len) _lv_memset_00(&mask_buf[kr], len - kr);
   2286e:	44 39 c2             	cmp    %r8d,%edx
   22871:	7e 11                	jle    22884 <lv_draw_mask_radius+0x2a0>
   22873:	44 29 c2             	sub    %r8d,%edx
   22876:	49 63 f8             	movslq %r8d,%rdi
   22879:	48 63 f2             	movslq %edx,%rsi
   2287c:	48 01 ef             	add    %rbp,%rdi
   2287f:	e8 2a f8 ff ff       	callq  220ae <_lv_memset_00>
    return LV_DRAW_MASK_RES_CHANGED;
   22884:	b0 02                	mov    $0x2,%al
   22886:	e9 b1 04 00 00       	jmpq   22d3c <lv_draw_mask_radius+0x758>
        if(radius <= 256) sqrt_mask = 0x800;
   2288b:	3d 00 01 00 00       	cmp    $0x100,%eax
   22890:	41 bd 00 80 00 00    	mov    $0x8000,%r13d
   22896:	ba 00 08 00 00       	mov    $0x800,%edx
            y = radius - abs_y;
   2289b:	41 89 c6             	mov    %eax,%r14d
        if(radius <= 256) sqrt_mask = 0x800;
   2289e:	44 0f 4e ea          	cmovle %edx,%r13d
            y = radius - abs_y;
   228a2:	41 29 f6             	sub    %esi,%r14d
            if(y == p->y_prev) {
   228a5:	45 39 70 1c          	cmp    %r14d,0x1c(%r8)
   228a9:	0f 85 d8 00 00 00    	jne    22987 <lv_draw_mask_radius+0x3a3>
                x0.f = p->y_prev_x.f;
   228af:	66 41 8b 50 22       	mov    0x22(%r8),%dx
   228b4:	66 89 54 24 2a       	mov    %dx,0x2a(%rsp)
                x0.i = p->y_prev_x.i;
   228b9:	41 8b 50 20          	mov    0x20(%r8),%edx
   228bd:	66 89 54 24 28       	mov    %dx,0x28(%rsp)
            _lv_sqrt(r2 - ((y - 1) * (y - 1)), &x1, sqrt_mask);
   228c2:	41 8d 4e ff          	lea    -0x1(%r14),%ecx
   228c6:	8b 7c 24 04          	mov    0x4(%rsp),%edi
   228ca:	48 8d 74 24 2c       	lea    0x2c(%rsp),%rsi
   228cf:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
   228d4:	89 44 24 08          	mov    %eax,0x8(%rsp)
   228d8:	89 ca                	mov    %ecx,%edx
   228da:	89 4c 24 18          	mov    %ecx,0x18(%rsp)
   228de:	0f af d1             	imul   %ecx,%edx
   228e1:	29 d7                	sub    %edx,%edi
   228e3:	44 89 ea             	mov    %r13d,%edx
   228e6:	e8 78 37 00 00       	callq  26063 <_lv_sqrt>
            p->y_prev = y - 1;
   228eb:	4c 8b 44 24 10       	mov    0x10(%rsp),%r8
            p->y_prev_x.f = x1.f;
   228f0:	66 8b 54 24 2e       	mov    0x2e(%rsp),%dx
            p->y_prev = y - 1;
   228f5:	8b 4c 24 18          	mov    0x18(%rsp),%ecx
   228f9:	8b 44 24 08          	mov    0x8(%rsp),%eax
            p->y_prev_x.f = x1.f;
   228fd:	66 41 89 50 22       	mov    %dx,0x22(%r8)
            p->y_prev_x.i = x1.i;
   22902:	8b 54 24 2c          	mov    0x2c(%rsp),%edx
            p->y_prev = y - 1;
   22906:	41 89 48 1c          	mov    %ecx,0x1c(%r8)
            p->y_prev_x.i = x1.i;
   2290a:	66 41 89 50 20       	mov    %dx,0x20(%r8)
        if(x0.i == x1.i - 1 && x1.f == 0) {
   2290f:	0f b7 74 24 2c       	movzwl 0x2c(%rsp),%esi
   22914:	0f b7 4c 24 28       	movzwl 0x28(%rsp),%ecx
   22919:	89 f2                	mov    %esi,%edx
   2291b:	ff ce                	dec    %esi
   2291d:	89 cf                	mov    %ecx,%edi
   2291f:	39 f1                	cmp    %esi,%ecx
   22921:	0f 84 91 00 00 00    	je     229b8 <lv_draw_mask_radius+0x3d4>
        if(x0.i == x1.i) {
   22927:	66 3b 7c 24 2c       	cmp    0x2c(%rsp),%di
   2292c:	0f 85 57 01 00 00    	jne    22a89 <lv_draw_mask_radius+0x4a5>
            lv_opa_t m = (x0.f + x1.f) >> 1;
   22932:	0f b7 54 24 2a       	movzwl 0x2a(%rsp),%edx
   22937:	0f b7 74 24 2e       	movzwl 0x2e(%rsp),%esi
   2293c:	01 f2                	add    %esi,%edx
   2293e:	d1 fa                	sar    %edx
            if(outer) m = 255 - m;
   22940:	45 84 ff             	test   %r15b,%r15b
            lv_opa_t m = (x0.f + x1.f) >> 1;
   22943:	41 88 d2             	mov    %dl,%r10b
            if(outer) m = 255 - m;
   22946:	74 03                	je     2294b <lv_draw_mask_radius+0x367>
   22948:	41 f7 d2             	not    %r10d
            int32_t ofs = radius - x0.i - 1;
   2294b:	29 c8                	sub    %ecx,%eax
            if(kl >= 0 && kl < len) {
   2294d:	89 d9                	mov    %ebx,%ecx
   2294f:	44 0f bf 0c 24       	movswl (%rsp),%r9d
            int32_t ofs = radius - x0.i - 1;
   22954:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
            if(kl >= 0 && kl < len) {
   22958:	44 01 c1             	add    %r8d,%ecx
   2295b:	79 7a                	jns    229d7 <lv_draw_mask_radius+0x3f3>
            int32_t kr = k + (w - ofs - 1);
   2295d:	45 29 c4             	sub    %r8d,%r12d
   22960:	46 8d 44 23 ff       	lea    -0x1(%rbx,%r12,1),%r8d
            if(kr >= 0 && kr < len) {
   22965:	45 85 c0             	test   %r8d,%r8d
   22968:	0f 89 89 00 00 00    	jns    229f7 <lv_draw_mask_radius+0x413>
            if(outer == false) {
   2296e:	45 84 ff             	test   %r15b,%r15b
   22971:	0f 85 d8 00 00 00    	jne    22a4f <lv_draw_mask_radius+0x46b>
                if(kl > len)  {
   22977:	44 39 c9             	cmp    %r9d,%ecx
   2297a:	0f 8e 9b 00 00 00    	jle    22a1b <lv_draw_mask_radius+0x437>
                    return LV_DRAW_MASK_RES_TRANSP;
   22980:	31 c0                	xor    %eax,%eax
   22982:	e9 b5 03 00 00       	jmpq   22d3c <lv_draw_mask_radius+0x758>
                _lv_sqrt(r2 - (y * y), &x0, sqrt_mask);
   22987:	44 89 f2             	mov    %r14d,%edx
   2298a:	8b 7c 24 04          	mov    0x4(%rsp),%edi
   2298e:	48 8d 74 24 28       	lea    0x28(%rsp),%rsi
   22993:	41 0f af d6          	imul   %r14d,%edx
   22997:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
   2299c:	89 44 24 18          	mov    %eax,0x18(%rsp)
   229a0:	29 d7                	sub    %edx,%edi
   229a2:	44 89 ea             	mov    %r13d,%edx
   229a5:	e8 b9 36 00 00       	callq  26063 <_lv_sqrt>
   229aa:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
   229af:	8b 44 24 18          	mov    0x18(%rsp),%eax
   229b3:	e9 0a ff ff ff       	jmpq   228c2 <lv_draw_mask_radius+0x2de>
        if(x0.i == x1.i - 1 && x1.f == 0) {
   229b8:	66 83 7c 24 2e 00    	cmpw   $0x0,0x2e(%rsp)
   229be:	0f 85 63 ff ff ff    	jne    22927 <lv_draw_mask_radius+0x343>
            x1.i--;
   229c4:	ff ca                	dec    %edx
            x1.f = 0xFF;
   229c6:	66 c7 44 24 2e ff 00 	movw   $0xff,0x2e(%rsp)
            x1.i--;
   229cd:	66 89 54 24 2c       	mov    %dx,0x2c(%rsp)
   229d2:	e9 50 ff ff ff       	jmpq   22927 <lv_draw_mask_radius+0x343>
            if(kl >= 0 && kl < len) {
   229d7:	44 39 c9             	cmp    %r9d,%ecx
   229da:	7d 81                	jge    2295d <lv_draw_mask_radius+0x379>
                mask_buf[kl] = mask_mix(mask_buf[kl], m);
   229dc:	4c 63 d9             	movslq %ecx,%r11
   229df:	41 0f b6 f2          	movzbl %r10b,%esi
   229e3:	49 01 eb             	add    %rbp,%r11
   229e6:	41 0f b6 3b          	movzbl (%r11),%edi
   229ea:	e8 c7 f6 ff ff       	callq  220b6 <mask_mix>
   229ef:	41 88 03             	mov    %al,(%r11)
   229f2:	e9 66 ff ff ff       	jmpq   2295d <lv_draw_mask_radius+0x379>
            if(kr >= 0 && kr < len) {
   229f7:	45 39 c8             	cmp    %r9d,%r8d
   229fa:	0f 8d 6e ff ff ff    	jge    2296e <lv_draw_mask_radius+0x38a>
                mask_buf[kr] = mask_mix(mask_buf[kr], m);
   22a00:	4d 63 d8             	movslq %r8d,%r11
   22a03:	41 0f b6 f2          	movzbl %r10b,%esi
   22a07:	49 01 eb             	add    %rbp,%r11
   22a0a:	41 0f b6 3b          	movzbl (%r11),%edi
   22a0e:	e8 a3 f6 ff ff       	callq  220b6 <mask_mix>
   22a13:	41 88 03             	mov    %al,(%r11)
   22a16:	e9 53 ff ff ff       	jmpq   2296e <lv_draw_mask_radius+0x38a>
                if(kl >= 0) {
   22a1b:	85 c9                	test   %ecx,%ecx
   22a1d:	78 0b                	js     22a2a <lv_draw_mask_radius+0x446>
                    _lv_memset_00(&mask_buf[0], kl);
   22a1f:	48 63 f1             	movslq %ecx,%rsi
   22a22:	48 89 ef             	mov    %rbp,%rdi
   22a25:	e8 84 f6 ff ff       	callq  220ae <_lv_memset_00>
                if(kr < 0) {
   22a2a:	41 ff c0             	inc    %r8d
   22a2d:	0f 88 4d ff ff ff    	js     22980 <lv_draw_mask_radius+0x39c>
                if(kr <= len) {
   22a33:	45 39 c8             	cmp    %r9d,%r8d
   22a36:	0f 8f 48 fe ff ff    	jg     22884 <lv_draw_mask_radius+0x2a0>
                    _lv_memset_00(&mask_buf[kr], len - kr);
   22a3c:	45 29 c1             	sub    %r8d,%r9d
   22a3f:	4d 63 c0             	movslq %r8d,%r8
   22a42:	49 63 f1             	movslq %r9d,%rsi
   22a45:	4a 8d 7c 05 00       	lea    0x0(%rbp,%r8,1),%rdi
   22a4a:	e9 30 fe ff ff       	jmpq   2287f <lv_draw_mask_radius+0x29b>
   22a4f:	ff c1                	inc    %ecx
   22a51:	b8 00 00 00 00       	mov    $0x0,%eax
                if(len_tmp + first > len) len_tmp = len - first;
   22a56:	44 89 ce             	mov    %r9d,%esi
   22a59:	0f 48 c8             	cmovs  %eax,%ecx
   22a5c:	29 ce                	sub    %ecx,%esi
   22a5e:	45 39 c8             	cmp    %r9d,%r8d
   22a61:	7f 05                	jg     22a68 <lv_draw_mask_radius+0x484>
                int32_t len_tmp = kr - first;
   22a63:	44 89 c6             	mov    %r8d,%esi
   22a66:	29 ce                	sub    %ecx,%esi
                if(first < len && len_tmp >= 0) {
   22a68:	85 f6                	test   %esi,%esi
   22a6a:	0f 88 14 fe ff ff    	js     22884 <lv_draw_mask_radius+0x2a0>
   22a70:	44 39 c9             	cmp    %r9d,%ecx
   22a73:	0f 8d 0b fe ff ff    	jge    22884 <lv_draw_mask_radius+0x2a0>
                    _lv_memset_00(&mask_buf[first], len_tmp);
   22a79:	48 63 c9             	movslq %ecx,%rcx
   22a7c:	48 63 f6             	movslq %esi,%rsi
   22a7f:	48 8d 7c 0d 00       	lea    0x0(%rbp,%rcx,1),%rdi
   22a84:	e9 f6 fd ff ff       	jmpq   2287f <lv_draw_mask_radius+0x29b>
            int32_t ofs = radius - (x0.i + 1);
   22a89:	8d 51 01             	lea    0x1(%rcx),%edx
   22a8c:	29 d0                	sub    %edx,%eax
            int32_t kl = k + ofs;
   22a8e:	8d 0c 03             	lea    (%rbx,%rax,1),%ecx
            int32_t kr = k + (w - ofs - 1);
   22a91:	41 29 c4             	sub    %eax,%r12d
            if(outer) {
   22a94:	45 84 ff             	test   %r15b,%r15b
            int32_t kr = k + (w - ofs - 1);
   22a97:	42 8d 5c 23 ff       	lea    -0x1(%rbx,%r12,1),%ebx
            int32_t kl = k + ofs;
   22a9c:	89 4c 24 18          	mov    %ecx,0x18(%rsp)
            if(outer) {
   22aa0:	74 32                	je     22ad4 <lv_draw_mask_radius+0x4f0>
   22aa2:	89 cf                	mov    %ecx,%edi
   22aa4:	b8 00 00 00 00       	mov    $0x0,%eax
   22aa9:	ff c7                	inc    %edi
   22aab:	0f 48 f8             	cmovs  %eax,%edi
                if(len_tmp + first > len) len_tmp = len - first;
   22aae:	0f bf 04 24          	movswl (%rsp),%eax
   22ab2:	89 c6                	mov    %eax,%esi
   22ab4:	29 fe                	sub    %edi,%esi
   22ab6:	39 d8                	cmp    %ebx,%eax
   22ab8:	7c 04                	jl     22abe <lv_draw_mask_radius+0x4da>
                int32_t len_tmp = kr - first;
   22aba:	89 de                	mov    %ebx,%esi
   22abc:	29 fe                	sub    %edi,%esi
                if(first < len && len_tmp >= 0) {
   22abe:	85 f6                	test   %esi,%esi
   22ac0:	78 12                	js     22ad4 <lv_draw_mask_radius+0x4f0>
   22ac2:	39 f8                	cmp    %edi,%eax
   22ac4:	7e 0e                	jle    22ad4 <lv_draw_mask_radius+0x4f0>
                    _lv_memset_00(&mask_buf[first], len_tmp);
   22ac6:	48 63 ff             	movslq %edi,%rdi
   22ac9:	48 63 f6             	movslq %esi,%rsi
   22acc:	48 01 ef             	add    %rbp,%rdi
   22acf:	e8 da f5 ff ff       	callq  220ae <_lv_memset_00>
            uint32_t i = x0.i + 1;
   22ad4:	0f b7 44 24 28       	movzwl 0x28(%rsp),%eax
            _lv_sqrt(r2 - (x0.i * x0.i), &y_prev, sqrt_mask);
   22ad9:	8b 7c 24 04          	mov    0x4(%rsp),%edi
   22add:	48 8d 74 24 30       	lea    0x30(%rsp),%rsi
   22ae2:	44 89 ea             	mov    %r13d,%edx
            uint32_t i = x0.i + 1;
   22ae5:	44 8d 60 01          	lea    0x1(%rax),%r12d
            _lv_sqrt(r2 - (x0.i * x0.i), &y_prev, sqrt_mask);
   22ae9:	0f af c0             	imul   %eax,%eax
   22aec:	29 c7                	sub    %eax,%edi
   22aee:	e8 70 35 00 00       	callq  26063 <_lv_sqrt>
            if(y_prev.f == 0) {
   22af3:	66 83 7c 24 32 00    	cmpw   $0x0,0x32(%rsp)
   22af9:	75 0c                	jne    22b07 <lv_draw_mask_radius+0x523>
                y_prev.i--;
   22afb:	66 ff 4c 24 30       	decw   0x30(%rsp)
                y_prev.f = 0xFF;
   22b00:	66 c7 44 24 32 ff 00 	movw   $0xff,0x32(%rsp)
            if(y_prev.i >= y) {
   22b07:	0f b7 44 24 30       	movzwl 0x30(%rsp),%eax
   22b0c:	44 39 f0             	cmp    %r14d,%eax
   22b0f:	0f 8c 9d 00 00 00    	jl     22bb2 <lv_draw_mask_radius+0x5ce>
                _lv_sqrt(r2 - (i * i), &y_next, sqrt_mask);
   22b15:	44 89 e0             	mov    %r12d,%eax
   22b18:	8b 7c 24 04          	mov    0x4(%rsp),%edi
   22b1c:	48 8d 74 24 34       	lea    0x34(%rsp),%rsi
   22b21:	41 0f af c4          	imul   %r12d,%eax
   22b25:	44 89 ea             	mov    %r13d,%edx
   22b28:	29 c7                	sub    %eax,%edi
   22b2a:	e8 34 35 00 00       	callq  26063 <_lv_sqrt>
                m = 255 - (((255 - x0.f) * (255 - y_next.f)) >> 9);
   22b2f:	0f b7 44 24 2a       	movzwl 0x2a(%rsp),%eax
   22b34:	0f b7 74 24 36       	movzwl 0x36(%rsp),%esi
   22b39:	ba ff 00 00 00       	mov    $0xff,%edx
   22b3e:	89 d7                	mov    %edx,%edi
   22b40:	29 c7                	sub    %eax,%edi
   22b42:	29 f2                	sub    %esi,%edx
   22b44:	89 f1                	mov    %esi,%ecx
   22b46:	89 f8                	mov    %edi,%eax
   22b48:	0f af c2             	imul   %edx,%eax
   22b4b:	c1 f8 09             	sar    $0x9,%eax
                if(outer) m = 255 - m;
   22b4e:	45 84 ff             	test   %r15b,%r15b
                m = 255 - (((255 - x0.f) * (255 - y_next.f)) >> 9);
   22b51:	41 88 c0             	mov    %al,%r8b
                if(outer) m = 255 - m;
   22b54:	75 03                	jne    22b59 <lv_draw_mask_radius+0x575>
                m = 255 - (((255 - x0.f) * (255 - y_next.f)) >> 9);
   22b56:	41 f7 d0             	not    %r8d
                if(kl >= 0 && kl < len) mask_buf[kl] = mask_mix(mask_buf[kl], m);
   22b59:	83 7c 24 18 00       	cmpl   $0x0,0x18(%rsp)
   22b5e:	78 22                	js     22b82 <lv_draw_mask_radius+0x59e>
   22b60:	0f bf 04 24          	movswl (%rsp),%eax
   22b64:	3b 44 24 18          	cmp    0x18(%rsp),%eax
   22b68:	7e 18                	jle    22b82 <lv_draw_mask_radius+0x59e>
   22b6a:	4c 63 4c 24 18       	movslq 0x18(%rsp),%r9
   22b6f:	41 0f b6 f0          	movzbl %r8b,%esi
   22b73:	49 01 e9             	add    %rbp,%r9
   22b76:	41 0f b6 39          	movzbl (%r9),%edi
   22b7a:	e8 37 f5 ff ff       	callq  220b6 <mask_mix>
   22b7f:	41 88 01             	mov    %al,(%r9)
                if(kr >= 0 && kr < len) mask_buf[kr] = mask_mix(mask_buf[kr], m);
   22b82:	85 db                	test   %ebx,%ebx
   22b84:	78 1e                	js     22ba4 <lv_draw_mask_radius+0x5c0>
   22b86:	0f bf 04 24          	movswl (%rsp),%eax
   22b8a:	39 d8                	cmp    %ebx,%eax
   22b8c:	7e 16                	jle    22ba4 <lv_draw_mask_radius+0x5c0>
   22b8e:	4c 63 cb             	movslq %ebx,%r9
   22b91:	41 0f b6 f0          	movzbl %r8b,%esi
   22b95:	49 01 e9             	add    %rbp,%r9
   22b98:	41 0f b6 39          	movzbl (%r9),%edi
   22b9c:	e8 15 f5 ff ff       	callq  220b6 <mask_mix>
   22ba1:	41 88 01             	mov    %al,(%r9)
                kl--;
   22ba4:	ff 4c 24 18          	decl   0x18(%rsp)
                kr++;
   22ba8:	ff c3                	inc    %ebx
                y_prev.f = y_next.f;
   22baa:	66 89 4c 24 32       	mov    %cx,0x32(%rsp)
                i++;
   22baf:	41 ff c4             	inc    %r12d
            for(; i <= x1.i; i++) {
   22bb2:	0f b7 44 24 2c       	movzwl 0x2c(%rsp),%eax
   22bb7:	0f b7 74 24 32       	movzwl 0x32(%rsp),%esi
    uint32_t raw = (ref->i << 4) + (ref->f >> 4);
   22bbc:	45 31 d2             	xor    %r10d,%r10d
   22bbf:	44 8b 5c 24 34       	mov    0x34(%rsp),%r11d
   22bc4:	66 44 8b 4c 24 36    	mov    0x36(%rsp),%r9w
                if(kl >= 0 && kl < len) mask_buf[kl] = mask_mix(mask_buf[kl], m);
   22bca:	44 0f bf 74 24 1e    	movswl 0x1e(%rsp),%r14d
            for(; i <= x1.i; i++) {
   22bd0:	89 44 24 08          	mov    %eax,0x8(%rsp)
    uint32_t raw = (ref->i << 4) + (ref->f >> 4);
   22bd4:	0f b7 44 24 30       	movzwl 0x30(%rsp),%eax
   22bd9:	c1 e0 04             	shl    $0x4,%eax
   22bdc:	89 44 24 10          	mov    %eax,0x10(%rsp)
   22be0:	31 c0                	xor    %eax,%eax
   22be2:	e9 24 fc ff ff       	jmpq   2280b <lv_draw_mask_radius+0x227>
                if(kl >= 0 && kl < len) mask_buf[kl] = mask_mix(mask_buf[kl], m);
   22be7:	41 39 ce             	cmp    %ecx,%r14d
   22bea:	0f 8e 09 fc ff ff    	jle    227f9 <lv_draw_mask_radius+0x215>
   22bf0:	48 63 c9             	movslq %ecx,%rcx
   22bf3:	41 0f b6 f5          	movzbl %r13b,%esi
   22bf7:	48 01 e9             	add    %rbp,%rcx
   22bfa:	0f b6 39             	movzbl (%rcx),%edi
   22bfd:	e8 b4 f4 ff ff       	callq  220b6 <mask_mix>
   22c02:	88 01                	mov    %al,(%rcx)
   22c04:	e9 f0 fb ff ff       	jmpq   227f9 <lv_draw_mask_radius+0x215>
                if(kr >= 0 && kr < len) mask_buf[kr] = mask_mix(mask_buf[kr], m);
   22c09:	45 39 c6             	cmp    %r8d,%r14d
   22c0c:	0f 8e f0 fb ff ff    	jle    22802 <lv_draw_mask_radius+0x21e>
   22c12:	4d 63 c0             	movslq %r8d,%r8
   22c15:	41 0f b6 f5          	movzbl %r13b,%esi
   22c19:	49 01 e8             	add    %rbp,%r8
   22c1c:	41 0f b6 38          	movzbl (%r8),%edi
   22c20:	e8 91 f4 ff ff       	callq  220b6 <mask_mix>
   22c25:	41 88 00             	mov    %al,(%r8)
   22c28:	e9 d5 fb ff ff       	jmpq   22802 <lv_draw_mask_radius+0x21e>
                m = (y_prev.f * x1.f) >> 9;
   22c2d:	0f b7 44 24 2e       	movzwl 0x2e(%rsp),%eax
   22c32:	0f af c2             	imul   %edx,%eax
   22c35:	c1 f8 09             	sar    $0x9,%eax
                if(outer) m = 255 - m;
   22c38:	45 84 ff             	test   %r15b,%r15b
                m = (y_prev.f * x1.f) >> 9;
   22c3b:	41 88 c1             	mov    %al,%r9b
                if(outer) m = 255 - m;
   22c3e:	74 03                	je     22c43 <lv_draw_mask_radius+0x65f>
   22c40:	41 f7 d1             	not    %r9d
                if(kl >= 0 && kl < len) mask_buf[kl] = mask_mix(mask_buf[kl], m);
   22c43:	85 c9                	test   %ecx,%ecx
   22c45:	78 1e                	js     22c65 <lv_draw_mask_radius+0x681>
   22c47:	0f bf 04 24          	movswl (%rsp),%eax
   22c4b:	39 c8                	cmp    %ecx,%eax
   22c4d:	7e 16                	jle    22c65 <lv_draw_mask_radius+0x681>
   22c4f:	4c 63 d1             	movslq %ecx,%r10
   22c52:	41 0f b6 f1          	movzbl %r9b,%esi
   22c56:	49 01 ea             	add    %rbp,%r10
   22c59:	41 0f b6 3a          	movzbl (%r10),%edi
   22c5d:	e8 54 f4 ff ff       	callq  220b6 <mask_mix>
   22c62:	41 88 02             	mov    %al,(%r10)
                if(kr >= 0 && kr < len) mask_buf[kr] = mask_mix(mask_buf[kr], m);
   22c65:	45 85 c0             	test   %r8d,%r8d
   22c68:	78 1f                	js     22c89 <lv_draw_mask_radius+0x6a5>
   22c6a:	0f bf 04 24          	movswl (%rsp),%eax
   22c6e:	44 39 c0             	cmp    %r8d,%eax
   22c71:	7e 16                	jle    22c89 <lv_draw_mask_radius+0x6a5>
   22c73:	4d 63 d0             	movslq %r8d,%r10
   22c76:	41 0f b6 f1          	movzbl %r9b,%esi
   22c7a:	49 01 ea             	add    %rbp,%r10
   22c7d:	41 0f b6 3a          	movzbl (%r10),%edi
   22c81:	e8 30 f4 ff ff       	callq  220b6 <mask_mix>
   22c86:	41 88 02             	mov    %al,(%r10)
                kl--;
   22c89:	ff c9                	dec    %ecx
                kr++;
   22c8b:	41 ff c0             	inc    %r8d
   22c8e:	e9 b0 fb ff ff       	jmpq   22843 <lv_draw_mask_radius+0x25f>
        else sqrt_mask = 0x8000;
   22c93:	3d 01 01 00 00       	cmp    $0x101,%eax
   22c98:	ba 00 80 00 00       	mov    $0x8000,%edx
   22c9d:	41 bd 00 08 00 00    	mov    $0x800,%r13d
   22ca3:	44 0f 4d ea          	cmovge %edx,%r13d
            y = radius - (h - abs_y) + 1;
   22ca7:	29 f1                	sub    %esi,%ecx
   22ca9:	89 c2                	mov    %eax,%edx
   22cab:	29 ca                	sub    %ecx,%edx
            if((y - 1) == p->y_prev) {
   22cad:	41 3b 50 1c          	cmp    0x1c(%r8),%edx
            y = radius - (h - abs_y) + 1;
   22cb1:	44 8d 72 01          	lea    0x1(%rdx),%r14d
            if((y - 1) == p->y_prev) {
   22cb5:	75 15                	jne    22ccc <lv_draw_mask_radius+0x6e8>
                x1.f = p->y_prev_x.f;
   22cb7:	66 41 8b 50 22       	mov    0x22(%r8),%dx
   22cbc:	66 89 54 24 2e       	mov    %dx,0x2e(%rsp)
                x1.i = p->y_prev_x.i;
   22cc1:	41 8b 50 20          	mov    0x20(%r8),%edx
   22cc5:	66 89 54 24 2c       	mov    %dx,0x2c(%rsp)
   22cca:	eb 28                	jmp    22cf4 <lv_draw_mask_radius+0x710>
                _lv_sqrt(r2 - ((y - 1) * (y - 1)), &x1, sqrt_mask);
   22ccc:	0f af d2             	imul   %edx,%edx
   22ccf:	8b 7c 24 04          	mov    0x4(%rsp),%edi
   22cd3:	48 8d 74 24 2c       	lea    0x2c(%rsp),%rsi
   22cd8:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
   22cdd:	89 44 24 18          	mov    %eax,0x18(%rsp)
   22ce1:	29 d7                	sub    %edx,%edi
   22ce3:	44 89 ea             	mov    %r13d,%edx
   22ce6:	e8 78 33 00 00       	callq  26063 <_lv_sqrt>
   22ceb:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
   22cf0:	8b 44 24 18          	mov    0x18(%rsp),%eax
            _lv_sqrt(r2 - (y * y), &x0, sqrt_mask);
   22cf4:	44 89 f2             	mov    %r14d,%edx
   22cf7:	8b 7c 24 04          	mov    0x4(%rsp),%edi
   22cfb:	48 8d 74 24 28       	lea    0x28(%rsp),%rsi
   22d00:	41 0f af d6          	imul   %r14d,%edx
   22d04:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
   22d09:	89 44 24 18          	mov    %eax,0x18(%rsp)
   22d0d:	29 d7                	sub    %edx,%edi
   22d0f:	44 89 ea             	mov    %r13d,%edx
   22d12:	e8 4c 33 00 00       	callq  26063 <_lv_sqrt>
            p->y_prev = y;
   22d17:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
            p->y_prev_x.f = x0.f;
   22d1c:	66 8b 54 24 2a       	mov    0x2a(%rsp),%dx
            p->y_prev_x.i = x0.i;
   22d21:	8b 44 24 18          	mov    0x18(%rsp),%eax
            p->y_prev_x.f = x0.f;
   22d25:	66 41 89 50 22       	mov    %dx,0x22(%r8)
            p->y_prev_x.i = x0.i;
   22d2a:	8b 54 24 28          	mov    0x28(%rsp),%edx
            p->y_prev = y;
   22d2e:	45 89 70 1c          	mov    %r14d,0x1c(%r8)
            p->y_prev_x.i = x0.i;
   22d32:	66 41 89 50 20       	mov    %dx,0x20(%r8)
   22d37:	e9 d3 fb ff ff       	jmpq   2290f <lv_draw_mask_radius+0x32b>
}
   22d3c:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
   22d41:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
   22d48:	00 00 
   22d4a:	74 05                	je     22d51 <lv_draw_mask_radius+0x76d>
   22d4c:	e8 ef 18 fe ff       	callq  4640 <__stack_chk_fail@plt>
   22d51:	48 83 c4 48          	add    $0x48,%rsp
   22d55:	5b                   	pop    %rbx
   22d56:	5d                   	pop    %rbp
   22d57:	41 5c                	pop    %r12
   22d59:	41 5d                	pop    %r13
   22d5b:	41 5e                	pop    %r14
   22d5d:	41 5f                	pop    %r15
   22d5f:	c3                   	retq   

0000000000022d60 <lv_draw_mask_add>:
        if(LV_GC_ROOT(_lv_draw_mask_list[i]).param == NULL) break;
   22d60:	48 8d 0d 39 4a 23 00 	lea    0x234a39(%rip),%rcx        # 2577a0 <_lv_draw_mask_list>
{
   22d67:	31 d2                	xor    %edx,%edx
        if(LV_GC_ROOT(_lv_draw_mask_list[i]).param == NULL) break;
   22d69:	49 89 d1             	mov    %rdx,%r9
   22d6c:	0f b6 c2             	movzbl %dl,%eax
   22d6f:	49 c1 e1 04          	shl    $0x4,%r9
   22d73:	49 83 3c 09 00       	cmpq   $0x0,(%r9,%rcx,1)
   22d78:	74 38                	je     22db2 <lv_draw_mask_add+0x52>
   22d7a:	48 ff c2             	inc    %rdx
    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {
   22d7d:	48 83 fa 10          	cmp    $0x10,%rdx
   22d81:	75 e6                	jne    22d69 <lv_draw_mask_add+0x9>
        LV_LOG_WARN("lv_mask_add: no place to add the mask");
   22d83:	4c 8d 05 cd 0a 01 00 	lea    0x10acd(%rip),%r8        # 33857 <_lv_bpp1_opa_table+0x2>
   22d8a:	48 8d 0d 8f dc 00 00 	lea    0xdc8f(%rip),%rcx        # 30a20 <__func__.3253>
   22d91:	48 8d 35 e5 0a 01 00 	lea    0x10ae5(%rip),%rsi        # 3387d <_lv_bpp1_opa_table+0x28>
{
   22d98:	48 83 ec 08          	sub    $0x8,%rsp
        LV_LOG_WARN("lv_mask_add: no place to add the mask");
   22d9c:	ba 53 00 00 00       	mov    $0x53,%edx
   22da1:	31 c0                	xor    %eax,%eax
   22da3:	bf 02 00 00 00       	mov    $0x2,%edi
   22da8:	e8 a9 31 00 00       	callq  25f56 <_lv_log_add>
        return LV_MASK_ID_INV;
   22dad:	83 c8 ff             	or     $0xffffffff,%eax
}
   22db0:	5a                   	pop    %rdx
   22db1:	c3                   	retq   
    LV_GC_ROOT(_lv_draw_mask_list[i]).param = param;
   22db2:	48 63 d2             	movslq %edx,%rdx
   22db5:	48 c1 e2 04          	shl    $0x4,%rdx
   22db9:	48 01 ca             	add    %rcx,%rdx
   22dbc:	48 89 3a             	mov    %rdi,(%rdx)
    LV_GC_ROOT(_lv_draw_mask_list[i]).custom_id = custom_id;
   22dbf:	48 89 72 08          	mov    %rsi,0x8(%rdx)
}
   22dc3:	c3                   	retq   

0000000000022dc4 <lv_draw_mask_apply>:
{
   22dc4:	41 57                	push   %r15
   22dc6:	41 56                	push   %r14
   22dc8:	49 89 fe             	mov    %rdi,%r14
   22dcb:	41 55                	push   %r13
   22dcd:	41 54                	push   %r12
        res = dsc->cb(mask_buf, abs_x, abs_y, len, (void *)m->param);
   22dcf:	44 0f bf e9          	movswl %cx,%r13d
{
   22dd3:	55                   	push   %rbp
   22dd4:	53                   	push   %rbx
   22dd5:	89 f5                	mov    %esi,%ebp
   22dd7:	41 89 d4             	mov    %edx,%r12d
    bool changed = false;
   22dda:	31 db                	xor    %ebx,%ebx
{
   22ddc:	48 83 ec 08          	sub    $0x8,%rsp
    _lv_draw_mask_saved_t * m = LV_GC_ROOT(_lv_draw_mask_list);
   22de0:	4c 8d 3d b9 49 23 00 	lea    0x2349b9(%rip),%r15        # 2577a0 <_lv_draw_mask_list>
    while(m->param) {
   22de7:	49 8b 07             	mov    (%r15),%rax
   22dea:	48 85 c0             	test   %rax,%rax
   22ded:	74 23                	je     22e12 <lv_draw_mask_apply+0x4e>
        res = dsc->cb(mask_buf, abs_x, abs_y, len, (void *)m->param);
   22def:	41 0f bf d4          	movswl %r12w,%edx
   22df3:	0f bf f5             	movswl %bp,%esi
   22df6:	49 89 c0             	mov    %rax,%r8
   22df9:	44 89 e9             	mov    %r13d,%ecx
   22dfc:	4c 89 f7             	mov    %r14,%rdi
   22dff:	ff 10                	callq  *(%rax)
        if(res == LV_DRAW_MASK_RES_TRANSP) return LV_DRAW_MASK_RES_TRANSP;
   22e01:	84 c0                	test   %al,%al
   22e03:	74 14                	je     22e19 <lv_draw_mask_apply+0x55>
        else if(res == LV_DRAW_MASK_RES_CHANGED) changed = true;
   22e05:	3c 02                	cmp    $0x2,%al
   22e07:	b0 01                	mov    $0x1,%al
   22e09:	0f 44 d8             	cmove  %eax,%ebx
        m++;
   22e0c:	49 83 c7 10          	add    $0x10,%r15
   22e10:	eb d5                	jmp    22de7 <lv_draw_mask_apply+0x23>
    return changed ? LV_DRAW_MASK_RES_CHANGED : LV_DRAW_MASK_RES_FULL_COVER;
   22e12:	84 db                	test   %bl,%bl
   22e14:	0f 95 c0             	setne  %al
   22e17:	ff c0                	inc    %eax
}
   22e19:	5a                   	pop    %rdx
   22e1a:	5b                   	pop    %rbx
   22e1b:	5d                   	pop    %rbp
   22e1c:	41 5c                	pop    %r12
   22e1e:	41 5d                	pop    %r13
   22e20:	41 5e                	pop    %r14
   22e22:	41 5f                	pop    %r15
   22e24:	c3                   	retq   

0000000000022e25 <lv_draw_mask_remove_id>:
    void * p = NULL;
   22e25:	31 c0                	xor    %eax,%eax
    if(id != LV_MASK_ID_INV) {
   22e27:	66 83 ff ff          	cmp    $0xffff,%di
   22e2b:	74 21                	je     22e4e <lv_draw_mask_remove_id+0x29>
        p = LV_GC_ROOT(_lv_draw_mask_list[id]).param;
   22e2d:	48 0f bf ff          	movswq %di,%rdi
   22e31:	48 c1 e7 04          	shl    $0x4,%rdi
   22e35:	48 03 3d 0c 31 21 00 	add    0x21310c(%rip),%rdi        # 235f48 <_GLOBAL_OFFSET_TABLE_+0x268>
   22e3c:	48 8b 07             	mov    (%rdi),%rax
        LV_GC_ROOT(_lv_draw_mask_list[id]).custom_id = NULL;
   22e3f:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
   22e46:	00 
        LV_GC_ROOT(_lv_draw_mask_list[id]).param = NULL;
   22e47:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
}
   22e4e:	c3                   	retq   

0000000000022e4f <lv_draw_mask_remove_custom>:
        if(LV_GC_ROOT(_lv_draw_mask_list[i]).custom_id == custom_id) {
   22e4f:	48 8d 0d 4a 49 23 00 	lea    0x23494a(%rip),%rcx        # 2577a0 <_lv_draw_mask_list>
{
   22e56:	31 d2                	xor    %edx,%edx
    void * p = NULL;
   22e58:	31 c0                	xor    %eax,%eax
        if(LV_GC_ROOT(_lv_draw_mask_list[i]).custom_id == custom_id) {
   22e5a:	48 39 7c 0a 08       	cmp    %rdi,0x8(%rdx,%rcx,1)
   22e5f:	75 15                	jne    22e76 <lv_draw_mask_remove_custom+0x27>
            p = LV_GC_ROOT(_lv_draw_mask_list[i]).param;
   22e61:	48 8b 04 0a          	mov    (%rdx,%rcx,1),%rax
            LV_GC_ROOT(_lv_draw_mask_list[i]).custom_id = NULL;
   22e65:	48 c7 44 0a 08 00 00 	movq   $0x0,0x8(%rdx,%rcx,1)
   22e6c:	00 00 
            LV_GC_ROOT(_lv_draw_mask_list[i]).param = NULL;
   22e6e:	48 c7 04 0a 00 00 00 	movq   $0x0,(%rdx,%rcx,1)
   22e75:	00 
   22e76:	48 83 c2 10          	add    $0x10,%rdx
    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {
   22e7a:	48 81 fa 00 01 00 00 	cmp    $0x100,%rdx
   22e81:	75 d7                	jne    22e5a <lv_draw_mask_remove_custom+0xb>
}
   22e83:	c3                   	retq   

0000000000022e84 <lv_draw_mask_get_cnt>:
{
   22e84:	48 8d 15 15 49 23 00 	lea    0x234915(%rip),%rdx        # 2577a0 <_lv_draw_mask_list>
    uint8_t cnt = 0;
   22e8b:	31 c0                	xor    %eax,%eax
   22e8d:	48 8d 8a 00 01 00 00 	lea    0x100(%rdx),%rcx
        if(LV_GC_ROOT(_lv_draw_mask_list[i]).param) cnt++;
   22e94:	48 83 3a 00          	cmpq   $0x0,(%rdx)
   22e98:	74 02                	je     22e9c <lv_draw_mask_get_cnt+0x18>
   22e9a:	ff c0                	inc    %eax
   22e9c:	48 83 c2 10          	add    $0x10,%rdx
    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {
   22ea0:	48 39 ca             	cmp    %rcx,%rdx
   22ea3:	75 ef                	jne    22e94 <lv_draw_mask_get_cnt+0x10>
}
   22ea5:	c3                   	retq   

0000000000022ea6 <lv_draw_mask_line_points_init>:
{
   22ea6:	41 56                	push   %r14
   22ea8:	41 55                	push   %r13
   22eaa:	41 89 f5             	mov    %esi,%r13d
   22ead:	41 54                	push   %r12
   22eaf:	55                   	push   %rbp
   22eb0:	41 89 f4             	mov    %esi,%r12d
   22eb3:	53                   	push   %rbx
    _lv_memset_00(param, sizeof(lv_draw_mask_line_param_t));
   22eb4:	be 38 00 00 00       	mov    $0x38,%esi
{
   22eb9:	49 89 fa             	mov    %rdi,%r10
   22ebc:	41 89 ce             	mov    %ecx,%r14d
   22ebf:	0f bf d9             	movswl %cx,%ebx
    _lv_memset_00(param, sizeof(lv_draw_mask_line_param_t));
   22ec2:	e8 e7 f1 ff ff       	callq  220ae <_lv_memset_00>
    if(p1y > p2y) {
   22ec7:	66 44 39 c2          	cmp    %r8w,%dx
   22ecb:	7f 10                	jg     22edd <lv_draw_mask_line_points_init+0x37>
   22ecd:	44 0f bf da          	movswl %dx,%r11d
   22ed1:	44 89 c5             	mov    %r8d,%ebp
   22ed4:	41 0f bf dd          	movswl %r13w,%ebx
   22ed8:	45 89 f4             	mov    %r14d,%r12d
   22edb:	eb 06                	jmp    22ee3 <lv_draw_mask_line_points_init+0x3d>
   22edd:	89 d5                	mov    %edx,%ebp
   22edf:	45 0f bf d8          	movswl %r8w,%r11d
    param->cfg.side = side;
   22ee3:	44 88 c8             	mov    %r9b,%al
   22ee6:	45 8a 4a 18          	mov    0x18(%r10),%r9b
    param->flat = (LV_MATH_ABS(p2x - p1x) > LV_MATH_ABS(p2y - p1y)) ? 1 : 0;
   22eea:	41 0f bf f4          	movswl %r12w,%esi
   22eee:	29 de                	sub    %ebx,%esi
    param->cfg.side = side;
   22ef0:	83 e0 03             	and    $0x3,%eax
    param->flat = (LV_MATH_ABS(p2x - p1x) > LV_MATH_ABS(p2y - p1y)) ? 1 : 0;
   22ef3:	0f bf cd             	movswl %bp,%ecx
   22ef6:	44 29 d9             	sub    %r11d,%ecx
    param->cfg.p1.x = p1x;
   22ef9:	66 41 89 5a 10       	mov    %bx,0x10(%r10)
    param->origo.x = p1x;
   22efe:	66 41 89 5a 1a       	mov    %bx,0x1a(%r10)
    param->cfg.side = side;
   22f03:	41 83 e1 fc          	and    $0xfffffffc,%r9d
    param->flat = (LV_MATH_ABS(p2x - p1x) > LV_MATH_ABS(p2y - p1y)) ? 1 : 0;
   22f07:	89 cf                	mov    %ecx,%edi
    param->dsc.cb = (lv_draw_mask_xcb_t)lv_draw_mask_line;
   22f09:	48 8d 1d cd f1 ff ff 	lea    -0xe33(%rip),%rbx        # 220dd <lv_draw_mask_line>
    param->cfg.side = side;
   22f10:	41 09 c1             	or     %eax,%r9d
    param->flat = (LV_MATH_ABS(p2x - p1x) > LV_MATH_ABS(p2y - p1y)) ? 1 : 0;
   22f13:	89 f0                	mov    %esi,%eax
   22f15:	c1 ff 1f             	sar    $0x1f,%edi
   22f18:	c1 f8 1f             	sar    $0x1f,%eax
    param->cfg.p1.y = p1y;
   22f1b:	66 45 89 5a 12       	mov    %r11w,0x12(%r10)
    param->cfg.p2.x = p2x;
   22f20:	66 45 89 62 14       	mov    %r12w,0x14(%r10)
    param->flat = (LV_MATH_ABS(p2x - p1x) > LV_MATH_ABS(p2y - p1y)) ? 1 : 0;
   22f25:	89 c2                	mov    %eax,%edx
    param->cfg.p2.y = p2y;
   22f27:	66 41 89 6a 16       	mov    %bp,0x16(%r10)
    param->cfg.side = side;
   22f2c:	45 88 4a 18          	mov    %r9b,0x18(%r10)
    param->flat = (LV_MATH_ABS(p2x - p1x) > LV_MATH_ABS(p2y - p1y)) ? 1 : 0;
   22f30:	31 f2                	xor    %esi,%edx
    param->origo.y = p1y;
   22f32:	66 45 89 5a 1c       	mov    %r11w,0x1c(%r10)
    param->xy_steep = 0;
   22f37:	49 c7 42 20 00 00 00 	movq   $0x0,0x20(%r10)
   22f3e:	00 
    param->flat = (LV_MATH_ABS(p2x - p1x) > LV_MATH_ABS(p2y - p1y)) ? 1 : 0;
   22f3f:	29 c2                	sub    %eax,%edx
   22f41:	89 f8                	mov    %edi,%eax
    param->dsc.cb = (lv_draw_mask_xcb_t)lv_draw_mask_line;
   22f43:	49 89 1a             	mov    %rbx,(%r10)
    param->flat = (LV_MATH_ABS(p2x - p1x) > LV_MATH_ABS(p2y - p1y)) ? 1 : 0;
   22f46:	31 c8                	xor    %ecx,%eax
    param->dsc.type = LV_DRAW_MASK_TYPE_LINE;
   22f48:	41 c6 42 08 00       	movb   $0x0,0x8(%r10)
    param->flat = (LV_MATH_ABS(p2x - p1x) > LV_MATH_ABS(p2y - p1y)) ? 1 : 0;
   22f4d:	29 f8                	sub    %edi,%eax
   22f4f:	39 c2                	cmp    %eax,%edx
   22f51:	41 8a 42 30          	mov    0x30(%r10),%al
   22f55:	0f 9f c2             	setg   %dl
   22f58:	83 e0 fe             	and    $0xfffffffe,%eax
   22f5b:	09 d0                	or     %edx,%eax
    if(param->flat) {
   22f5d:	a8 01                	test   $0x1,%al
    param->flat = (LV_MATH_ABS(p2x - p1x) > LV_MATH_ABS(p2y - p1y)) ? 1 : 0;
   22f5f:	41 88 42 30          	mov    %al,0x30(%r10)
    if(param->flat) {
   22f63:	74 32                	je     22f97 <lv_draw_mask_line_points_init+0xf1>
        if(dx) {
   22f65:	85 f6                	test   %esi,%esi
   22f67:	74 12                	je     22f7b <lv_draw_mask_line_points_init+0xd5>
            m = (1 << 20) / dx;  /*m is multiplier to normalize y (upscaled by 1024)*/
   22f69:	b8 00 00 10 00       	mov    $0x100000,%eax
   22f6e:	99                   	cltd   
   22f6f:	f7 fe                	idiv   %esi
            param->yx_steep = (m * dy) >> 10;
   22f71:	0f af c1             	imul   %ecx,%eax
   22f74:	c1 f8 0a             	sar    $0xa,%eax
   22f77:	41 89 42 24          	mov    %eax,0x24(%r10)
        if(dy) {
   22f7b:	85 c9                	test   %ecx,%ecx
   22f7d:	74 12                	je     22f91 <lv_draw_mask_line_points_init+0xeb>
            m = (1 << 20) / dy;  /*m is multiplier to normalize x (upscaled by 1024)*/
   22f7f:	b8 00 00 10 00       	mov    $0x100000,%eax
   22f84:	99                   	cltd   
   22f85:	f7 f9                	idiv   %ecx
            param->xy_steep = (m * dx) >> 10;
   22f87:	0f af c6             	imul   %esi,%eax
   22f8a:	c1 f8 0a             	sar    $0xa,%eax
   22f8d:	41 89 42 20          	mov    %eax,0x20(%r10)
        param->steep = param->yx_steep;
   22f91:	41 8b 42 24          	mov    0x24(%r10),%eax
   22f95:	eb 30                	jmp    22fc7 <lv_draw_mask_line_points_init+0x121>
        if(dy) {
   22f97:	85 c9                	test   %ecx,%ecx
   22f99:	74 12                	je     22fad <lv_draw_mask_line_points_init+0x107>
            m = (1 << 20) / dy;  /*m is multiplier to normalize x (upscaled by 1024)*/
   22f9b:	b8 00 00 10 00       	mov    $0x100000,%eax
   22fa0:	99                   	cltd   
   22fa1:	f7 f9                	idiv   %ecx
            param->xy_steep = (m * dx) >> 10;
   22fa3:	0f af c6             	imul   %esi,%eax
   22fa6:	c1 f8 0a             	sar    $0xa,%eax
   22fa9:	41 89 42 20          	mov    %eax,0x20(%r10)
        if(dx) {
   22fad:	85 f6                	test   %esi,%esi
   22faf:	74 12                	je     22fc3 <lv_draw_mask_line_points_init+0x11d>
            m = (1 << 20) / dx;  /*m is multiplier to normalize x (upscaled by 1024)*/
   22fb1:	b8 00 00 10 00       	mov    $0x100000,%eax
   22fb6:	99                   	cltd   
   22fb7:	f7 fe                	idiv   %esi
            param->yx_steep = (m * dy) >> 10;
   22fb9:	0f af c1             	imul   %ecx,%eax
   22fbc:	c1 f8 0a             	sar    $0xa,%eax
   22fbf:	41 89 42 24          	mov    %eax,0x24(%r10)
        param->steep = param->xy_steep;
   22fc3:	41 8b 42 20          	mov    0x20(%r10),%eax
    if(param->cfg.side == LV_DRAW_MASK_LINE_SIDE_LEFT) param->inv = 0;
   22fc7:	41 8a 52 18          	mov    0x18(%r10),%dl
        param->steep = param->xy_steep;
   22fcb:	41 89 42 28          	mov    %eax,0x28(%r10)
   22fcf:	41 8a 42 30          	mov    0x30(%r10),%al
   22fd3:	41 8b 4a 28          	mov    0x28(%r10),%ecx
    if(param->cfg.side == LV_DRAW_MASK_LINE_SIDE_LEFT) param->inv = 0;
   22fd7:	80 e2 03             	and    $0x3,%dl
   22fda:	75 05                	jne    22fe1 <lv_draw_mask_line_points_init+0x13b>
   22fdc:	83 e0 fd             	and    $0xfffffffd,%eax
   22fdf:	eb 08                	jmp    22fe9 <lv_draw_mask_line_points_init+0x143>
    else if(param->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT) param->inv = 1;
   22fe1:	80 fa 01             	cmp    $0x1,%dl
   22fe4:	75 22                	jne    23008 <lv_draw_mask_line_points_init+0x162>
   22fe6:	83 c8 02             	or     $0x2,%eax
   22fe9:	41 88 42 30          	mov    %al,0x30(%r10)
    param->spx = param->steep >> 2;
   22fed:	89 c8                	mov    %ecx,%eax
   22fef:	c1 f8 02             	sar    $0x2,%eax
   22ff2:	89 c2                	mov    %eax,%edx
   22ff4:	f7 da                	neg    %edx
   22ff6:	85 c9                	test   %ecx,%ecx
   22ff8:	0f 48 c2             	cmovs  %edx,%eax
}
   22ffb:	5b                   	pop    %rbx
    param->spx = param->steep >> 2;
   22ffc:	41 89 42 2c          	mov    %eax,0x2c(%r10)
}
   23000:	5d                   	pop    %rbp
   23001:	41 5c                	pop    %r12
   23003:	41 5d                	pop    %r13
   23005:	41 5e                	pop    %r14
   23007:	c3                   	retq   
    else if(param->cfg.side == LV_DRAW_MASK_LINE_SIDE_TOP) {
   23008:	80 fa 02             	cmp    $0x2,%dl
   2300b:	75 06                	jne    23013 <lv_draw_mask_line_points_init+0x16d>
        if(param->steep > 0) param->inv = 1;
   2300d:	85 c9                	test   %ecx,%ecx
   2300f:	7f d5                	jg     22fe6 <lv_draw_mask_line_points_init+0x140>
   23011:	eb c9                	jmp    22fdc <lv_draw_mask_line_points_init+0x136>
        if(param->steep > 0) param->inv = 0;
   23013:	85 c9                	test   %ecx,%ecx
   23015:	7f c5                	jg     22fdc <lv_draw_mask_line_points_init+0x136>
   23017:	eb cd                	jmp    22fe6 <lv_draw_mask_line_points_init+0x140>

0000000000023019 <lv_draw_mask_radius_init>:
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   23019:	66 8b 46 06          	mov    0x6(%rsi),%ax
   2301d:	44 8d 40 01          	lea    0x1(%rax),%r8d
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   23021:	66 8b 46 04          	mov    0x4(%rsi),%ax
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   23025:	66 44 2b 46 02       	sub    0x2(%rsi),%r8w
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   2302a:	ff c0                	inc    %eax
   2302c:	66 2b 06             	sub    (%rsi),%ax
    int32_t short_side = LV_MATH_MIN(w, h);
   2302f:	66 41 39 c0          	cmp    %ax,%r8w
   23033:	41 0f 4e c0          	cmovle %r8d,%eax
    if(radius > short_side >> 1) radius = short_side >> 1;
   23037:	44 0f bf c2          	movswl %dx,%r8d
    int32_t short_side = LV_MATH_MIN(w, h);
   2303b:	98                   	cwtl   
    if(radius > short_side >> 1) radius = short_side >> 1;
   2303c:	d1 f8                	sar    %eax
   2303e:	41 39 c0             	cmp    %eax,%r8d
   23041:	0f 4e c2             	cmovle %edx,%eax
   23044:	48 8b 16             	mov    (%rsi),%rdx
    param->dsc.type = LV_DRAW_MASK_TYPE_RADIUS;
   23047:	c6 47 08 02          	movb   $0x2,0x8(%rdi)
    param->cfg.radius = radius;
   2304b:	66 89 47 18          	mov    %ax,0x18(%rdi)
    param->cfg.outer = inv ? 1 : 0;
   2304f:	88 c8                	mov    %cl,%al
   23051:	8a 4f 1a             	mov    0x1a(%rdi),%cl
   23054:	83 e0 01             	and    $0x1,%eax
   23057:	48 89 57 10          	mov    %rdx,0x10(%rdi)
   2305b:	83 e1 fe             	and    $0xfffffffe,%ecx
   2305e:	09 c1                	or     %eax,%ecx
    param->dsc.cb = (lv_draw_mask_xcb_t)lv_draw_mask_radius;
   23060:	48 8d 05 7d f5 ff ff 	lea    -0xa83(%rip),%rax        # 225e4 <lv_draw_mask_radius>
    param->cfg.outer = inv ? 1 : 0;
   23067:	88 4f 1a             	mov    %cl,0x1a(%rdi)
    param->dsc.cb = (lv_draw_mask_xcb_t)lv_draw_mask_radius;
   2306a:	48 89 07             	mov    %rax,(%rdi)
    param->y_prev = INT32_MIN;
   2306d:	b8 00 00 00 80       	mov    $0x80000000,%eax
   23072:	48 89 47 1c          	mov    %rax,0x1c(%rdi)
}
   23076:	c3                   	retq   

0000000000023077 <grad_get>:
    }
}

LV_ATTRIBUTE_FAST_MEM static inline lv_color_t grad_get(const lv_draw_rect_dsc_t * dsc, lv_coord_t s, lv_coord_t i)
{
    int32_t min = (dsc->bg_main_color_stop * s) >> 8;
   23077:	44 0f bf 4f 0e       	movswl 0xe(%rdi),%r9d
   2307c:	0f bf ce             	movswl %si,%ecx
    if(i <= min) return dsc->bg_color;
   2307f:	44 0f bf d2          	movswl %dx,%r10d
    int32_t min = (dsc->bg_main_color_stop * s) >> 8;
   23083:	45 89 c8             	mov    %r9d,%r8d
   23086:	44 0f af c1          	imul   %ecx,%r8d
   2308a:	41 c1 f8 08          	sar    $0x8,%r8d
    if(i <= min) return dsc->bg_color;
   2308e:	45 39 c2             	cmp    %r8d,%r10d
   23091:	7f 04                	jg     23097 <grad_get+0x20>
   23093:	8b 47 04             	mov    0x4(%rdi),%eax
   23096:	c3                   	retq   

    int32_t max = (dsc->bg_grad_color_stop * s) >> 8;
   23097:	0f bf 47 10          	movswl 0x10(%rdi),%eax
   2309b:	89 ce                	mov    %ecx,%esi
   2309d:	0f af f0             	imul   %eax,%esi
   230a0:	c1 fe 08             	sar    $0x8,%esi
    if(i >= max) return dsc->bg_grad_color;
   230a3:	41 39 f2             	cmp    %esi,%r10d
   230a6:	7c 04                	jl     230ac <grad_get+0x35>
   230a8:	8b 47 08             	mov    0x8(%rdi),%eax
   230ab:	c3                   	retq   

    int32_t d = dsc->bg_grad_color_stop - dsc->bg_main_color_stop;
    d = (s * d) >> 8;
    i -= min;
   230ac:	44 29 c2             	sub    %r8d,%edx
    int32_t d = dsc->bg_grad_color_stop - dsc->bg_main_color_stop;
   230af:	44 29 c8             	sub    %r9d,%eax
LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
{
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   230b2:	41 b8 ff 00 00 00    	mov    $0xff,%r8d
   230b8:	89 c6                	mov    %eax,%esi
    lv_opa_t mix = (i * 255) / d;
   230ba:	0f bf c2             	movswl %dx,%eax
    d = (s * d) >> 8;
   230bd:	0f af f1             	imul   %ecx,%esi
    lv_opa_t mix = (i * 255) / d;
   230c0:	69 c0 ff 00 00 00    	imul   $0xff,%eax,%eax
    d = (s * d) >> 8;
   230c6:	c1 fe 08             	sar    $0x8,%esi
    lv_opa_t mix = (i * 255) / d;
   230c9:	99                   	cltd   
   230ca:	f7 fe                	idiv   %esi
   230cc:	0f b6 57 0a          	movzbl 0xa(%rdi),%edx
   230d0:	89 d1                	mov    %edx,%ecx
   230d2:	0f b6 57 06          	movzbl 0x6(%rdi),%edx
   230d6:	0f b6 c0             	movzbl %al,%eax
   230d9:	41 29 c0             	sub    %eax,%r8d
   230dc:	0f af c8             	imul   %eax,%ecx
   230df:	41 0f af d0          	imul   %r8d,%edx
   230e3:	01 ca                	add    %ecx,%edx
                                        (255 - mix) + LV_COLOR_MIX_ROUND_OFS));
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   230e5:	0f b6 4f 09          	movzbl 0x9(%rdi),%ecx
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   230e9:	69 f2 81 80 00 00    	imul   $0x8081,%edx,%esi
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   230ef:	0f af c8             	imul   %eax,%ecx
   230f2:	c1 ee 07             	shr    $0x7,%esi
   230f5:	89 ca                	mov    %ecx,%edx
   230f7:	0f b6 4f 05          	movzbl 0x5(%rdi),%ecx
   230fb:	41 0f af c8          	imul   %r8d,%ecx
   230ff:	01 d1                	add    %edx,%ecx
                                        (255 - mix) + LV_COLOR_MIX_ROUND_OFS));
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   23101:	0f b6 57 08          	movzbl 0x8(%rdi),%edx
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   23105:	69 c9 81 80 00 00    	imul   $0x8081,%ecx,%ecx
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   2310b:	0f af c2             	imul   %edx,%eax
   2310e:	0f b6 57 04          	movzbl 0x4(%rdi),%edx
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   23112:	c1 e9 17             	shr    $0x17,%ecx
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   23115:	44 0f af c2          	imul   %edx,%r8d
   23119:	42 8d 14 00          	lea    (%rax,%r8,1),%edx
   2311d:	31 c0                	xor    %eax,%eax
   2311f:	69 d2 81 80 00 00    	imul   $0x8081,%edx,%edx
   23125:	c1 ea 17             	shr    $0x17,%edx
   23128:	88 d0                	mov    %dl,%al
   2312a:	89 f2                	mov    %esi,%edx
   2312c:	88 cc                	mov    %cl,%ah
   2312e:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
   23134:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   23139:	09 d0                	or     %edx,%eax
   2313b:	0d 00 00 00 ff       	or     $0xff000000,%eax
    return lv_color_mix(dsc->bg_grad_color, dsc->bg_color, mix);
}
   23140:	c3                   	retq   

0000000000023141 <lv_draw_rect_dsc_init>:
   23141:	31 c0                	xor    %eax,%eax
   23143:	b9 20 00 00 00       	mov    $0x20,%ecx
{
   23148:	48 89 fa             	mov    %rdi,%rdx
   2314b:	f3 ab                	rep stos %eax,%es:(%rdi)
    dsc->bg_color = LV_COLOR_WHITE;
   2314d:	48 b8 ff ff ff ff 00 	movabs $0xff000000ffffffff,%rax
   23154:	00 00 ff 
    dsc->border_color = LV_COLOR_BLACK;
   23157:	c7 42 14 00 00 00 ff 	movl   $0xff000000,0x14(%rdx)
    dsc->value_color = LV_COLOR_BLACK;
   2315e:	c7 42 6c 00 00 00 ff 	movl   $0xff000000,0x6c(%rdx)
    dsc->bg_color = LV_COLOR_WHITE;
   23165:	48 89 42 04          	mov    %rax,0x4(%rdx)
    dsc->pattern_font = LV_THEME_DEFAULT_FONT_NORMAL;
   23169:	48 8d 05 70 37 21 00 	lea    0x213770(%rip),%rax        # 2368e0 <lv_font_montserrat_14>
    dsc->shadow_color = LV_COLOR_BLACK;
   23170:	c7 42 2c 00 00 00 ff 	movl   $0xff000000,0x2c(%rdx)
    dsc->bg_grad_color_stop = 0xFF;
   23177:	66 c7 42 10 ff 00    	movw   $0xff,0x10(%rdx)
    dsc->bg_opa = LV_OPA_COVER;
   2317d:	c6 42 12 ff          	movb   $0xff,0x12(%rdx)
    dsc->outline_opa = LV_OPA_COVER;
   23181:	c6 42 28 ff          	movb   $0xff,0x28(%rdx)
    dsc->border_opa = LV_OPA_COVER;
   23185:	c6 42 1c ff          	movb   $0xff,0x1c(%rdx)
    dsc->pattern_recolor = LV_COLOR_BLACK;
   23189:	c7 42 50 00 00 00 ff 	movl   $0xff000000,0x50(%rdx)
   23190:	c6 42 54 ff          	movb   $0xff,0x54(%rdx)
    dsc->pattern_font = LV_THEME_DEFAULT_FONT_NORMAL;
   23194:	48 89 42 48          	mov    %rax,0x48(%rdx)
    dsc->value_opa = LV_OPA_COVER;
   23198:	c6 42 68 ff          	movb   $0xff,0x68(%rdx)
    dsc->value_font = LV_THEME_DEFAULT_FONT_NORMAL;
   2319c:	48 89 42 60          	mov    %rax,0x60(%rdx)
    dsc->shadow_opa = LV_OPA_COVER;
   231a0:	c6 42 38 ff          	movb   $0xff,0x38(%rdx)
    dsc->border_side = LV_BORDER_SIDE_FULL;
   231a4:	66 c7 42 1a 0f 00    	movw   $0xf,0x1a(%rdx)
}
   231aa:	c3                   	retq   

00000000000231ab <lv_draw_rect>:
{
   231ab:	41 57                	push   %r15
   231ad:	41 56                	push   %r14
   231af:	41 55                	push   %r13
   231b1:	41 54                	push   %r12
   231b3:	55                   	push   %rbp
   231b4:	53                   	push   %rbx
   231b5:	48 81 ec f8 00 00 00 	sub    $0xf8,%rsp
   231bc:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   231c3:	00 00 
   231c5:	48 89 84 24 e8 00 00 	mov    %rax,0xe8(%rsp)
   231cc:	00 
   231cd:	31 c0                	xor    %eax,%eax
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   231cf:	66 8b 47 06          	mov    0x6(%rdi),%ax
   231d3:	48 89 34 24          	mov    %rsi,(%rsp)
   231d7:	ff c0                	inc    %eax
   231d9:	66 2b 47 02          	sub    0x2(%rdi),%ax
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
   231dd:	66 85 c0             	test   %ax,%ax
   231e0:	0f 8e 4b 11 00 00    	jle    24331 <lv_draw_rect+0x1186>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   231e6:	66 8b 47 04          	mov    0x4(%rdi),%ax
   231ea:	48 89 fb             	mov    %rdi,%rbx
   231ed:	ff c0                	inc    %eax
   231ef:	66 2b 07             	sub    (%rdi),%ax
   231f2:	66 85 c0             	test   %ax,%ax
   231f5:	0f 8e 36 11 00 00    	jle    24331 <lv_draw_rect+0x1186>
    if(dsc->bg_opa <= LV_OPA_MIN) return;
   231fb:	8a 42 12             	mov    0x12(%rdx),%al
   231fe:	48 89 d5             	mov    %rdx,%rbp
   23201:	3c 02                	cmp    $0x2,%al
   23203:	88 44 24 10          	mov    %al,0x10(%rsp)
   23207:	0f 86 d0 06 00 00    	jbe    238dd <lv_draw_rect+0x732>
    if(dsc->border_width > 1 && dsc->border_opa >= LV_OPA_MAX && dsc->radius != 0) {
   2320d:	66 83 7a 18 01       	cmpw   $0x1,0x18(%rdx)
   23212:	48 8b 07             	mov    (%rdi),%rax
   23215:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
   2321a:	7e 5c                	jle    23278 <lv_draw_rect+0xcd>
   2321c:	80 7a 1c fc          	cmpb   $0xfc,0x1c(%rdx)
   23220:	76 56                	jbe    23278 <lv_draw_rect+0xcd>
   23222:	66 83 3a 00          	cmpw   $0x0,(%rdx)
   23226:	74 50                	je     23278 <lv_draw_rect+0xcd>
        coords_bg.x1 += (dsc->border_side & LV_BORDER_SIDE_LEFT) ? 1 : 0;
   23228:	0f bf 52 1a          	movswl 0x1a(%rdx),%edx
        coords_bg.y1 += (dsc->border_side & LV_BORDER_SIDE_TOP) ? 1 : 0;
   2322c:	89 c7                	mov    %eax,%edi
   2322e:	c1 ff 10             	sar    $0x10,%edi
        coords_bg.x1 += (dsc->border_side & LV_BORDER_SIDE_LEFT) ? 1 : 0;
   23231:	89 d1                	mov    %edx,%ecx
   23233:	89 d6                	mov    %edx,%esi
   23235:	c1 f9 02             	sar    $0x2,%ecx
        coords_bg.y2 -= (dsc->border_side & LV_BORDER_SIDE_BOTTOM) ? 1 : 0;
   23238:	83 e6 01             	and    $0x1,%esi
        coords_bg.x1 += (dsc->border_side & LV_BORDER_SIDE_LEFT) ? 1 : 0;
   2323b:	83 e1 01             	and    $0x1,%ecx
   2323e:	01 c1                	add    %eax,%ecx
   23240:	66 89 4c 24 78       	mov    %cx,0x78(%rsp)
        coords_bg.y1 += (dsc->border_side & LV_BORDER_SIDE_TOP) ? 1 : 0;
   23245:	89 d1                	mov    %edx,%ecx
        coords_bg.x2 -= (dsc->border_side & LV_BORDER_SIDE_RIGHT) ? 1 : 0;
   23247:	c1 fa 03             	sar    $0x3,%edx
        coords_bg.y1 += (dsc->border_side & LV_BORDER_SIDE_TOP) ? 1 : 0;
   2324a:	d1 f9                	sar    %ecx
        coords_bg.x2 -= (dsc->border_side & LV_BORDER_SIDE_RIGHT) ? 1 : 0;
   2324c:	83 e2 01             	and    $0x1,%edx
        coords_bg.y1 += (dsc->border_side & LV_BORDER_SIDE_TOP) ? 1 : 0;
   2324f:	83 e1 01             	and    $0x1,%ecx
   23252:	01 f9                	add    %edi,%ecx
   23254:	66 89 4c 24 7a       	mov    %cx,0x7a(%rsp)
        coords_bg.x2 -= (dsc->border_side & LV_BORDER_SIDE_RIGHT) ? 1 : 0;
   23259:	48 89 c1             	mov    %rax,%rcx
        coords_bg.y2 -= (dsc->border_side & LV_BORDER_SIDE_BOTTOM) ? 1 : 0;
   2325c:	48 c1 f8 30          	sar    $0x30,%rax
        coords_bg.x2 -= (dsc->border_side & LV_BORDER_SIDE_RIGHT) ? 1 : 0;
   23260:	48 c1 e1 10          	shl    $0x10,%rcx
        coords_bg.y2 -= (dsc->border_side & LV_BORDER_SIDE_BOTTOM) ? 1 : 0;
   23264:	29 f0                	sub    %esi,%eax
        coords_bg.x2 -= (dsc->border_side & LV_BORDER_SIDE_RIGHT) ? 1 : 0;
   23266:	48 c1 f9 30          	sar    $0x30,%rcx
        coords_bg.y2 -= (dsc->border_side & LV_BORDER_SIDE_BOTTOM) ? 1 : 0;
   2326a:	66 89 44 24 7e       	mov    %ax,0x7e(%rsp)
        coords_bg.x2 -= (dsc->border_side & LV_BORDER_SIDE_RIGHT) ? 1 : 0;
   2326f:	89 cf                	mov    %ecx,%edi
   23271:	29 d7                	sub    %edx,%edi
   23273:	66 89 7c 24 7c       	mov    %di,0x7c(%rsp)
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
   23278:	80 7c 24 10 fd       	cmpb   $0xfd,0x10(%rsp)
   2327d:	76 05                	jbe    23284 <lv_draw_rect+0xd9>
   2327f:	c6 44 24 10 ff       	movb   $0xff,0x10(%rsp)
    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
   23284:	e8 b1 a4 ff ff       	callq  1d73a <_lv_refr_get_disp_refreshing>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   23289:	48 89 c7             	mov    %rax,%rdi
    is_common = _lv_area_intersect(&draw_area, &coords_bg, clip);
   2328c:	4c 8d 7c 24 78       	lea    0x78(%rsp),%r15
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   23291:	e8 6c 1e 00 00       	callq  25102 <lv_disp_get_buf>
    is_common = _lv_area_intersect(&draw_area, &coords_bg, clip);
   23296:	48 8b 14 24          	mov    (%rsp),%rdx
   2329a:	48 8d bc 24 80 00 00 	lea    0x80(%rsp),%rdi
   232a1:	00 
   232a2:	4c 89 fe             	mov    %r15,%rsi
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   232a5:	49 89 c6             	mov    %rax,%r14
    is_common = _lv_area_intersect(&draw_area, &coords_bg, clip);
   232a8:	e8 6f 22 00 00       	callq  2551c <_lv_area_intersect>
    if(is_common == false) return;
   232ad:	84 c0                	test   %al,%al
   232af:	0f 84 28 06 00 00    	je     238dd <lv_draw_rect+0x732>
    draw_area.x1 -= disp_area->x1;
   232b5:	66 41 8b 46 1c       	mov    0x1c(%r14),%ax
    draw_area.x2 -= disp_area->x1;
   232ba:	8b bc 24 84 00 00 00 	mov    0x84(%rsp),%edi
    draw_area.x1 -= disp_area->x1;
   232c1:	8b 94 24 80 00 00 00 	mov    0x80(%rsp),%edx
    draw_area.y1 -= disp_area->y1;
   232c8:	66 41 8b 4e 1e       	mov    0x1e(%r14),%cx
   232cd:	66 29 8c 24 82 00 00 	sub    %cx,0x82(%rsp)
   232d4:	00 
    draw_area.y2 -= disp_area->y1;
   232d5:	66 29 8c 24 86 00 00 	sub    %cx,0x86(%rsp)
   232dc:	00 
    draw_area.x2 -= disp_area->x1;
   232dd:	29 c7                	sub    %eax,%edi
    draw_area.x1 -= disp_area->x1;
   232df:	29 c2                	sub    %eax,%edx
    draw_area.x2 -= disp_area->x1;
   232e1:	89 f8                	mov    %edi,%eax
   232e3:	66 89 bc 24 84 00 00 	mov    %di,0x84(%rsp)
   232ea:	00 
   232eb:	ff c0                	inc    %eax
   232ed:	29 d0                	sub    %edx,%eax
   232ef:	66 89 44 24 2c       	mov    %ax,0x2c(%rsp)
    int32_t draw_area_w = lv_area_get_width(&draw_area);
   232f4:	98                   	cwtl   
    draw_area.x1 -= disp_area->x1;
   232f5:	66 89 94 24 80 00 00 	mov    %dx,0x80(%rsp)
   232fc:	00 
    lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   232fd:	89 c7                	mov    %eax,%edi
    int32_t draw_area_w = lv_area_get_width(&draw_area);
   232ff:	89 44 24 30          	mov    %eax,0x30(%rsp)
    lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   23303:	e8 d6 2e 00 00       	callq  261de <_lv_mem_buf_get>
   23308:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    lv_grad_dir_t grad_dir = dsc->bg_grad_dir;
   2330d:	8a 45 0c             	mov    0xc(%rbp),%al
   23310:	88 44 24 14          	mov    %al,0x14(%rsp)
    if(dsc->bg_color.full == dsc->bg_grad_color.full) grad_dir = LV_GRAD_DIR_NONE;
   23314:	8b 45 08             	mov    0x8(%rbp),%eax
   23317:	39 45 04             	cmp    %eax,0x4(%rbp)
   2331a:	40 8a 7c 24 14       	mov    0x14(%rsp),%dil
   2331f:	b0 00                	mov    $0x0,%al
   23321:	0f 44 f8             	cmove  %eax,%edi
   23324:	40 88 7c 24 14       	mov    %dil,0x14(%rsp)
    uint16_t other_mask_cnt = lv_draw_mask_get_cnt();
   23329:	e8 56 fb ff ff       	callq  22e84 <lv_draw_mask_get_cnt>
   2332e:	0f b6 c0             	movzbl %al,%eax
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   23331:	66 8b 7c 24 7e       	mov    0x7e(%rsp),%di
    if(other_mask_cnt) simple_mode = false;
   23336:	66 85 c0             	test   %ax,%ax
    uint16_t other_mask_cnt = lv_draw_mask_get_cnt();
   23339:	66 89 44 24 54       	mov    %ax,0x54(%rsp)
    if(other_mask_cnt) simple_mode = false;
   2333e:	0f 95 44 24 40       	setne  0x40(%rsp)
    else if(grad_dir == LV_GRAD_DIR_HOR) simple_mode = false;
   23343:	80 7c 24 14 02       	cmpb   $0x2,0x14(%rsp)
   23348:	44 8d 67 01          	lea    0x1(%rdi),%r12d
   2334c:	0f 94 c0             	sete   %al
   2334f:	0b 44 24 40          	or     0x40(%rsp),%eax
   23353:	66 44 2b 64 24 7a    	sub    0x7a(%rsp),%r12w
   23359:	83 f0 01             	xor    $0x1,%eax
    int32_t coords_h = lv_area_get_height(&coords_bg);
   2335c:	45 0f bf e4          	movswl %r12w,%r12d
    else if(grad_dir == LV_GRAD_DIR_HOR) simple_mode = false;
   23360:	88 44 24 52          	mov    %al,0x52(%rsp)
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   23364:	8b 44 24 7c          	mov    0x7c(%rsp),%eax
   23368:	44 8d 40 01          	lea    0x1(%rax),%r8d
   2336c:	44 2b 44 24 78       	sub    0x78(%rsp),%r8d
    int32_t rout = dsc->radius;
   23371:	0f bf 45 00          	movswl 0x0(%rbp),%eax
    int32_t coords_w = lv_area_get_width(&coords_bg);
   23375:	45 0f bf e8          	movswl %r8w,%r13d
    int32_t short_side = LV_MATH_MIN(coords_w, coords_h);
   23379:	45 39 ec             	cmp    %r13d,%r12d
   2337c:	45 0f 4f e5          	cmovg  %r13d,%r12d
    if(rout > short_side >> 1) rout = short_side >> 1;
   23380:	41 d1 fc             	sar    %r12d
   23383:	41 39 c4             	cmp    %eax,%r12d
   23386:	44 0f 4f e0          	cmovg  %eax,%r12d
    if(simple_mode && rout == 0 && (grad_dir == LV_GRAD_DIR_NONE)) {
   2338a:	45 85 e4             	test   %r12d,%r12d
   2338d:	75 45                	jne    233d4 <lv_draw_rect+0x229>
   2338f:	80 7c 24 52 00       	cmpb   $0x0,0x52(%rsp)
   23394:	74 3e                	je     233d4 <lv_draw_rect+0x229>
   23396:	80 7c 24 14 00       	cmpb   $0x0,0x14(%rsp)
    int16_t mask_rout_id = LV_MASK_ID_INV;
   2339b:	66 c7 44 24 38 ff ff 	movw   $0xffff,0x38(%rsp)
    if(simple_mode && rout == 0 && (grad_dir == LV_GRAD_DIR_NONE)) {
   233a2:	75 6f                	jne    23413 <lv_draw_rect+0x268>
        _lv_blend_fill(clip, &coords_bg,
   233a4:	0f b6 45 13          	movzbl 0x13(%rbp),%eax
   233a8:	48 83 ec 08          	sub    $0x8,%rsp
   233ac:	8b 55 04             	mov    0x4(%rbp),%edx
   233af:	41 b8 01 00 00 00    	mov    $0x1,%r8d
   233b5:	31 c9                	xor    %ecx,%ecx
   233b7:	4c 89 fe             	mov    %r15,%rsi
   233ba:	50                   	push   %rax
   233bb:	44 0f b6 4c 24 20    	movzbl 0x20(%rsp),%r9d
   233c1:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   233c6:	e8 82 bb ff ff       	callq  1ef4d <_lv_blend_fill>
   233cb:	41 59                	pop    %r9
   233cd:	41 5a                	pop    %r10
   233cf:	e9 f5 04 00 00       	jmpq   238c9 <lv_draw_rect+0x71e>
        if(rout > 0) {
   233d4:	45 85 e4             	test   %r12d,%r12d
    int16_t mask_rout_id = LV_MASK_ID_INV;
   233d7:	66 c7 44 24 38 ff ff 	movw   $0xffff,0x38(%rsp)
        if(rout > 0) {
   233de:	7e 33                	jle    23413 <lv_draw_rect+0x268>
            lv_draw_mask_radius_init(&mask_rout_param, &coords_bg, rout, false);
   233e0:	4c 8d bc 24 c0 00 00 	lea    0xc0(%rsp),%r15
   233e7:	00 
   233e8:	48 8d 74 24 78       	lea    0x78(%rsp),%rsi
   233ed:	31 c9                	xor    %ecx,%ecx
   233ef:	44 89 e2             	mov    %r12d,%edx
   233f2:	44 89 44 24 18       	mov    %r8d,0x18(%rsp)
   233f7:	4c 89 ff             	mov    %r15,%rdi
   233fa:	e8 1a fc ff ff       	callq  23019 <lv_draw_mask_radius_init>
            mask_rout_id = lv_draw_mask_add(&mask_rout_param, NULL);
   233ff:	31 f6                	xor    %esi,%esi
   23401:	4c 89 ff             	mov    %r15,%rdi
   23404:	e8 57 f9 ff ff       	callq  22d60 <lv_draw_mask_add>
   23409:	44 8b 44 24 18       	mov    0x18(%rsp),%r8d
   2340e:	66 89 44 24 38       	mov    %ax,0x38(%rsp)
        if(grad_dir == LV_GRAD_DIR_HOR) {
   23413:	80 7c 24 14 02       	cmpb   $0x2,0x14(%rsp)
        lv_color_t grad_color = dsc->bg_color;
   23418:	8b 45 04             	mov    0x4(%rbp),%eax
        lv_color_t * grad_map = NULL;
   2341b:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
   23422:	00 00 
        lv_color_t grad_color = dsc->bg_color;
   23424:	89 44 24 18          	mov    %eax,0x18(%rsp)
        if(grad_dir == LV_GRAD_DIR_HOR) {
   23428:	75 35                	jne    2345f <lv_draw_rect+0x2b4>
            grad_map = _lv_mem_buf_get(coords_w * sizeof(lv_color_t));
   2342a:	49 0f bf f8          	movswq %r8w,%rdi
   2342e:	c1 e7 02             	shl    $0x2,%edi
   23431:	e8 a8 2d 00 00       	callq  261de <_lv_mem_buf_get>
   23436:	45 31 db             	xor    %r11d,%r11d
   23439:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
            for(i = 0; i < coords_w; i++) {
   2343e:	45 39 dd             	cmp    %r11d,%r13d
   23441:	7e 1c                	jle    2345f <lv_draw_rect+0x2b4>
                grad_map[i] = grad_get(dsc, coords_w, i);
   23443:	44 89 da             	mov    %r11d,%edx
   23446:	48 89 ef             	mov    %rbp,%rdi
   23449:	44 89 ee             	mov    %r13d,%esi
   2344c:	e8 26 fc ff ff       	callq  23077 <grad_get>
   23451:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
   23456:	42 89 04 9f          	mov    %eax,(%rdi,%r11,4)
   2345a:	49 ff c3             	inc    %r11
   2345d:	eb df                	jmp    2343e <lv_draw_rect+0x293>
        if(lv_area_get_width(&coords_bg) - 2 * rout > SPLIT_LIMIT) split = true;
   2345f:	8b 54 24 7c          	mov    0x7c(%rsp),%edx
   23463:	8b 4c 24 78          	mov    0x78(%rsp),%ecx
   23467:	43 8d 34 24          	lea    (%r12,%r12,1),%esi
   2346b:	8d 42 01             	lea    0x1(%rdx),%eax
        fill_area.x2 = coords_bg.x2;
   2346e:	66 89 94 24 8c 00 00 	mov    %dx,0x8c(%rsp)
   23475:	00 
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   23476:	66 41 8b 56 1e       	mov    0x1e(%r14),%dx
        fill_area.x1 = coords_bg.x1;
   2347b:	66 89 8c 24 88 00 00 	mov    %cx,0x88(%rsp)
   23482:	00 
   23483:	29 c8                	sub    %ecx,%eax
        if(lv_area_get_width(&coords_bg) - 2 * rout > SPLIT_LIMIT) split = true;
   23485:	98                   	cwtl   
   23486:	29 f0                	sub    %esi,%eax
   23488:	83 f8 32             	cmp    $0x32,%eax
   2348b:	89 44 24 48          	mov    %eax,0x48(%rsp)
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   2348f:	0f bf 84 24 82 00 00 	movswl 0x82(%rsp),%eax
   23496:	00 
        if(lv_area_get_width(&coords_bg) - 2 * rout > SPLIT_LIMIT) split = true;
   23497:	0f 9f 44 24 57       	setg   0x57(%rsp)
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   2349c:	01 c2                	add    %eax,%edx
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   2349e:	89 44 24 28          	mov    %eax,0x28(%rsp)
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   234a2:	66 89 94 24 8a 00 00 	mov    %dx,0x8a(%rsp)
   234a9:	00 
        fill_area.y2 = fill_area.y1;
   234aa:	66 89 94 24 8e 00 00 	mov    %dx,0x8e(%rsp)
   234b1:	00 
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   234b2:	0f bf 84 24 86 00 00 	movswl 0x86(%rsp),%eax
   234b9:	00 
   234ba:	39 44 24 28          	cmp    %eax,0x28(%rsp)
   234be:	0f 8f a1 02 00 00    	jg     23765 <lv_draw_rect+0x5ba>
            if(y > coords_bg.y1 + rout + 1 &&
   234c4:	0f bf 44 24 7a       	movswl 0x7a(%rsp),%eax
            int32_t y = h + vdb->area.y1;
   234c9:	45 0f bf 6e 1e       	movswl 0x1e(%r14),%r13d
   234ce:	44 03 6c 24 28       	add    0x28(%rsp),%r13d
            if(y > coords_bg.y1 + rout + 1 &&
   234d3:	41 8d 44 04 01       	lea    0x1(%r12,%rax,1),%eax
   234d8:	41 39 c5             	cmp    %eax,%r13d
   234db:	7e 16                	jle    234f3 <lv_draw_rect+0x348>
               y < coords_bg.y2 - rout - 1) {
   234dd:	0f bf 44 24 7e       	movswl 0x7e(%rsp),%eax
   234e2:	44 29 e0             	sub    %r12d,%eax
   234e5:	ff c8                	dec    %eax
            if(y > coords_bg.y1 + rout + 1 &&
   234e7:	41 39 c5             	cmp    %eax,%r13d
   234ea:	7d 07                	jge    234f3 <lv_draw_rect+0x348>
                if(simple_mode == false) {
   234ec:	80 7c 24 52 00       	cmpb   $0x0,0x52(%rsp)
   234f1:	75 4f                	jne    23542 <lv_draw_rect+0x397>
                _lv_memset(mask_buf, opa, draw_area_w);
   234f3:	48 0f bf 4c 24 2c    	movswq 0x2c(%rsp),%rcx
   234f9:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
            opa2 = opa;
   234fe:	41 bf ff 00 00 00    	mov    $0xff,%r15d
   23504:	8a 44 24 10          	mov    0x10(%rsp),%al
   23508:	f3 aa                	rep stos %al,%es:(%rdi)
                mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
   2350a:	8b 54 24 28          	mov    0x28(%rsp),%edx
   2350e:	8b b4 24 80 00 00 00 	mov    0x80(%rsp),%esi
   23515:	66 41 03 56 1e       	add    0x1e(%r14),%dx
   2351a:	41 03 76 1c          	add    0x1c(%r14),%esi
   2351e:	8b 4c 24 30          	mov    0x30(%rsp),%ecx
   23522:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   23527:	0f bf d2             	movswl %dx,%edx
   2352a:	0f bf f6             	movswl %si,%esi
   2352d:	e8 92 f8 ff ff       	callq  22dc4 <lv_draw_mask_apply>
            opa2 = opa;
   23532:	3c 02                	cmp    $0x2,%al
                mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
   23534:	41 88 c3             	mov    %al,%r11b
            opa2 = opa;
   23537:	0f b6 44 24 10       	movzbl 0x10(%rsp),%eax
   2353c:	44 0f 45 f8          	cmovne %eax,%r15d
   23540:	eb 09                	jmp    2354b <lv_draw_rect+0x3a0>
   23542:	44 0f b6 7c 24 10    	movzbl 0x10(%rsp),%r15d
                mask_res = LV_DRAW_MASK_RES_FULL_COVER;
   23548:	41 b3 01             	mov    $0x1,%r11b
            if(grad_dir == LV_GRAD_DIR_VER) {
   2354b:	80 7c 24 14 01       	cmpb   $0x1,0x14(%rsp)
   23550:	75 26                	jne    23578 <lv_draw_rect+0x3cd>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   23552:	66 8b 7c 24 7e       	mov    0x7e(%rsp),%di
                grad_color = grad_get(dsc, lv_area_get_height(&coords_bg), y - coords_bg.y1);
   23557:	66 8b 44 24 7a       	mov    0x7a(%rsp),%ax
   2355c:	44 89 ea             	mov    %r13d,%edx
   2355f:	8d 77 01             	lea    0x1(%rdi),%esi
   23562:	29 c2                	sub    %eax,%edx
   23564:	48 89 ef             	mov    %rbp,%rdi
   23567:	0f bf d2             	movswl %dx,%edx
   2356a:	29 c6                	sub    %eax,%esi
   2356c:	0f bf f6             	movswl %si,%esi
   2356f:	e8 03 fb ff ff       	callq  23077 <grad_get>
   23574:	89 44 24 18          	mov    %eax,0x18(%rsp)
            if(simple_mode && split &&
   23578:	80 7c 24 57 00       	cmpb   $0x0,0x57(%rsp)
   2357d:	0f 84 50 01 00 00    	je     236d3 <lv_draw_rect+0x528>
   23583:	80 7c 24 52 00       	cmpb   $0x0,0x52(%rsp)
   23588:	0f 84 45 01 00 00    	je     236d3 <lv_draw_rect+0x528>
               (y < coords_bg.y1 + rout + 1 ||
   2358e:	0f bf 44 24 7a       	movswl 0x7a(%rsp),%eax
   23593:	41 8d 44 04 01       	lea    0x1(%r12,%rax,1),%eax
            if(simple_mode && split &&
   23598:	41 39 c5             	cmp    %eax,%r13d
   2359b:	7c 13                	jl     235b0 <lv_draw_rect+0x405>
                y > coords_bg.y2 - rout - 1)) {
   2359d:	0f bf 44 24 7e       	movswl 0x7e(%rsp),%eax
   235a2:	44 29 e0             	sub    %r12d,%eax
   235a5:	ff c8                	dec    %eax
               (y < coords_bg.y1 + rout + 1 ||
   235a7:	41 39 c5             	cmp    %eax,%r13d
   235aa:	0f 8e 23 01 00 00    	jle    236d3 <lv_draw_rect+0x528>
                fill_area2.x1 = coords_bg.x1;
   235b0:	8b 44 24 78          	mov    0x78(%rsp),%eax
                _lv_blend_fill(clip, &fill_area2,
   235b4:	4c 8d 94 24 90 00 00 	lea    0x90(%rsp),%r10
   235bb:	00 
   235bc:	48 83 ec 08          	sub    $0x8,%rsp
   235c0:	45 0f b6 eb          	movzbl %r11b,%r13d
   235c4:	45 89 f9             	mov    %r15d,%r9d
   235c7:	45 89 e8             	mov    %r13d,%r8d
   235ca:	4c 89 d6             	mov    %r10,%rsi
                fill_area2.x1 = coords_bg.x1;
   235cd:	66 89 84 24 98 00 00 	mov    %ax,0x98(%rsp)
   235d4:	00 
                fill_area2.x2 = coords_bg.x1 + rout - 1;
   235d5:	42 8d 44 20 ff       	lea    -0x1(%rax,%r12,1),%eax
   235da:	66 89 84 24 9c 00 00 	mov    %ax,0x9c(%rsp)
   235e1:	00 
                fill_area2.y1 = fill_area.y1;
   235e2:	66 8b 84 24 92 00 00 	mov    0x92(%rsp),%ax
   235e9:	00 
   235ea:	66 89 84 24 9a 00 00 	mov    %ax,0x9a(%rsp)
   235f1:	00 
                fill_area2.y2 = fill_area.y2;
   235f2:	66 8b 84 24 96 00 00 	mov    0x96(%rsp),%ax
   235f9:	00 
   235fa:	66 89 84 24 9e 00 00 	mov    %ax,0x9e(%rsp)
   23601:	00 
                _lv_blend_fill(clip, &fill_area2,
   23602:	0f b6 45 13          	movzbl 0x13(%rbp),%eax
   23606:	50                   	push   %rax
   23607:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   2360c:	8b 54 24 28          	mov    0x28(%rsp),%edx
   23610:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   23615:	4c 89 54 24 68       	mov    %r10,0x68(%rsp)
   2361a:	e8 2e b9 ff ff       	callq  1ef4d <_lv_blend_fill>
   2361f:	5f                   	pop    %rdi
   23620:	41 58                	pop    %r8
                if(grad_dir == LV_GRAD_DIR_VER) {
   23622:	80 7c 24 14 01       	cmpb   $0x1,0x14(%rsp)
   23627:	4c 8b 54 24 58       	mov    0x58(%rsp),%r10
   2362c:	75 4b                	jne    23679 <lv_draw_rect+0x4ce>
                    fill_area2.x1 = coords_bg.x1 + rout;
   2362e:	44 89 e0             	mov    %r12d,%eax
   23631:	03 44 24 78          	add    0x78(%rsp),%eax
                    _lv_blend_fill(clip, &fill_area2,
   23635:	48 83 ec 08          	sub    $0x8,%rsp
   23639:	31 c9                	xor    %ecx,%ecx
   2363b:	4c 89 d6             	mov    %r10,%rsi
   2363e:	41 b8 01 00 00 00    	mov    $0x1,%r8d
                    fill_area2.x1 = coords_bg.x1 + rout;
   23644:	66 89 84 24 98 00 00 	mov    %ax,0x98(%rsp)
   2364b:	00 
                    fill_area2.x2 = coords_bg.x2 - rout;
   2364c:	8b 84 24 84 00 00 00 	mov    0x84(%rsp),%eax
   23653:	44 29 e0             	sub    %r12d,%eax
   23656:	66 89 84 24 9c 00 00 	mov    %ax,0x9c(%rsp)
   2365d:	00 
                    _lv_blend_fill(clip, &fill_area2,
   2365e:	0f b6 45 13          	movzbl 0x13(%rbp),%eax
   23662:	50                   	push   %rax
   23663:	44 0f b6 4c 24 20    	movzbl 0x20(%rsp),%r9d
   23669:	8b 54 24 28          	mov    0x28(%rsp),%edx
   2366d:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   23672:	e8 d6 b8 ff ff       	callq  1ef4d <_lv_blend_fill>
   23677:	59                   	pop    %rcx
   23678:	5e                   	pop    %rsi
                fill_area2.x1 = coords_bg.x2 - rout + 1;
   23679:	0f bf 44 24 7c       	movswl 0x7c(%rsp),%eax
                int32_t mask_ofs = (coords_bg.x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
   2367e:	0f bf 8c 24 80 00 00 	movswl 0x80(%rsp),%ecx
   23685:	00 
                _lv_blend_fill(clip, &fill_area2,
   23686:	48 8d b4 24 90 00 00 	lea    0x90(%rsp),%rsi
   2368d:	00 
   2368e:	45 89 f9             	mov    %r15d,%r9d
   23691:	45 89 e8             	mov    %r13d,%r8d
                fill_area2.x1 = coords_bg.x2 - rout + 1;
   23694:	8d 50 01             	lea    0x1(%rax),%edx
                fill_area2.x2 = coords_bg.x2;
   23697:	66 89 84 24 94 00 00 	mov    %ax,0x94(%rsp)
   2369e:	00 
                int32_t mask_ofs = (coords_bg.x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
   2369f:	44 29 e0             	sub    %r12d,%eax
   236a2:	ff c0                	inc    %eax
                fill_area2.x1 = coords_bg.x2 - rout + 1;
   236a4:	44 29 e2             	sub    %r12d,%edx
   236a7:	66 89 94 24 90 00 00 	mov    %dx,0x90(%rsp)
   236ae:	00 
                int32_t mask_ofs = (coords_bg.x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
   236af:	41 0f bf 56 1c       	movswl 0x1c(%r14),%edx
   236b4:	01 ca                	add    %ecx,%edx
                _lv_blend_fill(clip, &fill_area2,
   236b6:	b9 00 00 00 00       	mov    $0x0,%ecx
   236bb:	29 d0                	sub    %edx,%eax
   236bd:	0f 49 c8             	cmovns %eax,%ecx
   236c0:	0f b6 45 13          	movzbl 0x13(%rbp),%eax
   236c4:	48 83 ec 08          	sub    $0x8,%rsp
   236c8:	48 63 c9             	movslq %ecx,%rcx
   236cb:	48 03 4c 24 10       	add    0x10(%rsp),%rcx
   236d0:	50                   	push   %rax
   236d1:	eb 69                	jmp    2373c <lv_draw_rect+0x591>
                if(grad_dir == LV_GRAD_DIR_HOR) {
   236d3:	80 7c 24 14 02       	cmpb   $0x2,0x14(%rsp)
   236d8:	75 2f                	jne    23709 <lv_draw_rect+0x55e>
                    _lv_blend_map(clip, &fill_area, grad_map, mask_buf, mask_res, opa2, dsc->bg_blend_mode);
   236da:	0f b6 45 13          	movzbl 0x13(%rbp),%eax
   236de:	48 8d b4 24 88 00 00 	lea    0x88(%rsp),%rsi
   236e5:	00 
   236e6:	48 83 ec 08          	sub    $0x8,%rsp
   236ea:	45 0f b6 cf          	movzbl %r15b,%r9d
   236ee:	45 0f b6 c3          	movzbl %r11b,%r8d
   236f2:	50                   	push   %rax
   236f3:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   236f8:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
   236fd:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   23702:	e8 1a be ff ff       	callq  1f521 <_lv_blend_map>
   23707:	eb 41                	jmp    2374a <lv_draw_rect+0x59f>
                else if(grad_dir == LV_GRAD_DIR_VER) {
   23709:	80 7c 24 14 01       	cmpb   $0x1,0x14(%rsp)
   2370e:	74 0e                	je     2371e <lv_draw_rect+0x573>
                else if(other_mask_cnt != 0 || !split) {
   23710:	83 7c 24 48 32       	cmpl   $0x32,0x48(%rsp)
   23715:	7e 07                	jle    2371e <lv_draw_rect+0x573>
   23717:	80 7c 24 40 00       	cmpb   $0x0,0x40(%rsp)
   2371c:	74 2e                	je     2374c <lv_draw_rect+0x5a1>
                    _lv_blend_fill(clip, &fill_area,
   2371e:	0f b6 45 13          	movzbl 0x13(%rbp),%eax
   23722:	48 8d b4 24 88 00 00 	lea    0x88(%rsp),%rsi
   23729:	00 
   2372a:	48 83 ec 08          	sub    $0x8,%rsp
   2372e:	45 0f b6 cf          	movzbl %r15b,%r9d
   23732:	45 0f b6 c3          	movzbl %r11b,%r8d
   23736:	50                   	push   %rax
   23737:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   2373c:	8b 54 24 28          	mov    0x28(%rsp),%edx
   23740:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   23745:	e8 03 b8 ff ff       	callq  1ef4d <_lv_blend_fill>
   2374a:	58                   	pop    %rax
   2374b:	5a                   	pop    %rdx
            fill_area.y1++;
   2374c:	66 ff 84 24 8a 00 00 	incw   0x8a(%rsp)
   23753:	00 
            fill_area.y2++;
   23754:	66 ff 84 24 8e 00 00 	incw   0x8e(%rsp)
   2375b:	00 
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   2375c:	ff 44 24 28          	incl   0x28(%rsp)
   23760:	e9 4d fd ff ff       	jmpq   234b2 <lv_draw_rect+0x307>
        if(grad_dir == LV_GRAD_DIR_NONE && other_mask_cnt == 0 && split) {
   23765:	80 7c 24 14 00       	cmpb   $0x0,0x14(%rsp)
   2376a:	0f 94 c0             	sete   %al
   2376d:	84 44 24 57          	test   %al,0x57(%rsp)
   23771:	0f 84 40 01 00 00    	je     238b7 <lv_draw_rect+0x70c>
   23777:	66 83 7c 24 54 00    	cmpw   $0x0,0x54(%rsp)
   2377d:	0f 85 34 01 00 00    	jne    238b7 <lv_draw_rect+0x70c>
            fill_area.x1 = coords_bg.x1 + rout;
   23783:	44 89 e0             	mov    %r12d,%eax
   23786:	03 44 24 78          	add    0x78(%rsp),%eax
            _lv_blend_fill(clip, &fill_area,
   2378a:	44 0f b6 6c 24 10    	movzbl 0x10(%rsp),%r13d
   23790:	4c 8d b4 24 88 00 00 	lea    0x88(%rsp),%r14
   23797:	00 
   23798:	48 83 ec 08          	sub    $0x8,%rsp
   2379c:	8b 55 04             	mov    0x4(%rbp),%edx
   2379f:	31 c9                	xor    %ecx,%ecx
   237a1:	41 b8 01 00 00 00    	mov    $0x1,%r8d
   237a7:	4c 89 f6             	mov    %r14,%rsi
            fill_area.x1 = coords_bg.x1 + rout;
   237aa:	66 89 84 24 90 00 00 	mov    %ax,0x90(%rsp)
   237b1:	00 
            fill_area.x2 = coords_bg.x2 - rout;
   237b2:	8b 84 24 84 00 00 00 	mov    0x84(%rsp),%eax
            _lv_blend_fill(clip, &fill_area,
   237b9:	45 89 e9             	mov    %r13d,%r9d
            fill_area.x2 = coords_bg.x2 - rout;
   237bc:	44 29 e0             	sub    %r12d,%eax
   237bf:	66 89 84 24 94 00 00 	mov    %ax,0x94(%rsp)
   237c6:	00 
            fill_area.y1 = coords_bg.y1;
   237c7:	66 8b 84 24 82 00 00 	mov    0x82(%rsp),%ax
   237ce:	00 
   237cf:	66 89 84 24 92 00 00 	mov    %ax,0x92(%rsp)
   237d6:	00 
            fill_area.y2 = coords_bg.y1 + rout;
   237d7:	44 01 e0             	add    %r12d,%eax
   237da:	66 89 84 24 96 00 00 	mov    %ax,0x96(%rsp)
   237e1:	00 
            _lv_blend_fill(clip, &fill_area,
   237e2:	0f b6 45 13          	movzbl 0x13(%rbp),%eax
   237e6:	50                   	push   %rax
   237e7:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   237ec:	e8 5c b7 ff ff       	callq  1ef4d <_lv_blend_fill>
   237f1:	41 5f                	pop    %r15
   237f3:	58                   	pop    %rax
            fill_area.y1 = coords_bg.y2 - rout;
   237f4:	66 8b 54 24 7e       	mov    0x7e(%rsp),%dx
            if(fill_area.y1 <= fill_area.y2) fill_area.y1 = fill_area.y2 + 1;    /*Avoid overdrawing the last line*/
   237f9:	66 8b 84 24 8e 00 00 	mov    0x8e(%rsp),%ax
   23800:	00 
            fill_area.y1 = coords_bg.y2 - rout;
   23801:	89 d1                	mov    %edx,%ecx
   23803:	44 29 e1             	sub    %r12d,%ecx
            if(fill_area.y1 <= fill_area.y2) fill_area.y1 = fill_area.y2 + 1;    /*Avoid overdrawing the last line*/
   23806:	66 39 c1             	cmp    %ax,%cx
            fill_area.y1 = coords_bg.y2 - rout;
   23809:	66 89 8c 24 8a 00 00 	mov    %cx,0x8a(%rsp)
   23810:	00 
            if(fill_area.y1 <= fill_area.y2) fill_area.y1 = fill_area.y2 + 1;    /*Avoid overdrawing the last line*/
   23811:	7f 0a                	jg     2381d <lv_draw_rect+0x672>
   23813:	ff c0                	inc    %eax
   23815:	66 89 84 24 8a 00 00 	mov    %ax,0x8a(%rsp)
   2381c:	00 
            _lv_blend_fill(clip, &fill_area,
   2381d:	0f b6 45 13          	movzbl 0x13(%rbp),%eax
            fill_area.y2 = coords_bg.y2;
   23821:	66 89 94 24 8e 00 00 	mov    %dx,0x8e(%rsp)
   23828:	00 
            _lv_blend_fill(clip, &fill_area,
   23829:	48 83 ec 08          	sub    $0x8,%rsp
   2382d:	8b 55 04             	mov    0x4(%rbp),%edx
   23830:	45 89 e9             	mov    %r13d,%r9d
   23833:	41 b8 01 00 00 00    	mov    $0x1,%r8d
   23839:	31 c9                	xor    %ecx,%ecx
   2383b:	4c 89 f6             	mov    %r14,%rsi
   2383e:	50                   	push   %rax
   2383f:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   23844:	e8 04 b7 ff ff       	callq  1ef4d <_lv_blend_fill>
            fill_area.x1 = coords_bg.x1;
   23849:	8b 84 24 88 00 00 00 	mov    0x88(%rsp),%eax
            _lv_blend_fill(clip, &fill_area,
   23850:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   23855:	45 89 e9             	mov    %r13d,%r9d
   23858:	8b 55 04             	mov    0x4(%rbp),%edx
   2385b:	41 b8 01 00 00 00    	mov    $0x1,%r8d
   23861:	31 c9                	xor    %ecx,%ecx
   23863:	4c 89 f6             	mov    %r14,%rsi
            fill_area.x1 = coords_bg.x1;
   23866:	66 89 84 24 98 00 00 	mov    %ax,0x98(%rsp)
   2386d:	00 
            fill_area.x2 = coords_bg.x2;
   2386e:	8b 84 24 8c 00 00 00 	mov    0x8c(%rsp),%eax
   23875:	66 89 84 24 9c 00 00 	mov    %ax,0x9c(%rsp)
   2387c:	00 
            fill_area.y1 = coords_bg.y1 + rout + 1;
   2387d:	66 8b 84 24 8a 00 00 	mov    0x8a(%rsp),%ax
   23884:	00 
   23885:	42 8d 44 20 01       	lea    0x1(%rax,%r12,1),%eax
            fill_area.y2 = coords_bg.y2 - rout - 1;
   2388a:	41 f7 d4             	not    %r12d
   2388d:	66 44 03 a4 24 8e 00 	add    0x8e(%rsp),%r12w
   23894:	00 00 
            fill_area.y1 = coords_bg.y1 + rout + 1;
   23896:	66 89 84 24 9a 00 00 	mov    %ax,0x9a(%rsp)
   2389d:	00 
            _lv_blend_fill(clip, &fill_area,
   2389e:	0f b6 45 13          	movzbl 0x13(%rbp),%eax
            fill_area.y2 = coords_bg.y2 - rout - 1;
   238a2:	66 44 89 a4 24 9e 00 	mov    %r12w,0x9e(%rsp)
   238a9:	00 00 
            _lv_blend_fill(clip, &fill_area,
   238ab:	89 04 24             	mov    %eax,(%rsp)
   238ae:	e8 9a b6 ff ff       	callq  1ef4d <_lv_blend_fill>
   238b3:	41 5b                	pop    %r11
   238b5:	41 5c                	pop    %r12
        if(grad_map) _lv_mem_buf_release(grad_map);
   238b7:	48 83 7c 24 20 00    	cmpq   $0x0,0x20(%rsp)
   238bd:	74 0a                	je     238c9 <lv_draw_rect+0x71e>
   238bf:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
   238c4:	e8 04 2a 00 00       	callq  262cd <_lv_mem_buf_release>
    lv_draw_mask_remove_id(mask_rout_id);
   238c9:	0f bf 7c 24 38       	movswl 0x38(%rsp),%edi
   238ce:	e8 52 f5 ff ff       	callq  22e25 <lv_draw_mask_remove_id>
    _lv_mem_buf_release(mask_buf);
   238d3:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   238d8:	e8 f0 29 00 00       	callq  262cd <_lv_mem_buf_release>
    if(dsc->border_opa <= LV_OPA_MIN) return;
   238dd:	8a 45 1c             	mov    0x1c(%rbp),%al
   238e0:	3c 02                	cmp    $0x2,%al
   238e2:	88 44 24 10          	mov    %al,0x10(%rsp)
   238e6:	0f 86 45 0a 00 00    	jbe    24331 <lv_draw_rect+0x1186>
    if(dsc->border_width == 0) return;
   238ec:	8b 55 18             	mov    0x18(%rbp),%edx
   238ef:	66 85 d2             	test   %dx,%dx
   238f2:	0f 84 39 0a 00 00    	je     24331 <lv_draw_rect+0x1186>
    if(dsc->border_side == LV_BORDER_SIDE_NONE) return;
   238f8:	66 8b 4d 1a          	mov    0x1a(%rbp),%cx
   238fc:	66 85 c9             	test   %cx,%cx
   238ff:	0f 84 2c 0a 00 00    	je     24331 <lv_draw_rect+0x1186>
    if(dsc->border_post) return;
   23905:	f6 45 1e 01          	testb  $0x1,0x1e(%rbp)
   23909:	0f 85 22 0a 00 00    	jne    24331 <lv_draw_rect+0x1186>
   2390f:	66 8b 7b 06          	mov    0x6(%rbx),%di
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   23913:	66 8b 43 04          	mov    0x4(%rbx),%ax
    area_inner.x1 += ((dsc->border_side & LV_BORDER_SIDE_LEFT) ? dsc->border_width : - (dsc->border_width + rout));
   23917:	89 d6                	mov    %edx,%esi
    int32_t rout = dsc->radius;
   23919:	44 0f bf 75 00       	movswl 0x0(%rbp),%r14d
   2391e:	ff c0                	inc    %eax
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   23920:	44 8d 47 01          	lea    0x1(%rdi),%r8d
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   23924:	66 2b 03             	sub    (%rbx),%ax
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   23927:	66 44 2b 43 02       	sub    0x2(%rbx),%r8w
   2392c:	89 d7                	mov    %edx,%edi
    int32_t coords_w = lv_area_get_width(coords);
   2392e:	98                   	cwtl   
    int32_t coords_h = lv_area_get_height(coords);
   2392f:	45 0f bf c0          	movswl %r8w,%r8d
    int32_t short_side = LV_MATH_MIN(coords_w, coords_h);
   23933:	44 39 c0             	cmp    %r8d,%eax
   23936:	44 0f 4e c0          	cmovle %eax,%r8d
   2393a:	48 8b 03             	mov    (%rbx),%rax
    if(rout > short_side >> 1) rout = short_side >> 1;
   2393d:	41 d1 f8             	sar    %r8d
   23940:	45 39 f0             	cmp    %r14d,%r8d
   23943:	45 0f 4f c6          	cmovg  %r14d,%r8d
    area_inner.x1 += ((dsc->border_side & LV_BORDER_SIDE_LEFT) ? dsc->border_width : - (dsc->border_width + rout));
   23947:	f6 c1 04             	test   $0x4,%cl
   2394a:	45 89 c7             	mov    %r8d,%r15d
   2394d:	75 06                	jne    23955 <lv_draw_rect+0x7aa>
   2394f:	42 8d 34 02          	lea    (%rdx,%r8,1),%esi
   23953:	f7 de                	neg    %esi
   23955:	01 c6                	add    %eax,%esi
    area_inner.x2 -= ((dsc->border_side & LV_BORDER_SIDE_RIGHT) ? dsc->border_width : - (dsc->border_width + rout));
   23957:	41 89 d2             	mov    %edx,%r10d
    area_inner.x1 += ((dsc->border_side & LV_BORDER_SIDE_LEFT) ? dsc->border_width : - (dsc->border_width + rout));
   2395a:	66 89 74 24 70       	mov    %si,0x70(%rsp)
    area_inner.x2 -= ((dsc->border_side & LV_BORDER_SIDE_RIGHT) ? dsc->border_width : - (dsc->border_width + rout));
   2395f:	48 89 c6             	mov    %rax,%rsi
   23962:	48 c1 e6 10          	shl    $0x10,%rsi
   23966:	48 c1 fe 30          	sar    $0x30,%rsi
   2396a:	f6 c1 08             	test   $0x8,%cl
   2396d:	75 07                	jne    23976 <lv_draw_rect+0x7cb>
   2396f:	46 8d 14 3a          	lea    (%rdx,%r15,1),%r10d
   23973:	41 f7 da             	neg    %r10d
   23976:	44 29 d6             	sub    %r10d,%esi
    area_inner.y1 += ((dsc->border_side & LV_BORDER_SIDE_TOP) ? dsc->border_width : - (dsc->border_width + rout));
   23979:	41 89 c2             	mov    %eax,%r10d
   2397c:	41 c1 fa 10          	sar    $0x10,%r10d
   23980:	f6 c1 02             	test   $0x2,%cl
    area_inner.x2 -= ((dsc->border_side & LV_BORDER_SIDE_RIGHT) ? dsc->border_width : - (dsc->border_width + rout));
   23983:	66 89 74 24 74       	mov    %si,0x74(%rsp)
    area_inner.y1 += ((dsc->border_side & LV_BORDER_SIDE_TOP) ? dsc->border_width : - (dsc->border_width + rout));
   23988:	89 d6                	mov    %edx,%esi
   2398a:	75 06                	jne    23992 <lv_draw_rect+0x7e7>
   2398c:	42 8d 34 3a          	lea    (%rdx,%r15,1),%esi
   23990:	f7 de                	neg    %esi
   23992:	44 01 d6             	add    %r10d,%esi
    area_inner.y2 -= ((dsc->border_side & LV_BORDER_SIDE_BOTTOM) ? dsc->border_width : - (dsc->border_width + rout));
   23995:	48 c1 f8 30          	sar    $0x30,%rax
   23999:	f6 c1 01             	test   $0x1,%cl
    area_inner.y1 += ((dsc->border_side & LV_BORDER_SIDE_TOP) ? dsc->border_width : - (dsc->border_width + rout));
   2399c:	66 89 74 24 72       	mov    %si,0x72(%rsp)
    area_inner.y2 -= ((dsc->border_side & LV_BORDER_SIDE_BOTTOM) ? dsc->border_width : - (dsc->border_width + rout));
   239a1:	75 07                	jne    239aa <lv_draw_rect+0x7ff>
   239a3:	44 01 fa             	add    %r15d,%edx
   239a6:	89 d7                	mov    %edx,%edi
   239a8:	f7 df                	neg    %edi
   239aa:	29 f8                	sub    %edi,%eax
    if(dsc->border_side == LV_BORDER_SIDE_FULL) {
   239ac:	66 83 f9 0f          	cmp    $0xf,%cx
    area_inner.y2 -= ((dsc->border_side & LV_BORDER_SIDE_BOTTOM) ? dsc->border_width : - (dsc->border_width + rout));
   239b0:	66 89 44 24 76       	mov    %ax,0x76(%rsp)
    if(dsc->border_side == LV_BORDER_SIDE_FULL) {
   239b5:	0f 85 ac 06 00 00    	jne    24067 <lv_draw_rect+0xebc>
   239bb:	8b 45 14             	mov    0x14(%rbp),%eax
        draw_full_border(&area_inner, coords, clip, dsc->radius, dsc->border_color, dsc->border_opa, dsc->border_blend_mode);
   239be:	44 0f b6 7d 1d       	movzbl 0x1d(%rbp),%r15d
   239c3:	89 44 24 08          	mov    %eax,0x8(%rsp)
#endif

static void draw_full_border(const lv_area_t * area_inner, const lv_area_t * area_outer, const lv_area_t * clip,
                             lv_coord_t radius, lv_color_t color, lv_opa_t opa, lv_blend_mode_t blend_mode)
{
    uint8_t other_mask_cnt = lv_draw_mask_get_cnt();
   239c7:	e8 b8 f4 ff ff       	callq  22e84 <lv_draw_mask_get_cnt>
   239cc:	88 44 24 28          	mov    %al,0x28(%rsp)
    bool simple_mode = true;
    if(other_mask_cnt) simple_mode = false;

    int32_t inner_w = lv_area_get_width(area_inner);
   239d0:	8b 44 24 70          	mov    0x70(%rsp),%eax
   239d4:	44 8b 6c 24 74       	mov    0x74(%rsp),%r13d
    int32_t inner_h = lv_area_get_height(area_inner);
    lv_coord_t border_width = area_outer->x2 - area_inner->x2;
   239d9:	66 8b 6b 04          	mov    0x4(%rbx),%bp
    int32_t inner_w = lv_area_get_width(area_inner);
   239dd:	66 89 44 24 14       	mov    %ax,0x14(%rsp)
    int32_t inner_h = lv_area_get_height(area_inner);
   239e2:	66 8b 44 24 72       	mov    0x72(%rsp),%ax
   239e7:	66 89 44 24 18       	mov    %ax,0x18(%rsp)
   239ec:	66 8b 44 24 76       	mov    0x76(%rsp),%ax
   239f1:	66 89 44 24 20       	mov    %ax,0x20(%rsp)
    if(rin > short_side >> 1) rin = short_side >> 1;

    /*Get the outer area*/
    int32_t rout = rin + border_width;

    int32_t coords_out_w = lv_area_get_width(area_outer);
   239f6:	66 8b 03             	mov    (%rbx),%ax
   239f9:	66 89 44 24 30       	mov    %ax,0x30(%rsp)
    int32_t coords_out_h = lv_area_get_height(area_outer);
   239fe:	66 8b 43 02          	mov    0x2(%rbx),%ax
   23a02:	66 89 44 24 38       	mov    %ax,0x38(%rsp)
   23a07:	66 8b 43 06          	mov    0x6(%rbx),%ax
   23a0b:	66 89 44 24 52       	mov    %ax,0x52(%rsp)
    short_side = LV_MATH_MIN(coords_out_w, coords_out_h);
    if(rout > short_side >> 1) rout = short_side >> 1;

    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
   23a10:	e8 25 9d ff ff       	callq  1d73a <_lv_refr_get_disp_refreshing>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   23a15:	48 89 c7             	mov    %rax,%rdi
   23a18:	e8 e5 16 00 00       	callq  25102 <lv_disp_get_buf>

    /* Get clipped fill area which is the real draw area.
     * It is always the same or inside `fill_area` */
    lv_area_t draw_area;
    bool is_common;
    is_common = _lv_area_intersect(&draw_area, area_outer, clip);
   23a1d:	48 8b 14 24          	mov    (%rsp),%rdx
   23a21:	48 8d 7c 24 78       	lea    0x78(%rsp),%rdi
   23a26:	48 89 de             	mov    %rbx,%rsi
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   23a29:	49 89 c4             	mov    %rax,%r12
    is_common = _lv_area_intersect(&draw_area, area_outer, clip);
   23a2c:	e8 eb 1a 00 00       	callq  2551c <_lv_area_intersect>
    if(is_common == false) return;
   23a31:	84 c0                	test   %al,%al
   23a33:	0f 84 f8 08 00 00    	je     24331 <lv_draw_rect+0x1186>
   23a39:	8b 54 24 20          	mov    0x20(%rsp),%edx
        draw_full_border(&area_inner, coords, clip, dsc->radius, dsc->border_color, dsc->border_opa, dsc->border_blend_mode);
   23a3d:	0f b6 44 24 10       	movzbl 0x10(%rsp),%eax
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   23a42:	41 8d 4d 01          	lea    0x1(%r13),%ecx
   23a46:	2b 4c 24 14          	sub    0x14(%rsp),%ecx

    /* Now `draw_area` has absolute coordinates.
     * Make it relative to `disp_area` to simplify draw to `disp_buf`*/
    draw_area.x1 -= disp_area->x1;
    draw_area.y1 -= disp_area->y1;
    draw_area.x2 -= disp_area->x1;
   23a4a:	8b 7c 24 7c          	mov    0x7c(%rsp),%edi
    draw_area.y1 -= disp_area->y1;
   23a4e:	66 41 8b 74 24 1e    	mov    0x1e(%r12),%si
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   23a54:	ff c2                	inc    %edx
   23a56:	2b 54 24 18          	sub    0x18(%rsp),%edx
        draw_full_border(&area_inner, coords, clip, dsc->radius, dsc->border_color, dsc->border_opa, dsc->border_blend_mode);
   23a5a:	89 44 24 10          	mov    %eax,0x10(%rsp)
    lv_coord_t border_width = area_outer->x2 - area_inner->x2;
   23a5e:	89 e8                	mov    %ebp,%eax
    int32_t inner_w = lv_area_get_width(area_inner);
   23a60:	0f bf c9             	movswl %cx,%ecx
    lv_coord_t border_width = area_outer->x2 - area_inner->x2;
   23a63:	44 29 e8             	sub    %r13d,%eax
   23a66:	66 44 8b 6c 24 52    	mov    0x52(%rsp),%r13w
   23a6c:	66 89 44 24 2c       	mov    %ax,0x2c(%rsp)
    int32_t rout = rin + border_width;
   23a71:	98                   	cwtl   
    int32_t inner_h = lv_area_get_height(area_inner);
   23a72:	0f bf d2             	movswl %dx,%edx
    int32_t rout = rin + border_width;
   23a75:	89 44 24 14          	mov    %eax,0x14(%rsp)
    int32_t short_side = LV_MATH_MIN(inner_w, inner_h);
   23a79:	39 d1                	cmp    %edx,%ecx
   23a7b:	0f 4e d1             	cmovle %ecx,%edx
    if(rin > short_side >> 1) rin = short_side >> 1;
   23a7e:	d1 fa                	sar    %edx
   23a80:	44 39 f2             	cmp    %r14d,%edx
   23a83:	41 0f 4f d6          	cmovg  %r14d,%edx
   23a87:	41 ff c5             	inc    %r13d
   23a8a:	44 2b 6c 24 38       	sub    0x38(%rsp),%r13d
    int32_t rout = rin + border_width;
   23a8f:	8d 0c 02             	lea    (%rdx,%rax,1),%ecx
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   23a92:	8d 45 01             	lea    0x1(%rbp),%eax
   23a95:	2b 44 24 30          	sub    0x30(%rsp),%eax

    int32_t draw_area_w = lv_area_get_width(&draw_area);

    /*Create inner the mask*/
    lv_draw_mask_radius_param_t mask_rin_param;
    lv_draw_mask_radius_init(&mask_rin_param, area_inner, rin, true);
   23a99:	48 8d ac 24 90 00 00 	lea    0x90(%rsp),%rbp
   23aa0:	00 
    int32_t coords_out_h = lv_area_get_height(area_outer);
   23aa1:	45 0f bf ed          	movswl %r13w,%r13d
    int32_t coords_out_w = lv_area_get_width(area_outer);
   23aa5:	98                   	cwtl   
    short_side = LV_MATH_MIN(coords_out_w, coords_out_h);
   23aa6:	44 39 e8             	cmp    %r13d,%eax
   23aa9:	44 0f 4e e8          	cmovle %eax,%r13d
    draw_area.x1 -= disp_area->x1;
   23aad:	66 41 8b 44 24 1c    	mov    0x1c(%r12),%ax
    if(rout > short_side >> 1) rout = short_side >> 1;
   23ab3:	41 d1 fd             	sar    %r13d
   23ab6:	41 39 cd             	cmp    %ecx,%r13d
   23ab9:	44 0f 4f e9          	cmovg  %ecx,%r13d
    draw_area.x1 -= disp_area->x1;
   23abd:	8b 4c 24 78          	mov    0x78(%rsp),%ecx
    draw_area.x2 -= disp_area->x1;
   23ac1:	29 c7                	sub    %eax,%edi
    draw_area.y1 -= disp_area->y1;
   23ac3:	66 29 74 24 7a       	sub    %si,0x7a(%rsp)
    draw_area.y2 -= disp_area->y1;
   23ac8:	66 29 74 24 7e       	sub    %si,0x7e(%rsp)
    lv_draw_mask_radius_init(&mask_rin_param, area_inner, rin, true);
   23acd:	48 8d 74 24 70       	lea    0x70(%rsp),%rsi
    draw_area.x2 -= disp_area->x1;
   23ad2:	66 89 7c 24 7c       	mov    %di,0x7c(%rsp)
    draw_area.x1 -= disp_area->x1;
   23ad7:	29 c1                	sub    %eax,%ecx
    draw_area.x2 -= disp_area->x1;
   23ad9:	89 f8                	mov    %edi,%eax
    lv_draw_mask_radius_init(&mask_rin_param, area_inner, rin, true);
   23adb:	48 89 ef             	mov    %rbp,%rdi
   23ade:	ff c0                	inc    %eax
   23ae0:	29 c8                	sub    %ecx,%eax
    draw_area.x1 -= disp_area->x1;
   23ae2:	66 89 4c 24 78       	mov    %cx,0x78(%rsp)
   23ae7:	66 89 44 24 18       	mov    %ax,0x18(%rsp)
    lv_draw_mask_radius_init(&mask_rin_param, area_inner, rin, true);
   23aec:	b9 01 00 00 00       	mov    $0x1,%ecx
    int32_t draw_area_w = lv_area_get_width(&draw_area);
   23af1:	98                   	cwtl   
   23af2:	89 44 24 20          	mov    %eax,0x20(%rsp)
    lv_draw_mask_radius_init(&mask_rin_param, area_inner, rin, true);
   23af6:	e8 1e f5 ff ff       	callq  23019 <lv_draw_mask_radius_init>
    int16_t mask_rin_id = lv_draw_mask_add(&mask_rin_param, NULL);
   23afb:	48 89 ef             	mov    %rbp,%rdi

    lv_draw_mask_radius_param_t mask_rout_param;
    lv_draw_mask_radius_init(&mask_rout_param, area_outer, rout, false);
   23afe:	48 8d ac 24 c0 00 00 	lea    0xc0(%rsp),%rbp
   23b05:	00 
    int16_t mask_rin_id = lv_draw_mask_add(&mask_rin_param, NULL);
   23b06:	31 f6                	xor    %esi,%esi
   23b08:	e8 53 f2 ff ff       	callq  22d60 <lv_draw_mask_add>
    lv_draw_mask_radius_init(&mask_rout_param, area_outer, rout, false);
   23b0d:	31 c9                	xor    %ecx,%ecx
   23b0f:	41 0f bf d5          	movswl %r13w,%edx
   23b13:	48 89 de             	mov    %rbx,%rsi
   23b16:	48 89 ef             	mov    %rbp,%rdi
    int16_t mask_rin_id = lv_draw_mask_add(&mask_rin_param, NULL);
   23b19:	66 89 44 24 52       	mov    %ax,0x52(%rsp)
    lv_draw_mask_radius_init(&mask_rout_param, area_outer, rout, false);
   23b1e:	e8 f6 f4 ff ff       	callq  23019 <lv_draw_mask_radius_init>
    int16_t mask_rout_id = lv_draw_mask_add(&mask_rout_param, NULL);
   23b23:	31 f6                	xor    %esi,%esi
   23b25:	48 89 ef             	mov    %rbp,%rdi
   23b28:	e8 33 f2 ff ff       	callq  22d60 <lv_draw_mask_add>

    lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   23b2d:	8b 7c 24 20          	mov    0x20(%rsp),%edi
    int16_t mask_rout_id = lv_draw_mask_add(&mask_rout_param, NULL);
   23b31:	66 89 44 24 54       	mov    %ax,0x54(%rsp)
    lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   23b36:	e8 a3 26 00 00       	callq  261de <_lv_mem_buf_get>
    int32_t h;
    lv_draw_mask_res_t mask_res;
    lv_area_t fill_area;

    /*Apply some optimization if there is no other mask*/
    if(simple_mode) {
   23b3b:	80 7c 24 28 00       	cmpb   $0x0,0x28(%rsp)
    lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   23b40:	49 89 c6             	mov    %rax,%r14
   23b43:	66 41 8b 44 24 1e    	mov    0x1e(%r12),%ax
    if(simple_mode) {
   23b49:	0f 85 54 04 00 00    	jne    23fa3 <lv_draw_rect+0xdf8>
    int32_t corner_size = LV_MATH_MAX(rout, border_width - 1);
   23b4f:	8b 7c 24 14          	mov    0x14(%rsp),%edi
        /*Draw the upper corner area*/
        int32_t upper_corner_end = area_outer->y1 - disp_area->y1 + corner_size;
   23b53:	0f bf c8             	movswl %ax,%ecx

        fill_area.x1 = area_outer->x1;
        fill_area.x2 = area_outer->x2;
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   23b56:	0f bf 6c 24 7a       	movswl 0x7a(%rsp),%ebp
    int32_t corner_size = LV_MATH_MAX(rout, border_width - 1);
   23b5b:	8d 57 ff             	lea    -0x1(%rdi),%edx
   23b5e:	44 39 ea             	cmp    %r13d,%edx
   23b61:	41 0f 4c d5          	cmovl  %r13d,%edx
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   23b65:	01 e8                	add    %ebp,%eax
    int32_t corner_size = LV_MATH_MAX(rout, border_width - 1);
   23b67:	89 54 24 28          	mov    %edx,0x28(%rsp)
        int32_t upper_corner_end = area_outer->y1 - disp_area->y1 + corner_size;
   23b6b:	0f bf 53 02          	movswl 0x2(%rbx),%edx
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   23b6f:	66 89 84 24 82 00 00 	mov    %ax,0x82(%rsp)
   23b76:	00 
        fill_area.y2 = fill_area.y1;
   23b77:	66 89 84 24 86 00 00 	mov    %ax,0x86(%rsp)
   23b7e:	00 
        for(h = draw_area.y1; h <= upper_corner_end; h++) {
            _lv_memset_ff(mask_buf, draw_area_w);
   23b7f:	48 0f bf 44 24 18    	movswq 0x18(%rsp),%rax
        int32_t upper_corner_end = area_outer->y1 - disp_area->y1 + corner_size;
   23b85:	29 ca                	sub    %ecx,%edx
   23b87:	03 54 24 28          	add    0x28(%rsp),%edx
            _lv_memset_ff(mask_buf, draw_area_w);
   23b8b:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
        int32_t upper_corner_end = area_outer->y1 - disp_area->y1 + corner_size;
   23b90:	89 54 24 30          	mov    %edx,0x30(%rsp)
        fill_area.x1 = area_outer->x1;
   23b94:	66 8b 13             	mov    (%rbx),%dx
   23b97:	66 89 94 24 80 00 00 	mov    %dx,0x80(%rsp)
   23b9e:	00 
        fill_area.x2 = area_outer->x2;
   23b9f:	66 8b 53 04          	mov    0x4(%rbx),%dx
   23ba3:	66 89 94 24 84 00 00 	mov    %dx,0x84(%rsp)
   23baa:	00 
        for(h = draw_area.y1; h <= upper_corner_end; h++) {
   23bab:	39 6c 24 30          	cmp    %ebp,0x30(%rsp)
   23baf:	0f 8c 7b 01 00 00    	jl     23d30 <lv_draw_rect+0xb85>
   23bb5:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
   23bba:	b0 ff                	mov    $0xff,%al
   23bbc:	4c 89 f7             	mov    %r14,%rdi
   23bbf:	f3 aa                	rep stos %al,%es:(%rdi)
            mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
   23bc1:	8b 4c 24 20          	mov    0x20(%rsp),%ecx
   23bc5:	4c 89 f7             	mov    %r14,%rdi
   23bc8:	8b 74 24 78          	mov    0x78(%rsp),%esi
   23bcc:	66 41 8b 54 24 1e    	mov    0x1e(%r12),%dx
   23bd2:	41 03 74 24 1c       	add    0x1c(%r12),%esi
   23bd7:	01 ea                	add    %ebp,%edx
   23bd9:	0f bf d2             	movswl %dx,%edx
   23bdc:	0f bf f6             	movswl %si,%esi
   23bdf:	e8 e0 f1 ff ff       	callq  22dc4 <lv_draw_mask_apply>

            lv_area_t fill_area2;
            fill_area2.y1 = fill_area.y1;
   23be4:	66 8b 94 24 82 00 00 	mov    0x82(%rsp),%dx
   23beb:	00 
            fill_area2.y2 = fill_area.y2;

            fill_area2.x1 = area_outer->x1;
            fill_area2.x2 = area_outer->x1 + rout - 1;

            _lv_blend_fill(clip, &fill_area2, color, mask_buf, mask_res, opa, blend_mode);
   23bec:	0f b6 c0             	movzbl %al,%eax
   23bef:	4c 8d 94 24 88 00 00 	lea    0x88(%rsp),%r10
   23bf6:	00 
   23bf7:	89 44 24 38          	mov    %eax,0x38(%rsp)
   23bfb:	48 83 ec 08          	sub    $0x8,%rsp
   23bff:	4c 89 f1             	mov    %r14,%rcx
   23c02:	4c 89 d6             	mov    %r10,%rsi
            fill_area2.y1 = fill_area.y1;
   23c05:	66 89 94 24 92 00 00 	mov    %dx,0x92(%rsp)
   23c0c:	00 
            fill_area2.y2 = fill_area.y2;
   23c0d:	66 8b 94 24 8e 00 00 	mov    0x8e(%rsp),%dx
   23c14:	00 
   23c15:	66 89 94 24 96 00 00 	mov    %dx,0x96(%rsp)
   23c1c:	00 
            fill_area2.x1 = area_outer->x1;
   23c1d:	66 8b 13             	mov    (%rbx),%dx
   23c20:	66 89 94 24 90 00 00 	mov    %dx,0x90(%rsp)
   23c27:	00 
            fill_area2.x2 = area_outer->x1 + rout - 1;
   23c28:	42 8d 54 2a ff       	lea    -0x1(%rdx,%r13,1),%edx
   23c2d:	66 89 94 24 94 00 00 	mov    %dx,0x94(%rsp)
   23c34:	00 
            _lv_blend_fill(clip, &fill_area2, color, mask_buf, mask_res, opa, blend_mode);
   23c35:	41 57                	push   %r15
   23c37:	8b 54 24 18          	mov    0x18(%rsp),%edx
   23c3b:	44 8b 4c 24 20       	mov    0x20(%rsp),%r9d
   23c40:	44 8b 44 24 48       	mov    0x48(%rsp),%r8d
   23c45:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   23c4a:	4c 89 54 24 58       	mov    %r10,0x58(%rsp)
   23c4f:	e8 f9 b2 ff ff       	callq  1ef4d <_lv_blend_fill>
   23c54:	41 59                	pop    %r9

            /*Draw the top horizontal line*/
            if(fill_area2.y2 < area_outer->y1 + border_width) {
   23c56:	0f bf 43 02          	movswl 0x2(%rbx),%eax
            _lv_blend_fill(clip, &fill_area2, color, mask_buf, mask_res, opa, blend_mode);
   23c5a:	41 5a                	pop    %r10
            if(fill_area2.y2 < area_outer->y1 + border_width) {
   23c5c:	0f bf 94 24 8e 00 00 	movswl 0x8e(%rsp),%edx
   23c63:	00 
   23c64:	03 44 24 14          	add    0x14(%rsp),%eax
   23c68:	4c 8b 54 24 48       	mov    0x48(%rsp),%r10
   23c6d:	39 c2                	cmp    %eax,%edx
   23c6f:	7d 44                	jge    23cb5 <lv_draw_rect+0xb0a>
                fill_area2.x1 = area_outer->x1 + rout;
   23c71:	66 8b 03             	mov    (%rbx),%ax
                fill_area2.x2 = area_outer->x2 - rout;

                _lv_blend_fill(clip, &fill_area2, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   23c74:	48 83 ec 08          	sub    $0x8,%rsp
   23c78:	41 b8 01 00 00 00    	mov    $0x1,%r8d
   23c7e:	31 c9                	xor    %ecx,%ecx
   23c80:	4c 89 d6             	mov    %r10,%rsi
                fill_area2.x1 = area_outer->x1 + rout;
   23c83:	44 01 e8             	add    %r13d,%eax
   23c86:	66 89 84 24 90 00 00 	mov    %ax,0x90(%rsp)
   23c8d:	00 
                fill_area2.x2 = area_outer->x2 - rout;
   23c8e:	66 8b 43 04          	mov    0x4(%rbx),%ax
   23c92:	44 29 e8             	sub    %r13d,%eax
   23c95:	66 89 84 24 94 00 00 	mov    %ax,0x94(%rsp)
   23c9c:	00 
                _lv_blend_fill(clip, &fill_area2, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   23c9d:	41 57                	push   %r15
   23c9f:	44 8b 4c 24 20       	mov    0x20(%rsp),%r9d
   23ca4:	8b 54 24 18          	mov    0x18(%rsp),%edx
   23ca8:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   23cad:	e8 9b b2 ff ff       	callq  1ef4d <_lv_blend_fill>
   23cb2:	5f                   	pop    %rdi
   23cb3:	41 58                	pop    %r8
            }

            fill_area2.x1 = area_outer->x2 - rout + 1;
   23cb5:	0f bf 43 04          	movswl 0x4(%rbx),%eax
            fill_area2.x2 = area_outer->x2;

            int32_t mask_ofs = (area_outer->x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
   23cb9:	0f bf 4c 24 78       	movswl 0x78(%rsp),%ecx
            if(mask_ofs < 0) mask_ofs = 0;
            _lv_blend_fill(clip, &fill_area2, color, mask_buf + mask_ofs, mask_res, opa, blend_mode);
   23cbe:	48 8d b4 24 88 00 00 	lea    0x88(%rsp),%rsi
   23cc5:	00 
            fill_area2.x1 = area_outer->x2 - rout + 1;
   23cc6:	8d 50 01             	lea    0x1(%rax),%edx
            fill_area2.x2 = area_outer->x2;
   23cc9:	66 89 84 24 8c 00 00 	mov    %ax,0x8c(%rsp)
   23cd0:	00 
            int32_t mask_ofs = (area_outer->x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
   23cd1:	44 29 e8             	sub    %r13d,%eax
   23cd4:	ff c0                	inc    %eax
            fill_area2.x1 = area_outer->x2 - rout + 1;
   23cd6:	44 29 ea             	sub    %r13d,%edx
   23cd9:	66 89 94 24 88 00 00 	mov    %dx,0x88(%rsp)
   23ce0:	00 
            int32_t mask_ofs = (area_outer->x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
   23ce1:	41 0f bf 54 24 1c    	movswl 0x1c(%r12),%edx
   23ce7:	01 ca                	add    %ecx,%edx
            _lv_blend_fill(clip, &fill_area2, color, mask_buf + mask_ofs, mask_res, opa, blend_mode);
   23ce9:	b9 00 00 00 00       	mov    $0x0,%ecx
   23cee:	29 d0                	sub    %edx,%eax
   23cf0:	0f 49 c8             	cmovns %eax,%ecx
   23cf3:	48 83 ec 08          	sub    $0x8,%rsp
        for(h = draw_area.y1; h <= upper_corner_end; h++) {
   23cf7:	ff c5                	inc    %ebp
            _lv_blend_fill(clip, &fill_area2, color, mask_buf + mask_ofs, mask_res, opa, blend_mode);
   23cf9:	41 57                	push   %r15
   23cfb:	44 8b 4c 24 20       	mov    0x20(%rsp),%r9d
   23d00:	48 63 c9             	movslq %ecx,%rcx
   23d03:	44 8b 44 24 48       	mov    0x48(%rsp),%r8d
   23d08:	8b 54 24 18          	mov    0x18(%rsp),%edx
   23d0c:	4c 01 f1             	add    %r14,%rcx
   23d0f:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   23d14:	e8 34 b2 ff ff       	callq  1ef4d <_lv_blend_fill>
   23d19:	59                   	pop    %rcx
   23d1a:	5e                   	pop    %rsi

            fill_area.y1++;
   23d1b:	66 ff 84 24 82 00 00 	incw   0x82(%rsp)
   23d22:	00 
            fill_area.y2++;
   23d23:	66 ff 84 24 86 00 00 	incw   0x86(%rsp)
   23d2a:	00 
   23d2b:	e9 7b fe ff ff       	jmpq   23bab <lv_draw_rect+0xa00>
        }

        /*Draw the lower corner area */
        int32_t lower_corner_end = area_outer->y2 - disp_area->y1 - corner_size;
   23d30:	41 0f bf 54 24 1e    	movswl 0x1e(%r12),%edx
   23d36:	0f bf 6b 06          	movswl 0x6(%rbx),%ebp
   23d3a:	29 d5                	sub    %edx,%ebp
   23d3c:	2b 6c 24 28          	sub    0x28(%rsp),%ebp
   23d40:	89 d0                	mov    %edx,%eax
        if(lower_corner_end <= upper_corner_end) lower_corner_end = upper_corner_end + 1;
   23d42:	39 6c 24 30          	cmp    %ebp,0x30(%rsp)
   23d46:	7c 06                	jl     23d4e <lv_draw_rect+0xba3>
   23d48:	8b 6c 24 30          	mov    0x30(%rsp),%ebp
   23d4c:	ff c5                	inc    %ebp
        fill_area.y1 = disp_area->y1 + lower_corner_end;
   23d4e:	01 e8                	add    %ebp,%eax
   23d50:	66 89 84 24 82 00 00 	mov    %ax,0x82(%rsp)
   23d57:	00 
        fill_area.y2 = fill_area.y1;
   23d58:	66 89 84 24 86 00 00 	mov    %ax,0x86(%rsp)
   23d5f:	00 
        for(h = lower_corner_end; h <= draw_area.y2; h++) {
            _lv_memset_ff(mask_buf, draw_area_w);
   23d60:	48 0f bf 44 24 18    	movswq 0x18(%rsp),%rax
   23d66:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
        for(h = lower_corner_end; h <= draw_area.y2; h++) {
   23d6b:	0f bf 44 24 7e       	movswl 0x7e(%rsp),%eax
   23d70:	39 c5                	cmp    %eax,%ebp
   23d72:	0f 8f 7b 01 00 00    	jg     23ef3 <lv_draw_rect+0xd48>
   23d78:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
   23d7d:	b0 ff                	mov    $0xff,%al
   23d7f:	4c 89 f7             	mov    %r14,%rdi
   23d82:	f3 aa                	rep stos %al,%es:(%rdi)
            mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
   23d84:	8b 4c 24 20          	mov    0x20(%rsp),%ecx
   23d88:	4c 89 f7             	mov    %r14,%rdi
   23d8b:	8b 74 24 78          	mov    0x78(%rsp),%esi
   23d8f:	66 41 8b 54 24 1e    	mov    0x1e(%r12),%dx
   23d95:	41 03 74 24 1c       	add    0x1c(%r12),%esi
   23d9a:	01 ea                	add    %ebp,%edx
   23d9c:	0f bf d2             	movswl %dx,%edx
   23d9f:	0f bf f6             	movswl %si,%esi
   23da2:	e8 1d f0 ff ff       	callq  22dc4 <lv_draw_mask_apply>

            lv_area_t fill_area2;
            fill_area2.x1 = area_outer->x1;
   23da7:	66 8b 13             	mov    (%rbx),%dx
            fill_area2.x2 = area_outer->x1 + rout - 1;
            fill_area2.y1 = fill_area.y1;
            fill_area2.y2 = fill_area.y2;

            _lv_blend_fill(clip, &fill_area2, color, mask_buf, mask_res, opa, blend_mode);
   23daa:	0f b6 c0             	movzbl %al,%eax
   23dad:	4c 8d 94 24 88 00 00 	lea    0x88(%rsp),%r10
   23db4:	00 
   23db5:	89 44 24 18          	mov    %eax,0x18(%rsp)
   23db9:	48 83 ec 08          	sub    $0x8,%rsp
   23dbd:	4c 89 f1             	mov    %r14,%rcx
   23dc0:	4c 89 d6             	mov    %r10,%rsi
            fill_area2.x1 = area_outer->x1;
   23dc3:	66 89 94 24 90 00 00 	mov    %dx,0x90(%rsp)
   23dca:	00 
            fill_area2.x2 = area_outer->x1 + rout - 1;
   23dcb:	42 8d 54 2a ff       	lea    -0x1(%rdx,%r13,1),%edx
   23dd0:	66 89 94 24 94 00 00 	mov    %dx,0x94(%rsp)
   23dd7:	00 
            fill_area2.y1 = fill_area.y1;
   23dd8:	66 8b 94 24 8a 00 00 	mov    0x8a(%rsp),%dx
   23ddf:	00 
   23de0:	66 89 94 24 92 00 00 	mov    %dx,0x92(%rsp)
   23de7:	00 
            fill_area2.y2 = fill_area.y2;
   23de8:	66 8b 94 24 8e 00 00 	mov    0x8e(%rsp),%dx
   23def:	00 
   23df0:	66 89 94 24 96 00 00 	mov    %dx,0x96(%rsp)
   23df7:	00 
            _lv_blend_fill(clip, &fill_area2, color, mask_buf, mask_res, opa, blend_mode);
   23df8:	41 57                	push   %r15
   23dfa:	44 8b 4c 24 20       	mov    0x20(%rsp),%r9d
   23dff:	44 8b 44 24 28       	mov    0x28(%rsp),%r8d
   23e04:	8b 54 24 18          	mov    0x18(%rsp),%edx
   23e08:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   23e0d:	4c 89 54 24 48       	mov    %r10,0x48(%rsp)
   23e12:	e8 36 b1 ff ff       	callq  1ef4d <_lv_blend_fill>
   23e17:	58                   	pop    %rax

            /*Draw the bottom horizontal line*/
            if(fill_area2.y2 > area_outer->y2 - border_width) {
   23e18:	0f bf 43 06          	movswl 0x6(%rbx),%eax
            _lv_blend_fill(clip, &fill_area2, color, mask_buf, mask_res, opa, blend_mode);
   23e1c:	5a                   	pop    %rdx
            if(fill_area2.y2 > area_outer->y2 - border_width) {
   23e1d:	0f bf 94 24 8e 00 00 	movswl 0x8e(%rsp),%edx
   23e24:	00 
   23e25:	2b 44 24 14          	sub    0x14(%rsp),%eax
   23e29:	4c 8b 54 24 38       	mov    0x38(%rsp),%r10
   23e2e:	39 c2                	cmp    %eax,%edx
   23e30:	7e 44                	jle    23e76 <lv_draw_rect+0xccb>
                fill_area2.x1 = area_outer->x1 + rout;
   23e32:	66 8b 03             	mov    (%rbx),%ax
                fill_area2.x2 = area_outer->x2 - rout;

                _lv_blend_fill(clip, &fill_area2, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   23e35:	48 83 ec 08          	sub    $0x8,%rsp
   23e39:	41 b8 01 00 00 00    	mov    $0x1,%r8d
   23e3f:	31 c9                	xor    %ecx,%ecx
   23e41:	4c 89 d6             	mov    %r10,%rsi
                fill_area2.x1 = area_outer->x1 + rout;
   23e44:	44 01 e8             	add    %r13d,%eax
   23e47:	66 89 84 24 90 00 00 	mov    %ax,0x90(%rsp)
   23e4e:	00 
                fill_area2.x2 = area_outer->x2 - rout;
   23e4f:	66 8b 43 04          	mov    0x4(%rbx),%ax
   23e53:	44 29 e8             	sub    %r13d,%eax
   23e56:	66 89 84 24 94 00 00 	mov    %ax,0x94(%rsp)
   23e5d:	00 
                _lv_blend_fill(clip, &fill_area2, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   23e5e:	41 57                	push   %r15
   23e60:	44 8b 4c 24 20       	mov    0x20(%rsp),%r9d
   23e65:	8b 54 24 18          	mov    0x18(%rsp),%edx
   23e69:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   23e6e:	e8 da b0 ff ff       	callq  1ef4d <_lv_blend_fill>
   23e73:	41 5b                	pop    %r11
   23e75:	58                   	pop    %rax
            }
            fill_area2.x1 = area_outer->x2 - rout + 1;
   23e76:	0f bf 43 04          	movswl 0x4(%rbx),%eax
            fill_area2.x2 = area_outer->x2;

            int32_t mask_ofs = (area_outer->x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
   23e7a:	0f bf 4c 24 78       	movswl 0x78(%rsp),%ecx
            if(mask_ofs < 0) mask_ofs = 0;
            _lv_blend_fill(clip, &fill_area2, color, mask_buf + mask_ofs, mask_res, opa, blend_mode);
   23e7f:	48 8d b4 24 88 00 00 	lea    0x88(%rsp),%rsi
   23e86:	00 
            fill_area2.x1 = area_outer->x2 - rout + 1;
   23e87:	8d 50 01             	lea    0x1(%rax),%edx
            fill_area2.x2 = area_outer->x2;
   23e8a:	66 89 84 24 8c 00 00 	mov    %ax,0x8c(%rsp)
   23e91:	00 
            int32_t mask_ofs = (area_outer->x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
   23e92:	44 29 e8             	sub    %r13d,%eax
   23e95:	ff c0                	inc    %eax
            fill_area2.x1 = area_outer->x2 - rout + 1;
   23e97:	44 29 ea             	sub    %r13d,%edx
   23e9a:	66 89 94 24 88 00 00 	mov    %dx,0x88(%rsp)
   23ea1:	00 
            int32_t mask_ofs = (area_outer->x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
   23ea2:	41 0f bf 54 24 1c    	movswl 0x1c(%r12),%edx
   23ea8:	01 ca                	add    %ecx,%edx
            _lv_blend_fill(clip, &fill_area2, color, mask_buf + mask_ofs, mask_res, opa, blend_mode);
   23eaa:	b9 00 00 00 00       	mov    $0x0,%ecx
   23eaf:	29 d0                	sub    %edx,%eax
   23eb1:	0f 49 c8             	cmovns %eax,%ecx
   23eb4:	48 83 ec 08          	sub    $0x8,%rsp
        for(h = lower_corner_end; h <= draw_area.y2; h++) {
   23eb8:	ff c5                	inc    %ebp
            _lv_blend_fill(clip, &fill_area2, color, mask_buf + mask_ofs, mask_res, opa, blend_mode);
   23eba:	41 57                	push   %r15
   23ebc:	44 8b 4c 24 20       	mov    0x20(%rsp),%r9d
   23ec1:	48 63 c9             	movslq %ecx,%rcx
   23ec4:	44 8b 44 24 28       	mov    0x28(%rsp),%r8d
   23ec9:	8b 54 24 18          	mov    0x18(%rsp),%edx
   23ecd:	4c 01 f1             	add    %r14,%rcx
   23ed0:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   23ed5:	e8 73 b0 ff ff       	callq  1ef4d <_lv_blend_fill>
   23eda:	41 59                	pop    %r9
   23edc:	41 5a                	pop    %r10


            fill_area.y1++;
   23ede:	66 ff 84 24 82 00 00 	incw   0x82(%rsp)
   23ee5:	00 
            fill_area.y2++;
   23ee6:	66 ff 84 24 86 00 00 	incw   0x86(%rsp)
   23eed:	00 
   23eee:	e9 78 fe ff ff       	jmpq   23d6b <lv_draw_rect+0xbc0>
        }

        /*Draw the left vertical part*/
        fill_area.y1 = area_outer->y1 + corner_size + 1;
   23ef3:	8b 7c 24 28          	mov    0x28(%rsp),%edi
   23ef7:	66 8b 43 02          	mov    0x2(%rbx),%ax
        fill_area.y2 = area_outer->y2 - corner_size - 1;

        fill_area.x1 = area_outer->x1;
        fill_area.x2 = area_outer->x1 + border_width - 1;
        _lv_blend_fill(clip, &fill_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   23efb:	48 8d ac 24 80 00 00 	lea    0x80(%rsp),%rbp
   23f02:	00 
   23f03:	48 83 ec 08          	sub    $0x8,%rsp
   23f07:	41 b8 01 00 00 00    	mov    $0x1,%r8d
   23f0d:	31 c9                	xor    %ecx,%ecx
   23f0f:	48 89 ee             	mov    %rbp,%rsi
        fill_area.y1 = area_outer->y1 + corner_size + 1;
   23f12:	8d 44 38 01          	lea    0x1(%rax,%rdi,1),%eax
   23f16:	66 89 84 24 8a 00 00 	mov    %ax,0x8a(%rsp)
   23f1d:	00 
        fill_area.y2 = area_outer->y2 - corner_size - 1;
   23f1e:	89 f8                	mov    %edi,%eax
        fill_area.x2 = area_outer->x1 + border_width - 1;
   23f20:	8b 7c 24 34          	mov    0x34(%rsp),%edi
        fill_area.y2 = area_outer->y2 - corner_size - 1;
   23f24:	f7 d0                	not    %eax
   23f26:	66 03 43 06          	add    0x6(%rbx),%ax
   23f2a:	66 89 84 24 8e 00 00 	mov    %ax,0x8e(%rsp)
   23f31:	00 
        fill_area.x1 = area_outer->x1;
   23f32:	66 8b 03             	mov    (%rbx),%ax
   23f35:	66 89 84 24 88 00 00 	mov    %ax,0x88(%rsp)
   23f3c:	00 
        fill_area.x2 = area_outer->x1 + border_width - 1;
   23f3d:	8d 44 07 ff          	lea    -0x1(%rdi,%rax,1),%eax
   23f41:	66 89 84 24 8c 00 00 	mov    %ax,0x8c(%rsp)
   23f48:	00 
        _lv_blend_fill(clip, &fill_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   23f49:	41 57                	push   %r15
   23f4b:	44 8b 4c 24 20       	mov    0x20(%rsp),%r9d
   23f50:	8b 54 24 18          	mov    0x18(%rsp),%edx
   23f54:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   23f59:	e8 ef af ff ff       	callq  1ef4d <_lv_blend_fill>

        /*Draw the right vertical border*/
        fill_area.x1 = area_outer->x2 - border_width + 1;
   23f5e:	66 8b 53 04          	mov    0x4(%rbx),%dx
        fill_area.x2 = area_outer->x2;

        _lv_blend_fill(clip, &fill_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   23f62:	44 8b 4c 24 20       	mov    0x20(%rsp),%r9d
   23f67:	41 b8 01 00 00 00    	mov    $0x1,%r8d
   23f6d:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   23f72:	31 c9                	xor    %ecx,%ecx
   23f74:	48 89 ee             	mov    %rbp,%rsi
   23f77:	44 89 3c 24          	mov    %r15d,(%rsp)
        fill_area.x1 = area_outer->x2 - border_width + 1;
   23f7b:	8d 42 01             	lea    0x1(%rdx),%eax
   23f7e:	2b 44 24 3c          	sub    0x3c(%rsp),%eax
        fill_area.x2 = area_outer->x2;
   23f82:	66 89 94 24 94 00 00 	mov    %dx,0x94(%rsp)
   23f89:	00 
        _lv_blend_fill(clip, &fill_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   23f8a:	8b 54 24 18          	mov    0x18(%rsp),%edx
        fill_area.x1 = area_outer->x2 - border_width + 1;
   23f8e:	66 89 84 24 90 00 00 	mov    %ax,0x90(%rsp)
   23f95:	00 
        _lv_blend_fill(clip, &fill_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   23f96:	e8 b2 af ff ff       	callq  1ef4d <_lv_blend_fill>
   23f9b:	5f                   	pop    %rdi
   23f9c:	41 58                	pop    %r8
   23f9e:	e9 a8 00 00 00       	jmpq   2404b <lv_draw_rect+0xea0>
    }
    /*Process line by line if there is other mask too*/
    else {
        fill_area.x1 = area_outer->x1;
   23fa3:	66 8b 13             	mov    (%rbx),%dx
        fill_area.x2 = area_outer->x2;
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   23fa6:	0f bf 6c 24 7a       	movswl 0x7a(%rsp),%ebp
        fill_area.x1 = area_outer->x1;
   23fab:	66 89 94 24 80 00 00 	mov    %dx,0x80(%rsp)
   23fb2:	00 
        fill_area.x2 = area_outer->x2;
   23fb3:	66 8b 53 04          	mov    0x4(%rbx),%dx
        fill_area.y2 = fill_area.y1;

        for(h = draw_area.y1; h <= draw_area.y2; h++) {
            _lv_memset_ff(mask_buf, draw_area_w);
   23fb7:	48 0f bf 5c 24 18    	movswq 0x18(%rsp),%rbx
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   23fbd:	01 e8                	add    %ebp,%eax
   23fbf:	66 89 84 24 82 00 00 	mov    %ax,0x82(%rsp)
   23fc6:	00 
        fill_area.y2 = fill_area.y1;
   23fc7:	66 89 84 24 86 00 00 	mov    %ax,0x86(%rsp)
   23fce:	00 
        fill_area.x2 = area_outer->x2;
   23fcf:	66 89 94 24 84 00 00 	mov    %dx,0x84(%rsp)
   23fd6:	00 
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   23fd7:	0f bf 44 24 7e       	movswl 0x7e(%rsp),%eax
   23fdc:	39 c5                	cmp    %eax,%ebp
   23fde:	7f 6b                	jg     2404b <lv_draw_rect+0xea0>
   23fe0:	b0 ff                	mov    $0xff,%al
   23fe2:	4c 89 f7             	mov    %r14,%rdi
   23fe5:	48 89 d9             	mov    %rbx,%rcx
   23fe8:	f3 aa                	rep stos %al,%es:(%rdi)
            mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
   23fea:	8b 4c 24 20          	mov    0x20(%rsp),%ecx
   23fee:	4c 89 f7             	mov    %r14,%rdi
   23ff1:	8b 74 24 78          	mov    0x78(%rsp),%esi
   23ff5:	66 41 8b 54 24 1e    	mov    0x1e(%r12),%dx
   23ffb:	41 03 74 24 1c       	add    0x1c(%r12),%esi
   24000:	01 ea                	add    %ebp,%edx
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   24002:	ff c5                	inc    %ebp
            mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
   24004:	0f bf d2             	movswl %dx,%edx
   24007:	0f bf f6             	movswl %si,%esi
   2400a:	e8 b5 ed ff ff       	callq  22dc4 <lv_draw_mask_apply>

            _lv_blend_fill(clip, &fill_area, color, mask_buf, mask_res, opa, blend_mode);
   2400f:	48 8d b4 24 80 00 00 	lea    0x80(%rsp),%rsi
   24016:	00 
   24017:	48 83 ec 08          	sub    $0x8,%rsp
   2401b:	4c 89 f1             	mov    %r14,%rcx
   2401e:	41 57                	push   %r15
   24020:	44 8b 4c 24 20       	mov    0x20(%rsp),%r9d
   24025:	44 0f b6 c0          	movzbl %al,%r8d
   24029:	8b 54 24 18          	mov    0x18(%rsp),%edx
   2402d:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   24032:	e8 16 af ff ff       	callq  1ef4d <_lv_blend_fill>
   24037:	59                   	pop    %rcx
   24038:	5e                   	pop    %rsi
            fill_area.y1++;
   24039:	66 ff 84 24 82 00 00 	incw   0x82(%rsp)
   24040:	00 
            fill_area.y2++;
   24041:	66 ff 84 24 86 00 00 	incw   0x86(%rsp)
   24048:	00 
   24049:	eb 8c                	jmp    23fd7 <lv_draw_rect+0xe2c>

        }
    }
    lv_draw_mask_remove_id(mask_rin_id);
   2404b:	0f bf 7c 24 52       	movswl 0x52(%rsp),%edi
   24050:	e8 d0 ed ff ff       	callq  22e25 <lv_draw_mask_remove_id>
    lv_draw_mask_remove_id(mask_rout_id);
   24055:	0f bf 7c 24 54       	movswl 0x54(%rsp),%edi
   2405a:	e8 c6 ed ff ff       	callq  22e25 <lv_draw_mask_remove_id>
    _lv_mem_buf_release(mask_buf);
   2405f:	4c 89 f7             	mov    %r14,%rdi
   24062:	e9 c5 02 00 00       	jmpq   2432c <lv_draw_rect+0x1181>
        if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
   24067:	80 7c 24 10 fd       	cmpb   $0xfd,0x10(%rsp)
   2406c:	76 05                	jbe    24073 <lv_draw_rect+0xec8>
   2406e:	c6 44 24 10 ff       	movb   $0xff,0x10(%rsp)
        lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
   24073:	e8 c2 96 ff ff       	callq  1d73a <_lv_refr_get_disp_refreshing>
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   24078:	48 89 c7             	mov    %rax,%rdi
   2407b:	e8 82 10 00 00       	callq  25102 <lv_disp_get_buf>
        is_common = _lv_area_intersect(&draw_area, coords, clip);
   24080:	48 8b 14 24          	mov    (%rsp),%rdx
   24084:	48 8d bc 24 80 00 00 	lea    0x80(%rsp),%rdi
   2408b:	00 
   2408c:	48 89 de             	mov    %rbx,%rsi
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   2408f:	49 89 c5             	mov    %rax,%r13
        is_common = _lv_area_intersect(&draw_area, coords, clip);
   24092:	e8 85 14 00 00       	callq  2551c <_lv_area_intersect>
        if(is_common == false) return;
   24097:	84 c0                	test   %al,%al
   24099:	0f 84 92 02 00 00    	je     24331 <lv_draw_rect+0x1186>
        draw_area.x1 -= disp_area->x1;
   2409f:	66 41 8b 4d 1c       	mov    0x1c(%r13),%cx
        draw_area.x2 -= disp_area->x1;
   240a4:	44 8b a4 24 84 00 00 	mov    0x84(%rsp),%r12d
   240ab:	00 
        int16_t mask_rout_id = LV_MASK_ID_INV;
   240ac:	41 83 ce ff          	or     $0xffffffff,%r14d
        draw_area.x1 -= disp_area->x1;
   240b0:	8b 84 24 80 00 00 00 	mov    0x80(%rsp),%eax
        draw_area.y1 -= disp_area->y1;
   240b7:	66 41 8b 55 1e       	mov    0x1e(%r13),%dx
   240bc:	66 29 94 24 82 00 00 	sub    %dx,0x82(%rsp)
   240c3:	00 
        draw_area.y2 -= disp_area->y1;
   240c4:	66 29 94 24 86 00 00 	sub    %dx,0x86(%rsp)
   240cb:	00 
        draw_area.x2 -= disp_area->x1;
   240cc:	41 29 cc             	sub    %ecx,%r12d
        draw_area.x1 -= disp_area->x1;
   240cf:	29 c8                	sub    %ecx,%eax
        draw_area.x2 -= disp_area->x1;
   240d1:	66 44 89 a4 24 84 00 	mov    %r12w,0x84(%rsp)
   240d8:	00 00 
   240da:	41 ff c4             	inc    %r12d
   240dd:	41 29 c4             	sub    %eax,%r12d
        draw_area.x1 -= disp_area->x1;
   240e0:	66 89 84 24 80 00 00 	mov    %ax,0x80(%rsp)
   240e7:	00 
        int32_t draw_area_w = lv_area_get_width(&draw_area);
   240e8:	41 0f bf c4          	movswl %r12w,%eax
        lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   240ec:	89 c7                	mov    %eax,%edi
        int32_t draw_area_w = lv_area_get_width(&draw_area);
   240ee:	89 44 24 14          	mov    %eax,0x14(%rsp)
        lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   240f2:	e8 e7 20 00 00       	callq  261de <_lv_mem_buf_get>
        if(rout > 0) {
   240f7:	45 85 ff             	test   %r15d,%r15d
        lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   240fa:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
        if(rout > 0) {
   240ff:	7e 25                	jle    24126 <lv_draw_rect+0xf7b>
            lv_draw_mask_radius_init(&mask_rout_param, coords, rout, false);
   24101:	4c 8d b4 24 90 00 00 	lea    0x90(%rsp),%r14
   24108:	00 
   24109:	31 c9                	xor    %ecx,%ecx
   2410b:	44 89 fa             	mov    %r15d,%edx
   2410e:	48 89 de             	mov    %rbx,%rsi
   24111:	4c 89 f7             	mov    %r14,%rdi
   24114:	e8 00 ef ff ff       	callq  23019 <lv_draw_mask_radius_init>
            mask_rout_id = lv_draw_mask_add(&mask_rout_param, NULL);
   24119:	4c 89 f7             	mov    %r14,%rdi
   2411c:	31 f6                	xor    %esi,%esi
   2411e:	e8 3d ec ff ff       	callq  22d60 <lv_draw_mask_add>
   24123:	41 89 c6             	mov    %eax,%r14d
        lv_draw_mask_radius_init(&mask_rin_param, &area_inner, rout - dsc->border_width, true);
   24126:	44 89 fa             	mov    %r15d,%edx
   24129:	2b 55 18             	sub    0x18(%rbp),%edx
   2412c:	48 8d 84 24 c0 00 00 	lea    0xc0(%rsp),%rax
   24133:	00 
   24134:	48 8d 74 24 70       	lea    0x70(%rsp),%rsi
   24139:	b9 01 00 00 00       	mov    $0x1,%ecx
   2413e:	48 89 c7             	mov    %rax,%rdi
   24141:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   24146:	0f bf d2             	movswl %dx,%edx
   24149:	e8 cb ee ff ff       	callq  23019 <lv_draw_mask_radius_init>
        int16_t mask_rin_id = lv_draw_mask_add(&mask_rin_param, NULL);
   2414e:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
   24153:	31 f6                	xor    %esi,%esi
   24155:	48 89 c7             	mov    %rax,%rdi
   24158:	e8 03 ec ff ff       	callq  22d60 <lv_draw_mask_add>
        int32_t corner_size = LV_MATH_MAX(rout, dsc->border_width - 1);
   2415d:	44 0f bf 55 18       	movswl 0x18(%rbp),%r10d
        int16_t mask_rin_id = lv_draw_mask_add(&mask_rin_param, NULL);
   24162:	66 89 44 24 18       	mov    %ax,0x18(%rsp)
        lv_color_t color = dsc->border_color;
   24167:	8b 45 14             	mov    0x14(%rbp),%eax
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   2416a:	66 41 8b 75 1e       	mov    0x1e(%r13),%si
   2416f:	66 8b 94 24 82 00 00 	mov    0x82(%rsp),%dx
   24176:	00 
        fill_area.x2 = coords->x2;
   24177:	66 8b 4b 04          	mov    0x4(%rbx),%cx
        int32_t corner_size = LV_MATH_MAX(rout, dsc->border_width - 1);
   2417b:	41 ff ca             	dec    %r10d
        lv_color_t color = dsc->border_color;
   2417e:	89 44 24 20          	mov    %eax,0x20(%rsp)
        lv_blend_mode_t blend_mode = dsc->border_blend_mode;
   24182:	8a 45 1d             	mov    0x1d(%rbp),%al
        int32_t corner_size = LV_MATH_MAX(rout, dsc->border_width - 1);
   24185:	45 39 fa             	cmp    %r15d,%r10d
        fill_area.x2 = coords->x2;
   24188:	66 89 8c 24 8c 00 00 	mov    %cx,0x8c(%rsp)
   2418f:	00 
        int32_t corner_size = LV_MATH_MAX(rout, dsc->border_width - 1);
   24190:	45 0f 4c d7          	cmovl  %r15d,%r10d
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   24194:	01 d6                	add    %edx,%esi
        lv_blend_mode_t blend_mode = dsc->border_blend_mode;
   24196:	41 88 c7             	mov    %al,%r15b
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   24199:	66 89 b4 24 8a 00 00 	mov    %si,0x8a(%rsp)
   241a0:	00 
        fill_area.x1 = coords->x1;
   241a1:	0f bf 03             	movswl (%rbx),%eax
        fill_area.y2 = fill_area.y1;
   241a4:	66 89 b4 24 8e 00 00 	mov    %si,0x8e(%rsp)
   241ab:	00 
        if(dsc->border_side == LV_BORDER_SIDE_LEFT) fill_area.x2 = coords->x1 + corner_size;
   241ac:	66 8b 75 1a          	mov    0x1a(%rbp),%si
   241b0:	66 83 fe 04          	cmp    $0x4,%si
        fill_area.x1 = coords->x1;
   241b4:	66 89 84 24 88 00 00 	mov    %ax,0x88(%rsp)
   241bb:	00 
        if(dsc->border_side == LV_BORDER_SIDE_LEFT) fill_area.x2 = coords->x1 + corner_size;
   241bc:	75 0f                	jne    241cd <lv_draw_rect+0x1022>
   241be:	44 01 d0             	add    %r10d,%eax
        uint32_t buf_ofs = 0;
   241c1:	31 ed                	xor    %ebp,%ebp
        if(dsc->border_side == LV_BORDER_SIDE_LEFT) fill_area.x2 = coords->x1 + corner_size;
   241c3:	66 89 84 24 8c 00 00 	mov    %ax,0x8c(%rsp)
   241ca:	00 
   241cb:	eb 18                	jmp    241e5 <lv_draw_rect+0x103a>
        uint32_t buf_ofs = 0;
   241cd:	31 ed                	xor    %ebp,%ebp
        else if(dsc->border_side == LV_BORDER_SIDE_RIGHT) {
   241cf:	66 83 fe 08          	cmp    $0x8,%si
   241d3:	75 10                	jne    241e5 <lv_draw_rect+0x103a>
            fill_area.x1 = coords->x2 - corner_size;
   241d5:	44 29 d1             	sub    %r10d,%ecx
   241d8:	0f bf e9             	movswl %cx,%ebp
   241db:	66 89 ac 24 88 00 00 	mov    %bp,0x88(%rsp)
   241e2:	00 
            buf_ofs = fill_area.x1 - coords->x1;
   241e3:	29 c5                	sub    %eax,%ebp
        if(dsc->border_side == LV_BORDER_SIDE_TOP) top_only = true;
   241e5:	66 83 fe 02          	cmp    $0x2,%si
        volatile bool top_only = false;
   241e9:	c6 44 24 6e 00       	movb   $0x0,0x6e(%rsp)
        volatile bool bottom_only = false;
   241ee:	c6 44 24 6f 00       	movb   $0x0,0x6f(%rsp)
        if(dsc->border_side == LV_BORDER_SIDE_TOP) top_only = true;
   241f3:	75 07                	jne    241fc <lv_draw_rect+0x1051>
   241f5:	c6 44 24 6e 01       	movb   $0x1,0x6e(%rsp)
   241fa:	eb 16                	jmp    24212 <lv_draw_rect+0x1067>
        if(dsc->border_side == LV_BORDER_SIDE_BOTTOM) bottom_only = true;
   241fc:	66 83 fe 01          	cmp    $0x1,%si
   24200:	74 0b                	je     2420d <lv_draw_rect+0x1062>
        if(dsc->border_side == (LV_BORDER_SIDE_TOP | LV_BORDER_SIDE_BOTTOM)) {
   24202:	66 83 fe 03          	cmp    $0x3,%si
   24206:	75 0a                	jne    24212 <lv_draw_rect+0x1067>
            top_only = true;
   24208:	c6 44 24 6e 01       	movb   $0x1,0x6e(%rsp)
            bottom_only = true;
   2420d:	c6 44 24 6f 01       	movb   $0x1,0x6f(%rsp)
        volatile bool normal = !top_only && !bottom_only ? true : false;
   24212:	8a 4c 24 6e          	mov    0x6e(%rsp),%cl
   24216:	31 c0                	xor    %eax,%eax
   24218:	84 c9                	test   %cl,%cl
   2421a:	75 0a                	jne    24226 <lv_draw_rect+0x107b>
   2421c:	8a 44 24 6f          	mov    0x6f(%rsp),%al
   24220:	83 f0 01             	xor    $0x1,%eax
   24223:	0f b6 c0             	movzbl %al,%eax
   24226:	83 e0 01             	and    $0x1,%eax
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   24229:	44 0f bf da          	movswl %dx,%r11d
                _lv_memset_ff(mask_buf, draw_area_w);
   2422d:	4d 0f bf e4          	movswq %r12w,%r12
        volatile bool normal = !top_only && !bottom_only ? true : false;
   24231:	88 44 24 78          	mov    %al,0x78(%rsp)
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   24235:	0f bf 84 24 86 00 00 	movswl 0x86(%rsp),%eax
   2423c:	00 
   2423d:	41 39 c3             	cmp    %eax,%r11d
   24240:	0f 8f ce 00 00 00    	jg     24314 <lv_draw_rect+0x1169>
            if(normal ||
   24246:	8a 44 24 78          	mov    0x78(%rsp),%al
   2424a:	84 c0                	test   %al,%al
   2424c:	75 35                	jne    24283 <lv_draw_rect+0x10d8>
               (top_only && fill_area.y1 <= coords->y1 + corner_size) ||
   2424e:	8a 54 24 6e          	mov    0x6e(%rsp),%dl
   24252:	0f bf 84 24 8a 00 00 	movswl 0x8a(%rsp),%eax
   24259:	00 
            if(normal ||
   2425a:	84 d2                	test   %dl,%dl
   2425c:	74 0e                	je     2426c <lv_draw_rect+0x10c1>
               (top_only && fill_area.y1 <= coords->y1 + corner_size) ||
   2425e:	0f bf 53 02          	movswl 0x2(%rbx),%edx
   24262:	0f bf c8             	movswl %ax,%ecx
   24265:	44 01 d2             	add    %r10d,%edx
   24268:	39 d1                	cmp    %edx,%ecx
   2426a:	7e 17                	jle    24283 <lv_draw_rect+0x10d8>
               (bottom_only && fill_area.y1 >= coords->y2 - corner_size)) {
   2426c:	8a 54 24 6f          	mov    0x6f(%rsp),%dl
               (top_only && fill_area.y1 <= coords->y1 + corner_size) ||
   24270:	84 d2                	test   %dl,%dl
   24272:	0f 84 84 00 00 00    	je     242fc <lv_draw_rect+0x1151>
               (bottom_only && fill_area.y1 >= coords->y2 - corner_size)) {
   24278:	0f bf 53 06          	movswl 0x6(%rbx),%edx
   2427c:	44 29 d2             	sub    %r10d,%edx
   2427f:	39 d0                	cmp    %edx,%eax
   24281:	7c 79                	jl     242fc <lv_draw_rect+0x1151>
   24283:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   24288:	b0 ff                	mov    $0xff,%al
   2428a:	4c 89 e1             	mov    %r12,%rcx
                mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
   2428d:	44 89 da             	mov    %r11d,%edx
   24290:	44 89 54 24 2c       	mov    %r10d,0x2c(%rsp)
   24295:	44 89 5c 24 28       	mov    %r11d,0x28(%rsp)
   2429a:	f3 aa                	rep stos %al,%es:(%rdi)
   2429c:	8b 4c 24 14          	mov    0x14(%rsp),%ecx
   242a0:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   242a5:	8b b4 24 80 00 00 00 	mov    0x80(%rsp),%esi
   242ac:	66 41 03 55 1e       	add    0x1e(%r13),%dx
   242b1:	41 03 75 1c          	add    0x1c(%r13),%esi
   242b5:	0f bf d2             	movswl %dx,%edx
   242b8:	0f bf f6             	movswl %si,%esi
   242bb:	e8 04 eb ff ff       	callq  22dc4 <lv_draw_mask_apply>
                _lv_blend_fill(clip, &fill_area, color, mask_buf + buf_ofs, mask_res, opa, blend_mode);
   242c0:	48 8d b4 24 88 00 00 	lea    0x88(%rsp),%rsi
   242c7:	00 
   242c8:	41 0f b6 d7          	movzbl %r15b,%edx
   242cc:	48 83 ec 08          	sub    $0x8,%rsp
   242d0:	89 e9                	mov    %ebp,%ecx
   242d2:	48 03 4c 24 10       	add    0x10(%rsp),%rcx
   242d7:	52                   	push   %rdx
   242d8:	44 0f b6 4c 24 20    	movzbl 0x20(%rsp),%r9d
   242de:	8b 54 24 30          	mov    0x30(%rsp),%edx
   242e2:	44 0f b6 c0          	movzbl %al,%r8d
   242e6:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   242eb:	e8 5d ac ff ff       	callq  1ef4d <_lv_blend_fill>
   242f0:	58                   	pop    %rax
   242f1:	5a                   	pop    %rdx
   242f2:	44 8b 54 24 2c       	mov    0x2c(%rsp),%r10d
   242f7:	44 8b 5c 24 28       	mov    0x28(%rsp),%r11d
            fill_area.y1++;
   242fc:	66 ff 84 24 8a 00 00 	incw   0x8a(%rsp)
   24303:	00 
            fill_area.y2++;
   24304:	66 ff 84 24 8e 00 00 	incw   0x8e(%rsp)
   2430b:	00 
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   2430c:	41 ff c3             	inc    %r11d
   2430f:	e9 21 ff ff ff       	jmpq   24235 <lv_draw_rect+0x108a>
        lv_draw_mask_remove_id(mask_rin_id);
   24314:	0f bf 7c 24 18       	movswl 0x18(%rsp),%edi
   24319:	e8 07 eb ff ff       	callq  22e25 <lv_draw_mask_remove_id>
        lv_draw_mask_remove_id(mask_rout_id);
   2431e:	41 0f bf fe          	movswl %r14w,%edi
   24322:	e8 fe ea ff ff       	callq  22e25 <lv_draw_mask_remove_id>
        _lv_mem_buf_release(mask_buf);
   24327:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   2432c:	e8 9c 1f 00 00       	callq  262cd <_lv_mem_buf_release>
}
   24331:	48 8b 84 24 e8 00 00 	mov    0xe8(%rsp),%rax
   24338:	00 
   24339:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   24340:	00 00 
   24342:	74 05                	je     24349 <lv_draw_rect+0x119e>
   24344:	e8 f7 02 fe ff       	callq  4640 <__stack_chk_fail@plt>
   24349:	48 81 c4 f8 00 00 00 	add    $0xf8,%rsp
   24350:	5b                   	pop    %rbx
   24351:	5d                   	pop    %rbp
   24352:	41 5c                	pop    %r12
   24354:	41 5d                	pop    %r13
   24356:	41 5e                	pop    %r14
   24358:	41 5f                	pop    %r15
   2435a:	c3                   	retq   

000000000002435b <_lv_img_buf_get_transformed_area>:
    LV_UNUSED(angle);
    LV_UNUSED(zoom);
    LV_UNUSED(pivot);
    res->x1 = 0;
    res->y1 = 0;
    res->x2 = w - 1;
   2435b:	ff ce                	dec    %esi
    res->y2 = h - 1;
   2435d:	ff ca                	dec    %edx
    res->x1 = 0;
   2435f:	c7 07 00 00 00 00    	movl   $0x0,(%rdi)
    res->x2 = w - 1;
   24365:	66 89 77 04          	mov    %si,0x4(%rdi)
    res->y2 = h - 1;
   24369:	66 89 57 06          	mov    %dx,0x6(%rdi)
#endif
}
   2436d:	c3                   	retq   

000000000002436e <_lv_memset_00>:
   2436e:	89 f1                	mov    %esi,%ecx
   24370:	31 c0                	xor    %eax,%eax
   24372:	f3 aa                	rep stos %al,%es:(%rdi)
   24374:	c3                   	retq   

0000000000024375 <_lv_img_cache_open>:
 * @param color color The color of the image with `LV_IMG_CF_ALPHA_...`
 * @return pointer to the cache entry or NULL if can open the image
 */
lv_img_cache_entry_t * _lv_img_cache_open(const void * src, lv_color_t color)
{
    if(entry_cnt == 0) {
   24375:	0f b7 05 62 ad 23 00 	movzwl 0x23ad62(%rip),%eax        # 25f0de <entry_cnt>
{
   2437c:	41 56                	push   %r14
   2437e:	41 55                	push   %r13
   24380:	41 54                	push   %r12
   24382:	55                   	push   %rbp
   24383:	53                   	push   %rbx
    if(entry_cnt == 0) {
   24384:	66 85 c0             	test   %ax,%ax
   24387:	75 29                	jne    243b2 <_lv_img_cache_open+0x3d>
        LV_LOG_WARN("lv_img_cache_open: the cache size is 0");
   24389:	4c 8d 05 28 f5 00 00 	lea    0xf528(%rip),%r8        # 338b8 <_lv_bpp1_opa_table+0x63>
   24390:	48 8d 0d a9 c6 00 00 	lea    0xc6a9(%rip),%rcx        # 30a40 <__func__.3233>
   24397:	48 8d 35 41 f5 00 00 	lea    0xf541(%rip),%rsi        # 338df <_lv_bpp1_opa_table+0x8a>
   2439e:	ba 44 00 00 00       	mov    $0x44,%edx
   243a3:	bf 02 00 00 00       	mov    $0x2,%edi
   243a8:	e8 a9 1b 00 00       	callq  25f56 <_lv_log_add>
   243ad:	e9 77 01 00 00       	jmpq   24529 <_lv_img_cache_open+0x1b4>
        return NULL;
    }

    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
   243b2:	48 8d 15 47 3c 23 00 	lea    0x233c47(%rip),%rdx        # 258000 <_lv_img_cache_array>
   243b9:	48 89 fd             	mov    %rdi,%rbp
   243bc:	41 89 f4             	mov    %esi,%r12d
   243bf:	48 6b c0 48          	imul   $0x48,%rax,%rax
   243c3:	4c 8b 2a             	mov    (%rdx),%r13
   243c6:	49 8d 55 40          	lea    0x40(%r13),%rdx
   243ca:	48 01 d0             	add    %rdx,%rax

    /*Decrement all lifes. Make the entries older*/
    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
   243cd:	48 39 d0             	cmp    %rdx,%rax
   243d0:	74 14                	je     243e6 <_lv_img_cache_open+0x71>
        if(cache[i].life > INT32_MIN + LV_IMG_CACHE_AGING) {
   243d2:	8b 0a                	mov    (%rdx),%ecx
   243d4:	81 f9 02 00 00 80    	cmp    $0x80000002,%ecx
   243da:	7c 04                	jl     243e0 <_lv_img_cache_open+0x6b>
            cache[i].life -= LV_IMG_CACHE_AGING;
   243dc:	ff c9                	dec    %ecx
   243de:	89 0a                	mov    %ecx,(%rdx)
   243e0:	48 83 c2 48          	add    $0x48,%rdx
   243e4:	eb e7                	jmp    243cd <_lv_img_cache_open+0x58>
        }
    }

    /*Is the image cached?*/
    lv_img_cache_entry_t * cached_src = NULL;
    for(i = 0; i < entry_cnt; i++) {
   243e6:	45 31 f6             	xor    %r14d,%r14d
   243e9:	66 8b 0d ee ac 23 00 	mov    0x23acee(%rip),%cx        # 25f0de <entry_cnt>
   243f0:	66 44 39 f1          	cmp    %r14w,%cx
   243f4:	76 58                	jbe    2444e <_lv_img_cache_open+0xd9>
        bool match = false;
        lv_img_src_t src_type = lv_img_src_get_type(cache[i].dec_dsc.src);
   243f6:	41 0f b7 de          	movzwl %r14w,%ebx
   243fa:	48 6b db 48          	imul   $0x48,%rbx,%rbx
   243fe:	4c 01 eb             	add    %r13,%rbx
   24401:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
   24405:	e8 59 c2 ff ff       	callq  20663 <lv_img_src_get_type>
        if(src_type == LV_IMG_SRC_VARIABLE) {
   2440a:	84 c0                	test   %al,%al
   2440c:	75 0c                	jne    2441a <_lv_img_cache_open+0xa5>
            if(cache[i].dec_dsc.src == src && cache[i].dec_dsc.color.full == color.full) match = true;
   2440e:	48 39 6b 08          	cmp    %rbp,0x8(%rbx)
   24412:	75 35                	jne    24449 <_lv_img_cache_open+0xd4>
   24414:	44 39 63 10          	cmp    %r12d,0x10(%rbx)
   24418:	eb 12                	jmp    2442c <_lv_img_cache_open+0xb7>
        }
        else if(src_type == LV_IMG_SRC_FILE) {
   2441a:	fe c8                	dec    %al
   2441c:	75 2b                	jne    24449 <_lv_img_cache_open+0xd4>
            if(strcmp(cache[i].dec_dsc.src, src) == 0) match = true;
   2441e:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
   24422:	48 89 ee             	mov    %rbp,%rsi
   24425:	e8 86 02 fe ff       	callq  46b0 <strcmp@plt>
   2442a:	85 c0                	test   %eax,%eax
   2442c:	75 1b                	jne    24449 <_lv_img_cache_open+0xd4>
        if(match) {
            /* If opened increment its life.
             * Image difficult to open should live longer to keep avoid frequent their recaching.
             * Therefore increase `life` with `time_to_open`*/
            cached_src = &cache[i];
            cached_src->life += cached_src->dec_dsc.time_to_open * LV_IMG_CACHE_LIFE_GAIN;
   2442e:	8b 43 28             	mov    0x28(%rbx),%eax
   24431:	03 43 40             	add    0x40(%rbx),%eax
   24434:	ba e8 03 00 00       	mov    $0x3e8,%edx
   24439:	3d e8 03 00 00       	cmp    $0x3e8,%eax
   2443e:	0f 4f c2             	cmovg  %edx,%eax
   24441:	89 43 40             	mov    %eax,0x40(%rbx)
   24444:	e9 09 01 00 00       	jmpq   24552 <_lv_img_cache_open+0x1dd>
    for(i = 0; i < entry_cnt; i++) {
   24449:	41 ff c6             	inc    %r14d
   2444c:	eb 9b                	jmp    243e9 <_lv_img_cache_open+0x74>
   2444e:	49 8d 45 48          	lea    0x48(%r13),%rax
    }

    /*The image is not cached then cache it now*/
    if(cached_src == NULL) {
        /*Find an entry to reuse. Select the entry with the least life*/
        cached_src = &cache[0];
   24452:	4c 89 eb             	mov    %r13,%rbx
        for(i = 1; i < entry_cnt; i++) {
   24455:	ba 01 00 00 00       	mov    $0x1,%edx
   2445a:	66 39 d1             	cmp    %dx,%cx
   2445d:	76 12                	jbe    24471 <_lv_img_cache_open+0xfc>
            if(cache[i].life < cached_src->life) {
   2445f:	8b 73 40             	mov    0x40(%rbx),%esi
   24462:	39 70 40             	cmp    %esi,0x40(%rax)
   24465:	48 0f 4c d8          	cmovl  %rax,%rbx
        for(i = 1; i < entry_cnt; i++) {
   24469:	ff c2                	inc    %edx
   2446b:	48 83 c0 48          	add    $0x48,%rax
   2446f:	eb e9                	jmp    2445a <_lv_img_cache_open+0xe5>
                cached_src = &cache[i];
            }
        }

        /*Close the decoder to reuse if it was opened (has a valid source)*/
        if(cached_src->dec_dsc.src) {
   24471:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
   24476:	74 1d                	je     24495 <_lv_img_cache_open+0x120>
            lv_img_decoder_close(&cached_src->dec_dsc);
   24478:	48 89 df             	mov    %rbx,%rdi
   2447b:	e8 62 0a 00 00       	callq  24ee2 <lv_img_decoder_close>
            LV_LOG_INFO("image draw: cache miss, close and reuse an entry");
   24480:	4c 8d 05 93 f4 00 00 	lea    0xf493(%rip),%r8        # 3391a <_lv_bpp1_opa_table+0xc5>
   24487:	48 8d 0d b2 c5 00 00 	lea    0xc5b2(%rip),%rcx        # 30a40 <__func__.3233>
   2448e:	ba 77 00 00 00       	mov    $0x77,%edx
   24493:	eb 13                	jmp    244a8 <_lv_img_cache_open+0x133>
        }
        else {
            LV_LOG_INFO("image draw: cache miss, cached to an empty entry");
   24495:	4c 8d 05 af f4 00 00 	lea    0xf4af(%rip),%r8        # 3394b <_lv_bpp1_opa_table+0xf6>
   2449c:	48 8d 0d 9d c5 00 00 	lea    0xc59d(%rip),%rcx        # 30a40 <__func__.3233>
   244a3:	ba 7a 00 00 00       	mov    $0x7a,%edx
   244a8:	48 8d 35 30 f4 00 00 	lea    0xf430(%rip),%rsi        # 338df <_lv_bpp1_opa_table+0x8a>
   244af:	bf 01 00 00 00       	mov    $0x1,%edi
   244b4:	31 c0                	xor    %eax,%eax
   244b6:	e8 9b 1a 00 00       	callq  25f56 <_lv_log_add>
        }

        /*Open the image and measure the time to open*/
        uint32_t t_start;
        t_start                          = lv_tick_get();
   244bb:	e8 ce 0f 00 00       	callq  2548e <lv_tick_get>
        cached_src->dec_dsc.time_to_open = 0;
   244c0:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%rbx)
        lv_res_t open_res                = lv_img_decoder_open(&cached_src->dec_dsc, src, color);
   244c7:	44 89 e2             	mov    %r12d,%edx
   244ca:	48 89 ee             	mov    %rbp,%rsi
   244cd:	48 89 df             	mov    %rbx,%rdi
        t_start                          = lv_tick_get();
   244d0:	41 89 c5             	mov    %eax,%r13d
        lv_res_t open_res                = lv_img_decoder_open(&cached_src->dec_dsc, src, color);
   244d3:	e8 10 09 00 00       	callq  24de8 <lv_img_decoder_open>
        if(open_res == LV_RES_INV) {
   244d8:	84 c0                	test   %al,%al
   244da:	75 51                	jne    2452d <_lv_img_cache_open+0x1b8>
            LV_LOG_WARN("Image draw cannot open the image resource");
   244dc:	4c 8d 05 99 f4 00 00 	lea    0xf499(%rip),%r8        # 3397c <_lv_bpp1_opa_table+0x127>
   244e3:	48 8d 0d 56 c5 00 00 	lea    0xc556(%rip),%rcx        # 30a40 <__func__.3233>
   244ea:	48 8d 35 ee f3 00 00 	lea    0xf3ee(%rip),%rsi        # 338df <_lv_bpp1_opa_table+0x8a>
   244f1:	ba 83 00 00 00       	mov    $0x83,%edx
   244f6:	bf 02 00 00 00       	mov    $0x2,%edi
   244fb:	e8 56 1a 00 00       	callq  25f56 <_lv_log_add>
            lv_img_decoder_close(&cached_src->dec_dsc);
   24500:	48 89 df             	mov    %rbx,%rdi
   24503:	e8 da 09 00 00       	callq  24ee2 <lv_img_decoder_close>
            _lv_memset_00(&cached_src->dec_dsc, sizeof(lv_img_decoder_dsc_t));
   24508:	be 40 00 00 00       	mov    $0x40,%esi
   2450d:	48 89 df             	mov    %rbx,%rdi
   24510:	e8 59 fe ff ff       	callq  2436e <_lv_memset_00>
            _lv_memset_00(cached_src, sizeof(lv_img_cache_entry_t));
   24515:	be 48 00 00 00       	mov    $0x48,%esi
   2451a:	48 89 df             	mov    %rbx,%rdi
   2451d:	e8 4c fe ff ff       	callq  2436e <_lv_memset_00>
            cached_src->life = INT32_MIN; /*Make the empty entry very "weak" to force its use  */
   24522:	c7 43 40 00 00 00 80 	movl   $0x80000000,0x40(%rbx)
            return NULL;
   24529:	31 db                	xor    %ebx,%ebx
   2452b:	eb 25                	jmp    24552 <_lv_img_cache_open+0x1dd>
        }

        cached_src->life = 0;

        /*If `time_to_open` was not set in the open function set it here*/
        if(cached_src->dec_dsc.time_to_open == 0) {
   2452d:	83 7b 28 00          	cmpl   $0x0,0x28(%rbx)
        cached_src->life = 0;
   24531:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%rbx)
        if(cached_src->dec_dsc.time_to_open == 0) {
   24538:	75 0b                	jne    24545 <_lv_img_cache_open+0x1d0>
            cached_src->dec_dsc.time_to_open = lv_tick_elaps(t_start);
   2453a:	44 89 ef             	mov    %r13d,%edi
   2453d:	e8 5d 0f 00 00       	callq  2549f <lv_tick_elaps>
   24542:	89 43 28             	mov    %eax,0x28(%rbx)
        }

        if(cached_src->dec_dsc.time_to_open == 0) cached_src->dec_dsc.time_to_open = 1;
   24545:	83 7b 28 00          	cmpl   $0x0,0x28(%rbx)
   24549:	75 07                	jne    24552 <_lv_img_cache_open+0x1dd>
   2454b:	c7 43 28 01 00 00 00 	movl   $0x1,0x28(%rbx)
    }

    return cached_src;
}
   24552:	48 89 d8             	mov    %rbx,%rax
   24555:	5b                   	pop    %rbx
   24556:	5d                   	pop    %rbp
   24557:	41 5c                	pop    %r12
   24559:	41 5d                	pop    %r13
   2455b:	41 5e                	pop    %r14
   2455d:	c3                   	retq   

000000000002455e <lv_img_cache_invalidate_src>:
 * Invalidate an image source in the cache.
 * Useful if the image source is updated therefore it needs to be cached again.
 * @param src an image source path to a file or pointer to an `lv_img_dsc_t` variable.
 */
void lv_img_cache_invalidate_src(const void * src)
{
   2455e:	41 55                	push   %r13
   24560:	41 54                	push   %r12
   24562:	49 89 fc             	mov    %rdi,%r12
   24565:	55                   	push   %rbp
   24566:	53                   	push   %rbx

    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);

    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
   24567:	31 ed                	xor    %ebp,%ebp
{
   24569:	48 83 ec 08          	sub    $0x8,%rsp
    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
   2456d:	48 8d 05 8c 3a 23 00 	lea    0x233a8c(%rip),%rax        # 258000 <_lv_img_cache_array>
   24574:	4c 8b 28             	mov    (%rax),%r13
    for(i = 0; i < entry_cnt; i++) {
   24577:	66 39 2d 60 ab 23 00 	cmp    %bp,0x23ab60(%rip)        # 25f0de <entry_cnt>
   2457e:	76 43                	jbe    245c3 <lv_img_cache_invalidate_src+0x65>
        if(cache[i].dec_dsc.src == src || src == NULL) {
   24580:	0f b7 dd             	movzwl %bp,%ebx
   24583:	48 6b db 48          	imul   $0x48,%rbx,%rbx
   24587:	4c 01 eb             	add    %r13,%rbx
   2458a:	48 8b 43 08          	mov    0x8(%rbx),%rax
   2458e:	4c 39 e0             	cmp    %r12,%rax
   24591:	74 05                	je     24598 <lv_img_cache_invalidate_src+0x3a>
   24593:	4d 85 e4             	test   %r12,%r12
   24596:	75 27                	jne    245bf <lv_img_cache_invalidate_src+0x61>
            if(cache[i].dec_dsc.src != NULL) {
   24598:	48 85 c0             	test   %rax,%rax
   2459b:	74 08                	je     245a5 <lv_img_cache_invalidate_src+0x47>
                lv_img_decoder_close(&cache[i].dec_dsc);
   2459d:	48 89 df             	mov    %rbx,%rdi
   245a0:	e8 3d 09 00 00       	callq  24ee2 <lv_img_decoder_close>
            }

            _lv_memset_00(&cache[i].dec_dsc, sizeof(lv_img_decoder_dsc_t));
   245a5:	be 40 00 00 00       	mov    $0x40,%esi
   245aa:	48 89 df             	mov    %rbx,%rdi
   245ad:	e8 bc fd ff ff       	callq  2436e <_lv_memset_00>
            _lv_memset_00(&cache[i], sizeof(lv_img_cache_entry_t));
   245b2:	be 48 00 00 00       	mov    $0x48,%esi
   245b7:	48 89 df             	mov    %rbx,%rdi
   245ba:	e8 af fd ff ff       	callq  2436e <_lv_memset_00>
    for(i = 0; i < entry_cnt; i++) {
   245bf:	ff c5                	inc    %ebp
   245c1:	eb b4                	jmp    24577 <lv_img_cache_invalidate_src+0x19>
        }
    }
}
   245c3:	58                   	pop    %rax
   245c4:	5b                   	pop    %rbx
   245c5:	5d                   	pop    %rbp
   245c6:	41 5c                	pop    %r12
   245c8:	41 5d                	pop    %r13
   245ca:	c3                   	retq   

00000000000245cb <lv_img_cache_set_size>:
{
   245cb:	41 54                	push   %r12
   245cd:	55                   	push   %rbp
   245ce:	41 89 fc             	mov    %edi,%r12d
    if(LV_GC_ROOT(_lv_img_cache_array) != NULL) {
   245d1:	48 8d 2d 28 3a 23 00 	lea    0x233a28(%rip),%rbp        # 258000 <_lv_img_cache_array>
{
   245d8:	53                   	push   %rbx
   245d9:	0f b7 df             	movzwl %di,%ebx
    if(LV_GC_ROOT(_lv_img_cache_array) != NULL) {
   245dc:	48 83 7d 00 00       	cmpq   $0x0,0x0(%rbp)
   245e1:	74 10                	je     245f3 <lv_img_cache_set_size+0x28>
        lv_img_cache_invalidate_src(NULL);
   245e3:	31 ff                	xor    %edi,%edi
   245e5:	e8 74 ff ff ff       	callq  2455e <lv_img_cache_invalidate_src>
        lv_mem_free(LV_GC_ROOT(_lv_img_cache_array));
   245ea:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
   245ee:	e8 11 1b 00 00       	callq  26104 <lv_mem_free>
    LV_GC_ROOT(_lv_img_cache_array) = lv_mem_alloc(sizeof(lv_img_cache_entry_t) * new_entry_cnt);
   245f3:	48 6b db 48          	imul   $0x48,%rbx,%rbx
   245f7:	48 89 df             	mov    %rbx,%rdi
   245fa:	e8 92 1a 00 00       	callq  26091 <lv_mem_alloc>
    if(LV_GC_ROOT(_lv_img_cache_array) == NULL) {
   245ff:	48 85 c0             	test   %rax,%rax
    LV_GC_ROOT(_lv_img_cache_array) = lv_mem_alloc(sizeof(lv_img_cache_entry_t) * new_entry_cnt);
   24602:	48 89 45 00          	mov    %rax,0x0(%rbp)
    if(LV_GC_ROOT(_lv_img_cache_array) == NULL) {
   24606:	75 0b                	jne    24613 <lv_img_cache_set_size+0x48>
        entry_cnt = 0;
   24608:	66 c7 05 cd aa 23 00 	movw   $0x0,0x23aacd(%rip)        # 25f0de <entry_cnt>
   2460f:	00 00 
        return;
   24611:	eb 37                	jmp    2464a <lv_img_cache_set_size+0x7f>
    entry_cnt = new_entry_cnt;
   24613:	66 44 89 25 c3 aa 23 	mov    %r12w,0x23aac3(%rip)        # 25f0de <entry_cnt>
   2461a:	00 
    for(i = 0; i < entry_cnt; i++) {
   2461b:	31 d2                	xor    %edx,%edx
   2461d:	48 39 d3             	cmp    %rdx,%rbx
   24620:	74 28                	je     2464a <lv_img_cache_set_size+0x7f>
        _lv_memset_00(&LV_GC_ROOT(_lv_img_cache_array)[i].dec_dsc, sizeof(lv_img_decoder_dsc_t));
   24622:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
   24626:	be 40 00 00 00       	mov    $0x40,%esi
   2462b:	48 01 d7             	add    %rdx,%rdi
   2462e:	e8 3b fd ff ff       	callq  2436e <_lv_memset_00>
        _lv_memset_00(&LV_GC_ROOT(_lv_img_cache_array)[i], sizeof(lv_img_cache_entry_t));
   24633:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
   24637:	be 48 00 00 00       	mov    $0x48,%esi
   2463c:	48 01 d7             	add    %rdx,%rdi
   2463f:	e8 2a fd ff ff       	callq  2436e <_lv_memset_00>
   24644:	48 83 c2 48          	add    $0x48,%rdx
   24648:	eb d3                	jmp    2461d <lv_img_cache_set_size+0x52>
}
   2464a:	5b                   	pop    %rbx
   2464b:	5d                   	pop    %rbp
   2464c:	41 5c                	pop    %r12
   2464e:	c3                   	retq   

000000000002464f <lv_img_decoder_built_in_close>:
 * Close the pending decoding. Free resources etc.
 * @param decoder pointer to the decoder the function associated with
 * @param dsc pointer to decoder descriptor
 */
void lv_img_decoder_built_in_close(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc)
{
   2464f:	55                   	push   %rbp
   24650:	53                   	push   %rbx
   24651:	48 83 ec 08          	sub    $0x8,%rsp
    (void)decoder; /*Unused*/

    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
   24655:	48 8b 6e 38          	mov    0x38(%rsi),%rbp
    if(user_data) {
   24659:	48 85 ed             	test   %rbp,%rbp
   2465c:	74 2f                	je     2468d <lv_img_decoder_built_in_close+0x3e>
        if(user_data->f) {
            lv_fs_close(user_data->f);
            lv_mem_free(user_data->f);
        }
#endif
        if(user_data->palette) lv_mem_free(user_data->palette);
   2465e:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
   24662:	48 89 f3             	mov    %rsi,%rbx
   24665:	48 85 ff             	test   %rdi,%rdi
   24668:	74 05                	je     2466f <lv_img_decoder_built_in_close+0x20>
   2466a:	e8 95 1a 00 00       	callq  26104 <lv_mem_free>
        if(user_data->opa) lv_mem_free(user_data->opa);
   2466f:	48 8b 7d 08          	mov    0x8(%rbp),%rdi
   24673:	48 85 ff             	test   %rdi,%rdi
   24676:	74 05                	je     2467d <lv_img_decoder_built_in_close+0x2e>
   24678:	e8 87 1a 00 00       	callq  26104 <lv_mem_free>

        lv_mem_free(user_data);
   2467d:	48 89 ef             	mov    %rbp,%rdi
   24680:	e8 7f 1a 00 00       	callq  26104 <lv_mem_free>

        dsc->user_data = NULL;
   24685:	48 c7 43 38 00 00 00 	movq   $0x0,0x38(%rbx)
   2468c:	00 
    }
}
   2468d:	58                   	pop    %rax
   2468e:	5b                   	pop    %rbx
   2468f:	5d                   	pop    %rbp
   24690:	c3                   	retq   

0000000000024691 <lv_img_decoder_built_in_open>:
{
   24691:	41 56                	push   %r14
   24693:	41 55                	push   %r13
   24695:	41 54                	push   %r12
   24697:	55                   	push   %rbp
   24698:	53                   	push   %rbx
    if(dsc->src_type == LV_IMG_SRC_FILE) {
   24699:	8a 56 14             	mov    0x14(%rsi),%dl
   2469c:	80 fa 01             	cmp    $0x1,%dl
   2469f:	75 18                	jne    246b9 <lv_img_decoder_built_in_open+0x28>
        LV_LOG_WARN("Image built-in decoder cannot read file because LV_USE_FILESYSTEM = 0");
   246a1:	4c 8d 05 fe f2 00 00 	lea    0xf2fe(%rip),%r8        # 339a6 <_lv_bpp1_opa_table+0x151>
   246a8:	48 8d 0d b1 c3 00 00 	lea    0xc3b1(%rip),%rcx        # 30a60 <__func__.3316>
   246af:	ba 66 01 00 00       	mov    $0x166,%edx
   246b4:	e9 a2 01 00 00       	jmpq   2485b <lv_img_decoder_built_in_open+0x1ca>
    else if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
   246b9:	84 d2                	test   %dl,%dl
   246bb:	48 89 fd             	mov    %rdi,%rbp
   246be:	48 89 f3             	mov    %rsi,%rbx
   246c1:	75 11                	jne    246d4 <lv_img_decoder_built_in_open+0x43>
        if(((lv_img_dsc_t *)dsc->src)->data == NULL) {
   246c3:	48 8b 4e 08          	mov    0x8(%rsi),%rcx
            return LV_RES_INV;
   246c7:	31 c0                	xor    %eax,%eax
        if(((lv_img_dsc_t *)dsc->src)->data == NULL) {
   246c9:	48 83 79 08 00       	cmpq   $0x0,0x8(%rcx)
   246ce:	0f 84 9c 01 00 00    	je     24870 <lv_img_decoder_built_in_open+0x1df>
    lv_img_cf_t cf = dsc->header.cf;
   246d4:	40 8a 7b 18          	mov    0x18(%rbx),%dil
   246d8:	83 e7 1f             	and    $0x1f,%edi
    if(cf == LV_IMG_CF_TRUE_COLOR || cf == LV_IMG_CF_TRUE_COLOR_ALPHA || cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
   246db:	8d 47 fc             	lea    -0x4(%rdi),%eax
   246de:	3c 02                	cmp    $0x2,%al
   246e0:	77 21                	ja     24703 <lv_img_decoder_built_in_open+0x72>
        if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
   246e2:	84 d2                	test   %dl,%dl
   246e4:	75 0e                	jne    246f4 <lv_img_decoder_built_in_open+0x63>
            dsc->img_data = ((lv_img_dsc_t *)dsc->src)->data;
   246e6:	48 8b 43 08          	mov    0x8(%rbx),%rax
   246ea:	48 8b 40 08          	mov    0x8(%rax),%rax
   246ee:	48 89 43 20          	mov    %rax,0x20(%rbx)
   246f2:	eb 08                	jmp    246fc <lv_img_decoder_built_in_open+0x6b>
            dsc->img_data = NULL;
   246f4:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
   246fb:	00 
            return LV_RES_OK;
   246fc:	b0 01                	mov    $0x1,%al
   246fe:	e9 6d 01 00 00       	jmpq   24870 <lv_img_decoder_built_in_open+0x1df>
    else if(cf == LV_IMG_CF_INDEXED_1BIT || cf == LV_IMG_CF_INDEXED_2BIT || cf == LV_IMG_CF_INDEXED_4BIT ||
   24703:	8d 47 f9             	lea    -0x7(%rdi),%eax
   24706:	3c 03                	cmp    $0x3,%al
   24708:	0f 87 22 01 00 00    	ja     24830 <lv_img_decoder_built_in_open+0x19f>
        uint8_t px_size       = lv_img_cf_get_px_size(cf);
   2470e:	40 0f b6 ff          	movzbl %dil,%edi
        uint32_t palette_size = 1 << px_size;
   24712:	41 bd 01 00 00 00    	mov    $0x1,%r13d
        uint8_t px_size       = lv_img_cf_get_px_size(cf);
   24718:	e8 ce bb ff ff       	callq  202eb <lv_img_cf_get_px_size>
        uint32_t palette_size = 1 << px_size;
   2471d:	88 c1                	mov    %al,%cl
   2471f:	41 d3 e5             	shl    %cl,%r13d
        if(dsc->user_data == NULL) {
   24722:	48 83 7b 38 00       	cmpq   $0x0,0x38(%rbx)
   24727:	75 3a                	jne    24763 <lv_img_decoder_built_in_open+0xd2>
            dsc->user_data = lv_mem_alloc(sizeof(lv_img_decoder_built_in_data_t));
   24729:	bf 10 00 00 00       	mov    $0x10,%edi
   2472e:	e8 5e 19 00 00       	callq  26091 <lv_mem_alloc>
            if(dsc->user_data == NULL) {
   24733:	48 85 c0             	test   %rax,%rax
            dsc->user_data = lv_mem_alloc(sizeof(lv_img_decoder_built_in_data_t));
   24736:	48 89 43 38          	mov    %rax,0x38(%rbx)
            if(dsc->user_data == NULL) {
   2473a:	75 21                	jne    2475d <lv_img_decoder_built_in_open+0xcc>
                LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
   2473c:	4c 8d 05 e6 f2 00 00 	lea    0xf2e6(%rip),%r8        # 33a29 <_lv_bpp1_opa_table+0x1d4>
   24743:	48 8d 0d 16 c3 00 00 	lea    0xc316(%rip),%rcx        # 30a60 <__func__.3316>
   2474a:	ba 8d 01 00 00       	mov    $0x18d,%edx
   2474f:	48 8d 35 96 f2 00 00 	lea    0xf296(%rip),%rsi        # 339ec <_lv_bpp1_opa_table+0x197>
   24756:	bf 03 00 00 00       	mov    $0x3,%edi
   2475b:	eb 58                	jmp    247b5 <lv_img_decoder_built_in_open+0x124>
   2475d:	0f 57 c0             	xorps  %xmm0,%xmm0
   24760:	0f 11 00             	movups %xmm0,(%rax)
        lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
   24763:	4c 8b 63 38          	mov    0x38(%rbx),%r12
        user_data->palette                         = lv_mem_alloc(palette_size * sizeof(lv_color_t));
   24767:	45 89 ee             	mov    %r13d,%r14d
   2476a:	4a 8d 3c b5 00 00 00 	lea    0x0(,%r14,4),%rdi
   24771:	00 
   24772:	e8 1a 19 00 00       	callq  26091 <lv_mem_alloc>
        user_data->opa                             = lv_mem_alloc(palette_size * sizeof(lv_opa_t));
   24777:	4c 89 f7             	mov    %r14,%rdi
        user_data->palette                         = lv_mem_alloc(palette_size * sizeof(lv_color_t));
   2477a:	49 89 04 24          	mov    %rax,(%r12)
        user_data->opa                             = lv_mem_alloc(palette_size * sizeof(lv_opa_t));
   2477e:	e8 0e 19 00 00       	callq  26091 <lv_mem_alloc>
        if(user_data->palette == NULL || user_data->opa == NULL) {
   24783:	49 83 3c 24 00       	cmpq   $0x0,(%r12)
        user_data->opa                             = lv_mem_alloc(palette_size * sizeof(lv_opa_t));
   24788:	49 89 44 24 08       	mov    %rax,0x8(%r12)
        if(user_data->palette == NULL || user_data->opa == NULL) {
   2478d:	74 05                	je     24794 <lv_img_decoder_built_in_open+0x103>
   2478f:	48 85 c0             	test   %rax,%rax
   24792:	75 36                	jne    247ca <lv_img_decoder_built_in_open+0x139>
            LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
   24794:	4c 8d 05 8e f2 00 00 	lea    0xf28e(%rip),%r8        # 33a29 <_lv_bpp1_opa_table+0x1d4>
   2479b:	48 8d 0d be c2 00 00 	lea    0xc2be(%rip),%rcx        # 30a60 <__func__.3316>
   247a2:	48 8d 35 43 f2 00 00 	lea    0xf243(%rip),%rsi        # 339ec <_lv_bpp1_opa_table+0x197>
   247a9:	ba 9a 01 00 00       	mov    $0x19a,%edx
   247ae:	bf 03 00 00 00       	mov    $0x3,%edi
   247b3:	31 c0                	xor    %eax,%eax
   247b5:	e8 9c 17 00 00       	callq  25f56 <_lv_log_add>
            lv_img_decoder_built_in_close(decoder, dsc);
   247ba:	48 89 de             	mov    %rbx,%rsi
   247bd:	48 89 ef             	mov    %rbp,%rdi
   247c0:	e8 8a fe ff ff       	callq  2464f <lv_img_decoder_built_in_close>
   247c5:	e9 a4 00 00 00       	jmpq   2486e <lv_img_decoder_built_in_open+0x1dd>
        if(dsc->src_type == LV_IMG_SRC_FILE) {
   247ca:	80 7b 14 01          	cmpb   $0x1,0x14(%rbx)
   247ce:	75 15                	jne    247e5 <lv_img_decoder_built_in_open+0x154>
            LV_LOG_WARN("Image built-in decoder can read the palette because LV_USE_FILESYSTEM = 0");
   247d0:	4c 8d 05 7b f2 00 00 	lea    0xf27b(%rip),%r8        # 33a52 <_lv_bpp1_opa_table+0x1fd>
   247d7:	48 8d 0d 82 c2 00 00 	lea    0xc282(%rip),%rcx        # 30a60 <__func__.3316>
   247de:	ba ab 01 00 00       	mov    $0x1ab,%edx
   247e3:	eb 76                	jmp    2485b <lv_img_decoder_built_in_open+0x1ca>
            lv_color32_t * palette_p = (lv_color32_t *)((lv_img_dsc_t *)dsc->src)->data;
   247e5:	48 8b 43 08          	mov    0x8(%rbx),%rax
   247e9:	48 8b 50 08          	mov    0x8(%rax),%rdx
            for(i = 0; i < palette_size; i++) {
   247ed:	31 c0                	xor    %eax,%eax
   247ef:	41 39 c5             	cmp    %eax,%r13d
   247f2:	0f 86 fc fe ff ff    	jbe    246f4 <lv_img_decoder_built_in_open+0x63>
                user_data->palette[i] = lv_color_make(palette_p[i].ch.red, palette_p[i].ch.green, palette_p[i].ch.blue);
   247f8:	49 8b 0c 24          	mov    (%r12),%rcx
   247fc:	40 8a 74 82 02       	mov    0x2(%rdx,%rax,4),%sil
   24801:	44 8a 04 82          	mov    (%rdx,%rax,4),%r8b
   24805:	40 8a 7c 82 01       	mov    0x1(%rdx,%rax,4),%dil
   2480a:	48 8d 0c 81          	lea    (%rcx,%rax,4),%rcx
   2480e:	44 88 01             	mov    %r8b,(%rcx)
   24811:	40 88 79 01          	mov    %dil,0x1(%rcx)
   24815:	40 88 71 02          	mov    %sil,0x2(%rcx)
   24819:	c6 41 03 ff          	movb   $0xff,0x3(%rcx)
                user_data->opa[i]     = palette_p[i].ch.alpha;
   2481d:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
   24822:	40 8a 74 82 03       	mov    0x3(%rdx,%rax,4),%sil
   24827:	40 88 34 01          	mov    %sil,(%rcx,%rax,1)
   2482b:	48 ff c0             	inc    %rax
   2482e:	eb bf                	jmp    247ef <lv_img_decoder_built_in_open+0x15e>
    else if(cf == LV_IMG_CF_ALPHA_1BIT || cf == LV_IMG_CF_ALPHA_2BIT || cf == LV_IMG_CF_ALPHA_4BIT ||
   24830:	83 ef 0b             	sub    $0xb,%edi
   24833:	40 80 ff 03          	cmp    $0x3,%dil
   24837:	0f 86 b7 fe ff ff    	jbe    246f4 <lv_img_decoder_built_in_open+0x63>
        lv_img_decoder_built_in_close(decoder, dsc);
   2483d:	48 89 de             	mov    %rbx,%rsi
   24840:	48 89 ef             	mov    %rbp,%rdi
   24843:	e8 07 fe ff ff       	callq  2464f <lv_img_decoder_built_in_close>
        LV_LOG_WARN("Image decoder open: unknown color format")
   24848:	4c 8d 05 4d f2 00 00 	lea    0xf24d(%rip),%r8        # 33a9c <_lv_bpp1_opa_table+0x247>
   2484f:	48 8d 0d 0a c2 00 00 	lea    0xc20a(%rip),%rcx        # 30a60 <__func__.3316>
   24856:	ba d2 01 00 00       	mov    $0x1d2,%edx
   2485b:	48 8d 35 8a f1 00 00 	lea    0xf18a(%rip),%rsi        # 339ec <_lv_bpp1_opa_table+0x197>
   24862:	bf 02 00 00 00       	mov    $0x2,%edi
   24867:	31 c0                	xor    %eax,%eax
   24869:	e8 e8 16 00 00       	callq  25f56 <_lv_log_add>
        return LV_RES_INV;
   2486e:	31 c0                	xor    %eax,%eax
}
   24870:	5b                   	pop    %rbx
   24871:	5d                   	pop    %rbp
   24872:	41 5c                	pop    %r12
   24874:	41 5d                	pop    %r13
   24876:	41 5e                	pop    %r14
   24878:	c3                   	retq   

0000000000024879 <lv_img_decoder_built_in_info>:
{
   24879:	55                   	push   %rbp
   2487a:	53                   	push   %rbx
    lv_img_src_t src_type = lv_img_src_get_type(src);
   2487b:	48 89 f7             	mov    %rsi,%rdi
{
   2487e:	48 89 f5             	mov    %rsi,%rbp
   24881:	48 89 d3             	mov    %rdx,%rbx
   24884:	48 83 ec 08          	sub    $0x8,%rsp
    lv_img_src_t src_type = lv_img_src_get_type(src);
   24888:	e8 d6 bd ff ff       	callq  20663 <lv_img_src_get_type>
    if(src_type == LV_IMG_SRC_VARIABLE) {
   2488d:	84 c0                	test   %al,%al
   2488f:	75 45                	jne    248d6 <lv_img_decoder_built_in_info+0x5d>
        lv_img_cf_t cf = ((lv_img_dsc_t *)src)->header.cf;
   24891:	8a 4d 00             	mov    0x0(%rbp),%cl
   24894:	83 e1 1f             	and    $0x1f,%ecx
        if(cf < CF_BUILT_IN_FIRST || cf > CF_BUILT_IN_LAST) return LV_RES_INV;
   24897:	8d 51 fc             	lea    -0x4(%rcx),%edx
   2489a:	80 fa 0a             	cmp    $0xa,%dl
   2489d:	0f 87 87 00 00 00    	ja     2492a <lv_img_decoder_built_in_info+0xb1>
        header->w  = ((lv_img_dsc_t *)src)->header.w;
   248a3:	8b 45 00             	mov    0x0(%rbp),%eax
   248a6:	8b 13                	mov    (%rbx),%edx
   248a8:	25 00 fc 1f 00       	and    $0x1ffc00,%eax
   248ad:	81 e2 ff 03 e0 ff    	and    $0xffe003ff,%edx
   248b3:	09 c2                	or     %eax,%edx
   248b5:	89 13                	mov    %edx,(%rbx)
        header->h  = ((lv_img_dsc_t *)src)->header.h;
   248b7:	66 8b 55 02          	mov    0x2(%rbp),%dx
   248bb:	89 d0                	mov    %edx,%eax
   248bd:	66 8b 53 02          	mov    0x2(%rbx),%dx
   248c1:	83 e0 e0             	and    $0xffffffe0,%eax
   248c4:	83 e2 1f             	and    $0x1f,%edx
   248c7:	09 c2                	or     %eax,%edx
        header->cf = ((lv_img_dsc_t *)src)->header.cf;
   248c9:	8a 03                	mov    (%rbx),%al
        header->h  = ((lv_img_dsc_t *)src)->header.h;
   248cb:	66 89 53 02          	mov    %dx,0x2(%rbx)
        header->cf = ((lv_img_dsc_t *)src)->header.cf;
   248cf:	83 e0 e0             	and    $0xffffffe0,%eax
   248d2:	09 c8                	or     %ecx,%eax
   248d4:	eb 26                	jmp    248fc <lv_img_decoder_built_in_info+0x83>
    else if(src_type == LV_IMG_SRC_SYMBOL) {
   248d6:	3c 02                	cmp    $0x2,%al
   248d8:	75 28                	jne    24902 <lv_img_decoder_built_in_info+0x89>
        header->w = 1;
   248da:	8b 03                	mov    (%rbx),%eax
   248dc:	25 ff 03 e0 ff       	and    $0xffe003ff,%eax
   248e1:	80 cc 04             	or     $0x4,%ah
   248e4:	89 03                	mov    %eax,(%rbx)
        header->h = 1;
   248e6:	66 8b 43 02          	mov    0x2(%rbx),%ax
   248ea:	83 e0 1f             	and    $0x1f,%eax
   248ed:	83 c8 20             	or     $0x20,%eax
   248f0:	66 89 43 02          	mov    %ax,0x2(%rbx)
        header->cf = LV_IMG_CF_ALPHA_1BIT;
   248f4:	8a 03                	mov    (%rbx),%al
   248f6:	83 e0 e0             	and    $0xffffffe0,%eax
   248f9:	83 c8 0b             	or     $0xb,%eax
   248fc:	88 03                	mov    %al,(%rbx)
    return LV_RES_OK;
   248fe:	b0 01                	mov    $0x1,%al
   24900:	eb 28                	jmp    2492a <lv_img_decoder_built_in_info+0xb1>
        LV_LOG_WARN("Image get info found unknown src type");
   24902:	4c 8d 05 bc f1 00 00 	lea    0xf1bc(%rip),%r8        # 33ac5 <_lv_bpp1_opa_table+0x270>
   24909:	48 8d 0d 70 c1 00 00 	lea    0xc170(%rip),%rcx        # 30a80 <__func__.3311>
   24910:	48 8d 35 d5 f0 00 00 	lea    0xf0d5(%rip),%rsi        # 339ec <_lv_bpp1_opa_table+0x197>
   24917:	31 c0                	xor    %eax,%eax
   24919:	ba 33 01 00 00       	mov    $0x133,%edx
   2491e:	bf 02 00 00 00       	mov    $0x2,%edi
   24923:	e8 2e 16 00 00       	callq  25f56 <_lv_log_add>
   24928:	31 c0                	xor    %eax,%eax
}
   2492a:	5a                   	pop    %rdx
   2492b:	5b                   	pop    %rbx
   2492c:	5d                   	pop    %rbp
   2492d:	c3                   	retq   

000000000002492e <lv_img_decoder_built_in_read_line>:
{
   2492e:	41 57                	push   %r15
   24930:	41 56                	push   %r14
   24932:	41 55                	push   %r13
   24934:	41 54                	push   %r12
   24936:	49 89 f4             	mov    %rsi,%r12
   24939:	55                   	push   %rbp
   2493a:	53                   	push   %rbx
   2493b:	48 83 ec 38          	sub    $0x38,%rsp
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
   2493f:	40 8a 7e 18          	mov    0x18(%rsi),%dil
{
   24943:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   2494a:	00 00 
   2494c:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
   24951:	31 c0                	xor    %eax,%eax
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
   24953:	83 e7 1f             	and    $0x1f,%edi
   24956:	8d 47 fc             	lea    -0x4(%rdi),%eax
   24959:	3c 02                	cmp    $0x2,%al
   2495b:	77 37                	ja     24994 <lv_img_decoder_built_in_read_line+0x66>
    lv_res_t res = LV_RES_INV;
   2495d:	31 db                	xor    %ebx,%ebx
        if(dsc->src_type == LV_IMG_SRC_FILE) {
   2495f:	80 7e 14 01          	cmpb   $0x1,0x14(%rsi)
   24963:	0f 85 e5 03 00 00    	jne    24d4e <lv_img_decoder_built_in_read_line+0x420>
    LV_UNUSED(dsc);
    LV_UNUSED(x);
    LV_UNUSED(y);
    LV_UNUSED(len);
    LV_UNUSED(buf);
    LV_LOG_WARN("Image built-in decoder cannot read file because LV_USE_FILESYSTEM = 0");
   24969:	4c 8d 05 36 f0 00 00 	lea    0xf036(%rip),%r8        # 339a6 <_lv_bpp1_opa_table+0x151>
   24970:	48 8d 0d e9 89 00 00 	lea    0x89e9(%rip),%rcx        # 2d360 <__func__.3348>
   24977:	48 8d 35 6e f0 00 00 	lea    0xf06e(%rip),%rsi        # 339ec <_lv_bpp1_opa_table+0x197>
   2497e:	ba 3f 02 00 00       	mov    $0x23f,%edx
   24983:	bf 02 00 00 00       	mov    $0x2,%edi
   24988:	31 c0                	xor    %eax,%eax
   2498a:	e8 c7 15 00 00       	callq  25f56 <_lv_log_add>
   2498f:	e9 ba 03 00 00       	jmpq   24d4e <lv_img_decoder_built_in_read_line+0x420>
            dsc->header.cf == LV_IMG_CF_ALPHA_4BIT || dsc->header.cf == LV_IMG_CF_ALPHA_8BIT) {
   24994:	8d 47 f5             	lea    -0xb(%rdi),%eax
   24997:	89 d3                	mov    %edx,%ebx
   24999:	4d 89 cf             	mov    %r9,%r15
   2499c:	45 89 c6             	mov    %r8d,%r14d
    else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||
   2499f:	3c 03                	cmp    $0x3,%al
   249a1:	0f 87 e0 01 00 00    	ja     24b87 <lv_img_decoder_built_in_read_line+0x259>
{

#if LV_IMG_CF_ALPHA
    const lv_opa_t alpha1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
    const lv_opa_t alpha2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
    const lv_opa_t alpha4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
   249a7:	48 b8 00 11 22 33 44 	movabs $0x7766554433221100,%rax
   249ae:	55 66 77 
        res = lv_img_decoder_built_in_line_alpha(dsc, x, y, len, buf);
   249b1:	0f bf ea             	movswl %dx,%ebp
                                           68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255
                                          };

    /*Simply fill the buffer with the color. Later only the alpha value will be modified.*/
    lv_color_t bg_color = dsc->color;
   249b4:	8b 56 10             	mov    0x10(%rsi),%edx
    const lv_opa_t alpha4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
   249b7:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   249bc:	48 b8 88 99 aa bb cc 	movabs $0xffeeddccbbaa9988,%rax
   249c3:	dd ee ff 
        res = lv_img_decoder_built_in_line_alpha(dsc, x, y, len, buf);
   249c6:	0f bf c9             	movswl %cx,%ecx
    const lv_opa_t alpha4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
   249c9:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    const lv_opa_t alpha1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
   249ce:	66 c7 44 24 12 00 ff 	movw   $0xff00,0x12(%rsp)
    lv_color_t bg_color = dsc->color;
   249d5:	31 c0                	xor    %eax,%eax
    const lv_opa_t alpha2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
   249d7:	c7 44 24 14 00 55 aa 	movl   $0xffaa5500,0x14(%rsp)
   249de:	ff 
    lv_coord_t i;
    for(i = 0; i < len; i++) {
   249df:	66 41 39 c6          	cmp    %ax,%r14w
   249e3:	7e 09                	jle    249ee <lv_img_decoder_built_in_read_line+0xc0>
#elif LV_COLOR_DEPTH == 16
        /*Because of Alpha byte 16 bit color can start on odd address which can cause crash*/
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE] = bg_color.full & 0xFF;
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + 1] = (bg_color.full >> 8) & 0xFF;
#elif LV_COLOR_DEPTH == 32
        *((uint32_t *)&buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE]) = bg_color.full;
   249e5:	41 89 14 87          	mov    %edx,(%r15,%rax,4)
   249e9:	48 ff c0             	inc    %rax
   249ec:	eb f1                	jmp    249df <lv_img_decoder_built_in_read_line+0xb1>
#error "Invalid LV_COLOR_DEPTH. Check it in lv_conf.h"
#endif
    }

    const lv_opa_t * opa_table = NULL;
    uint8_t px_size            = lv_img_cf_get_px_size(dsc->header.cf);
   249ee:	41 8a 7c 24 18       	mov    0x18(%r12),%dil
   249f3:	89 4c 24 0c          	mov    %ecx,0xc(%rsp)
   249f7:	83 e7 1f             	and    $0x1f,%edi
   249fa:	e8 ec b8 ff ff       	callq  202eb <lv_img_cf_get_px_size>
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/

    lv_coord_t w = 0;
    uint32_t ofs = 0;
    int8_t pos   = 0;
    switch(dsc->header.cf) {
   249ff:	41 8a 54 24 18       	mov    0x18(%r12),%dl
   24a04:	8b 4c 24 0c          	mov    0xc(%rsp),%ecx
   24a08:	83 e2 1f             	and    $0x1f,%edx
   24a0b:	80 fa 0c             	cmp    $0xc,%dl
   24a0e:	74 6e                	je     24a7e <lv_img_decoder_built_in_read_line+0x150>
   24a10:	77 46                	ja     24a58 <lv_img_decoder_built_in_read_line+0x12a>
   24a12:	80 fa 0b             	cmp    $0xb,%dl
   24a15:	0f 85 de 00 00 00    	jne    24af9 <lv_img_decoder_built_in_read_line+0x1cb>
        case LV_IMG_CF_ALPHA_1BIT:
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
   24a1b:	41 8b 74 24 18       	mov    0x18(%r12),%esi
            if(dsc->header.w & 0x7) w++;
            ofs += w * y + (x >> 3); /*First pixel*/
            pos       = 7 - (x & 0x7);
            opa_table = alpha1_opa_table;
   24a20:	4c 8d 44 24 12       	lea    0x12(%rsp),%r8
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
   24a25:	c1 ee 0a             	shr    $0xa,%esi
   24a28:	89 f2                	mov    %esi,%edx
   24a2a:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
   24a30:	c1 fa 03             	sar    $0x3,%edx
   24a33:	40 80 e6 07          	and    $0x7,%sil
            if(dsc->header.w & 0x7) w++;
   24a37:	8d 7a 01             	lea    0x1(%rdx),%edi
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
   24a3a:	0f 44 fa             	cmove  %edx,%edi
            ofs += w * y + (x >> 3); /*First pixel*/
   24a3d:	0f bf ff             	movswl %di,%edi
   24a40:	0f af cf             	imul   %edi,%ecx
   24a43:	89 df                	mov    %ebx,%edi
            pos       = 7 - (x & 0x7);
   24a45:	f7 d3                	not    %ebx
            ofs += w * y + (x >> 3); /*First pixel*/
   24a47:	66 c1 ff 03          	sar    $0x3,%di
            pos       = 7 - (x & 0x7);
   24a4b:	83 e3 07             	and    $0x7,%ebx
            ofs += w * y + (x >> 3); /*First pixel*/
   24a4e:	0f bf ff             	movswl %di,%edi
   24a51:	01 cf                	add    %ecx,%edi
   24a53:	e9 a8 00 00 00       	jmpq   24b00 <lv_img_decoder_built_in_read_line+0x1d2>
    switch(dsc->header.cf) {
   24a58:	80 fa 0d             	cmp    $0xd,%dl
   24a5b:	74 5d                	je     24aba <lv_img_decoder_built_in_read_line+0x18c>
   24a5d:	80 fa 0e             	cmp    $0xe,%dl
   24a60:	0f 85 93 00 00 00    	jne    24af9 <lv_img_decoder_built_in_read_line+0x1cb>
            ofs += w * y + (x >> 1); /*First pixel*/
            pos       = 4 - ((x & 0x1) * 4);
            opa_table = alpha4_opa_table;
            break;
        case LV_IMG_CF_ALPHA_8BIT:
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
   24a66:	41 8b 7c 24 18       	mov    0x18(%r12),%edi
            ofs += w * y + x;  /*First pixel*/
            pos = 0;
   24a6b:	31 db                	xor    %ebx,%ebx
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
   24a6d:	c1 ef 0a             	shr    $0xa,%edi
            ofs += w * y + x;  /*First pixel*/
   24a70:	81 e7 ff 07 00 00    	and    $0x7ff,%edi
   24a76:	0f af cf             	imul   %edi,%ecx
   24a79:	8d 3c 29             	lea    (%rcx,%rbp,1),%edi
   24a7c:	eb 7f                	jmp    24afd <lv_img_decoder_built_in_read_line+0x1cf>
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
   24a7e:	41 8b 7c 24 18       	mov    0x18(%r12),%edi
            pos       = 6 - ((x & 0x3) * 2);
   24a83:	f7 d5                	not    %ebp
            opa_table = alpha2_opa_table;
   24a85:	4c 8d 44 24 14       	lea    0x14(%rsp),%r8
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
   24a8a:	c1 ef 0a             	shr    $0xa,%edi
   24a8d:	89 fa                	mov    %edi,%edx
   24a8f:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
   24a95:	c1 fa 02             	sar    $0x2,%edx
   24a98:	40 80 e7 03          	and    $0x3,%dil
            if(dsc->header.w & 0x3) w++;
   24a9c:	8d 72 01             	lea    0x1(%rdx),%esi
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
   24a9f:	0f 44 f2             	cmove  %edx,%esi
            ofs += w * y + (x >> 2); /*First pixel*/
   24aa2:	66 c1 fb 02          	sar    $0x2,%bx
            pos       = 6 - ((x & 0x3) * 2);
   24aa6:	83 e5 03             	and    $0x3,%ebp
            ofs += w * y + (x >> 2); /*First pixel*/
   24aa9:	0f bf fe             	movswl %si,%edi
   24aac:	0f af cf             	imul   %edi,%ecx
   24aaf:	0f bf fb             	movswl %bx,%edi
            pos       = 6 - ((x & 0x3) * 2);
   24ab2:	8d 5c 2d 00          	lea    0x0(%rbp,%rbp,1),%ebx
            ofs += w * y + (x >> 2); /*First pixel*/
   24ab6:	01 cf                	add    %ecx,%edi
   24ab8:	eb 46                	jmp    24b00 <lv_img_decoder_built_in_read_line+0x1d2>
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
   24aba:	41 8b 7c 24 18       	mov    0x18(%r12),%edi
            pos       = 4 - ((x & 0x1) * 4);
   24abf:	4c 8d 44 24 18       	lea    0x18(%rsp),%r8
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
   24ac4:	c1 ef 0a             	shr    $0xa,%edi
   24ac7:	89 fe                	mov    %edi,%esi
   24ac9:	81 e6 ff 07 00 00    	and    $0x7ff,%esi
   24acf:	d1 fe                	sar    %esi
   24ad1:	40 80 e7 01          	and    $0x1,%dil
            if(dsc->header.w & 0x1) w++;
   24ad5:	8d 56 01             	lea    0x1(%rsi),%edx
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
   24ad8:	0f 44 d6             	cmove  %esi,%edx
            ofs += w * y + (x >> 1); /*First pixel*/
   24adb:	0f bf fa             	movswl %dx,%edi
   24ade:	0f af cf             	imul   %edi,%ecx
   24ae1:	89 df                	mov    %ebx,%edi
            pos       = 4 - ((x & 0x1) * 4);
   24ae3:	83 e3 01             	and    $0x1,%ebx
            ofs += w * y + (x >> 1); /*First pixel*/
   24ae6:	66 d1 ff             	sar    %di
   24ae9:	0f bf ff             	movswl %di,%edi
   24aec:	01 cf                	add    %ecx,%edi
            pos       = 4 - ((x & 0x1) * 4);
   24aee:	66 83 fb 01          	cmp    $0x1,%bx
   24af2:	19 db                	sbb    %ebx,%ebx
   24af4:	83 e3 04             	and    $0x4,%ebx
   24af7:	eb 07                	jmp    24b00 <lv_img_decoder_built_in_read_line+0x1d2>
    int8_t pos   = 0;
   24af9:	31 db                	xor    %ebx,%ebx
    uint32_t ofs = 0;
   24afb:	31 ff                	xor    %edi,%edi
    const lv_opa_t * opa_table = NULL;
   24afd:	45 31 c0             	xor    %r8d,%r8d
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
    uint8_t * fs_buf = _lv_mem_buf_get(w);
#endif

    const uint8_t * data_tmp = NULL;
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
   24b00:	41 80 7c 24 14 00    	cmpb   $0x0,0x14(%r12)
   24b06:	75 1f                	jne    24b27 <lv_img_decoder_built_in_read_line+0x1f9>
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
   24b08:	88 c1                	mov    %al,%cl
   24b0a:	ba 01 00 00 00       	mov    $0x1,%edx
        const lv_img_dsc_t * img_dsc = dsc->src;

        data_tmp = img_dsc->data + ofs;
   24b0f:	45 31 c9             	xor    %r9d,%r9d
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
   24b12:	d3 e2                	shl    %cl,%edx
        data_tmp = img_dsc->data + ofs;
   24b14:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];

        pos -= px_size;
        if(pos < 0) {
            pos = 8 - px_size;
   24b19:	41 b2 08             	mov    $0x8,%r10b
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
   24b1c:	ff ca                	dec    %edx
        uint8_t val_act = (*data_tmp & (mask << pos)) >> pos;
   24b1e:	0f b7 d2             	movzwl %dx,%edx
        data_tmp = img_dsc->data + ofs;
   24b21:	48 03 79 08          	add    0x8(%rcx),%rdi
   24b25:	eb 55                	jmp    24b7c <lv_img_decoder_built_in_read_line+0x24e>
        LV_LOG_WARN("Image built-in alpha line reader can't read file because LV_USE_FILESYSTEM = 0");
   24b27:	4c 8d 05 bd ef 00 00 	lea    0xefbd(%rip),%r8        # 33aeb <_lv_bpp1_opa_table+0x296>
   24b2e:	48 8d 0d eb 87 00 00 	lea    0x87eb(%rip),%rcx        # 2d320 <__func__.3377>
   24b35:	ba 95 02 00 00       	mov    $0x295,%edx
   24b3a:	e9 fa 01 00 00       	jmpq   24d39 <lv_img_decoder_built_in_read_line+0x40b>
        uint8_t val_act = (*data_tmp & (mask << pos)) >> pos;
   24b3f:	0f b6 37             	movzbl (%rdi),%esi
   24b42:	88 d9                	mov    %bl,%cl
   24b44:	41 89 d3             	mov    %edx,%r11d
   24b47:	41 d3 e3             	shl    %cl,%r11d
   24b4a:	88 d9                	mov    %bl,%cl
   24b4c:	44 21 de             	and    %r11d,%esi
   24b4f:	d3 fe                	sar    %cl,%esi
   24b51:	89 f1                	mov    %esi,%ecx
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];
   24b53:	41 8a 74 24 18       	mov    0x18(%r12),%sil
   24b58:	83 e6 1f             	and    $0x1f,%esi
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
   24b5b:	40 80 fe 0e          	cmp    $0xe,%sil
   24b5f:	74 07                	je     24b68 <lv_img_decoder_built_in_read_line+0x23a>
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];
   24b61:	0f b6 c9             	movzbl %cl,%ecx
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
   24b64:	41 8a 0c 08          	mov    (%r8,%rcx,1),%cl
        if(pos < 0) {
   24b68:	28 c3                	sub    %al,%bl
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
   24b6a:	43 88 4c 8f 03       	mov    %cl,0x3(%r15,%r9,4)
        if(pos < 0) {
   24b6f:	79 08                	jns    24b79 <lv_img_decoder_built_in_read_line+0x24b>
            pos = 8 - px_size;
   24b71:	44 88 d3             	mov    %r10b,%bl
            data_tmp++;
   24b74:	48 ff c7             	inc    %rdi
            pos = 8 - px_size;
   24b77:	29 c3                	sub    %eax,%ebx
   24b79:	49 ff c1             	inc    %r9
    for(i = 0; i < len; i++) {
   24b7c:	66 45 39 ce          	cmp    %r9w,%r14w
   24b80:	7f bd                	jg     24b3f <lv_img_decoder_built_in_read_line+0x211>
   24b82:	e9 9b 01 00 00       	jmpq   24d22 <lv_img_decoder_built_in_read_line+0x3f4>
            dsc->header.cf == LV_IMG_CF_INDEXED_4BIT || dsc->header.cf == LV_IMG_CF_INDEXED_8BIT) {
   24b87:	8d 47 f9             	lea    -0x7(%rdi),%eax
    else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT || dsc->header.cf == LV_IMG_CF_INDEXED_2BIT ||
   24b8a:	3c 03                	cmp    $0x3,%al
   24b8c:	0f 87 94 01 00 00    	ja     24d26 <lv_img_decoder_built_in_read_line+0x3f8>
static lv_res_t lv_img_decoder_built_in_line_indexed(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                     lv_coord_t len, uint8_t * buf)
{

#if LV_IMG_CF_INDEXED
    uint8_t px_size = lv_img_cf_get_px_size(dsc->header.cf);
   24b92:	40 0f b6 ff          	movzbl %dil,%edi
        res = lv_img_decoder_built_in_line_indexed(dsc, x, y, len, buf);
   24b96:	0f bf ea             	movswl %dx,%ebp
   24b99:	44 0f bf e9          	movswl %cx,%r13d
    uint8_t px_size = lv_img_cf_get_px_size(dsc->header.cf);
   24b9d:	e8 49 b7 ff ff       	callq  202eb <lv_img_cf_get_px_size>
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/

    lv_coord_t w = 0;
    int8_t pos   = 0;
    uint32_t ofs = 0;
    switch(dsc->header.cf) {
   24ba2:	41 8a 54 24 18       	mov    0x18(%r12),%dl
   24ba7:	83 e2 1f             	and    $0x1f,%edx
   24baa:	80 fa 08             	cmp    $0x8,%dl
   24bad:	74 71                	je     24c20 <lv_img_decoder_built_in_read_line+0x2f2>
   24baf:	77 45                	ja     24bf6 <lv_img_decoder_built_in_read_line+0x2c8>
   24bb1:	80 fa 07             	cmp    $0x7,%dl
   24bb4:	0f 85 dc 00 00 00    	jne    24c96 <lv_img_decoder_built_in_read_line+0x368>
        case LV_IMG_CF_INDEXED_1BIT:
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
   24bba:	41 8b 74 24 18       	mov    0x18(%r12),%esi
   24bbf:	c1 ee 0a             	shr    $0xa,%esi
   24bc2:	89 f2                	mov    %esi,%edx
   24bc4:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
   24bca:	c1 fa 03             	sar    $0x3,%edx
   24bcd:	40 80 e6 07          	and    $0x7,%sil
            if(dsc->header.w & 0x7) w++;
   24bd1:	8d 4a 01             	lea    0x1(%rdx),%ecx
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
   24bd4:	0f 44 ca             	cmove  %edx,%ecx
            ofs += w * y + (x >> 3); /*First pixel*/
   24bd7:	89 da                	mov    %ebx,%edx
            ofs += 8;                /*Skip the palette*/
            pos = 7 - (x & 0x7);
   24bd9:	f7 d3                	not    %ebx
            ofs += w * y + (x >> 3); /*First pixel*/
   24bdb:	0f bf c9             	movswl %cx,%ecx
   24bde:	66 c1 fa 03          	sar    $0x3,%dx
            pos = 7 - (x & 0x7);
   24be2:	83 e3 07             	and    $0x7,%ebx
            ofs += w * y + (x >> 3); /*First pixel*/
   24be5:	44 0f af e9          	imul   %ecx,%r13d
   24be9:	0f bf d2             	movswl %dx,%edx
            ofs += 8;                /*Skip the palette*/
   24bec:	41 8d 74 15 08       	lea    0x8(%r13,%rdx,1),%esi
   24bf1:	e9 a4 00 00 00       	jmpq   24c9a <lv_img_decoder_built_in_read_line+0x36c>
    switch(dsc->header.cf) {
   24bf6:	80 fa 09             	cmp    $0x9,%dl
   24bf9:	74 60                	je     24c5b <lv_img_decoder_built_in_read_line+0x32d>
   24bfb:	80 fa 0a             	cmp    $0xa,%dl
   24bfe:	0f 85 92 00 00 00    	jne    24c96 <lv_img_decoder_built_in_read_line+0x368>
            ofs += w * y + (x >> 1); /*First pixel*/
            ofs += 64;               /*Skip the palette*/
            pos = 4 - ((x & 0x1) * 4);
            break;
        case LV_IMG_CF_INDEXED_8BIT:
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
   24c04:	41 8b 4c 24 18       	mov    0x18(%r12),%ecx
   24c09:	c1 e9 0a             	shr    $0xa,%ecx
            ofs += w * y + x;  /*First pixel*/
   24c0c:	81 e1 ff 07 00 00    	and    $0x7ff,%ecx
   24c12:	44 0f af e9          	imul   %ecx,%r13d
            ofs += 1024;       /*Skip the palette*/
   24c16:	42 8d b4 2d 00 04 00 	lea    0x400(%rbp,%r13,1),%esi
   24c1d:	00 
   24c1e:	eb 78                	jmp    24c98 <lv_img_decoder_built_in_read_line+0x36a>
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
   24c20:	41 8b 74 24 18       	mov    0x18(%r12),%esi
            pos = 6 - ((x & 0x3) * 2);
   24c25:	f7 d5                	not    %ebp
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
   24c27:	c1 ee 0a             	shr    $0xa,%esi
   24c2a:	89 f2                	mov    %esi,%edx
   24c2c:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
   24c32:	c1 fa 02             	sar    $0x2,%edx
   24c35:	40 80 e6 03          	and    $0x3,%sil
            if(dsc->header.w & 0x3) w++;
   24c39:	8d 4a 01             	lea    0x1(%rdx),%ecx
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
   24c3c:	0f 44 ca             	cmove  %edx,%ecx
            ofs += w * y + (x >> 2); /*First pixel*/
   24c3f:	66 c1 fb 02          	sar    $0x2,%bx
            pos = 6 - ((x & 0x3) * 2);
   24c43:	83 e5 03             	and    $0x3,%ebp
            ofs += w * y + (x >> 2); /*First pixel*/
   24c46:	0f bf c9             	movswl %cx,%ecx
   24c49:	0f bf db             	movswl %bx,%ebx
   24c4c:	44 0f af e9          	imul   %ecx,%r13d
            ofs += 16;               /*Skip the palette*/
   24c50:	41 8d 74 1d 10       	lea    0x10(%r13,%rbx,1),%esi
            pos = 6 - ((x & 0x3) * 2);
   24c55:	8d 5c 2d 00          	lea    0x0(%rbp,%rbp,1),%ebx
   24c59:	eb 3f                	jmp    24c9a <lv_img_decoder_built_in_read_line+0x36c>
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
   24c5b:	41 8b 74 24 18       	mov    0x18(%r12),%esi
   24c60:	c1 ee 0a             	shr    $0xa,%esi
   24c63:	89 f2                	mov    %esi,%edx
   24c65:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
   24c6b:	d1 fa                	sar    %edx
   24c6d:	40 80 e6 01          	and    $0x1,%sil
            if(dsc->header.w & 0x1) w++;
   24c71:	8d 4a 01             	lea    0x1(%rdx),%ecx
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
   24c74:	0f 44 ca             	cmove  %edx,%ecx
            ofs += w * y + (x >> 1); /*First pixel*/
   24c77:	89 da                	mov    %ebx,%edx
   24c79:	0f bf c9             	movswl %cx,%ecx
   24c7c:	66 d1 fa             	sar    %dx
   24c7f:	44 0f af e9          	imul   %ecx,%r13d
            pos = 4 - ((x & 0x1) * 4);
   24c83:	80 e3 01             	and    $0x1,%bl
            ofs += w * y + (x >> 1); /*First pixel*/
   24c86:	0f bf d2             	movswl %dx,%edx
            pos = 4 - ((x & 0x1) * 4);
   24c89:	0f 94 c3             	sete   %bl
   24c8c:	c1 e3 02             	shl    $0x2,%ebx
            ofs += 64;               /*Skip the palette*/
   24c8f:	41 8d 74 15 40       	lea    0x40(%r13,%rdx,1),%esi
   24c94:	eb 04                	jmp    24c9a <lv_img_decoder_built_in_read_line+0x36c>
    uint32_t ofs = 0;
   24c96:	31 f6                	xor    %esi,%esi
    int8_t pos   = 0;
   24c98:	31 db                	xor    %ebx,%ebx

#if LV_USE_FILESYSTEM
    uint8_t * fs_buf = _lv_mem_buf_get(w);
#endif
    const uint8_t * data_tmp = NULL;
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
   24c9a:	41 80 7c 24 14 00    	cmpb   $0x0,0x14(%r12)
   24ca0:	75 2c                	jne    24cce <lv_img_decoder_built_in_read_line+0x3a0>
        const lv_img_dsc_t * img_dsc = dsc->src;
        data_tmp                     = img_dsc->data + ofs;
   24ca2:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
   24ca7:	88 c1                	mov    %al,%cl
   24ca9:	ba 01 00 00 00       	mov    $0x1,%edx
   24cae:	d3 e2                	shl    %cl,%edx
        data_tmp                     = img_dsc->data + ofs;
   24cb0:	89 f1                	mov    %esi,%ecx
#endif
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] = user_data->opa[val_act];

        pos -= px_size;
        if(pos < 0) {
            pos = 8 - px_size;
   24cb2:	41 b2 08             	mov    $0x8,%r10b
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
   24cb5:	ff ca                	dec    %edx
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
   24cb7:	4d 8b 44 24 38       	mov    0x38(%r12),%r8
        data_tmp                     = img_dsc->data + ofs;
   24cbc:	45 31 c9             	xor    %r9d,%r9d
   24cbf:	48 03 4f 08          	add    0x8(%rdi),%rcx
        uint8_t val_act = (*data_tmp & (mask << pos)) >> pos;
   24cc3:	0f b7 d2             	movzwl %dx,%edx
            pos = 8 - px_size;
   24cc6:	41 29 c2             	sub    %eax,%r10d
        data_tmp                     = img_dsc->data + ofs;
   24cc9:	48 89 cf             	mov    %rcx,%rdi
   24ccc:	eb 4e                	jmp    24d1c <lv_img_decoder_built_in_read_line+0x3ee>
        LV_LOG_WARN("Image built-in indexed line reader can't read file because LV_USE_FILESYSTEM = 0");
   24cce:	4c 8d 05 65 ee 00 00 	lea    0xee65(%rip),%r8        # 33b3a <_lv_bpp1_opa_table+0x2e5>
   24cd5:	48 8d 0d 04 86 00 00 	lea    0x8604(%rip),%rcx        # 2d2e0 <__func__.3402>
   24cdc:	ba eb 02 00 00       	mov    $0x2eb,%edx
   24ce1:	eb 56                	jmp    24d39 <lv_img_decoder_built_in_read_line+0x40b>
        uint8_t val_act = (*data_tmp & (mask << pos)) >> pos;
   24ce3:	0f b6 37             	movzbl (%rdi),%esi
   24ce6:	88 d9                	mov    %bl,%cl
   24ce8:	41 89 d3             	mov    %edx,%r11d
   24ceb:	41 d3 e3             	shl    %cl,%r11d
   24cee:	88 d9                	mov    %bl,%cl
   24cf0:	44 21 de             	and    %r11d,%esi
   24cf3:	d3 fe                	sar    %cl,%esi
        if(pos < 0) {
   24cf5:	28 c3                	sub    %al,%bl
        lv_color_t color = user_data->palette[val_act];
   24cf7:	40 0f b6 ce          	movzbl %sil,%ecx
   24cfb:	49 8b 30             	mov    (%r8),%rsi
   24cfe:	8b 34 8e             	mov    (%rsi,%rcx,4),%esi
        *((uint32_t *)&buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE]) = color.full;
   24d01:	43 89 34 8f          	mov    %esi,(%r15,%r9,4)
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] = user_data->opa[val_act];
   24d05:	49 8b 70 08          	mov    0x8(%r8),%rsi
   24d09:	8a 0c 0e             	mov    (%rsi,%rcx,1),%cl
   24d0c:	43 88 4c 8f 03       	mov    %cl,0x3(%r15,%r9,4)
        if(pos < 0) {
   24d11:	79 06                	jns    24d19 <lv_img_decoder_built_in_read_line+0x3eb>
            pos = 8 - px_size;
   24d13:	44 88 d3             	mov    %r10b,%bl
            data_tmp++;
   24d16:	48 ff c7             	inc    %rdi
   24d19:	49 ff c1             	inc    %r9
    for(i = 0; i < len; i++) {
   24d1c:	66 45 39 ce          	cmp    %r9w,%r14w
   24d20:	7f c1                	jg     24ce3 <lv_img_decoder_built_in_read_line+0x3b5>
        }
    }
#if LV_USE_FILESYSTEM
    _lv_mem_buf_release(fs_buf);
#endif
    return LV_RES_OK;
   24d22:	b3 01                	mov    $0x1,%bl
   24d24:	eb 28                	jmp    24d4e <lv_img_decoder_built_in_read_line+0x420>
        LV_LOG_WARN("Built-in image decoder read not supports the color format");
   24d26:	4c 8d 05 5e ee 00 00 	lea    0xee5e(%rip),%r8        # 33b8b <_lv_bpp1_opa_table+0x336>
   24d2d:	48 8d 0d 6c 86 00 00 	lea    0x866c(%rip),%rcx        # 2d3a0 <__func__.3335>
   24d34:	ba fb 01 00 00       	mov    $0x1fb,%edx
   24d39:	48 8d 35 ac ec 00 00 	lea    0xecac(%rip),%rsi        # 339ec <_lv_bpp1_opa_table+0x197>
   24d40:	bf 02 00 00 00       	mov    $0x2,%edi
   24d45:	31 c0                	xor    %eax,%eax
        return LV_RES_INV;
   24d47:	31 db                	xor    %ebx,%ebx
        LV_LOG_WARN("Built-in image decoder read not supports the color format");
   24d49:	e8 08 12 00 00       	callq  25f56 <_lv_log_add>
}
   24d4e:	88 d8                	mov    %bl,%al
   24d50:	48 8b 5c 24 28       	mov    0x28(%rsp),%rbx
   24d55:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
   24d5c:	00 00 
   24d5e:	74 05                	je     24d65 <lv_img_decoder_built_in_read_line+0x437>
   24d60:	e8 db f8 fd ff       	callq  4640 <__stack_chk_fail@plt>
   24d65:	48 83 c4 38          	add    $0x38,%rsp
   24d69:	5b                   	pop    %rbx
   24d6a:	5d                   	pop    %rbp
   24d6b:	41 5c                	pop    %r12
   24d6d:	41 5d                	pop    %r13
   24d6f:	41 5e                	pop    %r14
   24d71:	41 5f                	pop    %r15
   24d73:	c3                   	retq   

0000000000024d74 <lv_img_decoder_get_info>:
{
   24d74:	41 55                	push   %r13
   24d76:	41 54                	push   %r12
   24d78:	49 89 fd             	mov    %rdi,%r13
   24d7b:	55                   	push   %rbp
   24d7c:	53                   	push   %rbx
    lv_res_t res = LV_RES_INV;
   24d7d:	45 31 e4             	xor    %r12d,%r12d
{
   24d80:	48 89 f3             	mov    %rsi,%rbx
   24d83:	48 83 ec 08          	sub    $0x8,%rsp
    header->h = 0;
   24d87:	66 83 66 02 1f       	andw   $0x1f,0x2(%rsi)
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
   24d8c:	48 8d 3d 1d 30 23 00 	lea    0x23301d(%rip),%rdi        # 257db0 <_lv_img_defoder_ll>
    header->w = 0;
   24d93:	81 26 ff 03 e0 ff    	andl   $0xffe003ff,(%rsi)
    header->cf = LV_IMG_CF_UNKNOWN;
   24d99:	c6 06 00             	movb   $0x0,(%rsi)
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
   24d9c:	e8 ca 0e 00 00       	callq  25c6b <_lv_ll_get_head>
   24da1:	48 89 c5             	mov    %rax,%rbp
   24da4:	48 85 ed             	test   %rbp,%rbp
   24da7:	74 34                	je     24ddd <lv_img_decoder_get_info+0x69>
        if(d->info_cb) {
   24da9:	48 8b 45 00          	mov    0x0(%rbp),%rax
   24dad:	48 85 c0             	test   %rax,%rax
   24db0:	74 14                	je     24dc6 <lv_img_decoder_get_info+0x52>
            res = d->info_cb(d, src, header);
   24db2:	48 89 da             	mov    %rbx,%rdx
   24db5:	4c 89 ee             	mov    %r13,%rsi
   24db8:	48 89 ef             	mov    %rbp,%rdi
   24dbb:	ff d0                	callq  *%rax
            if(res == LV_RES_OK) break;
   24dbd:	3c 01                	cmp    $0x1,%al
            res = d->info_cb(d, src, header);
   24dbf:	41 88 c4             	mov    %al,%r12b
            if(res == LV_RES_OK) break;
   24dc2:	75 05                	jne    24dc9 <lv_img_decoder_get_info+0x55>
   24dc4:	eb 17                	jmp    24ddd <lv_img_decoder_get_info+0x69>
        res = LV_RES_INV;
   24dc6:	45 31 e4             	xor    %r12d,%r12d
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
   24dc9:	48 8d 3d e0 2f 23 00 	lea    0x232fe0(%rip),%rdi        # 257db0 <_lv_img_defoder_ll>
   24dd0:	48 89 ee             	mov    %rbp,%rsi
   24dd3:	e8 ab 0e 00 00       	callq  25c83 <_lv_ll_get_next>
   24dd8:	48 89 c5             	mov    %rax,%rbp
   24ddb:	eb c7                	jmp    24da4 <lv_img_decoder_get_info+0x30>
}
   24ddd:	5a                   	pop    %rdx
   24dde:	44 88 e0             	mov    %r12b,%al
   24de1:	5b                   	pop    %rbx
   24de2:	5d                   	pop    %rbp
   24de3:	41 5c                	pop    %r12
   24de5:	41 5d                	pop    %r13
   24de7:	c3                   	retq   

0000000000024de8 <lv_img_decoder_open>:
{
   24de8:	41 56                	push   %r14
   24dea:	41 55                	push   %r13
   24dec:	49 89 f5             	mov    %rsi,%r13
   24def:	41 54                	push   %r12
   24df1:	55                   	push   %rbp
   24df2:	53                   	push   %rbx
   24df3:	48 89 fb             	mov    %rdi,%rbx
    dsc->color     = color;
   24df6:	89 57 10             	mov    %edx,0x10(%rdi)
    dsc->src_type  = lv_img_src_get_type(src);
   24df9:	48 89 f7             	mov    %rsi,%rdi
   24dfc:	e8 62 b8 ff ff       	callq  20663 <lv_img_src_get_type>
   24e01:	88 43 14             	mov    %al,0x14(%rbx)
    if(dsc->src_type == LV_IMG_SRC_FILE) {
   24e04:	fe c8                	dec    %al
    dsc->user_data = NULL;
   24e06:	48 c7 43 38 00 00 00 	movq   $0x0,0x38(%rbx)
   24e0d:	00 
    if(dsc->src_type == LV_IMG_SRC_FILE) {
   24e0e:	75 27                	jne    24e37 <lv_img_decoder_open+0x4f>
        size_t fnlen = strlen(src);
   24e10:	31 c0                	xor    %eax,%eax
   24e12:	4c 89 ef             	mov    %r13,%rdi
   24e15:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
   24e19:	f2 ae                	repnz scas %es:(%rdi),%al
   24e1b:	48 f7 d1             	not    %rcx
   24e1e:	48 89 cf             	mov    %rcx,%rdi
        dsc->src = lv_mem_alloc(fnlen + 1);
   24e21:	e8 6b 12 00 00       	callq  26091 <lv_mem_alloc>
  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
   24e26:	4c 89 ee             	mov    %r13,%rsi
   24e29:	48 89 43 08          	mov    %rax,0x8(%rbx)
   24e2d:	48 89 c7             	mov    %rax,%rdi
   24e30:	e8 9b f7 fd ff       	callq  45d0 <strcpy@plt>
   24e35:	eb 04                	jmp    24e3b <lv_img_decoder_open+0x53>
        dsc->src       = src;
   24e37:	4c 89 6b 08          	mov    %r13,0x8(%rbx)
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
   24e3b:	48 8d 3d 6e 2f 23 00 	lea    0x232f6e(%rip),%rdi        # 257db0 <_lv_img_defoder_ll>
        res = d->info_cb(d, src, &dsc->header);
   24e42:	4c 8d 73 18          	lea    0x18(%rbx),%r14
    lv_res_t res = LV_RES_INV;
   24e46:	45 31 e4             	xor    %r12d,%r12d
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
   24e49:	e8 1d 0e 00 00       	callq  25c6b <_lv_ll_get_head>
   24e4e:	48 89 c5             	mov    %rax,%rbp
   24e51:	48 85 ed             	test   %rbp,%rbp
   24e54:	74 59                	je     24eaf <lv_img_decoder_open+0xc7>
        if(d->info_cb == NULL || d->open_cb == NULL) continue;
   24e56:	48 8b 45 00          	mov    0x0(%rbp),%rax
   24e5a:	48 85 c0             	test   %rax,%rax
   24e5d:	74 3c                	je     24e9b <lv_img_decoder_open+0xb3>
   24e5f:	48 83 7d 08 00       	cmpq   $0x0,0x8(%rbp)
   24e64:	74 35                	je     24e9b <lv_img_decoder_open+0xb3>
        res = d->info_cb(d, src, &dsc->header);
   24e66:	4c 89 f2             	mov    %r14,%rdx
   24e69:	4c 89 ee             	mov    %r13,%rsi
   24e6c:	48 89 ef             	mov    %rbp,%rdi
   24e6f:	ff d0                	callq  *%rax
        if(res != LV_RES_OK) continue;
   24e71:	3c 01                	cmp    $0x1,%al
        res = d->info_cb(d, src, &dsc->header);
   24e73:	41 88 c4             	mov    %al,%r12b
        if(res != LV_RES_OK) continue;
   24e76:	75 23                	jne    24e9b <lv_img_decoder_open+0xb3>
        dsc->error_msg = NULL;
   24e78:	48 c7 43 30 00 00 00 	movq   $0x0,0x30(%rbx)
   24e7f:	00 
        dsc->img_data  = NULL;
   24e80:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
   24e87:	00 
        res = d->open_cb(d, dsc);
   24e88:	48 89 de             	mov    %rbx,%rsi
        dsc->decoder   = d;
   24e8b:	48 89 2b             	mov    %rbp,(%rbx)
        res = d->open_cb(d, dsc);
   24e8e:	48 89 ef             	mov    %rbp,%rdi
   24e91:	ff 55 08             	callq  *0x8(%rbp)
        if(res == LV_RES_OK) break;
   24e94:	3c 01                	cmp    $0x1,%al
        res = d->open_cb(d, dsc);
   24e96:	41 88 c4             	mov    %al,%r12b
        if(res == LV_RES_OK) break;
   24e99:	74 14                	je     24eaf <lv_img_decoder_open+0xc7>
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
   24e9b:	48 8d 3d 0e 2f 23 00 	lea    0x232f0e(%rip),%rdi        # 257db0 <_lv_img_defoder_ll>
   24ea2:	48 89 ee             	mov    %rbp,%rsi
   24ea5:	e8 d9 0d 00 00       	callq  25c83 <_lv_ll_get_next>
   24eaa:	48 89 c5             	mov    %rax,%rbp
   24ead:	eb a2                	jmp    24e51 <lv_img_decoder_open+0x69>
}
   24eaf:	5b                   	pop    %rbx
   24eb0:	44 88 e0             	mov    %r12b,%al
   24eb3:	5d                   	pop    %rbp
   24eb4:	41 5c                	pop    %r12
   24eb6:	41 5d                	pop    %r13
   24eb8:	41 5e                	pop    %r14
   24eba:	c3                   	retq   

0000000000024ebb <lv_img_decoder_read_line>:
{
   24ebb:	49 89 fb             	mov    %rdi,%r11
    if(dsc->decoder->read_line_cb) res = dsc->decoder->read_line_cb(dsc->decoder, dsc, x, y, len, buf);
   24ebe:	48 8b 3f             	mov    (%rdi),%rdi
   24ec1:	4c 8b 57 10          	mov    0x10(%rdi),%r10
   24ec5:	4d 85 d2             	test   %r10,%r10
   24ec8:	74 15                	je     24edf <lv_img_decoder_read_line+0x24>
   24eca:	0f bf c2             	movswl %dx,%eax
   24ecd:	4d 89 c1             	mov    %r8,%r9
   24ed0:	0f bf d6             	movswl %si,%edx
   24ed3:	44 0f bf c1          	movswl %cx,%r8d
   24ed7:	4c 89 de             	mov    %r11,%rsi
   24eda:	89 c1                	mov    %eax,%ecx
   24edc:	41 ff e2             	jmpq   *%r10
}
   24edf:	31 c0                	xor    %eax,%eax
   24ee1:	c3                   	retq   

0000000000024ee2 <lv_img_decoder_close>:
{
   24ee2:	53                   	push   %rbx
   24ee3:	48 89 fb             	mov    %rdi,%rbx
    if(dsc->decoder) {
   24ee6:	48 8b 3f             	mov    (%rdi),%rdi
   24ee9:	48 85 ff             	test   %rdi,%rdi
   24eec:	74 25                	je     24f13 <lv_img_decoder_close+0x31>
        if(dsc->decoder->close_cb) dsc->decoder->close_cb(dsc->decoder, dsc);
   24eee:	48 8b 47 18          	mov    0x18(%rdi),%rax
   24ef2:	48 85 c0             	test   %rax,%rax
   24ef5:	74 05                	je     24efc <lv_img_decoder_close+0x1a>
   24ef7:	48 89 de             	mov    %rbx,%rsi
   24efa:	ff d0                	callq  *%rax
        if(dsc->src_type == LV_IMG_SRC_FILE) {
   24efc:	80 7b 14 01          	cmpb   $0x1,0x14(%rbx)
   24f00:	75 11                	jne    24f13 <lv_img_decoder_close+0x31>
            lv_mem_free(dsc->src);
   24f02:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
   24f06:	e8 f9 11 00 00       	callq  26104 <lv_mem_free>
            dsc->src = NULL;
   24f0b:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
   24f12:	00 
}
   24f13:	5b                   	pop    %rbx
   24f14:	c3                   	retq   

0000000000024f15 <lv_img_decoder_create>:
{
   24f15:	48 83 ec 08          	sub    $0x8,%rsp
    decoder = _lv_ll_ins_head(&LV_GC_ROOT(_lv_img_defoder_ll));
   24f19:	48 8d 3d 90 2e 23 00 	lea    0x232e90(%rip),%rdi        # 257db0 <_lv_img_defoder_ll>
   24f20:	e8 a2 0c 00 00       	callq  25bc7 <_lv_ll_ins_head>
    if(decoder == NULL) return NULL;
   24f25:	48 85 c0             	test   %rax,%rax
    decoder = _lv_ll_ins_head(&LV_GC_ROOT(_lv_img_defoder_ll));
   24f28:	48 89 c2             	mov    %rax,%rdx
    if(decoder == NULL) return NULL;
   24f2b:	74 0c                	je     24f39 <lv_img_decoder_create+0x24>
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
   24f2d:	b9 0a 00 00 00       	mov    $0xa,%ecx
   24f32:	31 c0                	xor    %eax,%eax
   24f34:	48 89 d7             	mov    %rdx,%rdi
   24f37:	f3 ab                	rep stos %eax,%es:(%rdi)
}
   24f39:	48 89 d0             	mov    %rdx,%rax
   24f3c:	5a                   	pop    %rdx
   24f3d:	c3                   	retq   

0000000000024f3e <lv_img_decoder_set_info_cb>:
    decoder->info_cb = info_cb;
   24f3e:	48 89 37             	mov    %rsi,(%rdi)
}
   24f41:	c3                   	retq   

0000000000024f42 <lv_img_decoder_set_open_cb>:
    decoder->open_cb = open_cb;
   24f42:	48 89 77 08          	mov    %rsi,0x8(%rdi)
}
   24f46:	c3                   	retq   

0000000000024f47 <lv_img_decoder_set_read_line_cb>:
    decoder->read_line_cb = read_line_cb;
   24f47:	48 89 77 10          	mov    %rsi,0x10(%rdi)
}
   24f4b:	c3                   	retq   

0000000000024f4c <lv_img_decoder_set_close_cb>:
    decoder->close_cb = close_cb;
   24f4c:	48 89 77 18          	mov    %rsi,0x18(%rdi)
}
   24f50:	c3                   	retq   

0000000000024f51 <_lv_img_decoder_init>:
    _lv_ll_init(&LV_GC_ROOT(_lv_img_defoder_ll), sizeof(lv_img_decoder_t));
   24f51:	48 8d 3d 58 2e 23 00 	lea    0x232e58(%rip),%rdi        # 257db0 <_lv_img_defoder_ll>
{
   24f58:	53                   	push   %rbx
    _lv_ll_init(&LV_GC_ROOT(_lv_img_defoder_ll), sizeof(lv_img_decoder_t));
   24f59:	be 28 00 00 00       	mov    $0x28,%esi
   24f5e:	e8 4b 0c 00 00       	callq  25bae <_lv_ll_init>
    decoder = lv_img_decoder_create();
   24f63:	e8 ad ff ff ff       	callq  24f15 <lv_img_decoder_create>
    if(decoder == NULL) {
   24f68:	48 85 c0             	test   %rax,%rax
   24f6b:	75 27                	jne    24f94 <_lv_img_decoder_init+0x43>
}
   24f6d:	5b                   	pop    %rbx
        LV_LOG_WARN("lv_img_decoder_init: out of memory");
   24f6e:	4c 8d 05 50 ec 00 00 	lea    0xec50(%rip),%r8        # 33bc5 <_lv_bpp1_opa_table+0x370>
   24f75:	48 8d 0d 24 bb 00 00 	lea    0xbb24(%rip),%rcx        # 30aa0 <__func__.3248>
   24f7c:	48 8d 35 69 ea 00 00 	lea    0xea69(%rip),%rsi        # 339ec <_lv_bpp1_opa_table+0x197>
   24f83:	ba 47 00 00 00       	mov    $0x47,%edx
   24f88:	bf 02 00 00 00       	mov    $0x2,%edi
   24f8d:	31 c0                	xor    %eax,%eax
   24f8f:	e9 c2 0f 00 00       	jmpq   25f56 <_lv_log_add>
    lv_img_decoder_set_info_cb(decoder, lv_img_decoder_built_in_info);
   24f94:	48 8d 35 de f8 ff ff 	lea    -0x722(%rip),%rsi        # 24879 <lv_img_decoder_built_in_info>
   24f9b:	48 89 c7             	mov    %rax,%rdi
   24f9e:	48 89 c3             	mov    %rax,%rbx
   24fa1:	e8 98 ff ff ff       	callq  24f3e <lv_img_decoder_set_info_cb>
    lv_img_decoder_set_open_cb(decoder, lv_img_decoder_built_in_open);
   24fa6:	48 8d 35 e4 f6 ff ff 	lea    -0x91c(%rip),%rsi        # 24691 <lv_img_decoder_built_in_open>
   24fad:	48 89 df             	mov    %rbx,%rdi
   24fb0:	e8 8d ff ff ff       	callq  24f42 <lv_img_decoder_set_open_cb>
    lv_img_decoder_set_read_line_cb(decoder, lv_img_decoder_built_in_read_line);
   24fb5:	48 8d 35 72 f9 ff ff 	lea    -0x68e(%rip),%rsi        # 2492e <lv_img_decoder_built_in_read_line>
   24fbc:	48 89 df             	mov    %rbx,%rdi
   24fbf:	e8 83 ff ff ff       	callq  24f47 <lv_img_decoder_set_read_line_cb>
    lv_img_decoder_set_close_cb(decoder, lv_img_decoder_built_in_close);
   24fc4:	48 89 df             	mov    %rbx,%rdi
   24fc7:	48 8d 35 81 f6 ff ff 	lea    -0x97f(%rip),%rsi        # 2464f <lv_img_decoder_built_in_close>
}
   24fce:	5b                   	pop    %rbx
    lv_img_decoder_set_close_cb(decoder, lv_img_decoder_built_in_close);
   24fcf:	e9 78 ff ff ff       	jmpq   24f4c <lv_img_decoder_set_close_cb>

0000000000024fd4 <lv_disp_drv_init>:
   24fd4:	48 8d 77 04          	lea    0x4(%rdi),%rsi
 * It is used to surly have known values in the fields ant not memory junk.
 * After it you can set the fields.
 * @param driver pointer to driver variable to initialize
 */
void lv_disp_drv_init(lv_disp_drv_t * driver)
{
   24fd8:	48 89 fa             	mov    %rdi,%rdx
   24fdb:	31 c0                	xor    %eax,%eax
   24fdd:	b9 15 00 00 00       	mov    $0x15,%ecx
   24fe2:	48 89 f7             	mov    %rsi,%rdi
   24fe5:	f3 ab                	rep stos %eax,%es:(%rdi)

    driver->flush_cb         = NULL;
    driver->hor_res          = LV_HOR_RES_MAX;
    driver->ver_res          = LV_VER_RES_MAX;
    driver->buffer           = NULL;
    driver->rotated          = 0;
   24fe7:	c6 42 10 00          	movb   $0x0,0x10(%rdx)
    driver->hor_res          = LV_HOR_RES_MAX;
   24feb:	c7 02 e0 01 40 01    	movl   $0x14001e0,(%rdx)
    driver->color_chroma_key = LV_COLOR_TRANSP;
   24ff1:	c7 42 50 00 ff 00 ff 	movl   $0xff00ff00,0x50(%rdx)
    driver->gpu_blend_cb = NULL;
    driver->gpu_fill_cb  = NULL;
#endif

#if LV_USE_USER_DATA
    driver->user_data = NULL;
   24ff8:	48 c7 42 58 00 00 00 	movq   $0x0,0x58(%rdx)
   24fff:	00 
    driver->dpi = LV_DPI;
   25000:	8b 42 10             	mov    0x10(%rdx),%eax
#endif

    driver->set_px_cb = NULL;
   25003:	48 c7 42 28 00 00 00 	movq   $0x0,0x28(%rdx)
   2500a:	00 
    driver->dpi = LV_DPI;
   2500b:	66 25 01 f8          	and    $0xf801,%ax
   2500f:	66 0d 04 01          	or     $0x104,%ax
   25013:	66 89 42 10          	mov    %ax,0x10(%rdx)
}
   25017:	c3                   	retq   

0000000000025018 <lv_disp_buf_init>:
   25018:	4c 8d 4f 1c          	lea    0x1c(%rdi),%r9
 *             It lets LVGL to render next frame into the other buffer while previous is being
 * sent. Set to `NULL` if unused.
 * @param size_in_px_cnt size of the `buf1` and `buf2` in pixel count.
 */
void lv_disp_buf_init(lv_disp_buf_t * disp_buf, void * buf1, void * buf2, uint32_t size_in_px_cnt)
{
   2501c:	49 89 f8             	mov    %rdi,%r8
   2501f:	41 89 ca             	mov    %ecx,%r10d
   25022:	31 c0                	xor    %eax,%eax
   25024:	b9 05 00 00 00       	mov    $0x5,%ecx
   25029:	4c 89 cf             	mov    %r9,%rdi
   2502c:	f3 ab                	rep stos %eax,%es:(%rdi)
    _lv_memset_00(disp_buf, sizeof(lv_disp_buf_t));

    disp_buf->buf1    = buf1;
   2502e:	49 89 30             	mov    %rsi,(%r8)
    disp_buf->buf2    = buf2;
   25031:	49 89 50 08          	mov    %rdx,0x8(%r8)
    disp_buf->buf_act = disp_buf->buf1;
   25035:	49 89 70 10          	mov    %rsi,0x10(%r8)
    disp_buf->size    = size_in_px_cnt;
   25039:	45 89 50 18          	mov    %r10d,0x18(%r8)
}
   2503d:	c3                   	retq   

000000000002503e <lv_disp_get_default>:
 * @return pointer to the default display
 */
lv_disp_t * lv_disp_get_default(void)
{
    return disp_def;
}
   2503e:	48 8b 05 9b 2f 23 00 	mov    0x232f9b(%rip),%rax        # 257fe0 <disp_def>
   25045:	c3                   	retq   

0000000000025046 <lv_disp_get_hor_res>:
 * @param disp pointer to a display (NULL to use the default display)
 * @return the horizontal resolution of the display
 */
lv_coord_t lv_disp_get_hor_res(lv_disp_t * disp)
{
    if(disp == NULL) disp = lv_disp_get_default();
   25046:	48 85 ff             	test   %rdi,%rdi
   25049:	75 26                	jne    25071 <lv_disp_get_hor_res+0x2b>
{
   2504b:	48 83 ec 08          	sub    $0x8,%rsp
    if(disp == NULL) disp = lv_disp_get_default();
   2504f:	e8 ea ff ff ff       	callq  2503e <lv_disp_get_default>
   25054:	48 89 c7             	mov    %rax,%rdi

    if(disp == NULL)
        return LV_HOR_RES_MAX;
   25057:	b8 e0 01 00 00       	mov    $0x1e0,%eax
    if(disp == NULL)
   2505c:	48 85 ff             	test   %rdi,%rdi
   2505f:	74 0e                	je     2506f <lv_disp_get_hor_res+0x29>
    else
        return disp->driver.rotated == 0 ? disp->driver.hor_res : disp->driver.ver_res;
   25061:	f6 47 10 01          	testb  $0x1,0x10(%rdi)
   25065:	75 04                	jne    2506b <lv_disp_get_hor_res+0x25>
   25067:	8b 07                	mov    (%rdi),%eax
   25069:	eb 04                	jmp    2506f <lv_disp_get_hor_res+0x29>
   2506b:	66 8b 47 02          	mov    0x2(%rdi),%ax
}
   2506f:	5a                   	pop    %rdx
   25070:	c3                   	retq   
        return disp->driver.rotated == 0 ? disp->driver.hor_res : disp->driver.ver_res;
   25071:	f6 47 10 01          	testb  $0x1,0x10(%rdi)
   25075:	75 03                	jne    2507a <lv_disp_get_hor_res+0x34>
   25077:	8b 07                	mov    (%rdi),%eax
   25079:	c3                   	retq   
   2507a:	66 8b 47 02          	mov    0x2(%rdi),%ax
}
   2507e:	c3                   	retq   

000000000002507f <lv_disp_get_ver_res>:
 * @param disp pointer to a display (NULL to use the default display)
 * @return the vertical resolution of the display
 */
lv_coord_t lv_disp_get_ver_res(lv_disp_t * disp)
{
    if(disp == NULL) disp = lv_disp_get_default();
   2507f:	48 85 ff             	test   %rdi,%rdi
   25082:	75 26                	jne    250aa <lv_disp_get_ver_res+0x2b>
{
   25084:	48 83 ec 08          	sub    $0x8,%rsp
    if(disp == NULL) disp = lv_disp_get_default();
   25088:	e8 b1 ff ff ff       	callq  2503e <lv_disp_get_default>
   2508d:	48 89 c7             	mov    %rax,%rdi

    if(disp == NULL)
        return LV_VER_RES_MAX;
   25090:	b8 40 01 00 00       	mov    $0x140,%eax
    if(disp == NULL)
   25095:	48 85 ff             	test   %rdi,%rdi
   25098:	74 0e                	je     250a8 <lv_disp_get_ver_res+0x29>
    else
        return disp->driver.rotated == 0 ? disp->driver.ver_res : disp->driver.hor_res;
   2509a:	f6 47 10 01          	testb  $0x1,0x10(%rdi)
   2509e:	75 06                	jne    250a6 <lv_disp_get_ver_res+0x27>
   250a0:	66 8b 47 02          	mov    0x2(%rdi),%ax
   250a4:	eb 02                	jmp    250a8 <lv_disp_get_ver_res+0x29>
   250a6:	8b 07                	mov    (%rdi),%eax
}
   250a8:	5a                   	pop    %rdx
   250a9:	c3                   	retq   
        return disp->driver.rotated == 0 ? disp->driver.ver_res : disp->driver.hor_res;
   250aa:	f6 47 10 01          	testb  $0x1,0x10(%rdi)
   250ae:	75 05                	jne    250b5 <lv_disp_get_ver_res+0x36>
   250b0:	66 8b 47 02          	mov    0x2(%rdi),%ax
   250b4:	c3                   	retq   
   250b5:	8b 07                	mov    (%rdi),%eax
}
   250b7:	c3                   	retq   

00000000000250b8 <lv_disp_get_dpi>:
 * @param disp pointer to a display (NULL to use the default display)
 * @return dpi of the display
 */
lv_coord_t lv_disp_get_dpi(lv_disp_t * disp)
{
    if(disp == NULL) disp = lv_disp_get_default();
   250b8:	48 85 ff             	test   %rdi,%rdi
   250bb:	75 20                	jne    250dd <lv_disp_get_dpi+0x25>
{
   250bd:	48 83 ec 08          	sub    $0x8,%rsp
    if(disp == NULL) disp = lv_disp_get_default();
   250c1:	e8 78 ff ff ff       	callq  2503e <lv_disp_get_default>
    if(disp == NULL) return LV_DPI;  /*Do not return 0 because it might be a divider*/
   250c6:	48 85 c0             	test   %rax,%rax
   250c9:	ba 82 00 00 00       	mov    $0x82,%edx
   250ce:	74 1b                	je     250eb <lv_disp_get_dpi+0x33>
    return disp->driver.dpi;
   250d0:	8b 50 10             	mov    0x10(%rax),%edx
   250d3:	66 d1 ea             	shr    %dx
   250d6:	66 81 e2 ff 03       	and    $0x3ff,%dx
   250db:	eb 0e                	jmp    250eb <lv_disp_get_dpi+0x33>
   250dd:	8b 57 10             	mov    0x10(%rdi),%edx
   250e0:	66 d1 ea             	shr    %dx
   250e3:	66 81 e2 ff 03       	and    $0x3ff,%dx
}
   250e8:	89 d0                	mov    %edx,%eax
   250ea:	c3                   	retq   
   250eb:	89 d0                	mov    %edx,%eax
   250ed:	5a                   	pop    %rdx
   250ee:	c3                   	retq   

00000000000250ef <lv_disp_flush_ready>:
    if(disp_drv->screen_transp) {
        _lv_memset_00(disp_drv->buffer->buf_act, disp_drv->buffer->size * sizeof(lv_color32_t));
    }
#endif

    disp_drv->buffer->flushing = 0;
   250ef:	48 8b 47 08          	mov    0x8(%rdi),%rax
   250f3:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%rax)
    disp_drv->buffer->flushing_last = 0;
   250fa:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
}
   25101:	c3                   	retq   

0000000000025102 <lv_disp_get_buf>:
 * @param disp pointer to a display
 * @return pointer to the internal buffers
 */
lv_disp_buf_t * lv_disp_get_buf(lv_disp_t * disp)
{
    return disp->driver.buffer;
   25102:	48 8b 47 08          	mov    0x8(%rdi),%rax
}
   25106:	c3                   	retq   

0000000000025107 <lv_disp_get_inv_buf_size>:
 * Get the number of areas in the buffer
 * @return number of invalid areas
 */
uint16_t lv_disp_get_inv_buf_size(lv_disp_t * disp)
{
    return disp->inv_p;
   25107:	66 8b 87 d2 01 00 00 	mov    0x1d2(%rdi),%ax
   2510e:	66 25 ff 03          	and    $0x3ff,%ax
}
   25112:	c3                   	retq   

0000000000025113 <_lv_disp_pop_from_inv_buf>:
 * @param num number of areas to delete
 */
void _lv_disp_pop_from_inv_buf(lv_disp_t * disp, uint16_t num)
{

    if(disp->inv_p < num)
   25113:	66 8b 97 d2 01 00 00 	mov    0x1d2(%rdi),%dx
   2511a:	0f b7 ce             	movzwl %si,%ecx
   2511d:	89 d0                	mov    %edx,%eax
        disp->inv_p = 0;
   2511f:	66 81 e2 00 fc       	and    $0xfc00,%dx
    if(disp->inv_p < num)
   25124:	66 25 ff 03          	and    $0x3ff,%ax
   25128:	44 0f b7 c0          	movzwl %ax,%r8d
        disp->inv_p = 0;
   2512c:	29 f0                	sub    %esi,%eax
   2512e:	66 25 ff 03          	and    $0x3ff,%ax
   25132:	09 d0                	or     %edx,%eax
   25134:	41 39 c8             	cmp    %ecx,%r8d
   25137:	0f 4c c2             	cmovl  %edx,%eax
   2513a:	66 89 87 d2 01 00 00 	mov    %ax,0x1d2(%rdi)
    else
        disp->inv_p -= num;
}
   25141:	c3                   	retq   

0000000000025142 <lv_disp_is_double_buf>:
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_double_buf(lv_disp_t * disp)
{
    if(disp->driver.buffer->buf1 && disp->driver.buffer->buf2)
   25142:	48 8b 57 08          	mov    0x8(%rdi),%rdx
        return true;
    else
        return false;
   25146:	31 c0                	xor    %eax,%eax
    if(disp->driver.buffer->buf1 && disp->driver.buffer->buf2)
   25148:	48 83 3a 00          	cmpq   $0x0,(%rdx)
   2514c:	74 08                	je     25156 <lv_disp_is_double_buf+0x14>
   2514e:	48 83 7a 08 00       	cmpq   $0x0,0x8(%rdx)
   25153:	0f 95 c0             	setne  %al
}
   25156:	c3                   	retq   

0000000000025157 <lv_disp_is_true_double_buf>:
 * `size` is screen sized)
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_true_double_buf(lv_disp_t * disp)
{
   25157:	41 54                	push   %r12
   25159:	55                   	push   %rbp
   2515a:	48 89 fd             	mov    %rdi,%rbp
   2515d:	53                   	push   %rbx
    uint32_t scr_size = disp->driver.hor_res * disp->driver.ver_res;
   2515e:	44 0f bf 67 02       	movswl 0x2(%rdi),%r12d
   25163:	0f bf 1f             	movswl (%rdi),%ebx

    if(lv_disp_is_double_buf(disp) && disp->driver.buffer->size == scr_size) {
   25166:	e8 d7 ff ff ff       	callq  25142 <lv_disp_is_double_buf>
   2516b:	84 c0                	test   %al,%al
   2516d:	74 0e                	je     2517d <lv_disp_is_true_double_buf+0x26>
   2516f:	48 8b 45 08          	mov    0x8(%rbp),%rax
    uint32_t scr_size = disp->driver.hor_res * disp->driver.ver_res;
   25173:	41 0f af dc          	imul   %r12d,%ebx
    if(lv_disp_is_double_buf(disp) && disp->driver.buffer->size == scr_size) {
   25177:	39 58 18             	cmp    %ebx,0x18(%rax)
   2517a:	0f 94 c0             	sete   %al
        return true;
    }
    else {
        return false;
    }
}
   2517d:	5b                   	pop    %rbx
   2517e:	5d                   	pop    %rbp
   2517f:	41 5c                	pop    %r12
   25181:	c3                   	retq   

0000000000025182 <lv_disp_drv_register>:
{
   25182:	55                   	push   %rbp
   25183:	53                   	push   %rbx
   25184:	48 89 fd             	mov    %rdi,%rbp
   25187:	48 83 ec 08          	sub    $0x8,%rsp
    lv_disp_t * disp = _lv_ll_ins_head(&LV_GC_ROOT(_lv_disp_ll));
   2518b:	48 8d 3d 5e 2c 23 00 	lea    0x232c5e(%rip),%rdi        # 257df0 <_lv_disp_ll>
   25192:	e8 30 0a 00 00       	callq  25bc7 <_lv_ll_ins_head>
    if(!disp) {
   25197:	48 85 c0             	test   %rax,%rax
   2519a:	75 07                	jne    251a3 <lv_disp_drv_register+0x21>
        return NULL;
   2519c:	31 db                	xor    %ebx,%ebx
   2519e:	e9 6d 01 00 00       	jmpq   25310 <lv_disp_drv_register+0x18e>
   251a3:	48 89 c3             	mov    %rax,%rbx
   251a6:	b9 76 00 00 00       	mov    $0x76,%ecx
   251ab:	31 c0                	xor    %eax,%eax
   251ad:	48 89 df             	mov    %rbx,%rdi
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
   251b0:	48 89 ee             	mov    %rbp,%rsi
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
   251b3:	f3 ab                	rep stos %eax,%es:(%rdi)
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
   251b5:	b9 18 00 00 00       	mov    $0x18,%ecx
   251ba:	48 89 df             	mov    %rbx,%rdi
   251bd:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
    _lv_ll_init(&disp->scr_ll, sizeof(lv_obj_t));
   251bf:	48 8d 7b 68          	lea    0x68(%rbx),%rdi
   251c3:	be 68 00 00 00       	mov    $0x68,%esi
   251c8:	e8 e1 09 00 00       	callq  25bae <_lv_ll_init>
    if(disp_def == NULL) disp_def = disp;
   251cd:	48 83 3d 0b 2e 23 00 	cmpq   $0x0,0x232e0b(%rip)        # 257fe0 <disp_def>
   251d4:	00 
    disp->last_activity_time = 0;
   251d5:	c7 83 d4 01 00 00 00 	movl   $0x0,0x1d4(%rbx)
   251dc:	00 00 00 
    if(disp_def == NULL) disp_def = disp;
   251df:	75 07                	jne    251e8 <lv_disp_drv_register+0x66>
   251e1:	48 89 1d f8 2d 23 00 	mov    %rbx,0x232df8(%rip)        # 257fe0 <disp_def>
    disp->refr_task = lv_task_create(_lv_disp_refr_task, LV_DISP_DEF_REFR_PERIOD, LV_REFR_TASK_PRIO, disp);
   251e8:	48 8d 3d 7d 88 ff ff 	lea    -0x7783(%rip),%rdi        # 1da6c <_lv_disp_refr_task>
   251ef:	48 89 d9             	mov    %rbx,%rcx
   251f2:	ba 03 00 00 00       	mov    $0x3,%edx
   251f7:	be 1e 00 00 00       	mov    $0x1e,%esi
    lv_disp_t * disp_def_tmp = disp_def;
   251fc:	48 8b 2d dd 2d 23 00 	mov    0x232ddd(%rip),%rbp        # 257fe0 <disp_def>
    disp_def                 = disp; /*Temporarily change the default screen to create the default screens on the
   25203:	48 89 1d d6 2d 23 00 	mov    %rbx,0x232dd6(%rip)        # 257fe0 <disp_def>
    disp->refr_task = lv_task_create(_lv_disp_refr_task, LV_DISP_DEF_REFR_PERIOD, LV_REFR_TASK_PRIO, disp);
   2520a:	e8 09 15 00 00       	callq  26718 <lv_task_create>
    if(disp->refr_task == NULL) return NULL;
   2520f:	48 85 c0             	test   %rax,%rax
    disp->refr_task = lv_task_create(_lv_disp_refr_task, LV_DISP_DEF_REFR_PERIOD, LV_REFR_TASK_PRIO, disp);
   25212:	48 89 43 60          	mov    %rax,0x60(%rbx)
    if(disp->refr_task == NULL) return NULL;
   25216:	74 84                	je     2519c <lv_disp_drv_register+0x1a>
    disp->inv_p = 0;
   25218:	66 81 a3 d2 01 00 00 	andw   $0xfc00,0x1d2(%rbx)
   2521f:	00 fc 
    disp->bg_color = LV_COLOR_WHITE;
   25221:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
   25226:	31 f6                	xor    %esi,%esi
   25228:	31 ff                	xor    %edi,%edi
    disp->last_activity_time = 0;
   2522a:	c7 83 d4 01 00 00 00 	movl   $0x0,0x1d4(%rbx)
   25231:	00 00 00 
    disp->bg_color = LV_COLOR_WHITE;
   25234:	48 89 83 a4 00 00 00 	mov    %rax,0xa4(%rbx)
    disp->bg_img = NULL;
   2523b:	c7 83 ac 00 00 00 00 	movl   $0x0,0xac(%rbx)
   25242:	00 00 00 
   25245:	c6 83 b0 00 00 00 ff 	movb   $0xff,0xb0(%rbx)
    disp->prev_scr  = NULL;
   2524c:	48 c7 83 88 00 00 00 	movq   $0x0,0x88(%rbx)
   25253:	00 00 00 00 
    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
   25257:	e8 3c 5e ff ff       	callq  1b098 <lv_obj_create>
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
   2525c:	31 f6                	xor    %esi,%esi
   2525e:	31 ff                	xor    %edi,%edi
    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
   25260:	48 89 83 80 00 00 00 	mov    %rax,0x80(%rbx)
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
   25267:	e8 2c 5e ff ff       	callq  1b098 <lv_obj_create>
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create sys layer on the display*/
   2526c:	31 f6                	xor    %esi,%esi
   2526e:	31 ff                	xor    %edi,%edi
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
   25270:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create sys layer on the display*/
   25277:	e8 1c 5e ff ff       	callq  1b098 <lv_obj_create>
    lv_obj_reset_style_list(disp->top_layer, LV_OBJ_PART_MAIN);
   2527c:	48 8b bb 90 00 00 00 	mov    0x90(%rbx),%rdi
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create sys layer on the display*/
   25283:	48 89 83 98 00 00 00 	mov    %rax,0x98(%rbx)
    lv_obj_reset_style_list(disp->top_layer, LV_OBJ_PART_MAIN);
   2528a:	31 f6                	xor    %esi,%esi
   2528c:	e8 3e 70 ff ff       	callq  1c2cf <lv_obj_reset_style_list>
    lv_obj_reset_style_list(disp->sys_layer, LV_OBJ_PART_MAIN);
   25291:	48 8b bb 98 00 00 00 	mov    0x98(%rbx),%rdi
   25298:	31 f6                	xor    %esi,%esi
   2529a:	e8 30 70 ff ff       	callq  1c2cf <lv_obj_reset_style_list>
    lv_obj_set_click(disp->top_layer, false);
   2529f:	48 8b bb 90 00 00 00 	mov    0x90(%rbx),%rdi
   252a6:	31 f6                	xor    %esi,%esi
   252a8:	e8 e9 53 ff ff       	callq  1a696 <lv_obj_set_click>
    lv_obj_set_click(disp->sys_layer, false);
   252ad:	48 8b bb 98 00 00 00 	mov    0x98(%rbx),%rdi
   252b4:	31 f6                	xor    %esi,%esi
   252b6:	e8 db 53 ff ff       	callq  1a696 <lv_obj_set_click>
    lv_obj_invalidate(disp->act_scr);
   252bb:	48 8b bb 80 00 00 00 	mov    0x80(%rbx),%rdi
   252c2:	e8 eb 59 ff ff       	callq  1acb2 <lv_obj_invalidate>
    lv_task_ready(disp->refr_task); /*Be sure the screen will be refreshed immediately on start up*/
   252c7:	48 8b 7b 60          	mov    0x60(%rbx),%rdi
    disp_def = disp_def_tmp; /*Revert the default display*/
   252cb:	48 89 2d 0e 2d 23 00 	mov    %rbp,0x232d0e(%rip)        # 257fe0 <disp_def>
    lv_task_ready(disp->refr_task); /*Be sure the screen will be refreshed immediately on start up*/
   252d2:	e8 93 14 00 00       	callq  2676a <lv_task_ready>
    if(lv_disp_is_true_double_buf(disp) && disp->driver.set_px_cb) {
   252d7:	48 89 df             	mov    %rbx,%rdi
   252da:	e8 78 fe ff ff       	callq  25157 <lv_disp_is_true_double_buf>
   252df:	84 c0                	test   %al,%al
   252e1:	74 2d                	je     25310 <lv_disp_drv_register+0x18e>
   252e3:	48 83 7b 28 00       	cmpq   $0x0,0x28(%rbx)
   252e8:	74 26                	je     25310 <lv_disp_drv_register+0x18e>
        LV_LOG_ERROR("Can't handle 2 screen sized buffers with set_px_cb. Display will not be refreshed.");
   252ea:	4c 8d 05 f7 e8 00 00 	lea    0xe8f7(%rip),%r8        # 33be8 <_lv_bpp1_opa_table+0x393>
   252f1:	48 8d 0d c8 b7 00 00 	lea    0xb7c8(%rip),%rcx        # 30ac0 <__func__.5734>
   252f8:	48 8d 35 3c e9 00 00 	lea    0xe93c(%rip),%rsi        # 33c3b <_lv_bpp1_opa_table+0x3e6>
   252ff:	ba ac 00 00 00       	mov    $0xac,%edx
   25304:	bf 03 00 00 00       	mov    $0x3,%edi
   25309:	31 c0                	xor    %eax,%eax
   2530b:	e8 46 0c 00 00       	callq  25f56 <_lv_log_add>
}
   25310:	48 89 d8             	mov    %rbx,%rax
   25313:	5a                   	pop    %rdx
   25314:	5b                   	pop    %rbx
   25315:	5d                   	pop    %rbp
   25316:	c3                   	retq   

0000000000025317 <lv_indev_drv_init>:
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
   25317:	31 c0                	xor    %eax,%eax
   25319:	b9 0c 00 00 00       	mov    $0xc,%ecx
 * It is used to surly have known values in the fields ant not memory junk.
 * After it you can set the fields.
 * @param driver pointer to driver variable to initialize
 */
void lv_indev_drv_init(lv_indev_drv_t * driver)
{
   2531e:	48 89 fa             	mov    %rdi,%rdx
   25321:	f3 ab                	rep stos %eax,%es:(%rdi)
    _lv_memset_00(driver, sizeof(lv_indev_drv_t));

    driver->type                 = LV_INDEV_TYPE_NONE;
    driver->drag_limit           = LV_INDEV_DEF_DRAG_LIMIT;
   25323:	48 b8 0a 0a 03 32 90 	movabs $0x64019032030a0a,%rax
   2532a:	01 64 00 
   2532d:	48 89 42 30          	mov    %rax,0x30(%rdx)
    driver->drag_throw           = LV_INDEV_DEF_DRAG_THROW;
    driver->long_press_time      = LV_INDEV_DEF_LONG_PRESS_TIME;
    driver->long_press_rep_time  = LV_INDEV_DEF_LONG_PRESS_REP_TIME;
    driver->gesture_limit        = LV_INDEV_DEF_GESTURE_LIMIT;
    driver->gesture_min_velocity = LV_INDEV_DEF_GESTURE_MIN_VELOCITY;
}
   25331:	c3                   	retq   

0000000000025332 <lv_indev_drv_register>:
 * Register an initialized input device driver.
 * @param driver pointer to an initialized 'lv_indev_drv_t' variable (can be local variable)
 * @return pointer to the new input device or NULL on error
 */
lv_indev_t * lv_indev_drv_register(lv_indev_drv_t * driver)
{
   25332:	55                   	push   %rbp
   25333:	53                   	push   %rbx
   25334:	48 89 fd             	mov    %rdi,%rbp
   25337:	48 83 ec 08          	sub    $0x8,%rsp

    if(driver->disp == NULL) driver->disp = lv_disp_get_default();
   2533b:	48 83 7f 20 00       	cmpq   $0x0,0x20(%rdi)
   25340:	75 09                	jne    2534b <lv_indev_drv_register+0x19>
   25342:	e8 f7 fc ff ff       	callq  2503e <lv_disp_get_default>
   25347:	48 89 45 20          	mov    %rax,0x20(%rbp)

    if(driver->disp == NULL) {
   2534b:	48 83 7d 20 00       	cmpq   $0x0,0x20(%rbp)
   25350:	75 2a                	jne    2537c <lv_indev_drv_register+0x4a>
        LV_LOG_WARN("lv_indev_drv_register: no display registered hence can't attach the indev to "
   25352:	4c 8d 05 1b e9 00 00 	lea    0xe91b(%rip),%r8        # 33c74 <_lv_bpp1_opa_table+0x41f>
   25359:	48 8d 0d 80 b7 00 00 	lea    0xb780(%rip),%rcx        # 30ae0 <__func__.5691>
   25360:	48 8d 35 64 e9 00 00 	lea    0xe964(%rip),%rsi        # 33ccb <_lv_bpp1_opa_table+0x476>
   25367:	ba 4d 00 00 00       	mov    $0x4d,%edx
   2536c:	bf 02 00 00 00       	mov    $0x2,%edi
   25371:	31 c0                	xor    %eax,%eax
   25373:	e8 de 0b 00 00       	callq  25f56 <_lv_log_add>
                    "a display");
        return NULL;
   25378:	31 db                	xor    %ebx,%ebx
   2537a:	eb 72                	jmp    253ee <lv_indev_drv_register+0xbc>
    }

    lv_indev_t * indev = _lv_ll_ins_head(&LV_GC_ROOT(_lv_indev_ll));
   2537c:	48 8d 3d 4d 2a 23 00 	lea    0x232a4d(%rip),%rdi        # 257dd0 <_lv_indev_ll>
   25383:	e8 3f 08 00 00       	callq  25bc7 <_lv_ll_ins_head>
    if(!indev) {
   25388:	48 85 c0             	test   %rax,%rax
    lv_indev_t * indev = _lv_ll_ins_head(&LV_GC_ROOT(_lv_indev_ll));
   2538b:	48 89 c3             	mov    %rax,%rbx
    if(!indev) {
   2538e:	74 5e                	je     253ee <lv_indev_drv_register+0xbc>
   25390:	31 c0                	xor    %eax,%eax
   25392:	b9 28 00 00 00       	mov    $0x28,%ecx
   25397:	48 89 df             	mov    %rbx,%rdi
   2539a:	f3 ab                	rep stos %eax,%es:(%rdi)
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
   2539c:	48 89 ee             	mov    %rbp,%rsi
   2539f:	b9 0e 00 00 00       	mov    $0xe,%ecx
   253a4:	48 89 df             	mov    %rbx,%rdi
    indev->proc.reset_query = 1;
    indev->cursor           = NULL;
    indev->group            = NULL;
    indev->btn_points       = NULL;

    indev->driver.read_task = lv_task_create(_lv_indev_read_task, LV_INDEV_DEF_READ_PERIOD, LV_TASK_PRIO_HIGH, indev);
   253a7:	ba 04 00 00 00       	mov    $0x4,%edx
   253ac:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
   253ae:	48 8d 3d ed 4e ff ff 	lea    -0xb113(%rip),%rdi        # 1a2a2 <_lv_indev_read_task>
    indev->cursor           = NULL;
   253b5:	48 c7 83 88 00 00 00 	movq   $0x0,0x88(%rbx)
   253bc:	00 00 00 00 
    indev->driver.read_task = lv_task_create(_lv_indev_read_task, LV_INDEV_DEF_READ_PERIOD, LV_TASK_PRIO_HIGH, indev);
   253c0:	48 89 d9             	mov    %rbx,%rcx
    indev->group            = NULL;
   253c3:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
   253ca:	00 00 00 00 
    indev->btn_points       = NULL;
   253ce:	48 c7 83 98 00 00 00 	movq   $0x0,0x98(%rbx)
   253d5:	00 00 00 00 
    indev->driver.read_task = lv_task_create(_lv_indev_read_task, LV_INDEV_DEF_READ_PERIOD, LV_TASK_PRIO_HIGH, indev);
   253d9:	be 1e 00 00 00       	mov    $0x1e,%esi
    indev->proc.reset_query = 1;
   253de:	80 8b 80 00 00 00 02 	orb    $0x2,0x80(%rbx)
    indev->driver.read_task = lv_task_create(_lv_indev_read_task, LV_INDEV_DEF_READ_PERIOD, LV_TASK_PRIO_HIGH, indev);
   253e5:	e8 2e 13 00 00       	callq  26718 <lv_task_create>
   253ea:	48 89 43 28          	mov    %rax,0x28(%rbx)

    return indev;
}
   253ee:	48 89 d8             	mov    %rbx,%rax
   253f1:	5a                   	pop    %rdx
   253f2:	5b                   	pop    %rbx
   253f3:	5d                   	pop    %rbp
   253f4:	c3                   	retq   

00000000000253f5 <lv_indev_get_next>:
 * @return the next input devise or NULL if no more. Give the first input device when the parameter
 * is NULL
 */
lv_indev_t * lv_indev_get_next(lv_indev_t * indev)
{
    if(indev == NULL)
   253f5:	48 85 ff             	test   %rdi,%rdi
{
   253f8:	48 89 fe             	mov    %rdi,%rsi
   253fb:	48 8d 3d ce 29 23 00 	lea    0x2329ce(%rip),%rdi        # 257dd0 <_lv_indev_ll>
    if(indev == NULL)
   25402:	75 05                	jne    25409 <lv_indev_get_next+0x14>
        return _lv_ll_get_head(&LV_GC_ROOT(_lv_indev_ll));
   25404:	e9 62 08 00 00       	jmpq   25c6b <_lv_ll_get_head>
    else
        return _lv_ll_get_next(&LV_GC_ROOT(_lv_indev_ll), indev);
   25409:	e9 75 08 00 00       	jmpq   25c83 <_lv_ll_get_next>

000000000002540e <_lv_indev_read>:
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
   2540e:	0f 57 c0             	xorps  %xmm0,%xmm0
   25411:	0f 11 06             	movups %xmm0,(%rsi)

    _lv_memset_00(data, sizeof(lv_indev_data_t));

    /* For touchpad sometimes users don't the last pressed coordinate on release.
     * So be sure a coordinates are initialized to the last point */
    if(indev->driver.type == LV_INDEV_TYPE_POINTER) {
   25414:	8a 07                	mov    (%rdi),%al
   25416:	3c 01                	cmp    $0x1,%al
   25418:	75 10                	jne    2542a <_lv_indev_read+0x1c>
        data->point.x = indev->proc.types.pointer.act_point.x;
   2541a:	8b 47 40             	mov    0x40(%rdi),%eax
   2541d:	66 89 06             	mov    %ax,(%rsi)
        data->point.y = indev->proc.types.pointer.act_point.y;
   25420:	66 8b 47 42          	mov    0x42(%rdi),%ax
   25424:	66 89 46 02          	mov    %ax,0x2(%rsi)
   25428:	eb 1d                	jmp    25447 <_lv_indev_read+0x39>
    }
    /*Similarly set at least the last key in case of the  the user doesn't set it  on release*/
    else if(indev->driver.type == LV_INDEV_TYPE_KEYPAD) {
   2542a:	3c 02                	cmp    $0x2,%al
   2542c:	75 08                	jne    25436 <_lv_indev_read+0x28>
        data->key = indev->proc.types.keypad.last_key;
   2542e:	8b 47 44             	mov    0x44(%rdi),%eax
   25431:	89 46 04             	mov    %eax,0x4(%rsi)
   25434:	eb 11                	jmp    25447 <_lv_indev_read+0x39>
    }
    /*For compatibility assume that used button was enter (encoder push) */
    else if(indev->driver.type == LV_INDEV_TYPE_ENCODER) {
   25436:	3c 04                	cmp    $0x4,%al
   25438:	75 0d                	jne    25447 <_lv_indev_read+0x39>
        data->key = LV_KEY_ENTER;
   2543a:	c7 46 04 0a 00 00 00 	movl   $0xa,0x4(%rsi)
        data->enc_diff = 0;
   25441:	66 c7 46 0c 00 00    	movw   $0x0,0xc(%rsi)
    }

    if(indev->driver.read_cb) {
   25447:	48 8b 47 08          	mov    0x8(%rdi),%rax
   2544b:	48 85 c0             	test   %rax,%rax
   2544e:	74 02                	je     25452 <_lv_indev_read+0x44>
        LV_LOG_TRACE("idnev read started");
        cont = indev->driver.read_cb(&indev->driver, data);
   25450:	ff e0                	jmpq   *%rax
        LV_LOG_TRACE("idnev read finished");
    }
    else {
        LV_LOG_WARN("indev function registered");
   25452:	4c 8d 05 ac e8 00 00 	lea    0xe8ac(%rip),%r8        # 33d05 <_lv_bpp1_opa_table+0x4b0>
   25459:	48 8d 0d c8 b7 00 00 	lea    0xb7c8(%rip),%rcx        # 30c28 <__func__.5705>
   25460:	48 8d 35 64 e8 00 00 	lea    0xe864(%rip),%rsi        # 33ccb <_lv_bpp1_opa_table+0x476>
{
   25467:	48 83 ec 08          	sub    $0x8,%rsp
        LV_LOG_WARN("indev function registered");
   2546b:	ba 9e 00 00 00       	mov    $0x9e,%edx
   25470:	31 c0                	xor    %eax,%eax
   25472:	bf 02 00 00 00       	mov    $0x2,%edi
   25477:	e8 da 0a 00 00       	callq  25f56 <_lv_log_add>
    }

    return cont;
}
   2547c:	31 c0                	xor    %eax,%eax
   2547e:	5a                   	pop    %rdx
   2547f:	c3                   	retq   

0000000000025480 <lv_tick_inc>:
 * You have to call this function periodically
 * @param tick_period the call period of this function in milliseconds
 */
LV_ATTRIBUTE_TICK_INC void lv_tick_inc(uint32_t tick_period)
{
    tick_irq_flag = 0;
   25480:	c6 05 66 9c 23 00 00 	movb   $0x0,0x239c66(%rip)        # 25f0ed <tick_irq_flag>
    sys_time += tick_period;
   25487:	01 3d 17 9c 23 00    	add    %edi,0x239c17(%rip)        # 25f0a4 <sys_time>
}
   2548d:	c3                   	retq   

000000000002548e <lv_tick_get>:
/**
 * Get the elapsed milliseconds since start up
 * @return the elapsed milliseconds
 */
uint32_t lv_tick_get(void)
{
   2548e:	48 83 ec 08          	sub    $0x8,%rsp
	return z_impl_k_uptime_ticks();
   25492:	31 c0                	xor    %eax,%eax
   25494:	e8 1a 73 00 00       	callq  2c7b3 <z_impl_k_uptime_ticks>

    return result;
#else
    return LV_TICK_CUSTOM_SYS_TIME_EXPR;
#endif
}
   25499:	5a                   	pop    %rdx
   2549a:	48 6b c0 0a          	imul   $0xa,%rax,%rax
   2549e:	c3                   	retq   

000000000002549f <lv_tick_elaps>:
 * Get the elapsed milliseconds since a previous time stamp
 * @param prev_tick a previous time stamp (return value of systick_get() )
 * @return the elapsed milliseconds since 'prev_tick'
 */
uint32_t lv_tick_elaps(uint32_t prev_tick)
{
   2549f:	53                   	push   %rbx
   254a0:	89 fb                	mov    %edi,%ebx
    uint32_t act_time = lv_tick_get();
   254a2:	e8 e7 ff ff ff       	callq  2548e <lv_tick_get>
    else {
        prev_tick = UINT32_MAX - prev_tick + 1;
        prev_tick += act_time;
    }

    return prev_tick;
   254a7:	29 d8                	sub    %ebx,%eax
}
   254a9:	5b                   	pop    %rbx
   254aa:	c3                   	retq   

00000000000254ab <lv_point_within_circle.isra.2>:
 *   STATIC FUNCTIONS
 **********************/

static bool lv_point_within_circle(const lv_area_t * area, const lv_point_t * p)
{
    lv_coord_t r = (area->x2 - area->x1) / 2;
   254ab:	0f bf c2             	movswl %dx,%eax
   254ae:	0f bf d7             	movswl %di,%edx
   254b1:	41 b8 02 00 00 00    	mov    $0x2,%r8d
   254b7:	29 d0                	sub    %edx,%eax
   254b9:	99                   	cltd   
   254ba:	41 f7 f8             	idiv   %r8d
    /* Circle center */
    lv_coord_t cx = area->x1 + r;
    lv_coord_t cy = area->y1 + r;

    /*Simplify the code by moving everything to (0, 0) */
    lv_coord_t px = p->x - cx;
   254bd:	66 8b 11             	mov    (%rcx),%dx
    lv_coord_t py = p->y - cy;
   254c0:	66 8b 49 02          	mov    0x2(%rcx),%cx
    lv_coord_t px = p->x - cx;
   254c4:	29 fa                	sub    %edi,%edx
    lv_coord_t py = p->y - cy;
   254c6:	29 f1                	sub    %esi,%ecx
    lv_coord_t px = p->x - cx;
   254c8:	29 c2                	sub    %eax,%edx
    lv_coord_t py = p->y - cy;
   254ca:	29 c1                	sub    %eax,%ecx

    int32_t r_sqrd = r * r;
    int32_t dist = (px * px) + (py * py);
   254cc:	0f bf d2             	movswl %dx,%edx
   254cf:	0f bf c9             	movswl %cx,%ecx
   254d2:	0f af c9             	imul   %ecx,%ecx
   254d5:	0f af d2             	imul   %edx,%edx
    int32_t r_sqrd = r * r;
   254d8:	0f af c0             	imul   %eax,%eax
    int32_t dist = (px * px) + (py * py);
   254db:	01 ca                	add    %ecx,%edx

    if(dist <= r_sqrd)
   254dd:	39 d0                	cmp    %edx,%eax
   254df:	0f 9d c0             	setge  %al
        return true;
    else
        return false;
}
   254e2:	c3                   	retq   

00000000000254e3 <lv_area_set>:
    area_p->x1 = x1;
   254e3:	66 89 37             	mov    %si,(%rdi)
    area_p->y1 = y1;
   254e6:	66 89 57 02          	mov    %dx,0x2(%rdi)
    area_p->x2 = x2;
   254ea:	66 89 4f 04          	mov    %cx,0x4(%rdi)
    area_p->y2 = y2;
   254ee:	66 44 89 47 06       	mov    %r8w,0x6(%rdi)
}
   254f3:	c3                   	retq   

00000000000254f4 <lv_area_set_height>:
    area_p->y2 = area_p->y1 + h - 1;
   254f4:	66 8b 47 02          	mov    0x2(%rdi),%ax
   254f8:	8d 74 30 ff          	lea    -0x1(%rax,%rsi,1),%esi
   254fc:	66 89 77 06          	mov    %si,0x6(%rdi)
}
   25500:	c3                   	retq   

0000000000025501 <lv_area_get_size>:
    size = (uint32_t)(area_p->x2 - area_p->x1 + 1) * (area_p->y2 - area_p->y1 + 1);
   25501:	0f bf 17             	movswl (%rdi),%edx
   25504:	0f bf 47 04          	movswl 0x4(%rdi),%eax
   25508:	0f bf 4f 02          	movswl 0x2(%rdi),%ecx
   2550c:	29 d0                	sub    %edx,%eax
   2550e:	0f bf 57 06          	movswl 0x6(%rdi),%edx
   25512:	ff c0                	inc    %eax
   25514:	29 ca                	sub    %ecx,%edx
   25516:	ff c2                	inc    %edx
   25518:	0f af c2             	imul   %edx,%eax
}
   2551b:	c3                   	retq   

000000000002551c <_lv_area_intersect>:
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
   2551c:	66 44 8b 0e          	mov    (%rsi),%r9w
   25520:	66 44 39 0a          	cmp    %r9w,(%rdx)
   25524:	66 44 0f 4d 0a       	cmovge (%rdx),%r9w
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
   25529:	66 8b 4e 02          	mov    0x2(%rsi),%cx
   2552d:	66 39 4a 02          	cmp    %cx,0x2(%rdx)
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
   25531:	66 44 8b 46 04       	mov    0x4(%rsi),%r8w
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
   25536:	66 0f 4d 4a 02       	cmovge 0x2(%rdx),%cx
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
   2553b:	66 44 39 42 04       	cmp    %r8w,0x4(%rdx)
   25540:	66 44 0f 4e 42 04    	cmovle 0x4(%rdx),%r8w
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
   25546:	66 8b 46 06          	mov    0x6(%rsi),%ax
   2554a:	66 39 42 06          	cmp    %ax,0x6(%rdx)
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
   2554e:	66 44 89 0f          	mov    %r9w,(%rdi)
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
   25552:	66 0f 4e 42 06       	cmovle 0x6(%rdx),%ax
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
   25557:	66 89 4f 02          	mov    %cx,0x2(%rdi)
    if((res_p->x1 > res_p->x2) || (res_p->y1 > res_p->y2)) {
   2555b:	66 45 39 c1          	cmp    %r8w,%r9w
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
   2555f:	66 44 89 47 04       	mov    %r8w,0x4(%rdi)
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
   25564:	89 c2                	mov    %eax,%edx
   25566:	66 89 47 06          	mov    %ax,0x6(%rdi)
    if((res_p->x1 > res_p->x2) || (res_p->y1 > res_p->y2)) {
   2556a:	0f 9f c0             	setg   %al
   2556d:	66 39 d1             	cmp    %dx,%cx
   25570:	0f 9f c2             	setg   %dl
   25573:	09 d0                	or     %edx,%eax
   25575:	83 f0 01             	xor    $0x1,%eax
}
   25578:	c3                   	retq   

0000000000025579 <_lv_area_join>:
    a_res_p->x1 = LV_MATH_MIN(a1_p->x1, a2_p->x1);
   25579:	66 8b 06             	mov    (%rsi),%ax
   2557c:	66 39 02             	cmp    %ax,(%rdx)
   2557f:	66 0f 4e 02          	cmovle (%rdx),%ax
   25583:	66 89 07             	mov    %ax,(%rdi)
    a_res_p->y1 = LV_MATH_MIN(a1_p->y1, a2_p->y1);
   25586:	66 8b 46 02          	mov    0x2(%rsi),%ax
   2558a:	66 39 42 02          	cmp    %ax,0x2(%rdx)
   2558e:	66 0f 4e 42 02       	cmovle 0x2(%rdx),%ax
   25593:	66 89 47 02          	mov    %ax,0x2(%rdi)
    a_res_p->x2 = LV_MATH_MAX(a1_p->x2, a2_p->x2);
   25597:	66 8b 46 04          	mov    0x4(%rsi),%ax
   2559b:	66 39 42 04          	cmp    %ax,0x4(%rdx)
   2559f:	66 0f 4d 42 04       	cmovge 0x4(%rdx),%ax
   255a4:	66 89 47 04          	mov    %ax,0x4(%rdi)
    a_res_p->y2 = LV_MATH_MAX(a1_p->y2, a2_p->y2);
   255a8:	66 8b 46 06          	mov    0x6(%rsi),%ax
   255ac:	66 39 42 06          	cmp    %ax,0x6(%rdx)
   255b0:	66 0f 4d 42 06       	cmovge 0x6(%rdx),%ax
   255b5:	66 89 47 06          	mov    %ax,0x6(%rdi)
}
   255b9:	c3                   	retq   

00000000000255ba <_lv_area_is_point_on>:
{
   255ba:	41 55                	push   %r13
   255bc:	41 54                	push   %r12
   255be:	55                   	push   %rbp
   255bf:	53                   	push   %rbx
   255c0:	89 d3                	mov    %edx,%ebx
   255c2:	48 83 ec 18          	sub    $0x18,%rsp
    if((p_p->x >= a_p->x1 && p_p->x <= a_p->x2) && ((p_p->y >= a_p->y1 && p_p->y <= a_p->y2))) {
   255c6:	66 8b 16             	mov    (%rsi),%dx
   255c9:	66 44 8b 07          	mov    (%rdi),%r8w
{
   255cd:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   255d4:	00 00 
   255d6:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   255db:	31 c0                	xor    %eax,%eax
    if((p_p->x >= a_p->x1 && p_p->x <= a_p->x2) && ((p_p->y >= a_p->y1 && p_p->y <= a_p->y2))) {
   255dd:	66 44 39 c2          	cmp    %r8w,%dx
   255e1:	0f 8c 8a 01 00 00    	jl     25771 <_lv_area_is_point_on+0x1b7>
   255e7:	48 89 f5             	mov    %rsi,%rbp
   255ea:	66 8b 77 04          	mov    0x4(%rdi),%si
   255ee:	49 89 fc             	mov    %rdi,%r12
   255f1:	66 39 f2             	cmp    %si,%dx
   255f4:	0f 8f 77 01 00 00    	jg     25771 <_lv_area_is_point_on+0x1b7>
   255fa:	66 8b 55 02          	mov    0x2(%rbp),%dx
   255fe:	66 8b 7f 02          	mov    0x2(%rdi),%di
   25602:	66 39 fa             	cmp    %di,%dx
   25605:	0f 8c 66 01 00 00    	jl     25771 <_lv_area_is_point_on+0x1b7>
   2560b:	66 41 8b 4c 24 06    	mov    0x6(%r12),%cx
   25611:	66 39 ca             	cmp    %cx,%dx
   25614:	0f 8f 57 01 00 00    	jg     25771 <_lv_area_is_point_on+0x1b7>
    if(radius <= 0) {
   2561a:	66 85 db             	test   %bx,%bx
   2561d:	7f 07                	jg     25626 <_lv_area_is_point_on+0x6c>
        return true;
   2561f:	b0 01                	mov    $0x1,%al
   25621:	e9 4b 01 00 00       	jmpq   25771 <_lv_area_is_point_on+0x1b7>
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   25626:	ff c6                	inc    %esi
    lv_coord_t w = lv_area_get_width(a_p) / 2;
   25628:	41 b9 02 00 00 00    	mov    $0x2,%r9d
    corner_area.y1 = a_p->y1;
   2562e:	66 89 7c 24 02       	mov    %di,0x2(%rsp)
   25633:	44 29 c6             	sub    %r8d,%esi
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   25636:	49 89 e5             	mov    %rsp,%r13
    corner_area.x1 = a_p->x1;
   25639:	66 44 89 04 24       	mov    %r8w,(%rsp)
    lv_coord_t w = lv_area_get_width(a_p) / 2;
   2563e:	89 f2                	mov    %esi,%edx
   25640:	89 f0                	mov    %esi,%eax
   25642:	66 c1 fa 0f          	sar    $0xf,%dx
   25646:	66 41 f7 f9          	idiv   %r9w
   2564a:	89 c6                	mov    %eax,%esi
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   2564c:	8d 41 01             	lea    0x1(%rcx),%eax
   2564f:	29 f8                	sub    %edi,%eax
    lv_coord_t h = lv_area_get_height(a_p) / 2;
   25651:	89 c2                	mov    %eax,%edx
   25653:	66 c1 fa 0f          	sar    $0xf,%dx
   25657:	66 41 f7 f9          	idiv   %r9w
    lv_coord_t max_radius = LV_MATH_MIN(w, h);
   2565b:	66 39 c6             	cmp    %ax,%si
   2565e:	0f 4e c6             	cmovle %esi,%eax
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   25661:	48 89 ee             	mov    %rbp,%rsi
    corner_area.x2 = a_p->x1 + radius;
   25664:	66 39 d8             	cmp    %bx,%ax
   25667:	0f 4e d8             	cmovle %eax,%ebx
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   2566a:	31 d2                	xor    %edx,%edx
    corner_area.y2 = a_p->y1 + radius;
   2566c:	01 df                	add    %ebx,%edi
    corner_area.x2 = a_p->x1 + radius;
   2566e:	41 01 d8             	add    %ebx,%r8d
    corner_area.y2 = a_p->y1 + radius;
   25671:	66 89 7c 24 06       	mov    %di,0x6(%rsp)
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   25676:	4c 89 ef             	mov    %r13,%rdi
    corner_area.x2 = a_p->x1 + radius;
   25679:	66 44 89 44 24 04    	mov    %r8w,0x4(%rsp)
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   2567f:	e8 36 ff ff ff       	callq  255ba <_lv_area_is_point_on>
   25684:	84 c0                	test   %al,%al
   25686:	74 1a                	je     256a2 <_lv_area_is_point_on+0xe8>
        corner_area.x2 += radius;
   25688:	89 da                	mov    %ebx,%edx
   2568a:	03 54 24 04          	add    0x4(%rsp),%edx
        return lv_point_within_circle(&corner_area, p_p);
   2568e:	48 89 e9             	mov    %rbp,%rcx
        corner_area.y2 += radius;
   25691:	66 01 5c 24 06       	add    %bx,0x6(%rsp)
        return lv_point_within_circle(&corner_area, p_p);
   25696:	66 8b 74 24 02       	mov    0x2(%rsp),%si
        corner_area.x2 += radius;
   2569b:	66 89 54 24 04       	mov    %dx,0x4(%rsp)
   256a0:	eb 3f                	jmp    256e1 <_lv_area_is_point_on+0x127>
    corner_area.y1 = a_p->y2 - radius;
   256a2:	66 41 8b 44 24 06    	mov    0x6(%r12),%ax
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   256a8:	48 89 ee             	mov    %rbp,%rsi
   256ab:	4c 89 ef             	mov    %r13,%rdi
    corner_area.y1 = a_p->y2 - radius;
   256ae:	89 c2                	mov    %eax,%edx
    corner_area.y2 = a_p->y2;
   256b0:	66 89 44 24 06       	mov    %ax,0x6(%rsp)
    corner_area.y1 = a_p->y2 - radius;
   256b5:	29 da                	sub    %ebx,%edx
   256b7:	66 89 54 24 02       	mov    %dx,0x2(%rsp)
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   256bc:	31 d2                	xor    %edx,%edx
   256be:	e8 f7 fe ff ff       	callq  255ba <_lv_area_is_point_on>
   256c3:	84 c0                	test   %al,%al
   256c5:	74 22                	je     256e9 <_lv_area_is_point_on+0x12f>
        corner_area.y1 -= radius;
   256c7:	66 8b 74 24 02       	mov    0x2(%rsp),%si
        corner_area.x2 += radius;
   256cc:	89 da                	mov    %ebx,%edx
   256ce:	03 54 24 04          	add    0x4(%rsp),%edx
        return lv_point_within_circle(&corner_area, p_p);
   256d2:	48 89 e9             	mov    %rbp,%rcx
        corner_area.y1 -= radius;
   256d5:	29 de                	sub    %ebx,%esi
        corner_area.x2 += radius;
   256d7:	66 89 54 24 04       	mov    %dx,0x4(%rsp)
        corner_area.y1 -= radius;
   256dc:	66 89 74 24 02       	mov    %si,0x2(%rsp)
        return lv_point_within_circle(&corner_area, p_p);
   256e1:	8b 3c 24             	mov    (%rsp),%edi
   256e4:	e9 83 00 00 00       	jmpq   2576c <_lv_area_is_point_on+0x1b2>
    corner_area.x1 = a_p->x2 - radius;
   256e9:	66 41 8b 44 24 04    	mov    0x4(%r12),%ax
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   256ef:	48 89 ee             	mov    %rbp,%rsi
   256f2:	4c 89 ef             	mov    %r13,%rdi
    corner_area.x1 = a_p->x2 - radius;
   256f5:	89 c2                	mov    %eax,%edx
    corner_area.x2 = a_p->x2;
   256f7:	66 89 44 24 04       	mov    %ax,0x4(%rsp)
    corner_area.x1 = a_p->x2 - radius;
   256fc:	29 da                	sub    %ebx,%edx
   256fe:	66 89 14 24          	mov    %dx,(%rsp)
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   25702:	31 d2                	xor    %edx,%edx
   25704:	e8 b1 fe ff ff       	callq  255ba <_lv_area_is_point_on>
   25709:	84 c0                	test   %al,%al
   2570b:	74 1e                	je     2572b <_lv_area_is_point_on+0x171>
        corner_area.x1 -= radius;
   2570d:	8b 3c 24             	mov    (%rsp),%edi
        corner_area.y1 -= radius;
   25710:	66 8b 74 24 02       	mov    0x2(%rsp),%si
        return lv_point_within_circle(&corner_area, p_p);
   25715:	48 89 e9             	mov    %rbp,%rcx
   25718:	8b 54 24 04          	mov    0x4(%rsp),%edx
        corner_area.x1 -= radius;
   2571c:	29 df                	sub    %ebx,%edi
        corner_area.y1 -= radius;
   2571e:	29 de                	sub    %ebx,%esi
        corner_area.x1 -= radius;
   25720:	66 89 3c 24          	mov    %di,(%rsp)
        corner_area.y1 -= radius;
   25724:	66 89 74 24 02       	mov    %si,0x2(%rsp)
   25729:	eb 41                	jmp    2576c <_lv_area_is_point_on+0x1b2>
    corner_area.y1 = a_p->y1;
   2572b:	66 41 8b 44 24 02    	mov    0x2(%r12),%ax
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   25731:	31 d2                	xor    %edx,%edx
   25733:	48 89 ee             	mov    %rbp,%rsi
   25736:	4c 89 ef             	mov    %r13,%rdi
    corner_area.y1 = a_p->y1;
   25739:	66 89 44 24 02       	mov    %ax,0x2(%rsp)
    corner_area.y2 = a_p->y1 + radius;
   2573e:	01 d8                	add    %ebx,%eax
   25740:	66 89 44 24 06       	mov    %ax,0x6(%rsp)
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   25745:	e8 70 fe ff ff       	callq  255ba <_lv_area_is_point_on>
   2574a:	84 c0                	test   %al,%al
   2574c:	0f 84 cd fe ff ff    	je     2561f <_lv_area_is_point_on+0x65>
        corner_area.x1 -= radius;
   25752:	8b 3c 24             	mov    (%rsp),%edi
        corner_area.y2 += radius;
   25755:	66 01 5c 24 06       	add    %bx,0x6(%rsp)
        return lv_point_within_circle(&corner_area, p_p);
   2575a:	48 89 e9             	mov    %rbp,%rcx
   2575d:	8b 54 24 04          	mov    0x4(%rsp),%edx
   25761:	66 8b 74 24 02       	mov    0x2(%rsp),%si
        corner_area.x1 -= radius;
   25766:	29 df                	sub    %ebx,%edi
   25768:	66 89 3c 24          	mov    %di,(%rsp)
        return lv_point_within_circle(&corner_area, p_p);
   2576c:	e8 3a fd ff ff       	callq  254ab <lv_point_within_circle.isra.2>
}
   25771:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
   25776:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   2577d:	00 00 
   2577f:	74 05                	je     25786 <_lv_area_is_point_on+0x1cc>
   25781:	e8 ba ee fd ff       	callq  4640 <__stack_chk_fail@plt>
   25786:	48 83 c4 18          	add    $0x18,%rsp
   2578a:	5b                   	pop    %rbx
   2578b:	5d                   	pop    %rbp
   2578c:	41 5c                	pop    %r12
   2578e:	41 5d                	pop    %r13
   25790:	c3                   	retq   

0000000000025791 <_lv_area_is_on>:
        return false;
   25791:	31 c0                	xor    %eax,%eax
    if((a1_p->x1 <= a2_p->x2) && (a1_p->x2 >= a2_p->x1) && (a1_p->y1 <= a2_p->y2) && (a1_p->y2 >= a2_p->y1)) {
   25793:	66 8b 56 04          	mov    0x4(%rsi),%dx
   25797:	66 39 17             	cmp    %dx,(%rdi)
   2579a:	7f 1e                	jg     257ba <_lv_area_is_on+0x29>
   2579c:	66 8b 0e             	mov    (%rsi),%cx
   2579f:	66 39 4f 04          	cmp    %cx,0x4(%rdi)
   257a3:	7c 15                	jl     257ba <_lv_area_is_on+0x29>
   257a5:	66 8b 56 06          	mov    0x6(%rsi),%dx
   257a9:	66 39 57 02          	cmp    %dx,0x2(%rdi)
   257ad:	7f 0b                	jg     257ba <_lv_area_is_on+0x29>
   257af:	66 8b 46 02          	mov    0x2(%rsi),%ax
   257b3:	66 39 47 06          	cmp    %ax,0x6(%rdi)
   257b7:	0f 9d c0             	setge  %al
}
   257ba:	c3                   	retq   

00000000000257bb <_lv_area_is_in>:
{
   257bb:	41 55                	push   %r13
   257bd:	41 54                	push   %r12
   257bf:	55                   	push   %rbp
   257c0:	53                   	push   %rbx
   257c1:	48 89 f5             	mov    %rsi,%rbp
   257c4:	48 89 fb             	mov    %rdi,%rbx
   257c7:	48 83 ec 18          	sub    $0x18,%rsp
    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
   257cb:	66 8b 0f             	mov    (%rdi),%cx
{
   257ce:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   257d5:	00 00 
   257d7:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   257dc:	31 c0                	xor    %eax,%eax
    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
   257de:	66 3b 0e             	cmp    (%rsi),%cx
   257e1:	7c 1f                	jl     25802 <_lv_area_is_in+0x47>
   257e3:	66 8b 76 02          	mov    0x2(%rsi),%si
   257e7:	66 39 77 02          	cmp    %si,0x2(%rdi)
   257eb:	7c 15                	jl     25802 <_lv_area_is_in+0x47>
   257ed:	66 8b 7d 04          	mov    0x4(%rbp),%di
   257f1:	66 39 7b 04          	cmp    %di,0x4(%rbx)
   257f5:	7f 0b                	jg     25802 <_lv_area_is_in+0x47>
   257f7:	66 8b 45 06          	mov    0x6(%rbp),%ax
   257fb:	66 39 43 06          	cmp    %ax,0x6(%rbx)
   257ff:	0f 9e c0             	setle  %al
    if(radius == 0) return is_in;
   25802:	66 85 d2             	test   %dx,%dx
   25805:	0f 84 94 00 00 00    	je     2589f <_lv_area_is_in+0xe4>
    p.y = ain_p->y1;
   2580b:	66 8b 43 02          	mov    0x2(%rbx),%ax
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
   2580f:	4c 8d 6c 24 04       	lea    0x4(%rsp),%r13
   25814:	44 0f bf e2          	movswl %dx,%r12d
   25818:	44 89 e2             	mov    %r12d,%edx
   2581b:	48 89 ef             	mov    %rbp,%rdi
    p.x = ain_p->x1;
   2581e:	66 89 4c 24 04       	mov    %cx,0x4(%rsp)
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
   25823:	4c 89 ee             	mov    %r13,%rsi
    p.y = ain_p->y1;
   25826:	66 89 44 24 06       	mov    %ax,0x6(%rsp)
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
   2582b:	e8 8a fd ff ff       	callq  255ba <_lv_area_is_point_on>
   25830:	84 c0                	test   %al,%al
   25832:	75 04                	jne    25838 <_lv_area_is_in+0x7d>
   25834:	31 c0                	xor    %eax,%eax
   25836:	eb 67                	jmp    2589f <_lv_area_is_in+0xe4>
    p.x = ain_p->x2;
   25838:	66 8b 43 04          	mov    0x4(%rbx),%ax
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
   2583c:	44 89 e2             	mov    %r12d,%edx
   2583f:	4c 89 ee             	mov    %r13,%rsi
   25842:	48 89 ef             	mov    %rbp,%rdi
    p.x = ain_p->x2;
   25845:	66 89 44 24 04       	mov    %ax,0x4(%rsp)
    p.y = ain_p->y1;
   2584a:	66 8b 43 02          	mov    0x2(%rbx),%ax
   2584e:	66 89 44 24 06       	mov    %ax,0x6(%rsp)
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
   25853:	e8 62 fd ff ff       	callq  255ba <_lv_area_is_point_on>
   25858:	84 c0                	test   %al,%al
   2585a:	74 d8                	je     25834 <_lv_area_is_in+0x79>
    p.x = ain_p->x1;
   2585c:	66 8b 03             	mov    (%rbx),%ax
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
   2585f:	44 89 e2             	mov    %r12d,%edx
   25862:	4c 89 ee             	mov    %r13,%rsi
   25865:	48 89 ef             	mov    %rbp,%rdi
    p.x = ain_p->x1;
   25868:	66 89 44 24 04       	mov    %ax,0x4(%rsp)
    p.y = ain_p->y2;
   2586d:	66 8b 43 06          	mov    0x6(%rbx),%ax
   25871:	66 89 44 24 06       	mov    %ax,0x6(%rsp)
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
   25876:	e8 3f fd ff ff       	callq  255ba <_lv_area_is_point_on>
   2587b:	84 c0                	test   %al,%al
   2587d:	74 b5                	je     25834 <_lv_area_is_in+0x79>
    p.x = ain_p->x2;
   2587f:	66 8b 43 04          	mov    0x4(%rbx),%ax
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
   25883:	44 89 e2             	mov    %r12d,%edx
   25886:	4c 89 ee             	mov    %r13,%rsi
   25889:	48 89 ef             	mov    %rbp,%rdi
    p.x = ain_p->x2;
   2588c:	66 89 44 24 04       	mov    %ax,0x4(%rsp)
    p.y = ain_p->y2;
   25891:	66 8b 43 06          	mov    0x6(%rbx),%ax
   25895:	66 89 44 24 06       	mov    %ax,0x6(%rsp)
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
   2589a:	e8 1b fd ff ff       	callq  255ba <_lv_area_is_point_on>
}
   2589f:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
   258a4:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   258ab:	00 00 
   258ad:	74 05                	je     258b4 <_lv_area_is_in+0xf9>
   258af:	e8 8c ed fd ff       	callq  4640 <__stack_chk_fail@plt>
   258b4:	48 83 c4 18          	add    $0x18,%rsp
   258b8:	5b                   	pop    %rbx
   258b9:	5d                   	pop    %rbp
   258ba:	41 5c                	pop    %r12
   258bc:	41 5d                	pop    %r13
   258be:	c3                   	retq   

00000000000258bf <_lv_area_align>:
    switch(align) {
   258bf:	80 fa 14             	cmp    $0x14,%dl
   258c2:	66 44 8b 07          	mov    (%rdi),%r8w
   258c6:	0f 87 6d 02 00 00    	ja     25b39 <_lv_area_align+0x27a>
   258cc:	4c 8d 0d e1 b4 00 00 	lea    0xb4e1(%rip),%r9        # 30db4 <__func__.5785+0x14c>
   258d3:	0f b6 d2             	movzbl %dl,%edx
   258d6:	49 63 04 91          	movslq (%r9,%rdx,4),%rax
   258da:	4c 01 c8             	add    %r9,%rax
   258dd:	ff e0                	jmpq   *%rax
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   258df:	66 8b 47 04          	mov    0x4(%rdi),%ax
            res->x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
   258e3:	41 ba 02 00 00 00    	mov    $0x2,%r10d
   258e9:	ff c0                	inc    %eax
   258eb:	44 29 c0             	sub    %r8d,%eax
   258ee:	89 c2                	mov    %eax,%edx
   258f0:	66 c1 fa 0f          	sar    $0xf,%dx
   258f4:	66 41 f7 fa          	idiv   %r10w
   258f8:	41 89 c1             	mov    %eax,%r9d
   258fb:	66 8b 46 04          	mov    0x4(%rsi),%ax
   258ff:	ff c0                	inc    %eax
   25901:	66 2b 06             	sub    (%rsi),%ax
   25904:	89 c2                	mov    %eax,%edx
   25906:	66 c1 fa 0f          	sar    $0xf,%dx
   2590a:	66 41 f7 fa          	idiv   %r10w
   2590e:	41 29 c1             	sub    %eax,%r9d
   25911:	66 44 89 09          	mov    %r9w,(%rcx)
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   25915:	66 8b 47 06          	mov    0x6(%rdi),%ax
   25919:	ff c0                	inc    %eax
   2591b:	66 2b 47 02          	sub    0x2(%rdi),%ax
   2591f:	e9 cc 01 00 00       	jmpq   25af0 <_lv_area_align+0x231>
            res->x = 0;
   25924:	c7 01 00 00 00 00    	movl   $0x0,(%rcx)
            break;
   2592a:	e9 0a 02 00 00       	jmpq   25b39 <_lv_area_align+0x27a>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   2592f:	66 8b 47 04          	mov    0x4(%rdi),%ax
            res->x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
   25933:	41 ba 02 00 00 00    	mov    $0x2,%r10d
   25939:	ff c0                	inc    %eax
   2593b:	44 29 c0             	sub    %r8d,%eax
   2593e:	89 c2                	mov    %eax,%edx
   25940:	66 c1 fa 0f          	sar    $0xf,%dx
   25944:	66 41 f7 fa          	idiv   %r10w
   25948:	41 89 c1             	mov    %eax,%r9d
   2594b:	66 8b 46 04          	mov    0x4(%rsi),%ax
   2594f:	ff c0                	inc    %eax
   25951:	66 2b 06             	sub    (%rsi),%ax
   25954:	89 c2                	mov    %eax,%edx
   25956:	66 c1 fa 0f          	sar    $0xf,%dx
   2595a:	66 41 f7 fa          	idiv   %r10w
   2595e:	41 29 c1             	sub    %eax,%r9d
   25961:	44 89 c8             	mov    %r9d,%eax
   25964:	e9 60 01 00 00       	jmpq   25ac9 <_lv_area_align+0x20a>
            res->x = lv_area_get_width(base) - lv_area_get_width(to_align);
   25969:	66 8b 06             	mov    (%rsi),%ax
   2596c:	66 2b 46 04          	sub    0x4(%rsi),%ax
   25970:	66 03 47 04          	add    0x4(%rdi),%ax
   25974:	e9 4d 01 00 00       	jmpq   25ac6 <_lv_area_align+0x207>
            res->x = 0;
   25979:	66 c7 01 00 00       	movw   $0x0,(%rcx)
   2597e:	e9 a2 01 00 00       	jmpq   25b25 <_lv_area_align+0x266>
   25983:	66 8b 47 04          	mov    0x4(%rdi),%ax
            res->x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
   25987:	41 ba 02 00 00 00    	mov    $0x2,%r10d
   2598d:	ff c0                	inc    %eax
   2598f:	44 29 c0             	sub    %r8d,%eax
   25992:	89 c2                	mov    %eax,%edx
   25994:	66 c1 fa 0f          	sar    $0xf,%dx
   25998:	66 41 f7 fa          	idiv   %r10w
   2599c:	41 89 c1             	mov    %eax,%r9d
   2599f:	66 8b 46 04          	mov    0x4(%rsi),%ax
   259a3:	ff c0                	inc    %eax
   259a5:	66 2b 06             	sub    (%rsi),%ax
   259a8:	89 c2                	mov    %eax,%edx
   259aa:	66 c1 fa 0f          	sar    $0xf,%dx
   259ae:	66 41 f7 fa          	idiv   %r10w
   259b2:	41 29 c1             	sub    %eax,%r9d
   259b5:	44 89 c8             	mov    %r9d,%eax
   259b8:	e9 65 01 00 00       	jmpq   25b22 <_lv_area_align+0x263>
            res->x = lv_area_get_width(base) - lv_area_get_width(to_align);
   259bd:	66 8b 06             	mov    (%rsi),%ax
   259c0:	66 2b 46 04          	sub    0x4(%rsi),%ax
   259c4:	66 03 47 04          	add    0x4(%rdi),%ax
   259c8:	e9 52 01 00 00       	jmpq   25b1f <_lv_area_align+0x260>
            res->x = 0;
   259cd:	66 c7 01 00 00       	movw   $0x0,(%rcx)
   259d2:	e9 09 01 00 00       	jmpq   25ae0 <_lv_area_align+0x221>
            res->x = lv_area_get_width(base) - lv_area_get_width(to_align);
   259d7:	66 8b 06             	mov    (%rsi),%ax
   259da:	66 2b 46 04          	sub    0x4(%rsi),%ax
   259de:	66 03 47 04          	add    0x4(%rdi),%ax
   259e2:	e9 f3 00 00 00       	jmpq   25ada <_lv_area_align+0x21b>
            res->x = 0;
   259e7:	66 c7 01 00 00       	movw   $0x0,(%rcx)
   259ec:	eb 48                	jmp    25a36 <_lv_area_align+0x177>
   259ee:	66 8b 47 04          	mov    0x4(%rdi),%ax
            res->x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
   259f2:	41 ba 02 00 00 00    	mov    $0x2,%r10d
   259f8:	ff c0                	inc    %eax
   259fa:	44 29 c0             	sub    %r8d,%eax
   259fd:	89 c2                	mov    %eax,%edx
   259ff:	66 c1 fa 0f          	sar    $0xf,%dx
   25a03:	66 41 f7 fa          	idiv   %r10w
   25a07:	41 89 c1             	mov    %eax,%r9d
   25a0a:	66 8b 46 04          	mov    0x4(%rsi),%ax
   25a0e:	ff c0                	inc    %eax
   25a10:	66 2b 06             	sub    (%rsi),%ax
   25a13:	89 c2                	mov    %eax,%edx
   25a15:	66 c1 fa 0f          	sar    $0xf,%dx
   25a19:	66 41 f7 fa          	idiv   %r10w
   25a1d:	41 29 c1             	sub    %eax,%r9d
   25a20:	44 89 c8             	mov    %r9d,%eax
   25a23:	eb 0e                	jmp    25a33 <_lv_area_align+0x174>
            res->x = lv_area_get_width(base) - lv_area_get_width(to_align);
   25a25:	66 8b 06             	mov    (%rsi),%ax
   25a28:	66 2b 46 04          	sub    0x4(%rsi),%ax
   25a2c:	66 03 47 04          	add    0x4(%rdi),%ax
   25a30:	44 29 c0             	sub    %r8d,%eax
   25a33:	66 89 01             	mov    %ax,(%rcx)
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   25a36:	66 8b 46 06          	mov    0x6(%rsi),%ax
   25a3a:	66 2b 46 02          	sub    0x2(%rsi),%ax
            res->y = -lv_area_get_height(to_align);
   25a3e:	f7 d0                	not    %eax
   25a40:	e9 f0 00 00 00       	jmpq   25b35 <_lv_area_align+0x276>
            res->x = 0;
   25a45:	66 c7 01 00 00       	movw   $0x0,(%rcx)
   25a4a:	eb 48                	jmp    25a94 <_lv_area_align+0x1d5>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   25a4c:	66 8b 47 04          	mov    0x4(%rdi),%ax
            res->x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
   25a50:	41 ba 02 00 00 00    	mov    $0x2,%r10d
   25a56:	ff c0                	inc    %eax
   25a58:	44 29 c0             	sub    %r8d,%eax
   25a5b:	89 c2                	mov    %eax,%edx
   25a5d:	66 c1 fa 0f          	sar    $0xf,%dx
   25a61:	66 41 f7 fa          	idiv   %r10w
   25a65:	41 89 c1             	mov    %eax,%r9d
   25a68:	66 8b 46 04          	mov    0x4(%rsi),%ax
   25a6c:	ff c0                	inc    %eax
   25a6e:	66 2b 06             	sub    (%rsi),%ax
   25a71:	89 c2                	mov    %eax,%edx
   25a73:	66 c1 fa 0f          	sar    $0xf,%dx
   25a77:	66 41 f7 fa          	idiv   %r10w
   25a7b:	41 29 c1             	sub    %eax,%r9d
   25a7e:	44 89 c8             	mov    %r9d,%eax
   25a81:	eb 0e                	jmp    25a91 <_lv_area_align+0x1d2>
            res->x = lv_area_get_width(base) - lv_area_get_width(to_align);
   25a83:	66 8b 06             	mov    (%rsi),%ax
   25a86:	66 2b 46 04          	sub    0x4(%rsi),%ax
   25a8a:	66 03 47 04          	add    0x4(%rdi),%ax
   25a8e:	44 29 c0             	sub    %r8d,%eax
   25a91:	66 89 01             	mov    %ax,(%rcx)
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   25a94:	66 8b 47 06          	mov    0x6(%rdi),%ax
   25a98:	ff c0                	inc    %eax
   25a9a:	e9 92 00 00 00       	jmpq   25b31 <_lv_area_align+0x272>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   25a9f:	66 8b 46 04          	mov    0x4(%rsi),%ax
   25aa3:	66 2b 06             	sub    (%rsi),%ax
            res->x = -lv_area_get_width(to_align);
   25aa6:	f7 d0                	not    %eax
   25aa8:	eb 1f                	jmp    25ac9 <_lv_area_align+0x20a>
   25aaa:	66 8b 46 04          	mov    0x4(%rsi),%ax
   25aae:	66 2b 06             	sub    (%rsi),%ax
            res->x = -lv_area_get_width(to_align);
   25ab1:	f7 d0                	not    %eax
   25ab3:	eb 28                	jmp    25add <_lv_area_align+0x21e>
   25ab5:	66 8b 46 04          	mov    0x4(%rsi),%ax
   25ab9:	66 2b 06             	sub    (%rsi),%ax
            res->x = -lv_area_get_width(to_align);
   25abc:	f7 d0                	not    %eax
   25abe:	eb 62                	jmp    25b22 <_lv_area_align+0x263>
   25ac0:	66 8b 47 04          	mov    0x4(%rdi),%ax
   25ac4:	ff c0                	inc    %eax
   25ac6:	44 29 c0             	sub    %r8d,%eax
   25ac9:	66 89 01             	mov    %ax,(%rcx)
            res->y = 0;
   25acc:	66 c7 41 02 00 00    	movw   $0x0,0x2(%rcx)
            break;
   25ad2:	eb 65                	jmp    25b39 <_lv_area_align+0x27a>
   25ad4:	66 8b 47 04          	mov    0x4(%rdi),%ax
   25ad8:	ff c0                	inc    %eax
   25ada:	44 29 c0             	sub    %r8d,%eax
   25add:	66 89 01             	mov    %ax,(%rcx)
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   25ae0:	66 8b 47 06          	mov    0x6(%rdi),%ax
            res->y = lv_area_get_height(base) / 2 - lv_area_get_height(to_align) / 2;
   25ae4:	41 ba 02 00 00 00    	mov    $0x2,%r10d
   25aea:	ff c0                	inc    %eax
   25aec:	66 2b 47 02          	sub    0x2(%rdi),%ax
   25af0:	89 c2                	mov    %eax,%edx
   25af2:	66 c1 fa 0f          	sar    $0xf,%dx
   25af6:	66 41 f7 fa          	idiv   %r10w
   25afa:	41 89 c1             	mov    %eax,%r9d
   25afd:	66 8b 46 06          	mov    0x6(%rsi),%ax
   25b01:	ff c0                	inc    %eax
   25b03:	66 2b 46 02          	sub    0x2(%rsi),%ax
   25b07:	89 c2                	mov    %eax,%edx
   25b09:	66 c1 fa 0f          	sar    $0xf,%dx
   25b0d:	66 41 f7 fa          	idiv   %r10w
   25b11:	41 29 c1             	sub    %eax,%r9d
   25b14:	44 89 c8             	mov    %r9d,%eax
   25b17:	eb 1c                	jmp    25b35 <_lv_area_align+0x276>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   25b19:	66 8b 47 04          	mov    0x4(%rdi),%ax
   25b1d:	ff c0                	inc    %eax
   25b1f:	44 29 c0             	sub    %r8d,%eax
   25b22:	66 89 01             	mov    %ax,(%rcx)
            res->y = lv_area_get_height(base) - lv_area_get_height(to_align);
   25b25:	66 8b 46 02          	mov    0x2(%rsi),%ax
   25b29:	66 2b 46 06          	sub    0x6(%rsi),%ax
   25b2d:	66 03 47 06          	add    0x6(%rdi),%ax
   25b31:	66 2b 47 02          	sub    0x2(%rdi),%ax
   25b35:	66 89 41 02          	mov    %ax,0x2(%rcx)
    res->y += base->y1;
   25b39:	66 8b 47 02          	mov    0x2(%rdi),%ax
    res->x += base->x1;
   25b3d:	66 44 01 01          	add    %r8w,(%rcx)
    res->y += base->y1;
   25b41:	66 01 41 02          	add    %ax,0x2(%rcx)
}
   25b45:	c3                   	retq   

0000000000025b46 <lv_color_fill>:
        *buf = color;
        buf++;
        px_num --;
    }
#else
    while(px_num > 16) {
   25b46:	83 fa 10             	cmp    $0x10,%edx
   25b49:	76 38                	jbe    25b83 <lv_color_fill+0x3d>
        *buf = color;
   25b4b:	89 37                	mov    %esi,(%rdi)
        buf++;
        *buf = color;
   25b4d:	89 77 04             	mov    %esi,0x4(%rdi)
        *buf = color;
        buf++;
        *buf = color;
        buf++;

        px_num -= 16;
   25b50:	83 ea 10             	sub    $0x10,%edx
        *buf = color;
   25b53:	89 77 08             	mov    %esi,0x8(%rdi)
        *buf = color;
   25b56:	89 77 0c             	mov    %esi,0xc(%rdi)
   25b59:	48 83 c7 40          	add    $0x40,%rdi
        *buf = color;
   25b5d:	89 77 d0             	mov    %esi,-0x30(%rdi)
        *buf = color;
   25b60:	89 77 d4             	mov    %esi,-0x2c(%rdi)
        *buf = color;
   25b63:	89 77 d8             	mov    %esi,-0x28(%rdi)
        *buf = color;
   25b66:	89 77 dc             	mov    %esi,-0x24(%rdi)
        *buf = color;
   25b69:	89 77 e0             	mov    %esi,-0x20(%rdi)
        *buf = color;
   25b6c:	89 77 e4             	mov    %esi,-0x1c(%rdi)
        *buf = color;
   25b6f:	89 77 e8             	mov    %esi,-0x18(%rdi)
        *buf = color;
   25b72:	89 77 ec             	mov    %esi,-0x14(%rdi)
        *buf = color;
   25b75:	89 77 f0             	mov    %esi,-0x10(%rdi)
        *buf = color;
   25b78:	89 77 f4             	mov    %esi,-0xc(%rdi)
        *buf = color;
   25b7b:	89 77 f8             	mov    %esi,-0x8(%rdi)
        *buf = color;
   25b7e:	89 77 fc             	mov    %esi,-0x4(%rdi)
   25b81:	eb c3                	jmp    25b46 <lv_color_fill>
   25b83:	89 d2                	mov    %edx,%edx
    while(px_num > 16) {
   25b85:	31 c0                	xor    %eax,%eax
    }
    while(px_num) {
   25b87:	48 39 d0             	cmp    %rdx,%rax
   25b8a:	74 08                	je     25b94 <lv_color_fill+0x4e>
        *buf = color;
   25b8c:	89 34 87             	mov    %esi,(%rdi,%rax,4)
   25b8f:	48 ff c0             	inc    %rax
   25b92:	eb f3                	jmp    25b87 <lv_color_fill+0x41>
        buf++;
        px_num --;
    }
#endif
}
   25b94:	c3                   	retq   

0000000000025b95 <node_set_prev.isra.0>:
 * @param act pointer to a node which prev. node pointer should be set
 * @param prev pointer to a node which should be the previous node before 'act'
 */
static void node_set_prev(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * prev)
{
    if(act == NULL) return; /*Can't set the prev node of `NULL`*/
   25b95:	48 85 f6             	test   %rsi,%rsi
   25b98:	74 06                	je     25ba0 <node_set_prev.isra.0+0xb>

    uint8_t * act8 = (uint8_t *) act;

    act8 += LL_PREV_P_OFFSET(ll_p);
   25b9a:	8b 07                	mov    (%rdi),%eax

    lv_ll_node_t ** act_node_p = (lv_ll_node_t **) act8;
    lv_ll_node_t ** prev_node_p = (lv_ll_node_t **) &prev;

    *act_node_p = *prev_node_p;
   25b9c:	48 89 14 06          	mov    %rdx,(%rsi,%rax,1)
}
   25ba0:	c3                   	retq   

0000000000025ba1 <node_set_next.isra.1>:
 * @param act pointer to a node which next node pointer should be set
 * @param next pointer to a node which should be the next node before 'act'
 */
static void node_set_next(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * next)
{
    if(act == NULL) return; /*Can't set the next node of `NULL`*/
   25ba1:	48 85 f6             	test   %rsi,%rsi
   25ba4:	74 07                	je     25bad <node_set_next.isra.1+0xc>
    uint8_t * act8 = (uint8_t *) act;

    act8 += LL_NEXT_P_OFFSET(ll_p);
   25ba6:	8b 07                	mov    (%rdi),%eax
    lv_ll_node_t ** act_node_p = (lv_ll_node_t **) act8;
    lv_ll_node_t ** next_node_p = (lv_ll_node_t **) &next;

    *act_node_p = *next_node_p;
   25ba8:	48 89 54 06 08       	mov    %rdx,0x8(%rsi,%rax,1)
}
   25bad:	c3                   	retq   

0000000000025bae <_lv_ll_init>:
    node_size = (node_size + 7) & (~0x7);
   25bae:	83 c6 07             	add    $0x7,%esi
    ll_p->head = NULL;
   25bb1:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
   25bb8:	00 
    ll_p->tail = NULL;
   25bb9:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
   25bc0:	00 
    node_size = (node_size + 7) & (~0x7);
   25bc1:	83 e6 f8             	and    $0xfffffff8,%esi
   25bc4:	89 37                	mov    %esi,(%rdi)
}
   25bc6:	c3                   	retq   

0000000000025bc7 <_lv_ll_ins_head>:
{
   25bc7:	53                   	push   %rbx
   25bc8:	48 89 fb             	mov    %rdi,%rbx
    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
   25bcb:	8b 3f                	mov    (%rdi),%edi
   25bcd:	48 83 c7 10          	add    $0x10,%rdi
   25bd1:	e8 bb 04 00 00       	callq  26091 <lv_mem_alloc>
    if(n_new != NULL) {
   25bd6:	48 85 c0             	test   %rax,%rax
    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
   25bd9:	48 89 c1             	mov    %rax,%rcx
    if(n_new != NULL) {
   25bdc:	74 36                	je     25c14 <_lv_ll_ins_head+0x4d>
        node_set_prev(ll_p, n_new, NULL);       /*No prev. before the new head*/
   25bde:	31 d2                	xor    %edx,%edx
   25be0:	48 89 c6             	mov    %rax,%rsi
   25be3:	48 89 df             	mov    %rbx,%rdi
   25be6:	e8 aa ff ff ff       	callq  25b95 <node_set_prev.isra.0>
        node_set_next(ll_p, n_new, ll_p->head); /*After new comes the old head*/
   25beb:	48 8b 53 08          	mov    0x8(%rbx),%rdx
   25bef:	e8 ad ff ff ff       	callq  25ba1 <node_set_next.isra.1>
        if(ll_p->head != NULL) { /*If there is old head then before it goes the new*/
   25bf4:	48 8b 73 08          	mov    0x8(%rbx),%rsi
   25bf8:	48 85 f6             	test   %rsi,%rsi
   25bfb:	74 08                	je     25c05 <_lv_ll_ins_head+0x3e>
            node_set_prev(ll_p, ll_p->head, n_new);
   25bfd:	48 89 ca             	mov    %rcx,%rdx
   25c00:	e8 90 ff ff ff       	callq  25b95 <node_set_prev.isra.0>
        if(ll_p->tail == NULL) { /*If there is no tail (1. node) set the tail too*/
   25c05:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
        ll_p->head = n_new;      /*Set the new head in the dsc.*/
   25c0a:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
        if(ll_p->tail == NULL) { /*If there is no tail (1. node) set the tail too*/
   25c0e:	75 04                	jne    25c14 <_lv_ll_ins_head+0x4d>
            ll_p->tail = n_new;
   25c10:	48 89 4b 10          	mov    %rcx,0x10(%rbx)
}
   25c14:	48 89 c8             	mov    %rcx,%rax
   25c17:	5b                   	pop    %rbx
   25c18:	c3                   	retq   

0000000000025c19 <_lv_ll_ins_tail>:
{
   25c19:	53                   	push   %rbx
   25c1a:	48 89 fb             	mov    %rdi,%rbx
    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
   25c1d:	8b 3f                	mov    (%rdi),%edi
   25c1f:	48 83 c7 10          	add    $0x10,%rdi
   25c23:	e8 69 04 00 00       	callq  26091 <lv_mem_alloc>
    if(n_new != NULL) {
   25c28:	48 85 c0             	test   %rax,%rax
    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
   25c2b:	48 89 c1             	mov    %rax,%rcx
    if(n_new != NULL) {
   25c2e:	74 36                	je     25c66 <_lv_ll_ins_tail+0x4d>
        node_set_next(ll_p, n_new, NULL);       /*No next after the new tail*/
   25c30:	31 d2                	xor    %edx,%edx
   25c32:	48 89 c6             	mov    %rax,%rsi
   25c35:	48 89 df             	mov    %rbx,%rdi
   25c38:	e8 64 ff ff ff       	callq  25ba1 <node_set_next.isra.1>
        node_set_prev(ll_p, n_new, ll_p->tail); /*The prev. before new is the old tail*/
   25c3d:	48 8b 53 10          	mov    0x10(%rbx),%rdx
   25c41:	e8 4f ff ff ff       	callq  25b95 <node_set_prev.isra.0>
        if(ll_p->tail != NULL) {                /*If there is old tail then the new comes after it*/
   25c46:	48 8b 73 10          	mov    0x10(%rbx),%rsi
   25c4a:	48 85 f6             	test   %rsi,%rsi
   25c4d:	74 08                	je     25c57 <_lv_ll_ins_tail+0x3e>
            node_set_next(ll_p, ll_p->tail, n_new);
   25c4f:	48 89 ca             	mov    %rcx,%rdx
   25c52:	e8 4a ff ff ff       	callq  25ba1 <node_set_next.isra.1>
        if(ll_p->head == NULL) { /*If there is no head (1. node) set the head too*/
   25c57:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
        ll_p->tail = n_new;      /*Set the new tail in the dsc.*/
   25c5c:	48 89 4b 10          	mov    %rcx,0x10(%rbx)
        if(ll_p->head == NULL) { /*If there is no head (1. node) set the head too*/
   25c60:	75 04                	jne    25c66 <_lv_ll_ins_tail+0x4d>
            ll_p->head = n_new;
   25c62:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
}
   25c66:	48 89 c8             	mov    %rcx,%rax
   25c69:	5b                   	pop    %rbx
   25c6a:	c3                   	retq   

0000000000025c6b <_lv_ll_get_head>:
    void * head = NULL;
   25c6b:	31 c0                	xor    %eax,%eax
    if(ll_p != NULL) {
   25c6d:	48 85 ff             	test   %rdi,%rdi
   25c70:	74 04                	je     25c76 <_lv_ll_get_head+0xb>
        head = ll_p->head;
   25c72:	48 8b 47 08          	mov    0x8(%rdi),%rax
}
   25c76:	c3                   	retq   

0000000000025c77 <_lv_ll_get_tail>:
    void * tail = NULL;
   25c77:	31 c0                	xor    %eax,%eax
    if(ll_p != NULL) {
   25c79:	48 85 ff             	test   %rdi,%rdi
   25c7c:	74 04                	je     25c82 <_lv_ll_get_tail+0xb>
        tail = ll_p->tail;
   25c7e:	48 8b 47 10          	mov    0x10(%rdi),%rax
}
   25c82:	c3                   	retq   

0000000000025c83 <_lv_ll_get_next>:
    if(ll_p == NULL) return NULL;
   25c83:	31 c0                	xor    %eax,%eax
   25c85:	48 85 ff             	test   %rdi,%rdi
   25c88:	74 07                	je     25c91 <_lv_ll_get_next+0xe>
    n_act_d += LL_NEXT_P_OFFSET(ll_p);
   25c8a:	8b 07                	mov    (%rdi),%eax
    return *((lv_ll_node_t **)n_act_d);
   25c8c:	48 8b 44 06 08       	mov    0x8(%rsi,%rax,1),%rax
}
   25c91:	c3                   	retq   

0000000000025c92 <_lv_ll_get_prev>:
    if(ll_p == NULL) return NULL;
   25c92:	31 c0                	xor    %eax,%eax
   25c94:	48 85 ff             	test   %rdi,%rdi
   25c97:	74 06                	je     25c9f <_lv_ll_get_prev+0xd>
    n_act_d += LL_PREV_P_OFFSET(ll_p);
   25c99:	8b 07                	mov    (%rdi),%eax
    return *((lv_ll_node_t **)n_act_d);
   25c9b:	48 8b 04 06          	mov    (%rsi,%rax,1),%rax
}
   25c9f:	c3                   	retq   

0000000000025ca0 <_lv_ll_ins_prev>:
    if(NULL == ll_p || NULL == n_act) return NULL;
   25ca0:	48 85 ff             	test   %rdi,%rdi
{
   25ca3:	41 54                	push   %r12
   25ca5:	55                   	push   %rbp
   25ca6:	53                   	push   %rbx
    if(NULL == ll_p || NULL == n_act) return NULL;
   25ca7:	74 73                	je     25d1c <_lv_ll_ins_prev+0x7c>
   25ca9:	48 85 f6             	test   %rsi,%rsi
   25cac:	74 6e                	je     25d1c <_lv_ll_ins_prev+0x7c>
   25cae:	49 89 f4             	mov    %rsi,%r12
   25cb1:	48 89 fb             	mov    %rdi,%rbx
    if(_lv_ll_get_head(ll_p) == n_act) {
   25cb4:	e8 b2 ff ff ff       	callq  25c6b <_lv_ll_get_head>
   25cb9:	4c 39 e0             	cmp    %r12,%rax
   25cbc:	75 0c                	jne    25cca <_lv_ll_ins_prev+0x2a>
        n_new = _lv_ll_ins_head(ll_p);
   25cbe:	48 89 df             	mov    %rbx,%rdi
}
   25cc1:	5b                   	pop    %rbx
   25cc2:	5d                   	pop    %rbp
   25cc3:	41 5c                	pop    %r12
        n_new = _lv_ll_ins_head(ll_p);
   25cc5:	e9 fd fe ff ff       	jmpq   25bc7 <_lv_ll_ins_head>
        n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
   25cca:	8b 3b                	mov    (%rbx),%edi
   25ccc:	48 83 c7 10          	add    $0x10,%rdi
   25cd0:	e8 bc 03 00 00       	callq  26091 <lv_mem_alloc>
        if(n_new == NULL) return NULL;
   25cd5:	48 85 c0             	test   %rax,%rax
        n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
   25cd8:	48 89 c5             	mov    %rax,%rbp
        if(n_new == NULL) return NULL;
   25cdb:	74 41                	je     25d1e <_lv_ll_ins_prev+0x7e>
        n_prev = _lv_ll_get_prev(ll_p, n_act);
   25cdd:	4c 89 e6             	mov    %r12,%rsi
   25ce0:	48 89 df             	mov    %rbx,%rdi
   25ce3:	e8 aa ff ff ff       	callq  25c92 <_lv_ll_get_prev>
        node_set_next(ll_p, n_prev, n_new);
   25ce8:	48 89 df             	mov    %rbx,%rdi
        n_prev = _lv_ll_get_prev(ll_p, n_act);
   25ceb:	48 89 c1             	mov    %rax,%rcx
        node_set_next(ll_p, n_prev, n_new);
   25cee:	48 89 c6             	mov    %rax,%rsi
   25cf1:	48 89 ea             	mov    %rbp,%rdx
   25cf4:	e8 a8 fe ff ff       	callq  25ba1 <node_set_next.isra.1>
        node_set_prev(ll_p, n_new, n_prev);
   25cf9:	48 89 ee             	mov    %rbp,%rsi
   25cfc:	48 89 ca             	mov    %rcx,%rdx
   25cff:	e8 91 fe ff ff       	callq  25b95 <node_set_prev.isra.0>
        node_set_prev(ll_p, n_act, n_new);
   25d04:	48 89 ea             	mov    %rbp,%rdx
   25d07:	4c 89 e6             	mov    %r12,%rsi
   25d0a:	e8 86 fe ff ff       	callq  25b95 <node_set_prev.isra.0>
        node_set_next(ll_p, n_new, n_act);
   25d0f:	4c 89 e2             	mov    %r12,%rdx
   25d12:	48 89 ee             	mov    %rbp,%rsi
   25d15:	e8 87 fe ff ff       	callq  25ba1 <node_set_next.isra.1>
   25d1a:	eb 02                	jmp    25d1e <_lv_ll_ins_prev+0x7e>
    if(NULL == ll_p || NULL == n_act) return NULL;
   25d1c:	31 ed                	xor    %ebp,%ebp
}
   25d1e:	48 89 e8             	mov    %rbp,%rax
   25d21:	5b                   	pop    %rbx
   25d22:	5d                   	pop    %rbp
   25d23:	41 5c                	pop    %r12
   25d25:	c3                   	retq   

0000000000025d26 <_lv_ll_remove>:
{
   25d26:	41 54                	push   %r12
   25d28:	55                   	push   %rbp
   25d29:	48 89 f5             	mov    %rsi,%rbp
   25d2c:	53                   	push   %rbx
   25d2d:	48 89 fb             	mov    %rdi,%rbx
    if(_lv_ll_get_head(ll_p) == node_p) {
   25d30:	e8 36 ff ff ff       	callq  25c6b <_lv_ll_get_head>
   25d35:	48 39 e8             	cmp    %rbp,%rax
   25d38:	75 25                	jne    25d5f <_lv_ll_remove+0x39>
        ll_p->head = _lv_ll_get_next(ll_p, node_p);
   25d3a:	48 89 c6             	mov    %rax,%rsi
   25d3d:	48 89 df             	mov    %rbx,%rdi
   25d40:	e8 3e ff ff ff       	callq  25c83 <_lv_ll_get_next>
        if(ll_p->head == NULL) {
   25d45:	48 85 c0             	test   %rax,%rax
        ll_p->head = _lv_ll_get_next(ll_p, node_p);
   25d48:	48 89 43 08          	mov    %rax,0x8(%rbx)
        if(ll_p->head == NULL) {
   25d4c:	75 0a                	jne    25d58 <_lv_ll_remove+0x32>
            ll_p->tail = NULL;
   25d4e:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
   25d55:	00 
   25d56:	eb 7f                	jmp    25dd7 <_lv_ll_remove+0xb1>
            node_set_prev(ll_p, ll_p->head, NULL);
   25d58:	31 d2                	xor    %edx,%edx
   25d5a:	48 89 c6             	mov    %rax,%rsi
   25d5d:	eb 6c                	jmp    25dcb <_lv_ll_remove+0xa5>
    else if(_lv_ll_get_tail(ll_p) == node_p) {
   25d5f:	48 89 df             	mov    %rbx,%rdi
   25d62:	e8 10 ff ff ff       	callq  25c77 <_lv_ll_get_tail>
   25d67:	48 39 e8             	cmp    %rbp,%rax
   25d6a:	75 2f                	jne    25d9b <_lv_ll_remove+0x75>
        ll_p->tail = _lv_ll_get_prev(ll_p, node_p);
   25d6c:	48 89 c6             	mov    %rax,%rsi
   25d6f:	48 89 df             	mov    %rbx,%rdi
   25d72:	e8 1b ff ff ff       	callq  25c92 <_lv_ll_get_prev>
        if(ll_p->tail == NULL) {
   25d77:	48 85 c0             	test   %rax,%rax
        ll_p->tail = _lv_ll_get_prev(ll_p, node_p);
   25d7a:	48 89 43 10          	mov    %rax,0x10(%rbx)
        if(ll_p->tail == NULL) {
   25d7e:	75 0a                	jne    25d8a <_lv_ll_remove+0x64>
            ll_p->head = NULL;
   25d80:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
   25d87:	00 
   25d88:	eb 4d                	jmp    25dd7 <_lv_ll_remove+0xb1>
            node_set_next(ll_p, ll_p->tail, NULL);
   25d8a:	48 89 df             	mov    %rbx,%rdi
   25d8d:	31 d2                	xor    %edx,%edx
   25d8f:	48 89 c6             	mov    %rax,%rsi
}
   25d92:	5b                   	pop    %rbx
   25d93:	5d                   	pop    %rbp
   25d94:	41 5c                	pop    %r12
            node_set_next(ll_p, ll_p->tail, NULL);
   25d96:	e9 06 fe ff ff       	jmpq   25ba1 <node_set_next.isra.1>
        lv_ll_node_t * n_prev = _lv_ll_get_prev(ll_p, node_p);
   25d9b:	48 89 ee             	mov    %rbp,%rsi
   25d9e:	48 89 df             	mov    %rbx,%rdi
   25da1:	e8 ec fe ff ff       	callq  25c92 <_lv_ll_get_prev>
        lv_ll_node_t * n_next = _lv_ll_get_next(ll_p, node_p);
   25da6:	48 89 ee             	mov    %rbp,%rsi
        lv_ll_node_t * n_prev = _lv_ll_get_prev(ll_p, node_p);
   25da9:	49 89 c4             	mov    %rax,%r12
        lv_ll_node_t * n_next = _lv_ll_get_next(ll_p, node_p);
   25dac:	48 89 df             	mov    %rbx,%rdi
   25daf:	e8 cf fe ff ff       	callq  25c83 <_lv_ll_get_next>
        node_set_next(ll_p, n_prev, n_next);
   25db4:	4c 89 e6             	mov    %r12,%rsi
        lv_ll_node_t * n_next = _lv_ll_get_next(ll_p, node_p);
   25db7:	48 89 c1             	mov    %rax,%rcx
        node_set_next(ll_p, n_prev, n_next);
   25dba:	48 89 c2             	mov    %rax,%rdx
   25dbd:	48 89 df             	mov    %rbx,%rdi
   25dc0:	e8 dc fd ff ff       	callq  25ba1 <node_set_next.isra.1>
        node_set_prev(ll_p, n_next, n_prev);
   25dc5:	4c 89 e2             	mov    %r12,%rdx
   25dc8:	48 89 ce             	mov    %rcx,%rsi
   25dcb:	48 89 df             	mov    %rbx,%rdi
}
   25dce:	5b                   	pop    %rbx
   25dcf:	5d                   	pop    %rbp
   25dd0:	41 5c                	pop    %r12
        node_set_prev(ll_p, n_next, n_prev);
   25dd2:	e9 be fd ff ff       	jmpq   25b95 <node_set_prev.isra.0>
}
   25dd7:	5b                   	pop    %rbx
   25dd8:	5d                   	pop    %rbp
   25dd9:	41 5c                	pop    %r12
   25ddb:	c3                   	retq   

0000000000025ddc <_lv_ll_chg_list>:
{
   25ddc:	41 54                	push   %r12
   25dde:	55                   	push   %rbp
   25ddf:	41 89 cc             	mov    %ecx,%r12d
   25de2:	53                   	push   %rbx
   25de3:	48 89 f3             	mov    %rsi,%rbx
    _lv_ll_remove(ll_ori_p, node);
   25de6:	48 89 d6             	mov    %rdx,%rsi
{
   25de9:	48 89 d5             	mov    %rdx,%rbp
    _lv_ll_remove(ll_ori_p, node);
   25dec:	e8 35 ff ff ff       	callq  25d26 <_lv_ll_remove>
    if(head) {
   25df1:	45 84 e4             	test   %r12b,%r12b
   25df4:	74 38                	je     25e2e <_lv_ll_chg_list+0x52>
        node_set_prev(ll_new_p, node, NULL);
   25df6:	31 d2                	xor    %edx,%edx
   25df8:	48 89 ee             	mov    %rbp,%rsi
   25dfb:	48 89 df             	mov    %rbx,%rdi
   25dfe:	e8 92 fd ff ff       	callq  25b95 <node_set_prev.isra.0>
        node_set_next(ll_new_p, node, ll_new_p->head);
   25e03:	48 8b 53 08          	mov    0x8(%rbx),%rdx
   25e07:	e8 95 fd ff ff       	callq  25ba1 <node_set_next.isra.1>
        if(ll_new_p->head != NULL) { /*If there is old head then before it goes the new*/
   25e0c:	48 8b 73 08          	mov    0x8(%rbx),%rsi
   25e10:	48 85 f6             	test   %rsi,%rsi
   25e13:	74 08                	je     25e1d <_lv_ll_chg_list+0x41>
            node_set_prev(ll_new_p, ll_new_p->head, node);
   25e15:	48 89 ea             	mov    %rbp,%rdx
   25e18:	e8 78 fd ff ff       	callq  25b95 <node_set_prev.isra.0>
        if(ll_new_p->tail == NULL) { /*If there is no tail (first node) set the tail too*/
   25e1d:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
        ll_new_p->head = node;       /*Set the new head in the dsc.*/
   25e22:	48 89 6b 08          	mov    %rbp,0x8(%rbx)
        if(ll_new_p->tail == NULL) { /*If there is no tail (first node) set the tail too*/
   25e26:	75 3c                	jne    25e64 <_lv_ll_chg_list+0x88>
            ll_new_p->tail = node;
   25e28:	48 89 6b 10          	mov    %rbp,0x10(%rbx)
   25e2c:	eb 36                	jmp    25e64 <_lv_ll_chg_list+0x88>
        node_set_prev(ll_new_p, node, ll_new_p->tail);
   25e2e:	48 8b 53 10          	mov    0x10(%rbx),%rdx
   25e32:	48 89 ee             	mov    %rbp,%rsi
   25e35:	48 89 df             	mov    %rbx,%rdi
   25e38:	e8 58 fd ff ff       	callq  25b95 <node_set_prev.isra.0>
        node_set_next(ll_new_p, node, NULL);
   25e3d:	31 d2                	xor    %edx,%edx
   25e3f:	e8 5d fd ff ff       	callq  25ba1 <node_set_next.isra.1>
        if(ll_new_p->tail != NULL) { /*If there is old tail then after it goes the new*/
   25e44:	48 8b 73 10          	mov    0x10(%rbx),%rsi
   25e48:	48 85 f6             	test   %rsi,%rsi
   25e4b:	74 08                	je     25e55 <_lv_ll_chg_list+0x79>
            node_set_next(ll_new_p, ll_new_p->tail, node);
   25e4d:	48 89 ea             	mov    %rbp,%rdx
   25e50:	e8 4c fd ff ff       	callq  25ba1 <node_set_next.isra.1>
        if(ll_new_p->head == NULL) { /*If there is no head (first node) set the head too*/
   25e55:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
        ll_new_p->tail = node;       /*Set the new tail in the dsc.*/
   25e5a:	48 89 6b 10          	mov    %rbp,0x10(%rbx)
        if(ll_new_p->head == NULL) { /*If there is no head (first node) set the head too*/
   25e5e:	75 04                	jne    25e64 <_lv_ll_chg_list+0x88>
            ll_new_p->head = node;
   25e60:	48 89 6b 08          	mov    %rbp,0x8(%rbx)
}
   25e64:	5b                   	pop    %rbx
   25e65:	5d                   	pop    %rbp
   25e66:	41 5c                	pop    %r12
   25e68:	c3                   	retq   

0000000000025e69 <_lv_ll_move_before>:
    if(n_act == n_after) return; /*Can't move before itself*/
   25e69:	48 39 d6             	cmp    %rdx,%rsi
   25e6c:	0f 84 c2 00 00 00    	je     25f34 <_lv_ll_move_before+0xcb>
{
   25e72:	41 55                	push   %r13
   25e74:	41 54                	push   %r12
   25e76:	49 89 d5             	mov    %rdx,%r13
   25e79:	55                   	push   %rbp
   25e7a:	53                   	push   %rbx
   25e7b:	48 89 fd             	mov    %rdi,%rbp
   25e7e:	48 89 f3             	mov    %rsi,%rbx
   25e81:	48 83 ec 08          	sub    $0x8,%rsp
    if(n_after != NULL)
   25e85:	48 85 d2             	test   %rdx,%rdx
   25e88:	74 50                	je     25eda <_lv_ll_move_before+0x71>
        n_before = _lv_ll_get_prev(ll_p, n_after);
   25e8a:	48 89 d6             	mov    %rdx,%rsi
   25e8d:	e8 00 fe ff ff       	callq  25c92 <_lv_ll_get_prev>
    if(n_act == n_before) return; /*Already before `n_after`*/
   25e92:	48 39 c3             	cmp    %rax,%rbx
        n_before = _lv_ll_get_prev(ll_p, n_after);
   25e95:	49 89 c4             	mov    %rax,%r12
    if(n_act == n_before) return; /*Already before `n_after`*/
   25e98:	0f 84 8e 00 00 00    	je     25f2c <_lv_ll_move_before+0xc3>
    _lv_ll_remove(ll_p, n_act);
   25e9e:	48 89 de             	mov    %rbx,%rsi
   25ea1:	48 89 ef             	mov    %rbp,%rdi
   25ea4:	e8 7d fe ff ff       	callq  25d26 <_lv_ll_remove>
    node_set_next(ll_p, n_before, n_act);
   25ea9:	48 89 ef             	mov    %rbp,%rdi
   25eac:	48 89 da             	mov    %rbx,%rdx
   25eaf:	4c 89 e6             	mov    %r12,%rsi
   25eb2:	e8 ea fc ff ff       	callq  25ba1 <node_set_next.isra.1>
    node_set_prev(ll_p, n_act, n_before);
   25eb7:	4c 89 e2             	mov    %r12,%rdx
   25eba:	48 89 de             	mov    %rbx,%rsi
   25ebd:	e8 d3 fc ff ff       	callq  25b95 <node_set_prev.isra.0>
    node_set_prev(ll_p, n_after, n_act);
   25ec2:	48 89 da             	mov    %rbx,%rdx
   25ec5:	4c 89 ee             	mov    %r13,%rsi
   25ec8:	e8 c8 fc ff ff       	callq  25b95 <node_set_prev.isra.0>
    node_set_next(ll_p, n_act, n_after);
   25ecd:	4c 89 ea             	mov    %r13,%rdx
   25ed0:	48 89 de             	mov    %rbx,%rsi
   25ed3:	e8 c9 fc ff ff       	callq  25ba1 <node_set_next.isra.1>
   25ed8:	eb 49                	jmp    25f23 <_lv_ll_move_before+0xba>
        n_before = _lv_ll_get_tail(ll_p); /*if `n_after` is NULL `n_act` should be the new tail*/
   25eda:	e8 98 fd ff ff       	callq  25c77 <_lv_ll_get_tail>
    if(n_act == n_before) return; /*Already before `n_after`*/
   25edf:	48 39 c3             	cmp    %rax,%rbx
        n_before = _lv_ll_get_tail(ll_p); /*if `n_after` is NULL `n_act` should be the new tail*/
   25ee2:	49 89 c4             	mov    %rax,%r12
    if(n_act == n_before) return; /*Already before `n_after`*/
   25ee5:	74 45                	je     25f2c <_lv_ll_move_before+0xc3>
    _lv_ll_remove(ll_p, n_act);
   25ee7:	48 89 de             	mov    %rbx,%rsi
   25eea:	48 89 ef             	mov    %rbp,%rdi
   25eed:	e8 34 fe ff ff       	callq  25d26 <_lv_ll_remove>
    node_set_next(ll_p, n_before, n_act);
   25ef2:	48 89 ef             	mov    %rbp,%rdi
   25ef5:	48 89 da             	mov    %rbx,%rdx
   25ef8:	4c 89 e6             	mov    %r12,%rsi
   25efb:	e8 a1 fc ff ff       	callq  25ba1 <node_set_next.isra.1>
    node_set_prev(ll_p, n_act, n_before);
   25f00:	4c 89 e2             	mov    %r12,%rdx
   25f03:	48 89 de             	mov    %rbx,%rsi
   25f06:	e8 8a fc ff ff       	callq  25b95 <node_set_prev.isra.0>
    node_set_prev(ll_p, n_after, n_act);
   25f0b:	48 89 da             	mov    %rbx,%rdx
   25f0e:	31 f6                	xor    %esi,%esi
   25f10:	e8 80 fc ff ff       	callq  25b95 <node_set_prev.isra.0>
    node_set_next(ll_p, n_act, n_after);
   25f15:	31 d2                	xor    %edx,%edx
   25f17:	48 89 de             	mov    %rbx,%rsi
   25f1a:	e8 82 fc ff ff       	callq  25ba1 <node_set_next.isra.1>
    if(n_after == NULL) ll_p->tail = n_act;
   25f1f:	48 89 5d 10          	mov    %rbx,0x10(%rbp)
    if(n_before == NULL) ll_p->head = n_act;
   25f23:	4d 85 e4             	test   %r12,%r12
   25f26:	75 04                	jne    25f2c <_lv_ll_move_before+0xc3>
   25f28:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
}
   25f2c:	58                   	pop    %rax
   25f2d:	5b                   	pop    %rbx
   25f2e:	5d                   	pop    %rbp
   25f2f:	41 5c                	pop    %r12
   25f31:	41 5d                	pop    %r13
   25f33:	c3                   	retq   
   25f34:	c3                   	retq   

0000000000025f35 <_lv_ll_is_empty>:
    if(ll_p == NULL) return true;
   25f35:	48 85 ff             	test   %rdi,%rdi
   25f38:	b0 01                	mov    $0x1,%al
   25f3a:	74 11                	je     25f4d <_lv_ll_is_empty+0x18>
    return false;
   25f3c:	31 c0                	xor    %eax,%eax
    if(ll_p->head == NULL && ll_p->tail == NULL) return true;
   25f3e:	48 83 7f 08 00       	cmpq   $0x0,0x8(%rdi)
   25f43:	75 08                	jne    25f4d <_lv_ll_is_empty+0x18>
   25f45:	48 83 7f 10 00       	cmpq   $0x0,0x10(%rdi)
   25f4a:	0f 94 c0             	sete   %al
}
   25f4d:	c3                   	retq   

0000000000025f4e <lv_log_register_print_cb>:
 * and send the formatted log message to a console or serial port.
 * @param print_cb a function pointer to print a log
 */
void lv_log_register_print_cb(lv_log_print_g_cb_t print_cb)
{
    custom_print_cb = print_cb;
   25f4e:	48 89 3d b3 20 23 00 	mov    %rdi,0x2320b3(%rip)        # 258008 <custom_print_cb>
}
   25f55:	c3                   	retq   

0000000000025f56 <_lv_log_add>:
 * @param func name of the function when the log added
 * @param format printf-like format string
 * @param ... parameters for `format`
 */
void _lv_log_add(lv_log_level_t level, const char * file, int line, const char * func, const char * format, ...)
{
   25f56:	41 56                	push   %r14
   25f58:	41 55                	push   %r13
   25f5a:	49 89 cd             	mov    %rcx,%r13
   25f5d:	41 54                	push   %r12
   25f5f:	55                   	push   %rbp
   25f60:	41 89 d4             	mov    %edx,%r12d
   25f63:	53                   	push   %rbx
   25f64:	48 89 f5             	mov    %rsi,%rbp
   25f67:	89 fb                	mov    %edi,%ebx
   25f69:	48 81 ec d0 01 00 00 	sub    $0x1d0,%rsp
   25f70:	84 c0                	test   %al,%al
   25f72:	4c 89 8c 24 48 01 00 	mov    %r9,0x148(%rsp)
   25f79:	00 
   25f7a:	74 40                	je     25fbc <_lv_log_add+0x66>
   25f7c:	0f 29 84 24 50 01 00 	movaps %xmm0,0x150(%rsp)
   25f83:	00 
   25f84:	0f 29 8c 24 60 01 00 	movaps %xmm1,0x160(%rsp)
   25f8b:	00 
   25f8c:	0f 29 94 24 70 01 00 	movaps %xmm2,0x170(%rsp)
   25f93:	00 
   25f94:	0f 29 9c 24 80 01 00 	movaps %xmm3,0x180(%rsp)
   25f9b:	00 
   25f9c:	0f 29 a4 24 90 01 00 	movaps %xmm4,0x190(%rsp)
   25fa3:	00 
   25fa4:	0f 29 ac 24 a0 01 00 	movaps %xmm5,0x1a0(%rsp)
   25fab:	00 
   25fac:	0f 29 b4 24 b0 01 00 	movaps %xmm6,0x1b0(%rsp)
   25fb3:	00 
   25fb4:	0f 29 bc 24 c0 01 00 	movaps %xmm7,0x1c0(%rsp)
   25fbb:	00 
   25fbc:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   25fc3:	00 00 
   25fc5:	48 89 84 24 18 01 00 	mov    %rax,0x118(%rsp)
   25fcc:	00 
   25fcd:	31 c0                	xor    %eax,%eax
    if(level >= _LV_LOG_LEVEL_NUM) return; /*Invalid level*/

    if(level >= LV_LOG_LEVEL) {
   25fcf:	8d 43 ff             	lea    -0x1(%rbx),%eax
   25fd2:	3c 04                	cmp    $0x4,%al
   25fd4:	77 65                	ja     2603b <_lv_log_add+0xe5>
        va_list args;
        va_start(args, format);
   25fd6:	48 8d 84 24 00 02 00 	lea    0x200(%rsp),%rax
   25fdd:	00 
  return __builtin___vsnprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   25fde:	4c 8d 74 24 18       	lea    0x18(%rsp),%r14
   25fe3:	49 89 e1             	mov    %rsp,%r9
   25fe6:	b9 00 01 00 00       	mov    $0x100,%ecx
   25feb:	ba 01 00 00 00       	mov    $0x1,%edx
   25ff0:	be 00 01 00 00       	mov    $0x100,%esi
   25ff5:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   25ffa:	48 8d 84 24 20 01 00 	lea    0x120(%rsp),%rax
   26001:	00 
   26002:	4c 89 f7             	mov    %r14,%rdi
   26005:	c7 04 24 28 00 00 00 	movl   $0x28,(%rsp)
   2600c:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
   26013:	00 
   26014:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
   26019:	e8 32 e5 fd ff       	callq  4550 <__vsnprintf_chk@plt>
        }

        static const char * lvl_prefix[] = {"Trace", "Info", "Warn", "Error", "User"};
        printf("%s: %s \t(%s #%d %s())\n", lvl_prefix[level], buf, &file[p], line, func);
#else
        if(custom_print_cb) custom_print_cb(level, file, line, func, buf);
   2601e:	48 8b 05 e3 1f 23 00 	mov    0x231fe3(%rip),%rax        # 258008 <custom_print_cb>
   26025:	48 85 c0             	test   %rax,%rax
   26028:	74 11                	je     2603b <_lv_log_add+0xe5>
   2602a:	0f be fb             	movsbl %bl,%edi
   2602d:	4d 89 f0             	mov    %r14,%r8
   26030:	4c 89 e9             	mov    %r13,%rcx
   26033:	44 89 e2             	mov    %r12d,%edx
   26036:	48 89 ee             	mov    %rbp,%rsi
   26039:	ff d0                	callq  *%rax
#endif
    }
}
   2603b:	48 8b 84 24 18 01 00 	mov    0x118(%rsp),%rax
   26042:	00 
   26043:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   2604a:	00 00 
   2604c:	74 05                	je     26053 <_lv_log_add+0xfd>
   2604e:	e8 ed e5 fd ff       	callq  4640 <__stack_chk_fail@plt>
   26053:	48 81 c4 d0 01 00 00 	add    $0x1d0,%rsp
   2605a:	5b                   	pop    %rbx
   2605b:	5d                   	pop    %rbp
   2605c:	41 5c                	pop    %r12
   2605e:	41 5d                	pop    %r13
   26060:	41 5e                	pop    %r14
   26062:	c3                   	retq   

0000000000026063 <_lv_sqrt>:
 * If root < 256: mask = 0x800
 * Else: mask = 0x8000
 */
LV_ATTRIBUTE_FAST_MEM void _lv_sqrt(uint32_t x, lv_sqrt_res_t * q, uint32_t mask)
{
    x = x << 8; /*To get 4 bit precision. (sqrt(256) = 16 = 4 bit)*/
   26063:	c1 e7 08             	shl    $0x8,%edi

    uint32_t root = 0;
   26066:	31 c0                	xor    %eax,%eax
    uint32_t trial;
    // http://ww1.microchip.com/...en/AppNotes/91040a.pdf
    do {
        trial = root + mask;
   26068:	8d 0c 02             	lea    (%rdx,%rax,1),%ecx
        if((uint32_t)trial * trial <= x) root = trial;
   2606b:	41 89 c8             	mov    %ecx,%r8d
   2606e:	44 0f af c1          	imul   %ecx,%r8d
   26072:	41 39 f8             	cmp    %edi,%r8d
   26075:	0f 46 c1             	cmovbe %ecx,%eax
        mask = mask >> 1;
    } while(mask);
   26078:	d1 ea                	shr    %edx
   2607a:	75 ec                	jne    26068 <_lv_sqrt+0x5>

    q->i = (uint32_t) root >> 4;
   2607c:	89 c2                	mov    %eax,%edx
    q->f = (uint32_t)(root & 0xf) << 4;
   2607e:	c1 e0 04             	shl    $0x4,%eax
    q->i = (uint32_t) root >> 4;
   26081:	c1 ea 04             	shr    $0x4,%edx
    q->f = (uint32_t)(root & 0xf) << 4;
   26084:	66 25 ff 00          	and    $0xff,%ax
    q->i = (uint32_t) root >> 4;
   26088:	66 89 16             	mov    %dx,(%rsi)
    q->f = (uint32_t)(root & 0xf) << 4;
   2608b:	66 89 46 02          	mov    %ax,0x2(%rsi)
}
   2608f:	c3                   	retq   

0000000000026090 <_lv_mem_init>:
    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
   26090:	c3                   	retq   

0000000000026091 <lv_mem_alloc>:
 * Allocate a memory dynamically
 * @param size size of the memory to allocate in bytes
 * @return pointer to the allocated memory
 */
void * lv_mem_alloc(size_t size)
{
   26091:	55                   	push   %rbp
   26092:	53                   	push   %rbx
    if(size == 0) {
        return &zero_mem;
   26093:	48 8d 2d 0e 90 23 00 	lea    0x23900e(%rip),%rbp        # 25f0a8 <zero_mem>
{
   2609a:	48 83 ec 08          	sub    $0x8,%rsp
    if(size == 0) {
   2609e:	48 85 ff             	test   %rdi,%rdi
   260a1:	74 5a                	je     260fd <lv_mem_alloc+0x6c>
    }

#ifdef LV_ARCH_64
    /*Round the size up to 8*/
    size = (size + 7) & (~0x7);
   260a3:	48 8d 5f 07          	lea    0x7(%rdi),%rbx
 *
 * @return Address of the allocated memory if successful; otherwise NULL.
 */
static inline void *k_malloc(size_t size)
{
	return k_aligned_alloc(sizeof(void *), size);
   260a7:	bf 08 00 00 00       	mov    $0x8,%edi
   260ac:	48 83 e3 f8          	and    $0xfffffffffffffff8,%rbx
    /*Use custom, user defined malloc function*/
#if LV_ENABLE_GC == 1 /*gc must not include header*/
    alloc = LV_MEM_CUSTOM_ALLOC(size);
#else                 /* LV_ENABLE_GC */
    /*Allocate a header too to store the size*/
    alloc = LV_MEM_CUSTOM_ALLOC(size + sizeof(lv_mem_header_t));
   260b0:	48 8d 73 08          	lea    0x8(%rbx),%rsi
   260b4:	e8 ca 6d 00 00       	callq  2ce83 <k_aligned_alloc>
    if(alloc != NULL) {
   260b9:	48 85 c0             	test   %rax,%rax
   260bc:	48 89 c5             	mov    %rax,%rbp
   260bf:	74 16                	je     260d7 <lv_mem_alloc+0x46>
        ((lv_mem_ent_t *)alloc)->header.s.d_size = size;
   260c1:	8b 38                	mov    (%rax),%edi
   260c3:	01 db                	add    %ebx,%ebx
        ((lv_mem_ent_t *)alloc)->header.s.used   = 1;

        alloc = &((lv_mem_ent_t *)alloc)->first_data;
   260c5:	48 83 c5 08          	add    $0x8,%rbp
        ((lv_mem_ent_t *)alloc)->header.s.d_size = size;
   260c9:	83 e7 01             	and    $0x1,%edi
   260cc:	09 fb                	or     %edi,%ebx
   260ce:	89 18                	mov    %ebx,(%rax)
        ((lv_mem_ent_t *)alloc)->header.s.used   = 1;
   260d0:	83 cb 01             	or     $0x1,%ebx
   260d3:	88 18                	mov    %bl,(%rax)
   260d5:	eb 26                	jmp    260fd <lv_mem_alloc+0x6c>
#if LV_MEM_ADD_JUNK
    if(alloc != NULL) _lv_memset(alloc, 0xaa, size);
#endif

    if(alloc == NULL) {
        LV_LOG_WARN("Couldn't allocate memory");
   260d7:	4c 8d 05 41 dc 00 00 	lea    0xdc41(%rip),%r8        # 33d1f <_lv_bpp1_opa_table+0x4ca>
   260de:	48 8d 0d 63 ab 00 00 	lea    0xab63(%rip),%rcx        # 30c48 <__func__.5804>
   260e5:	48 8d 35 4c dc 00 00 	lea    0xdc4c(%rip),%rsi        # 33d38 <_lv_bpp1_opa_table+0x4e3>
   260ec:	ba d0 00 00 00       	mov    $0xd0,%edx
   260f1:	bf 02 00 00 00       	mov    $0x2,%edi
   260f6:	31 c0                	xor    %eax,%eax
   260f8:	e8 59 fe ff ff       	callq  25f56 <_lv_log_add>
        }
#endif
    }

    return alloc;
}
   260fd:	48 89 e8             	mov    %rbp,%rax
   26100:	5a                   	pop    %rdx
   26101:	5b                   	pop    %rbx
   26102:	5d                   	pop    %rbp
   26103:	c3                   	retq   

0000000000026104 <lv_mem_free>:
 * @param data pointer to an allocated memory
 */
void lv_mem_free(const void * data)
{
    if(data == &zero_mem) return;
    if(data == NULL) return;
   26104:	48 8d 05 9d 8f 23 00 	lea    0x238f9d(%rip),%rax        # 25f0a8 <zero_mem>
   2610b:	48 39 c7             	cmp    %rax,%rdi
   2610e:	74 12                	je     26122 <lv_mem_free+0x1e>
   26110:	48 85 ff             	test   %rdi,%rdi
   26113:	74 0d                	je     26122 <lv_mem_free+0x1e>
#endif

#if LV_ENABLE_GC == 0
    /*e points to the header*/
    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));
    e->header.s.used = 0;
   26115:	80 67 f8 fe          	andb   $0xfe,-0x8(%rdi)
    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));
   26119:	48 83 ef 08          	sub    $0x8,%rdi


#endif /*LV_MEM_AUTO_DEFRAG*/
#else /*Use custom, user defined free function*/
#if LV_ENABLE_GC == 0
    LV_MEM_CUSTOM_FREE(e);
   2611d:	e9 4e 6d 00 00       	jmpq   2ce70 <k_free>
#else
    LV_MEM_CUSTOM_FREE((void *)data);
#endif /*LV_ENABLE_GC*/
#endif
}
   26122:	c3                   	retq   

0000000000026123 <_lv_mem_get_size>:
#if LV_ENABLE_GC == 0

uint32_t _lv_mem_get_size(const void * data)
{
    if(data == NULL) return 0;
    if(data == &zero_mem) return 0;
   26123:	48 85 ff             	test   %rdi,%rdi
   26126:	74 12                	je     2613a <_lv_mem_get_size+0x17>
   26128:	48 8d 05 79 8f 23 00 	lea    0x238f79(%rip),%rax        # 25f0a8 <zero_mem>
   2612f:	48 39 c7             	cmp    %rax,%rdi
   26132:	74 06                	je     2613a <_lv_mem_get_size+0x17>

    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));

    return e->header.s.d_size;
   26134:	8b 47 f8             	mov    -0x8(%rdi),%eax
   26137:	d1 e8                	shr    %eax
   26139:	c3                   	retq   
    if(data == &zero_mem) return 0;
   2613a:	31 c0                	xor    %eax,%eax
}
   2613c:	c3                   	retq   

000000000002613d <lv_mem_realloc>:
    new_size = (new_size + 7) & (~0x7);
   2613d:	48 8d 4e 07          	lea    0x7(%rsi),%rcx
{
   26141:	41 56                	push   %r14
   26143:	41 55                	push   %r13
   26145:	41 54                	push   %r12
   26147:	55                   	push   %rbp
    new_size = (new_size + 7) & (~0x7);
   26148:	48 83 e1 f8          	and    $0xfffffffffffffff8,%rcx
    if(data_p != NULL) {
   2614c:	48 85 ff             	test   %rdi,%rdi
{
   2614f:	53                   	push   %rbx
    new_size = (new_size + 7) & (~0x7);
   26150:	49 89 cc             	mov    %rcx,%r12
{
   26153:	48 89 fb             	mov    %rdi,%rbx
    if(data_p != NULL) {
   26156:	74 0d                	je     26165 <lv_mem_realloc+0x28>
            data_p = NULL;
   26158:	f6 47 f8 01          	testb  $0x1,-0x8(%rdi)
   2615c:	b8 00 00 00 00       	mov    $0x0,%eax
   26161:	48 0f 44 d8          	cmove  %rax,%rbx
    uint32_t old_size = _lv_mem_get_size(data_p);
   26165:	48 89 df             	mov    %rbx,%rdi
   26168:	49 89 dd             	mov    %rbx,%r13
   2616b:	e8 b3 ff ff ff       	callq  26123 <_lv_mem_get_size>
   26170:	89 c5                	mov    %eax,%ebp
    if(old_size == new_size) return data_p; /*Also avoid reallocating the same memory*/
   26172:	4c 39 e5             	cmp    %r12,%rbp
   26175:	74 5b                	je     261d2 <lv_mem_realloc+0x95>
    new_p = lv_mem_alloc(new_size);
   26177:	4c 89 e7             	mov    %r12,%rdi
   2617a:	e8 12 ff ff ff       	callq  26091 <lv_mem_alloc>
    if(new_p == NULL) {
   2617f:	48 85 c0             	test   %rax,%rax
    new_p = lv_mem_alloc(new_size);
   26182:	49 89 c5             	mov    %rax,%r13
    if(new_p == NULL) {
   26185:	75 28                	jne    261af <lv_mem_realloc+0x72>
        LV_LOG_WARN("Couldn't allocate memory");
   26187:	4c 8d 05 91 db 00 00 	lea    0xdb91(%rip),%r8        # 33d1f <_lv_bpp1_opa_table+0x4ca>
   2618e:	48 8d 0d a3 aa 00 00 	lea    0xaaa3(%rip),%rcx        # 30c38 <__func__.5816>
   26195:	48 8d 35 9c db 00 00 	lea    0xdb9c(%rip),%rsi        # 33d38 <_lv_bpp1_opa_table+0x4e3>
   2619c:	ba 43 01 00 00       	mov    $0x143,%edx
   261a1:	bf 02 00 00 00       	mov    $0x2,%edi
   261a6:	31 c0                	xor    %eax,%eax
   261a8:	e8 a9 fd ff ff       	callq  25f56 <_lv_log_add>
   261ad:	eb 23                	jmp    261d2 <lv_mem_realloc+0x95>
        if(old_size != 0) {
   261af:	85 ed                	test   %ebp,%ebp
   261b1:	74 1f                	je     261d2 <lv_mem_realloc+0x95>
   261b3:	48 85 db             	test   %rbx,%rbx
   261b6:	74 1a                	je     261d2 <lv_mem_realloc+0x95>
            _lv_memcpy(new_p, data_p, LV_MATH_MIN(new_size, old_size));
   261b8:	4c 39 e5             	cmp    %r12,%rbp
   261bb:	4c 89 e1             	mov    %r12,%rcx
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
   261be:	48 89 c7             	mov    %rax,%rdi
   261c1:	48 0f 46 cd          	cmovbe %rbp,%rcx
   261c5:	48 89 de             	mov    %rbx,%rsi
   261c8:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
            lv_mem_free(data_p);
   261ca:	48 89 df             	mov    %rbx,%rdi
   261cd:	e8 32 ff ff ff       	callq  26104 <lv_mem_free>
}
   261d2:	5b                   	pop    %rbx
   261d3:	4c 89 e8             	mov    %r13,%rax
   261d6:	5d                   	pop    %rbp
   261d7:	41 5c                	pop    %r12
   261d9:	41 5d                	pop    %r13
   261db:	41 5e                	pop    %r14
   261dd:	c3                   	retq   

00000000000261de <_lv_mem_buf_get>:
 * Get a temporal buffer with the given size.
 * @param size the required size
 */
void * _lv_mem_buf_get(uint32_t size)
{
    if(size == 0) return NULL;
   261de:	31 c0                	xor    %eax,%eax
   261e0:	85 ff                	test   %edi,%edi
   261e2:	0f 84 e4 00 00 00    	je     262cc <_lv_mem_buf_get+0xee>

    /*Try small static buffers first*/
    uint8_t i;
    if(size <= MEM_BUF_SMALL_SIZE) {
   261e8:	83 ff 10             	cmp    $0x10,%edi
   261eb:	77 2f                	ja     2621c <_lv_mem_buf_get+0x3e>
        for(i = 0; i < sizeof(mem_buf_small) / sizeof(mem_buf_small[0]); i++) {
            if(mem_buf_small[i].used == 0) {
   261ed:	f6 05 d6 06 21 00 01 	testb  $0x1,0x2106d6(%rip)        # 2368ca <mem_buf_small+0xa>
   261f4:	74 14                	je     2620a <_lv_mem_buf_get+0x2c>
   261f6:	31 d2                	xor    %edx,%edx
   261f8:	f6 05 db 06 21 00 01 	testb  $0x1,0x2106db(%rip)        # 2368da <mem_buf_small+0x1a>
   261ff:	b0 ff                	mov    $0xff,%al
   26201:	75 1d                	jne    26220 <_lv_mem_buf_get+0x42>
   26203:	b8 01 00 00 00       	mov    $0x1,%eax
   26208:	eb 02                	jmp    2620c <_lv_mem_buf_get+0x2e>
   2620a:	31 c0                	xor    %eax,%eax
                mem_buf_small[i].used = 1;
   2620c:	48 8d 15 ad 06 21 00 	lea    0x2106ad(%rip),%rdx        # 2368c0 <mem_buf_small>
   26213:	48 c1 e0 04          	shl    $0x4,%rax
   26217:	48 01 d0             	add    %rdx,%rax
   2621a:	eb 70                	jmp    2628c <_lv_mem_buf_get+0xae>
   2621c:	31 d2                	xor    %edx,%edx
   2621e:	b0 ff                	mov    $0xff,%al
    }

    /*Try to find a free buffer with suitable size */
    int8_t i_guess = -1;
    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
        if(LV_GC_ROOT(_lv_mem_buf[i]).used == 0 && LV_GC_ROOT(_lv_mem_buf[i]).size >= size) {
   26220:	48 8d 35 79 16 23 00 	lea    0x231679(%rip),%rsi        # 2578a0 <_lv_mem_buf>
   26227:	48 63 ca             	movslq %edx,%rcx
   2622a:	48 c1 e1 04          	shl    $0x4,%rcx
   2622e:	48 01 f1             	add    %rsi,%rcx
   26231:	44 8a 41 0a          	mov    0xa(%rcx),%r8b
   26235:	41 f6 c0 01          	test   $0x1,%r8b
   26239:	75 39                	jne    26274 <_lv_mem_buf_get+0x96>
   2623b:	49 89 d1             	mov    %rdx,%r9
   2623e:	49 c1 e1 04          	shl    $0x4,%r9
   26242:	45 0f b7 54 31 08    	movzwl 0x8(%r9,%rsi,1),%r10d
   26248:	41 39 fa             	cmp    %edi,%r10d
   2624b:	72 27                	jb     26274 <_lv_mem_buf_get+0x96>
            if(LV_GC_ROOT(_lv_mem_buf[i]).size == size) {
   2624d:	75 0c                	jne    2625b <_lv_mem_buf_get+0x7d>
                LV_GC_ROOT(_lv_mem_buf[i]).used = 1;
   2624f:	41 83 c8 01          	or     $0x1,%r8d
                return LV_GC_ROOT(_lv_mem_buf[i]).p;
   26253:	48 8b 01             	mov    (%rcx),%rax
                LV_GC_ROOT(_lv_mem_buf[i]).used = 1;
   26256:	44 88 41 0a          	mov    %r8b,0xa(%rcx)
                return LV_GC_ROOT(_lv_mem_buf[i]).p;
   2625a:	c3                   	retq   
            }
            else if(i_guess < 0) {
   2625b:	3c ff                	cmp    $0xff,%al
   2625d:	75 04                	jne    26263 <_lv_mem_buf_get+0x85>
                i_guess = i;
   2625f:	88 d0                	mov    %dl,%al
   26261:	eb 11                	jmp    26274 <_lv_mem_buf_get+0x96>
            }
            /*If size of `i` is closer to `size` prefer it*/
            else if(LV_GC_ROOT(_lv_mem_buf[i]).size < LV_GC_ROOT(_lv_mem_buf[i_guess]).size) {
   26263:	48 0f be c8          	movsbq %al,%rcx
   26267:	48 c1 e1 04          	shl    $0x4,%rcx
                i_guess = i;
   2626b:	66 44 3b 54 0e 08    	cmp    0x8(%rsi,%rcx,1),%r10w
   26271:	0f 42 c2             	cmovb  %edx,%eax
   26274:	48 ff c2             	inc    %rdx
    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
   26277:	48 83 fa 10          	cmp    $0x10,%rdx
   2627b:	75 aa                	jne    26227 <_lv_mem_buf_get+0x49>
            }
        }
    }

    if(i_guess >= 0) {
   2627d:	3c ff                	cmp    $0xff,%al
   2627f:	74 13                	je     26294 <_lv_mem_buf_get+0xb6>
        LV_GC_ROOT(_lv_mem_buf[i_guess]).used = 1;
   26281:	48 0f be c0          	movsbq %al,%rax
   26285:	48 c1 e0 04          	shl    $0x4,%rax
   26289:	48 01 f0             	add    %rsi,%rax
   2628c:	80 48 0a 01          	orb    $0x1,0xa(%rax)
        return LV_GC_ROOT(_lv_mem_buf[i_guess]).p;
   26290:	48 8b 00             	mov    (%rax),%rax
   26293:	c3                   	retq   
{
   26294:	53                   	push   %rbx
   26295:	31 d2                	xor    %edx,%edx
    }


    /*Reallocate a free buffer*/
    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
        if(LV_GC_ROOT(_lv_mem_buf[i]).used == 0) {
   26297:	48 63 da             	movslq %edx,%rbx
   2629a:	48 c1 e3 04          	shl    $0x4,%rbx
   2629e:	48 01 f3             	add    %rsi,%rbx
   262a1:	8a 43 0a             	mov    0xa(%rbx),%al
   262a4:	a8 01                	test   $0x1,%al
   262a6:	75 19                	jne    262c1 <_lv_mem_buf_get+0xe3>
            LV_GC_ROOT(_lv_mem_buf[i]).used = 1;
            LV_GC_ROOT(_lv_mem_buf[i]).size = size;
   262a8:	66 89 7b 08          	mov    %di,0x8(%rbx)
            /*if this fails you probably need to increase your LV_MEM_SIZE/heap size*/
            LV_GC_ROOT(_lv_mem_buf[i]).p = lv_mem_realloc(LV_GC_ROOT(_lv_mem_buf[i]).p, size);
   262ac:	89 fe                	mov    %edi,%esi
   262ae:	48 8b 3b             	mov    (%rbx),%rdi
            LV_GC_ROOT(_lv_mem_buf[i]).used = 1;
   262b1:	83 c8 01             	or     $0x1,%eax
   262b4:	88 43 0a             	mov    %al,0xa(%rbx)
            LV_GC_ROOT(_lv_mem_buf[i]).p = lv_mem_realloc(LV_GC_ROOT(_lv_mem_buf[i]).p, size);
   262b7:	e8 81 fe ff ff       	callq  2613d <lv_mem_realloc>
   262bc:	48 89 03             	mov    %rax,(%rbx)
            if(LV_GC_ROOT(_lv_mem_buf[i]).p == NULL) {
                LV_DEBUG_ASSERT(false, "Out of memory, can't allocate a new  buffer (increase your LV_MEM_SIZE/heap size", 0x00);
            }
            return  LV_GC_ROOT(_lv_mem_buf[i]).p;
   262bf:	eb 09                	jmp    262ca <_lv_mem_buf_get+0xec>
   262c1:	ff c2                	inc    %edx
    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
   262c3:	83 fa 10             	cmp    $0x10,%edx
   262c6:	75 cf                	jne    26297 <_lv_mem_buf_get+0xb9>
    if(size == 0) return NULL;
   262c8:	31 c0                	xor    %eax,%eax
        }
    }

    LV_DEBUG_ASSERT(false, "No free buffer. Increase LV_DRAW_BUF_MAX_NUM.", 0x00);
    return NULL;
}
   262ca:	5b                   	pop    %rbx
   262cb:	c3                   	retq   
   262cc:	c3                   	retq   

00000000000262cd <_lv_mem_buf_release>:
{
    uint8_t i;

    /*Try small static buffers first*/
    for(i = 0; i < sizeof(mem_buf_small) / sizeof(mem_buf_small[0]); i++) {
        if(mem_buf_small[i].p == p) {
   262cd:	48 3b 3d ec 05 21 00 	cmp    0x2105ec(%rip),%rdi        # 2368c0 <mem_buf_small>
   262d4:	74 1b                	je     262f1 <_lv_mem_buf_release+0x24>
   262d6:	31 d2                	xor    %edx,%edx
   262d8:	48 3b 3d f1 05 21 00 	cmp    0x2105f1(%rip),%rdi        # 2368d0 <mem_buf_small+0x10>
   262df:	74 09                	je     262ea <_lv_mem_buf_release+0x1d>
            return;
        }
    }

    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
        if(LV_GC_ROOT(_lv_mem_buf[i]).p == p) {
   262e1:	48 8d 0d b8 15 23 00 	lea    0x2315b8(%rip),%rcx        # 2578a0 <_lv_mem_buf>
   262e8:	eb 1a                	jmp    26304 <_lv_mem_buf_release+0x37>
        if(mem_buf_small[i].p == p) {
   262ea:	b8 01 00 00 00       	mov    $0x1,%eax
   262ef:	eb 02                	jmp    262f3 <_lv_mem_buf_release+0x26>
   262f1:	31 c0                	xor    %eax,%eax
            mem_buf_small[i].used = 0;
   262f3:	48 8d 15 c6 05 21 00 	lea    0x2105c6(%rip),%rdx        # 2368c0 <mem_buf_small>
   262fa:	48 c1 e0 04          	shl    $0x4,%rax
   262fe:	80 64 02 0a fe       	andb   $0xfe,0xa(%rdx,%rax,1)
            return;
   26303:	c3                   	retq   
        if(LV_GC_ROOT(_lv_mem_buf[i]).p == p) {
   26304:	48 89 d6             	mov    %rdx,%rsi
   26307:	48 63 c2             	movslq %edx,%rax
   2630a:	48 c1 e6 04          	shl    $0x4,%rsi
   2630e:	48 39 3c 0e          	cmp    %rdi,(%rsi,%rcx,1)
   26312:	75 0a                	jne    2631e <_lv_mem_buf_release+0x51>
            LV_GC_ROOT(_lv_mem_buf[i]).used = 0;
   26314:	48 c1 e0 04          	shl    $0x4,%rax
   26318:	80 64 01 0a fe       	andb   $0xfe,0xa(%rcx,%rax,1)
            return;
        }
    }

    LV_LOG_ERROR("lv_mem_buf_release: p is not a known buffer")
}
   2631d:	c3                   	retq   
   2631e:	48 ff c2             	inc    %rdx
    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
   26321:	48 83 fa 10          	cmp    $0x10,%rdx
   26325:	75 dd                	jne    26304 <_lv_mem_buf_release+0x37>
    LV_LOG_ERROR("lv_mem_buf_release: p is not a known buffer")
   26327:	4c 8d 05 3f da 00 00 	lea    0xda3f(%rip),%r8        # 33d6d <_lv_bpp1_opa_table+0x518>
   2632e:	48 8d 0d cb a7 00 00 	lea    0xa7cb(%rip),%rcx        # 30b00 <__func__.5854>
   26335:	48 8d 35 fc d9 00 00 	lea    0xd9fc(%rip),%rsi        # 33d38 <_lv_bpp1_opa_table+0x4e3>
   2633c:	ba 36 02 00 00       	mov    $0x236,%edx
   26341:	bf 03 00 00 00       	mov    $0x3,%edi
   26346:	31 c0                	xor    %eax,%eax
   26348:	e9 09 fc ff ff       	jmpq   25f56 <_lv_log_add>

000000000002634d <_lv_mem_buf_free_all>:

/**
 * Free all memory buffers
 */
void _lv_mem_buf_free_all(void)
{
   2634d:	41 54                	push   %r12
    uint8_t i;
    for(i = 0; i < sizeof(mem_buf_small) / sizeof(mem_buf_small[0]); i++) {
        mem_buf_small[i].used = 0;
   2634f:	80 25 74 05 21 00 fe 	andb   $0xfe,0x210574(%rip)        # 2368ca <mem_buf_small+0xa>
{
   26356:	55                   	push   %rbp
        mem_buf_small[i].used = 0;
   26357:	80 25 7c 05 21 00 fe 	andb   $0xfe,0x21057c(%rip)        # 2368da <mem_buf_small+0x1a>
   2635e:	31 ed                	xor    %ebp,%ebp
{
   26360:	53                   	push   %rbx
   26361:	48 8d 1d 38 15 23 00 	lea    0x231538(%rip),%rbx        # 2578a0 <_lv_mem_buf>
   26368:	49 89 dc             	mov    %rbx,%r12
    }

    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
        if(LV_GC_ROOT(_lv_mem_buf[i]).p) {
   2636b:	48 8b 3b             	mov    (%rbx),%rdi
   2636e:	48 85 ff             	test   %rdi,%rdi
   26371:	74 1f                	je     26392 <_lv_mem_buf_free_all+0x45>
            lv_mem_free(LV_GC_ROOT(_lv_mem_buf[i]).p);
   26373:	e8 8c fd ff ff       	callq  26104 <lv_mem_free>
            LV_GC_ROOT(_lv_mem_buf[i]).p = NULL;
            LV_GC_ROOT(_lv_mem_buf[i]).used = 0;
   26378:	48 63 c5             	movslq %ebp,%rax
            LV_GC_ROOT(_lv_mem_buf[i]).p = NULL;
   2637b:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
            LV_GC_ROOT(_lv_mem_buf[i]).used = 0;
   26382:	48 c1 e0 04          	shl    $0x4,%rax
   26386:	41 80 64 04 0a fe    	andb   $0xfe,0xa(%r12,%rax,1)
            LV_GC_ROOT(_lv_mem_buf[i]).size = 0;
   2638c:	66 c7 43 08 00 00    	movw   $0x0,0x8(%rbx)
   26392:	48 ff c5             	inc    %rbp
   26395:	48 83 c3 10          	add    $0x10,%rbx
    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
   26399:	48 83 fd 10          	cmp    $0x10,%rbp
   2639d:	75 cc                	jne    2636b <_lv_mem_buf_free_all+0x1e>
        }
    }
}
   2639f:	5b                   	pop    %rbx
   263a0:	5d                   	pop    %rbp
   263a1:	41 5c                	pop    %r12
   263a3:	c3                   	retq   

00000000000263a4 <lv_task_create_basic>:
 * Create an "empty" task. It needs to initialized with at least
 * `lv_task_set_cb` and `lv_task_set_period`
 * @return pointer to the created task
 */
lv_task_t * lv_task_create_basic(void)
{
   263a4:	53                   	push   %rbx
    lv_task_t * new_task = NULL;
    lv_task_t * tmp;

    /*Create task lists in order of priority from high to low*/
    tmp = _lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
   263a5:	48 8d 1d 64 1a 23 00 	lea    0x231a64(%rip),%rbx        # 257e10 <_lv_task_ll>
   263ac:	48 89 df             	mov    %rbx,%rdi
   263af:	e8 b7 f8 ff ff       	callq  25c6b <_lv_ll_get_head>

    /*It's the first task*/
    if(NULL == tmp) {
   263b4:	48 85 c0             	test   %rax,%rax
   263b7:	75 14                	jne    263cd <lv_task_create_basic+0x29>
        new_task = _lv_ll_ins_head(&LV_GC_ROOT(_lv_task_ll));
   263b9:	48 89 df             	mov    %rbx,%rdi
   263bc:	e8 06 f8 ff ff       	callq  25bc7 <_lv_ll_ins_head>
        LV_ASSERT_MEM(new_task);
        if(new_task == NULL) return NULL;
   263c1:	48 85 c0             	test   %rax,%rax
        new_task = _lv_ll_ins_head(&LV_GC_ROOT(_lv_task_ll));
   263c4:	48 89 c3             	mov    %rax,%rbx
        if(new_task == NULL) return NULL;
   263c7:	75 30                	jne    263f9 <lv_task_create_basic+0x55>
   263c9:	31 db                	xor    %ebx,%ebx
   263cb:	eb 6b                	jmp    26438 <lv_task_create_basic+0x94>
    }
    /*Insert the new task to proper place according to its priority*/
    else {
        do {
            if(tmp->prio <= DEF_PRIO) {
   263cd:	8a 50 1c             	mov    0x1c(%rax),%dl
                new_task = _lv_ll_ins_prev(&LV_GC_ROOT(_lv_task_ll), tmp);
   263d0:	48 89 c6             	mov    %rax,%rsi
   263d3:	48 89 df             	mov    %rbx,%rdi
            if(tmp->prio <= DEF_PRIO) {
   263d6:	83 e2 07             	and    $0x7,%edx
   263d9:	80 fa 03             	cmp    $0x3,%dl
   263dc:	77 07                	ja     263e5 <lv_task_create_basic+0x41>
                new_task = _lv_ll_ins_prev(&LV_GC_ROOT(_lv_task_ll), tmp);
   263de:	e8 bd f8 ff ff       	callq  25ca0 <_lv_ll_ins_prev>
   263e3:	eb dc                	jmp    263c1 <lv_task_create_basic+0x1d>
                LV_ASSERT_MEM(new_task);
                if(new_task == NULL) return NULL;
                break;
            }
            tmp = _lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), tmp);
   263e5:	e8 99 f8 ff ff       	callq  25c83 <_lv_ll_get_next>
        } while(tmp != NULL);
   263ea:	48 85 c0             	test   %rax,%rax
   263ed:	75 de                	jne    263cd <lv_task_create_basic+0x29>

        /*Only too high priority tasks were found. Add the task to the end*/
        if(tmp == NULL) {
            new_task = _lv_ll_ins_tail(&LV_GC_ROOT(_lv_task_ll));
   263ef:	48 89 df             	mov    %rbx,%rdi
   263f2:	e8 22 f8 ff ff       	callq  25c19 <_lv_ll_ins_tail>
   263f7:	eb c8                	jmp    263c1 <lv_task_create_basic+0x1d>
            if(new_task == NULL) return NULL;
        }
    }
    task_list_changed = true;

    new_task->period  = DEF_PERIOD;
   263f9:	c7 00 f4 01 00 00    	movl   $0x1f4,(%rax)
    new_task->task_cb = NULL;
   263ff:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
   26406:	00 
    new_task->prio    = DEF_PRIO;
   26407:	8a 40 1c             	mov    0x1c(%rax),%al

    new_task->repeat_count = -1;
   2640a:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%rbx)
    task_list_changed = true;
   26411:	c6 05 d8 8c 23 00 01 	movb   $0x1,0x238cd8(%rip)        # 25f0f0 <task_list_changed>
    new_task->prio    = DEF_PRIO;
   26418:	83 e0 f8             	and    $0xfffffff8,%eax
   2641b:	83 c8 03             	or     $0x3,%eax
   2641e:	88 43 1c             	mov    %al,0x1c(%rbx)
    new_task->last_run = lv_tick_get();
   26421:	e8 68 f0 ff ff       	callq  2548e <lv_tick_get>

    new_task->user_data = NULL;
   26426:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
   2642d:	00 
    new_task->last_run = lv_tick_get();
   2642e:	89 43 04             	mov    %eax,0x4(%rbx)

    task_created = true;
   26431:	c6 05 b7 8c 23 00 01 	movb   $0x1,0x238cb7(%rip)        # 25f0ef <task_created>

    return new_task;
}
   26438:	48 89 d8             	mov    %rbx,%rax
   2643b:	5b                   	pop    %rbx
   2643c:	c3                   	retq   

000000000002643d <lv_task_set_cb>:
 * @param task pointer to a task
 * @param task_cb the function to call periodically
 */
void lv_task_set_cb(lv_task_t * task, lv_task_cb_t task_cb)
{
    task->task_cb = task_cb;
   2643d:	48 89 77 08          	mov    %rsi,0x8(%rdi)
}
   26441:	c3                   	retq   

0000000000026442 <lv_task_del>:
/**
 * Delete a lv_task
 * @param task pointer to task created by task
 */
void lv_task_del(lv_task_t * task)
{
   26442:	53                   	push   %rbx
    _lv_ll_remove(&LV_GC_ROOT(_lv_task_ll), task);
   26443:	48 89 fe             	mov    %rdi,%rsi
{
   26446:	48 89 fb             	mov    %rdi,%rbx
    _lv_ll_remove(&LV_GC_ROOT(_lv_task_ll), task);
   26449:	48 8d 3d c0 19 23 00 	lea    0x2319c0(%rip),%rdi        # 257e10 <_lv_task_ll>
   26450:	e8 d1 f8 ff ff       	callq  25d26 <_lv_ll_remove>
    task_list_changed = true;

    lv_mem_free(task);
   26455:	48 89 df             	mov    %rbx,%rdi
    task_list_changed = true;
   26458:	c6 05 91 8c 23 00 01 	movb   $0x1,0x238c91(%rip)        # 25f0f0 <task_list_changed>
    lv_mem_free(task);
   2645f:	e8 a0 fc ff ff       	callq  26104 <lv_mem_free>

    if(LV_GC_ROOT(_lv_task_act) == task) task_deleted = true; /*The active task was deleted*/
   26464:	48 8d 05 8d 1b 23 00 	lea    0x231b8d(%rip),%rax        # 257ff8 <_lv_task_act>
   2646b:	48 39 18             	cmp    %rbx,(%rax)
   2646e:	75 07                	jne    26477 <lv_task_del+0x35>
   26470:	c6 05 7a 8c 23 00 01 	movb   $0x1,0x238c7a(%rip)        # 25f0f1 <task_deleted>
}
   26477:	5b                   	pop    %rbx
   26478:	c3                   	retq   

0000000000026479 <lv_task_exec>:
 * Execute task if its the priority is appropriate
 * @param task pointer to lv_task
 * @return true: execute, false: not executed
 */
static bool lv_task_exec(lv_task_t * task)
{
   26479:	53                   	push   %rbx
   2647a:	48 89 fb             	mov    %rdi,%rbx
 * @return the time remaining, or 0 if it needs to be run again
 */
static uint32_t lv_task_time_remaining(lv_task_t * task)
{
    /*Check if at least 'period' time elapsed*/
    uint32_t elp = lv_tick_elaps(task->last_run);
   2647d:	8b 7f 04             	mov    0x4(%rdi),%edi
   26480:	e8 1a f0 ff ff       	callq  2549f <lv_tick_elaps>
    bool exec = false;
   26485:	31 d2                	xor    %edx,%edx
    if(elp >= task->period)
   26487:	3b 03                	cmp    (%rbx),%eax
   26489:	72 49                	jb     264d4 <lv_task_exec+0x5b>
        task->last_run = lv_tick_get();
   2648b:	e8 fe ef ff ff       	callq  2548e <lv_tick_get>
   26490:	89 43 04             	mov    %eax,0x4(%rbx)
        if(task->task_cb) task->task_cb(task);
   26493:	48 8b 43 08          	mov    0x8(%rbx),%rax
        task_deleted   = false;
   26497:	c6 05 53 8c 23 00 00 	movb   $0x0,0x238c53(%rip)        # 25f0f1 <task_deleted>
        task_created   = false;
   2649e:	c6 05 4a 8c 23 00 00 	movb   $0x0,0x238c4a(%rip)        # 25f0ef <task_created>
        if(task->task_cb) task->task_cb(task);
   264a5:	48 85 c0             	test   %rax,%rax
   264a8:	74 05                	je     264af <lv_task_exec+0x36>
   264aa:	48 89 df             	mov    %rbx,%rdi
   264ad:	ff d0                	callq  *%rax
        if(task_deleted == false) { /*The task might be deleted by itself as well*/
   264af:	80 3d 3b 8c 23 00 00 	cmpb   $0x0,0x238c3b(%rip)        # 25f0f1 <task_deleted>
   264b6:	75 1a                	jne    264d2 <lv_task_exec+0x59>
            if(task->repeat_count > 0) {
   264b8:	8b 43 18             	mov    0x18(%rbx),%eax
   264bb:	85 c0                	test   %eax,%eax
   264bd:	7e 05                	jle    264c4 <lv_task_exec+0x4b>
                task->repeat_count--;
   264bf:	ff c8                	dec    %eax
   264c1:	89 43 18             	mov    %eax,0x18(%rbx)
            if(task->repeat_count == 0) {
   264c4:	83 7b 18 00          	cmpl   $0x0,0x18(%rbx)
   264c8:	75 08                	jne    264d2 <lv_task_exec+0x59>
                lv_task_del(task);
   264ca:	48 89 df             	mov    %rbx,%rdi
   264cd:	e8 70 ff ff ff       	callq  26442 <lv_task_del>
   264d2:	b2 01                	mov    $0x1,%dl
}
   264d4:	88 d0                	mov    %dl,%al
   264d6:	5b                   	pop    %rbx
   264d7:	c3                   	retq   

00000000000264d8 <lv_task_handler>:
    if(already_running) return 1;
   264d8:	80 3d 0f 8c 23 00 00 	cmpb   $0x0,0x238c0f(%rip)        # 25f0ee <already_running.3217>
   264df:	b8 01 00 00 00       	mov    $0x1,%eax
   264e4:	0f 85 ab 01 00 00    	jne    26695 <lv_task_handler+0x1bd>
    if(lv_task_run == false) {
   264ea:	80 3d 02 8c 23 00 00 	cmpb   $0x0,0x238c02(%rip)        # 25f0f3 <lv_task_run>
    already_running = true;
   264f1:	c6 05 f6 8b 23 00 01 	movb   $0x1,0x238bf6(%rip)        # 25f0ee <already_running.3217>
    if(lv_task_run == false) {
   264f8:	75 08                	jne    26502 <lv_task_handler+0x2a>
        already_running = false; /*Release mutex*/
   264fa:	c6 05 ed 8b 23 00 00 	movb   $0x0,0x238bed(%rip)        # 25f0ee <already_running.3217>
        return 1;
   26501:	c3                   	retq   
{
   26502:	41 55                	push   %r13
   26504:	41 54                	push   %r12
   26506:	55                   	push   %rbp
   26507:	53                   	push   %rbx
   26508:	48 83 ec 08          	sub    $0x8,%rsp
    handler_start = lv_tick_get();
   2650c:	e8 7d ef ff ff       	callq  2548e <lv_tick_get>
   26511:	89 05 a1 8b 23 00    	mov    %eax,0x238ba1(%rip)        # 25f0b8 <handler_start.3219>
    lv_task_t * task_interrupter = NULL;
   26517:	31 ed                	xor    %ebp,%ebp
        LV_GC_ROOT(_lv_task_act) = _lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
   26519:	4c 8d 25 f0 18 23 00 	lea    0x2318f0(%rip),%r12        # 257e10 <_lv_task_ll>
        task_deleted             = false;
   26520:	c6 05 ca 8b 23 00 00 	movb   $0x0,0x238bca(%rip)        # 25f0f1 <task_deleted>
        task_created             = false;
   26527:	c6 05 c1 8b 23 00 00 	movb   $0x0,0x238bc1(%rip)        # 25f0ef <task_created>
        LV_GC_ROOT(_lv_task_act) = _lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
   2652e:	4c 89 e7             	mov    %r12,%rdi
   26531:	e8 35 f7 ff ff       	callq  25c6b <_lv_ll_get_head>
   26536:	48 8d 1d bb 1a 23 00 	lea    0x231abb(%rip),%rbx        # 257ff8 <_lv_task_act>
   2653d:	48 89 03             	mov    %rax,(%rbx)
        while(LV_GC_ROOT(_lv_task_act)) {
   26540:	48 8b 33             	mov    (%rbx),%rsi
   26543:	48 85 f6             	test   %rsi,%rsi
   26546:	0f 84 8d 00 00 00    	je     265d9 <lv_task_handler+0x101>
            next = _lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), LV_GC_ROOT(_lv_task_act));
   2654c:	4c 89 e7             	mov    %r12,%rdi
   2654f:	e8 2f f7 ff ff       	callq  25c83 <_lv_ll_get_next>
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_OFF) {
   26554:	48 8b 3b             	mov    (%rbx),%rdi
            next = _lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), LV_GC_ROOT(_lv_task_act));
   26557:	49 89 c5             	mov    %rax,%r13
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_OFF) {
   2655a:	8a 47 1c             	mov    0x1c(%rdi),%al
   2655d:	24 07                	and    $0x7,%al
   2655f:	74 78                	je     265d9 <lv_task_handler+0x101>
            if(LV_GC_ROOT(_lv_task_act) == task_interrupter) {
   26561:	48 39 ef             	cmp    %rbp,%rdi
   26564:	75 07                	jne    2656d <lv_task_handler+0x95>
                LV_GC_ROOT(_lv_task_act) = next;
   26566:	4c 89 2b             	mov    %r13,(%rbx)
                task_interrupter = NULL; /*From this point only task after the interrupter comes, so
   26569:	31 ed                	xor    %ebp,%ebp
                continue; /*Load the next task*/
   2656b:	eb d3                	jmp    26540 <lv_task_handler+0x68>
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_HIGHEST) {
   2656d:	3c 05                	cmp    $0x5,%al
   2656f:	75 07                	jne    26578 <lv_task_handler+0xa0>
                lv_task_exec(LV_GC_ROOT(_lv_task_act));
   26571:	e8 03 ff ff ff       	callq  26479 <lv_task_exec>
   26576:	eb 32                	jmp    265aa <lv_task_handler+0xd2>
            else if(task_interrupter) {
   26578:	48 85 ed             	test   %rbp,%rbp
   2657b:	74 0a                	je     26587 <lv_task_handler+0xaf>
                if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio > task_interrupter->prio) {
   2657d:	8a 55 1c             	mov    0x1c(%rbp),%dl
   26580:	83 e2 07             	and    $0x7,%edx
   26583:	38 d0                	cmp    %dl,%al
   26585:	76 23                	jbe    265aa <lv_task_handler+0xd2>
                if(lv_task_exec(LV_GC_ROOT(_lv_task_act))) {
   26587:	e8 ed fe ff ff       	callq  26479 <lv_task_exec>
   2658c:	84 c0                	test   %al,%al
   2658e:	74 1a                	je     265aa <lv_task_handler+0xd2>
                    if(!task_created && !task_deleted) {
   26590:	80 3d 58 8b 23 00 00 	cmpb   $0x0,0x238b58(%rip)        # 25f0ef <task_created>
   26597:	75 40                	jne    265d9 <lv_task_handler+0x101>
   26599:	80 3d 51 8b 23 00 00 	cmpb   $0x0,0x238b51(%rip)        # 25f0f1 <task_deleted>
   265a0:	75 11                	jne    265b3 <lv_task_handler+0xdb>
                        task_interrupter = LV_GC_ROOT(_lv_task_act); /*Check all tasks again from the highest priority */
   265a2:	48 8b 2b             	mov    (%rbx),%rbp
   265a5:	e9 6f ff ff ff       	jmpq   26519 <lv_task_handler+0x41>
            if(task_created || task_deleted) {
   265aa:	80 3d 3e 8b 23 00 00 	cmpb   $0x0,0x238b3e(%rip)        # 25f0ef <task_created>
   265b1:	75 26                	jne    265d9 <lv_task_handler+0x101>
   265b3:	80 3d 37 8b 23 00 00 	cmpb   $0x0,0x238b37(%rip)        # 25f0f1 <task_deleted>
   265ba:	75 1d                	jne    265d9 <lv_task_handler+0x101>
            if(task_list_changed) {
   265bc:	80 3d 2d 8b 23 00 00 	cmpb   $0x0,0x238b2d(%rip)        # 25f0f0 <task_list_changed>
   265c3:	74 0c                	je     265d1 <lv_task_handler+0xf9>
                task_list_changed = false;
   265c5:	c6 05 24 8b 23 00 00 	movb   $0x0,0x238b24(%rip)        # 25f0f0 <task_list_changed>
   265cc:	e9 46 ff ff ff       	jmpq   26517 <lv_task_handler+0x3f>
            LV_GC_ROOT(_lv_task_act) = next; /*Load the next task*/
   265d1:	4c 89 2b             	mov    %r13,(%rbx)
   265d4:	e9 67 ff ff ff       	jmpq   26540 <lv_task_handler+0x68>
    busy_time += lv_tick_elaps(handler_start);
   265d9:	8b 3d d9 8a 23 00    	mov    0x238ad9(%rip),%edi        # 25f0b8 <handler_start.3219>
   265df:	e8 bb ee ff ff       	callq  2549f <lv_tick_elaps>
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
   265e4:	8b 3d c6 8a 23 00    	mov    0x238ac6(%rip),%edi        # 25f0b0 <idle_period_start.3218>
    busy_time += lv_tick_elaps(handler_start);
   265ea:	01 05 c4 8a 23 00    	add    %eax,0x238ac4(%rip)        # 25f0b4 <busy_time.3220>
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
   265f0:	e8 aa ee ff ff       	callq  2549f <lv_tick_elaps>
    if(idle_period_time >= IDLE_MEAS_PERIOD) {
   265f5:	3d f3 01 00 00       	cmp    $0x1f3,%eax
   265fa:	76 35                	jbe    26631 <lv_task_handler+0x159>
        idle_last         = (uint32_t)((uint32_t)busy_time * 100) / IDLE_MEAS_PERIOD; /*Calculate the busy percentage*/
   265fc:	6b 05 b1 8a 23 00 64 	imul   $0x64,0x238ab1(%rip),%eax        # 25f0b4 <busy_time.3220>
   26603:	31 d2                	xor    %edx,%edx
   26605:	b9 f4 01 00 00       	mov    $0x1f4,%ecx
   2660a:	f7 f1                	div    %ecx
        idle_last         = idle_last > 100 ? 0 : 100 - idle_last;                    /*But we need idle time*/
   2660c:	31 d2                	xor    %edx,%edx
   2660e:	3c 64                	cmp    $0x64,%al
   26610:	77 04                	ja     26616 <lv_task_handler+0x13e>
   26612:	b2 64                	mov    $0x64,%dl
   26614:	29 c2                	sub    %eax,%edx
   26616:	88 15 d6 8a 23 00    	mov    %dl,0x238ad6(%rip)        # 25f0f2 <idle_last>
        busy_time         = 0;
   2661c:	c7 05 8e 8a 23 00 00 	movl   $0x0,0x238a8e(%rip)        # 25f0b4 <busy_time.3220>
   26623:	00 00 00 
        idle_period_start = lv_tick_get();
   26626:	e8 63 ee ff ff       	callq  2548e <lv_tick_get>
   2662b:	89 05 7f 8a 23 00    	mov    %eax,0x238a7f(%rip)        # 25f0b0 <idle_period_start.3218>
    next = _lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
   26631:	4c 89 e7             	mov    %r12,%rdi
    time_till_next = LV_NO_TASK_READY;
   26634:	c7 05 6e 8a 23 00 ff 	movl   $0xffffffff,0x238a6e(%rip)        # 25f0ac <time_till_next.3221>
   2663b:	ff ff ff 
    next = _lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
   2663e:	e8 28 f6 ff ff       	callq  25c6b <_lv_ll_get_head>
    while(next) {
   26643:	48 85 c0             	test   %rax,%rax
        next = _lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), next); /*Find the next task*/
   26646:	48 89 c3             	mov    %rax,%rbx
    while(next) {
   26649:	74 35                	je     26680 <lv_task_handler+0x1a8>
        if(next->prio != LV_TASK_PRIO_OFF) {
   2664b:	f6 43 1c 07          	testb  $0x7,0x1c(%rbx)
   2664f:	74 22                	je     26673 <lv_task_handler+0x19b>
    uint32_t elp = lv_tick_elaps(task->last_run);
   26651:	8b 7b 04             	mov    0x4(%rbx),%edi
   26654:	e8 46 ee ff ff       	callq  2549f <lv_tick_elaps>
    if(elp >= task->period)
   26659:	8b 0b                	mov    (%rbx),%ecx
        return 0;
   2665b:	31 d2                	xor    %edx,%edx
    if(elp >= task->period)
   2665d:	39 c8                	cmp    %ecx,%eax
   2665f:	73 04                	jae    26665 <lv_task_handler+0x18d>
    return task->period - elp;
   26661:	29 c1                	sub    %eax,%ecx
   26663:	89 ca                	mov    %ecx,%edx
            if(delay < time_till_next)
   26665:	39 15 41 8a 23 00    	cmp    %edx,0x238a41(%rip)        # 25f0ac <time_till_next.3221>
   2666b:	76 06                	jbe    26673 <lv_task_handler+0x19b>
                time_till_next = delay;
   2666d:	89 15 39 8a 23 00    	mov    %edx,0x238a39(%rip)        # 25f0ac <time_till_next.3221>
        next = _lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), next); /*Find the next task*/
   26673:	48 89 de             	mov    %rbx,%rsi
   26676:	4c 89 e7             	mov    %r12,%rdi
   26679:	e8 05 f6 ff ff       	callq  25c83 <_lv_ll_get_next>
   2667e:	eb c3                	jmp    26643 <lv_task_handler+0x16b>
    return time_till_next;
   26680:	8b 05 26 8a 23 00    	mov    0x238a26(%rip),%eax        # 25f0ac <time_till_next.3221>
    already_running = false; /*Release the mutex*/
   26686:	c6 05 61 8a 23 00 00 	movb   $0x0,0x238a61(%rip)        # 25f0ee <already_running.3217>
}
   2668d:	5a                   	pop    %rdx
   2668e:	5b                   	pop    %rbx
   2668f:	5d                   	pop    %rbp
   26690:	41 5c                	pop    %r12
   26692:	41 5d                	pop    %r13
   26694:	c3                   	retq   
   26695:	c3                   	retq   

0000000000026696 <lv_task_set_prio>:
{
   26696:	41 55                	push   %r13
   26698:	41 54                	push   %r12
    if(task->prio == prio) return;
   2669a:	44 0f b6 ee          	movzbl %sil,%r13d
{
   2669e:	55                   	push   %rbp
   2669f:	53                   	push   %rbx
   266a0:	48 83 ec 08          	sub    $0x8,%rsp
    if(task->prio == prio) return;
   266a4:	8a 47 1c             	mov    0x1c(%rdi),%al
   266a7:	83 e0 07             	and    $0x7,%eax
   266aa:	44 39 e8             	cmp    %r13d,%eax
   266ad:	74 5e                	je     2670d <lv_task_set_prio+0x77>
    _LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i) {
   266af:	4c 8d 25 5a 17 23 00 	lea    0x23175a(%rip),%r12        # 257e10 <_lv_task_ll>
   266b6:	48 89 fb             	mov    %rdi,%rbx
   266b9:	89 f5                	mov    %esi,%ebp
   266bb:	4c 89 e7             	mov    %r12,%rdi
   266be:	e8 a8 f5 ff ff       	callq  25c6b <_lv_ll_get_head>
   266c3:	48 85 c0             	test   %rax,%rax
   266c6:	74 22                	je     266ea <lv_task_set_prio+0x54>
        if(i->prio <= prio) {
   266c8:	8a 50 1c             	mov    0x1c(%rax),%dl
   266cb:	83 e2 07             	and    $0x7,%edx
   266ce:	41 39 d5             	cmp    %edx,%r13d
   266d1:	7c 0a                	jl     266dd <lv_task_set_prio+0x47>
            if(i != task) _lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, i);
   266d3:	48 39 d8             	cmp    %rbx,%rax
   266d6:	48 89 c2             	mov    %rax,%rdx
   266d9:	75 11                	jne    266ec <lv_task_set_prio+0x56>
   266db:	eb 1a                	jmp    266f7 <lv_task_set_prio+0x61>
    _LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i) {
   266dd:	48 89 c6             	mov    %rax,%rsi
   266e0:	4c 89 e7             	mov    %r12,%rdi
   266e3:	e8 9b f5 ff ff       	callq  25c83 <_lv_ll_get_next>
   266e8:	eb d9                	jmp    266c3 <lv_task_set_prio+0x2d>
        _lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, NULL);
   266ea:	31 d2                	xor    %edx,%edx
   266ec:	48 89 de             	mov    %rbx,%rsi
   266ef:	4c 89 e7             	mov    %r12,%rdi
   266f2:	e8 72 f7 ff ff       	callq  25e69 <_lv_ll_move_before>
    task->prio = prio;
   266f7:	8a 43 1c             	mov    0x1c(%rbx),%al
   266fa:	83 e5 07             	and    $0x7,%ebp
    task_list_changed = true;
   266fd:	c6 05 ec 89 23 00 01 	movb   $0x1,0x2389ec(%rip)        # 25f0f0 <task_list_changed>
    task->prio = prio;
   26704:	83 e0 f8             	and    $0xfffffff8,%eax
   26707:	09 c5                	or     %eax,%ebp
   26709:	40 88 6b 1c          	mov    %bpl,0x1c(%rbx)
}
   2670d:	58                   	pop    %rax
   2670e:	5b                   	pop    %rbx
   2670f:	5d                   	pop    %rbp
   26710:	41 5c                	pop    %r12
   26712:	41 5d                	pop    %r13
   26714:	c3                   	retq   

0000000000026715 <lv_task_set_period>:
    task->period = period;
   26715:	89 37                	mov    %esi,(%rdi)
}
   26717:	c3                   	retq   

0000000000026718 <lv_task_create>:
{
   26718:	41 56                	push   %r14
   2671a:	41 55                	push   %r13
   2671c:	49 89 fe             	mov    %rdi,%r14
   2671f:	41 54                	push   %r12
   26721:	55                   	push   %rbp
   26722:	41 89 f5             	mov    %esi,%r13d
   26725:	53                   	push   %rbx
   26726:	89 d5                	mov    %edx,%ebp
   26728:	49 89 cc             	mov    %rcx,%r12
    lv_task_t * new_task = lv_task_create_basic();
   2672b:	e8 74 fc ff ff       	callq  263a4 <lv_task_create_basic>
    if(new_task == NULL) return NULL;
   26730:	48 85 c0             	test   %rax,%rax
    lv_task_t * new_task = lv_task_create_basic();
   26733:	48 89 c3             	mov    %rax,%rbx
    if(new_task == NULL) return NULL;
   26736:	74 26                	je     2675e <lv_task_create+0x46>
    lv_task_set_cb(new_task, task_xcb);
   26738:	48 89 c7             	mov    %rax,%rdi
   2673b:	4c 89 f6             	mov    %r14,%rsi
   2673e:	e8 fa fc ff ff       	callq  2643d <lv_task_set_cb>
    lv_task_set_period(new_task, period);
   26743:	44 89 ee             	mov    %r13d,%esi
   26746:	48 89 df             	mov    %rbx,%rdi
   26749:	e8 c7 ff ff ff       	callq  26715 <lv_task_set_period>
    lv_task_set_prio(new_task, prio);
   2674e:	40 0f b6 f5          	movzbl %bpl,%esi
   26752:	48 89 df             	mov    %rbx,%rdi
   26755:	e8 3c ff ff ff       	callq  26696 <lv_task_set_prio>
    new_task->user_data = user_data;
   2675a:	4c 89 63 10          	mov    %r12,0x10(%rbx)
}
   2675e:	48 89 d8             	mov    %rbx,%rax
   26761:	5b                   	pop    %rbx
   26762:	5d                   	pop    %rbp
   26763:	41 5c                	pop    %r12
   26765:	41 5d                	pop    %r13
   26767:	41 5e                	pop    %r14
   26769:	c3                   	retq   

000000000002676a <lv_task_ready>:
{
   2676a:	53                   	push   %rbx
   2676b:	48 89 fb             	mov    %rdi,%rbx
    task->last_run = lv_tick_get() - task->period - 1;
   2676e:	e8 1b ed ff ff       	callq  2548e <lv_tick_get>
   26773:	8b 13                	mov    (%rbx),%edx
   26775:	f7 d2                	not    %edx
   26777:	01 d0                	add    %edx,%eax
   26779:	89 43 04             	mov    %eax,0x4(%rbx)
}
   2677c:	5b                   	pop    %rbx
   2677d:	c3                   	retq   

000000000002677e <lv_task_enable>:
    lv_task_run = en;
   2677e:	40 88 3d 6e 89 23 00 	mov    %dil,0x23896e(%rip)        # 25f0f3 <lv_task_run>
}
   26785:	c3                   	retq   

0000000000026786 <_lv_task_core_init>:
{
   26786:	48 83 ec 08          	sub    $0x8,%rsp
    _lv_ll_init(&LV_GC_ROOT(_lv_task_ll), sizeof(lv_task_t));
   2678a:	48 8d 3d 7f 16 23 00 	lea    0x23167f(%rip),%rdi        # 257e10 <_lv_task_ll>
   26791:	be 20 00 00 00       	mov    $0x20,%esi
   26796:	e8 13 f4 ff ff       	callq  25bae <_lv_ll_init>
    task_list_changed = false;
   2679b:	c6 05 4e 89 23 00 00 	movb   $0x0,0x23894e(%rip)        # 25f0f0 <task_list_changed>
    lv_task_enable(true);
   267a2:	bf 01 00 00 00       	mov    $0x1,%edi
}
   267a7:	58                   	pop    %rax
    lv_task_enable(true);
   267a8:	e9 d1 ff ff ff       	jmpq   2677e <lv_task_enable>

00000000000267ad <lv_txt_utf8_size>:
 * @param str pointer to a character in a string
 * @return length of the UTF-8 character (1,2,3 or 4). O on invalid code
 */
static uint8_t lv_txt_utf8_size(const char * str)
{
    if((str[0] & 0x80) == 0)
   267ad:	0f be 17             	movsbl (%rdi),%edx
        return 1;
   267b0:	b0 01                	mov    $0x1,%al
    if((str[0] & 0x80) == 0)
   267b2:	84 d2                	test   %dl,%dl
   267b4:	79 36                	jns    267ec <lv_txt_utf8_size+0x3f>
    else if((str[0] & 0xE0) == 0xC0)
   267b6:	89 d1                	mov    %edx,%ecx
        return 2;
   267b8:	b0 02                	mov    $0x2,%al
    else if((str[0] & 0xE0) == 0xC0)
   267ba:	81 e1 e0 00 00 00    	and    $0xe0,%ecx
   267c0:	81 f9 c0 00 00 00    	cmp    $0xc0,%ecx
   267c6:	74 24                	je     267ec <lv_txt_utf8_size+0x3f>
    else if((str[0] & 0xF0) == 0xE0)
   267c8:	89 d1                	mov    %edx,%ecx
        return 3;
   267ca:	b0 03                	mov    $0x3,%al
    else if((str[0] & 0xF0) == 0xE0)
   267cc:	81 e1 f0 00 00 00    	and    $0xf0,%ecx
   267d2:	81 f9 e0 00 00 00    	cmp    $0xe0,%ecx
   267d8:	74 12                	je     267ec <lv_txt_utf8_size+0x3f>
    else if((str[0] & 0xF8) == 0xF0)
   267da:	81 e2 f8 00 00 00    	and    $0xf8,%edx
        return 4;
    return 0; /*If the char was invalid tell it's 1 byte long*/
   267e0:	81 fa f0 00 00 00    	cmp    $0xf0,%edx
   267e6:	0f 94 c0             	sete   %al
   267e9:	c1 e0 02             	shl    $0x2,%eax
}
   267ec:	c3                   	retq   

00000000000267ed <lv_txt_utf8_next>:
 *          After call it will point to the next UTF-8 char in 'txt'.
 *          NULL to use txt[0] as index
 * @return the decoded Unicode character or 0 on invalid UTF-8 code
 */
static uint32_t lv_txt_utf8_next(const char * txt, uint32_t * i)
{
   267ed:	48 83 ec 18          	sub    $0x18,%rsp
   267f1:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   267f8:	00 00 
   267fa:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   267ff:	31 c0                	xor    %eax,%eax

    uint32_t result = 0;

    /*Dummy 'i' pointer is required*/
    uint32_t i_tmp = 0;
    if(i == NULL) i = &i_tmp;
   26801:	48 85 f6             	test   %rsi,%rsi
    uint32_t i_tmp = 0;
   26804:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%rsp)
   2680b:	00 
    if(i == NULL) i = &i_tmp;
   2680c:	75 05                	jne    26813 <lv_txt_utf8_next+0x26>
   2680e:	48 8d 74 24 04       	lea    0x4(%rsp),%rsi

    /*Normal ASCII*/
    if((txt[*i] & 0x80) == 0) {
   26813:	8b 06                	mov    (%rsi),%eax
   26815:	49 89 c0             	mov    %rax,%r8
   26818:	0f be 04 07          	movsbl (%rdi,%rax,1),%eax
   2681c:	41 8d 50 01          	lea    0x1(%r8),%edx
   26820:	84 c0                	test   %al,%al
   26822:	78 07                	js     2682b <lv_txt_utf8_next+0x3e>
        result = txt[*i];
        (*i)++;
   26824:	89 16                	mov    %edx,(%rsi)
   26826:	e9 23 01 00 00       	jmpq   2694e <lv_txt_utf8_next+0x161>
    }
    /*Real UTF-8 decode*/
    else {
        /*2 bytes UTF-8 code*/
        if((txt[*i] & 0xE0) == 0xC0) {
   2682b:	89 c1                	mov    %eax,%ecx
   2682d:	81 e1 e0 00 00 00    	and    $0xe0,%ecx
   26833:	81 f9 c0 00 00 00    	cmp    $0xc0,%ecx
   26839:	75 2c                	jne    26867 <lv_txt_utf8_next+0x7a>
            result = (uint32_t)(txt[*i] & 0x1F) << 6;
            (*i)++;
   2683b:	89 16                	mov    %edx,(%rsi)
            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
   2683d:	8a 14 17             	mov    (%rdi,%rdx,1),%dl
   26840:	89 d1                	mov    %edx,%ecx
   26842:	81 e1 c0 00 00 00    	and    $0xc0,%ecx
   26848:	83 c1 80             	add    $0xffffff80,%ecx
   2684b:	0f 85 fb 00 00 00    	jne    2694c <lv_txt_utf8_next+0x15f>
            result = (uint32_t)(txt[*i] & 0x1F) << 6;
   26851:	c1 e0 06             	shl    $0x6,%eax
            result += (txt[*i] & 0x3F);
   26854:	83 e2 3f             	and    $0x3f,%edx
            (*i)++;
   26857:	41 83 c0 02          	add    $0x2,%r8d
            result = (uint32_t)(txt[*i] & 0x1F) << 6;
   2685b:	25 c0 07 00 00       	and    $0x7c0,%eax
            result += (txt[*i] & 0x3F);
   26860:	01 d0                	add    %edx,%eax
   26862:	e9 e0 00 00 00       	jmpq   26947 <lv_txt_utf8_next+0x15a>
        }
        /*3 bytes UTF-8 code*/
        else if((txt[*i] & 0xF0) == 0xE0) {
   26867:	89 c1                	mov    %eax,%ecx
   26869:	81 e1 f0 00 00 00    	and    $0xf0,%ecx
   2686f:	81 f9 e0 00 00 00    	cmp    $0xe0,%ecx
   26875:	75 51                	jne    268c8 <lv_txt_utf8_next+0xdb>
            result = (uint32_t)(txt[*i] & 0x0F) << 12;
            (*i)++;
   26877:	89 16                	mov    %edx,(%rsi)

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
   26879:	44 0f be 0c 17       	movsbl (%rdi,%rdx,1),%r9d
   2687e:	44 89 ca             	mov    %r9d,%edx
   26881:	81 e2 c0 00 00 00    	and    $0xc0,%edx
   26887:	83 c2 80             	add    $0xffffff80,%edx
   2688a:	0f 85 bc 00 00 00    	jne    2694c <lv_txt_utf8_next+0x15f>
            result += (uint32_t)(txt[*i] & 0x3F) << 6;
            (*i)++;
   26890:	41 8d 50 02          	lea    0x2(%r8),%edx
   26894:	89 16                	mov    %edx,(%rsi)

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
   26896:	8a 14 17             	mov    (%rdi,%rdx,1),%dl
   26899:	89 d1                	mov    %edx,%ecx
   2689b:	81 e1 c0 00 00 00    	and    $0xc0,%ecx
   268a1:	83 c1 80             	add    $0xffffff80,%ecx
   268a4:	0f 85 a2 00 00 00    	jne    2694c <lv_txt_utf8_next+0x15f>
            result = (uint32_t)(txt[*i] & 0x0F) << 12;
   268aa:	c1 e0 0c             	shl    $0xc,%eax
            result += (txt[*i] & 0x3F);
   268ad:	83 e2 3f             	and    $0x3f,%edx
            (*i)++;
   268b0:	41 83 c0 03          	add    $0x3,%r8d
            result = (uint32_t)(txt[*i] & 0x0F) << 12;
   268b4:	0f b7 c8             	movzwl %ax,%ecx
            result += (uint32_t)(txt[*i] & 0x3F) << 6;
   268b7:	44 89 c8             	mov    %r9d,%eax
   268ba:	c1 e0 06             	shl    $0x6,%eax
   268bd:	01 ca                	add    %ecx,%edx
   268bf:	25 c0 0f 00 00       	and    $0xfc0,%eax
            result += (txt[*i] & 0x3F);
   268c4:	01 d0                	add    %edx,%eax
   268c6:	eb 7f                	jmp    26947 <lv_txt_utf8_next+0x15a>
        }
        /*4 bytes UTF-8 code*/
        else if((txt[*i] & 0xF8) == 0xF0) {
   268c8:	89 c1                	mov    %eax,%ecx
            result = (uint32_t)(txt[*i] & 0x07) << 18;
            (*i)++;
   268ca:	89 16                	mov    %edx,(%rsi)
        else if((txt[*i] & 0xF8) == 0xF0) {
   268cc:	81 e1 f8 00 00 00    	and    $0xf8,%ecx
   268d2:	81 f9 f0 00 00 00    	cmp    $0xf0,%ecx
   268d8:	75 72                	jne    2694c <lv_txt_utf8_next+0x15f>

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
   268da:	0f be 14 17          	movsbl (%rdi,%rdx,1),%edx
   268de:	89 d1                	mov    %edx,%ecx
   268e0:	81 e1 c0 00 00 00    	and    $0xc0,%ecx
   268e6:	83 c1 80             	add    $0xffffff80,%ecx
   268e9:	75 61                	jne    2694c <lv_txt_utf8_next+0x15f>
            result += (uint32_t)(txt[*i] & 0x3F) << 12;
            (*i)++;
   268eb:	41 8d 48 02          	lea    0x2(%r8),%ecx
   268ef:	89 0e                	mov    %ecx,(%rsi)

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
   268f1:	0f be 0c 0f          	movsbl (%rdi,%rcx,1),%ecx
   268f5:	41 89 c9             	mov    %ecx,%r9d
   268f8:	41 81 e1 c0 00 00 00 	and    $0xc0,%r9d
   268ff:	41 83 c1 80          	add    $0xffffff80,%r9d
   26903:	75 47                	jne    2694c <lv_txt_utf8_next+0x15f>
            result += (uint32_t)(txt[*i] & 0x3F) << 6;
            (*i)++;
   26905:	45 8d 48 03          	lea    0x3(%r8),%r9d
   26909:	44 89 0e             	mov    %r9d,(%rsi)

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
   2690c:	42 8a 3c 0f          	mov    (%rdi,%r9,1),%dil
   26910:	41 89 f9             	mov    %edi,%r9d
   26913:	41 81 e1 c0 00 00 00 	and    $0xc0,%r9d
   2691a:	41 83 c1 80          	add    $0xffffff80,%r9d
   2691e:	75 2c                	jne    2694c <lv_txt_utf8_next+0x15f>
            result = (uint32_t)(txt[*i] & 0x07) << 18;
   26920:	c1 e0 12             	shl    $0x12,%eax
            result += (uint32_t)(txt[*i] & 0x3F) << 12;
   26923:	c1 e2 0c             	shl    $0xc,%edx
            result += (uint32_t)(txt[*i] & 0x3F) << 6;
   26926:	c1 e1 06             	shl    $0x6,%ecx
            result = (uint32_t)(txt[*i] & 0x07) << 18;
   26929:	25 00 00 1c 00       	and    $0x1c0000,%eax
            result += (uint32_t)(txt[*i] & 0x3F) << 12;
   2692e:	81 e2 00 f0 03 00    	and    $0x3f000,%edx
            result += (uint32_t)(txt[*i] & 0x3F) << 6;
   26934:	81 e1 c0 0f 00 00    	and    $0xfc0,%ecx
            result += txt[*i] & 0x3F;
   2693a:	83 e7 3f             	and    $0x3f,%edi
            result += (uint32_t)(txt[*i] & 0x3F) << 12;
   2693d:	09 d0                	or     %edx,%eax
            (*i)++;
   2693f:	41 83 c0 04          	add    $0x4,%r8d
            result += txt[*i] & 0x3F;
   26943:	01 f9                	add    %edi,%ecx
   26945:	01 c8                	add    %ecx,%eax
            (*i)++;
   26947:	44 89 06             	mov    %r8d,(%rsi)
   2694a:	eb 02                	jmp    2694e <lv_txt_utf8_next+0x161>
    uint32_t result = 0;
   2694c:	31 c0                	xor    %eax,%eax
        else {
            (*i)++; /*Not UTF-8 char. Go the next.*/
        }
    }
    return result;
}
   2694e:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   26953:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
   2695a:	00 00 
   2695c:	74 05                	je     26963 <lv_txt_utf8_next+0x176>
   2695e:	e8 dd dc fd ff       	callq  4640 <__stack_chk_fail@plt>
   26963:	48 83 c4 18          	add    $0x18,%rsp
   26967:	c3                   	retq   

0000000000026968 <lv_txt_utf8_get_byte_id>:
 * @param txt a '\0' terminated UTF-8 string
 * @param utf8_id character index
 * @return byte index of the 'utf8_id'th letter
 */
static uint32_t lv_txt_utf8_get_byte_id(const char * txt, uint32_t utf8_id)
{
   26968:	41 55                	push   %r13
   2696a:	41 54                	push   %r12
   2696c:	49 89 fd             	mov    %rdi,%r13
   2696f:	55                   	push   %rbp
   26970:	53                   	push   %rbx
   26971:	89 f5                	mov    %esi,%ebp
    uint32_t i;
    uint32_t byte_cnt = 0;
    for(i = 0; i < utf8_id; i++) {
   26973:	45 31 e4             	xor    %r12d,%r12d
    uint32_t byte_cnt = 0;
   26976:	31 db                	xor    %ebx,%ebx
{
   26978:	48 83 ec 08          	sub    $0x8,%rsp
    for(i = 0; i < utf8_id; i++) {
   2697c:	49 39 ec             	cmp    %rbp,%r12
   2697f:	74 1e                	je     2699f <lv_txt_utf8_get_byte_id+0x37>
        uint8_t c_size = _lv_txt_encoded_size(&txt[byte_cnt]);
   26981:	48 8d 05 18 01 21 00 	lea    0x210118(%rip),%rax        # 236aa0 <_lv_txt_encoded_size>
   26988:	89 df                	mov    %ebx,%edi
   2698a:	4c 01 ef             	add    %r13,%rdi
   2698d:	ff 10                	callq  *(%rax)
        byte_cnt += c_size > 0 ? c_size : 1;
   2698f:	84 c0                	test   %al,%al
   26991:	75 02                	jne    26995 <lv_txt_utf8_get_byte_id+0x2d>
   26993:	b0 01                	mov    $0x1,%al
   26995:	0f b6 c0             	movzbl %al,%eax
   26998:	49 ff c4             	inc    %r12
   2699b:	01 c3                	add    %eax,%ebx
   2699d:	eb dd                	jmp    2697c <lv_txt_utf8_get_byte_id+0x14>
    }

    return byte_cnt;
}
   2699f:	5a                   	pop    %rdx
   269a0:	89 d8                	mov    %ebx,%eax
   269a2:	5b                   	pop    %rbx
   269a3:	5d                   	pop    %rbp
   269a4:	41 5c                	pop    %r12
   269a6:	41 5d                	pop    %r13
   269a8:	c3                   	retq   

00000000000269a9 <lv_txt_utf8_get_char_id>:
 * @param txt a '\0' terminated UTF-8 string
 * @param byte_id byte index
 * @return character index of the letter at 'byte_id'th position
 */
static uint32_t lv_txt_utf8_get_char_id(const char * txt, uint32_t byte_id)
{
   269a9:	41 55                	push   %r13
   269ab:	41 54                	push   %r12
   269ad:	49 89 fc             	mov    %rdi,%r12
   269b0:	55                   	push   %rbp
   269b1:	53                   	push   %rbx
   269b2:	89 f5                	mov    %esi,%ebp
    uint32_t i        = 0;
    uint32_t char_cnt = 0;
   269b4:	31 db                	xor    %ebx,%ebx
{
   269b6:	48 83 ec 18          	sub    $0x18,%rsp
   269ba:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   269c1:	00 00 
   269c3:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   269c8:	31 c0                	xor    %eax,%eax

    while(i < byte_id) {
        _lv_txt_encoded_next(txt, &i); /*'i' points to the next letter so use the prev. value*/
   269ca:	4c 8d 6c 24 04       	lea    0x4(%rsp),%r13
    uint32_t i        = 0;
   269cf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%rsp)
   269d6:	00 
    while(i < byte_id) {
   269d7:	39 6c 24 04          	cmp    %ebp,0x4(%rsp)
   269db:	73 13                	jae    269f0 <lv_txt_utf8_get_char_id+0x47>
        _lv_txt_encoded_next(txt, &i); /*'i' points to the next letter so use the prev. value*/
   269dd:	48 8d 05 b4 00 21 00 	lea    0x2100b4(%rip),%rax        # 236a98 <_lv_txt_encoded_next>
   269e4:	4c 89 ee             	mov    %r13,%rsi
   269e7:	4c 89 e7             	mov    %r12,%rdi
        char_cnt++;
   269ea:	ff c3                	inc    %ebx
        _lv_txt_encoded_next(txt, &i); /*'i' points to the next letter so use the prev. value*/
   269ec:	ff 10                	callq  *(%rax)
   269ee:	eb e7                	jmp    269d7 <lv_txt_utf8_get_char_id+0x2e>
    }

    return char_cnt;
}
   269f0:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   269f5:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
   269fc:	00 00 
   269fe:	89 d8                	mov    %ebx,%eax
   26a00:	74 05                	je     26a07 <lv_txt_utf8_get_char_id+0x5e>
   26a02:	e8 39 dc fd ff       	callq  4640 <__stack_chk_fail@plt>
   26a07:	48 83 c4 18          	add    $0x18,%rsp
   26a0b:	5b                   	pop    %rbx
   26a0c:	5d                   	pop    %rbp
   26a0d:	41 5c                	pop    %r12
   26a0f:	41 5d                	pop    %r13
   26a11:	c3                   	retq   

0000000000026a12 <lv_txt_utf8_get_length>:
 * E.g.: "ÁBC" is 3 characters (but 4 bytes)
 * @param txt a '\0' terminated char string
 * @return number of characters
 */
static uint32_t lv_txt_utf8_get_length(const char * txt)
{
   26a12:	41 54                	push   %r12
   26a14:	55                   	push   %rbp
   26a15:	48 89 fd             	mov    %rdi,%rbp
   26a18:	53                   	push   %rbx
    uint32_t len = 0;
   26a19:	31 db                	xor    %ebx,%ebx
{
   26a1b:	48 83 ec 10          	sub    $0x10,%rsp
   26a1f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   26a26:	00 00 
   26a28:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   26a2d:	31 c0                	xor    %eax,%eax
    uint32_t i   = 0;

    while(txt[i] != '\0') {
        _lv_txt_encoded_next(txt, &i);
   26a2f:	4c 8d 64 24 04       	lea    0x4(%rsp),%r12
    uint32_t i   = 0;
   26a34:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%rsp)
   26a3b:	00 
    while(txt[i] != '\0') {
   26a3c:	8b 44 24 04          	mov    0x4(%rsp),%eax
   26a40:	80 7c 05 00 00       	cmpb   $0x0,0x0(%rbp,%rax,1)
   26a45:	74 13                	je     26a5a <lv_txt_utf8_get_length+0x48>
        _lv_txt_encoded_next(txt, &i);
   26a47:	48 8d 05 4a 00 21 00 	lea    0x21004a(%rip),%rax        # 236a98 <_lv_txt_encoded_next>
   26a4e:	4c 89 e6             	mov    %r12,%rsi
   26a51:	48 89 ef             	mov    %rbp,%rdi
        len++;
   26a54:	ff c3                	inc    %ebx
        _lv_txt_encoded_next(txt, &i);
   26a56:	ff 10                	callq  *(%rax)
   26a58:	eb e2                	jmp    26a3c <lv_txt_utf8_get_length+0x2a>
    }

    return len;
}
   26a5a:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   26a5f:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
   26a66:	00 00 
   26a68:	89 d8                	mov    %ebx,%eax
   26a6a:	74 05                	je     26a71 <lv_txt_utf8_get_length+0x5f>
   26a6c:	e8 cf db fd ff       	callq  4640 <__stack_chk_fail@plt>
   26a71:	48 83 c4 10          	add    $0x10,%rsp
   26a75:	5b                   	pop    %rbx
   26a76:	5d                   	pop    %rbp
   26a77:	41 5c                	pop    %r12
   26a79:	c3                   	retq   

0000000000026a7a <lv_txt_utf8_prev>:
{
   26a7a:	41 54                	push   %r12
   26a7c:	55                   	push   %rbp
   26a7d:	49 89 fc             	mov    %rdi,%r12
   26a80:	53                   	push   %rbx
    (*i)--;
   26a81:	40 b5 04             	mov    $0x4,%bpl
{
   26a84:	48 89 f3             	mov    %rsi,%rbx
   26a87:	48 83 ec 10          	sub    $0x10,%rsp
    (*i)--;
   26a8b:	ff 0e                	decl   (%rsi)
{
   26a8d:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   26a94:	00 00 
   26a96:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   26a9b:	31 c0                	xor    %eax,%eax
        c_size = _lv_txt_encoded_size(&txt[*i]);
   26a9d:	8b 3b                	mov    (%rbx),%edi
   26a9f:	48 8d 05 fa ff 20 00 	lea    0x20fffa(%rip),%rax        # 236aa0 <_lv_txt_encoded_size>
   26aa6:	4c 01 e7             	add    %r12,%rdi
   26aa9:	ff 10                	callq  *(%rax)
        if(c_size == 0) {
   26aab:	84 c0                	test   %al,%al
   26aad:	8b 03                	mov    (%rbx),%eax
   26aaf:	75 13                	jne    26ac4 <lv_txt_utf8_prev+0x4a>
            if(*i != 0)
   26ab1:	85 c0                	test   %eax,%eax
   26ab3:	75 04                	jne    26ab9 <lv_txt_utf8_prev+0x3f>
        if(cnt >= 4) return 0; /*No UTF-8 char found before the initial*/
   26ab5:	31 c0                	xor    %eax,%eax
   26ab7:	eb 20                	jmp    26ad9 <lv_txt_utf8_prev+0x5f>
                (*i)--;
   26ab9:	ff c8                	dec    %eax
        if(cnt >= 4) return 0; /*No UTF-8 char found before the initial*/
   26abb:	40 fe cd             	dec    %bpl
                (*i)--;
   26abe:	89 03                	mov    %eax,(%rbx)
        if(cnt >= 4) return 0; /*No UTF-8 char found before the initial*/
   26ac0:	75 db                	jne    26a9d <lv_txt_utf8_prev+0x23>
   26ac2:	eb f1                	jmp    26ab5 <lv_txt_utf8_prev+0x3b>
    uint32_t i_tmp  = *i;
   26ac4:	89 44 24 04          	mov    %eax,0x4(%rsp)
    uint32_t letter = _lv_txt_encoded_next(txt, &i_tmp); /*Character found, get it*/
   26ac8:	48 8d 05 c9 ff 20 00 	lea    0x20ffc9(%rip),%rax        # 236a98 <_lv_txt_encoded_next>
   26acf:	48 8d 74 24 04       	lea    0x4(%rsp),%rsi
   26ad4:	4c 89 e7             	mov    %r12,%rdi
   26ad7:	ff 10                	callq  *(%rax)
}
   26ad9:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   26ade:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
   26ae5:	00 00 
   26ae7:	74 05                	je     26aee <lv_txt_utf8_prev+0x74>
   26ae9:	e8 52 db fd ff       	callq  4640 <__stack_chk_fail@plt>
   26aee:	48 83 c4 10          	add    $0x10,%rsp
   26af2:	5b                   	pop    %rbx
   26af3:	5d                   	pop    %rbp
   26af4:	41 5c                	pop    %r12
   26af6:	c3                   	retq   

0000000000026af7 <_lv_txt_is_cmd>:
    bool ret = false;
   26af7:	31 c0                	xor    %eax,%eax
    if(c == (uint32_t)LV_TXT_COLOR_CMD[0]) {
   26af9:	83 fe 23             	cmp    $0x23,%esi
   26afc:	75 1f                	jne    26b1d <_lv_txt_is_cmd+0x26>
   26afe:	8a 17                	mov    (%rdi),%dl
        if(*state == LV_TXT_CMD_STATE_WAIT) { /*Start char*/
   26b00:	84 d2                	test   %dl,%dl
   26b02:	75 05                	jne    26b09 <_lv_txt_is_cmd+0x12>
            *state = LV_TXT_CMD_STATE_PAR;
   26b04:	c6 07 01             	movb   $0x1,(%rdi)
   26b07:	eb 12                	jmp    26b1b <_lv_txt_is_cmd+0x24>
        else if(*state == LV_TXT_CMD_STATE_PAR) {
   26b09:	80 fa 01             	cmp    $0x1,%dl
   26b0c:	75 05                	jne    26b13 <_lv_txt_is_cmd+0x1c>
            *state = LV_TXT_CMD_STATE_WAIT;
   26b0e:	c6 07 00             	movb   $0x0,(%rdi)
   26b11:	eb 0a                	jmp    26b1d <_lv_txt_is_cmd+0x26>
        else if(*state == LV_TXT_CMD_STATE_IN) {
   26b13:	80 fa 02             	cmp    $0x2,%dl
   26b16:	75 05                	jne    26b1d <_lv_txt_is_cmd+0x26>
            *state = LV_TXT_CMD_STATE_WAIT;
   26b18:	c6 07 00             	movb   $0x0,(%rdi)
            ret    = true;
   26b1b:	b0 01                	mov    $0x1,%al
    if(*state == LV_TXT_CMD_STATE_PAR) {
   26b1d:	80 3f 01             	cmpb   $0x1,(%rdi)
   26b20:	75 0a                	jne    26b2c <_lv_txt_is_cmd+0x35>
        if(c == ' ') {
   26b22:	83 fe 20             	cmp    $0x20,%esi
        ret = true;
   26b25:	b0 01                	mov    $0x1,%al
        if(c == ' ') {
   26b27:	75 03                	jne    26b2c <_lv_txt_is_cmd+0x35>
            *state = LV_TXT_CMD_STATE_IN; /*After the parameter the text is in the command*/
   26b29:	c6 07 02             	movb   $0x2,(%rdi)
}
   26b2c:	c3                   	retq   

0000000000026b2d <_lv_txt_get_width>:
{
   26b2d:	41 57                	push   %r15
   26b2f:	41 56                	push   %r14
   26b31:	41 55                	push   %r13
   26b33:	41 54                	push   %r12
   26b35:	55                   	push   %rbp
   26b36:	53                   	push   %rbx
   26b37:	48 83 ec 28          	sub    $0x28,%rsp
   26b3b:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   26b42:	00 00 
   26b44:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   26b49:	31 c0                	xor    %eax,%eax
    if(font == NULL) return 0;
   26b4b:	48 85 ff             	test   %rdi,%rdi
{
   26b4e:	66 89 4c 24 08       	mov    %cx,0x8(%rsp)
   26b53:	44 88 44 24 0b       	mov    %r8b,0xb(%rsp)
    if(font == NULL) return 0;
   26b58:	0f 84 a3 00 00 00    	je     26c01 <_lv_txt_get_width+0xd4>
   26b5e:	48 85 d2             	test   %rdx,%rdx
   26b61:	49 89 d6             	mov    %rdx,%r14
   26b64:	0f 84 97 00 00 00    	je     26c01 <_lv_txt_get_width+0xd4>
            uint32_t letter      = _lv_txt_encoded_next(txt, &i);
   26b6a:	48 8d 44 24 14       	lea    0x14(%rsp),%rax
    lv_coord_t width             = 0;
   26b6f:	31 db                	xor    %ebx,%ebx
    if(length != 0) {
   26b71:	85 f6                	test   %esi,%esi
   26b73:	48 89 fd             	mov    %rdi,%rbp
   26b76:	41 89 f5             	mov    %esi,%r13d
   26b79:	41 89 cc             	mov    %ecx,%r12d
    uint32_t i                   = 0;
   26b7c:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%rsp)
   26b83:	00 
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
   26b84:	c6 44 24 13 00       	movb   $0x0,0x13(%rsp)
            uint32_t letter      = _lv_txt_encoded_next(txt, &i);
   26b89:	48 89 04 24          	mov    %rax,(%rsp)
    if(length != 0) {
   26b8d:	74 74                	je     26c03 <_lv_txt_get_width+0xd6>
        while(i < length) {
   26b8f:	44 3b 6c 24 14       	cmp    0x14(%rsp),%r13d
   26b94:	76 61                	jbe    26bf7 <_lv_txt_get_width+0xca>
            uint32_t letter      = _lv_txt_encoded_next(txt, &i);
   26b96:	48 8d 05 fb fe 20 00 	lea    0x20fefb(%rip),%rax        # 236a98 <_lv_txt_encoded_next>
   26b9d:	48 8b 34 24          	mov    (%rsp),%rsi
   26ba1:	48 89 ef             	mov    %rbp,%rdi
   26ba4:	ff 10                	callq  *(%rax)
            uint32_t letter_next = _lv_txt_encoded_next(&txt[i], NULL);
   26ba6:	8b 7c 24 14          	mov    0x14(%rsp),%edi
            uint32_t letter      = _lv_txt_encoded_next(txt, &i);
   26baa:	41 89 c7             	mov    %eax,%r15d
            uint32_t letter_next = _lv_txt_encoded_next(&txt[i], NULL);
   26bad:	48 8d 05 e4 fe 20 00 	lea    0x20fee4(%rip),%rax        # 236a98 <_lv_txt_encoded_next>
   26bb4:	31 f6                	xor    %esi,%esi
   26bb6:	48 01 ef             	add    %rbp,%rdi
   26bb9:	ff 10                	callq  *(%rax)
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
   26bbb:	f6 44 24 0b 01       	testb  $0x1,0xb(%rsp)
            uint32_t letter_next = _lv_txt_encoded_next(&txt[i], NULL);
   26bc0:	89 c2                	mov    %eax,%edx
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
   26bc2:	75 18                	jne    26bdc <_lv_txt_get_width+0xaf>
            lv_coord_t char_width = lv_font_get_glyph_width(font, letter, letter_next);
   26bc4:	44 89 fe             	mov    %r15d,%esi
   26bc7:	4c 89 f7             	mov    %r14,%rdi
   26bca:	e8 11 05 00 00       	callq  270e0 <lv_font_get_glyph_width>
            if(char_width > 0) {
   26bcf:	66 85 c0             	test   %ax,%ax
   26bd2:	7e bb                	jle    26b8f <_lv_txt_get_width+0x62>
                width += letter_space;
   26bd4:	03 5c 24 08          	add    0x8(%rsp),%ebx
   26bd8:	01 c3                	add    %eax,%ebx
   26bda:	eb b3                	jmp    26b8f <_lv_txt_get_width+0x62>
                if(_lv_txt_is_cmd(&cmd_state, letter) != false) {
   26bdc:	48 8d 7c 24 13       	lea    0x13(%rsp),%rdi
   26be1:	44 89 fe             	mov    %r15d,%esi
   26be4:	89 44 24 0c          	mov    %eax,0xc(%rsp)
   26be8:	e8 0a ff ff ff       	callq  26af7 <_lv_txt_is_cmd>
   26bed:	84 c0                	test   %al,%al
   26bef:	8b 54 24 0c          	mov    0xc(%rsp),%edx
   26bf3:	74 cf                	je     26bc4 <_lv_txt_get_width+0x97>
   26bf5:	eb 98                	jmp    26b8f <_lv_txt_get_width+0x62>
        if(width > 0) {
   26bf7:	66 85 db             	test   %bx,%bx
   26bfa:	7e 07                	jle    26c03 <_lv_txt_get_width+0xd6>
            width -= letter_space; /*Trim the last letter space. Important if the text is center
   26bfc:	44 29 e3             	sub    %r12d,%ebx
   26bff:	eb 02                	jmp    26c03 <_lv_txt_get_width+0xd6>
    if(font == NULL) return 0;
   26c01:	31 db                	xor    %ebx,%ebx
}
   26c03:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   26c08:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   26c0f:	00 00 
   26c11:	89 d8                	mov    %ebx,%eax
   26c13:	74 05                	je     26c1a <_lv_txt_get_width+0xed>
   26c15:	e8 26 da fd ff       	callq  4640 <__stack_chk_fail@plt>
   26c1a:	48 83 c4 28          	add    $0x28,%rsp
   26c1e:	5b                   	pop    %rbx
   26c1f:	5d                   	pop    %rbp
   26c20:	41 5c                	pop    %r12
   26c22:	41 5d                	pop    %r13
   26c24:	41 5e                	pop    %r14
   26c26:	41 5f                	pop    %r15
   26c28:	c3                   	retq   

0000000000026c29 <_lv_txt_get_next_line>:
{
   26c29:	41 57                	push   %r15
   26c2b:	41 56                	push   %r14
   26c2d:	41 55                	push   %r13
   26c2f:	41 54                	push   %r12
   26c31:	55                   	push   %rbp
   26c32:	53                   	push   %rbx
   26c33:	48 83 ec 58          	sub    $0x58,%rsp
   26c37:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   26c3e:	00 00 
   26c40:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
   26c45:	31 c0                	xor    %eax,%eax
    if(font == NULL) return 0;
   26c47:	48 85 f6             	test   %rsi,%rsi
{
   26c4a:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
   26c4f:	66 89 54 24 2c       	mov    %dx,0x2c(%rsp)
   26c54:	44 88 44 24 2f       	mov    %r8b,0x2f(%rsp)
    if(font == NULL) return 0;
   26c59:	0f 84 75 02 00 00    	je     26ed4 <_lv_txt_get_next_line+0x2ab>
   26c5f:	48 85 ff             	test   %rdi,%rdi
   26c62:	48 89 fd             	mov    %rdi,%rbp
   26c65:	0f 84 69 02 00 00    	je     26ed4 <_lv_txt_get_next_line+0x2ab>
    if((flag & LV_TXT_FLAG_EXPAND) || (flag & LV_TXT_FLAG_FIT)) {
   26c6b:	41 f6 c0 12          	test   $0x12,%r8b
   26c6f:	74 2d                	je     26c9e <_lv_txt_get_next_line+0x75>
        for(i = 0; txt[i] != '\n' && txt[i] != '\r' && txt[i] != '\0'; i++) {
   26c71:	31 c0                	xor    %eax,%eax
   26c73:	89 c2                	mov    %eax,%edx
   26c75:	8a 54 15 00          	mov    0x0(%rbp,%rdx,1),%dl
   26c79:	80 fa 0a             	cmp    $0xa,%dl
   26c7c:	74 11                	je     26c8f <_lv_txt_get_next_line+0x66>
   26c7e:	80 fa 0d             	cmp    $0xd,%dl
   26c81:	74 0c                	je     26c8f <_lv_txt_get_next_line+0x66>
   26c83:	84 d2                	test   %dl,%dl
   26c85:	0f 84 4b 02 00 00    	je     26ed6 <_lv_txt_get_next_line+0x2ad>
   26c8b:	ff c0                	inc    %eax
   26c8d:	eb e4                	jmp    26c73 <_lv_txt_get_next_line+0x4a>
        if(txt[i] != '\0') i++;    /*To go beyond `\n`*/
   26c8f:	84 d2                	test   %dl,%dl
   26c91:	0f 84 3f 02 00 00    	je     26ed6 <_lv_txt_get_next_line+0x2ad>
   26c97:	ff c0                	inc    %eax
   26c99:	e9 38 02 00 00       	jmpq   26ed6 <_lv_txt_get_next_line+0x2ad>
   26c9e:	0f bf c2             	movswl %dx,%eax
   26ca1:	89 cb                	mov    %ecx,%ebx
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
   26ca3:	c6 44 24 3b 00       	movb   $0x0,0x3b(%rsp)
   26ca8:	89 44 24 20          	mov    %eax,0x20(%rsp)
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
   26cac:	44 88 c0             	mov    %r8b,%al
    uint32_t i = 0;                                        /* Iterating index into txt */
   26caf:	c7 44 24 3c 00 00 00 	movl   $0x0,0x3c(%rsp)
   26cb6:	00 
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
   26cb7:	24 02                	and    $0x2,%al
   26cb9:	88 44 24 29          	mov    %al,0x29(%rsp)
   26cbd:	b8 18 7c 00 00       	mov    $0x7c18,%eax
   26cc2:	0f 45 d8             	cmovne %eax,%ebx
    while(txt[i] != '\0' && max_width > 0) {
   26cc5:	8b 44 24 3c          	mov    0x3c(%rsp),%eax
   26cc9:	89 44 24 0c          	mov    %eax,0xc(%rsp)
   26ccd:	48 01 e8             	add    %rbp,%rax
   26cd0:	80 38 00             	cmpb   $0x0,(%rax)
   26cd3:	48 89 04 24          	mov    %rax,(%rsp)
   26cd7:	0f 84 d9 01 00 00    	je     26eb6 <_lv_txt_get_next_line+0x28d>
   26cdd:	66 85 db             	test   %bx,%bx
   26ce0:	0f 8e d0 01 00 00    	jle    26eb6 <_lv_txt_get_next_line+0x28d>
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
   26ce6:	80 7c 24 29 00       	cmpb   $0x0,0x29(%rsp)
   26ceb:	b8 18 7c 00 00       	mov    $0x7c18,%eax
    uint32_t i = 0, i_next = 0, i_next_next = 0;  /* Iterating index into txt */
   26cf0:	c7 44 24 40 00 00 00 	movl   $0x0,0x40(%rsp)
   26cf7:	00 
   26cf8:	c7 44 24 44 00 00 00 	movl   $0x0,0x44(%rsp)
   26cff:	00 
    letter = _lv_txt_encoded_next(txt, &i_next);
   26d00:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
   26d05:	48 8b 3c 24          	mov    (%rsp),%rdi
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
   26d09:	0f 44 c3             	cmove  %ebx,%eax
        uint32_t word_w = 0;
   26d0c:	45 31 ed             	xor    %r13d,%r13d
    uint32_t break_index = NO_BREAK_FOUND; /* only used for "long" words */
   26d0f:	41 83 ce ff          	or     $0xffffffff,%r14d
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
   26d13:	66 89 44 24 2a       	mov    %ax,0x2a(%rsp)
    letter = _lv_txt_encoded_next(txt, &i_next);
   26d18:	48 8d 05 79 fd 20 00 	lea    0x20fd79(%rip),%rax        # 236a98 <_lv_txt_encoded_next>
    uint32_t i = 0, i_next = 0, i_next_next = 0;  /* Iterating index into txt */
   26d1f:	45 31 ff             	xor    %r15d,%r15d
    letter = _lv_txt_encoded_next(txt, &i_next);
   26d22:	ff 10                	callq  *(%rax)
   26d24:	41 89 c4             	mov    %eax,%r12d
    i_next_next = i_next;
   26d27:	8b 44 24 40          	mov    0x40(%rsp),%eax
    uint32_t word_len = 0;   /* Number of characters in the transversed word */
   26d2b:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%rsp)
   26d32:	00 
    lv_coord_t cur_w = 0;  /* Pixel Width of transversed string */
   26d33:	66 c7 44 24 16 00 00 	movw   $0x0,0x16(%rsp)
    uint32_t letter_next = 0; /* Letter at i_next */
   26d3a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
   26d41:	00 
    i_next_next = i_next;
   26d42:	89 44 24 44          	mov    %eax,0x44(%rsp)
    while(txt[i] != '\0') {
   26d46:	48 8b 3c 24          	mov    (%rsp),%rdi
   26d4a:	44 89 f8             	mov    %r15d,%eax
   26d4d:	80 3c 07 00          	cmpb   $0x0,(%rdi,%rax,1)
   26d51:	0f 84 de 00 00 00    	je     26e35 <_lv_txt_get_next_line+0x20c>
        letter_next = _lv_txt_encoded_next(txt, &i_next_next);
   26d57:	48 8d 05 3a fd 20 00 	lea    0x20fd3a(%rip),%rax        # 236a98 <_lv_txt_encoded_next>
   26d5e:	48 8d 74 24 44       	lea    0x44(%rsp),%rsi
   26d63:	48 8b 3c 24          	mov    (%rsp),%rdi
   26d67:	ff 10                	callq  *(%rax)
   26d69:	89 44 24 08          	mov    %eax,0x8(%rsp)
        word_len++;
   26d6d:	8b 44 24 10          	mov    0x10(%rsp),%eax
   26d71:	ff c0                	inc    %eax
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
   26d73:	f6 44 24 2f 01       	testb  $0x1,0x2f(%rsp)
        word_len++;
   26d78:	89 44 24 24          	mov    %eax,0x24(%rsp)
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
   26d7c:	74 15                	je     26d93 <_lv_txt_get_next_line+0x16a>
            if(_lv_txt_is_cmd(cmd_state, letter) != false) {
   26d7e:	48 8d 7c 24 3b       	lea    0x3b(%rsp),%rdi
   26d83:	44 89 e6             	mov    %r12d,%esi
   26d86:	e8 6c fd ff ff       	callq  26af7 <_lv_txt_is_cmd>
   26d8b:	84 c0                	test   %al,%al
   26d8d:	0f 85 83 00 00 00    	jne    26e16 <_lv_txt_get_next_line+0x1ed>
        letter_w = lv_font_get_glyph_width(font, letter, letter_next);
   26d93:	8b 54 24 08          	mov    0x8(%rsp),%edx
   26d97:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
   26d9c:	44 89 e6             	mov    %r12d,%esi
   26d9f:	e8 3c 03 00 00       	callq  270e0 <lv_font_get_glyph_width>
        cur_w += letter_w;
   26da4:	66 8b 54 24 16       	mov    0x16(%rsp),%dx
   26da9:	01 c2                	add    %eax,%edx
        if(letter_w > 0) {
   26dab:	66 85 c0             	test   %ax,%ax
   26dae:	7e 04                	jle    26db4 <_lv_txt_get_next_line+0x18b>
            cur_w += letter_space;
   26db0:	03 54 24 2c          	add    0x2c(%rsp),%edx
        if(break_index == NO_BREAK_FOUND && (cur_w - letter_space) > max_width) {
   26db4:	41 83 fe ff          	cmp    $0xffffffff,%r14d
   26db8:	66 89 54 24 16       	mov    %dx,0x16(%rsp)
   26dbd:	75 12                	jne    26dd1 <_lv_txt_get_next_line+0x1a8>
   26dbf:	0f bf c2             	movswl %dx,%eax
   26dc2:	0f bf 74 24 2a       	movswl 0x2a(%rsp),%esi
   26dc7:	2b 44 24 20          	sub    0x20(%rsp),%eax
   26dcb:	39 f0                	cmp    %esi,%eax
   26dcd:	45 0f 4f f7          	cmovg  %r15d,%r14d
        if(letter == '\n' || letter == '\r' || is_break_char(letter)) {
   26dd1:	41 83 fc 0a          	cmp    $0xa,%r12d
   26dd5:	74 24                	je     26dfb <_lv_txt_get_next_line+0x1d2>
   26dd7:	41 83 fc 0d          	cmp    $0xd,%r12d
   26ddb:	74 1e                	je     26dfb <_lv_txt_get_next_line+0x1d2>
{
    uint8_t i;
    bool ret = false;

    /*Compare the letter to TXT_BREAK_CHARS*/
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
   26ddd:	31 f6                	xor    %esi,%esi
   26ddf:	48 8d 0d b3 cf 00 00 	lea    0xcfb3(%rip),%rcx        # 33d99 <_lv_bpp1_opa_table+0x544>
   26de6:	40 0f b6 c6          	movzbl %sil,%eax
   26dea:	0f be 04 01          	movsbl (%rcx,%rax,1),%eax
   26dee:	84 c0                	test   %al,%al
   26df0:	74 1a                	je     26e0c <_lv_txt_get_next_line+0x1e3>
        if(letter == (uint32_t)LV_TXT_BREAK_CHARS[i]) {
   26df2:	41 39 c4             	cmp    %eax,%r12d
   26df5:	74 04                	je     26dfb <_lv_txt_get_next_line+0x1d2>
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
   26df7:	ff c6                	inc    %esi
   26df9:	eb e4                	jmp    26ddf <_lv_txt_get_next_line+0x1b6>
            if(i == 0 && break_index == NO_BREAK_FOUND && word_w_ptr != NULL) *word_w_ptr = cur_w;
   26dfb:	45 85 ff             	test   %r15d,%r15d
   26dfe:	75 35                	jne    26e35 <_lv_txt_get_next_line+0x20c>
   26e00:	41 83 fe ff          	cmp    $0xffffffff,%r14d
   26e04:	75 2f                	jne    26e35 <_lv_txt_get_next_line+0x20c>
   26e06:	44 0f bf ea          	movswl %dx,%r13d
   26e0a:	eb 2f                	jmp    26e3b <_lv_txt_get_next_line+0x212>
        if(word_w_ptr != NULL && break_index == NO_BREAK_FOUND) *word_w_ptr = cur_w;
   26e0c:	41 83 fe ff          	cmp    $0xffffffff,%r14d
   26e10:	75 04                	jne    26e16 <_lv_txt_get_next_line+0x1ed>
   26e12:	44 0f bf ea          	movswl %dx,%r13d
        i_next = i_next_next;
   26e16:	8b 44 24 44          	mov    0x44(%rsp),%eax
        i = i_next;
   26e1a:	44 8b 7c 24 40       	mov    0x40(%rsp),%r15d
        letter_next = _lv_txt_encoded_next(txt, &i_next_next);
   26e1f:	44 8b 64 24 08       	mov    0x8(%rsp),%r12d
        i_next = i_next_next;
   26e24:	89 44 24 40          	mov    %eax,0x40(%rsp)
        letter_next = _lv_txt_encoded_next(txt, &i_next_next);
   26e28:	8b 44 24 24          	mov    0x24(%rsp),%eax
   26e2c:	89 44 24 10          	mov    %eax,0x10(%rsp)
   26e30:	e9 11 ff ff ff       	jmpq   26d46 <_lv_txt_get_next_line+0x11d>
    if(break_index == NO_BREAK_FOUND) {
   26e35:	41 83 fe ff          	cmp    $0xffffffff,%r14d
   26e39:	75 1b                	jne    26e56 <_lv_txt_get_next_line+0x22d>
        if(word_len == 0 || (letter == '\r' && letter_next == '\n')) i = i_next;
   26e3b:	83 7c 24 10 00       	cmpl   $0x0,0x10(%rsp)
   26e40:	74 0d                	je     26e4f <_lv_txt_get_next_line+0x226>
   26e42:	41 83 fc 0d          	cmp    $0xd,%r12d
   26e46:	75 20                	jne    26e68 <_lv_txt_get_next_line+0x23f>
   26e48:	83 7c 24 08 0a       	cmpl   $0xa,0x8(%rsp)
   26e4d:	75 19                	jne    26e68 <_lv_txt_get_next_line+0x23f>
   26e4f:	44 8b 7c 24 40       	mov    0x40(%rsp),%r15d
   26e54:	eb 12                	jmp    26e68 <_lv_txt_get_next_line+0x23f>
    if(force) return break_index;
   26e56:	31 c0                	xor    %eax,%eax
   26e58:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp)
   26e5d:	44 0f 45 f0          	cmovne %eax,%r14d
   26e61:	44 0f 45 e8          	cmovne %eax,%r13d
   26e65:	45 89 f7             	mov    %r14d,%r15d
        max_width -= word_w;
   26e68:	44 29 eb             	sub    %r13d,%ebx
        if(advance == 0) {
   26e6b:	45 85 ff             	test   %r15d,%r15d
   26e6e:	8b 44 24 3c          	mov    0x3c(%rsp),%eax
   26e72:	75 17                	jne    26e8b <_lv_txt_get_next_line+0x262>
            if(i == 0) _lv_txt_encoded_next(txt, &i); // prevent inf loops
   26e74:	85 c0                	test   %eax,%eax
   26e76:	75 56                	jne    26ece <_lv_txt_get_next_line+0x2a5>
   26e78:	48 8d 05 19 fc 20 00 	lea    0x20fc19(%rip),%rax        # 236a98 <_lv_txt_encoded_next>
   26e7f:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
   26e84:	48 89 ef             	mov    %rbp,%rdi
   26e87:	ff 10                	callq  *(%rax)
   26e89:	eb 2b                	jmp    26eb6 <_lv_txt_get_next_line+0x28d>
        i += advance;
   26e8b:	42 8d 0c 38          	lea    (%rax,%r15,1),%ecx
        if(txt[0] == '\n' || txt[0] == '\r') break;
   26e8f:	8a 45 00             	mov    0x0(%rbp),%al
        i += advance;
   26e92:	89 4c 24 3c          	mov    %ecx,0x3c(%rsp)
        if(txt[0] == '\n' || txt[0] == '\r') break;
   26e96:	3c 0a                	cmp    $0xa,%al
   26e98:	74 1c                	je     26eb6 <_lv_txt_get_next_line+0x28d>
   26e9a:	3c 0d                	cmp    $0xd,%al
   26e9c:	74 18                	je     26eb6 <_lv_txt_get_next_line+0x28d>
        if(txt[i] == '\n' || txt[i] == '\r') {
   26e9e:	89 c8                	mov    %ecx,%eax
   26ea0:	8a 44 05 00          	mov    0x0(%rbp,%rax,1),%al
   26ea4:	3c 0a                	cmp    $0xa,%al
   26ea6:	74 08                	je     26eb0 <_lv_txt_get_next_line+0x287>
   26ea8:	3c 0d                	cmp    $0xd,%al
   26eaa:	0f 85 15 fe ff ff    	jne    26cc5 <_lv_txt_get_next_line+0x9c>
            i++;  /* Include the following newline in the current line */
   26eb0:	ff c1                	inc    %ecx
   26eb2:	89 4c 24 3c          	mov    %ecx,0x3c(%rsp)
    if(i == 0) {
   26eb6:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%rsp)
   26ebb:	75 11                	jne    26ece <_lv_txt_get_next_line+0x2a5>
        _lv_txt_encoded_next(txt, &i);
   26ebd:	48 8d 05 d4 fb 20 00 	lea    0x20fbd4(%rip),%rax        # 236a98 <_lv_txt_encoded_next>
   26ec4:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
   26ec9:	48 89 ef             	mov    %rbp,%rdi
   26ecc:	ff 10                	callq  *(%rax)
    return i;
   26ece:	8b 44 24 3c          	mov    0x3c(%rsp),%eax
   26ed2:	eb 02                	jmp    26ed6 <_lv_txt_get_next_line+0x2ad>
    if(font == NULL) return 0;
   26ed4:	31 c0                	xor    %eax,%eax
}
   26ed6:	48 8b 5c 24 48       	mov    0x48(%rsp),%rbx
   26edb:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
   26ee2:	00 00 
   26ee4:	74 05                	je     26eeb <_lv_txt_get_next_line+0x2c2>
   26ee6:	e8 55 d7 fd ff       	callq  4640 <__stack_chk_fail@plt>
   26eeb:	48 83 c4 58          	add    $0x58,%rsp
   26eef:	5b                   	pop    %rbx
   26ef0:	5d                   	pop    %rbp
   26ef1:	41 5c                	pop    %r12
   26ef3:	41 5d                	pop    %r13
   26ef5:	41 5e                	pop    %r14
   26ef7:	41 5f                	pop    %r15
   26ef9:	c3                   	retq   

0000000000026efa <_lv_txt_get_size>:
{
   26efa:	41 57                	push   %r15
   26efc:	41 56                	push   %r14
   26efe:	41 55                	push   %r13
   26f00:	41 54                	push   %r12
   26f02:	55                   	push   %rbp
   26f03:	53                   	push   %rbx
   26f04:	48 83 ec 28          	sub    $0x28,%rsp
    if(font == NULL) return;
   26f08:	48 85 d2             	test   %rdx,%rdx
{
   26f0b:	8b 44 24 60          	mov    0x60(%rsp),%eax
   26f0f:	66 44 89 44 24 0e    	mov    %r8w,0xe(%rsp)
    size_res->x = 0;
   26f15:	c7 07 00 00 00 00    	movl   $0x0,(%rdi)
    if(font == NULL) return;
   26f1b:	0f 84 37 01 00 00    	je     27058 <_lv_txt_get_size+0x15e>
   26f21:	48 85 f6             	test   %rsi,%rsi
   26f24:	49 89 f6             	mov    %rsi,%r14
   26f27:	0f 84 2b 01 00 00    	je     27058 <_lv_txt_get_size+0x15e>
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
   26f2d:	a8 02                	test   $0x2,%al
   26f2f:	48 89 fb             	mov    %rdi,%rbx
    uint16_t letter_height = lv_font_get_line_height(font);
   26f32:	66 8b 6a 10          	mov    0x10(%rdx),%bp
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
   26f36:	0f b6 f8             	movzbl %al,%edi
   26f39:	b8 18 7c 00 00       	mov    $0x7c18,%eax
   26f3e:	49 89 d7             	mov    %rdx,%r15
   26f41:	44 0f 45 c8          	cmovne %eax,%r9d
        new_line_start += _lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
   26f45:	0f bf c1             	movswl %cx,%eax
   26f48:	45 89 c5             	mov    %r8d,%r13d
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
   26f4b:	89 7c 24 08          	mov    %edi,0x8(%rsp)
    uint32_t line_start     = 0;
   26f4f:	45 31 e4             	xor    %r12d,%r12d
        new_line_start += _lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
   26f52:	89 44 24 18          	mov    %eax,0x18(%rsp)
    while(text[line_start] != '\0') {
   26f56:	45 89 e3             	mov    %r12d,%r11d
   26f59:	4d 01 f3             	add    %r14,%r11
   26f5c:	41 80 3b 00          	cmpb   $0x0,(%r11)
   26f60:	0f 84 c0 00 00 00    	je     27026 <_lv_txt_get_size+0x12c>
        new_line_start += _lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
   26f66:	8b 54 24 18          	mov    0x18(%rsp),%edx
   26f6a:	44 8b 44 24 08       	mov    0x8(%rsp),%r8d
   26f6f:	41 0f bf c9          	movswl %r9w,%ecx
   26f73:	4c 89 fe             	mov    %r15,%rsi
   26f76:	4c 89 df             	mov    %r11,%rdi
   26f79:	44 89 4c 24 1c       	mov    %r9d,0x1c(%rsp)
   26f7e:	4c 89 5c 24 10       	mov    %r11,0x10(%rsp)
   26f83:	e8 a1 fc ff ff       	callq  26c29 <_lv_txt_get_next_line>
        if((unsigned long)size_res->y + (unsigned long)letter_height + (unsigned long)line_space > LV_MAX_OF(lv_coord_t)) {
   26f88:	48 0f bf 74 24 0e    	movswq 0xe(%rsp),%rsi
   26f8e:	66 8b 4b 02          	mov    0x2(%rbx),%cx
   26f92:	0f b7 d5             	movzwl %bp,%edx
        new_line_start += _lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
   26f95:	41 01 c4             	add    %eax,%r12d
        if((unsigned long)size_res->y + (unsigned long)letter_height + (unsigned long)line_space > LV_MAX_OF(lv_coord_t)) {
   26f98:	4c 8b 5c 24 10       	mov    0x10(%rsp),%r11
   26f9d:	44 8b 4c 24 1c       	mov    0x1c(%rsp),%r9d
   26fa2:	48 01 f2             	add    %rsi,%rdx
   26fa5:	48 0f bf f1          	movswq %cx,%rsi
   26fa9:	48 01 f2             	add    %rsi,%rdx
   26fac:	48 81 fa ff 7f 00 00 	cmp    $0x7fff,%rdx
   26fb3:	76 34                	jbe    26fe9 <_lv_txt_get_size+0xef>
}
   26fb5:	48 83 c4 28          	add    $0x28,%rsp
            LV_LOG_WARN("lv_txt_get_size: integer overflow while calculating text height");
   26fb9:	4c 8d 05 e1 cd 00 00 	lea    0xcde1(%rip),%r8        # 33da1 <_lv_bpp1_opa_table+0x54c>
   26fc0:	48 8d 0d 59 9b 00 00 	lea    0x9b59(%rip),%rcx        # 30b20 <__func__.2407>
}
   26fc7:	5b                   	pop    %rbx
   26fc8:	5d                   	pop    %rbp
   26fc9:	41 5c                	pop    %r12
   26fcb:	41 5d                	pop    %r13
   26fcd:	41 5e                	pop    %r14
   26fcf:	41 5f                	pop    %r15
            LV_LOG_WARN("lv_txt_get_size: integer overflow while calculating text height");
   26fd1:	48 8d 35 09 ce 00 00 	lea    0xce09(%rip),%rsi        # 33de1 <_lv_bpp1_opa_table+0x58c>
   26fd8:	ba 71 00 00 00       	mov    $0x71,%edx
   26fdd:	bf 02 00 00 00       	mov    $0x2,%edi
   26fe2:	31 c0                	xor    %eax,%eax
   26fe4:	e9 6d ef ff ff       	jmpq   25f56 <_lv_log_add>
            size_res->y += line_space;
   26fe9:	66 8b 74 24 0e       	mov    0xe(%rsp),%si
        lv_coord_t act_line_length = _lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space,
   26fee:	44 8b 44 24 08       	mov    0x8(%rsp),%r8d
   26ff3:	4c 89 df             	mov    %r11,%rdi
   26ff6:	44 89 4c 24 10       	mov    %r9d,0x10(%rsp)
            size_res->y += line_space;
   26ffb:	8d 14 2e             	lea    (%rsi,%rbp,1),%edx
        lv_coord_t act_line_length = _lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space,
   26ffe:	89 c6                	mov    %eax,%esi
            size_res->y += line_space;
   27000:	01 ca                	add    %ecx,%edx
        lv_coord_t act_line_length = _lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space,
   27002:	8b 4c 24 18          	mov    0x18(%rsp),%ecx
            size_res->y += line_space;
   27006:	66 89 53 02          	mov    %dx,0x2(%rbx)
        lv_coord_t act_line_length = _lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space,
   2700a:	4c 89 fa             	mov    %r15,%rdx
   2700d:	e8 1b fb ff ff       	callq  26b2d <_lv_txt_get_width>
        size_res->x = LV_MATH_MAX(act_line_length, size_res->x);
   27012:	66 39 03             	cmp    %ax,(%rbx)
   27015:	44 8b 4c 24 10       	mov    0x10(%rsp),%r9d
   2701a:	66 0f 4d 03          	cmovge (%rbx),%ax
   2701e:	66 89 03             	mov    %ax,(%rbx)
   27021:	e9 30 ff ff ff       	jmpq   26f56 <_lv_txt_get_size+0x5c>
    if((line_start != 0) && (text[line_start - 1] == '\n' || text[line_start - 1] == '\r')) {
   27026:	45 85 e4             	test   %r12d,%r12d
   27029:	74 1a                	je     27045 <_lv_txt_get_size+0x14b>
   2702b:	41 8d 44 24 ff       	lea    -0x1(%r12),%eax
   27030:	41 8a 04 06          	mov    (%r14,%rax,1),%al
   27034:	3c 0a                	cmp    $0xa,%al
   27036:	74 04                	je     2703c <_lv_txt_get_size+0x142>
   27038:	3c 0d                	cmp    $0xd,%al
   2703a:	75 09                	jne    27045 <_lv_txt_get_size+0x14b>
        size_res->y += letter_height + line_space;
   2703c:	42 8d 44 2d 00       	lea    0x0(%rbp,%r13,1),%eax
   27041:	66 01 43 02          	add    %ax,0x2(%rbx)
    if(size_res->y == 0)
   27045:	66 8b 43 02          	mov    0x2(%rbx),%ax
        size_res->y = letter_height;
   27049:	89 c2                	mov    %eax,%edx
   2704b:	44 29 ea             	sub    %r13d,%edx
   2704e:	66 85 c0             	test   %ax,%ax
   27051:	0f 45 ea             	cmovne %edx,%ebp
   27054:	66 89 6b 02          	mov    %bp,0x2(%rbx)
}
   27058:	48 83 c4 28          	add    $0x28,%rsp
   2705c:	5b                   	pop    %rbx
   2705d:	5d                   	pop    %rbp
   2705e:	41 5c                	pop    %r12
   27060:	41 5d                	pop    %r13
   27062:	41 5e                	pop    %r14
   27064:	41 5f                	pop    %r15
   27066:	c3                   	retq   

0000000000027067 <_lv_utils_bsearch>:
 *
 * @return a pointer to a matching item, or NULL if none exists.
 */
void * _lv_utils_bsearch(const void * key, const void * base, uint32_t n, uint32_t size,
                         int32_t (*cmp)(const void * pRef, const void * pElement))
{
   27067:	41 57                	push   %r15
   27069:	41 56                	push   %r14
   2706b:	49 89 f7             	mov    %rsi,%r15
   2706e:	41 55                	push   %r13
   27070:	41 54                	push   %r12

    for(middle = base; n != 0;) {
        middle += (n / 2) * size;
        if((c = (*cmp)(key, middle)) > 0) {
            n    = (n / 2) - ((n & 1) == 0);
            base = (middle += size);
   27072:	41 89 cd             	mov    %ecx,%r13d
{
   27075:	55                   	push   %rbp
   27076:	53                   	push   %rbx
   27077:	49 89 fc             	mov    %rdi,%r12
   2707a:	89 d3                	mov    %edx,%ebx
   2707c:	48 83 ec 18          	sub    $0x18,%rsp
    for(middle = base; n != 0;) {
   27080:	85 db                	test   %ebx,%ebx
   27082:	74 43                	je     270c7 <_lv_utils_bsearch+0x60>
        middle += (n / 2) * size;
   27084:	41 89 de             	mov    %ebx,%r14d
   27087:	89 4c 24 0c          	mov    %ecx,0xc(%rsp)
        if((c = (*cmp)(key, middle)) > 0) {
   2708b:	4c 89 04 24          	mov    %r8,(%rsp)
        middle += (n / 2) * size;
   2708f:	41 d1 ee             	shr    %r14d
        if((c = (*cmp)(key, middle)) > 0) {
   27092:	4c 89 e7             	mov    %r12,%rdi
        middle += (n / 2) * size;
   27095:	44 89 f5             	mov    %r14d,%ebp
   27098:	0f af e9             	imul   %ecx,%ebp
   2709b:	4c 01 fd             	add    %r15,%rbp
        if((c = (*cmp)(key, middle)) > 0) {
   2709e:	48 89 ee             	mov    %rbp,%rsi
   270a1:	41 ff d0             	callq  *%r8
   270a4:	83 f8 00             	cmp    $0x0,%eax
   270a7:	4c 8b 04 24          	mov    (%rsp),%r8
   270ab:	8b 4c 24 0c          	mov    0xc(%rsp),%ecx
   270af:	7e 0f                	jle    270c0 <_lv_utils_bsearch+0x59>
   270b1:	f7 d3                	not    %ebx
            base = (middle += size);
   270b3:	4e 8d 7c 2d 00       	lea    0x0(%rbp,%r13,1),%r15
   270b8:	83 e3 01             	and    $0x1,%ebx
            n    = (n / 2) - ((n & 1) == 0);
   270bb:	41 29 de             	sub    %ebx,%r14d
   270be:	eb 02                	jmp    270c2 <_lv_utils_bsearch+0x5b>
        }
        else if(c < 0) {
   270c0:	74 07                	je     270c9 <_lv_utils_bsearch+0x62>
{
   270c2:	44 89 f3             	mov    %r14d,%ebx
   270c5:	eb b9                	jmp    27080 <_lv_utils_bsearch+0x19>
        }
        else {
            return (char *)middle;
        }
    }
    return NULL;
   270c7:	31 ed                	xor    %ebp,%ebp
}
   270c9:	48 83 c4 18          	add    $0x18,%rsp
   270cd:	48 89 e8             	mov    %rbp,%rax
   270d0:	5b                   	pop    %rbx
   270d1:	5d                   	pop    %rbp
   270d2:	41 5c                	pop    %r12
   270d4:	41 5d                	pop    %r13
   270d6:	41 5e                	pop    %r14
   270d8:	41 5f                	pop    %r15
   270da:	c3                   	retq   

00000000000270db <lv_font_get_glyph_bitmap>:
 * @param letter an UNICODE character code
 * @return  pointer to the bitmap of the letter
 */
const uint8_t * lv_font_get_glyph_bitmap(const lv_font_t * font_p, uint32_t letter)
{
    return font_p->get_glyph_bitmap(font_p, letter);
   270db:	ff 67 08             	jmpq   *0x8(%rdi)

00000000000270de <lv_font_get_glyph_dsc>:
 *         false: the letter was not found, no data is loaded to `dsc_out`
 */
bool lv_font_get_glyph_dsc(const lv_font_t * font_p, lv_font_glyph_dsc_t * dsc_out, uint32_t letter,
                           uint32_t letter_next)
{
    return font_p->get_glyph_dsc(font_p, dsc_out, letter, letter_next);
   270de:	ff 27                	jmpq   *(%rdi)

00000000000270e0 <lv_font_get_glyph_width>:
 * @param letter an UNICODE letter
 * @param letter_next the next letter after `letter`. Used for kerning
 * @return the width of the glyph
 */
uint16_t lv_font_get_glyph_width(const lv_font_t * font, uint32_t letter, uint32_t letter_next)
{
   270e0:	48 83 ec 28          	sub    $0x28,%rsp
   270e4:	89 f0                	mov    %esi,%eax
    lv_font_glyph_dsc_t g;
    bool ret;
    ret = lv_font_get_glyph_dsc(font, &g, letter, letter_next);
   270e6:	48 8d 74 24 0c       	lea    0xc(%rsp),%rsi
{
   270eb:	64 48 8b 0c 25 28 00 	mov    %fs:0x28,%rcx
   270f2:	00 00 
   270f4:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
   270f9:	31 c9                	xor    %ecx,%ecx
    ret = lv_font_get_glyph_dsc(font, &g, letter, letter_next);
   270fb:	89 d1                	mov    %edx,%ecx
   270fd:	89 c2                	mov    %eax,%edx
   270ff:	e8 da ff ff ff       	callq  270de <lv_font_get_glyph_dsc>
   27104:	31 d2                	xor    %edx,%edx
    if(ret) return g.adv_w;
   27106:	84 c0                	test   %al,%al
   27108:	74 04                	je     2710e <lv_font_get_glyph_width+0x2e>
   2710a:	8b 54 24 0c          	mov    0xc(%rsp),%edx
    else return 0;
}
   2710e:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   27113:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   2711a:	00 00 
   2711c:	89 d0                	mov    %edx,%eax
   2711e:	74 05                	je     27125 <lv_font_get_glyph_width+0x45>
   27120:	e8 1b d5 fd ff       	callq  4640 <__stack_chk_fail@plt>
   27125:	48 83 c4 28          	add    $0x28,%rsp
   27129:	c3                   	retq   

000000000002712a <kern_pair_8_compare>:
{
    const uint8_t * ref8_p = ref;
    const uint8_t * element8_p = element;

    /*If the MSB is different it will matter. If not return the diff. of the LSB*/
    if(ref8_p[0] != element8_p[0]) return (int32_t)ref8_p[0] - element8_p[0];
   2712a:	0f b6 07             	movzbl (%rdi),%eax
   2712d:	0f b6 16             	movzbl (%rsi),%edx
   27130:	38 d0                	cmp    %dl,%al
   27132:	75 08                	jne    2713c <kern_pair_8_compare+0x12>
    else return (int32_t) ref8_p[1] - element8_p[1];
   27134:	0f b6 47 01          	movzbl 0x1(%rdi),%eax
   27138:	0f b6 56 01          	movzbl 0x1(%rsi),%edx
   2713c:	29 d0                	sub    %edx,%eax

}
   2713e:	c3                   	retq   

000000000002713f <kern_pair_16_compare>:
{
    const uint16_t * ref16_p = ref;
    const uint16_t * element16_p = element;

    /*If the MSB is different it will matter. If not return the diff. of the LSB*/
    if(ref16_p[0] != element16_p[0]) return (int32_t)ref16_p[0] - element16_p[0];
   2713f:	0f b7 07             	movzwl (%rdi),%eax
   27142:	0f b7 16             	movzwl (%rsi),%edx
   27145:	66 39 d0             	cmp    %dx,%ax
   27148:	75 08                	jne    27152 <kern_pair_16_compare+0x13>
    else return (int32_t) ref16_p[1] - element16_p[1];
   2714a:	0f b7 47 02          	movzwl 0x2(%rdi),%eax
   2714e:	0f b7 56 02          	movzwl 0x2(%rsi),%edx
   27152:	29 d0                	sub    %edx,%eax
}
   27154:	c3                   	retq   

0000000000027155 <unicode_list_compare>:
 *  @retval > 0   Reference is less than element.
 *
 */
static int32_t unicode_list_compare(const void * ref, const void * element)
{
    return ((int32_t)(*(uint16_t *)ref)) - ((int32_t)(*(uint16_t *)element));
   27155:	0f b7 07             	movzwl (%rdi),%eax
   27158:	0f b7 16             	movzwl (%rsi),%edx
   2715b:	29 d0                	sub    %edx,%eax
}
   2715d:	c3                   	retq   

000000000002715e <get_glyph_dsc_id.isra.0.part.1>:
static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
   2715e:	41 55                	push   %r13
   27160:	41 54                	push   %r12
   27162:	55                   	push   %rbp
   27163:	53                   	push   %rbx
   27164:	48 83 ec 18          	sub    $0x18,%rsp
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
   27168:	48 8b 2f             	mov    (%rdi),%rbp
static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
   2716b:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   27172:	00 00 
   27174:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   27179:	31 c0                	xor    %eax,%eax
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
   2717b:	39 75 28             	cmp    %esi,0x28(%rbp)
   2717e:	74 0e                	je     2718e <get_glyph_dsc_id.isra.0.part.1+0x30>
   27180:	41 89 f5             	mov    %esi,%r13d
    for(i = 0; i < fdsc->cmap_num; i++) {
   27183:	66 8b 75 22          	mov    0x22(%rbp),%si
   27187:	66 81 e6 ff 03       	and    $0x3ff,%si
   2718c:	eb 26                	jmp    271b4 <get_glyph_dsc_id.isra.0.part.1+0x56>
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
   2718e:	8b 5d 2c             	mov    0x2c(%rbp),%ebx
   27191:	e9 f2 00 00 00       	jmpq   27288 <get_glyph_dsc_id.isra.0.part.1+0x12a>
        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
   27196:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
   2719a:	49 89 c4             	mov    %rax,%r12
   2719d:	44 89 ea             	mov    %r13d,%edx
   271a0:	49 c1 e4 05          	shl    $0x5,%r12
   271a4:	48 ff c0             	inc    %rax
   271a7:	4c 01 e1             	add    %r12,%rcx
   271aa:	2b 11                	sub    (%rcx),%edx
        if(rcp > fdsc->cmaps[i].range_length) continue;
   271ac:	0f b7 79 04          	movzwl 0x4(%rcx),%edi
   271b0:	39 fa                	cmp    %edi,%edx
   271b2:	76 0a                	jbe    271be <get_glyph_dsc_id.isra.0.part.1+0x60>
    for(i = 0; i < fdsc->cmap_num; i++) {
   271b4:	66 39 c6             	cmp    %ax,%si
   271b7:	77 dd                	ja     27196 <get_glyph_dsc_id.isra.0.part.1+0x38>
   271b9:	e9 bd 00 00 00       	jmpq   2727b <get_glyph_dsc_id.isra.0.part.1+0x11d>
        if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY) {
   271be:	8a 41 1a             	mov    0x1a(%rcx),%al
   271c1:	84 c0                	test   %al,%al
   271c3:	75 0b                	jne    271d0 <get_glyph_dsc_id.isra.0.part.1+0x72>
            glyph_id = fdsc->cmaps[i].glyph_id_start + rcp;
   271c5:	0f b7 59 06          	movzwl 0x6(%rcx),%ebx
   271c9:	01 d3                	add    %edx,%ebx
   271cb:	e9 a2 00 00 00       	jmpq   27272 <get_glyph_dsc_id.isra.0.part.1+0x114>
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL) {
   271d0:	3c 01                	cmp    $0x1,%al
   271d2:	75 11                	jne    271e5 <get_glyph_dsc_id.isra.0.part.1+0x87>
            glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_8[rcp];
   271d4:	48 8b 41 10          	mov    0x10(%rcx),%rax
   271d8:	0f b6 1c 10          	movzbl (%rax,%rdx,1),%ebx
   271dc:	0f b7 41 06          	movzwl 0x6(%rcx),%eax
   271e0:	e9 8b 00 00 00       	jmpq   27270 <get_glyph_dsc_id.isra.0.part.1+0x112>
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_TINY) {
   271e5:	3c 02                	cmp    $0x2,%al
   271e7:	75 3e                	jne    27227 <get_glyph_dsc_id.isra.0.part.1+0xc9>
            uint16_t key = rcp;
   271e9:	66 89 54 24 06       	mov    %dx,0x6(%rsp)
            uint8_t * p = _lv_utils_bsearch(&key, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length,
   271ee:	0f b7 51 18          	movzwl 0x18(%rcx),%edx
   271f2:	48 8d 7c 24 06       	lea    0x6(%rsp),%rdi
   271f7:	48 8b 71 08          	mov    0x8(%rcx),%rsi
   271fb:	4c 8d 05 53 ff ff ff 	lea    -0xad(%rip),%r8        # 27155 <unicode_list_compare>
   27202:	b9 02 00 00 00       	mov    $0x2,%ecx
        uint32_t glyph_id = 0;
   27207:	31 db                	xor    %ebx,%ebx
            uint8_t * p = _lv_utils_bsearch(&key, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length,
   27209:	e8 59 fe ff ff       	callq  27067 <_lv_utils_bsearch>
            if(p) {
   2720e:	48 85 c0             	test   %rax,%rax
   27211:	74 5f                	je     27272 <get_glyph_dsc_id.isra.0.part.1+0x114>
                lv_uintptr_t ofs = (lv_uintptr_t)(p - (uint8_t *) fdsc->cmaps[i].unicode_list);
   27213:	4c 03 65 10          	add    0x10(%rbp),%r12
   27217:	49 2b 44 24 08       	sub    0x8(%r12),%rax
                glyph_id = fdsc->cmaps[i].glyph_id_start + ofs;
   2721c:	41 0f b7 5c 24 06    	movzwl 0x6(%r12),%ebx
                ofs = ofs >> 1;     /*The list stores `uint16_t` so the get the index divide by 2*/
   27222:	48 d1 e8             	shr    %rax
   27225:	eb 49                	jmp    27270 <get_glyph_dsc_id.isra.0.part.1+0x112>
        uint32_t glyph_id = 0;
   27227:	31 db                	xor    %ebx,%ebx
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_FULL) {
   27229:	3c 03                	cmp    $0x3,%al
   2722b:	75 45                	jne    27272 <get_glyph_dsc_id.isra.0.part.1+0x114>
            uint16_t key = rcp;
   2722d:	66 89 54 24 06       	mov    %dx,0x6(%rsp)
            uint8_t * p = _lv_utils_bsearch(&key, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length,
   27232:	0f b7 51 18          	movzwl 0x18(%rcx),%edx
   27236:	48 8d 7c 24 06       	lea    0x6(%rsp),%rdi
   2723b:	48 8b 71 08          	mov    0x8(%rcx),%rsi
   2723f:	4c 8d 05 0f ff ff ff 	lea    -0xf1(%rip),%r8        # 27155 <unicode_list_compare>
   27246:	b9 02 00 00 00       	mov    $0x2,%ecx
   2724b:	e8 17 fe ff ff       	callq  27067 <_lv_utils_bsearch>
            if(p) {
   27250:	48 85 c0             	test   %rax,%rax
   27253:	74 1d                	je     27272 <get_glyph_dsc_id.isra.0.part.1+0x114>
                lv_uintptr_t ofs = (lv_uintptr_t)(p - (uint8_t *) fdsc->cmaps[i].unicode_list);
   27255:	4c 03 65 10          	add    0x10(%rbp),%r12
   27259:	49 2b 44 24 08       	sub    0x8(%r12),%rax
                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];
   2725e:	49 8b 54 24 10       	mov    0x10(%r12),%rdx
                ofs = ofs >> 1;     /*The list stores `uint16_t` so the get the index divide by 2*/
   27263:	48 d1 e8             	shr    %rax
                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];
   27266:	0f b6 1c 02          	movzbl (%rdx,%rax,1),%ebx
   2726a:	41 0f b7 44 24 06    	movzwl 0x6(%r12),%eax
   27270:	01 c3                	add    %eax,%ebx
        fdsc->last_letter = letter;
   27272:	44 89 6d 28          	mov    %r13d,0x28(%rbp)
        fdsc->last_glyph_id = glyph_id;
   27276:	89 5d 2c             	mov    %ebx,0x2c(%rbp)
   27279:	eb 0d                	jmp    27288 <get_glyph_dsc_id.isra.0.part.1+0x12a>
    fdsc->last_letter = letter;
   2727b:	44 89 6d 28          	mov    %r13d,0x28(%rbp)
    fdsc->last_glyph_id = 0;
   2727f:	c7 45 2c 00 00 00 00 	movl   $0x0,0x2c(%rbp)
    return 0;
   27286:	31 db                	xor    %ebx,%ebx
}
   27288:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   2728d:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
   27294:	00 00 
   27296:	89 d8                	mov    %ebx,%eax
   27298:	74 05                	je     2729f <get_glyph_dsc_id.isra.0.part.1+0x141>
   2729a:	e8 a1 d3 fd ff       	callq  4640 <__stack_chk_fail@plt>
   2729f:	48 83 c4 18          	add    $0x18,%rsp
   272a3:	5b                   	pop    %rbx
   272a4:	5d                   	pop    %rbp
   272a5:	41 5c                	pop    %r12
   272a7:	41 5d                	pop    %r13
   272a9:	c3                   	retq   

00000000000272aa <lv_font_get_bitmap_fmt_txt>:
    if(unicode_letter == '\t') unicode_letter = ' ';
   272aa:	83 fe 09             	cmp    $0x9,%esi
   272ad:	74 06                	je     272b5 <lv_font_get_bitmap_fmt_txt+0xb>
    if(letter == '\0') return 0;
   272af:	85 f6                	test   %esi,%esi
   272b1:	74 3d                	je     272f0 <lv_font_get_bitmap_fmt_txt+0x46>
   272b3:	eb 05                	jmp    272ba <lv_font_get_bitmap_fmt_txt+0x10>
    if(unicode_letter == '\t') unicode_letter = ' ';
   272b5:	be 20 00 00 00       	mov    $0x20,%esi
{
   272ba:	53                   	push   %rbx
   272bb:	48 83 c7 18          	add    $0x18,%rdi
   272bf:	48 8b 1f             	mov    (%rdi),%rbx
   272c2:	e8 97 fe ff ff       	callq  2715e <get_glyph_dsc_id.isra.0.part.1>
    if(!gid) return NULL;
   272c7:	85 c0                	test   %eax,%eax
   272c9:	75 04                	jne    272cf <lv_font_get_bitmap_fmt_txt+0x25>
   272cb:	31 c0                	xor    %eax,%eax
   272cd:	eb 1f                	jmp    272ee <lv_font_get_bitmap_fmt_txt+0x44>
        if(gdsc) return &fdsc->glyph_bitmap[gdsc->bitmap_index];
   272cf:	f6 43 24 03          	testb  $0x3,0x24(%rbx)
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
   272d3:	48 8b 53 08          	mov    0x8(%rbx),%rdx
   272d7:	89 c0                	mov    %eax,%eax
   272d9:	48 8d 04 c2          	lea    (%rdx,%rax,8),%rax
        if(gdsc) return &fdsc->glyph_bitmap[gdsc->bitmap_index];
   272dd:	75 ec                	jne    272cb <lv_font_get_bitmap_fmt_txt+0x21>
   272df:	48 85 c0             	test   %rax,%rax
   272e2:	74 e7                	je     272cb <lv_font_get_bitmap_fmt_txt+0x21>
   272e4:	8b 00                	mov    (%rax),%eax
   272e6:	25 ff ff 0f 00       	and    $0xfffff,%eax
   272eb:	48 03 03             	add    (%rbx),%rax
}
   272ee:	5b                   	pop    %rbx
   272ef:	c3                   	retq   
    if(!gid) return NULL;
   272f0:	31 c0                	xor    %eax,%eax
}
   272f2:	c3                   	retq   

00000000000272f3 <lv_font_get_glyph_dsc_fmt_txt>:
{
   272f3:	41 57                	push   %r15
   272f5:	41 56                	push   %r14
   272f7:	49 89 f6             	mov    %rsi,%r14
   272fa:	41 55                	push   %r13
   272fc:	41 54                	push   %r12
   272fe:	49 89 fd             	mov    %rdi,%r13
   27301:	55                   	push   %rbp
   27302:	53                   	push   %rbx
   27303:	48 83 ec 28          	sub    $0x28,%rsp
   27307:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   2730e:	00 00 
   27310:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   27315:	31 c0                	xor    %eax,%eax
    if(unicode_letter == '\t') {
   27317:	83 fa 09             	cmp    $0x9,%edx
   2731a:	74 0b                	je     27327 <lv_font_get_glyph_dsc_fmt_txt+0x34>
    if(letter == '\0') return 0;
   2731c:	85 d2                	test   %edx,%edx
   2731e:	75 10                	jne    27330 <lv_font_get_glyph_dsc_fmt_txt+0x3d>
    if(!gid) return false;
   27320:	31 db                	xor    %ebx,%ebx
   27322:	e9 a7 01 00 00       	jmpq   274ce <lv_font_get_glyph_dsc_fmt_txt+0x1db>
        is_tab = true;
   27327:	b3 01                	mov    $0x1,%bl
        unicode_letter = ' ';
   27329:	ba 20 00 00 00       	mov    $0x20,%edx
   2732e:	eb 02                	jmp    27332 <lv_font_get_glyph_dsc_fmt_txt+0x3f>
    bool is_tab = false;
   27330:	31 db                	xor    %ebx,%ebx
   27332:	4d 8d 7d 18          	lea    0x18(%r13),%r15
   27336:	89 d6                	mov    %edx,%esi
   27338:	89 4c 24 0c          	mov    %ecx,0xc(%rsp)
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
   2733c:	49 8b 6d 18          	mov    0x18(%r13),%rbp
   27340:	4c 89 ff             	mov    %r15,%rdi
   27343:	e8 16 fe ff ff       	callq  2715e <get_glyph_dsc_id.isra.0.part.1>
    if(!gid) return false;
   27348:	85 c0                	test   %eax,%eax
   2734a:	74 d4                	je     27320 <lv_font_get_glyph_dsc_fmt_txt+0x2d>
    if(letter == '\0') return 0;
   2734c:	48 83 7d 18 00       	cmpq   $0x0,0x18(%rbp)
   27351:	41 89 c4             	mov    %eax,%r12d
   27354:	74 08                	je     2735e <lv_font_get_glyph_dsc_fmt_txt+0x6b>
   27356:	8b 4c 24 0c          	mov    0xc(%rsp),%ecx
   2735a:	85 c9                	test   %ecx,%ecx
   2735c:	75 07                	jne    27365 <lv_font_get_glyph_dsc_fmt_txt+0x72>
    int8_t kvalue = 0;
   2735e:	31 d2                	xor    %edx,%edx
   27360:	e9 f9 00 00 00       	jmpq   2745e <lv_font_get_glyph_dsc_fmt_txt+0x16b>
   27365:	89 ce                	mov    %ecx,%esi
   27367:	4c 89 ff             	mov    %r15,%rdi
   2736a:	89 44 24 0c          	mov    %eax,0xc(%rsp)
   2736e:	e8 eb fd ff ff       	callq  2715e <get_glyph_dsc_id.isra.0.part.1>
        if(gid_next) {
   27373:	85 c0                	test   %eax,%eax
   27375:	74 e7                	je     2735e <lv_font_get_glyph_dsc_fmt_txt+0x6b>
            kvalue = get_kern_value(font, gid, gid_next);
   27377:	49 8b 4d 18          	mov    0x18(%r13),%rcx
    if(fdsc->kern_classes == 0) {
   2737b:	f6 41 23 40          	testb  $0x40,0x23(%rcx)
   2737f:	4c 8b 69 18          	mov    0x18(%rcx),%r13
   27383:	0f 85 9a 00 00 00    	jne    27423 <lv_font_get_glyph_dsc_fmt_txt+0x130>
        if(kdsc->glyph_ids_size == 0) {
   27389:	41 8a 4d 13          	mov    0x13(%r13),%cl
   2738d:	8b 54 24 0c          	mov    0xc(%rsp),%edx
   27391:	80 e1 03             	and    $0x3,%cl
   27394:	75 44                	jne    273da <lv_font_get_glyph_dsc_fmt_txt+0xe7>
            uint16_t g_id_both = (gid_right << 8) + gid_left; /*Create one number from the ids*/
   27396:	c1 e0 08             	shl    $0x8,%eax
            const uint8_t * g_ids = kdsc->glyph_ids;
   27399:	4d 8b 7d 00          	mov    0x0(%r13),%r15
            uint8_t * kid_p = _lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);
   2739d:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
            uint16_t g_id_both = (gid_right << 8) + gid_left; /*Create one number from the ids*/
   273a2:	01 d0                	add    %edx,%eax
            uint8_t * kid_p = _lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);
   273a4:	41 8b 55 10          	mov    0x10(%r13),%edx
   273a8:	4c 8d 05 7b fd ff ff 	lea    -0x285(%rip),%r8        # 2712a <kern_pair_8_compare>
   273af:	b9 02 00 00 00       	mov    $0x2,%ecx
            uint16_t g_id_both = (gid_right << 8) + gid_left; /*Create one number from the ids*/
   273b4:	66 89 44 24 10       	mov    %ax,0x10(%rsp)
            uint8_t * kid_p = _lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);
   273b9:	4c 89 fe             	mov    %r15,%rsi
   273bc:	81 e2 ff ff ff 00    	and    $0xffffff,%edx
   273c2:	e8 a0 fc ff ff       	callq  27067 <_lv_utils_bsearch>
    int8_t value = 0;
   273c7:	31 d2                	xor    %edx,%edx
            if(kid_p) {
   273c9:	48 85 c0             	test   %rax,%rax
   273cc:	0f 84 8c 00 00 00    	je     2745e <lv_font_get_glyph_dsc_fmt_txt+0x16b>
                lv_uintptr_t ofs = (lv_uintptr_t)(kid_p - g_ids);
   273d2:	4c 29 f8             	sub    %r15,%rax
                ofs = ofs >> 1;     /*ofs is for pair, divide by 2 to refer as a single value*/
   273d5:	48 d1 e8             	shr    %rax
   273d8:	eb 43                	jmp    2741d <lv_font_get_glyph_dsc_fmt_txt+0x12a>
        else if(kdsc->glyph_ids_size == 1) {
   273da:	fe c9                	dec    %cl
   273dc:	75 80                	jne    2735e <lv_font_get_glyph_dsc_fmt_txt+0x6b>
            lv_uintptr_t g_id_both = (uint32_t)((uint32_t)gid_right << 8) + gid_left; /*Create one number from the ids*/
   273de:	c1 e0 08             	shl    $0x8,%eax
            const uint16_t * g_ids = kdsc->glyph_ids;
   273e1:	4d 8b 7d 00          	mov    0x0(%r13),%r15
            uint8_t * kid_p = _lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);
   273e5:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
            lv_uintptr_t g_id_both = (uint32_t)((uint32_t)gid_right << 8) + gid_left; /*Create one number from the ids*/
   273ea:	01 d0                	add    %edx,%eax
            uint8_t * kid_p = _lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);
   273ec:	41 8b 55 10          	mov    0x10(%r13),%edx
   273f0:	4c 8d 05 48 fd ff ff 	lea    -0x2b8(%rip),%r8        # 2713f <kern_pair_16_compare>
   273f7:	b9 04 00 00 00       	mov    $0x4,%ecx
            lv_uintptr_t g_id_both = (uint32_t)((uint32_t)gid_right << 8) + gid_left; /*Create one number from the ids*/
   273fc:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
            uint8_t * kid_p = _lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);
   27401:	4c 89 fe             	mov    %r15,%rsi
   27404:	81 e2 ff ff ff 00    	and    $0xffffff,%edx
   2740a:	e8 58 fc ff ff       	callq  27067 <_lv_utils_bsearch>
    int8_t value = 0;
   2740f:	31 d2                	xor    %edx,%edx
            if(kid_p) {
   27411:	48 85 c0             	test   %rax,%rax
   27414:	74 48                	je     2745e <lv_font_get_glyph_dsc_fmt_txt+0x16b>
                lv_uintptr_t ofs = (lv_uintptr_t)(kid_p - (const uint8_t *)g_ids);
   27416:	4c 29 f8             	sub    %r15,%rax
                ofs = ofs >> 4;     /*ofs is 4 byte pairs, divide by 4 to refer as a single value*/
   27419:	48 c1 e8 04          	shr    $0x4,%rax
                value = kdsc->values[ofs];
   2741d:	49 8b 55 08          	mov    0x8(%r13),%rdx
   27421:	eb 37                	jmp    2745a <lv_font_get_glyph_dsc_fmt_txt+0x167>
        uint8_t left_class = kdsc->left_class_mapping[gid_left];
   27423:	49 8b 55 08          	mov    0x8(%r13),%rdx
        uint8_t right_class = kdsc->right_class_mapping[gid_right];
   27427:	49 8b 4d 10          	mov    0x10(%r13),%rcx
   2742b:	89 c0                	mov    %eax,%eax
        uint8_t left_class = kdsc->left_class_mapping[gid_left];
   2742d:	42 0f b6 14 22       	movzbl (%rdx,%r12,1),%edx
        uint8_t right_class = kdsc->right_class_mapping[gid_right];
   27432:	0f b6 04 01          	movzbl (%rcx,%rax,1),%eax
        if(left_class > 0 && right_class > 0) {
   27436:	84 d2                	test   %dl,%dl
   27438:	0f 84 20 ff ff ff    	je     2735e <lv_font_get_glyph_dsc_fmt_txt+0x6b>
   2743e:	84 c0                	test   %al,%al
   27440:	0f 84 18 ff ff ff    	je     2735e <lv_font_get_glyph_dsc_fmt_txt+0x6b>
            value = kdsc->class_pair_values[(left_class - 1) * kdsc->right_class_cnt + (right_class - 1)];
   27446:	41 0f b6 4d 19       	movzbl 0x19(%r13),%ecx
   2744b:	ff ca                	dec    %edx
   2744d:	0f af d1             	imul   %ecx,%edx
   27450:	8d 44 02 ff          	lea    -0x1(%rdx,%rax,1),%eax
   27454:	49 8b 55 00          	mov    0x0(%r13),%rdx
   27458:	48 98                	cltq   
   2745a:	0f be 14 02          	movsbl (%rdx,%rax,1),%edx
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
   2745e:	48 8b 45 08          	mov    0x8(%rbp),%rax
   27462:	4a 8d 0c e0          	lea    (%rax,%r12,8),%rcx
    int32_t kv = ((int32_t)((int32_t)kvalue * fdsc->kern_scale) >> 4);
   27466:	0f b7 45 20          	movzwl 0x20(%rbp),%eax
   2746a:	0f af d0             	imul   %eax,%edx
    uint32_t adv_w = gdsc->adv_w;
   2746d:	66 8b 41 02          	mov    0x2(%rcx),%ax
    int32_t kv = ((int32_t)((int32_t)kvalue * fdsc->kern_scale) >> 4);
   27471:	c1 fa 04             	sar    $0x4,%edx
    uint32_t adv_w = gdsc->adv_w;
   27474:	66 c1 e8 04          	shr    $0x4,%ax
    if(is_tab) adv_w *= 2;
   27478:	84 db                	test   %bl,%bl
    uint32_t adv_w = gdsc->adv_w;
   2747a:	0f b7 c0             	movzwl %ax,%eax
    if(is_tab) adv_w *= 2;
   2747d:	74 02                	je     27481 <lv_font_get_glyph_dsc_fmt_txt+0x18e>
   2747f:	01 c0                	add    %eax,%eax
    adv_w  = (adv_w + (1 << 3)) >> 4;
   27481:	8d 44 10 08          	lea    0x8(%rax,%rdx,1),%eax
   27485:	c1 e8 04             	shr    $0x4,%eax
    dsc_out->adv_w = adv_w;
   27488:	66 41 89 06          	mov    %ax,(%r14)
    dsc_out->box_h = gdsc->box_h;
   2748c:	0f b6 41 05          	movzbl 0x5(%rcx),%eax
   27490:	66 41 89 46 04       	mov    %ax,0x4(%r14)
    dsc_out->box_w = gdsc->box_w;
   27495:	0f b6 51 04          	movzbl 0x4(%rcx),%edx
   27499:	66 41 89 56 02       	mov    %dx,0x2(%r14)
    dsc_out->ofs_x = gdsc->ofs_x;
   2749e:	66 0f be 41 06       	movsbw 0x6(%rcx),%ax
   274a3:	66 41 89 46 06       	mov    %ax,0x6(%r14)
    dsc_out->ofs_y = gdsc->ofs_y;
   274a8:	66 0f be 41 07       	movsbw 0x7(%rcx),%ax
   274ad:	66 41 89 46 08       	mov    %ax,0x8(%r14)
    dsc_out->bpp   = (uint8_t)fdsc->bpp;
   274b2:	8a 45 23             	mov    0x23(%rbp),%al
   274b5:	c0 e8 02             	shr    $0x2,%al
   274b8:	83 e0 0f             	and    $0xf,%eax
    if(is_tab) dsc_out->box_w = dsc_out->box_w * 2;
   274bb:	84 db                	test   %bl,%bl
    dsc_out->bpp   = (uint8_t)fdsc->bpp;
   274bd:	41 88 46 0a          	mov    %al,0xa(%r14)
    if(is_tab) dsc_out->box_w = dsc_out->box_w * 2;
   274c1:	74 09                	je     274cc <lv_font_get_glyph_dsc_fmt_txt+0x1d9>
   274c3:	01 d2                	add    %edx,%edx
   274c5:	66 41 89 56 02       	mov    %dx,0x2(%r14)
   274ca:	eb 02                	jmp    274ce <lv_font_get_glyph_dsc_fmt_txt+0x1db>
    return true;
   274cc:	b3 01                	mov    $0x1,%bl
}
   274ce:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
   274d3:	64 48 33 34 25 28 00 	xor    %fs:0x28,%rsi
   274da:	00 00 
   274dc:	88 d8                	mov    %bl,%al
   274de:	74 05                	je     274e5 <lv_font_get_glyph_dsc_fmt_txt+0x1f2>
   274e0:	e8 5b d1 fd ff       	callq  4640 <__stack_chk_fail@plt>
   274e5:	48 83 c4 28          	add    $0x28,%rsp
   274e9:	5b                   	pop    %rbx
   274ea:	5d                   	pop    %rbp
   274eb:	41 5c                	pop    %r12
   274ed:	41 5d                	pop    %r13
   274ef:	41 5e                	pop    %r14
   274f1:	41 5f                	pop    %r15
   274f3:	c3                   	retq   

00000000000274f4 <_lv_font_clean_up_fmt_txt>:
{
   274f4:	53                   	push   %rbx
    if(LV_GC_ROOT(_lv_font_decompr_buf)) {
   274f5:	48 8d 1d ec 0a 23 00 	lea    0x230aec(%rip),%rbx        # 257fe8 <_lv_font_decompr_buf>
   274fc:	48 8b 3b             	mov    (%rbx),%rdi
   274ff:	48 85 ff             	test   %rdi,%rdi
   27502:	74 0c                	je     27510 <_lv_font_clean_up_fmt_txt+0x1c>
        lv_mem_free(LV_GC_ROOT(_lv_font_decompr_buf));
   27504:	e8 fb eb ff ff       	callq  26104 <lv_mem_free>
        LV_GC_ROOT(_lv_font_decompr_buf) = NULL;
   27509:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
}
   27510:	5b                   	pop    %rbx
   27511:	c3                   	retq   

0000000000027512 <apply_theme>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void apply_theme(lv_theme_t * th, lv_obj_t * obj, lv_theme_style_t name)
{
   27512:	41 54                	push   %r12
   27514:	49 89 fc             	mov    %rdi,%r12
   27517:	55                   	push   %rbp
   27518:	53                   	push   %rbx
    if(th->base) {
   27519:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
{
   2751d:	48 89 f3             	mov    %rsi,%rbx
   27520:	89 d5                	mov    %edx,%ebp
    if(th->base) {
   27522:	48 85 ff             	test   %rdi,%rdi
   27525:	74 05                	je     2752c <apply_theme+0x1a>
        apply_theme(th->base, obj, name);
   27527:	e8 e6 ff ff ff       	callq  27512 <apply_theme>
    }

    /*apply_xcb is deprecated, use apply_cb instead*/
    if(th->apply_xcb) {
   2752c:	49 8b 44 24 08       	mov    0x8(%r12),%rax
   27531:	48 85 c0             	test   %rax,%rax
   27534:	74 0b                	je     27541 <apply_theme+0x2f>
        th->apply_xcb(obj, name);
   27536:	89 ee                	mov    %ebp,%esi
   27538:	48 89 df             	mov    %rbx,%rdi
    }
    else if(th->apply_cb) {
        th->apply_cb(act_theme, obj, name);
    }
}
   2753b:	5b                   	pop    %rbx
   2753c:	5d                   	pop    %rbp
   2753d:	41 5c                	pop    %r12
        th->apply_xcb(obj, name);
   2753f:	ff e0                	jmpq   *%rax
    else if(th->apply_cb) {
   27541:	49 8b 04 24          	mov    (%r12),%rax
   27545:	48 85 c0             	test   %rax,%rax
   27548:	74 12                	je     2755c <apply_theme+0x4a>
        th->apply_cb(act_theme, obj, name);
   2754a:	89 ea                	mov    %ebp,%edx
   2754c:	48 89 de             	mov    %rbx,%rsi
   2754f:	48 8b 3d ba 0a 23 00 	mov    0x230aba(%rip),%rdi        # 258010 <act_theme>
}
   27556:	5b                   	pop    %rbx
   27557:	5d                   	pop    %rbp
   27558:	41 5c                	pop    %r12
        th->apply_cb(act_theme, obj, name);
   2755a:	ff e0                	jmpq   *%rax
}
   2755c:	5b                   	pop    %rbx
   2755d:	5d                   	pop    %rbp
   2755e:	41 5c                	pop    %r12
   27560:	c3                   	retq   

0000000000027561 <lv_theme_set_act>:
    act_theme = th;
   27561:	48 89 3d a8 0a 23 00 	mov    %rdi,0x230aa8(%rip)        # 258010 <act_theme>
}
   27568:	c3                   	retq   

0000000000027569 <lv_theme_apply>:
{
   27569:	55                   	push   %rbp

static void clear_styles(lv_obj_t * obj, lv_theme_style_t name)
{
    switch(name) {
   2756a:	8d 46 ff             	lea    -0x1(%rsi),%eax
{
   2756d:	53                   	push   %rbx
   2756e:	89 f5                	mov    %esi,%ebp
   27570:	48 89 fb             	mov    %rdi,%rbx
   27573:	48 83 ec 08          	sub    $0x8,%rsp
    switch(name) {
   27577:	83 f8 05             	cmp    $0x5,%eax
   2757a:	77 07                	ja     27583 <lv_theme_apply+0x1a>
        case LV_THEME_NONE:
            break;

        case LV_THEME_SCR:
            lv_obj_clean_style_list(obj, LV_OBJ_PART_MAIN);
   2757c:	31 f6                	xor    %esi,%esi
   2757e:	e8 ef 34 ff ff       	callq  1aa72 <lv_obj_clean_style_list>
    apply_theme(act_theme, obj, name);
   27583:	89 ea                	mov    %ebp,%edx
   27585:	48 89 de             	mov    %rbx,%rsi
   27588:	48 8b 3d 81 0a 23 00 	mov    0x230a81(%rip),%rdi        # 258010 <act_theme>
}
   2758f:	58                   	pop    %rax
   27590:	5b                   	pop    %rbx
   27591:	5d                   	pop    %rbp
    apply_theme(act_theme, obj, name);
   27592:	e9 7b ff ff ff       	jmpq   27512 <apply_theme>

0000000000027597 <lv_theme_get_font_normal>:
    return act_theme->font_normal;
   27597:	48 8b 05 72 0a 23 00 	mov    0x230a72(%rip),%rax        # 258010 <act_theme>
   2759e:	48 8b 40 28          	mov    0x28(%rax),%rax
}
   275a2:	c3                   	retq   

00000000000275a3 <theme_apply>:
    return &theme;
}


static void theme_apply(lv_theme_t * th, lv_obj_t * obj, lv_theme_style_t name)
{
   275a3:	55                   	push   %rbp
   275a4:	53                   	push   %rbx
    LV_UNUSED(th);

    lv_style_list_t * list;

    switch(name) {
   275a5:	ff ca                	dec    %edx
{
   275a7:	48 89 f3             	mov    %rsi,%rbx
   275aa:	48 83 ec 08          	sub    $0x8,%rsp
    switch(name) {
   275ae:	83 fa 05             	cmp    $0x5,%edx
   275b1:	0f 87 80 00 00 00    	ja     27637 <theme_apply+0x94>
   275b7:	48 8d 0d 4a 98 00 00 	lea    0x984a(%rip),%rcx        # 30e08 <__func__.5785+0x1a0>
            break;
#endif

#if LV_USE_IMG
        case LV_THEME_IMAGE:
            list = lv_obj_get_style_list(obj, LV_IMG_PART_MAIN);
   275be:	31 f6                	xor    %esi,%esi
   275c0:	48 89 df             	mov    %rbx,%rdi
    switch(name) {
   275c3:	48 63 04 91          	movslq (%rcx,%rdx,4),%rax
   275c7:	48 01 c8             	add    %rcx,%rax
   275ca:	ff e0                	jmpq   *%rax
            list = lv_obj_get_style_list(obj, LV_OBJ_PART_MAIN);
   275cc:	e8 3d 34 ff ff       	callq  1aa0e <lv_obj_get_style_list>
            _lv_style_list_add_style(list, &styles->scr);
   275d1:	48 8b 35 40 0a 23 00 	mov    0x230a40(%rip),%rsi        # 258018 <styles>
   275d8:	eb 10                	jmp    275ea <theme_apply+0x47>
            list = lv_obj_get_style_list(obj, LV_OBJ_PART_MAIN);
   275da:	e8 2f 34 ff ff       	callq  1aa0e <lv_obj_get_style_list>
            _lv_style_list_add_style(list, &styles->bg);
   275df:	48 8b 0d 32 0a 23 00 	mov    0x230a32(%rip),%rcx        # 258018 <styles>
   275e6:	48 8d 71 08          	lea    0x8(%rcx),%rsi
   275ea:	48 89 c7             	mov    %rax,%rdi
   275ed:	eb 3c                	jmp    2762b <theme_apply+0x88>
            list = lv_obj_get_style_list(obj, LV_BTN_PART_MAIN);
   275ef:	e8 1a 34 ff ff       	callq  1aa0e <lv_obj_get_style_list>
   275f4:	48 89 c5             	mov    %rax,%rbp
            _lv_style_list_add_style(list, &styles->bg);
   275f7:	48 8b 05 1a 0a 23 00 	mov    0x230a1a(%rip),%rax        # 258018 <styles>
   275fe:	48 89 ef             	mov    %rbp,%rdi
   27601:	48 8d 70 08          	lea    0x8(%rax),%rsi
   27605:	e8 29 6d ff ff       	callq  1e333 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->btn);
   2760a:	48 8b 05 07 0a 23 00 	mov    0x230a07(%rip),%rax        # 258018 <styles>
   27611:	48 89 ef             	mov    %rbp,%rdi
   27614:	48 8d 70 18          	lea    0x18(%rax),%rsi
   27618:	e8 16 6d ff ff       	callq  1e333 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->txt_underline);
   2761d:	48 8b 05 f4 09 23 00 	mov    0x2309f4(%rip),%rax        # 258018 <styles>
   27624:	48 89 ef             	mov    %rbp,%rdi
   27627:	48 8d 70 68          	lea    0x68(%rax),%rsi
   2762b:	e8 03 6d ff ff       	callq  1e333 <_lv_style_list_add_style>
            break;
   27630:	eb 05                	jmp    27637 <theme_apply+0x94>
            list = lv_obj_get_style_list(obj, LV_IMG_PART_MAIN);
   27632:	e8 d7 33 ff ff       	callq  1aa0e <lv_obj_get_style_list>


    lv_obj_refresh_style(obj, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);


}
   27637:	58                   	pop    %rax
    lv_obj_refresh_style(obj, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
   27638:	48 89 df             	mov    %rbx,%rdi
   2763b:	ba ff 00 00 00       	mov    $0xff,%edx
   27640:	be ff 00 00 00       	mov    $0xff,%esi
}
   27645:	5b                   	pop    %rbx
   27646:	5d                   	pop    %rbp
    lv_obj_refresh_style(obj, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
   27647:	e9 98 4a ff ff       	jmpq   1c0e4 <lv_obj_refresh_style>

000000000002764c <style_init_reset>:
 **********************/

static void style_init_reset(lv_style_t * style)
{
    if(inited) lv_style_reset(style);
    else lv_style_init(style);
   2764c:	e9 00 6c ff ff       	jmpq   1e251 <lv_style_init>

0000000000027651 <lv_theme_mono_init>:
{
   27651:	41 55                	push   %r13
   27653:	41 54                	push   %r12
   27655:	41 89 fd             	mov    %edi,%r13d
   27658:	55                   	push   %rbp
   27659:	53                   	push   %rbx
        LV_GC_ROOT(_lv_theme_mono_styles) = lv_mem_alloc(sizeof(theme_styles_t));
   2765a:	bf 70 00 00 00       	mov    $0x70,%edi
{
   2765f:	48 89 cd             	mov    %rcx,%rbp
   27662:	41 89 f4             	mov    %esi,%r12d
   27665:	89 d3                	mov    %edx,%ebx
   27667:	48 83 ec 18          	sub    $0x18,%rsp
   2766b:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
   27670:	4c 89 0c 24          	mov    %r9,(%rsp)
        LV_GC_ROOT(_lv_theme_mono_styles) = lv_mem_alloc(sizeof(theme_styles_t));
   27674:	e8 18 ea ff ff       	callq  26091 <lv_mem_alloc>
   27679:	48 8d 15 70 09 23 00 	lea    0x230970(%rip),%rdx        # 257ff0 <_lv_theme_mono_styles>
    theme.font_normal = font_normal;
   27680:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
    style_init_reset(&styles->scr);
   27685:	48 89 c7             	mov    %rax,%rdi
    theme.font_subtitle = font_subtitle;
   27688:	4c 8b 0c 24          	mov    (%rsp),%r9
        styles = (theme_styles_t *)LV_GC_ROOT(_lv_theme_mono_styles);
   2768c:	48 89 05 85 09 23 00 	mov    %rax,0x230985(%rip)        # 258018 <styles>
    theme.color_primary = color_primary;
   27693:	44 89 2d 1e 03 23 00 	mov    %r13d,0x23031e(%rip)        # 2579b8 <theme+0x18>
    theme.color_secondary = color_secondary;
   2769a:	44 89 25 1b 03 23 00 	mov    %r12d,0x23031b(%rip)        # 2579bc <theme+0x1c>
        LV_GC_ROOT(_lv_theme_mono_styles) = lv_mem_alloc(sizeof(theme_styles_t));
   276a1:	48 89 02             	mov    %rax,(%rdx)
    theme.font_title = font_title;
   276a4:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
    theme.font_normal = font_normal;
   276a9:	4c 89 05 18 03 23 00 	mov    %r8,0x230318(%rip)        # 2579c8 <theme+0x28>
    theme.font_subtitle = font_subtitle;
   276b0:	4c 89 0d 19 03 23 00 	mov    %r9,0x230319(%rip)        # 2579d0 <theme+0x30>
    theme.font_small = font_small;
   276b7:	48 89 2d 02 03 23 00 	mov    %rbp,0x230302(%rip)        # 2579c0 <theme+0x20>
    theme.flags = flags;
   276be:	89 1d 1c 03 23 00    	mov    %ebx,0x23031c(%rip)        # 2579e0 <theme+0x40>
    theme.font_title = font_title;
   276c4:	48 89 15 0d 03 23 00 	mov    %rdx,0x23030d(%rip)        # 2579d8 <theme+0x38>
    style_init_reset(&styles->scr);
   276cb:	e8 7c ff ff ff       	callq  2764c <style_init_reset>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_MAIN_STOP, bg_main_stop, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_STOP, bg_grad_stop, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_DIR, bg_grad_dir, lv_grad_dir_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_COLOR, bg_grad_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
   276d0:	48 8b 3d 41 09 23 00 	mov    0x230941(%rip),%rdi        # 258018 <styles>
   276d7:	ba ff 00 00 00       	mov    $0xff,%edx
   276dc:	be 2c 00 00 00       	mov    $0x2c,%esi
   276e1:	e8 e6 6f ff ff       	callq  1e6cc <_lv_style_set_opa>
    lv_style_set_bg_color(&styles->scr, LV_STATE_DEFAULT, BG_COLOR);
   276e6:	80 3d cd 02 23 00 00 	cmpb   $0x0,0x2302cd(%rip)        # 2579ba <theme+0x1a>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
   276ed:	48 8b 3d 24 09 23 00 	mov    0x230924(%rip),%rdi        # 258018 <styles>
   276f4:	be 29 00 00 00       	mov    $0x29,%esi
   276f9:	0f 94 c2             	sete   %dl
   276fc:	31 c0                	xor    %eax,%eax
   276fe:	f7 da                	neg    %edx
   27700:	88 d0                	mov    %dl,%al
   27702:	88 d4                	mov    %dl,%ah
   27704:	0f b6 d2             	movzbl %dl,%edx
   27707:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   2770c:	89 d1                	mov    %edx,%ecx
   2770e:	c1 e1 10             	shl    $0x10,%ecx
   27711:	89 c2                	mov    %eax,%edx
   27713:	09 ca                	or     %ecx,%edx
   27715:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   2771b:	e8 c0 6e ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_text_color(&styles->scr, LV_STATE_DEFAULT, FG_COLOR);
   27720:	80 3d 93 02 23 00 01 	cmpb   $0x1,0x230293(%rip)        # 2579ba <theme+0x1a>
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_STR, value_str, const char *, _ptr, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_DECOR, text_decor, lv_text_decor_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_BLEND_MODE, text_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
   27727:	48 8b 3d ea 08 23 00 	mov    0x2308ea(%rip),%rdi        # 258018 <styles>
   2772e:	be 89 80 00 00       	mov    $0x8089,%esi
   27733:	19 d2                	sbb    %edx,%edx
   27735:	31 c0                	xor    %eax,%eax
   27737:	f7 d2                	not    %edx
   27739:	88 d0                	mov    %dl,%al
   2773b:	88 d4                	mov    %dl,%ah
   2773d:	0f b6 d2             	movzbl %dl,%edx
   27740:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27745:	89 d1                	mov    %edx,%ecx
   27747:	c1 e1 10             	shl    $0x10,%ecx
   2774a:	89 c2                	mov    %eax,%edx
   2774c:	09 ca                	or     %ecx,%edx
   2774e:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27754:	e8 87 6e ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_value_color(&styles->scr, LV_STATE_DEFAULT, FG_COLOR);
   27759:	80 3d 5a 02 23 00 01 	cmpb   $0x1,0x23025a(%rip)        # 2579ba <theme+0x1a>
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_COLOR, value_color, lv_color_t, _color, nonscalar)
   27760:	48 8b 3d b1 08 23 00 	mov    0x2308b1(%rip),%rdi        # 258018 <styles>
   27767:	be 79 00 00 00       	mov    $0x79,%esi
   2776c:	19 d2                	sbb    %edx,%edx
   2776e:	31 c0                	xor    %eax,%eax
   27770:	f7 d2                	not    %edx
   27772:	88 d0                	mov    %dl,%al
   27774:	88 d4                	mov    %dl,%ah
   27776:	0f b6 d2             	movzbl %dl,%edx
   27779:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   2777e:	89 d1                	mov    %edx,%ecx
   27780:	c1 e1 10             	shl    $0x10,%ecx
   27783:	89 c2                	mov    %eax,%edx
   27785:	09 ca                	or     %ecx,%edx
   27787:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   2778d:	e8 4e 6e ff ff       	callq  1e5e0 <_lv_style_set_color>
    style_init_reset(&styles->bg);
   27792:	48 8b 05 7f 08 23 00 	mov    0x23087f(%rip),%rax        # 258018 <styles>
   27799:	48 8d 78 08          	lea    0x8(%rax),%rdi
   2779d:	e8 aa fe ff ff       	callq  2764c <style_init_reset>
    lv_style_set_border_post(&styles->bg, LV_STATE_DEFAULT, true);
   277a2:	48 8b 05 6f 08 23 00 	mov    0x23086f(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_POST, border_post, bool, _int, scalar)
   277a9:	ba 01 00 00 00       	mov    $0x1,%edx
   277ae:	be 33 00 00 00       	mov    $0x33,%esi
   277b3:	48 8d 78 08          	lea    0x8(%rax),%rdi
   277b7:	e8 3c 6d ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_radius(&styles->bg, LV_STATE_DEFAULT, RADIUS);
   277bc:	48 8b 05 55 08 23 00 	mov    0x230855(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
   277c3:	ba 04 00 00 00       	mov    $0x4,%edx
   277c8:	be 01 00 00 00       	mov    $0x1,%esi
   277cd:	48 8d 78 08          	lea    0x8(%rax),%rdi
   277d1:	e8 22 6d ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_bg_opa(&styles->bg, LV_STATE_DEFAULT, LV_OPA_COVER);
   277d6:	48 8b 05 3b 08 23 00 	mov    0x23083b(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
   277dd:	ba ff 00 00 00       	mov    $0xff,%edx
   277e2:	be 2c 00 00 00       	mov    $0x2c,%esi
   277e7:	48 8d 78 08          	lea    0x8(%rax),%rdi
   277eb:	e8 dc 6e ff ff       	callq  1e6cc <_lv_style_set_opa>
    lv_style_set_bg_color(&styles->bg, LV_STATE_DEFAULT, BG_COLOR);
   277f0:	80 3d c3 01 23 00 00 	cmpb   $0x0,0x2301c3(%rip)        # 2579ba <theme+0x1a>
   277f7:	48 8b 05 1a 08 23 00 	mov    0x23081a(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
   277fe:	be 29 00 00 00       	mov    $0x29,%esi
   27803:	48 8d 78 08          	lea    0x8(%rax),%rdi
   27807:	0f 94 c2             	sete   %dl
   2780a:	31 c0                	xor    %eax,%eax
   2780c:	f7 da                	neg    %edx
   2780e:	88 d0                	mov    %dl,%al
   27810:	88 d4                	mov    %dl,%ah
   27812:	0f b6 d2             	movzbl %dl,%edx
   27815:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   2781a:	89 d1                	mov    %edx,%ecx
   2781c:	c1 e1 10             	shl    $0x10,%ecx
   2781f:	89 c2                	mov    %eax,%edx
   27821:	09 ca                	or     %ecx,%edx
   27823:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27829:	e8 b2 6d ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_border_width(&styles->bg, LV_STATE_DEFAULT, BORDER_WIDTH);
   2782e:	48 8b 05 e3 07 23 00 	mov    0x2307e3(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_WIDTH, border_width, lv_style_int_t, _int, scalar)
   27835:	ba 02 00 00 00       	mov    $0x2,%edx
   2783a:	be 30 00 00 00       	mov    $0x30,%esi
   2783f:	48 8d 78 08          	lea    0x8(%rax),%rdi
   27843:	e8 b0 6c ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_border_width(&styles->bg, LV_STATE_FOCUSED, BORDER_WIDTH * 2);
   27848:	48 8b 05 c9 07 23 00 	mov    0x2307c9(%rip),%rax        # 258018 <styles>
   2784f:	ba 04 00 00 00       	mov    $0x4,%edx
   27854:	be 30 02 00 00       	mov    $0x230,%esi
   27859:	48 8d 78 08          	lea    0x8(%rax),%rdi
   2785d:	e8 96 6c ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_border_width(&styles->bg, LV_STATE_FOCUSED | LV_STATE_EDITED, BORDER_WIDTH * 3);
   27862:	48 8b 05 af 07 23 00 	mov    0x2307af(%rip),%rax        # 258018 <styles>
   27869:	ba 06 00 00 00       	mov    $0x6,%edx
   2786e:	be 30 06 00 00       	mov    $0x630,%esi
   27873:	48 8d 78 08          	lea    0x8(%rax),%rdi
   27877:	e8 7c 6c ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_border_color(&styles->bg, LV_STATE_DEFAULT, FG_COLOR);
   2787c:	80 3d 37 01 23 00 01 	cmpb   $0x1,0x230137(%rip)        # 2579ba <theme+0x1a>
   27883:	48 8b 05 8e 07 23 00 	mov    0x23078e(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_COLOR, border_color, lv_color_t, _color, nonscalar)
   2788a:	be 39 00 00 00       	mov    $0x39,%esi
   2788f:	48 8d 78 08          	lea    0x8(%rax),%rdi
   27893:	19 d2                	sbb    %edx,%edx
   27895:	31 c0                	xor    %eax,%eax
   27897:	f7 d2                	not    %edx
   27899:	88 d0                	mov    %dl,%al
   2789b:	88 d4                	mov    %dl,%ah
   2789d:	0f b6 d2             	movzbl %dl,%edx
   278a0:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   278a5:	89 d1                	mov    %edx,%ecx
   278a7:	c1 e1 10             	shl    $0x10,%ecx
   278aa:	89 c2                	mov    %eax,%edx
   278ac:	09 ca                	or     %ecx,%edx
   278ae:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   278b4:	e8 27 6d ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_line_width(&styles->bg, LV_STATE_DEFAULT, LV_MATH_MAX(LV_DPI / 100, 1));
   278b9:	48 8b 05 58 07 23 00 	mov    0x230758(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_SEL_COLOR, text_sel_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_OPA, text_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_WIDTH, line_width, lv_style_int_t, _int, scalar)
   278c0:	ba 01 00 00 00       	mov    $0x1,%edx
   278c5:	be 90 00 00 00       	mov    $0x90,%esi
   278ca:	48 8d 78 08          	lea    0x8(%rax),%rdi
   278ce:	e8 25 6c ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_scale_end_line_width(&styles->bg, LV_STATE_DEFAULT, LV_MATH_MAX(LV_DPI / 100, 1));
   278d3:	48 8b 05 3e 07 23 00 	mov    0x23073e(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PATH, transition_path, const void *, _ptr, scalar)
#endif
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_WIDTH, scale_width, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_BORDER_WIDTH, scale_border_width, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_END_BORDER_WIDTH, scale_end_border_width, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_END_LINE_WIDTH, scale_end_line_width, lv_style_int_t, _int, scalar)
   278da:	ba 01 00 00 00       	mov    $0x1,%edx
   278df:	be c3 00 00 00       	mov    $0xc3,%esi
   278e4:	48 8d 78 08          	lea    0x8(%rax),%rdi
   278e8:	e8 0b 6c ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_line_color(&styles->bg, LV_STATE_DEFAULT, FG_COLOR);
   278ed:	80 3d c6 00 23 00 01 	cmpb   $0x1,0x2300c6(%rip)        # 2579ba <theme+0x1a>
   278f4:	48 8b 05 1d 07 23 00 	mov    0x23071d(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_COLOR, line_color, lv_color_t, _color, nonscalar)
   278fb:	be 99 00 00 00       	mov    $0x99,%esi
   27900:	48 8d 78 08          	lea    0x8(%rax),%rdi
   27904:	19 d2                	sbb    %edx,%edx
   27906:	31 c0                	xor    %eax,%eax
   27908:	f7 d2                	not    %edx
   2790a:	88 d0                	mov    %dl,%al
   2790c:	88 d4                	mov    %dl,%ah
   2790e:	0f b6 d2             	movzbl %dl,%edx
   27911:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27916:	89 d1                	mov    %edx,%ecx
   27918:	c1 e1 10             	shl    $0x10,%ecx
   2791b:	89 c2                	mov    %eax,%edx
   2791d:	09 ca                	or     %ecx,%edx
   2791f:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27925:	e8 b6 6c ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_scale_grad_color(&styles->bg, LV_STATE_DEFAULT, FG_COLOR);
   2792a:	80 3d 89 00 23 00 01 	cmpb   $0x1,0x230089(%rip)        # 2579ba <theme+0x1a>
   27931:	48 8b 05 e0 06 23 00 	mov    0x2306e0(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_GRAD_COLOR, scale_grad_color, lv_color_t, _color, nonscalar)
   27938:	be c9 00 00 00       	mov    $0xc9,%esi
   2793d:	48 8d 78 08          	lea    0x8(%rax),%rdi
   27941:	19 d2                	sbb    %edx,%edx
   27943:	31 c0                	xor    %eax,%eax
   27945:	f7 d2                	not    %edx
   27947:	88 d0                	mov    %dl,%al
   27949:	88 d4                	mov    %dl,%ah
   2794b:	0f b6 d2             	movzbl %dl,%edx
   2794e:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27953:	89 d1                	mov    %edx,%ecx
   27955:	c1 e1 10             	shl    $0x10,%ecx
   27958:	89 c2                	mov    %eax,%edx
   2795a:	09 ca                	or     %ecx,%edx
   2795c:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27962:	e8 79 6c ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_scale_end_color(&styles->bg, LV_STATE_DEFAULT, FG_COLOR);
   27967:	80 3d 4c 00 23 00 01 	cmpb   $0x1,0x23004c(%rip)        # 2579ba <theme+0x1a>
   2796e:	48 8b 05 a3 06 23 00 	mov    0x2306a3(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_END_COLOR, scale_end_color, lv_color_t, _color, nonscalar)
   27975:	be ca 00 00 00       	mov    $0xca,%esi
   2797a:	48 8d 78 08          	lea    0x8(%rax),%rdi
   2797e:	19 d2                	sbb    %edx,%edx
   27980:	31 c0                	xor    %eax,%eax
   27982:	f7 d2                	not    %edx
   27984:	88 d0                	mov    %dl,%al
   27986:	88 d4                	mov    %dl,%ah
   27988:	0f b6 d2             	movzbl %dl,%edx
   2798b:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27990:	89 d1                	mov    %edx,%ecx
   27992:	c1 e1 10             	shl    $0x10,%ecx
   27995:	89 c2                	mov    %eax,%edx
   27997:	09 ca                	or     %ecx,%edx
   27999:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   2799f:	e8 3c 6c ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_text_color(&styles->bg, LV_STATE_DEFAULT, FG_COLOR);
   279a4:	80 3d 0f 00 23 00 01 	cmpb   $0x1,0x23000f(%rip)        # 2579ba <theme+0x1a>
   279ab:	48 8b 05 66 06 23 00 	mov    0x230666(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
   279b2:	be 89 80 00 00       	mov    $0x8089,%esi
   279b7:	48 8d 78 08          	lea    0x8(%rax),%rdi
   279bb:	19 d2                	sbb    %edx,%edx
   279bd:	31 c0                	xor    %eax,%eax
   279bf:	f7 d2                	not    %edx
   279c1:	88 d0                	mov    %dl,%al
   279c3:	88 d4                	mov    %dl,%ah
   279c5:	0f b6 d2             	movzbl %dl,%edx
   279c8:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   279cd:	89 d1                	mov    %edx,%ecx
   279cf:	c1 e1 10             	shl    $0x10,%ecx
   279d2:	89 c2                	mov    %eax,%edx
   279d4:	09 ca                	or     %ecx,%edx
   279d6:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   279dc:	e8 ff 6b ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_value_color(&styles->bg, LV_STATE_DEFAULT, FG_COLOR);
   279e1:	80 3d d2 ff 22 00 01 	cmpb   $0x1,0x22ffd2(%rip)        # 2579ba <theme+0x1a>
   279e8:	48 8b 05 29 06 23 00 	mov    0x230629(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_COLOR, value_color, lv_color_t, _color, nonscalar)
   279ef:	be 79 00 00 00       	mov    $0x79,%esi
   279f4:	48 8d 78 08          	lea    0x8(%rax),%rdi
   279f8:	19 d2                	sbb    %edx,%edx
   279fa:	31 c0                	xor    %eax,%eax
   279fc:	f7 d2                	not    %edx
   279fe:	88 d0                	mov    %dl,%al
   27a00:	88 d4                	mov    %dl,%ah
   27a02:	0f b6 d2             	movzbl %dl,%edx
   27a05:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27a0a:	89 d1                	mov    %edx,%ecx
   27a0c:	c1 e1 10             	shl    $0x10,%ecx
   27a0f:	89 c2                	mov    %eax,%edx
   27a11:	09 ca                	or     %ecx,%edx
   27a13:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27a19:	e8 c2 6b ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_pad_left(&styles->bg, LV_STATE_DEFAULT, LV_DPI / 10);
   27a1e:	48 8b 05 f3 05 23 00 	mov    0x2305f3(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   27a25:	ba 0d 00 00 00       	mov    $0xd,%edx
   27a2a:	be 12 00 00 00       	mov    $0x12,%esi
   27a2f:	48 8d 78 08          	lea    0x8(%rax),%rdi
   27a33:	e8 c0 6a ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_pad_right(&styles->bg, LV_STATE_DEFAULT, LV_DPI / 10);
   27a38:	48 8b 05 d9 05 23 00 	mov    0x2305d9(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   27a3f:	ba 0d 00 00 00       	mov    $0xd,%edx
   27a44:	be 13 00 00 00       	mov    $0x13,%esi
   27a49:	48 8d 78 08          	lea    0x8(%rax),%rdi
   27a4d:	e8 a6 6a ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_pad_top(&styles->bg, LV_STATE_DEFAULT, LV_DPI / 10);
   27a52:	48 8b 05 bf 05 23 00 	mov    0x2305bf(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   27a59:	ba 0d 00 00 00       	mov    $0xd,%edx
   27a5e:	be 10 00 00 00       	mov    $0x10,%esi
   27a63:	48 8d 78 08          	lea    0x8(%rax),%rdi
   27a67:	e8 8c 6a ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_pad_bottom(&styles->bg, LV_STATE_DEFAULT, LV_DPI / 10);
   27a6c:	48 8b 05 a5 05 23 00 	mov    0x2305a5(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   27a73:	ba 0d 00 00 00       	mov    $0xd,%edx
   27a78:	be 11 00 00 00       	mov    $0x11,%esi
   27a7d:	48 8d 78 08          	lea    0x8(%rax),%rdi
   27a81:	e8 72 6a ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_pad_inner(&styles->bg, LV_STATE_DEFAULT, LV_DPI / 10);
   27a86:	48 8b 05 8b 05 23 00 	mov    0x23058b(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   27a8d:	ba 0d 00 00 00       	mov    $0xd,%edx
   27a92:	be 14 00 00 00       	mov    $0x14,%esi
   27a97:	48 8d 78 08          	lea    0x8(%rax),%rdi
   27a9b:	e8 58 6a ff ff       	callq  1e4f8 <_lv_style_set_int>
    style_init_reset(&styles->clip_corner);
   27aa0:	48 8b 05 71 05 23 00 	mov    0x230571(%rip),%rax        # 258018 <styles>
   27aa7:	48 8d 78 10          	lea    0x10(%rax),%rdi
   27aab:	e8 9c fb ff ff       	callq  2764c <style_init_reset>
    lv_style_set_clip_corner(&styles->clip_corner, LV_STATE_DEFAULT, true);
   27ab0:	48 8b 05 61 05 23 00 	mov    0x230561(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(CLIP_CORNER, clip_corner, bool, _int, scalar)
   27ab7:	ba 01 00 00 00       	mov    $0x1,%edx
   27abc:	be 02 00 00 00       	mov    $0x2,%esi
   27ac1:	48 8d 78 10          	lea    0x10(%rax),%rdi
   27ac5:	e8 2e 6a ff ff       	callq  1e4f8 <_lv_style_set_int>
    style_init_reset(&styles->btn);
   27aca:	48 8b 05 47 05 23 00 	mov    0x230547(%rip),%rax        # 258018 <styles>
   27ad1:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27ad5:	e8 72 fb ff ff       	callq  2764c <style_init_reset>
    lv_style_set_radius(&styles->btn, LV_STATE_DEFAULT, RADIUS);
   27ada:	48 8b 05 37 05 23 00 	mov    0x230537(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
   27ae1:	ba 04 00 00 00       	mov    $0x4,%edx
   27ae6:	be 01 00 00 00       	mov    $0x1,%esi
   27aeb:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27aef:	e8 04 6a ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_border_width(&styles->btn, LV_STATE_DEFAULT, BORDER_WIDTH);
   27af4:	48 8b 05 1d 05 23 00 	mov    0x23051d(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_WIDTH, border_width, lv_style_int_t, _int, scalar)
   27afb:	ba 02 00 00 00       	mov    $0x2,%edx
   27b00:	be 30 00 00 00       	mov    $0x30,%esi
   27b05:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27b09:	e8 ea 69 ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_border_width(&styles->btn, LV_STATE_FOCUSED, BORDER_WIDTH + 1);
   27b0e:	48 8b 05 03 05 23 00 	mov    0x230503(%rip),%rax        # 258018 <styles>
   27b15:	ba 03 00 00 00       	mov    $0x3,%edx
   27b1a:	be 30 02 00 00       	mov    $0x230,%esi
   27b1f:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27b23:	e8 d0 69 ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_border_width(&styles->btn, LV_STATE_FOCUSED | LV_STATE_EDITED, BORDER_WIDTH + 2);
   27b28:	48 8b 05 e9 04 23 00 	mov    0x2304e9(%rip),%rax        # 258018 <styles>
   27b2f:	ba 04 00 00 00       	mov    $0x4,%edx
   27b34:	be 30 06 00 00       	mov    $0x630,%esi
   27b39:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27b3d:	e8 b6 69 ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_border_color(&styles->btn, LV_STATE_DEFAULT, FG_COLOR);
   27b42:	80 3d 71 fe 22 00 00 	cmpb   $0x0,0x22fe71(%rip)        # 2579ba <theme+0x1a>
   27b49:	48 8b 05 c8 04 23 00 	mov    0x2304c8(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_COLOR, border_color, lv_color_t, _color, nonscalar)
   27b50:	be 39 00 00 00       	mov    $0x39,%esi
   27b55:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27b59:	0f 95 c2             	setne  %dl
   27b5c:	31 c0                	xor    %eax,%eax
   27b5e:	f7 da                	neg    %edx
   27b60:	88 d0                	mov    %dl,%al
   27b62:	88 d4                	mov    %dl,%ah
   27b64:	0f b6 d2             	movzbl %dl,%edx
   27b67:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27b6c:	89 d1                	mov    %edx,%ecx
   27b6e:	c1 e1 10             	shl    $0x10,%ecx
   27b71:	89 c2                	mov    %eax,%edx
   27b73:	09 ca                	or     %ecx,%edx
   27b75:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27b7b:	e8 60 6a ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_bg_color(&styles->btn, LV_STATE_DEFAULT, BG_COLOR);
   27b80:	80 3d 33 fe 22 00 00 	cmpb   $0x0,0x22fe33(%rip)        # 2579ba <theme+0x1a>
   27b87:	48 8b 05 8a 04 23 00 	mov    0x23048a(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
   27b8e:	be 29 00 00 00       	mov    $0x29,%esi
   27b93:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27b97:	0f 94 c2             	sete   %dl
   27b9a:	31 c0                	xor    %eax,%eax
   27b9c:	f7 da                	neg    %edx
   27b9e:	88 d0                	mov    %dl,%al
   27ba0:	88 d4                	mov    %dl,%ah
   27ba2:	0f b6 d2             	movzbl %dl,%edx
   27ba5:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27baa:	89 d1                	mov    %edx,%ecx
   27bac:	c1 e1 10             	shl    $0x10,%ecx
   27baf:	89 c2                	mov    %eax,%edx
   27bb1:	09 ca                	or     %ecx,%edx
   27bb3:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27bb9:	e8 22 6a ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_bg_color(&styles->btn, LV_STATE_PRESSED, FG_COLOR);
   27bbe:	80 3d f5 fd 22 00 00 	cmpb   $0x0,0x22fdf5(%rip)        # 2579ba <theme+0x1a>
   27bc5:	48 8b 05 4c 04 23 00 	mov    0x23044c(%rip),%rax        # 258018 <styles>
   27bcc:	be 29 10 00 00       	mov    $0x1029,%esi
   27bd1:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27bd5:	0f 95 c2             	setne  %dl
   27bd8:	31 c0                	xor    %eax,%eax
   27bda:	f7 da                	neg    %edx
   27bdc:	88 d0                	mov    %dl,%al
   27bde:	88 d4                	mov    %dl,%ah
   27be0:	0f b6 d2             	movzbl %dl,%edx
   27be3:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27be8:	89 d1                	mov    %edx,%ecx
   27bea:	c1 e1 10             	shl    $0x10,%ecx
   27bed:	89 c2                	mov    %eax,%edx
   27bef:	09 ca                	or     %ecx,%edx
   27bf1:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27bf7:	e8 e4 69 ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_bg_color(&styles->btn, LV_STATE_CHECKED, FG_COLOR);
   27bfc:	80 3d b7 fd 22 00 00 	cmpb   $0x0,0x22fdb7(%rip)        # 2579ba <theme+0x1a>
   27c03:	48 8b 05 0e 04 23 00 	mov    0x23040e(%rip),%rax        # 258018 <styles>
   27c0a:	be 29 01 00 00       	mov    $0x129,%esi
   27c0f:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27c13:	0f 95 c2             	setne  %dl
   27c16:	31 c0                	xor    %eax,%eax
   27c18:	f7 da                	neg    %edx
   27c1a:	88 d0                	mov    %dl,%al
   27c1c:	88 d4                	mov    %dl,%ah
   27c1e:	0f b6 d2             	movzbl %dl,%edx
   27c21:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27c26:	89 d1                	mov    %edx,%ecx
   27c28:	c1 e1 10             	shl    $0x10,%ecx
   27c2b:	89 c2                	mov    %eax,%edx
   27c2d:	09 ca                	or     %ecx,%edx
   27c2f:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27c35:	e8 a6 69 ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_bg_color(&styles->btn, LV_STATE_CHECKED | LV_STATE_PRESSED, BG_COLOR);
   27c3a:	80 3d 79 fd 22 00 00 	cmpb   $0x0,0x22fd79(%rip)        # 2579ba <theme+0x1a>
   27c41:	48 8b 05 d0 03 23 00 	mov    0x2303d0(%rip),%rax        # 258018 <styles>
   27c48:	be 29 11 00 00       	mov    $0x1129,%esi
   27c4d:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27c51:	0f 94 c2             	sete   %dl
   27c54:	31 c0                	xor    %eax,%eax
   27c56:	f7 da                	neg    %edx
   27c58:	88 d0                	mov    %dl,%al
   27c5a:	88 d4                	mov    %dl,%ah
   27c5c:	0f b6 d2             	movzbl %dl,%edx
   27c5f:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27c64:	89 d1                	mov    %edx,%ecx
   27c66:	c1 e1 10             	shl    $0x10,%ecx
   27c69:	89 c2                	mov    %eax,%edx
   27c6b:	09 ca                	or     %ecx,%edx
   27c6d:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27c73:	e8 68 69 ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_text_color(&styles->btn, LV_STATE_DEFAULT, FG_COLOR);
   27c78:	80 3d 3b fd 22 00 00 	cmpb   $0x0,0x22fd3b(%rip)        # 2579ba <theme+0x1a>
   27c7f:	48 8b 05 92 03 23 00 	mov    0x230392(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
   27c86:	be 89 80 00 00       	mov    $0x8089,%esi
   27c8b:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27c8f:	0f 95 c2             	setne  %dl
   27c92:	31 c0                	xor    %eax,%eax
   27c94:	f7 da                	neg    %edx
   27c96:	88 d0                	mov    %dl,%al
   27c98:	88 d4                	mov    %dl,%ah
   27c9a:	0f b6 d2             	movzbl %dl,%edx
   27c9d:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27ca2:	89 d1                	mov    %edx,%ecx
   27ca4:	c1 e1 10             	shl    $0x10,%ecx
   27ca7:	89 c2                	mov    %eax,%edx
   27ca9:	09 ca                	or     %ecx,%edx
   27cab:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27cb1:	e8 2a 69 ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_text_color(&styles->btn, LV_STATE_PRESSED, BG_COLOR);
   27cb6:	80 3d fd fc 22 00 00 	cmpb   $0x0,0x22fcfd(%rip)        # 2579ba <theme+0x1a>
   27cbd:	48 8b 05 54 03 23 00 	mov    0x230354(%rip),%rax        # 258018 <styles>
   27cc4:	be 89 90 00 00       	mov    $0x9089,%esi
   27cc9:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27ccd:	0f 94 c2             	sete   %dl
   27cd0:	31 c0                	xor    %eax,%eax
   27cd2:	f7 da                	neg    %edx
   27cd4:	88 d0                	mov    %dl,%al
   27cd6:	88 d4                	mov    %dl,%ah
   27cd8:	0f b6 d2             	movzbl %dl,%edx
   27cdb:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27ce0:	89 d1                	mov    %edx,%ecx
   27ce2:	c1 e1 10             	shl    $0x10,%ecx
   27ce5:	89 c2                	mov    %eax,%edx
   27ce7:	09 ca                	or     %ecx,%edx
   27ce9:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27cef:	e8 ec 68 ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_text_color(&styles->btn, LV_STATE_CHECKED, BG_COLOR);
   27cf4:	80 3d bf fc 22 00 00 	cmpb   $0x0,0x22fcbf(%rip)        # 2579ba <theme+0x1a>
   27cfb:	48 8b 05 16 03 23 00 	mov    0x230316(%rip),%rax        # 258018 <styles>
   27d02:	be 89 81 00 00       	mov    $0x8189,%esi
   27d07:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27d0b:	0f 94 c2             	sete   %dl
   27d0e:	31 c0                	xor    %eax,%eax
   27d10:	f7 da                	neg    %edx
   27d12:	88 d0                	mov    %dl,%al
   27d14:	88 d4                	mov    %dl,%ah
   27d16:	0f b6 d2             	movzbl %dl,%edx
   27d19:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27d1e:	89 d1                	mov    %edx,%ecx
   27d20:	c1 e1 10             	shl    $0x10,%ecx
   27d23:	89 c2                	mov    %eax,%edx
   27d25:	09 ca                	or     %ecx,%edx
   27d27:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27d2d:	e8 ae 68 ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_text_color(&styles->btn, LV_STATE_CHECKED | LV_STATE_PRESSED, FG_COLOR);
   27d32:	80 3d 81 fc 22 00 00 	cmpb   $0x0,0x22fc81(%rip)        # 2579ba <theme+0x1a>
   27d39:	48 8b 05 d8 02 23 00 	mov    0x2302d8(%rip),%rax        # 258018 <styles>
   27d40:	be 89 91 00 00       	mov    $0x9189,%esi
   27d45:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27d49:	0f 95 c2             	setne  %dl
   27d4c:	31 c0                	xor    %eax,%eax
   27d4e:	f7 da                	neg    %edx
   27d50:	88 d0                	mov    %dl,%al
   27d52:	88 d4                	mov    %dl,%ah
   27d54:	0f b6 d2             	movzbl %dl,%edx
   27d57:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27d5c:	89 d1                	mov    %edx,%ecx
   27d5e:	c1 e1 10             	shl    $0x10,%ecx
   27d61:	89 c2                	mov    %eax,%edx
   27d63:	09 ca                	or     %ecx,%edx
   27d65:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27d6b:	e8 70 68 ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_value_color(&styles->btn, LV_STATE_DEFAULT, FG_COLOR);
   27d70:	80 3d 43 fc 22 00 00 	cmpb   $0x0,0x22fc43(%rip)        # 2579ba <theme+0x1a>
   27d77:	48 8b 05 9a 02 23 00 	mov    0x23029a(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_COLOR, value_color, lv_color_t, _color, nonscalar)
   27d7e:	be 79 00 00 00       	mov    $0x79,%esi
   27d83:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27d87:	0f 95 c2             	setne  %dl
   27d8a:	31 c0                	xor    %eax,%eax
   27d8c:	f7 da                	neg    %edx
   27d8e:	88 d0                	mov    %dl,%al
   27d90:	88 d4                	mov    %dl,%ah
   27d92:	0f b6 d2             	movzbl %dl,%edx
   27d95:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27d9a:	89 d1                	mov    %edx,%ecx
   27d9c:	c1 e1 10             	shl    $0x10,%ecx
   27d9f:	89 c2                	mov    %eax,%edx
   27da1:	09 ca                	or     %ecx,%edx
   27da3:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27da9:	e8 32 68 ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_value_color(&styles->btn, LV_STATE_PRESSED, BG_COLOR);
   27dae:	80 3d 05 fc 22 00 00 	cmpb   $0x0,0x22fc05(%rip)        # 2579ba <theme+0x1a>
   27db5:	48 8b 05 5c 02 23 00 	mov    0x23025c(%rip),%rax        # 258018 <styles>
   27dbc:	be 79 10 00 00       	mov    $0x1079,%esi
   27dc1:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27dc5:	0f 94 c2             	sete   %dl
   27dc8:	31 c0                	xor    %eax,%eax
   27dca:	f7 da                	neg    %edx
   27dcc:	88 d0                	mov    %dl,%al
   27dce:	88 d4                	mov    %dl,%ah
   27dd0:	0f b6 d2             	movzbl %dl,%edx
   27dd3:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27dd8:	89 d1                	mov    %edx,%ecx
   27dda:	c1 e1 10             	shl    $0x10,%ecx
   27ddd:	89 c2                	mov    %eax,%edx
   27ddf:	09 ca                	or     %ecx,%edx
   27de1:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27de7:	e8 f4 67 ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_value_color(&styles->btn, LV_STATE_CHECKED, BG_COLOR);
   27dec:	80 3d c7 fb 22 00 00 	cmpb   $0x0,0x22fbc7(%rip)        # 2579ba <theme+0x1a>
   27df3:	48 8b 05 1e 02 23 00 	mov    0x23021e(%rip),%rax        # 258018 <styles>
   27dfa:	be 79 01 00 00       	mov    $0x179,%esi
   27dff:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27e03:	0f 94 c2             	sete   %dl
   27e06:	31 c0                	xor    %eax,%eax
   27e08:	f7 da                	neg    %edx
   27e0a:	88 d0                	mov    %dl,%al
   27e0c:	88 d4                	mov    %dl,%ah
   27e0e:	0f b6 d2             	movzbl %dl,%edx
   27e11:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27e16:	89 d1                	mov    %edx,%ecx
   27e18:	c1 e1 10             	shl    $0x10,%ecx
   27e1b:	89 c2                	mov    %eax,%edx
   27e1d:	09 ca                	or     %ecx,%edx
   27e1f:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27e25:	e8 b6 67 ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_value_color(&styles->btn, LV_STATE_CHECKED | LV_STATE_PRESSED, FG_COLOR);
   27e2a:	80 3d 89 fb 22 00 00 	cmpb   $0x0,0x22fb89(%rip)        # 2579ba <theme+0x1a>
   27e31:	48 8b 05 e0 01 23 00 	mov    0x2301e0(%rip),%rax        # 258018 <styles>
   27e38:	be 79 11 00 00       	mov    $0x1179,%esi
   27e3d:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27e41:	0f 95 c2             	setne  %dl
   27e44:	31 c0                	xor    %eax,%eax
   27e46:	f7 da                	neg    %edx
   27e48:	88 d0                	mov    %dl,%al
   27e4a:	88 d4                	mov    %dl,%ah
   27e4c:	0f b6 d2             	movzbl %dl,%edx
   27e4f:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27e54:	89 d1                	mov    %edx,%ecx
   27e56:	c1 e1 10             	shl    $0x10,%ecx
   27e59:	89 c2                	mov    %eax,%edx
   27e5b:	09 ca                	or     %ecx,%edx
   27e5d:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27e63:	e8 78 67 ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_image_recolor(&styles->btn, LV_STATE_DEFAULT, FG_COLOR);
   27e68:	80 3d 4b fb 22 00 00 	cmpb   $0x0,0x22fb4b(%rip)        # 2579ba <theme+0x1a>
   27e6f:	48 8b 05 a2 01 23 00 	mov    0x2301a2(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR, image_recolor, lv_color_t, _color, nonscalar)
   27e76:	be a9 80 00 00       	mov    $0x80a9,%esi
   27e7b:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27e7f:	0f 95 c2             	setne  %dl
   27e82:	31 c0                	xor    %eax,%eax
   27e84:	f7 da                	neg    %edx
   27e86:	88 d0                	mov    %dl,%al
   27e88:	88 d4                	mov    %dl,%ah
   27e8a:	0f b6 d2             	movzbl %dl,%edx
   27e8d:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27e92:	89 d1                	mov    %edx,%ecx
   27e94:	c1 e1 10             	shl    $0x10,%ecx
   27e97:	89 c2                	mov    %eax,%edx
   27e99:	09 ca                	or     %ecx,%edx
   27e9b:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27ea1:	e8 3a 67 ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_image_recolor(&styles->btn, LV_STATE_PRESSED, BG_COLOR);
   27ea6:	80 3d 0d fb 22 00 00 	cmpb   $0x0,0x22fb0d(%rip)        # 2579ba <theme+0x1a>
   27ead:	48 8b 05 64 01 23 00 	mov    0x230164(%rip),%rax        # 258018 <styles>
   27eb4:	be a9 90 00 00       	mov    $0x90a9,%esi
   27eb9:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27ebd:	0f 94 c2             	sete   %dl
   27ec0:	31 c0                	xor    %eax,%eax
   27ec2:	f7 da                	neg    %edx
   27ec4:	88 d0                	mov    %dl,%al
   27ec6:	88 d4                	mov    %dl,%ah
   27ec8:	0f b6 d2             	movzbl %dl,%edx
   27ecb:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27ed0:	89 d1                	mov    %edx,%ecx
   27ed2:	c1 e1 10             	shl    $0x10,%ecx
   27ed5:	89 c2                	mov    %eax,%edx
   27ed7:	09 ca                	or     %ecx,%edx
   27ed9:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27edf:	e8 fc 66 ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_image_recolor(&styles->btn, LV_STATE_CHECKED, BG_COLOR);
   27ee4:	80 3d cf fa 22 00 00 	cmpb   $0x0,0x22facf(%rip)        # 2579ba <theme+0x1a>
   27eeb:	48 8b 05 26 01 23 00 	mov    0x230126(%rip),%rax        # 258018 <styles>
   27ef2:	be a9 81 00 00       	mov    $0x81a9,%esi
   27ef7:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27efb:	0f 94 c2             	sete   %dl
   27efe:	31 c0                	xor    %eax,%eax
   27f00:	f7 da                	neg    %edx
   27f02:	88 d0                	mov    %dl,%al
   27f04:	88 d4                	mov    %dl,%ah
   27f06:	0f b6 d2             	movzbl %dl,%edx
   27f09:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27f0e:	89 d1                	mov    %edx,%ecx
   27f10:	c1 e1 10             	shl    $0x10,%ecx
   27f13:	89 c2                	mov    %eax,%edx
   27f15:	09 ca                	or     %ecx,%edx
   27f17:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27f1d:	e8 be 66 ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_image_recolor(&styles->btn, LV_STATE_CHECKED | LV_STATE_PRESSED, FG_COLOR);
   27f22:	80 3d 91 fa 22 00 00 	cmpb   $0x0,0x22fa91(%rip)        # 2579ba <theme+0x1a>
   27f29:	48 8b 05 e8 00 23 00 	mov    0x2300e8(%rip),%rax        # 258018 <styles>
   27f30:	be a9 91 00 00       	mov    $0x91a9,%esi
   27f35:	48 8d 78 18          	lea    0x18(%rax),%rdi
   27f39:	0f 95 c2             	setne  %dl
   27f3c:	31 c0                	xor    %eax,%eax
   27f3e:	f7 da                	neg    %edx
   27f40:	88 d0                	mov    %dl,%al
   27f42:	88 d4                	mov    %dl,%ah
   27f44:	0f b6 d2             	movzbl %dl,%edx
   27f47:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   27f4c:	89 d1                	mov    %edx,%ecx
   27f4e:	c1 e1 10             	shl    $0x10,%ecx
   27f51:	89 c2                	mov    %eax,%edx
   27f53:	09 ca                	or     %ecx,%edx
   27f55:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   27f5b:	e8 80 66 ff ff       	callq  1e5e0 <_lv_style_set_color>
    style_init_reset(&styles->round);
   27f60:	48 8b 05 b1 00 23 00 	mov    0x2300b1(%rip),%rax        # 258018 <styles>
   27f67:	48 8d 78 20          	lea    0x20(%rax),%rdi
   27f6b:	e8 dc f6 ff ff       	callq  2764c <style_init_reset>
    lv_style_set_radius(&styles->round, LV_STATE_DEFAULT, LV_RADIUS_CIRCLE);
   27f70:	48 8b 05 a1 00 23 00 	mov    0x2300a1(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
   27f77:	ba ff 7f 00 00       	mov    $0x7fff,%edx
   27f7c:	be 01 00 00 00       	mov    $0x1,%esi
   27f81:	48 8d 78 20          	lea    0x20(%rax),%rdi
   27f85:	e8 6e 65 ff ff       	callq  1e4f8 <_lv_style_set_int>
    style_init_reset(&styles->no_radius);
   27f8a:	48 8b 05 87 00 23 00 	mov    0x230087(%rip),%rax        # 258018 <styles>
   27f91:	48 8d 78 28          	lea    0x28(%rax),%rdi
   27f95:	e8 b2 f6 ff ff       	callq  2764c <style_init_reset>
    lv_style_set_radius(&styles->no_radius, LV_STATE_DEFAULT, 0);
   27f9a:	48 8b 05 77 00 23 00 	mov    0x230077(%rip),%rax        # 258018 <styles>
   27fa1:	31 d2                	xor    %edx,%edx
   27fa3:	be 01 00 00 00       	mov    $0x1,%esi
   27fa8:	48 8d 78 28          	lea    0x28(%rax),%rdi
   27fac:	e8 47 65 ff ff       	callq  1e4f8 <_lv_style_set_int>
    style_init_reset(&styles->border_none);
   27fb1:	48 8b 05 60 00 23 00 	mov    0x230060(%rip),%rax        # 258018 <styles>
   27fb8:	48 8d 78 38          	lea    0x38(%rax),%rdi
   27fbc:	e8 8b f6 ff ff       	callq  2764c <style_init_reset>
    lv_style_set_border_width(&styles->border_none, LV_STATE_DEFAULT, 0);
   27fc1:	48 8b 05 50 00 23 00 	mov    0x230050(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_WIDTH, border_width, lv_style_int_t, _int, scalar)
   27fc8:	31 d2                	xor    %edx,%edx
   27fca:	be 30 00 00 00       	mov    $0x30,%esi
   27fcf:	48 8d 78 38          	lea    0x38(%rax),%rdi
   27fd3:	e8 20 65 ff ff       	callq  1e4f8 <_lv_style_set_int>
    style_init_reset(&styles->fg_color);
   27fd8:	48 8b 05 39 00 23 00 	mov    0x230039(%rip),%rax        # 258018 <styles>
   27fdf:	48 8d 78 30          	lea    0x30(%rax),%rdi
   27fe3:	e8 64 f6 ff ff       	callq  2764c <style_init_reset>
    lv_style_set_bg_color(&styles->fg_color, LV_STATE_DEFAULT, FG_COLOR);
   27fe8:	80 3d cb f9 22 00 00 	cmpb   $0x0,0x22f9cb(%rip)        # 2579ba <theme+0x1a>
   27fef:	48 8b 05 22 00 23 00 	mov    0x230022(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
   27ff6:	be 29 00 00 00       	mov    $0x29,%esi
   27ffb:	48 8d 78 30          	lea    0x30(%rax),%rdi
   27fff:	0f 95 c2             	setne  %dl
   28002:	31 c0                	xor    %eax,%eax
   28004:	f7 da                	neg    %edx
   28006:	88 d0                	mov    %dl,%al
   28008:	88 d4                	mov    %dl,%ah
   2800a:	0f b6 d2             	movzbl %dl,%edx
   2800d:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   28012:	89 d1                	mov    %edx,%ecx
   28014:	c1 e1 10             	shl    $0x10,%ecx
   28017:	89 c2                	mov    %eax,%edx
   28019:	09 ca                	or     %ecx,%edx
   2801b:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   28021:	e8 ba 65 ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_text_color(&styles->fg_color, LV_STATE_DEFAULT, BG_COLOR);
   28026:	80 3d 8d f9 22 00 00 	cmpb   $0x0,0x22f98d(%rip)        # 2579ba <theme+0x1a>
   2802d:	48 8b 05 e4 ff 22 00 	mov    0x22ffe4(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
   28034:	be 89 80 00 00       	mov    $0x8089,%esi
   28039:	48 8d 78 30          	lea    0x30(%rax),%rdi
   2803d:	0f 94 c2             	sete   %dl
   28040:	31 c0                	xor    %eax,%eax
   28042:	f7 da                	neg    %edx
   28044:	88 d0                	mov    %dl,%al
   28046:	88 d4                	mov    %dl,%ah
   28048:	0f b6 d2             	movzbl %dl,%edx
   2804b:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   28050:	89 d1                	mov    %edx,%ecx
   28052:	c1 e1 10             	shl    $0x10,%ecx
   28055:	89 c2                	mov    %eax,%edx
   28057:	09 ca                	or     %ecx,%edx
   28059:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   2805f:	e8 7c 65 ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_image_recolor(&styles->fg_color, LV_STATE_DEFAULT, BG_COLOR);
   28064:	80 3d 4f f9 22 00 00 	cmpb   $0x0,0x22f94f(%rip)        # 2579ba <theme+0x1a>
   2806b:	48 8b 05 a6 ff 22 00 	mov    0x22ffa6(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR, image_recolor, lv_color_t, _color, nonscalar)
   28072:	be a9 80 00 00       	mov    $0x80a9,%esi
   28077:	48 8d 78 30          	lea    0x30(%rax),%rdi
   2807b:	0f 94 c2             	sete   %dl
   2807e:	31 c0                	xor    %eax,%eax
   28080:	f7 da                	neg    %edx
   28082:	88 d0                	mov    %dl,%al
   28084:	88 d4                	mov    %dl,%ah
   28086:	0f b6 d2             	movzbl %dl,%edx
   28089:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   2808e:	89 d1                	mov    %edx,%ecx
   28090:	c1 e1 10             	shl    $0x10,%ecx
   28093:	89 c2                	mov    %eax,%edx
   28095:	09 ca                	or     %ecx,%edx
   28097:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   2809d:	e8 3e 65 ff ff       	callq  1e5e0 <_lv_style_set_color>
    lv_style_set_line_color(&styles->fg_color, LV_STATE_DEFAULT, FG_COLOR);
   280a2:	80 3d 11 f9 22 00 00 	cmpb   $0x0,0x22f911(%rip)        # 2579ba <theme+0x1a>
   280a9:	48 8b 05 68 ff 22 00 	mov    0x22ff68(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_COLOR, line_color, lv_color_t, _color, nonscalar)
   280b0:	be 99 00 00 00       	mov    $0x99,%esi
   280b5:	48 8d 78 30          	lea    0x30(%rax),%rdi
   280b9:	0f 95 c2             	setne  %dl
   280bc:	31 c0                	xor    %eax,%eax
   280be:	f7 da                	neg    %edx
   280c0:	88 d0                	mov    %dl,%al
   280c2:	88 d4                	mov    %dl,%ah
   280c4:	0f b6 d2             	movzbl %dl,%edx
   280c7:	25 ff ff 00 ff       	and    $0xff00ffff,%eax
   280cc:	89 d1                	mov    %edx,%ecx
   280ce:	c1 e1 10             	shl    $0x10,%ecx
   280d1:	89 c2                	mov    %eax,%edx
   280d3:	09 ca                	or     %ecx,%edx
   280d5:	81 ca 00 00 00 ff    	or     $0xff000000,%edx
   280db:	e8 00 65 ff ff       	callq  1e5e0 <_lv_style_set_color>
    style_init_reset(&styles->big_line_space);
   280e0:	48 8b 05 31 ff 22 00 	mov    0x22ff31(%rip),%rax        # 258018 <styles>
   280e7:	48 8d 78 40          	lea    0x40(%rax),%rdi
   280eb:	e8 5c f5 ff ff       	callq  2764c <style_init_reset>
    lv_style_set_text_line_space(&styles->big_line_space, LV_STATE_DEFAULT, LV_DPI / 10);
   280f0:	48 8b 05 21 ff 22 00 	mov    0x22ff21(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
   280f7:	ba 0d 00 00 00       	mov    $0xd,%edx
   280fc:	be 81 80 00 00       	mov    $0x8081,%esi
   28101:	48 8d 78 40          	lea    0x40(%rax),%rdi
   28105:	e8 ee 63 ff ff       	callq  1e4f8 <_lv_style_set_int>
    style_init_reset(&styles->pad_none);
   2810a:	48 8b 05 07 ff 22 00 	mov    0x22ff07(%rip),%rax        # 258018 <styles>
   28111:	48 8d 78 48          	lea    0x48(%rax),%rdi
   28115:	e8 32 f5 ff ff       	callq  2764c <style_init_reset>
    lv_style_set_pad_left(&styles->pad_none, LV_STATE_DEFAULT, 0);
   2811a:	48 8b 05 f7 fe 22 00 	mov    0x22fef7(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   28121:	31 d2                	xor    %edx,%edx
   28123:	be 12 00 00 00       	mov    $0x12,%esi
   28128:	48 8d 78 48          	lea    0x48(%rax),%rdi
   2812c:	e8 c7 63 ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_pad_right(&styles->pad_none, LV_STATE_DEFAULT, 0);
   28131:	48 8b 05 e0 fe 22 00 	mov    0x22fee0(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   28138:	31 d2                	xor    %edx,%edx
   2813a:	be 13 00 00 00       	mov    $0x13,%esi
   2813f:	48 8d 78 48          	lea    0x48(%rax),%rdi
   28143:	e8 b0 63 ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_pad_top(&styles->pad_none, LV_STATE_DEFAULT, 0);
   28148:	48 8b 05 c9 fe 22 00 	mov    0x22fec9(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   2814f:	31 d2                	xor    %edx,%edx
   28151:	be 10 00 00 00       	mov    $0x10,%esi
   28156:	48 8d 78 48          	lea    0x48(%rax),%rdi
   2815a:	e8 99 63 ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_pad_bottom(&styles->pad_none, LV_STATE_DEFAULT, 0);
   2815f:	48 8b 05 b2 fe 22 00 	mov    0x22feb2(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   28166:	31 d2                	xor    %edx,%edx
   28168:	be 11 00 00 00       	mov    $0x11,%esi
   2816d:	48 8d 78 48          	lea    0x48(%rax),%rdi
   28171:	e8 82 63 ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_pad_inner(&styles->pad_none, LV_STATE_DEFAULT, 0);
   28176:	48 8b 05 9b fe 22 00 	mov    0x22fe9b(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   2817d:	31 d2                	xor    %edx,%edx
   2817f:	be 14 00 00 00       	mov    $0x14,%esi
   28184:	48 8d 78 48          	lea    0x48(%rax),%rdi
   28188:	e8 6b 63 ff ff       	callq  1e4f8 <_lv_style_set_int>
    style_init_reset(&styles->pad_normal);
   2818d:	48 8b 05 84 fe 22 00 	mov    0x22fe84(%rip),%rax        # 258018 <styles>
   28194:	48 8d 78 50          	lea    0x50(%rax),%rdi
   28198:	e8 af f4 ff ff       	callq  2764c <style_init_reset>
    lv_style_set_pad_left(&styles->pad_normal, LV_STATE_DEFAULT, LV_DPI / 10);
   2819d:	48 8b 05 74 fe 22 00 	mov    0x22fe74(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   281a4:	ba 0d 00 00 00       	mov    $0xd,%edx
   281a9:	be 12 00 00 00       	mov    $0x12,%esi
   281ae:	48 8d 78 50          	lea    0x50(%rax),%rdi
   281b2:	e8 41 63 ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_pad_right(&styles->pad_normal, LV_STATE_DEFAULT, LV_DPI / 10);
   281b7:	48 8b 05 5a fe 22 00 	mov    0x22fe5a(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   281be:	ba 0d 00 00 00       	mov    $0xd,%edx
   281c3:	be 13 00 00 00       	mov    $0x13,%esi
   281c8:	48 8d 78 50          	lea    0x50(%rax),%rdi
   281cc:	e8 27 63 ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_pad_top(&styles->pad_normal, LV_STATE_DEFAULT, LV_DPI / 10);
   281d1:	48 8b 05 40 fe 22 00 	mov    0x22fe40(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   281d8:	ba 0d 00 00 00       	mov    $0xd,%edx
   281dd:	be 10 00 00 00       	mov    $0x10,%esi
   281e2:	48 8d 78 50          	lea    0x50(%rax),%rdi
   281e6:	e8 0d 63 ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_pad_bottom(&styles->pad_normal, LV_STATE_DEFAULT, LV_DPI / 10);
   281eb:	48 8b 05 26 fe 22 00 	mov    0x22fe26(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   281f2:	ba 0d 00 00 00       	mov    $0xd,%edx
   281f7:	be 11 00 00 00       	mov    $0x11,%esi
   281fc:	48 8d 78 50          	lea    0x50(%rax),%rdi
   28200:	e8 f3 62 ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_pad_inner(&styles->pad_normal, LV_STATE_DEFAULT, LV_DPI / 10);
   28205:	48 8b 05 0c fe 22 00 	mov    0x22fe0c(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   2820c:	ba 0d 00 00 00       	mov    $0xd,%edx
   28211:	be 14 00 00 00       	mov    $0x14,%esi
   28216:	48 8d 78 50          	lea    0x50(%rax),%rdi
   2821a:	e8 d9 62 ff ff       	callq  1e4f8 <_lv_style_set_int>
    style_init_reset(&styles->pad_small);
   2821f:	48 8b 05 f2 fd 22 00 	mov    0x22fdf2(%rip),%rax        # 258018 <styles>
   28226:	48 8d 78 58          	lea    0x58(%rax),%rdi
   2822a:	e8 1d f4 ff ff       	callq  2764c <style_init_reset>
    lv_style_set_pad_left(&styles->pad_small, LV_STATE_DEFAULT, LV_DPI / 20);
   2822f:	48 8b 05 e2 fd 22 00 	mov    0x22fde2(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   28236:	ba 06 00 00 00       	mov    $0x6,%edx
   2823b:	be 12 00 00 00       	mov    $0x12,%esi
   28240:	48 8d 78 58          	lea    0x58(%rax),%rdi
   28244:	e8 af 62 ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_pad_right(&styles->pad_small, LV_STATE_DEFAULT, LV_DPI / 20);
   28249:	48 8b 05 c8 fd 22 00 	mov    0x22fdc8(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   28250:	ba 06 00 00 00       	mov    $0x6,%edx
   28255:	be 13 00 00 00       	mov    $0x13,%esi
   2825a:	48 8d 78 58          	lea    0x58(%rax),%rdi
   2825e:	e8 95 62 ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_pad_top(&styles->pad_small, LV_STATE_DEFAULT, LV_DPI / 20);
   28263:	48 8b 05 ae fd 22 00 	mov    0x22fdae(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   2826a:	ba 06 00 00 00       	mov    $0x6,%edx
   2826f:	be 10 00 00 00       	mov    $0x10,%esi
   28274:	48 8d 78 58          	lea    0x58(%rax),%rdi
   28278:	e8 7b 62 ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_pad_bottom(&styles->pad_small, LV_STATE_DEFAULT, LV_DPI / 20);
   2827d:	48 8b 05 94 fd 22 00 	mov    0x22fd94(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   28284:	ba 06 00 00 00       	mov    $0x6,%edx
   28289:	be 11 00 00 00       	mov    $0x11,%esi
   2828e:	48 8d 78 58          	lea    0x58(%rax),%rdi
   28292:	e8 61 62 ff ff       	callq  1e4f8 <_lv_style_set_int>
    lv_style_set_pad_inner(&styles->pad_small, LV_STATE_DEFAULT, LV_DPI / 20);
   28297:	48 8b 05 7a fd 22 00 	mov    0x22fd7a(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   2829e:	ba 06 00 00 00       	mov    $0x6,%edx
   282a3:	be 14 00 00 00       	mov    $0x14,%esi
   282a8:	48 8d 78 58          	lea    0x58(%rax),%rdi
   282ac:	e8 47 62 ff ff       	callq  1e4f8 <_lv_style_set_int>
    style_init_reset(&styles->pad_inner);
   282b1:	48 8b 05 60 fd 22 00 	mov    0x22fd60(%rip),%rax        # 258018 <styles>
   282b8:	48 8d 78 60          	lea    0x60(%rax),%rdi
   282bc:	e8 8b f3 ff ff       	callq  2764c <style_init_reset>
    lv_style_set_pad_inner(&styles->pad_inner, LV_STATE_DEFAULT, LV_DPI / 15);
   282c1:	48 8b 05 50 fd 22 00 	mov    0x22fd50(%rip),%rax        # 258018 <styles>
   282c8:	ba 08 00 00 00       	mov    $0x8,%edx
   282cd:	be 14 00 00 00       	mov    $0x14,%esi
   282d2:	48 8d 78 60          	lea    0x60(%rax),%rdi
   282d6:	e8 1d 62 ff ff       	callq  1e4f8 <_lv_style_set_int>
    style_init_reset(&styles->txt_underline);
   282db:	48 8b 05 36 fd 22 00 	mov    0x22fd36(%rip),%rax        # 258018 <styles>
   282e2:	48 8d 78 68          	lea    0x68(%rax),%rdi
   282e6:	e8 61 f3 ff ff       	callq  2764c <style_init_reset>
    lv_style_set_text_decor(&styles->txt_underline, LV_STATE_FOCUSED, LV_TEXT_DECOR_UNDERLINE);
   282eb:	48 8b 05 26 fd 22 00 	mov    0x22fd26(%rip),%rax        # 258018 <styles>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_DECOR, text_decor, lv_text_decor_t, _int, scalar)
   282f2:	ba 01 00 00 00       	mov    $0x1,%edx
   282f7:	be 82 82 00 00       	mov    $0x8282,%esi
   282fc:	48 8d 78 68          	lea    0x68(%rax),%rdi
   28300:	e8 f3 61 ff ff       	callq  1e4f8 <_lv_style_set_int>
    theme.apply_cb = theme_apply;
   28305:	48 8d 05 97 f2 ff ff 	lea    -0xd69(%rip),%rax        # 275a3 <theme_apply>
    theme.apply_xcb = NULL;
   2830c:	48 c7 05 91 f6 22 00 	movq   $0x0,0x22f691(%rip)        # 2579a8 <theme+0x8>
   28313:	00 00 00 00 
    theme.apply_cb = theme_apply;
   28317:	48 89 05 82 f6 22 00 	mov    %rax,0x22f682(%rip)        # 2579a0 <theme>
}
   2831e:	48 83 c4 18          	add    $0x18,%rsp
   28322:	48 8d 05 77 f6 22 00 	lea    0x22f677(%rip),%rax        # 2579a0 <theme>
   28329:	5b                   	pop    %rbx
   2832a:	5d                   	pop    %rbp
   2832b:	41 5c                	pop    %r12
   2832d:	41 5d                	pop    %r13
   2832f:	c3                   	retq   

0000000000028330 <lv_btn_design>:
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return an element of `lv_design_res_t`
 */
static lv_design_res_t lv_btn_design(lv_obj_t * btn, const lv_area_t * clip_area, lv_design_mode_t mode)
{
    if(mode == LV_DESIGN_COVER_CHK) {
   28330:	80 fa 02             	cmp    $0x2,%dl
   28333:	75 0b                	jne    28340 <lv_btn_design+0x10>
        return ancestor_design(btn, clip_area, mode);
   28335:	ba 02 00 00 00       	mov    $0x2,%edx
   2833a:	ff 25 e0 fc 22 00    	jmpq   *0x22fce0(%rip)        # 258020 <ancestor_design>
{
   28340:	48 83 ec 08          	sub    $0x8,%rsp
    }
    else if(mode == LV_DESIGN_DRAW_MAIN) {
   28344:	84 d2                	test   %dl,%dl
   28346:	75 04                	jne    2834c <lv_btn_design+0x1c>
        ancestor_design(btn, clip_area, mode);
   28348:	31 d2                	xor    %edx,%edx
   2834a:	eb 09                	jmp    28355 <lv_btn_design+0x25>
    }
    else if(mode == LV_DESIGN_DRAW_POST) {
   2834c:	fe ca                	dec    %dl
   2834e:	75 0b                	jne    2835b <lv_btn_design+0x2b>
        ancestor_design(btn, clip_area, mode);
   28350:	ba 01 00 00 00       	mov    $0x1,%edx
   28355:	ff 15 c5 fc 22 00    	callq  *0x22fcc5(%rip)        # 258020 <ancestor_design>
    }

    return LV_DESIGN_RES_OK;
}
   2835b:	31 c0                	xor    %eax,%eax
   2835d:	5a                   	pop    %rdx
   2835e:	c3                   	retq   

000000000002835f <lv_btn_create>:
{
   2835f:	41 55                	push   %r13
   28361:	41 54                	push   %r12
   28363:	49 89 fd             	mov    %rdi,%r13
   28366:	55                   	push   %rbp
   28367:	53                   	push   %rbx
   28368:	49 89 f4             	mov    %rsi,%r12
   2836b:	48 83 ec 08          	sub    $0x8,%rsp
    btn = lv_cont_create(par, copy);
   2836f:	e8 30 07 00 00       	callq  28aa4 <lv_cont_create>
    if(btn == NULL) return NULL;
   28374:	48 85 c0             	test   %rax,%rax
    btn = lv_cont_create(par, copy);
   28377:	48 89 c3             	mov    %rax,%rbx
    if(btn == NULL) return NULL;
   2837a:	0f 84 10 01 00 00    	je     28490 <lv_btn_create+0x131>
    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(btn);
   28380:	48 83 3d a0 fc 22 00 	cmpq   $0x0,0x22fca0(%rip)        # 258028 <ancestor_signal>
   28387:	00 
   28388:	75 0f                	jne    28399 <lv_btn_create+0x3a>
   2838a:	48 89 c7             	mov    %rax,%rdi
   2838d:	e8 63 3f ff ff       	callq  1c2f5 <lv_obj_get_signal_cb>
   28392:	48 89 05 8f fc 22 00 	mov    %rax,0x22fc8f(%rip)        # 258028 <ancestor_signal>
    if(ancestor_design == NULL) ancestor_design = lv_obj_get_design_cb(btn);
   28399:	48 83 3d 7f fc 22 00 	cmpq   $0x0,0x22fc7f(%rip)        # 258020 <ancestor_design>
   283a0:	00 
   283a1:	75 0f                	jne    283b2 <lv_btn_create+0x53>
   283a3:	48 89 df             	mov    %rbx,%rdi
   283a6:	e8 4f 3f ff ff       	callq  1c2fa <lv_obj_get_design_cb>
   283ab:	48 89 05 6e fc 22 00 	mov    %rax,0x22fc6e(%rip)        # 258020 <ancestor_design>
    lv_btn_ext_t * ext = lv_obj_allocate_ext_attr(btn, sizeof(lv_btn_ext_t));
   283b2:	be 03 00 00 00       	mov    $0x3,%esi
   283b7:	48 89 df             	mov    %rbx,%rdi
   283ba:	e8 32 24 ff ff       	callq  1a7f1 <lv_obj_allocate_ext_attr>
    if(ext == NULL) {
   283bf:	48 85 c0             	test   %rax,%rax
    lv_btn_ext_t * ext = lv_obj_allocate_ext_attr(btn, sizeof(lv_btn_ext_t));
   283c2:	48 89 c5             	mov    %rax,%rbp
    if(ext == NULL) {
   283c5:	75 0f                	jne    283d6 <lv_btn_create+0x77>
        lv_obj_del(btn);
   283c7:	48 89 df             	mov    %rbx,%rdi
        return NULL;
   283ca:	31 db                	xor    %ebx,%ebx
        lv_obj_del(btn);
   283cc:	e8 42 29 ff ff       	callq  1ad13 <lv_obj_del>
        return NULL;
   283d1:	e9 ba 00 00 00       	jmpq   28490 <lv_btn_create+0x131>
    ext->checkable = 0;
   283d6:	80 60 02 fe          	andb   $0xfe,0x2(%rax)
    lv_obj_set_signal_cb(btn, lv_btn_signal);
   283da:	48 8d 35 58 01 00 00 	lea    0x158(%rip),%rsi        # 28539 <lv_btn_signal>
   283e1:	48 89 df             	mov    %rbx,%rdi
   283e4:	e8 e7 23 ff ff       	callq  1a7d0 <lv_obj_set_signal_cb>
    lv_obj_set_design_cb(btn, lv_btn_design);
   283e9:	48 8d 35 40 ff ff ff 	lea    -0xc0(%rip),%rsi        # 28330 <lv_btn_design>
   283f0:	48 89 df             	mov    %rbx,%rdi
   283f3:	e8 f4 23 ff ff       	callq  1a7ec <lv_obj_set_design_cb>
    if(copy == NULL) {
   283f8:	4d 85 e4             	test   %r12,%r12
   283fb:	75 40                	jne    2843d <lv_btn_create+0xde>
        if(par) {
   283fd:	4d 85 ed             	test   %r13,%r13
   28400:	74 1f                	je     28421 <lv_btn_create+0xc2>
            lv_obj_set_size(btn, LV_DPI, LV_DPI / 3);
   28402:	be 82 00 00 00       	mov    $0x82,%esi
   28407:	48 89 df             	mov    %rbx,%rdi
   2840a:	ba 2b 00 00 00       	mov    $0x2b,%edx
   2840f:	e8 6a 30 ff ff       	callq  1b47e <lv_obj_set_size>
 * @param btn pointer to a button object
 * @param layout a layout from 'lv_cont_layout_t'
 */
static inline void lv_btn_set_layout(lv_obj_t * btn, lv_layout_t layout)
{
    lv_cont_set_layout(btn, layout);
   28414:	be 01 00 00 00       	mov    $0x1,%esi
   28419:	48 89 df             	mov    %rbx,%rdi
   2841c:	e8 c7 07 00 00       	callq  28be8 <lv_cont_set_layout>
        lv_obj_set_click(btn, true); /*Be sure the button is clickable*/
   28421:	48 89 df             	mov    %rbx,%rdi
   28424:	be 01 00 00 00       	mov    $0x1,%esi
   28429:	e8 68 22 ff ff       	callq  1a696 <lv_obj_set_click>
        lv_theme_apply(btn, LV_THEME_BTN);
   2842e:	be 03 00 00 00       	mov    $0x3,%esi
   28433:	48 89 df             	mov    %rbx,%rdi
   28436:	e8 2e f1 ff ff       	callq  27569 <lv_theme_apply>
   2843b:	eb 2d                	jmp    2846a <lv_btn_create+0x10b>
        lv_btn_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
   2843d:	4c 89 e7             	mov    %r12,%rdi
   28440:	e8 ba 3e ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
        ext->checkable             = copy_ext->checkable;
   28445:	8a 40 02             	mov    0x2(%rax),%al
        lv_obj_refresh_style(btn, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
   28448:	be ff 00 00 00       	mov    $0xff,%esi
   2844d:	48 89 df             	mov    %rbx,%rdi
        ext->checkable             = copy_ext->checkable;
   28450:	83 e0 01             	and    $0x1,%eax
   28453:	88 c2                	mov    %al,%dl
   28455:	8a 45 02             	mov    0x2(%rbp),%al
   28458:	83 e0 fe             	and    $0xfffffffe,%eax
   2845b:	09 d0                	or     %edx,%eax
        lv_obj_refresh_style(btn, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
   2845d:	ba ff 00 00 00       	mov    $0xff,%edx
        ext->checkable             = copy_ext->checkable;
   28462:	88 45 02             	mov    %al,0x2(%rbp)
        lv_obj_refresh_style(btn, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
   28465:	e8 7a 3c ff ff       	callq  1c0e4 <lv_obj_refresh_style>
    LV_LOG_INFO("button created");
   2846a:	4c 8d 05 a5 b9 00 00 	lea    0xb9a5(%rip),%r8        # 33e16 <_lv_bpp1_opa_table+0x5c1>
   28471:	48 8d 0d e0 87 00 00 	lea    0x87e0(%rip),%rcx        # 30c58 <__func__.5900>
   28478:	48 8d 35 a6 b9 00 00 	lea    0xb9a6(%rip),%rsi        # 33e25 <_lv_bpp1_opa_table+0x5d0>
   2847f:	ba 6a 00 00 00       	mov    $0x6a,%edx
   28484:	bf 01 00 00 00       	mov    $0x1,%edi
   28489:	31 c0                	xor    %eax,%eax
   2848b:	e8 c6 da ff ff       	callq  25f56 <_lv_log_add>
}
   28490:	5a                   	pop    %rdx
   28491:	48 89 d8             	mov    %rbx,%rax
   28494:	5b                   	pop    %rbx
   28495:	5d                   	pop    %rbp
   28496:	41 5c                	pop    %r12
   28498:	41 5d                	pop    %r13
   2849a:	c3                   	retq   

000000000002849b <lv_btn_set_state>:
    switch(state) {
   2849b:	40 80 fe 05          	cmp    $0x5,%sil
   2849f:	0f 87 82 00 00 00    	ja     28527 <lv_btn_set_state+0x8c>
   284a5:	48 8d 0d 74 89 00 00 	lea    0x8974(%rip),%rcx        # 30e20 <__func__.5785+0x1b8>
   284ac:	40 0f b6 d6          	movzbl %sil,%edx
{
   284b0:	53                   	push   %rbx
   284b1:	48 89 fb             	mov    %rdi,%rbx
    switch(state) {
   284b4:	48 63 04 91          	movslq (%rcx,%rdx,4),%rax
   284b8:	48 01 c8             	add    %rcx,%rax
   284bb:	ff e0                	jmpq   *%rax
            lv_obj_clear_state(btn, LV_STATE_PRESSED | LV_STATE_CHECKED | LV_STATE_DISABLED);
   284bd:	be 31 00 00 00       	mov    $0x31,%esi
   284c2:	eb 20                	jmp    284e4 <lv_btn_set_state+0x49>
            lv_obj_clear_state(btn, LV_STATE_CHECKED | LV_STATE_DISABLED);
   284c4:	be 21 00 00 00       	mov    $0x21,%esi
   284c9:	e8 a0 4a ff ff       	callq  1cf6e <lv_obj_clear_state>
            lv_obj_add_state(btn, LV_STATE_PRESSED);
   284ce:	be 10 00 00 00       	mov    $0x10,%esi
   284d3:	eb 49                	jmp    2851e <lv_btn_set_state+0x83>
            lv_obj_add_state(btn, LV_STATE_CHECKED);
   284d5:	be 01 00 00 00       	mov    $0x1,%esi
   284da:	e8 7b 4a ff ff       	callq  1cf5a <lv_obj_add_state>
            lv_obj_clear_state(btn, LV_STATE_PRESSED | LV_STATE_DISABLED);
   284df:	be 30 00 00 00       	mov    $0x30,%esi
   284e4:	48 89 df             	mov    %rbx,%rdi
}
   284e7:	5b                   	pop    %rbx
            lv_obj_clear_state(btn, LV_STATE_PRESSED | LV_STATE_DISABLED);
   284e8:	e9 81 4a ff ff       	jmpq   1cf6e <lv_obj_clear_state>
            lv_obj_add_state(btn, LV_STATE_PRESSED | LV_STATE_CHECKED);
   284ed:	be 11 00 00 00       	mov    $0x11,%esi
   284f2:	e8 63 4a ff ff       	callq  1cf5a <lv_obj_add_state>
            lv_obj_clear_state(btn, LV_STATE_DISABLED);
   284f7:	be 20 00 00 00       	mov    $0x20,%esi
   284fc:	eb e6                	jmp    284e4 <lv_btn_set_state+0x49>
            lv_obj_clear_state(btn, LV_STATE_PRESSED | LV_STATE_CHECKED);
   284fe:	be 11 00 00 00       	mov    $0x11,%esi
   28503:	e8 66 4a ff ff       	callq  1cf6e <lv_obj_clear_state>
            lv_obj_add_state(btn, LV_STATE_DISABLED);
   28508:	be 20 00 00 00       	mov    $0x20,%esi
   2850d:	eb 0f                	jmp    2851e <lv_btn_set_state+0x83>
            lv_obj_clear_state(btn, LV_STATE_PRESSED);
   2850f:	be 10 00 00 00       	mov    $0x10,%esi
   28514:	e8 55 4a ff ff       	callq  1cf6e <lv_obj_clear_state>
            lv_obj_add_state(btn, LV_STATE_DISABLED | LV_STATE_CHECKED);
   28519:	be 21 00 00 00       	mov    $0x21,%esi
   2851e:	48 89 df             	mov    %rbx,%rdi
}
   28521:	5b                   	pop    %rbx
            lv_obj_add_state(btn, LV_STATE_DISABLED | LV_STATE_CHECKED);
   28522:	e9 33 4a ff ff       	jmpq   1cf5a <lv_obj_add_state>
   28527:	c3                   	retq   

0000000000028528 <lv_btn_get_checkable>:
{
   28528:	48 83 ec 08          	sub    $0x8,%rsp
    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);
   2852c:	e8 ce 3d ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    return ext->checkable != 0 ? true : false;
   28531:	8a 40 02             	mov    0x2(%rax),%al
}
   28534:	5a                   	pop    %rdx
    return ext->checkable != 0 ? true : false;
   28535:	83 e0 01             	and    $0x1,%eax
}
   28538:	c3                   	retq   

0000000000028539 <lv_btn_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_btn_signal(lv_obj_t * btn, lv_signal_t sign, void * param)
{
   28539:	41 56                	push   %r14
   2853b:	41 55                	push   %r13
   2853d:	41 89 f5             	mov    %esi,%r13d
   28540:	41 54                	push   %r12
   28542:	55                   	push   %rbp
   28543:	49 89 d4             	mov    %rdx,%r12
   28546:	53                   	push   %rbx
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(btn, sign, param);
   28547:	40 0f b6 f6          	movzbl %sil,%esi
{
   2854b:	48 89 fb             	mov    %rdi,%rbx
   2854e:	48 83 ec 10          	sub    $0x10,%rsp
   28552:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   28559:	00 00 
   2855b:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   28560:	31 c0                	xor    %eax,%eax
    res = ancestor_signal(btn, sign, param);
   28562:	ff 15 c0 fa 22 00    	callq  *0x22fac0(%rip)        # 258028 <ancestor_signal>
   28568:	40 88 c5             	mov    %al,%bpl
    if(res != LV_RES_OK) return res;
   2856b:	fe c8                	dec    %al
   2856d:	0f 85 8d 00 00 00    	jne    28600 <lv_btn_signal+0xc7>
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
   28573:	41 80 fd 07          	cmp    $0x7,%r13b
   28577:	75 11                	jne    2858a <lv_btn_signal+0x51>
   28579:	48 8d 35 dd b8 00 00 	lea    0xb8dd(%rip),%rsi        # 33e5d <_lv_bpp1_opa_table+0x608>
   28580:	4c 89 e7             	mov    %r12,%rdi
   28583:	e8 e0 3d ff ff       	callq  1c368 <lv_obj_handle_get_type_signal>
   28588:	eb 73                	jmp    285fd <lv_btn_signal+0xc4>

    bool tgl           = lv_btn_get_checkable(btn);
   2858a:	48 89 df             	mov    %rbx,%rdi
   2858d:	e8 96 ff ff ff       	callq  28528 <lv_btn_get_checkable>

    if(sign == LV_SIGNAL_RELEASED) {
   28592:	41 80 fd 0e          	cmp    $0xe,%r13b
    bool tgl           = lv_btn_get_checkable(btn);
   28596:	41 88 c6             	mov    %al,%r14b
    if(sign == LV_SIGNAL_RELEASED) {
   28599:	75 65                	jne    28600 <lv_btn_signal+0xc7>
        /*If not dragged and it was not long press action then
         *change state and run the action*/
        if(lv_indev_is_dragging(param) == false && tgl) {
   2859b:	4c 89 e7             	mov    %r12,%rdi
   2859e:	e8 ea 12 ff ff       	callq  1988d <lv_indev_is_dragging>
   285a3:	fe c8                	dec    %al
   285a5:	74 59                	je     28600 <lv_btn_signal+0xc7>
   285a7:	45 84 f6             	test   %r14b,%r14b
   285aa:	74 54                	je     28600 <lv_btn_signal+0xc7>
            uint32_t toggled = 0;
            if(lv_obj_get_state(btn, LV_BTN_PART_MAIN) & LV_STATE_CHECKED) {
   285ac:	31 f6                	xor    %esi,%esi
   285ae:	48 89 df             	mov    %rbx,%rdi
            uint32_t toggled = 0;
   285b1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%rsp)
   285b8:	00 
            if(lv_obj_get_state(btn, LV_BTN_PART_MAIN) & LV_STATE_CHECKED) {
   285b9:	e8 10 30 ff ff       	callq  1b5ce <lv_obj_get_state>
   285be:	a8 01                	test   $0x1,%al
   285c0:	74 14                	je     285d6 <lv_btn_signal+0x9d>
                lv_btn_set_state(btn, LV_BTN_STATE_RELEASED);
   285c2:	31 f6                	xor    %esi,%esi
   285c4:	48 89 df             	mov    %rbx,%rdi
   285c7:	e8 cf fe ff ff       	callq  2849b <lv_btn_set_state>
                toggled = 0;
   285cc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%rsp)
   285d3:	00 
   285d4:	eb 15                	jmp    285eb <lv_btn_signal+0xb2>
            }
            else {
                lv_btn_set_state(btn, LV_BTN_STATE_CHECKED_RELEASED);
   285d6:	be 03 00 00 00       	mov    $0x3,%esi
   285db:	48 89 df             	mov    %rbx,%rdi
   285de:	e8 b8 fe ff ff       	callq  2849b <lv_btn_set_state>
                toggled = 1;
   285e3:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%rsp)
   285ea:	00 
            }

            res = lv_event_send(btn, LV_EVENT_VALUE_CHANGED, &toggled);
   285eb:	48 8d 54 24 04       	lea    0x4(%rsp),%rdx
   285f0:	be 10 00 00 00       	mov    $0x10,%esi
   285f5:	48 89 df             	mov    %rbx,%rdi
   285f8:	e8 b3 21 ff ff       	callq  1a7b0 <lv_event_send>
   285fd:	40 88 c5             	mov    %al,%bpl
        }
#endif
    }

    return res;
}
   28600:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
   28605:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   2860c:	00 00 
   2860e:	40 88 e8             	mov    %bpl,%al
   28611:	74 05                	je     28618 <lv_btn_signal+0xdf>
   28613:	e8 28 c0 fd ff       	callq  4640 <__stack_chk_fail@plt>
   28618:	48 83 c4 10          	add    $0x10,%rsp
   2861c:	5b                   	pop    %rbx
   2861d:	5d                   	pop    %rbp
   2861e:	41 5c                	pop    %r12
   28620:	41 5d                	pop    %r13
   28622:	41 5e                	pop    %r14
   28624:	c3                   	retq   

0000000000028625 <lv_cont_refr_autofit>:
/**
 * Handle auto fit. Set the size of the object to involve all children.
 * @param cont pointer to an object which size will be modified
 */
static void lv_cont_refr_autofit(lv_obj_t * cont)
{
   28625:	41 57                	push   %r15
   28627:	41 56                	push   %r14
    if(lv_obj_is_protected(cont, LV_PROTECT_CHILD_CHG)) return;
   28629:	be 01 00 00 00       	mov    $0x1,%esi
{
   2862e:	41 55                	push   %r13
   28630:	41 54                	push   %r12
   28632:	55                   	push   %rbp
   28633:	53                   	push   %rbx
   28634:	48 89 fb             	mov    %rdi,%rbx
   28637:	48 83 ec 58          	sub    $0x58,%rsp
   2863b:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   28642:	00 00 
   28644:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
   28649:	31 c0                	xor    %eax,%eax
    if(lv_obj_is_protected(cont, LV_PROTECT_CHILD_CHG)) return;
   2864b:	e8 76 2f ff ff       	callq  1b5c6 <lv_obj_is_protected>
   28650:	84 c0                	test   %al,%al
   28652:	0f 85 28 04 00 00    	jne    28a80 <lv_cont_refr_autofit+0x45b>
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
   28658:	48 89 df             	mov    %rbx,%rdi
   2865b:	e8 9f 3c ff ff       	callq  1c2ff <lv_obj_get_ext_attr>

    if(ext->fit_left == LV_FIT_NONE && ext->fit_right == LV_FIT_NONE && ext->fit_top == LV_FIT_NONE &&
   28660:	f6 00 f0             	testb  $0xf0,(%rax)
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
   28663:	49 89 c4             	mov    %rax,%r12
    if(ext->fit_left == LV_FIT_NONE && ext->fit_right == LV_FIT_NONE && ext->fit_top == LV_FIT_NONE &&
   28666:	75 0a                	jne    28672 <lv_cont_refr_autofit+0x4d>
   28668:	f6 40 01 0f          	testb  $0xf,0x1(%rax)
   2866c:	0f 84 0e 04 00 00    	je     28a80 <lv_cont_refr_autofit+0x45b>

    lv_area_t tight_area;
    lv_area_t ori;
    lv_obj_t * child_i;

    lv_obj_t * par               = lv_obj_get_parent(cont);
   28672:	48 89 df             	mov    %rbx,%rdi
   28675:	e8 a5 21 ff ff       	callq  1a81f <lv_obj_get_parent>
   2867a:	4c 8b 70 20          	mov    0x20(%rax),%r14
   2867e:	49 89 c5             	mov    %rax,%r13
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ANGLE, transform_angle, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ZOOM, transform_zoom, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(OPA_SCALE, opa_scale, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   28681:	31 f6                	xor    %esi,%esi
   28683:	ba 12 00 00 00       	mov    $0x12,%edx
   28688:	48 89 c7             	mov    %rax,%rdi
   2868b:	e8 5d 30 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    lv_area_t parent_area;
    lv_area_copy(&parent_area, &par->coords);
    parent_area.x1 += lv_obj_get_style_pad_left(par, LV_OBJ_PART_MAIN);
    parent_area.x2 -= lv_obj_get_style_pad_right(par, LV_OBJ_PART_MAIN);
   28690:	4c 89 f5             	mov    %r14,%rbp
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   28693:	31 f6                	xor    %esi,%esi
   28695:	ba 13 00 00 00       	mov    $0x13,%edx
   2869a:	4c 89 ef             	mov    %r13,%rdi
   2869d:	48 c1 e5 10          	shl    $0x10,%rbp
    parent_area.x1 += lv_obj_get_style_pad_left(par, LV_OBJ_PART_MAIN);
   286a1:	46 8d 3c 30          	lea    (%rax,%r14,1),%r15d
    parent_area.x2 -= lv_obj_get_style_pad_right(par, LV_OBJ_PART_MAIN);
   286a5:	48 c1 fd 30          	sar    $0x30,%rbp
   286a9:	e8 3f 30 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   286ae:	31 f6                	xor    %esi,%esi
   286b0:	ba 10 00 00 00       	mov    $0x10,%edx
   286b5:	4c 89 ef             	mov    %r13,%rdi
   286b8:	29 c5                	sub    %eax,%ebp
   286ba:	e8 2e 30 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    parent_area.y1 += lv_obj_get_style_pad_top(par, LV_OBJ_PART_MAIN);
   286bf:	44 89 f2             	mov    %r14d,%edx
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   286c2:	31 f6                	xor    %esi,%esi
   286c4:	4c 89 ef             	mov    %r13,%rdi
   286c7:	c1 fa 10             	sar    $0x10,%edx
    parent_area.y2 -= lv_obj_get_style_pad_bottom(par, LV_OBJ_PART_MAIN);
   286ca:	49 c1 fe 30          	sar    $0x30,%r14
    parent_area.y1 += lv_obj_get_style_pad_top(par, LV_OBJ_PART_MAIN);
   286ce:	01 d0                	add    %edx,%eax
   286d0:	ba 11 00 00 00       	mov    $0x11,%edx
   286d5:	66 89 44 24 08       	mov    %ax,0x8(%rsp)
   286da:	e8 0e 30 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    parent_area.y2 -= lv_obj_get_style_pad_bottom(par, LV_OBJ_PART_MAIN);
   286df:	44 89 f1             	mov    %r14d,%ecx

    /*Search the side coordinates of the children*/
    lv_obj_get_coords(cont, &ori);
   286e2:	48 89 df             	mov    %rbx,%rdi
    parent_area.y2 -= lv_obj_get_style_pad_bottom(par, LV_OBJ_PART_MAIN);
   286e5:	29 c1                	sub    %eax,%ecx
    lv_obj_get_coords(cont, &ori);
   286e7:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
    parent_area.y2 -= lv_obj_get_style_pad_bottom(par, LV_OBJ_PART_MAIN);
   286ec:	66 89 4c 24 10       	mov    %cx,0x10(%rsp)
    lv_obj_get_coords(cont, &ori);
   286f1:	48 89 c6             	mov    %rax,%rsi
   286f4:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
   286f9:	e8 b4 22 ff ff       	callq  1a9b2 <lv_obj_get_coords>
    lv_obj_get_coords(cont, &tight_area);
   286fe:	48 8d 74 24 38       	lea    0x38(%rsp),%rsi
   28703:	48 89 df             	mov    %rbx,%rdi
   28706:	e8 a7 22 ff ff       	callq  1a9b2 <lv_obj_get_coords>

    bool has_children = _lv_ll_is_empty(&cont->child_ll) ? false : true;
   2870b:	48 8d 43 08          	lea    0x8(%rbx),%rax
   2870f:	48 89 c7             	mov    %rax,%rdi
   28712:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
   28717:	e8 19 d8 ff ff       	callq  25f35 <_lv_ll_is_empty>

    if(has_children) {
   2871c:	34 01                	xor    $0x1,%al
   2871e:	88 44 24 1f          	mov    %al,0x1f(%rsp)
   28722:	0f 84 60 01 00 00    	je     28888 <lv_cont_refr_autofit+0x263>
        tight_area.x1 = LV_COORD_MAX;
        tight_area.y1 = LV_COORD_MAX;
        tight_area.x2 = LV_COORD_MIN;
        tight_area.y2 = LV_COORD_MIN;

        _LV_LL_READ(cont->child_ll, child_i) {
   28728:	48 8d 7b 08          	lea    0x8(%rbx),%rdi
        tight_area.x1 = LV_COORD_MAX;
   2872c:	48 b8 18 7c 18 7c e8 	movabs $0x83e883e87c187c18,%rax
   28733:	83 e8 83 
   28736:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
        _LV_LL_READ(cont->child_ll, child_i) {
   2873b:	e8 2b d5 ff ff       	callq  25c6b <_lv_ll_get_head>
   28740:	48 85 c0             	test   %rax,%rax
   28743:	49 89 c6             	mov    %rax,%r14
   28746:	0f 84 ec 00 00 00    	je     28838 <lv_cont_refr_autofit+0x213>
            if(lv_obj_get_hidden(child_i) != false) continue;
   2874c:	4c 89 f7             	mov    %r14,%rdi
   2874f:	e8 e2 23 ff ff       	callq  1ab36 <lv_obj_get_hidden>
   28754:	84 c0                	test   %al,%al
   28756:	0f 85 ca 00 00 00    	jne    28826 <lv_cont_refr_autofit+0x201>

            if(ext->fit_left != LV_FIT_PARENT) {
   2875c:	41 8a 04 24          	mov    (%r12),%al
   28760:	83 e0 30             	and    $0x30,%eax
   28763:	3c 20                	cmp    $0x20,%al
   28765:	74 28                	je     2878f <lv_cont_refr_autofit+0x16a>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
   28767:	ba 17 00 00 00       	mov    $0x17,%edx
   2876c:	31 f6                	xor    %esi,%esi
   2876e:	4c 89 f7             	mov    %r14,%rdi
   28771:	e8 77 2f ff ff       	callq  1b6ed <_lv_obj_get_style_int>
                lv_style_int_t mleft = lv_obj_get_style_margin_left(child_i, LV_OBJ_PART_MAIN);
                tight_area.x1 = LV_MATH_MIN(tight_area.x1, child_i->coords.x1 - mleft);
   28776:	41 0f bf 56 20       	movswl 0x20(%r14),%edx
   2877b:	98                   	cwtl   
   2877c:	29 c2                	sub    %eax,%edx
   2877e:	89 d0                	mov    %edx,%eax
   28780:	0f bf 54 24 38       	movswl 0x38(%rsp),%edx
   28785:	39 d0                	cmp    %edx,%eax
   28787:	0f 4f c2             	cmovg  %edx,%eax
   2878a:	66 89 44 24 38       	mov    %ax,0x38(%rsp)
            }

            if(ext->fit_right != LV_FIT_PARENT) {
   2878f:	41 8a 04 24          	mov    (%r12),%al
   28793:	83 e0 c0             	and    $0xffffffc0,%eax
   28796:	3c 80                	cmp    $0x80,%al
   28798:	74 26                	je     287c0 <lv_cont_refr_autofit+0x19b>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_RIGHT, margin_right, lv_style_int_t, _int, scalar)
   2879a:	ba 18 00 00 00       	mov    $0x18,%edx
   2879f:	31 f6                	xor    %esi,%esi
   287a1:	4c 89 f7             	mov    %r14,%rdi
   287a4:	e8 44 2f ff ff       	callq  1b6ed <_lv_obj_get_style_int>
                lv_style_int_t mright = lv_obj_get_style_margin_right(child_i, LV_OBJ_PART_MAIN);
                tight_area.x2 = LV_MATH_MAX(tight_area.x2, child_i->coords.x2 + mright);
   287a9:	41 0f bf 56 24       	movswl 0x24(%r14),%edx
   287ae:	98                   	cwtl   
   287af:	01 d0                	add    %edx,%eax
   287b1:	0f bf 54 24 3c       	movswl 0x3c(%rsp),%edx
   287b6:	39 d0                	cmp    %edx,%eax
   287b8:	0f 4c c2             	cmovl  %edx,%eax
   287bb:	66 89 44 24 3c       	mov    %ax,0x3c(%rsp)
            }

            if(ext->fit_top != LV_FIT_PARENT) {
   287c0:	41 8a 44 24 01       	mov    0x1(%r12),%al
   287c5:	83 e0 03             	and    $0x3,%eax
   287c8:	3c 02                	cmp    $0x2,%al
   287ca:	74 28                	je     287f4 <lv_cont_refr_autofit+0x1cf>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
   287cc:	ba 15 00 00 00       	mov    $0x15,%edx
   287d1:	31 f6                	xor    %esi,%esi
   287d3:	4c 89 f7             	mov    %r14,%rdi
   287d6:	e8 12 2f ff ff       	callq  1b6ed <_lv_obj_get_style_int>
                lv_style_int_t mtop = lv_obj_get_style_margin_top(child_i, LV_OBJ_PART_MAIN);
                tight_area.y1 = LV_MATH_MIN(tight_area.y1, child_i->coords.y1 - mtop);
   287db:	41 0f bf 56 22       	movswl 0x22(%r14),%edx
   287e0:	98                   	cwtl   
   287e1:	29 c2                	sub    %eax,%edx
   287e3:	89 d0                	mov    %edx,%eax
   287e5:	0f bf 54 24 3a       	movswl 0x3a(%rsp),%edx
   287ea:	39 d0                	cmp    %edx,%eax
   287ec:	0f 4f c2             	cmovg  %edx,%eax
   287ef:	66 89 44 24 3a       	mov    %ax,0x3a(%rsp)
            }

            if(ext->fit_bottom != LV_FIT_PARENT) {
   287f4:	41 8a 44 24 01       	mov    0x1(%r12),%al
   287f9:	83 e0 0c             	and    $0xc,%eax
   287fc:	3c 08                	cmp    $0x8,%al
   287fe:	74 26                	je     28826 <lv_cont_refr_autofit+0x201>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
   28800:	ba 16 00 00 00       	mov    $0x16,%edx
   28805:	31 f6                	xor    %esi,%esi
   28807:	4c 89 f7             	mov    %r14,%rdi
   2880a:	e8 de 2e ff ff       	callq  1b6ed <_lv_obj_get_style_int>
                lv_style_int_t mbottom = lv_obj_get_style_margin_bottom(child_i, LV_OBJ_PART_MAIN);
                tight_area.y2 = LV_MATH_MAX(tight_area.y2, child_i->coords.y2 + mbottom);
   2880f:	41 0f bf 56 26       	movswl 0x26(%r14),%edx
   28814:	98                   	cwtl   
   28815:	01 d0                	add    %edx,%eax
   28817:	0f bf 54 24 3e       	movswl 0x3e(%rsp),%edx
   2881c:	39 d0                	cmp    %edx,%eax
   2881e:	0f 4c c2             	cmovl  %edx,%eax
   28821:	66 89 44 24 3e       	mov    %ax,0x3e(%rsp)
        _LV_LL_READ(cont->child_ll, child_i) {
   28826:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
   2882b:	4c 89 f6             	mov    %r14,%rsi
   2882e:	e8 50 d4 ff ff       	callq  25c83 <_lv_ll_get_next>
   28833:	e9 08 ff ff ff       	jmpq   28740 <lv_cont_refr_autofit+0x11b>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   28838:	ba 12 00 00 00       	mov    $0x12,%edx
   2883d:	31 f6                	xor    %esi,%esi
   2883f:	48 89 df             	mov    %rbx,%rdi
   28842:	e8 a6 2e ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   28847:	ba 13 00 00 00       	mov    $0x13,%edx
   2884c:	31 f6                	xor    %esi,%esi
   2884e:	48 89 df             	mov    %rbx,%rdi
            }
        }

        tight_area.x1 -= lv_obj_get_style_pad_left(cont, LV_CONT_PART_MAIN);
   28851:	66 29 44 24 38       	sub    %ax,0x38(%rsp)
   28856:	e8 92 2e ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   2885b:	ba 10 00 00 00       	mov    $0x10,%edx
   28860:	31 f6                	xor    %esi,%esi
   28862:	48 89 df             	mov    %rbx,%rdi
        tight_area.x2 += lv_obj_get_style_pad_right(cont, LV_CONT_PART_MAIN);
   28865:	66 01 44 24 3c       	add    %ax,0x3c(%rsp)
   2886a:	e8 7e 2e ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   2886f:	ba 11 00 00 00       	mov    $0x11,%edx
   28874:	31 f6                	xor    %esi,%esi
   28876:	48 89 df             	mov    %rbx,%rdi
        tight_area.y1 -= lv_obj_get_style_pad_top(cont, LV_CONT_PART_MAIN);
   28879:	66 29 44 24 3a       	sub    %ax,0x3a(%rsp)
   2887e:	e8 6a 2e ff ff       	callq  1b6ed <_lv_obj_get_style_int>
        tight_area.y2 += lv_obj_get_style_pad_bottom(cont, LV_CONT_PART_MAIN);
   28883:	66 01 44 24 3e       	add    %ax,0x3e(%rsp)
    }

    lv_area_t new_area;
    lv_area_copy(&new_area, &ori);

    switch(ext->fit_left) {
   28888:	41 8a 04 24          	mov    (%r12),%al
   2888c:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
   28891:	88 c1                	mov    %al,%cl
   28893:	c0 e9 04             	shr    $0x4,%cl
   28896:	83 e1 03             	and    $0x3,%ecx
   28899:	80 f9 02             	cmp    $0x2,%cl
   2889c:	74 20                	je     288be <lv_cont_refr_autofit+0x299>
   2889e:	77 0b                	ja     288ab <lv_cont_refr_autofit+0x286>
   288a0:	fe c9                	dec    %cl
   288a2:	75 1e                	jne    288c2 <lv_cont_refr_autofit+0x29d>
        case LV_FIT_TIGHT:
            new_area.x1 = tight_area.x1;
   288a4:	66 8b 54 24 38       	mov    0x38(%rsp),%dx
            break;
   288a9:	eb 17                	jmp    288c2 <lv_cont_refr_autofit+0x29d>
        case LV_FIT_PARENT:
            new_area.x1 = parent_area.x1;
            break;
        case LV_FIT_MAX:
            new_area.x1 = has_children ? LV_MATH_MIN(tight_area.x1, parent_area.x1) : parent_area.x1;
   288ab:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%rsp)
   288b0:	74 0c                	je     288be <lv_cont_refr_autofit+0x299>
   288b2:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
   288b6:	66 41 39 cf          	cmp    %cx,%r15w
   288ba:	44 0f 4f f9          	cmovg  %ecx,%r15d
   288be:	66 44 89 fa          	mov    %r15w,%dx
            break;
        default:
            break;
    }

    switch(ext->fit_right) {
   288c2:	c0 e8 06             	shr    $0x6,%al
   288c5:	3c 02                	cmp    $0x2,%al
   288c7:	74 32                	je     288fb <lv_cont_refr_autofit+0x2d6>
   288c9:	77 1f                	ja     288ea <lv_cont_refr_autofit+0x2c5>
   288cb:	fe c8                	dec    %al
   288cd:	75 43                	jne    28912 <lv_cont_refr_autofit+0x2ed>
        case LV_FIT_TIGHT:
            new_area.x2 = tight_area.x2;
   288cf:	0f b7 44 24 3c       	movzwl 0x3c(%rsp),%eax
   288d4:	48 b9 ff ff ff ff 00 	movabs $0xffff0000ffffffff,%rcx
   288db:	00 ff ff 
   288de:	48 21 ca             	and    %rcx,%rdx
   288e1:	48 c1 e0 20          	shl    $0x20,%rax
   288e5:	48 09 c2             	or     %rax,%rdx
            break;
   288e8:	eb 28                	jmp    28912 <lv_cont_refr_autofit+0x2ed>
        case LV_FIT_PARENT:
            new_area.x2 = parent_area.x2;
            break;
        case LV_FIT_MAX:
            new_area.x2 = has_children ? LV_MATH_MAX(tight_area.x2, parent_area.x2) : parent_area.x2;
   288ea:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%rsp)
   288ef:	74 0a                	je     288fb <lv_cont_refr_autofit+0x2d6>
   288f1:	8b 44 24 3c          	mov    0x3c(%rsp),%eax
   288f5:	66 39 c5             	cmp    %ax,%bp
   288f8:	0f 4c e8             	cmovl  %eax,%ebp
   288fb:	0f b7 ed             	movzwl %bp,%ebp
   288fe:	48 b8 ff ff ff ff 00 	movabs $0xffff0000ffffffff,%rax
   28905:	00 ff ff 
   28908:	48 c1 e5 20          	shl    $0x20,%rbp
   2890c:	48 21 c2             	and    %rax,%rdx
   2890f:	48 09 ea             	or     %rbp,%rdx
            break;
        default:
            break;
    }

    switch(ext->fit_top) {
   28912:	41 8a 4c 24 01       	mov    0x1(%r12),%cl
   28917:	88 c8                	mov    %cl,%al
   28919:	83 e0 03             	and    $0x3,%eax
   2891c:	3c 02                	cmp    $0x2,%al
   2891e:	74 29                	je     28949 <lv_cont_refr_autofit+0x324>
   28920:	77 0b                	ja     2892d <lv_cont_refr_autofit+0x308>
   28922:	fe c8                	dec    %al
   28924:	75 3c                	jne    28962 <lv_cont_refr_autofit+0x33d>
        case LV_FIT_TIGHT:
            new_area.y1 = tight_area.y1;
   28926:	0f b7 44 24 3a       	movzwl 0x3a(%rsp),%eax
   2892b:	eb 21                	jmp    2894e <lv_cont_refr_autofit+0x329>
            break;
        case LV_FIT_PARENT:
            new_area.y1 = parent_area.y1;
            break;
        case LV_FIT_MAX:
            new_area.y1 = has_children ? LV_MATH_MIN(tight_area.y1, parent_area.y1) : parent_area.y1;
   2892d:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%rsp)
   28932:	74 15                	je     28949 <lv_cont_refr_autofit+0x324>
   28934:	66 8b 44 24 3a       	mov    0x3a(%rsp),%ax
   28939:	66 39 44 24 08       	cmp    %ax,0x8(%rsp)
   2893e:	66 0f 4e 44 24 08    	cmovle 0x8(%rsp),%ax
   28944:	66 89 44 24 08       	mov    %ax,0x8(%rsp)
   28949:	0f b7 44 24 08       	movzwl 0x8(%rsp),%eax
   2894e:	48 be ff ff 00 00 ff 	movabs $0xffffffff0000ffff,%rsi
   28955:	ff ff ff 
   28958:	48 c1 e0 10          	shl    $0x10,%rax
   2895c:	48 21 f2             	and    %rsi,%rdx
   2895f:	48 09 c2             	or     %rax,%rdx
            break;
        default:
            break;
    }

    switch(ext->fit_bottom) {
   28962:	88 c8                	mov    %cl,%al
   28964:	c0 e8 02             	shr    $0x2,%al
   28967:	83 e0 03             	and    $0x3,%eax
   2896a:	3c 02                	cmp    $0x2,%al
   2896c:	74 0d                	je     2897b <lv_cont_refr_autofit+0x356>
   2896e:	77 26                	ja     28996 <lv_cont_refr_autofit+0x371>
   28970:	fe c8                	dec    %al
   28972:	75 57                	jne    289cb <lv_cont_refr_autofit+0x3a6>
        case LV_FIT_TIGHT:
            new_area.y2 = tight_area.y2;
   28974:	0f b7 44 24 3e       	movzwl 0x3e(%rsp),%eax
   28979:	eb 3c                	jmp    289b7 <lv_cont_refr_autofit+0x392>
            break;
        case LV_FIT_PARENT:
            new_area.y2 = parent_area.y2;
   2897b:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
   28980:	48 b8 ff ff ff ff ff 	movabs $0xffffffffffff,%rax
   28987:	ff 00 00 
   2898a:	48 21 c2             	and    %rax,%rdx
   2898d:	48 c1 e1 30          	shl    $0x30,%rcx
   28991:	48 09 ca             	or     %rcx,%rdx
            break;
   28994:	eb 35                	jmp    289cb <lv_cont_refr_autofit+0x3a6>
        case LV_FIT_MAX:
            new_area.y2 = has_children ? LV_MATH_MAX(tight_area.y2, parent_area.y2) : parent_area.y2;
   28996:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%rsp)
   2899b:	74 15                	je     289b2 <lv_cont_refr_autofit+0x38d>
   2899d:	66 8b 44 24 3e       	mov    0x3e(%rsp),%ax
   289a2:	66 39 44 24 10       	cmp    %ax,0x10(%rsp)
   289a7:	66 0f 4d 44 24 10    	cmovge 0x10(%rsp),%ax
   289ad:	66 89 44 24 10       	mov    %ax,0x10(%rsp)
   289b2:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
   289b7:	48 b9 ff ff ff ff ff 	movabs $0xffffffffffff,%rcx
   289be:	ff 00 00 
   289c1:	48 c1 e0 30          	shl    $0x30,%rax
   289c5:	48 21 ca             	and    %rcx,%rdx
   289c8:	48 09 c2             	or     %rax,%rdx
        default:
            break;
    }

    /*Do nothing if the coordinates are not changed*/
    if(cont->coords.x1 != new_area.x1 || cont->coords.y1 != new_area.y1 || cont->coords.x2 != new_area.x2 ||
   289cb:	66 39 53 20          	cmp    %dx,0x20(%rbx)
   289cf:	75 2d                	jne    289fe <lv_cont_refr_autofit+0x3d9>
   289d1:	89 d0                	mov    %edx,%eax
   289d3:	c1 f8 10             	sar    $0x10,%eax
   289d6:	66 39 43 22          	cmp    %ax,0x22(%rbx)
   289da:	75 22                	jne    289fe <lv_cont_refr_autofit+0x3d9>
   289dc:	48 89 d0             	mov    %rdx,%rax
   289df:	48 c1 e0 10          	shl    $0x10,%rax
   289e3:	48 c1 f8 30          	sar    $0x30,%rax
   289e7:	66 39 43 24          	cmp    %ax,0x24(%rbx)
   289eb:	75 11                	jne    289fe <lv_cont_refr_autofit+0x3d9>
       cont->coords.y2 != new_area.y2) {
   289ed:	48 89 d0             	mov    %rdx,%rax
   289f0:	48 c1 f8 30          	sar    $0x30,%rax
    if(cont->coords.x1 != new_area.x1 || cont->coords.y1 != new_area.y1 || cont->coords.x2 != new_area.x2 ||
   289f4:	66 39 43 26          	cmp    %ax,0x26(%rbx)
   289f8:	0f 84 82 00 00 00    	je     28a80 <lv_cont_refr_autofit+0x45b>

        lv_obj_invalidate(cont);
   289fe:	48 89 df             	mov    %rbx,%rdi
   28a01:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
   28a06:	e8 a7 22 ff ff       	callq  1acb2 <lv_obj_invalidate>
   28a0b:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
        lv_area_copy(&cont->coords, &new_area);
        lv_obj_invalidate(cont);
   28a10:	48 89 df             	mov    %rbx,%rdi
   28a13:	48 89 53 20          	mov    %rdx,0x20(%rbx)
   28a17:	e8 96 22 ff ff       	callq  1acb2 <lv_obj_invalidate>

        /*Notify the object about its new coordinates*/
        cont->signal_cb(cont, LV_SIGNAL_COORD_CHG, &ori);
   28a1c:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
   28a21:	be 02 00 00 00       	mov    $0x2,%esi
   28a26:	48 89 df             	mov    %rbx,%rdi
   28a29:	ff 53 30             	callq  *0x30(%rbx)

        /*Inform the parent about the new coordinates*/
        par->signal_cb(par, LV_SIGNAL_CHILD_CHG, cont);
   28a2c:	48 89 da             	mov    %rbx,%rdx
   28a2f:	be 01 00 00 00       	mov    $0x1,%esi
   28a34:	4c 89 ef             	mov    %r13,%rdi
   28a37:	41 ff 55 30          	callq  *0x30(%r13)

        if(lv_obj_get_auto_realign(cont)) {
   28a3b:	48 89 df             	mov    %rbx,%rdi
   28a3e:	e8 c8 1f ff ff       	callq  1aa0b <lv_obj_get_auto_realign>
   28a43:	84 c0                	test   %al,%al
   28a45:	74 08                	je     28a4f <lv_cont_refr_autofit+0x42a>
            lv_obj_realign(cont);
   28a47:	48 89 df             	mov    %rbx,%rdi
   28a4a:	e8 21 1c ff ff       	callq  1a670 <lv_obj_realign>
        }

        /*Tell the children the parent's size has changed*/
        _LV_LL_READ(cont->child_ll, child_i) {
   28a4f:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
   28a54:	e8 12 d2 ff ff       	callq  25c6b <_lv_ll_get_head>
   28a59:	48 85 c0             	test   %rax,%rax
   28a5c:	48 89 c3             	mov    %rax,%rbx
   28a5f:	74 1f                	je     28a80 <lv_cont_refr_autofit+0x45b>
            child_i->signal_cb(child_i, LV_SIGNAL_PARENT_SIZE_CHG, &ori);
   28a61:	48 89 df             	mov    %rbx,%rdi
   28a64:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
   28a69:	be 03 00 00 00       	mov    $0x3,%esi
   28a6e:	ff 53 30             	callq  *0x30(%rbx)
        _LV_LL_READ(cont->child_ll, child_i) {
   28a71:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
   28a76:	48 89 de             	mov    %rbx,%rsi
   28a79:	e8 05 d2 ff ff       	callq  25c83 <_lv_ll_get_next>
   28a7e:	eb d9                	jmp    28a59 <lv_cont_refr_autofit+0x434>
        }
    }
}
   28a80:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
   28a85:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   28a8c:	00 00 
   28a8e:	74 05                	je     28a95 <lv_cont_refr_autofit+0x470>
   28a90:	e8 ab bb fd ff       	callq  4640 <__stack_chk_fail@plt>
   28a95:	48 83 c4 58          	add    $0x58,%rsp
   28a99:	5b                   	pop    %rbx
   28a9a:	5d                   	pop    %rbp
   28a9b:	41 5c                	pop    %r12
   28a9d:	41 5d                	pop    %r13
   28a9f:	41 5e                	pop    %r14
   28aa1:	41 5f                	pop    %r15
   28aa3:	c3                   	retq   

0000000000028aa4 <lv_cont_create>:
{
   28aa4:	41 55                	push   %r13
   28aa6:	41 54                	push   %r12
   28aa8:	49 89 fd             	mov    %rdi,%r13
   28aab:	55                   	push   %rbp
   28aac:	53                   	push   %rbx
   28aad:	49 89 f4             	mov    %rsi,%r12
   28ab0:	48 83 ec 08          	sub    $0x8,%rsp
    lv_obj_t * cont = lv_obj_create(par, copy);
   28ab4:	e8 df 25 ff ff       	callq  1b098 <lv_obj_create>
    if(cont == NULL) return NULL;
   28ab9:	48 85 c0             	test   %rax,%rax
    lv_obj_t * cont = lv_obj_create(par, copy);
   28abc:	48 89 c3             	mov    %rax,%rbx
    if(cont == NULL) return NULL;
   28abf:	0f 84 18 01 00 00    	je     28bdd <lv_cont_create+0x139>
    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(cont);
   28ac5:	48 83 3d 63 f5 22 00 	cmpq   $0x0,0x22f563(%rip)        # 258030 <ancestor_signal>
   28acc:	00 
   28acd:	75 0f                	jne    28ade <lv_cont_create+0x3a>
   28acf:	48 89 c7             	mov    %rax,%rdi
   28ad2:	e8 1e 38 ff ff       	callq  1c2f5 <lv_obj_get_signal_cb>
   28ad7:	48 89 05 52 f5 22 00 	mov    %rax,0x22f552(%rip)        # 258030 <ancestor_signal>
    if(ancestor_design == NULL) ancestor_design = lv_obj_get_design_cb(cont);
   28ade:	48 83 3d 52 f5 22 00 	cmpq   $0x0,0x22f552(%rip)        # 258038 <ancestor_design>
   28ae5:	00 
   28ae6:	75 0f                	jne    28af7 <lv_cont_create+0x53>
   28ae8:	48 89 df             	mov    %rbx,%rdi
   28aeb:	e8 0a 38 ff ff       	callq  1c2fa <lv_obj_get_design_cb>
   28af0:	48 89 05 41 f5 22 00 	mov    %rax,0x22f541(%rip)        # 258038 <ancestor_design>
    lv_obj_allocate_ext_attr(cont, sizeof(lv_cont_ext_t));
   28af7:	be 02 00 00 00       	mov    $0x2,%esi
   28afc:	48 89 df             	mov    %rbx,%rdi
   28aff:	e8 ed 1c ff ff       	callq  1a7f1 <lv_obj_allocate_ext_attr>
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
   28b04:	48 89 df             	mov    %rbx,%rdi
   28b07:	e8 f3 37 ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    if(ext == NULL) {
   28b0c:	48 85 c0             	test   %rax,%rax
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
   28b0f:	48 89 c5             	mov    %rax,%rbp
    if(ext == NULL) {
   28b12:	75 0f                	jne    28b23 <lv_cont_create+0x7f>
        lv_obj_del(cont);
   28b14:	48 89 df             	mov    %rbx,%rdi
        return NULL;
   28b17:	31 db                	xor    %ebx,%ebx
        lv_obj_del(cont);
   28b19:	e8 f5 21 ff ff       	callq  1ad13 <lv_obj_del>
        return NULL;
   28b1e:	e9 ba 00 00 00       	jmpq   28bdd <lv_cont_create+0x139>
    ext->fit_bottom = LV_FIT_NONE;
   28b23:	80 60 01 f0          	andb   $0xf0,0x1(%rax)
    lv_obj_set_signal_cb(cont, lv_cont_signal);
   28b27:	48 8d 35 e5 0a 00 00 	lea    0xae5(%rip),%rsi        # 29613 <lv_cont_signal>
    ext->layout     = LV_LAYOUT_OFF;
   28b2e:	c6 00 00             	movb   $0x0,(%rax)
    lv_obj_set_signal_cb(cont, lv_cont_signal);
   28b31:	48 89 df             	mov    %rbx,%rdi
   28b34:	e8 97 1c ff ff       	callq  1a7d0 <lv_obj_set_signal_cb>
    if(copy == NULL) {
   28b39:	4d 85 e4             	test   %r12,%r12
   28b3c:	75 14                	jne    28b52 <lv_cont_create+0xae>
        if(par != NULL) {
   28b3e:	4d 85 ed             	test   %r13,%r13
   28b41:	74 74                	je     28bb7 <lv_cont_create+0x113>
            lv_theme_apply(cont, LV_THEME_CONT);
   28b43:	be 04 00 00 00       	mov    $0x4,%esi
   28b48:	48 89 df             	mov    %rbx,%rdi
   28b4b:	e8 19 ea ff ff       	callq  27569 <lv_theme_apply>
   28b50:	eb 65                	jmp    28bb7 <lv_cont_create+0x113>
        lv_cont_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
   28b52:	4c 89 e7             	mov    %r12,%rdi
   28b55:	e8 a5 37 ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
        ext->fit_left            = copy_ext->fit_left;
   28b5a:	8a 55 00             	mov    0x0(%rbp),%dl
   28b5d:	8a 08                	mov    (%rax),%cl
        lv_obj_refresh_style(cont, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
   28b5f:	48 89 df             	mov    %rbx,%rdi
        ext->fit_left            = copy_ext->fit_left;
   28b62:	83 e1 30             	and    $0x30,%ecx
   28b65:	83 e2 cf             	and    $0xffffffcf,%edx
   28b68:	09 ca                	or     %ecx,%edx
   28b6a:	88 55 00             	mov    %dl,0x0(%rbp)
        ext->fit_right           = copy_ext->fit_right;
   28b6d:	8a 08                	mov    (%rax),%cl
   28b6f:	83 e2 3f             	and    $0x3f,%edx
   28b72:	83 e1 c0             	and    $0xffffffc0,%ecx
   28b75:	09 ca                	or     %ecx,%edx
        ext->fit_top             = copy_ext->fit_top;
   28b77:	8a 4d 01             	mov    0x1(%rbp),%cl
        ext->fit_right           = copy_ext->fit_right;
   28b7a:	88 55 00             	mov    %dl,0x0(%rbp)
        ext->fit_top             = copy_ext->fit_top;
   28b7d:	40 8a 70 01          	mov    0x1(%rax),%sil
        ext->layout              = copy_ext->layout;
   28b81:	83 e2 f0             	and    $0xfffffff0,%edx
        ext->fit_top             = copy_ext->fit_top;
   28b84:	83 e1 fc             	and    $0xfffffffc,%ecx
   28b87:	83 e6 03             	and    $0x3,%esi
   28b8a:	09 f1                	or     %esi,%ecx
   28b8c:	88 4d 01             	mov    %cl,0x1(%rbp)
        ext->fit_bottom          = copy_ext->fit_bottom;
   28b8f:	40 8a 70 01          	mov    0x1(%rax),%sil
   28b93:	83 e1 f3             	and    $0xfffffff3,%ecx
   28b96:	83 e6 0c             	and    $0xc,%esi
   28b99:	09 f1                	or     %esi,%ecx
        lv_obj_refresh_style(cont, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
   28b9b:	be ff 00 00 00       	mov    $0xff,%esi
        ext->fit_bottom          = copy_ext->fit_bottom;
   28ba0:	88 4d 01             	mov    %cl,0x1(%rbp)
        ext->layout              = copy_ext->layout;
   28ba3:	8a 00                	mov    (%rax),%al
   28ba5:	83 e0 0f             	and    $0xf,%eax
   28ba8:	09 c2                	or     %eax,%edx
   28baa:	88 55 00             	mov    %dl,0x0(%rbp)
        lv_obj_refresh_style(cont, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
   28bad:	ba ff 00 00 00       	mov    $0xff,%edx
   28bb2:	e8 2d 35 ff ff       	callq  1c0e4 <lv_obj_refresh_style>
    LV_LOG_INFO("container created");
   28bb7:	4c 8d 05 a6 b2 00 00 	lea    0xb2a6(%rip),%r8        # 33e64 <_lv_bpp1_opa_table+0x60f>
   28bbe:	48 8d 0d a3 80 00 00 	lea    0x80a3(%rip),%rcx        # 30c68 <__func__.5785>
   28bc5:	48 8d 35 aa b2 00 00 	lea    0xb2aa(%rip),%rsi        # 33e76 <_lv_bpp1_opa_table+0x621>
   28bcc:	ba 76 00 00 00       	mov    $0x76,%edx
   28bd1:	bf 01 00 00 00       	mov    $0x1,%edi
   28bd6:	31 c0                	xor    %eax,%eax
   28bd8:	e8 79 d3 ff ff       	callq  25f56 <_lv_log_add>
}
   28bdd:	5a                   	pop    %rdx
   28bde:	48 89 d8             	mov    %rbx,%rax
   28be1:	5b                   	pop    %rbx
   28be2:	5d                   	pop    %rbp
   28be3:	41 5c                	pop    %r12
   28be5:	41 5d                	pop    %r13
   28be7:	c3                   	retq   

0000000000028be8 <lv_cont_set_layout>:
{
   28be8:	55                   	push   %rbp
   28be9:	53                   	push   %rbx
   28bea:	48 89 fd             	mov    %rdi,%rbp
   28bed:	89 f3                	mov    %esi,%ebx
   28bef:	48 83 ec 08          	sub    $0x8,%rsp
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
   28bf3:	e8 07 37 ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    if(ext->layout == layout) return;
   28bf8:	8a 10                	mov    (%rax),%dl
   28bfa:	0f b6 cb             	movzbl %bl,%ecx
   28bfd:	89 d6                	mov    %edx,%esi
   28bff:	83 e6 0f             	and    $0xf,%esi
   28c02:	39 ce                	cmp    %ecx,%esi
   28c04:	74 1d                	je     28c23 <lv_cont_set_layout+0x3b>
    ext->layout = layout;
   28c06:	83 e3 0f             	and    $0xf,%ebx
   28c09:	83 e2 f0             	and    $0xfffffff0,%edx
    cont->signal_cb(cont, LV_SIGNAL_CHILD_CHG, NULL);
   28c0c:	48 89 ef             	mov    %rbp,%rdi
    ext->layout = layout;
   28c0f:	09 da                	or     %ebx,%edx
    cont->signal_cb(cont, LV_SIGNAL_CHILD_CHG, NULL);
   28c11:	be 01 00 00 00       	mov    $0x1,%esi
    ext->layout = layout;
   28c16:	88 10                	mov    %dl,(%rax)
    cont->signal_cb(cont, LV_SIGNAL_CHILD_CHG, NULL);
   28c18:	48 8b 45 30          	mov    0x30(%rbp),%rax
   28c1c:	31 d2                	xor    %edx,%edx
}
   28c1e:	59                   	pop    %rcx
   28c1f:	5b                   	pop    %rbx
   28c20:	5d                   	pop    %rbp
    cont->signal_cb(cont, LV_SIGNAL_CHILD_CHG, NULL);
   28c21:	ff e0                	jmpq   *%rax
}
   28c23:	58                   	pop    %rax
   28c24:	5b                   	pop    %rbx
   28c25:	5d                   	pop    %rbp
   28c26:	c3                   	retq   

0000000000028c27 <lv_cont_set_fit4>:
{
   28c27:	41 55                	push   %r13
   28c29:	41 54                	push   %r12
   28c2b:	41 89 cd             	mov    %ecx,%r13d
   28c2e:	55                   	push   %rbp
   28c2f:	53                   	push   %rbx
   28c30:	48 89 fb             	mov    %rdi,%rbx
   28c33:	89 f5                	mov    %esi,%ebp
   28c35:	41 89 d4             	mov    %edx,%r12d
   28c38:	48 83 ec 18          	sub    $0x18,%rsp
   28c3c:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
    lv_obj_invalidate(cont);
   28c41:	e8 6c 20 ff ff       	callq  1acb2 <lv_obj_invalidate>
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
   28c46:	48 89 df             	mov    %rbx,%rdi
   28c49:	e8 b1 36 ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    if(ext->fit_left == left && ext->fit_right == right && ext->fit_top == top && ext->fit_bottom == bottom) {
   28c4e:	8a 10                	mov    (%rax),%dl
   28c50:	40 0f b6 fd          	movzbl %bpl,%edi
   28c54:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
   28c59:	40 88 d6             	mov    %dl,%sil
   28c5c:	40 c0 ee 04          	shr    $0x4,%sil
   28c60:	83 e6 03             	and    $0x3,%esi
   28c63:	39 fe                	cmp    %edi,%esi
   28c65:	75 2e                	jne    28c95 <lv_cont_set_fit4+0x6e>
   28c67:	c0 ea 06             	shr    $0x6,%dl
   28c6a:	41 0f b6 f4          	movzbl %r12b,%esi
   28c6e:	0f b6 d2             	movzbl %dl,%edx
   28c71:	39 f2                	cmp    %esi,%edx
   28c73:	75 20                	jne    28c95 <lv_cont_set_fit4+0x6e>
   28c75:	40 8a 78 01          	mov    0x1(%rax),%dil
   28c79:	41 0f b6 d5          	movzbl %r13b,%edx
   28c7d:	89 fe                	mov    %edi,%esi
   28c7f:	83 e6 03             	and    $0x3,%esi
   28c82:	39 d6                	cmp    %edx,%esi
   28c84:	75 0f                	jne    28c95 <lv_cont_set_fit4+0x6e>
   28c86:	40 c0 ef 02          	shr    $0x2,%dil
   28c8a:	41 0f b6 d0          	movzbl %r8b,%edx
   28c8e:	83 e7 03             	and    $0x3,%edi
   28c91:	39 d7                	cmp    %edx,%edi
   28c93:	74 50                	je     28ce5 <lv_cont_set_fit4+0xbe>
    ext->fit_left   = left;
   28c95:	40 8a 38             	mov    (%rax),%dil
   28c98:	83 e5 03             	and    $0x3,%ebp
    ext->fit_top    = top;
   28c9b:	8a 48 01             	mov    0x1(%rax),%cl
    ext->fit_left   = left;
   28c9e:	c1 e5 04             	shl    $0x4,%ebp
    ext->fit_right  = right;
   28ca1:	41 c1 e4 06          	shl    $0x6,%r12d
    ext->fit_bottom = bottom;
   28ca5:	41 83 e0 03          	and    $0x3,%r8d
   28ca9:	41 c1 e0 02          	shl    $0x2,%r8d
    cont->signal_cb(cont, LV_SIGNAL_CHILD_CHG, NULL);
   28cad:	be 01 00 00 00       	mov    $0x1,%esi
    ext->fit_left   = left;
   28cb2:	83 e7 0f             	and    $0xf,%edi
    ext->fit_top    = top;
   28cb5:	83 e1 f0             	and    $0xfffffff0,%ecx
    ext->fit_right  = right;
   28cb8:	09 ef                	or     %ebp,%edi
   28cba:	40 88 fa             	mov    %dil,%dl
    cont->signal_cb(cont, LV_SIGNAL_CHILD_CHG, NULL);
   28cbd:	48 89 df             	mov    %rbx,%rdi
    ext->fit_right  = right;
   28cc0:	44 09 e2             	or     %r12d,%edx
   28cc3:	88 10                	mov    %dl,(%rax)
    ext->fit_top    = top;
   28cc5:	44 88 ea             	mov    %r13b,%dl
   28cc8:	83 e2 03             	and    $0x3,%edx
    ext->fit_bottom = bottom;
   28ccb:	09 d1                	or     %edx,%ecx
    cont->signal_cb(cont, LV_SIGNAL_CHILD_CHG, NULL);
   28ccd:	31 d2                	xor    %edx,%edx
    ext->fit_bottom = bottom;
   28ccf:	44 09 c1             	or     %r8d,%ecx
   28cd2:	88 48 01             	mov    %cl,0x1(%rax)
    cont->signal_cb(cont, LV_SIGNAL_CHILD_CHG, NULL);
   28cd5:	48 8b 43 30          	mov    0x30(%rbx),%rax
}
   28cd9:	48 83 c4 18          	add    $0x18,%rsp
   28cdd:	5b                   	pop    %rbx
   28cde:	5d                   	pop    %rbp
   28cdf:	41 5c                	pop    %r12
   28ce1:	41 5d                	pop    %r13
    cont->signal_cb(cont, LV_SIGNAL_CHILD_CHG, NULL);
   28ce3:	ff e0                	jmpq   *%rax
}
   28ce5:	48 83 c4 18          	add    $0x18,%rsp
   28ce9:	5b                   	pop    %rbx
   28cea:	5d                   	pop    %rbp
   28ceb:	41 5c                	pop    %r12
   28ced:	41 5d                	pop    %r13
   28cef:	c3                   	retq   

0000000000028cf0 <lv_cont_get_layout>:
{
   28cf0:	48 83 ec 08          	sub    $0x8,%rsp
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
   28cf4:	e8 06 36 ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    return ext->layout;
   28cf9:	8a 00                	mov    (%rax),%al
}
   28cfb:	5a                   	pop    %rdx
    return ext->layout;
   28cfc:	83 e0 0f             	and    $0xf,%eax
}
   28cff:	c3                   	retq   

0000000000028d00 <lv_cont_refr_layout>:
{
   28d00:	41 57                	push   %r15
   28d02:	41 56                	push   %r14
    if(lv_obj_is_protected(cont, LV_PROTECT_CHILD_CHG)) return;
   28d04:	be 01 00 00 00       	mov    $0x1,%esi
{
   28d09:	41 55                	push   %r13
   28d0b:	41 54                	push   %r12
   28d0d:	49 89 ff             	mov    %rdi,%r15
   28d10:	55                   	push   %rbp
   28d11:	53                   	push   %rbx
   28d12:	48 83 ec 38          	sub    $0x38,%rsp
    if(lv_obj_is_protected(cont, LV_PROTECT_CHILD_CHG)) return;
   28d16:	e8 ab 28 ff ff       	callq  1b5c6 <lv_obj_is_protected>
   28d1b:	84 c0                	test   %al,%al
   28d1d:	0f 85 e1 08 00 00    	jne    29604 <lv_cont_refr_layout+0x904>
    lv_layout_t type = lv_cont_get_layout(cont);
   28d23:	4c 89 ff             	mov    %r15,%rdi
   28d26:	e8 c5 ff ff ff       	callq  28cf0 <lv_cont_get_layout>
    if(lv_obj_get_child(cont, NULL) == NULL) return;
   28d2b:	31 f6                	xor    %esi,%esi
    lv_layout_t type = lv_cont_get_layout(cont);
   28d2d:	88 c3                	mov    %al,%bl
    if(lv_obj_get_child(cont, NULL) == NULL) return;
   28d2f:	4c 89 ff             	mov    %r15,%rdi
   28d32:	e8 68 1c ff ff       	callq  1a99f <lv_obj_get_child>
    if(type == LV_LAYOUT_OFF) return;
   28d37:	84 db                	test   %bl,%bl
   28d39:	0f 84 c5 08 00 00    	je     29604 <lv_cont_refr_layout+0x904>
   28d3f:	48 85 c0             	test   %rax,%rax
   28d42:	0f 84 bc 08 00 00    	je     29604 <lv_cont_refr_layout+0x904>
    if(type == LV_LAYOUT_CENTER) {
   28d48:	80 fb 01             	cmp    $0x1,%bl
   28d4b:	0f 85 15 01 00 00    	jne    28e66 <lv_cont_refr_layout+0x166>
    _LV_LL_READ(cont->child_ll, child) {
   28d51:	4d 8d 6f 08          	lea    0x8(%r15),%r13
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   28d55:	ba 14 00 00 00       	mov    $0x14,%edx
   28d5a:	31 f6                	xor    %esi,%esi
   28d5c:	4c 89 ff             	mov    %r15,%rdi
    lv_coord_t h_tot         = 0;
   28d5f:	31 db                	xor    %ebx,%ebx
    uint32_t obj_num         = 0;
   28d61:	45 31 f6             	xor    %r14d,%r14d
   28d64:	e8 84 29 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    _LV_LL_READ(cont->child_ll, child) {
   28d69:	4c 89 ef             	mov    %r13,%rdi
   28d6c:	44 0f bf e0          	movswl %ax,%r12d
   28d70:	e8 f6 ce ff ff       	callq  25c6b <_lv_ll_get_head>
   28d75:	48 89 c5             	mov    %rax,%rbp
        h_tot += lv_obj_get_height(child) + inner;
   28d78:	41 0f bf c4          	movswl %r12w,%eax
   28d7c:	89 44 24 08          	mov    %eax,0x8(%rsp)
    _LV_LL_READ(cont->child_ll, child) {
   28d80:	48 85 ed             	test   %rbp,%rbp
   28d83:	74 3e                	je     28dc3 <lv_cont_refr_layout+0xc3>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
   28d85:	48 89 ef             	mov    %rbp,%rdi
   28d88:	e8 a9 1d ff ff       	callq  1ab36 <lv_obj_get_hidden>
   28d8d:	84 c0                	test   %al,%al
   28d8f:	75 22                	jne    28db3 <lv_cont_refr_layout+0xb3>
   28d91:	be 04 00 00 00       	mov    $0x4,%esi
   28d96:	48 89 ef             	mov    %rbp,%rdi
   28d99:	e8 28 28 ff ff       	callq  1b5c6 <lv_obj_is_protected>
   28d9e:	84 c0                	test   %al,%al
   28da0:	75 11                	jne    28db3 <lv_cont_refr_layout+0xb3>
        h_tot += lv_obj_get_height(child) + inner;
   28da2:	48 89 ef             	mov    %rbp,%rdi
        obj_num++;
   28da5:	41 ff c6             	inc    %r14d
        h_tot += lv_obj_get_height(child) + inner;
   28da8:	e8 53 1c ff ff       	callq  1aa00 <lv_obj_get_height>
   28dad:	01 c3                	add    %eax,%ebx
   28daf:	03 5c 24 08          	add    0x8(%rsp),%ebx
    _LV_LL_READ(cont->child_ll, child) {
   28db3:	48 89 ee             	mov    %rbp,%rsi
   28db6:	4c 89 ef             	mov    %r13,%rdi
   28db9:	e8 c5 ce ff ff       	callq  25c83 <_lv_ll_get_next>
   28dbe:	48 89 c5             	mov    %rax,%rbp
   28dc1:	eb bd                	jmp    28d80 <lv_cont_refr_layout+0x80>
    if(obj_num == 0) return;
   28dc3:	45 85 f6             	test   %r14d,%r14d
   28dc6:	0f 84 38 08 00 00    	je     29604 <lv_cont_refr_layout+0x904>
    h_tot -= inner;
   28dcc:	44 29 e3             	sub    %r12d,%ebx
    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
   28dcf:	4c 89 ff             	mov    %r15,%rdi
   28dd2:	be 01 00 00 00       	mov    $0x1,%esi
   28dd7:	e8 ce 18 ff ff       	callq  1a6aa <lv_obj_add_protect>
    lv_coord_t last_cord = -(h_tot / 2);
   28ddc:	89 da                	mov    %ebx,%edx
   28dde:	89 d8                	mov    %ebx,%eax
   28de0:	b9 02 00 00 00       	mov    $0x2,%ecx
   28de5:	66 c1 fa 0f          	sar    $0xf,%dx
    _LV_LL_READ_BACK(cont->child_ll, child) {
   28de9:	4c 89 ef             	mov    %r13,%rdi
    lv_coord_t last_cord = -(h_tot / 2);
   28dec:	66 f7 f9             	idiv   %cx
   28def:	89 c3                	mov    %eax,%ebx
   28df1:	f7 db                	neg    %ebx
    _LV_LL_READ_BACK(cont->child_ll, child) {
   28df3:	e8 7f ce ff ff       	callq  25c77 <_lv_ll_get_tail>
   28df8:	48 85 c0             	test   %rax,%rax
   28dfb:	48 89 c5             	mov    %rax,%rbp
   28dfe:	0f 84 fb 00 00 00    	je     28eff <lv_cont_refr_layout+0x1ff>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
   28e04:	48 89 ef             	mov    %rbp,%rdi
   28e07:	e8 2a 1d ff ff       	callq  1ab36 <lv_obj_get_hidden>
   28e0c:	84 c0                	test   %al,%al
   28e0e:	75 49                	jne    28e59 <lv_cont_refr_layout+0x159>
   28e10:	be 04 00 00 00       	mov    $0x4,%esi
   28e15:	48 89 ef             	mov    %rbp,%rdi
   28e18:	e8 a9 27 ff ff       	callq  1b5c6 <lv_obj_is_protected>
   28e1d:	84 c0                	test   %al,%al
   28e1f:	75 38                	jne    28e59 <lv_cont_refr_layout+0x159>
        lv_obj_align(child, cont, LV_ALIGN_CENTER, 0, last_cord + lv_obj_get_height(child) / 2);
   28e21:	48 89 ef             	mov    %rbp,%rdi
   28e24:	e8 d7 1b ff ff       	callq  1aa00 <lv_obj_get_height>
   28e29:	89 c2                	mov    %eax,%edx
   28e2b:	b9 02 00 00 00       	mov    $0x2,%ecx
   28e30:	4c 89 fe             	mov    %r15,%rsi
   28e33:	66 c1 fa 0f          	sar    $0xf,%dx
   28e37:	48 89 ef             	mov    %rbp,%rdi
   28e3a:	66 f7 f9             	idiv   %cx
   28e3d:	31 c9                	xor    %ecx,%ecx
   28e3f:	31 d2                	xor    %edx,%edx
   28e41:	01 d8                	add    %ebx,%eax
   28e43:	44 0f bf c0          	movswl %ax,%r8d
   28e47:	e8 6e 21 ff ff       	callq  1afba <lv_obj_align>
        last_cord += lv_obj_get_height(child) + inner;
   28e4c:	48 89 ef             	mov    %rbp,%rdi
   28e4f:	e8 ac 1b ff ff       	callq  1aa00 <lv_obj_get_height>
   28e54:	01 c3                	add    %eax,%ebx
   28e56:	44 01 e3             	add    %r12d,%ebx
    _LV_LL_READ_BACK(cont->child_ll, child) {
   28e59:	48 89 ee             	mov    %rbp,%rsi
   28e5c:	4c 89 ef             	mov    %r13,%rdi
   28e5f:	e8 2e ce ff ff       	callq  25c92 <_lv_ll_get_prev>
   28e64:	eb 92                	jmp    28df8 <lv_cont_refr_layout+0xf8>
    else if(type == LV_LAYOUT_COLUMN_LEFT || type == LV_LAYOUT_COLUMN_MID || type == LV_LAYOUT_COLUMN_RIGHT) {
   28e66:	8d 43 fe             	lea    -0x2(%rbx),%eax
   28e69:	3c 02                	cmp    $0x2,%al
   28e6b:	0f 87 5c 01 00 00    	ja     28fcd <lv_cont_refr_layout+0x2cd>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   28e71:	31 f6                	xor    %esi,%esi
   28e73:	ba 12 00 00 00       	mov    $0x12,%edx
   28e78:	4c 89 ff             	mov    %r15,%rdi
   28e7b:	e8 6d 28 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   28e80:	31 f6                	xor    %esi,%esi
   28e82:	ba 13 00 00 00       	mov    $0x13,%edx
   28e87:	4c 89 ff             	mov    %r15,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   28e8a:	89 c5                	mov    %eax,%ebp
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   28e8c:	e8 5c 28 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   28e91:	31 f6                	xor    %esi,%esi
   28e93:	ba 10 00 00 00       	mov    $0x10,%edx
   28e98:	4c 89 ff             	mov    %r15,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   28e9b:	89 c3                	mov    %eax,%ebx
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   28e9d:	e8 4b 28 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   28ea2:	31 f6                	xor    %esi,%esi
   28ea4:	ba 14 00 00 00       	mov    $0x14,%edx
   28ea9:	4c 89 ff             	mov    %r15,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   28eac:	41 89 c5             	mov    %eax,%r13d
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   28eaf:	e8 39 28 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    lv_layout_t type = lv_cont_get_layout(cont);
   28eb4:	4c 89 ff             	mov    %r15,%rdi
   28eb7:	66 89 44 24 08       	mov    %ax,0x8(%rsp)
   28ebc:	e8 2f fe ff ff       	callq  28cf0 <lv_cont_get_layout>
    switch(type) {
   28ec1:	3c 03                	cmp    $0x3,%al
   28ec3:	74 5e                	je     28f23 <lv_cont_refr_layout+0x223>
   28ec5:	3c 04                	cmp    $0x4,%al
   28ec7:	74 51                	je     28f1a <lv_cont_refr_layout+0x21a>
            hpad_corr = 0;
   28ec9:	3c 02                	cmp    $0x2,%al
   28ecb:	b8 00 00 00 00       	mov    $0x0,%eax
   28ed0:	41 b4 01             	mov    $0x1,%r12b
   28ed3:	0f 45 e8             	cmovne %eax,%ebp
    _LV_LL_READ_BACK(cont->child_ll, child) {
   28ed6:	4d 8d 77 08          	lea    0x8(%r15),%r14
    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
   28eda:	be 01 00 00 00       	mov    $0x1,%esi
   28edf:	4c 89 ff             	mov    %r15,%rdi
   28ee2:	e8 c3 17 ff ff       	callq  1a6aa <lv_obj_add_protect>
    _LV_LL_READ_BACK(cont->child_ll, child) {
   28ee7:	4c 89 f7             	mov    %r14,%rdi
   28eea:	e8 88 cd ff ff       	callq  25c77 <_lv_ll_get_tail>
   28eef:	48 89 c3             	mov    %rax,%rbx
        lv_obj_align(child, cont, align, hpad_corr + mleft, last_cord + mtop);
   28ef2:	41 0f b6 c4          	movzbl %r12b,%eax
   28ef6:	89 44 24 10          	mov    %eax,0x10(%rsp)
    _LV_LL_READ_BACK(cont->child_ll, child) {
   28efa:	48 85 db             	test   %rbx,%rbx
   28efd:	75 2b                	jne    28f2a <lv_cont_refr_layout+0x22a>
}
   28eff:	48 83 c4 38          	add    $0x38,%rsp
    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
   28f03:	4c 89 ff             	mov    %r15,%rdi
   28f06:	be 01 00 00 00       	mov    $0x1,%esi
}
   28f0b:	5b                   	pop    %rbx
   28f0c:	5d                   	pop    %rbp
   28f0d:	41 5c                	pop    %r12
   28f0f:	41 5d                	pop    %r13
   28f11:	41 5e                	pop    %r14
   28f13:	41 5f                	pop    %r15
    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
   28f15:	e9 95 17 ff ff       	jmpq   1a6af <lv_obj_clear_protect>
            hpad_corr = -right;
   28f1a:	f7 db                	neg    %ebx
            align     = LV_ALIGN_IN_TOP_RIGHT;
   28f1c:	41 b4 03             	mov    $0x3,%r12b
            hpad_corr = -right;
   28f1f:	89 dd                	mov    %ebx,%ebp
   28f21:	eb b3                	jmp    28ed6 <lv_cont_refr_layout+0x1d6>
            hpad_corr = 0;
   28f23:	31 ed                	xor    %ebp,%ebp
            align     = LV_ALIGN_IN_TOP_MID;
   28f25:	41 b4 02             	mov    $0x2,%r12b
   28f28:	eb ac                	jmp    28ed6 <lv_cont_refr_layout+0x1d6>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
   28f2a:	48 89 df             	mov    %rbx,%rdi
   28f2d:	e8 04 1c ff ff       	callq  1ab36 <lv_obj_get_hidden>
   28f32:	84 c0                	test   %al,%al
   28f34:	0f 85 80 00 00 00    	jne    28fba <lv_cont_refr_layout+0x2ba>
   28f3a:	be 04 00 00 00       	mov    $0x4,%esi
   28f3f:	48 89 df             	mov    %rbx,%rdi
   28f42:	e8 7f 26 ff ff       	callq  1b5c6 <lv_obj_is_protected>
   28f47:	84 c0                	test   %al,%al
   28f49:	75 6f                	jne    28fba <lv_cont_refr_layout+0x2ba>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
   28f4b:	ba 15 00 00 00       	mov    $0x15,%edx
   28f50:	31 f6                	xor    %esi,%esi
   28f52:	48 89 df             	mov    %rbx,%rdi
   28f55:	e8 93 27 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
   28f5a:	ba 16 00 00 00       	mov    $0x16,%edx
   28f5f:	31 f6                	xor    %esi,%esi
   28f61:	48 89 df             	mov    %rbx,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
   28f64:	44 0f bf e0          	movswl %ax,%r12d
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
   28f68:	e8 80 27 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
   28f6d:	ba 17 00 00 00       	mov    $0x17,%edx
   28f72:	31 f6                	xor    %esi,%esi
   28f74:	48 89 df             	mov    %rbx,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
   28f77:	66 89 44 24 18       	mov    %ax,0x18(%rsp)
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
   28f7c:	e8 6c 27 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
        lv_obj_align(child, cont, align, hpad_corr + mleft, last_cord + mtop);
   28f81:	47 8d 04 2c          	lea    (%r12,%r13,1),%r8d
   28f85:	8d 4c 05 00          	lea    0x0(%rbp,%rax,1),%ecx
   28f89:	8b 54 24 10          	mov    0x10(%rsp),%edx
   28f8d:	4c 89 fe             	mov    %r15,%rsi
   28f90:	48 89 df             	mov    %rbx,%rdi
   28f93:	0f bf c9             	movswl %cx,%ecx
   28f96:	45 0f bf c0          	movswl %r8w,%r8d
   28f9a:	e8 1b 20 ff ff       	callq  1afba <lv_obj_align>
        last_cord += lv_obj_get_height(child) + inner + mtop + mbottom;
   28f9f:	48 89 df             	mov    %rbx,%rdi
   28fa2:	e8 59 1a ff ff       	callq  1aa00 <lv_obj_get_height>
   28fa7:	0f bf 54 24 08       	movswl 0x8(%rsp),%edx
   28fac:	44 03 6c 24 18       	add    0x18(%rsp),%r13d
   28fb1:	98                   	cwtl   
   28fb2:	01 d0                	add    %edx,%eax
   28fb4:	41 01 c4             	add    %eax,%r12d
   28fb7:	45 01 e5             	add    %r12d,%r13d
    _LV_LL_READ_BACK(cont->child_ll, child) {
   28fba:	48 89 de             	mov    %rbx,%rsi
   28fbd:	4c 89 f7             	mov    %r14,%rdi
   28fc0:	e8 cd cc ff ff       	callq  25c92 <_lv_ll_get_prev>
   28fc5:	48 89 c3             	mov    %rax,%rbx
   28fc8:	e9 2d ff ff ff       	jmpq   28efa <lv_cont_refr_layout+0x1fa>
    else if(type == LV_LAYOUT_ROW_TOP || type == LV_LAYOUT_ROW_MID || type == LV_LAYOUT_ROW_BOTTOM) {
   28fcd:	8d 43 fb             	lea    -0x5(%rbx),%eax
   28fd0:	3c 02                	cmp    $0x2,%al
   28fd2:	0f 87 2c 01 00 00    	ja     29104 <lv_cont_refr_layout+0x404>
    lv_layout_t type = lv_cont_get_layout(cont);
   28fd8:	4c 89 ff             	mov    %r15,%rdi
   28fdb:	e8 10 fd ff ff       	callq  28cf0 <lv_cont_get_layout>
    lv_bidi_dir_t base_dir = lv_obj_get_base_dir(cont);
   28fe0:	4c 89 ff             	mov    %r15,%rdi
    lv_layout_t type = lv_cont_get_layout(cont);
   28fe3:	88 c3                	mov    %al,%bl
    lv_bidi_dir_t base_dir = lv_obj_get_base_dir(cont);
   28fe5:	e8 ab 20 ff ff       	callq  1b095 <lv_obj_get_base_dir>
    switch(type) {
   28fea:	80 fb 06             	cmp    $0x6,%bl
    lv_bidi_dir_t base_dir = lv_obj_get_base_dir(cont);
   28fed:	41 88 c5             	mov    %al,%r13b
    switch(type) {
   28ff0:	74 20                	je     29012 <lv_cont_refr_layout+0x312>
   28ff2:	80 fb 07             	cmp    $0x7,%bl
   28ff5:	74 27                	je     2901e <lv_cont_refr_layout+0x31e>
            vpad_corr = 0;
   28ff7:	31 ed                	xor    %ebp,%ebp
    switch(type) {
   28ff9:	80 fb 05             	cmp    $0x5,%bl
   28ffc:	75 41                	jne    2903f <lv_cont_refr_layout+0x33f>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   28ffe:	ba 10 00 00 00       	mov    $0x10,%edx
   29003:	31 f6                	xor    %esi,%esi
   29005:	4c 89 ff             	mov    %r15,%rdi
   29008:	e8 e0 26 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
   2900d:	0f bf e8             	movswl %ax,%ebp
   29010:	eb 2d                	jmp    2903f <lv_cont_refr_layout+0x33f>
            vpad_corr = 0;
   29012:	31 ed                	xor    %ebp,%ebp
   29014:	3c 01                	cmp    $0x1,%al
   29016:	0f 94 c3             	sete   %bl
   29019:	83 c3 07             	add    $0x7,%ebx
   2901c:	eb 2c                	jmp    2904a <lv_cont_refr_layout+0x34a>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   2901e:	31 f6                	xor    %esi,%esi
   29020:	ba 11 00 00 00       	mov    $0x11,%edx
   29025:	4c 89 ff             	mov    %r15,%rdi
   29028:	e8 c0 26 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
            vpad_corr = -lv_obj_get_style_pad_bottom(cont, LV_CONT_PART_MAIN);
   2902d:	f7 d8                	neg    %eax
            align     = base_dir == LV_BIDI_DIR_RTL ? LV_ALIGN_IN_BOTTOM_RIGHT : LV_ALIGN_IN_BOTTOM_LEFT;
   2902f:	41 80 fd 01          	cmp    $0x1,%r13b
   29033:	0f 94 c3             	sete   %bl
            vpad_corr = -lv_obj_get_style_pad_bottom(cont, LV_CONT_PART_MAIN);
   29036:	0f bf e8             	movswl %ax,%ebp
            align     = base_dir == LV_BIDI_DIR_RTL ? LV_ALIGN_IN_BOTTOM_RIGHT : LV_ALIGN_IN_BOTTOM_LEFT;
   29039:	8d 5c 1b 04          	lea    0x4(%rbx,%rbx,1),%ebx
   2903d:	eb 0b                	jmp    2904a <lv_cont_refr_layout+0x34a>
            vpad_corr = 0;
   2903f:	41 80 fd 01          	cmp    $0x1,%r13b
   29043:	0f 94 c3             	sete   %bl
   29046:	8d 5c 1b 01          	lea    0x1(%rbx,%rbx,1),%ebx
    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
   2904a:	be 01 00 00 00       	mov    $0x1,%esi
   2904f:	4c 89 ff             	mov    %r15,%rdi
   29052:	e8 53 16 ff ff       	callq  1a6aa <lv_obj_add_protect>
    if(base_dir == LV_BIDI_DIR_RTL) last_cord = lv_obj_get_style_pad_right(cont, LV_CONT_PART_MAIN);
   29057:	41 80 fd 01          	cmp    $0x1,%r13b
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   2905b:	ba 13 00 00 00       	mov    $0x13,%edx
   29060:	74 05                	je     29067 <lv_cont_refr_layout+0x367>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   29062:	ba 12 00 00 00       	mov    $0x12,%edx
   29067:	31 f6                	xor    %esi,%esi
   29069:	4c 89 ff             	mov    %r15,%rdi
   2906c:	e8 7c 26 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   29071:	4c 89 ff             	mov    %r15,%rdi
   29074:	ba 14 00 00 00       	mov    $0x14,%edx
   29079:	31 f6                	xor    %esi,%esi
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   2907b:	41 89 c6             	mov    %eax,%r14d
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   2907e:	e8 6a 26 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
   29083:	66 89 44 24 18       	mov    %ax,0x18(%rsp)
    _LV_LL_READ_BACK(cont->child_ll, child) {
   29088:	49 8d 47 08          	lea    0x8(%r15),%rax
   2908c:	48 89 c7             	mov    %rax,%rdi
   2908f:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   29094:	e8 de cb ff ff       	callq  25c77 <_lv_ll_get_tail>
   29099:	48 85 c0             	test   %rax,%rax
   2909c:	49 89 c4             	mov    %rax,%r12
   2909f:	0f 84 5a fe ff ff    	je     28eff <lv_cont_refr_layout+0x1ff>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
   290a5:	4c 89 e7             	mov    %r12,%rdi
   290a8:	e8 89 1a ff ff       	callq  1ab36 <lv_obj_get_hidden>
   290ad:	84 c0                	test   %al,%al
   290af:	75 44                	jne    290f5 <lv_cont_refr_layout+0x3f5>
   290b1:	be 04 00 00 00       	mov    $0x4,%esi
   290b6:	4c 89 e7             	mov    %r12,%rdi
   290b9:	e8 08 25 ff ff       	callq  1b5c6 <lv_obj_is_protected>
   290be:	84 c0                	test   %al,%al
   290c0:	75 33                	jne    290f5 <lv_cont_refr_layout+0x3f5>
        if(base_dir == LV_BIDI_DIR_RTL) lv_obj_align(child, cont, align, -last_cord, vpad_corr);
   290c2:	41 80 fd 01          	cmp    $0x1,%r13b
   290c6:	0f b6 d3             	movzbl %bl,%edx
        else lv_obj_align(child, cont, align, last_cord, vpad_corr);
   290c9:	41 0f bf ce          	movswl %r14w,%ecx
        if(base_dir == LV_BIDI_DIR_RTL) lv_obj_align(child, cont, align, -last_cord, vpad_corr);
   290cd:	75 08                	jne    290d7 <lv_cont_refr_layout+0x3d7>
   290cf:	44 89 f1             	mov    %r14d,%ecx
   290d2:	f7 d9                	neg    %ecx
   290d4:	0f bf c9             	movswl %cx,%ecx
        else lv_obj_align(child, cont, align, last_cord, vpad_corr);
   290d7:	41 89 e8             	mov    %ebp,%r8d
   290da:	4c 89 fe             	mov    %r15,%rsi
   290dd:	4c 89 e7             	mov    %r12,%rdi
   290e0:	e8 d5 1e ff ff       	callq  1afba <lv_obj_align>
        last_cord += lv_obj_get_width(child) + inner;
   290e5:	4c 89 e7             	mov    %r12,%rdi
   290e8:	e8 08 19 ff ff       	callq  1a9f5 <lv_obj_get_width>
   290ed:	41 01 c6             	add    %eax,%r14d
   290f0:	44 03 74 24 18       	add    0x18(%rsp),%r14d
    _LV_LL_READ_BACK(cont->child_ll, child) {
   290f5:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   290fa:	4c 89 e6             	mov    %r12,%rsi
   290fd:	e8 90 cb ff ff       	callq  25c92 <_lv_ll_get_prev>
   29102:	eb 95                	jmp    29099 <lv_cont_refr_layout+0x399>
    else if(type == LV_LAYOUT_PRETTY_MID || type == LV_LAYOUT_PRETTY_TOP || type == LV_LAYOUT_PRETTY_BOTTOM) {
   29104:	8d 43 f8             	lea    -0x8(%rbx),%eax
   29107:	3c 02                	cmp    $0x2,%al
   29109:	0f 87 dc 03 00 00    	ja     294eb <lv_cont_refr_layout+0x7eb>
    lv_layout_t type = lv_cont_get_layout(cont);
   2910f:	4c 89 ff             	mov    %r15,%rdi
   29112:	e8 d9 fb ff ff       	callq  28cf0 <lv_cont_get_layout>
    lv_coord_t w_obj         = lv_obj_get_width(cont);
   29117:	4c 89 ff             	mov    %r15,%rdi
    lv_layout_t type = lv_cont_get_layout(cont);
   2911a:	88 44 24 1c          	mov    %al,0x1c(%rsp)
    lv_coord_t w_obj         = lv_obj_get_width(cont);
   2911e:	e8 d2 18 ff ff       	callq  1a9f5 <lv_obj_get_width>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   29123:	31 f6                	xor    %esi,%esi
   29125:	ba 10 00 00 00       	mov    $0x10,%edx
   2912a:	4c 89 ff             	mov    %r15,%rdi
   2912d:	89 c5                	mov    %eax,%ebp
   2912f:	e8 b9 25 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
   29134:	66 89 44 24 08       	mov    %ax,0x8(%rsp)
    child_rs = _lv_ll_get_tail(&cont->child_ll); /*Set the row starter child*/
   29139:	49 8d 47 08          	lea    0x8(%r15),%rax
   2913d:	48 89 c7             	mov    %rax,%rdi
   29140:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
   29145:	e8 2d cb ff ff       	callq  25c77 <_lv_ll_get_tail>
    if(child_rs == NULL) return;                /*Return if no child*/
   2914a:	48 85 c0             	test   %rax,%rax
    child_rs = _lv_ll_get_tail(&cont->child_ll); /*Set the row starter child*/
   2914d:	48 89 c3             	mov    %rax,%rbx
    if(child_rs == NULL) return;                /*Return if no child*/
   29150:	0f 84 ae 04 00 00    	je     29604 <lv_cont_refr_layout+0x904>
    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
   29156:	be 01 00 00 00       	mov    $0x1,%esi
   2915b:	4c 89 ff             	mov    %r15,%rdi
   2915e:	e8 47 15 ff ff       	callq  1a6aa <lv_obj_add_protect>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   29163:	ba 12 00 00 00       	mov    $0x12,%edx
   29168:	31 f6                	xor    %esi,%esi
   2916a:	4c 89 ff             	mov    %r15,%rdi
   2916d:	e8 7b 25 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   29172:	ba 13 00 00 00       	mov    $0x13,%edx
   29177:	31 f6                	xor    %esi,%esi
   29179:	4c 89 ff             	mov    %r15,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   2917c:	66 89 44 24 22       	mov    %ax,0x22(%rsp)
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   29181:	e8 67 25 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   29186:	ba 14 00 00 00       	mov    $0x14,%edx
   2918b:	31 f6                	xor    %esi,%esi
   2918d:	4c 89 ff             	mov    %r15,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   29190:	66 89 44 24 28       	mov    %ax,0x28(%rsp)
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   29195:	e8 53 25 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
   2919a:	66 89 44 24 20       	mov    %ax,0x20(%rsp)
                if(w_row + w > w_obj) {
   2919f:	0f bf c5             	movswl %bp,%eax
   291a2:	89 44 24 24          	mov    %eax,0x24(%rsp)
        lv_coord_t w_row = pleft + pright; /*The width is at least the left+right pad*/
   291a6:	66 44 8b 6c 24 22    	mov    0x22(%rsp),%r13w
   291ac:	44 03 6c 24 28       	add    0x28(%rsp),%r13d
   291b1:	48 89 dd             	mov    %rbx,%rbp
        uint32_t obj_num = 0;
   291b4:	45 31 e4             	xor    %r12d,%r12d
        lv_coord_t h_row = 0;
   291b7:	66 c7 44 24 18 00 00 	movw   $0x0,0x18(%rsp)
            if(lv_obj_get_hidden(child_rc) == false && lv_obj_is_protected(child_rc, LV_PROTECT_POS) == false) {
   291be:	48 89 df             	mov    %rbx,%rdi
   291c1:	e8 70 19 ff ff       	callq  1ab36 <lv_obj_get_hidden>
   291c6:	84 c0                	test   %al,%al
   291c8:	0f 85 d0 00 00 00    	jne    2929e <lv_cont_refr_layout+0x59e>
   291ce:	be 04 00 00 00       	mov    $0x4,%esi
   291d3:	48 89 df             	mov    %rbx,%rdi
   291d6:	e8 eb 23 ff ff       	callq  1b5c6 <lv_obj_is_protected>
   291db:	84 c0                	test   %al,%al
   291dd:	0f 85 bb 00 00 00    	jne    2929e <lv_cont_refr_layout+0x59e>
                lv_coord_t w = lv_obj_get_width(child_rc);
   291e3:	48 89 df             	mov    %rbx,%rdi
   291e6:	e8 0a 18 ff ff       	callq  1a9f5 <lv_obj_get_width>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
   291eb:	31 f6                	xor    %esi,%esi
   291ed:	41 89 c6             	mov    %eax,%r14d
   291f0:	ba 17 00 00 00       	mov    $0x17,%edx
   291f5:	48 89 df             	mov    %rbx,%rdi
   291f8:	e8 f0 24 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_RIGHT, margin_right, lv_style_int_t, _int, scalar)
   291fd:	ba 18 00 00 00       	mov    $0x18,%edx
                w += lv_obj_get_style_margin_left(child_rc, LV_OBJ_PART_MAIN);
   29202:	41 01 c6             	add    %eax,%r14d
   29205:	31 f6                	xor    %esi,%esi
   29207:	48 89 df             	mov    %rbx,%rdi
   2920a:	e8 de 24 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
                w += lv_obj_get_style_margin_right(child_rc, LV_OBJ_PART_MAIN);
   2920f:	41 01 c6             	add    %eax,%r14d
                if(w_row + w > w_obj) {
   29212:	41 0f bf d5          	movswl %r13w,%edx
   29216:	41 0f bf c6          	movswl %r14w,%eax
   2921a:	01 c2                	add    %eax,%edx
   2921c:	3b 54 24 24          	cmp    0x24(%rsp),%edx
   29220:	7e 1e                	jle    29240 <lv_cont_refr_layout+0x540>
                    if(child_rc != NULL && obj_num != 0) {
   29222:	45 85 e4             	test   %r12d,%r12d
   29225:	0f 84 9c 00 00 00    	je     292c7 <lv_cont_refr_layout+0x5c7>
                        child_rc = _lv_ll_get_next(&cont->child_ll, child_rc);
   2922b:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   29230:	48 89 de             	mov    %rbx,%rsi
   29233:	e8 4b ca ff ff       	callq  25c83 <_lv_ll_get_next>
   29238:	48 89 c3             	mov    %rax,%rbx
   2923b:	e9 db 00 00 00       	jmpq   2931b <lv_cont_refr_layout+0x61b>
                w_row += w + pinner; /*Add the object width + inner padding*/
   29240:	44 03 6c 24 20       	add    0x20(%rsp),%r13d
                lv_coord_t h = lv_obj_get_height(child_rc);
   29245:	48 89 df             	mov    %rbx,%rdi
   29248:	e8 b3 17 ff ff       	callq  1aa00 <lv_obj_get_height>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
   2924d:	31 f6                	xor    %esi,%esi
   2924f:	ba 15 00 00 00       	mov    $0x15,%edx
   29254:	48 89 df             	mov    %rbx,%rdi
                w_row += w + pinner; /*Add the object width + inner padding*/
   29257:	45 01 f5             	add    %r14d,%r13d
                lv_coord_t h = lv_obj_get_height(child_rc);
   2925a:	41 89 c6             	mov    %eax,%r14d
   2925d:	e8 8b 24 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
   29262:	31 f6                	xor    %esi,%esi
                h += lv_obj_get_style_margin_top(child_rc, LV_OBJ_PART_MAIN);
   29264:	41 01 c6             	add    %eax,%r14d
   29267:	ba 16 00 00 00       	mov    $0x16,%edx
   2926c:	48 89 df             	mov    %rbx,%rdi
   2926f:	e8 79 24 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
                h += lv_obj_get_style_margin_bottom(child_rc, LV_OBJ_PART_MAIN);
   29274:	41 01 c6             	add    %eax,%r14d
                h_row = LV_MATH_MAX(h_row, h);         /*Search the highest object*/
   29277:	66 44 39 74 24 18    	cmp    %r14w,0x18(%rsp)
                if(lv_obj_is_protected(child_rc, LV_PROTECT_FOLLOW))
   2927d:	be 08 00 00 00       	mov    $0x8,%esi
                h_row = LV_MATH_MAX(h_row, h);         /*Search the highest object*/
   29282:	66 44 0f 4d 74 24 18 	cmovge 0x18(%rsp),%r14w
                if(lv_obj_is_protected(child_rc, LV_PROTECT_FOLLOW))
   29289:	48 89 df             	mov    %rbx,%rdi
                obj_num++;
   2928c:	41 ff c4             	inc    %r12d
                h_row = LV_MATH_MAX(h_row, h);         /*Search the highest object*/
   2928f:	66 44 89 74 24 18    	mov    %r14w,0x18(%rsp)
                if(lv_obj_is_protected(child_rc, LV_PROTECT_FOLLOW))
   29295:	e8 2c 23 ff ff       	callq  1b5c6 <lv_obj_is_protected>
   2929a:	84 c0                	test   %al,%al
   2929c:	75 24                	jne    292c2 <lv_cont_refr_layout+0x5c2>
            child_rc = _lv_ll_get_prev(&cont->child_ll, child_rc); /*Load the next object*/
   2929e:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   292a3:	48 89 de             	mov    %rbx,%rsi
   292a6:	e8 e7 c9 ff ff       	callq  25c92 <_lv_ll_get_prev>
            if(obj_num == 0)
   292ab:	45 85 e4             	test   %r12d,%r12d
            child_rc = _lv_ll_get_prev(&cont->child_ll, child_rc); /*Load the next object*/
   292ae:	48 89 c3             	mov    %rax,%rbx
            if(obj_num == 0)
   292b1:	0f 84 3c 03 00 00    	je     295f3 <lv_cont_refr_layout+0x8f3>
        } while(child_rc != NULL);
   292b7:	48 85 c0             	test   %rax,%rax
   292ba:	0f 85 fe fe ff ff    	jne    291be <lv_cont_refr_layout+0x4be>
   292c0:	eb 59                	jmp    2931b <lv_cont_refr_layout+0x61b>
        if(obj_num == 0) {
   292c2:	45 85 e4             	test   %r12d,%r12d
   292c5:	75 54                	jne    2931b <lv_cont_refr_layout+0x61b>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
   292c7:	ba 15 00 00 00       	mov    $0x15,%edx
   292cc:	31 f6                	xor    %esi,%esi
   292ce:	48 89 df             	mov    %rbx,%rdi
   292d1:	e8 17 24 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
   292d6:	89 c5                	mov    %eax,%ebp
                lv_obj_align(child_rc, cont, LV_ALIGN_IN_TOP_MID, 0, act_y + mtop);
   292d8:	8b 44 24 08          	mov    0x8(%rsp),%eax
   292dc:	31 c9                	xor    %ecx,%ecx
   292de:	ba 02 00 00 00       	mov    $0x2,%edx
   292e3:	4c 89 fe             	mov    %r15,%rsi
   292e6:	48 89 df             	mov    %rbx,%rdi
   292e9:	44 8d 04 28          	lea    (%rax,%rbp,1),%r8d
   292ed:	45 0f bf c0          	movswl %r8w,%r8d
   292f1:	e8 c4 1c ff ff       	callq  1afba <lv_obj_align>
                h_row = lv_obj_get_height(child_rc); /*Not set previously because of the early break*/
   292f6:	48 89 df             	mov    %rbx,%rdi
   292f9:	e8 02 17 ff ff       	callq  1aa00 <lv_obj_get_height>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
   292fe:	ba 16 00 00 00       	mov    $0x16,%edx
                h_row += mtop;
   29303:	01 c5                	add    %eax,%ebp
   29305:	31 f6                	xor    %esi,%esi
   29307:	48 89 df             	mov    %rbx,%rdi
   2930a:	e8 de 23 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
                h_row += lv_obj_get_style_margin_bottom(child_rc, LV_OBJ_PART_MAIN);
   2930f:	01 e8                	add    %ebp,%eax
   29311:	66 89 44 24 18       	mov    %ax,0x18(%rsp)
   29316:	e9 9e 01 00 00       	jmpq   294b9 <lv_cont_refr_layout+0x7b9>
        else if(obj_num == 1) {
   2931b:	41 83 fc 01          	cmp    $0x1,%r12d
   2931f:	75 32                	jne    29353 <lv_cont_refr_layout+0x653>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
   29321:	31 f6                	xor    %esi,%esi
   29323:	48 89 ef             	mov    %rbp,%rdi
   29326:	ba 15 00 00 00       	mov    $0x15,%edx
   2932b:	e8 bd 23 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
                         act_y + lv_obj_get_style_margin_top(child_rs, LV_OBJ_PART_MAIN));
   29330:	8b 4c 24 08          	mov    0x8(%rsp),%ecx
            lv_obj_align(child_rs, cont, LV_ALIGN_IN_TOP_MID,
   29334:	ba 02 00 00 00       	mov    $0x2,%edx
   29339:	4c 89 fe             	mov    %r15,%rsi
   2933c:	48 89 ef             	mov    %rbp,%rdi
                         act_y + lv_obj_get_style_margin_top(child_rs, LV_OBJ_PART_MAIN));
   2933f:	44 8d 04 08          	lea    (%rax,%rcx,1),%r8d
            lv_obj_align(child_rs, cont, LV_ALIGN_IN_TOP_MID,
   29343:	31 c9                	xor    %ecx,%ecx
   29345:	45 0f bf c0          	movswl %r8w,%r8d
   29349:	e8 6c 1c ff ff       	callq  1afba <lv_obj_align>
   2934e:	e9 5d 01 00 00       	jmpq   294b0 <lv_cont_refr_layout+0x7b0>
            w_row -= pinner * obj_num;
   29353:	8b 44 24 20          	mov    0x20(%rsp),%eax
            lv_coord_t new_pinner = (w_obj - w_row) / (obj_num - 1);
   29357:	31 d2                	xor    %edx,%edx
            w_row -= pinner * obj_num;
   29359:	41 0f af c4          	imul   %r12d,%eax
            lv_coord_t new_pinner = (w_obj - w_row) / (obj_num - 1);
   2935d:	41 ff cc             	dec    %r12d
            w_row -= pinner * obj_num;
   29360:	41 29 c5             	sub    %eax,%r13d
            lv_coord_t new_pinner = (w_obj - w_row) / (obj_num - 1);
   29363:	8b 44 24 24          	mov    0x24(%rsp),%eax
   29367:	45 0f bf ed          	movswl %r13w,%r13d
   2936b:	44 29 e8             	sub    %r13d,%eax
   2936e:	41 f7 f4             	div    %r12d
            lv_coord_t act_x    = pleft; /*x init*/
   29371:	66 44 8b 64 24 22    	mov    0x22(%rsp),%r12w
                    act_x += lv_obj_get_width(child_tmp) + new_pinner + mleft + mright;
   29377:	98                   	cwtl   
   29378:	89 44 24 2c          	mov    %eax,0x2c(%rsp)
            while(child_tmp != NULL) {
   2937c:	48 85 ed             	test   %rbp,%rbp
   2937f:	0f 84 2b 01 00 00    	je     294b0 <lv_cont_refr_layout+0x7b0>
                if(lv_obj_get_hidden(child_tmp) == false && lv_obj_is_protected(child_tmp, LV_PROTECT_POS) == false) {
   29385:	48 89 ef             	mov    %rbp,%rdi
   29388:	e8 a9 17 ff ff       	callq  1ab36 <lv_obj_get_hidden>
   2938d:	84 c0                	test   %al,%al
   2938f:	0f 85 01 01 00 00    	jne    29496 <lv_cont_refr_layout+0x796>
   29395:	be 04 00 00 00       	mov    $0x4,%esi
   2939a:	48 89 ef             	mov    %rbp,%rdi
   2939d:	e8 24 22 ff ff       	callq  1b5c6 <lv_obj_is_protected>
   293a2:	84 c0                	test   %al,%al
   293a4:	0f 85 ec 00 00 00    	jne    29496 <lv_cont_refr_layout+0x796>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
   293aa:	31 f6                	xor    %esi,%esi
   293ac:	ba 17 00 00 00       	mov    $0x17,%edx
   293b1:	48 89 ef             	mov    %rbp,%rdi
   293b4:	e8 34 23 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_RIGHT, margin_right, lv_style_int_t, _int, scalar)
   293b9:	31 f6                	xor    %esi,%esi
   293bb:	ba 18 00 00 00       	mov    $0x18,%edx
   293c0:	48 89 ef             	mov    %rbp,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
   293c3:	44 0f bf f0          	movswl %ax,%r14d
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_RIGHT, margin_right, lv_style_int_t, _int, scalar)
   293c7:	e8 21 23 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
                    switch(type) {
   293cc:	80 7c 24 1c 09       	cmpb   $0x9,0x1c(%rsp)
   293d1:	66 89 44 24 2a       	mov    %ax,0x2a(%rsp)
   293d6:	74 36                	je     2940e <lv_cont_refr_layout+0x70e>
   293d8:	80 7c 24 1c 0a       	cmpb   $0xa,0x1c(%rsp)
   293dd:	74 5c                	je     2943b <lv_cont_refr_layout+0x73b>
   293df:	80 7c 24 1c 08       	cmpb   $0x8,0x1c(%rsp)
   293e4:	0f 85 93 00 00 00    	jne    2947d <lv_cont_refr_layout+0x77d>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
   293ea:	ba 15 00 00 00       	mov    $0x15,%edx
   293ef:	31 f6                	xor    %esi,%esi
   293f1:	48 89 ef             	mov    %rbp,%rdi
   293f4:	e8 f4 22 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
                                         act_y + lv_obj_get_style_margin_top(child_tmp, LV_OBJ_PART_MAIN));
   293f9:	8b 4c 24 08          	mov    0x8(%rsp),%ecx
   293fd:	44 8d 04 08          	lea    (%rax,%rcx,1),%r8d
                                         act_x + mleft,
   29401:	43 8d 0c 26          	lea    (%r14,%r12,1),%ecx
                            lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT,
   29405:	45 0f bf c0          	movswl %r8w,%r8d
   29409:	0f bf c9             	movswl %cx,%ecx
   2940c:	eb 5f                	jmp    2946d <lv_cont_refr_layout+0x76d>
                                         act_y + (h_row - lv_obj_get_height(child_tmp)) / 2);
   2940e:	48 89 ef             	mov    %rbp,%rdi
   29411:	e8 ea 15 ff ff       	callq  1aa00 <lv_obj_get_height>
   29416:	0f bf 54 24 18       	movswl 0x18(%rsp),%edx
   2941b:	0f bf c8             	movswl %ax,%ecx
   2941e:	89 d0                	mov    %edx,%eax
   29420:	29 c8                	sub    %ecx,%eax
   29422:	b9 02 00 00 00       	mov    $0x2,%ecx
   29427:	99                   	cltd   
   29428:	f7 f9                	idiv   %ecx
                                         act_x + mleft,
   2942a:	43 8d 0c 26          	lea    (%r14,%r12,1),%ecx
                                         act_y + (h_row - lv_obj_get_height(child_tmp)) / 2);
   2942e:	03 44 24 08          	add    0x8(%rsp),%eax
                            lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT,
   29432:	0f bf c9             	movswl %cx,%ecx
   29435:	44 0f bf c0          	movswl %ax,%r8d
   29439:	eb 32                	jmp    2946d <lv_cont_refr_layout+0x76d>
                                         act_y + h_row - lv_obj_get_height(child_tmp) - lv_obj_get_style_margin_bottom(child_tmp, LV_OBJ_PART_MAIN));
   2943b:	44 8b 6c 24 08       	mov    0x8(%rsp),%r13d
   29440:	44 03 6c 24 18       	add    0x18(%rsp),%r13d
   29445:	48 89 ef             	mov    %rbp,%rdi
   29448:	e8 b3 15 ff ff       	callq  1aa00 <lv_obj_get_height>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
   2944d:	ba 16 00 00 00       	mov    $0x16,%edx
   29452:	31 f6                	xor    %esi,%esi
   29454:	48 89 ef             	mov    %rbp,%rdi
   29457:	41 29 c5             	sub    %eax,%r13d
   2945a:	e8 8e 22 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
                                         act_x + mleft,
   2945f:	43 8d 0c 26          	lea    (%r14,%r12,1),%ecx
                                         act_y + h_row - lv_obj_get_height(child_tmp) - lv_obj_get_style_margin_bottom(child_tmp, LV_OBJ_PART_MAIN));
   29463:	41 29 c5             	sub    %eax,%r13d
                            lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT,
   29466:	45 0f bf c5          	movswl %r13w,%r8d
   2946a:	0f bf c9             	movswl %cx,%ecx
   2946d:	ba 01 00 00 00       	mov    $0x1,%edx
   29472:	4c 89 fe             	mov    %r15,%rsi
   29475:	48 89 ef             	mov    %rbp,%rdi
   29478:	e8 3d 1b ff ff       	callq  1afba <lv_obj_align>
                    act_x += lv_obj_get_width(child_tmp) + new_pinner + mleft + mright;
   2947d:	48 89 ef             	mov    %rbp,%rdi
   29480:	e8 70 15 ff ff       	callq  1a9f5 <lv_obj_get_width>
   29485:	98                   	cwtl   
   29486:	03 44 24 2c          	add    0x2c(%rsp),%eax
   2948a:	66 44 03 64 24 2a    	add    0x2a(%rsp),%r12w
   29490:	41 01 c6             	add    %eax,%r14d
   29493:	45 01 f4             	add    %r14d,%r12d
                if(child_tmp == child_rc) break;
   29496:	48 39 eb             	cmp    %rbp,%rbx
   29499:	74 21                	je     294bc <lv_cont_refr_layout+0x7bc>
                child_tmp = _lv_ll_get_prev(&cont->child_ll, child_tmp);
   2949b:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
   294a0:	48 89 ee             	mov    %rbp,%rsi
   294a3:	e8 ea c7 ff ff       	callq  25c92 <_lv_ll_get_prev>
   294a8:	48 89 c5             	mov    %rax,%rbp
   294ab:	e9 cc fe ff ff       	jmpq   2937c <lv_cont_refr_layout+0x67c>
        if(child_rc == NULL) break;
   294b0:	48 85 db             	test   %rbx,%rbx
   294b3:	0f 84 46 fa ff ff    	je     28eff <lv_cont_refr_layout+0x1ff>
   294b9:	48 89 dd             	mov    %rbx,%rbp
        act_y += pinner + h_row;           /*y increment*/
   294bc:	8b 44 24 08          	mov    0x8(%rsp),%eax
   294c0:	03 44 24 20          	add    0x20(%rsp),%eax
        child_rs = _lv_ll_get_prev(&cont->child_ll, child_rc); /*Go to the next object*/
   294c4:	48 89 ee             	mov    %rbp,%rsi
        act_y += pinner + h_row;           /*y increment*/
   294c7:	03 44 24 18          	add    0x18(%rsp),%eax
        child_rs = _lv_ll_get_prev(&cont->child_ll, child_rc); /*Go to the next object*/
   294cb:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
        act_y += pinner + h_row;           /*y increment*/
   294d0:	66 89 44 24 08       	mov    %ax,0x8(%rsp)
        child_rs = _lv_ll_get_prev(&cont->child_ll, child_rc); /*Go to the next object*/
   294d5:	e8 b8 c7 ff ff       	callq  25c92 <_lv_ll_get_prev>
    while(child_rs != NULL) {
   294da:	48 85 c0             	test   %rax,%rax
        child_rs = _lv_ll_get_prev(&cont->child_ll, child_rc); /*Go to the next object*/
   294dd:	48 89 c3             	mov    %rax,%rbx
    while(child_rs != NULL) {
   294e0:	0f 85 c0 fc ff ff    	jne    291a6 <lv_cont_refr_layout+0x4a6>
   294e6:	e9 14 fa ff ff       	jmpq   28eff <lv_cont_refr_layout+0x1ff>
    else if(type == LV_LAYOUT_GRID) {
   294eb:	80 fb 0b             	cmp    $0xb,%bl
   294ee:	0f 85 10 01 00 00    	jne    29604 <lv_cont_refr_layout+0x904>
    lv_coord_t w_fit         =  lv_obj_get_width_fit(cont);
   294f4:	4c 89 ff             	mov    %r15,%rdi
    _LV_LL_READ_BACK(cont->child_ll, child) {
   294f7:	4d 8d 77 08          	lea    0x8(%r15),%r14
    lv_coord_t w_fit         =  lv_obj_get_width_fit(cont);
   294fb:	e8 5b 24 ff ff       	callq  1b95b <lv_obj_get_width_fit>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   29500:	ba 14 00 00 00       	mov    $0x14,%edx
   29505:	31 f6                	xor    %esi,%esi
   29507:	4c 89 ff             	mov    %r15,%rdi
   2950a:	66 89 44 24 18       	mov    %ax,0x18(%rsp)
   2950f:	e8 d9 21 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    lv_coord_t y_ofs = inner + lv_obj_get_height(lv_obj_get_child(cont, NULL));
   29514:	31 f6                	xor    %esi,%esi
   29516:	4c 89 ff             	mov    %r15,%rdi
   29519:	66 89 44 24 08       	mov    %ax,0x8(%rsp)
   2951e:	e8 7c 14 ff ff       	callq  1a99f <lv_obj_get_child>
   29523:	48 89 c7             	mov    %rax,%rdi
   29526:	e8 d5 14 ff ff       	callq  1aa00 <lv_obj_get_height>
   2952b:	03 44 24 08          	add    0x8(%rsp),%eax
    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
   2952f:	be 01 00 00 00       	mov    $0x1,%esi
   29534:	4c 89 ff             	mov    %r15,%rdi
    lv_coord_t y_ofs = inner + lv_obj_get_height(lv_obj_get_child(cont, NULL));
   29537:	66 89 44 24 10       	mov    %ax,0x10(%rsp)
    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
   2953c:	e8 69 11 ff ff       	callq  1a6aa <lv_obj_add_protect>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   29541:	ba 12 00 00 00       	mov    $0x12,%edx
   29546:	31 f6                	xor    %esi,%esi
   29548:	4c 89 ff             	mov    %r15,%rdi
   2954b:	e8 9d 21 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   29550:	ba 10 00 00 00       	mov    $0x10,%edx
   29555:	31 f6                	xor    %esi,%esi
   29557:	4c 89 ff             	mov    %r15,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   2955a:	41 89 c5             	mov    %eax,%r13d
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   2955d:	e8 8b 21 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    _LV_LL_READ_BACK(cont->child_ll, child) {
   29562:	4c 89 f7             	mov    %r14,%rdi
   29565:	41 89 c4             	mov    %eax,%r12d
    lv_coord_t act_x = left;
   29568:	44 89 ed             	mov    %r13d,%ebp
    _LV_LL_READ_BACK(cont->child_ll, child) {
   2956b:	e8 07 c7 ff ff       	callq  25c77 <_lv_ll_get_tail>
   29570:	48 89 c3             	mov    %rax,%rbx
        if(act_x + obj_w > w_fit + left) {
   29573:	0f bf 44 24 18       	movswl 0x18(%rsp),%eax
   29578:	89 44 24 18          	mov    %eax,0x18(%rsp)
    _LV_LL_READ_BACK(cont->child_ll, child) {
   2957c:	48 85 db             	test   %rbx,%rbx
   2957f:	0f 84 7a f9 ff ff    	je     28eff <lv_cont_refr_layout+0x1ff>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
   29585:	48 89 df             	mov    %rbx,%rdi
   29588:	e8 a9 15 ff ff       	callq  1ab36 <lv_obj_get_hidden>
   2958d:	84 c0                	test   %al,%al
   2958f:	75 52                	jne    295e3 <lv_cont_refr_layout+0x8e3>
   29591:	be 04 00 00 00       	mov    $0x4,%esi
   29596:	48 89 df             	mov    %rbx,%rdi
   29599:	e8 28 20 ff ff       	callq  1b5c6 <lv_obj_is_protected>
   2959e:	84 c0                	test   %al,%al
   295a0:	75 41                	jne    295e3 <lv_cont_refr_layout+0x8e3>
        lv_coord_t obj_w = lv_obj_get_width(child);
   295a2:	48 89 df             	mov    %rbx,%rdi
   295a5:	e8 4b 14 ff ff       	callq  1a9f5 <lv_obj_get_width>
        if(act_x + obj_w > w_fit + left) {
   295aa:	0f bf d5             	movswl %bp,%edx
   295ad:	0f bf c8             	movswl %ax,%ecx
   295b0:	01 ca                	add    %ecx,%edx
   295b2:	41 0f bf cd          	movswl %r13w,%ecx
   295b6:	03 4c 24 18          	add    0x18(%rsp),%ecx
   295ba:	39 ca                	cmp    %ecx,%edx
   295bc:	7e 08                	jle    295c6 <lv_cont_refr_layout+0x8c6>
            act_y += y_ofs;
   295be:	44 03 64 24 10       	add    0x10(%rsp),%r12d
            act_x = left;
   295c3:	44 89 ed             	mov    %r13d,%ebp
        lv_obj_set_pos(child, act_x, act_y);
   295c6:	0f bf f5             	movswl %bp,%esi
   295c9:	41 0f bf d4          	movswl %r12w,%edx
   295cd:	48 89 df             	mov    %rbx,%rdi
   295d0:	89 44 24 1c          	mov    %eax,0x1c(%rsp)
   295d4:	e8 0e 18 ff ff       	callq  1ade7 <lv_obj_set_pos>
        act_x += inner + obj_w;
   295d9:	8b 44 24 1c          	mov    0x1c(%rsp),%eax
   295dd:	03 44 24 08          	add    0x8(%rsp),%eax
   295e1:	01 c5                	add    %eax,%ebp
    _LV_LL_READ_BACK(cont->child_ll, child) {
   295e3:	48 89 de             	mov    %rbx,%rsi
   295e6:	4c 89 f7             	mov    %r14,%rdi
   295e9:	e8 a4 c6 ff ff       	callq  25c92 <_lv_ll_get_prev>
   295ee:	48 89 c3             	mov    %rax,%rbx
   295f1:	eb 89                	jmp    2957c <lv_cont_refr_layout+0x87c>
        } while(child_rc != NULL);
   295f3:	48 85 c0             	test   %rax,%rax
   295f6:	0f 84 03 f9 ff ff    	je     28eff <lv_cont_refr_layout+0x1ff>
            child_rc = _lv_ll_get_prev(&cont->child_ll, child_rc); /*Load the next object*/
   295fc:	48 89 dd             	mov    %rbx,%rbp
   295ff:	e9 ba fb ff ff       	jmpq   291be <lv_cont_refr_layout+0x4be>
}
   29604:	48 83 c4 38          	add    $0x38,%rsp
   29608:	5b                   	pop    %rbx
   29609:	5d                   	pop    %rbp
   2960a:	41 5c                	pop    %r12
   2960c:	41 5d                	pop    %r13
   2960e:	41 5e                	pop    %r14
   29610:	41 5f                	pop    %r15
   29612:	c3                   	retq   

0000000000029613 <lv_cont_signal>:
{
   29613:	41 55                	push   %r13
   29615:	41 54                	push   %r12
   29617:	55                   	push   %rbp
   29618:	53                   	push   %rbx
   29619:	48 83 ec 08          	sub    $0x8,%rsp
    if(sign == LV_SIGNAL_GET_STYLE) {
   2961d:	40 80 fe 08          	cmp    $0x8,%sil
   29621:	75 37                	jne    2965a <lv_cont_signal+0x47>
    switch(type) {
   29623:	80 3a 00             	cmpb   $0x0,(%rdx)
   29626:	74 0a                	je     29632 <lv_cont_signal+0x1f>
        info->result = lv_cont_get_style(cont, info->part);
   29628:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
   2962f:	00 
   29630:	eb 15                	jmp    29647 <lv_cont_signal+0x34>
            style_dsc_p = &cont->style_list;
   29632:	48 8d 47 48          	lea    0x48(%rdi),%rax
        if(info->result != NULL) return LV_RES_OK;
   29636:	48 85 c0             	test   %rax,%rax
        info->result = lv_cont_get_style(cont, info->part);
   29639:	48 89 42 08          	mov    %rax,0x8(%rdx)
        if(info->result != NULL) return LV_RES_OK;
   2963d:	74 08                	je     29647 <lv_cont_signal+0x34>
   2963f:	41 b5 01             	mov    $0x1,%r13b
   29642:	e9 ab 00 00 00       	jmpq   296f2 <lv_cont_signal+0xdf>
}
   29647:	41 58                	pop    %r8
   29649:	5b                   	pop    %rbx
   2964a:	5d                   	pop    %rbp
   2964b:	41 5c                	pop    %r12
   2964d:	41 5d                	pop    %r13
        else return ancestor_signal(cont, sign, param);
   2964f:	be 08 00 00 00       	mov    $0x8,%esi
   29654:	ff 25 d6 e9 22 00    	jmpq   *0x22e9d6(%rip)        # 258030 <ancestor_signal>
   2965a:	48 89 d3             	mov    %rdx,%rbx
   2965d:	41 89 f4             	mov    %esi,%r12d
   29660:	48 89 fd             	mov    %rdi,%rbp
    res = ancestor_signal(cont, sign, param);
   29663:	40 0f b6 f6          	movzbl %sil,%esi
   29667:	ff 15 c3 e9 22 00    	callq  *0x22e9c3(%rip)        # 258030 <ancestor_signal>
    if(res != LV_RES_OK) return res;
   2966d:	3c 01                	cmp    $0x1,%al
    res = ancestor_signal(cont, sign, param);
   2966f:	41 88 c5             	mov    %al,%r13b
    if(res != LV_RES_OK) return res;
   29672:	75 7e                	jne    296f2 <lv_cont_signal+0xdf>
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
   29674:	41 80 fc 07          	cmp    $0x7,%r12b
   29678:	75 16                	jne    29690 <lv_cont_signal+0x7d>
}
   2967a:	59                   	pop    %rcx
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
   2967b:	48 89 df             	mov    %rbx,%rdi
   2967e:	48 8d 35 2a a8 00 00 	lea    0xa82a(%rip),%rsi        # 33eaf <_lv_bpp1_opa_table+0x65a>
}
   29685:	5b                   	pop    %rbx
   29686:	5d                   	pop    %rbp
   29687:	41 5c                	pop    %r12
   29689:	41 5d                	pop    %r13
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
   2968b:	e9 d8 2c ff ff       	jmpq   1c368 <lv_obj_handle_get_type_signal>
    if(sign == LV_SIGNAL_STYLE_CHG) { /*Recalculate the padding if the style changed*/
   29690:	41 80 fc 04          	cmp    $0x4,%r12b
   29694:	75 0a                	jne    296a0 <lv_cont_signal+0x8d>
        lv_cont_refr_layout(cont);
   29696:	48 89 ef             	mov    %rbp,%rdi
   29699:	e8 62 f6 ff ff       	callq  28d00 <lv_cont_refr_layout>
   2969e:	eb 4a                	jmp    296ea <lv_cont_signal+0xd7>
    else if(sign == LV_SIGNAL_CHILD_CHG) {
   296a0:	41 80 fc 01          	cmp    $0x1,%r12b
   296a4:	74 f0                	je     29696 <lv_cont_signal+0x83>
    else if(sign == LV_SIGNAL_COORD_CHG) {
   296a6:	41 80 fc 02          	cmp    $0x2,%r12b
   296aa:	75 34                	jne    296e0 <lv_cont_signal+0xcd>
        if(lv_obj_get_width(cont) != lv_area_get_width(param) || lv_obj_get_height(cont) != lv_area_get_height(param)) {
   296ac:	48 89 ef             	mov    %rbp,%rdi
   296af:	e8 41 13 ff ff       	callq  1a9f5 <lv_obj_get_width>
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   296b4:	66 8b 4b 04          	mov    0x4(%rbx),%cx
   296b8:	8d 51 01             	lea    0x1(%rcx),%edx
   296bb:	66 2b 13             	sub    (%rbx),%dx
   296be:	66 39 d0             	cmp    %dx,%ax
   296c1:	75 d3                	jne    29696 <lv_cont_signal+0x83>
   296c3:	48 89 ef             	mov    %rbp,%rdi
   296c6:	e8 35 13 ff ff       	callq  1aa00 <lv_obj_get_height>
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   296cb:	66 8b 4b 06          	mov    0x6(%rbx),%cx
   296cf:	8d 51 01             	lea    0x1(%rcx),%edx
   296d2:	66 2b 53 02          	sub    0x2(%rbx),%dx
   296d6:	66 39 d0             	cmp    %dx,%ax
   296d9:	75 bb                	jne    29696 <lv_cont_signal+0x83>
   296db:	e9 5f ff ff ff       	jmpq   2963f <lv_cont_signal+0x2c>
    else if(sign == LV_SIGNAL_PARENT_SIZE_CHG) {
   296e0:	41 80 fc 03          	cmp    $0x3,%r12b
   296e4:	0f 85 55 ff ff ff    	jne    2963f <lv_cont_signal+0x2c>
        lv_cont_refr_autofit(cont);
   296ea:	48 89 ef             	mov    %rbp,%rdi
   296ed:	e8 33 ef ff ff       	callq  28625 <lv_cont_refr_autofit>
}
   296f2:	5a                   	pop    %rdx
   296f3:	44 88 e8             	mov    %r13b,%al
   296f6:	5b                   	pop    %rbx
   296f7:	5d                   	pop    %rbp
   296f8:	41 5c                	pop    %r12
   296fa:	41 5d                	pop    %r13
   296fc:	c3                   	retq   

00000000000296fd <lv_label_dot_tmp_free>:
 * Free the dot_tmp_ptr field if it was previously allocated.
 * Always clears the field
 * @param label pointer to label object.
 */
static void lv_label_dot_tmp_free(lv_obj_t * label)
{
   296fd:	53                   	push   %rbx
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   296fe:	e8 fc 2b ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    if(ext->dot_tmp_alloc && ext->dot.tmp_ptr) {
   29703:	f6 40 19 01          	testb  $0x1,0x19(%rax)
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   29707:	48 89 c3             	mov    %rax,%rbx
    if(ext->dot_tmp_alloc && ext->dot.tmp_ptr) {
   2970a:	74 0e                	je     2971a <lv_label_dot_tmp_free+0x1d>
   2970c:	48 8b 78 08          	mov    0x8(%rax),%rdi
   29710:	48 85 ff             	test   %rdi,%rdi
   29713:	74 05                	je     2971a <lv_label_dot_tmp_free+0x1d>
        lv_mem_free(ext->dot.tmp_ptr);
   29715:	e8 ea c9 ff ff       	callq  26104 <lv_mem_free>
    }
    ext->dot_tmp_alloc = false;
   2971a:	80 63 19 fe          	andb   $0xfe,0x19(%rbx)
    ext->dot.tmp_ptr   = NULL;
   2971e:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
   29725:	00 
}
   29726:	5b                   	pop    %rbx
   29727:	c3                   	retq   

0000000000029728 <lv_label_revert_dots>:
{
   29728:	41 54                	push   %r12
   2972a:	55                   	push   %rbp
   2972b:	48 89 fd             	mov    %rdi,%rbp
   2972e:	53                   	push   %rbx
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   2972f:	e8 cb 2b ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
   29734:	48 89 c3             	mov    %rax,%rbx
    if(ext->long_mode != LV_LABEL_LONG_DOT) return;
   29737:	8a 40 18             	mov    0x18(%rax),%al
   2973a:	83 e0 07             	and    $0x7,%eax
   2973d:	3c 02                	cmp    $0x2,%al
   2973f:	75 5e                	jne    2979f <lv_label_revert_dots+0x77>
    if(ext->dot_end == LV_LABEL_DOT_END_INV) return;
   29741:	8b 73 10             	mov    0x10(%rbx),%esi
   29744:	81 fe ff ff 00 00    	cmp    $0xffff,%esi
   2974a:	74 53                	je     2979f <lv_label_revert_dots+0x77>
    uint32_t byte_i   = _lv_txt_encoded_get_byte_id(ext->text, letter_i);
   2974c:	48 8d 05 35 d3 20 00 	lea    0x20d335(%rip),%rax        # 236a88 <_lv_txt_encoded_get_byte_id>
    uint32_t letter_i = ext->dot_end - LV_LABEL_DOT_NUM;
   29753:	83 ee 03             	sub    $0x3,%esi
    uint32_t byte_i   = _lv_txt_encoded_get_byte_id(ext->text, letter_i);
   29756:	48 8b 3b             	mov    (%rbx),%rdi
   29759:	ff 10                	callq  *(%rax)
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   2975b:	48 89 ef             	mov    %rbp,%rdi
    uint32_t byte_i   = _lv_txt_encoded_get_byte_id(ext->text, letter_i);
   2975e:	41 89 c4             	mov    %eax,%r12d
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   29761:	e8 99 2b ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    if(ext->dot_tmp_alloc) {
   29766:	f6 40 19 01          	testb  $0x1,0x19(%rax)
        return ext->dot.tmp;
   2976a:	48 8d 70 08          	lea    0x8(%rax),%rsi
    if(ext->dot_tmp_alloc) {
   2976e:	74 04                	je     29774 <lv_label_revert_dots+0x4c>
        return ext->dot.tmp_ptr;
   29770:	48 8b 70 08          	mov    0x8(%rax),%rsi
    uint8_t i      = 0;
   29774:	31 d2                	xor    %edx,%edx
    while(ext->text[byte_i + i] != '\0') {
   29776:	0f b6 c2             	movzbl %dl,%eax
   29779:	0f b6 ca             	movzbl %dl,%ecx
   2977c:	44 01 e0             	add    %r12d,%eax
   2977f:	48 03 03             	add    (%rbx),%rax
   29782:	8a 0c 0e             	mov    (%rsi,%rcx,1),%cl
   29785:	80 38 00             	cmpb   $0x0,(%rax)
        ext->text[byte_i + i] = dot_tmp[i];
   29788:	88 08                	mov    %cl,(%rax)
    while(ext->text[byte_i + i] != '\0') {
   2978a:	74 04                	je     29790 <lv_label_revert_dots+0x68>
        i++;
   2978c:	ff c2                	inc    %edx
   2978e:	eb e6                	jmp    29776 <lv_label_revert_dots+0x4e>
    lv_label_dot_tmp_free(label);
   29790:	48 89 ef             	mov    %rbp,%rdi
   29793:	e8 65 ff ff ff       	callq  296fd <lv_label_dot_tmp_free>
    ext->dot_end = LV_LABEL_DOT_END_INV;
   29798:	c7 43 10 ff ff 00 00 	movl   $0xffff,0x10(%rbx)
}
   2979f:	5b                   	pop    %rbx
   297a0:	5d                   	pop    %rbp
   297a1:	41 5c                	pop    %r12
   297a3:	c3                   	retq   

00000000000297a4 <_lv_memcpy>:
 * @param dst pointer to the destination buffer
 * @param src pointer to the source buffer
 * @param len number of byte to copy
 */
static inline void * _lv_memcpy(void * dst, const void * src, size_t len)
{
   297a4:	48 89 f8             	mov    %rdi,%rax
   297a7:	48 89 d1             	mov    %rdx,%rcx
   297aa:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
    return memcpy(dst, src, len);
}
   297ac:	c3                   	retq   

00000000000297ad <lv_label_set_dot_tmp>:
{
   297ad:	41 54                	push   %r12
   297af:	55                   	push   %rbp
   297b0:	49 89 fc             	mov    %rdi,%r12
   297b3:	53                   	push   %rbx
   297b4:	89 d5                	mov    %edx,%ebp
   297b6:	48 83 ec 10          	sub    $0x10,%rsp
   297ba:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   297bf:	e8 3b 2b ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    lv_label_dot_tmp_free(label); /* Deallocate any existing space */
   297c4:	4c 89 e7             	mov    %r12,%rdi
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   297c7:	48 89 c3             	mov    %rax,%rbx
    lv_label_dot_tmp_free(label); /* Deallocate any existing space */
   297ca:	e8 2e ff ff ff       	callq  296fd <lv_label_dot_tmp_free>
    if(len > sizeof(char *)) {
   297cf:	83 fd 08             	cmp    $0x8,%ebp
   297d2:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   297d7:	76 57                	jbe    29830 <lv_label_set_dot_tmp+0x83>
        ext->dot.tmp_ptr = lv_mem_alloc(len + 1);
   297d9:	8d 7d 01             	lea    0x1(%rbp),%edi
   297dc:	e8 b0 c8 ff ff       	callq  26091 <lv_mem_alloc>
        if(ext->dot.tmp_ptr == NULL) {
   297e1:	48 85 c0             	test   %rax,%rax
        ext->dot.tmp_ptr = lv_mem_alloc(len + 1);
   297e4:	48 89 43 08          	mov    %rax,0x8(%rbx)
        if(ext->dot.tmp_ptr == NULL) {
   297e8:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   297ed:	75 28                	jne    29817 <lv_label_set_dot_tmp+0x6a>
            LV_LOG_ERROR("Failed to allocate memory for dot_tmp_ptr");
   297ef:	4c 8d 05 c1 a6 00 00 	lea    0xa6c1(%rip),%r8        # 33eb7 <_lv_bpp1_opa_table+0x662>
   297f6:	48 8d 0d 43 73 00 00 	lea    0x7343(%rip),%rcx        # 30b40 <__func__.6602>
   297fd:	48 8d 35 dd a6 00 00 	lea    0xa6dd(%rip),%rsi        # 33ee1 <_lv_bpp1_opa_table+0x68c>
   29804:	ba d0 05 00 00       	mov    $0x5d0,%edx
   29809:	bf 03 00 00 00       	mov    $0x3,%edi
   2980e:	e8 43 c7 ff ff       	callq  25f56 <_lv_log_add>
   29813:	31 c0                	xor    %eax,%eax
   29815:	eb 2a                	jmp    29841 <lv_label_set_dot_tmp+0x94>
        _lv_memcpy(ext->dot.tmp_ptr, data, len);
   29817:	48 89 ea             	mov    %rbp,%rdx
   2981a:	48 89 c7             	mov    %rax,%rdi
   2981d:	e8 82 ff ff ff       	callq  297a4 <_lv_memcpy>
        ext->dot.tmp_ptr[len] = '\0';
   29822:	48 8b 43 08          	mov    0x8(%rbx),%rax
   29826:	c6 04 28 00          	movb   $0x0,(%rax,%rbp,1)
        ext->dot_tmp_alloc    = true;
   2982a:	80 4b 19 01          	orb    $0x1,0x19(%rbx)
   2982e:	eb 0f                	jmp    2983f <lv_label_set_dot_tmp+0x92>
        ext->dot_tmp_alloc = false;
   29830:	80 63 19 fe          	andb   $0xfe,0x19(%rbx)
        _lv_memcpy(ext->dot.tmp, data, len);
   29834:	48 8d 7b 08          	lea    0x8(%rbx),%rdi
   29838:	89 ea                	mov    %ebp,%edx
   2983a:	e8 65 ff ff ff       	callq  297a4 <_lv_memcpy>
    return true;
   2983f:	b0 01                	mov    $0x1,%al
}
   29841:	48 83 c4 10          	add    $0x10,%rsp
   29845:	5b                   	pop    %rbx
   29846:	5d                   	pop    %rbp
   29847:	41 5c                	pop    %r12
   29849:	c3                   	retq   

000000000002984a <get_txt_coords>:

static void get_txt_coords(const lv_obj_t * label, lv_area_t * area)
{
   2984a:	41 56                	push   %r14
   2984c:	41 55                	push   %r13
   2984e:	41 54                	push   %r12
   29850:	55                   	push   %rbp
   29851:	48 89 fd             	mov    %rdi,%rbp
   29854:	53                   	push   %rbx
   29855:	48 89 f3             	mov    %rsi,%rbx
    lv_obj_get_coords(label, area);
   29858:	e8 55 11 ff ff       	callq  1a9b2 <lv_obj_get_coords>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   2985d:	48 89 ef             	mov    %rbp,%rdi
   29860:	ba 12 00 00 00       	mov    $0x12,%edx
   29865:	31 f6                	xor    %esi,%esi
   29867:	e8 81 1e ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   2986c:	48 89 ef             	mov    %rbp,%rdi
   2986f:	ba 13 00 00 00       	mov    $0x13,%edx
   29874:	31 f6                	xor    %esi,%esi
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   29876:	41 89 c6             	mov    %eax,%r14d
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   29879:	e8 6f 1e ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   2987e:	48 89 ef             	mov    %rbp,%rdi
   29881:	ba 10 00 00 00       	mov    $0x10,%edx
   29886:	31 f6                	xor    %esi,%esi
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   29888:	41 89 c5             	mov    %eax,%r13d
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   2988b:	e8 5d 1e ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   29890:	48 89 ef             	mov    %rbp,%rdi
   29893:	ba 11 00 00 00       	mov    $0x11,%edx
   29898:	31 f6                	xor    %esi,%esi
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   2989a:	41 89 c4             	mov    %eax,%r12d
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   2989d:	e8 4b 1e ff ff       	callq  1b6ed <_lv_obj_get_style_int>

    lv_coord_t left   = lv_obj_get_style_pad_left(label, LV_LABEL_PART_MAIN);
    lv_coord_t right  = lv_obj_get_style_pad_right(label, LV_LABEL_PART_MAIN);
    lv_coord_t top    = lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN);
    lv_coord_t bottom = lv_obj_get_style_pad_bottom(label, LV_LABEL_PART_MAIN);
    area->x1 += left;
   298a2:	66 44 01 33          	add    %r14w,(%rbx)
    area->x2 -= right;
   298a6:	66 44 29 6b 04       	sub    %r13w,0x4(%rbx)
    area->y1 += top;
   298ab:	66 44 01 63 02       	add    %r12w,0x2(%rbx)
    area->y2 -= bottom;
   298b0:	66 29 43 06          	sub    %ax,0x6(%rbx)
}
   298b4:	5b                   	pop    %rbx
   298b5:	5d                   	pop    %rbp
   298b6:	41 5c                	pop    %r12
   298b8:	41 5d                	pop    %r13
   298ba:	41 5e                	pop    %r14
   298bc:	c3                   	retq   

00000000000298bd <lv_label_set_align>:
{
   298bd:	55                   	push   %rbp
   298be:	53                   	push   %rbx
   298bf:	48 89 fd             	mov    %rdi,%rbp
   298c2:	89 f3                	mov    %esi,%ebx
   298c4:	48 83 ec 08          	sub    $0x8,%rsp
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   298c8:	e8 32 2a ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    if(ext->align == align) return;
   298cd:	8a 50 18             	mov    0x18(%rax),%dl
   298d0:	0f b6 f3             	movzbl %bl,%esi
   298d3:	88 d1                	mov    %dl,%cl
   298d5:	c0 e9 04             	shr    $0x4,%cl
   298d8:	83 e1 03             	and    $0x3,%ecx
   298db:	39 f1                	cmp    %esi,%ecx
   298dd:	74 19                	je     298f8 <lv_label_set_align+0x3b>
    ext->align = align;
   298df:	83 e3 03             	and    $0x3,%ebx
   298e2:	83 e2 cf             	and    $0xffffffcf,%edx
    lv_obj_invalidate(label); /*Enough to invalidate because alignment is only drawing related
   298e5:	48 89 ef             	mov    %rbp,%rdi
    ext->align = align;
   298e8:	c1 e3 04             	shl    $0x4,%ebx
   298eb:	09 da                	or     %ebx,%edx
   298ed:	88 50 18             	mov    %dl,0x18(%rax)
}
   298f0:	5a                   	pop    %rdx
   298f1:	5b                   	pop    %rbx
   298f2:	5d                   	pop    %rbp
    lv_obj_invalidate(label); /*Enough to invalidate because alignment is only drawing related
   298f3:	e9 ba 13 ff ff       	jmpq   1acb2 <lv_obj_invalidate>
}
   298f8:	58                   	pop    %rax
   298f9:	5b                   	pop    %rbx
   298fa:	5d                   	pop    %rbp
   298fb:	c3                   	retq   

00000000000298fc <lv_label_get_text>:
{
   298fc:	48 83 ec 08          	sub    $0x8,%rsp
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   29900:	e8 fa 29 ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    return ext->text;
   29905:	48 8b 00             	mov    (%rax),%rax
}
   29908:	5a                   	pop    %rdx
   29909:	c3                   	retq   

000000000002990a <lv_label_get_long_mode>:
{
   2990a:	48 83 ec 08          	sub    $0x8,%rsp
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   2990e:	e8 ec 29 ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    return ext->long_mode;
   29913:	8a 40 18             	mov    0x18(%rax),%al
}
   29916:	5a                   	pop    %rdx
    return ext->long_mode;
   29917:	83 e0 07             	and    $0x7,%eax
}
   2991a:	c3                   	retq   

000000000002991b <lv_label_get_align>:
{
   2991b:	48 83 ec 08          	sub    $0x8,%rsp
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   2991f:	e8 db 29 ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    lv_label_align_t align = ext->align;
   29924:	8a 40 18             	mov    0x18(%rax),%al
   29927:	c0 e8 04             	shr    $0x4,%al
   2992a:	83 e0 03             	and    $0x3,%eax
    if(align == LV_LABEL_ALIGN_AUTO) {
   2992d:	3c 03                	cmp    $0x3,%al
   2992f:	75 02                	jne    29933 <lv_label_get_align+0x18>
        align = LV_LABEL_ALIGN_LEFT;
   29931:	31 c0                	xor    %eax,%eax
}
   29933:	5a                   	pop    %rdx
   29934:	c3                   	retq   

0000000000029935 <lv_label_get_recolor>:
{
   29935:	48 83 ec 08          	sub    $0x8,%rsp
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   29939:	e8 c1 29 ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    return ext->recolor == 0 ? false : true;
   2993e:	8a 40 18             	mov    0x18(%rax),%al
}
   29941:	5a                   	pop    %rdx
    return ext->recolor == 0 ? false : true;
   29942:	c0 e8 06             	shr    $0x6,%al
   29945:	83 e0 01             	and    $0x1,%eax
}
   29948:	c3                   	retq   

0000000000029949 <lv_label_get_letter_on>:
{
   29949:	41 57                	push   %r15
   2994b:	41 56                	push   %r14
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   2994d:	ba 12 00 00 00       	mov    $0x12,%edx
   29952:	41 55                	push   %r13
   29954:	41 54                	push   %r12
   29956:	55                   	push   %rbp
   29957:	53                   	push   %rbx
   29958:	48 89 f3             	mov    %rsi,%rbx
   2995b:	48 89 fd             	mov    %rdi,%rbp
   2995e:	48 83 ec 58          	sub    $0x58,%rsp
   29962:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   29969:	00 00 
   2996b:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
   29970:	31 c0                	xor    %eax,%eax
    pos.x = pos_in->x - lv_obj_get_style_pad_left(label, LV_LABEL_PART_MAIN);
   29972:	66 8b 06             	mov    (%rsi),%ax
   29975:	31 f6                	xor    %esi,%esi
   29977:	66 89 44 24 24       	mov    %ax,0x24(%rsp)
   2997c:	e8 6c 1d ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    pos.y = pos_in->y - lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN);
   29981:	66 8b 5b 02          	mov    0x2(%rbx),%bx
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   29985:	ba 10 00 00 00       	mov    $0x10,%edx
   2998a:	31 f6                	xor    %esi,%esi
   2998c:	48 89 ef             	mov    %rbp,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   2998f:	66 89 44 24 26       	mov    %ax,0x26(%rsp)
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   29994:	e8 54 1d ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    get_txt_coords(label, &txt_coords);
   29999:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
    pos.y = pos_in->y - lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN);
   2999e:	29 c3                	sub    %eax,%ebx
    get_txt_coords(label, &txt_coords);
   299a0:	48 89 ef             	mov    %rbp,%rdi
    pos.y = pos_in->y - lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN);
   299a3:	66 89 5c 24 14       	mov    %bx,0x14(%rsp)
    get_txt_coords(label, &txt_coords);
   299a8:	e8 9d fe ff ff       	callq  2984a <get_txt_coords>
    const char * txt         = lv_label_get_text(label);
   299ad:	48 89 ef             	mov    %rbp,%rdi
   299b0:	e8 47 ff ff ff       	callq  298fc <lv_label_get_text>
    lv_label_ext_t * ext     = lv_obj_get_ext_attr(label);
   299b5:	48 89 ef             	mov    %rbp,%rdi
    const char * txt         = lv_label_get_text(label);
   299b8:	48 89 04 24          	mov    %rax,(%rsp)
    lv_label_ext_t * ext     = lv_obj_get_ext_attr(label);
   299bc:	e8 3e 29 ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
   299c1:	49 89 c5             	mov    %rax,%r13
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   299c4:	8b 44 24 44          	mov    0x44(%rsp),%eax
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_DECOR, text_decor, lv_text_decor_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_BLEND_MODE, text_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_SEL_COLOR, text_sel_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_OPA, text_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
   299c8:	31 f6                	xor    %esi,%esi
   299ca:	ba 8e 80 00 00       	mov    $0x808e,%edx
   299cf:	48 89 ef             	mov    %rbp,%rdi
   299d2:	44 8d 70 01          	lea    0x1(%rax),%r14d
   299d6:	44 2b 74 24 40       	sub    0x40(%rsp),%r14d
   299db:	66 44 89 74 24 18    	mov    %r14w,0x18(%rsp)
   299e1:	e8 73 24 ff ff       	callq  1be59 <_lv_obj_get_style_ptr>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
   299e6:	31 f6                	xor    %esi,%esi
   299e8:	ba 81 80 00 00       	mov    $0x8081,%edx
   299ed:	48 89 ef             	mov    %rbp,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
   299f0:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
   299f5:	e8 f3 1c ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
   299fa:	ba 80 80 00 00       	mov    $0x8080,%edx
   299ff:	31 f6                	xor    %esi,%esi
   29a01:	48 89 ef             	mov    %rbp,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
   29a04:	66 89 44 24 20       	mov    %ax,0x20(%rsp)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
   29a09:	e8 df 1c ff ff       	callq  1b6ed <_lv_obj_get_style_int>
   29a0e:	66 89 44 24 12       	mov    %ax,0x12(%rsp)
    lv_coord_t letter_height    = lv_font_get_line_height(font);
   29a13:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   29a18:	66 8b 58 10          	mov    0x10(%rax),%bx
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
   29a1c:	41 8a 45 18          	mov    0x18(%r13),%al
   29a20:	88 c2                	mov    %al,%dl
   29a22:	c0 ea 06             	shr    $0x6,%dl
   29a25:	83 e2 01             	and    $0x1,%edx
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
   29a28:	84 c0                	test   %al,%al
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
   29a2a:	41 88 d7             	mov    %dl,%r15b
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
   29a2d:	79 04                	jns    29a33 <lv_label_get_letter_on+0xea>
   29a2f:	41 83 cf 02          	or     $0x2,%r15d
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) flag |= LV_TXT_FLAG_FIT;
   29a33:	a8 07                	test   $0x7,%al
   29a35:	75 04                	jne    29a3b <lv_label_get_letter_on+0xf2>
   29a37:	41 83 cf 10          	or     $0x10,%r15d
    lv_label_align_t align = lv_label_get_align(label);
   29a3b:	48 89 ef             	mov    %rbp,%rdi
   29a3e:	e8 d8 fe ff ff       	callq  2991b <lv_label_get_align>
    if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
   29a43:	3c 01                	cmp    $0x1,%al
    lv_label_align_t align = lv_label_get_align(label);
   29a45:	41 88 c4             	mov    %al,%r12b
    if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
   29a48:	75 06                	jne    29a50 <lv_label_get_letter_on+0x107>
   29a4a:	41 83 cf 04          	or     $0x4,%r15d
   29a4e:	eb 08                	jmp    29a58 <lv_label_get_letter_on+0x10f>
    if(align == LV_LABEL_ALIGN_RIGHT) flag |= LV_TXT_FLAG_RIGHT;
   29a50:	3c 02                	cmp    $0x2,%al
   29a52:	75 04                	jne    29a58 <lv_label_get_letter_on+0x10f>
   29a54:	41 83 cf 08          	or     $0x8,%r15d
        new_line_start += _lv_txt_get_next_line(&txt[line_start], font, letter_space, max_w, flag);
   29a58:	41 0f b6 c7          	movzbl %r15b,%eax
{
   29a5c:	45 31 c9             	xor    %r9d,%r9d
   29a5f:	45 31 ed             	xor    %r13d,%r13d
        new_line_start += _lv_txt_get_next_line(&txt[line_start], font, letter_space, max_w, flag);
   29a62:	89 44 24 28          	mov    %eax,0x28(%rsp)
    while(txt[line_start] != '\0') {
   29a66:	48 8b 3c 24          	mov    (%rsp),%rdi
   29a6a:	44 89 e8             	mov    %r13d,%eax
   29a6d:	48 8d 2c 07          	lea    (%rdi,%rax,1),%rbp
   29a71:	80 7d 00 00          	cmpb   $0x0,0x0(%rbp)
   29a75:	74 7c                	je     29af3 <lv_label_get_letter_on+0x1aa>
        new_line_start += _lv_txt_get_next_line(&txt[line_start], font, letter_space, max_w, flag);
   29a77:	0f bf 4c 24 18       	movswl 0x18(%rsp),%ecx
   29a7c:	0f bf 54 24 12       	movswl 0x12(%rsp),%edx
   29a81:	48 89 ef             	mov    %rbp,%rdi
   29a84:	44 8b 44 24 28       	mov    0x28(%rsp),%r8d
   29a89:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   29a8e:	44 89 4c 24 2c       	mov    %r9d,0x2c(%rsp)
   29a93:	e8 91 d1 ff ff       	callq  26c29 <_lv_txt_get_next_line>
        if(pos.y <= y + letter_height) {
   29a98:	44 8b 4c 24 2c       	mov    0x2c(%rsp),%r9d
   29a9d:	0f bf 54 24 14       	movswl 0x14(%rsp),%edx
        new_line_start += _lv_txt_get_next_line(&txt[line_start], font, letter_space, max_w, flag);
   29aa2:	45 8d 74 05 00       	lea    0x0(%r13,%rax,1),%r14d
        if(pos.y <= y + letter_height) {
   29aa7:	0f bf cb             	movswl %bx,%ecx
   29aaa:	41 0f bf c1          	movswl %r9w,%eax
   29aae:	01 c8                	add    %ecx,%eax
   29ab0:	39 c2                	cmp    %eax,%edx
   29ab2:	7f 2e                	jg     29ae2 <lv_label_get_letter_on+0x199>
            letter = _lv_txt_encoded_prev(txt, &tmp);
   29ab4:	48 8d 05 d5 cf 20 00 	lea    0x20cfd5(%rip),%rax        # 236a90 <_lv_txt_encoded_prev>
            uint32_t tmp = new_line_start;
   29abb:	44 89 74 24 3c       	mov    %r14d,0x3c(%rsp)
            letter = _lv_txt_encoded_prev(txt, &tmp);
   29ac0:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
   29ac5:	48 8b 3c 24          	mov    (%rsp),%rdi
   29ac9:	ff 10                	callq  *(%rax)
            if(letter != '\n' && txt[new_line_start] == '\0') new_line_start++;
   29acb:	83 f8 0a             	cmp    $0xa,%eax
   29ace:	74 26                	je     29af6 <lv_label_get_letter_on+0x1ad>
   29ad0:	48 8b 0c 24          	mov    (%rsp),%rcx
   29ad4:	44 89 f0             	mov    %r14d,%eax
   29ad7:	80 3c 01 00          	cmpb   $0x0,(%rcx,%rax,1)
   29adb:	75 19                	jne    29af6 <lv_label_get_letter_on+0x1ad>
   29add:	41 ff c6             	inc    %r14d
   29ae0:	eb 14                	jmp    29af6 <lv_label_get_letter_on+0x1ad>
        y += letter_height + line_space;
   29ae2:	8b 44 24 20          	mov    0x20(%rsp),%eax
        new_line_start += _lv_txt_get_next_line(&txt[line_start], font, letter_space, max_w, flag);
   29ae6:	45 89 f5             	mov    %r14d,%r13d
        y += letter_height + line_space;
   29ae9:	01 d8                	add    %ebx,%eax
   29aeb:	41 01 c1             	add    %eax,%r9d
   29aee:	e9 73 ff ff ff       	jmpq   29a66 <lv_label_get_letter_on+0x11d>
   29af3:	45 89 ee             	mov    %r13d,%r14d
    if(align == LV_LABEL_ALIGN_CENTER) {
   29af6:	41 80 fc 01          	cmp    $0x1,%r12b
   29afa:	75 45                	jne    29b41 <lv_label_get_letter_on+0x1f8>
        line_w = _lv_txt_get_width(bidi_txt, new_line_start - line_start, font, letter_space, flag);
   29afc:	0f bf 4c 24 12       	movswl 0x12(%rsp),%ecx
   29b01:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   29b06:	44 89 f6             	mov    %r14d,%esi
   29b09:	44 29 ee             	sub    %r13d,%esi
   29b0c:	45 0f b6 c7          	movzbl %r15b,%r8d
   29b10:	48 89 ef             	mov    %rbp,%rdi
   29b13:	e8 15 d0 ff ff       	callq  26b2d <_lv_txt_get_width>
   29b18:	89 c1                	mov    %eax,%ecx
   29b1a:	8b 44 24 44          	mov    0x44(%rsp),%eax
        x += lv_area_get_width(&txt_coords) / 2 - line_w / 2;
   29b1e:	be 02 00 00 00       	mov    $0x2,%esi
   29b23:	ff c0                	inc    %eax
   29b25:	2b 44 24 40          	sub    0x40(%rsp),%eax
   29b29:	89 c2                	mov    %eax,%edx
   29b2b:	66 c1 fa 0f          	sar    $0xf,%dx
   29b2f:	66 f7 fe             	idiv   %si
   29b32:	89 ca                	mov    %ecx,%edx
   29b34:	66 c1 fa 0f          	sar    $0xf,%dx
   29b38:	89 c3                	mov    %eax,%ebx
   29b3a:	89 c8                	mov    %ecx,%eax
   29b3c:	66 f7 fe             	idiv   %si
   29b3f:	eb 2f                	jmp    29b70 <lv_label_get_letter_on+0x227>
    lv_coord_t x = 0;
   29b41:	31 db                	xor    %ebx,%ebx
    else if(align == LV_LABEL_ALIGN_RIGHT) {
   29b43:	41 80 fc 02          	cmp    $0x2,%r12b
   29b47:	75 29                	jne    29b72 <lv_label_get_letter_on+0x229>
        line_w = _lv_txt_get_width(bidi_txt, new_line_start - line_start, font, letter_space, flag);
   29b49:	0f bf 4c 24 12       	movswl 0x12(%rsp),%ecx
   29b4e:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   29b53:	44 89 f6             	mov    %r14d,%esi
   29b56:	44 29 ee             	sub    %r13d,%esi
   29b59:	45 0f b6 c7          	movzbl %r15b,%r8d
   29b5d:	48 89 ef             	mov    %rbp,%rdi
   29b60:	e8 c8 cf ff ff       	callq  26b2d <_lv_txt_get_width>
   29b65:	8b 4c 24 44          	mov    0x44(%rsp),%ecx
   29b69:	8d 59 01             	lea    0x1(%rcx),%ebx
   29b6c:	2b 5c 24 40          	sub    0x40(%rsp),%ebx
        x += lv_area_get_width(&txt_coords) - line_w;
   29b70:	29 c3                	sub    %eax,%ebx
    if(new_line_start > 0) {
   29b72:	45 85 f6             	test   %r14d,%r14d
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
   29b75:	c6 44 24 3b 00       	movb   $0x0,0x3b(%rsp)
    uint32_t i = 0;
   29b7a:	c7 44 24 3c 00 00 00 	movl   $0x0,0x3c(%rsp)
   29b81:	00 
    if(new_line_start > 0) {
   29b82:	0f 84 d1 00 00 00    	je     29c59 <lv_label_get_letter_on+0x310>
    pos.x = pos_in->x - lv_obj_get_style_pad_left(label, LV_LABEL_PART_MAIN);
   29b88:	8b 44 24 24          	mov    0x24(%rsp),%eax
   29b8c:	66 2b 44 24 26       	sub    0x26(%rsp),%ax
    uint32_t i_act = i;
   29b91:	45 31 e4             	xor    %r12d,%r12d
    pos.x = pos_in->x - lv_obj_get_style_pad_left(label, LV_LABEL_PART_MAIN);
   29b94:	66 89 44 24 24       	mov    %ax,0x24(%rsp)
            uint32_t letter = _lv_txt_encoded_next(bidi_txt, &i);
   29b99:	48 8d 44 24 3c       	lea    0x3c(%rsp),%rax
   29b9e:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
        while(i + line_start < new_line_start) {
   29ba3:	8b 44 24 3c          	mov    0x3c(%rsp),%eax
   29ba7:	44 01 e8             	add    %r13d,%eax
   29baa:	44 39 f0             	cmp    %r14d,%eax
   29bad:	0f 83 a6 00 00 00    	jae    29c59 <lv_label_get_letter_on+0x310>
            uint32_t letter = _lv_txt_encoded_next(bidi_txt, &i);
   29bb3:	48 8d 05 de ce 20 00 	lea    0x20cede(%rip),%rax        # 236a98 <_lv_txt_encoded_next>
   29bba:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
   29bbf:	48 89 ef             	mov    %rbp,%rdi
   29bc2:	ff 10                	callq  *(%rax)
            uint32_t letter_next = _lv_txt_encoded_next(&bidi_txt[i], NULL);
   29bc4:	8b 7c 24 3c          	mov    0x3c(%rsp),%edi
            uint32_t letter = _lv_txt_encoded_next(bidi_txt, &i);
   29bc8:	89 44 24 14          	mov    %eax,0x14(%rsp)
            uint32_t letter_next = _lv_txt_encoded_next(&bidi_txt[i], NULL);
   29bcc:	31 f6                	xor    %esi,%esi
   29bce:	48 8d 05 c3 ce 20 00 	lea    0x20cec3(%rip),%rax        # 236a98 <_lv_txt_encoded_next>
   29bd5:	48 01 ef             	add    %rbp,%rdi
   29bd8:	ff 10                	callq  *(%rax)
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
   29bda:	41 f6 c7 01          	test   $0x1,%r15b
            uint32_t letter_next = _lv_txt_encoded_next(&bidi_txt[i], NULL);
   29bde:	89 c2                	mov    %eax,%edx
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
   29be0:	75 21                	jne    29c03 <lv_label_get_letter_on+0x2ba>
            lv_coord_t gw = lv_font_get_glyph_width(font, letter, letter_next);
   29be2:	8b 74 24 14          	mov    0x14(%rsp),%esi
   29be6:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   29beb:	e8 f0 d4 ff ff       	callq  270e0 <lv_font_get_glyph_width>
            if(pos.x < x + gw || i + line_start == new_line_start ||  txt[i_act + line_start] == '\0') {
   29bf0:	0f bf 4c 24 24       	movswl 0x24(%rsp),%ecx
   29bf5:	0f bf d3             	movswl %bx,%edx
   29bf8:	0f bf f0             	movswl %ax,%esi
   29bfb:	01 f2                	add    %esi,%edx
   29bfd:	39 d1                	cmp    %edx,%ecx
   29bff:	7d 26                	jge    29c27 <lv_label_get_letter_on+0x2de>
   29c01:	eb 40                	jmp    29c43 <lv_label_get_letter_on+0x2fa>
   29c03:	89 44 24 20          	mov    %eax,0x20(%rsp)
                if(_lv_txt_is_cmd(&cmd_state, bidi_txt[i]) != false) {
   29c07:	8b 44 24 3c          	mov    0x3c(%rsp),%eax
   29c0b:	48 8d 7c 24 3b       	lea    0x3b(%rsp),%rdi
   29c10:	0f be 74 05 00       	movsbl 0x0(%rbp,%rax,1),%esi
   29c15:	e8 dd ce ff ff       	callq  26af7 <_lv_txt_is_cmd>
   29c1a:	84 c0                	test   %al,%al
   29c1c:	8b 54 24 20          	mov    0x20(%rsp),%edx
   29c20:	74 c0                	je     29be2 <lv_label_get_letter_on+0x299>
   29c22:	e9 7c ff ff ff       	jmpq   29ba3 <lv_label_get_letter_on+0x25a>
            if(pos.x < x + gw || i + line_start == new_line_start ||  txt[i_act + line_start] == '\0') {
   29c27:	8b 4c 24 3c          	mov    0x3c(%rsp),%ecx
   29c2b:	42 8d 14 29          	lea    (%rcx,%r13,1),%edx
   29c2f:	44 39 f2             	cmp    %r14d,%edx
   29c32:	74 0f                	je     29c43 <lv_label_get_letter_on+0x2fa>
   29c34:	48 8b 3c 24          	mov    (%rsp),%rdi
   29c38:	43 8d 54 25 00       	lea    0x0(%r13,%r12,1),%edx
   29c3d:	80 3c 17 00          	cmpb   $0x0,(%rdi,%rdx,1)
   29c41:	75 07                	jne    29c4a <lv_label_get_letter_on+0x301>
                i = i_act;
   29c43:	44 89 64 24 3c       	mov    %r12d,0x3c(%rsp)
                break;
   29c48:	eb 0f                	jmp    29c59 <lv_label_get_letter_on+0x310>
            x += letter_space;
   29c4a:	66 03 5c 24 12       	add    0x12(%rsp),%bx
            i_act = i;
   29c4f:	41 89 cc             	mov    %ecx,%r12d
            x += letter_space;
   29c52:	01 c3                	add    %eax,%ebx
   29c54:	e9 4a ff ff ff       	jmpq   29ba3 <lv_label_get_letter_on+0x25a>
    logical_pos = _lv_txt_encoded_get_char_id(bidi_txt, i);
   29c59:	48 8d 1d 20 ce 20 00 	lea    0x20ce20(%rip),%rbx        # 236a80 <_lv_txt_encoded_get_char_id>
   29c60:	48 89 ef             	mov    %rbp,%rdi
   29c63:	8b 74 24 3c          	mov    0x3c(%rsp),%esi
   29c67:	ff 13                	callq  *(%rbx)
   29c69:	89 c5                	mov    %eax,%ebp
    return  logical_pos + _lv_txt_encoded_get_char_id(txt, line_start);
   29c6b:	44 89 ee             	mov    %r13d,%esi
   29c6e:	48 8b 3c 24          	mov    (%rsp),%rdi
   29c72:	ff 13                	callq  *(%rbx)
   29c74:	01 e8                	add    %ebp,%eax
}
   29c76:	48 8b 5c 24 48       	mov    0x48(%rsp),%rbx
   29c7b:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
   29c82:	00 00 
   29c84:	74 05                	je     29c8b <lv_label_get_letter_on+0x342>
   29c86:	e8 b5 a9 fd ff       	callq  4640 <__stack_chk_fail@plt>
   29c8b:	48 83 c4 58          	add    $0x58,%rsp
   29c8f:	5b                   	pop    %rbx
   29c90:	5d                   	pop    %rbp
   29c91:	41 5c                	pop    %r12
   29c93:	41 5d                	pop    %r13
   29c95:	41 5e                	pop    %r14
   29c97:	41 5f                	pop    %r15
   29c99:	c3                   	retq   

0000000000029c9a <lv_label_refr_text>:
{
   29c9a:	41 57                	push   %r15
   29c9c:	41 56                	push   %r14
   29c9e:	41 55                	push   %r13
   29ca0:	41 54                	push   %r12
   29ca2:	55                   	push   %rbp
   29ca3:	53                   	push   %rbx
   29ca4:	48 89 fb             	mov    %rdi,%rbx
   29ca7:	48 83 ec 48          	sub    $0x48,%rsp
   29cab:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   29cb2:	00 00 
   29cb4:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
   29cb9:	31 c0                	xor    %eax,%eax
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   29cbb:	e8 3f 26 ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    if(ext->text == NULL) return;
   29cc0:	48 83 38 00          	cmpq   $0x0,(%rax)
   29cc4:	0f 84 d9 02 00 00    	je     29fa3 <lv_label_refr_text+0x309>
    get_txt_coords(label, &txt_coords);
   29cca:	48 8d 74 24 30       	lea    0x30(%rsp),%rsi
   29ccf:	48 89 df             	mov    %rbx,%rdi
   29cd2:	49 89 c6             	mov    %rax,%r14
   29cd5:	e8 70 fb ff ff       	callq  2984a <get_txt_coords>
   29cda:	8b 44 24 34          	mov    0x34(%rsp),%eax
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
   29cde:	31 f6                	xor    %esi,%esi
   29ce0:	ba 8e 80 00 00       	mov    $0x808e,%edx
   29ce5:	48 89 df             	mov    %rbx,%rdi
   29ce8:	8d 68 01             	lea    0x1(%rax),%ebp
   29ceb:	2b 6c 24 30          	sub    0x30(%rsp),%ebp
   29cef:	e8 65 21 ff ff       	callq  1be59 <_lv_obj_get_style_ptr>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
   29cf4:	31 f6                	xor    %esi,%esi
   29cf6:	ba 81 80 00 00       	mov    $0x8081,%edx
   29cfb:	48 89 df             	mov    %rbx,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
   29cfe:	49 89 c5             	mov    %rax,%r13
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
   29d01:	e8 e7 19 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
   29d06:	ba 80 80 00 00       	mov    $0x8080,%edx
   29d0b:	31 f6                	xor    %esi,%esi
   29d0d:	48 89 df             	mov    %rbx,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
   29d10:	66 89 44 24 08       	mov    %ax,0x8(%rsp)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
   29d15:	e8 d3 19 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
   29d1a:	41 8a 4e 18          	mov    0x18(%r14),%cl
   29d1e:	88 ca                	mov    %cl,%dl
   29d20:	c0 ea 06             	shr    $0x6,%dl
   29d23:	83 e2 01             	and    $0x1,%edx
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
   29d26:	84 c9                	test   %cl,%cl
   29d28:	79 03                	jns    29d2d <lv_label_refr_text+0x93>
   29d2a:	83 ca 02             	or     $0x2,%edx
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) flag |= LV_TXT_FLAG_FIT;
   29d2d:	80 e1 07             	and    $0x7,%cl
   29d30:	75 03                	jne    29d35 <lv_label_refr_text+0x9b>
   29d32:	83 ca 10             	or     $0x10,%edx
    _lv_txt_get_size(&size, ext->text, font, letter_space, line_space, max_w, flag);
   29d35:	44 0f bf 7c 24 08    	movswl 0x8(%rsp),%r15d
   29d3b:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
   29d40:	0f b6 d2             	movzbl %dl,%edx
   29d43:	48 83 ec 08          	sub    $0x8,%rsp
   29d47:	49 8b 36             	mov    (%r14),%rsi
   29d4a:	44 0f bf e0          	movswl %ax,%r12d
   29d4e:	52                   	push   %rdx
   29d4f:	44 0f bf cd          	movswl %bp,%r9d
   29d53:	4c 89 ea             	mov    %r13,%rdx
   29d56:	44 89 e1             	mov    %r12d,%ecx
   29d59:	45 89 f8             	mov    %r15d,%r8d
   29d5c:	e8 99 d1 ff ff       	callq  26efa <_lv_txt_get_size>
   29d61:	58                   	pop    %rax
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
   29d62:	41 8a 46 18          	mov    0x18(%r14),%al
    _lv_txt_get_size(&size, ext->text, font, letter_space, line_space, max_w, flag);
   29d66:	5a                   	pop    %rdx
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
   29d67:	24 07                	and    $0x7,%al
   29d69:	75 6a                	jne    29dd5 <lv_label_refr_text+0x13b>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   29d6b:	31 f6                	xor    %esi,%esi
   29d6d:	48 89 df             	mov    %rbx,%rdi
   29d70:	ba 12 00 00 00       	mov    $0x12,%edx
   29d75:	e8 73 19 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   29d7a:	31 f6                	xor    %esi,%esi
   29d7c:	48 89 df             	mov    %rbx,%rdi
   29d7f:	ba 13 00 00 00       	mov    $0x13,%edx
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   29d84:	0f bf e8             	movswl %ax,%ebp
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   29d87:	e8 61 19 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   29d8c:	31 f6                	xor    %esi,%esi
   29d8e:	48 89 df             	mov    %rbx,%rdi
        size.x += lv_obj_get_style_pad_left(label, LV_LABEL_PART_MAIN) + lv_obj_get_style_pad_right(label, LV_LABEL_PART_MAIN);
   29d91:	98                   	cwtl   
   29d92:	ba 10 00 00 00       	mov    $0x10,%edx
   29d97:	01 c5                	add    %eax,%ebp
   29d99:	66 01 6c 24 28       	add    %bp,0x28(%rsp)
   29d9e:	e8 4a 19 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   29da3:	31 f6                	xor    %esi,%esi
   29da5:	48 89 df             	mov    %rbx,%rdi
   29da8:	ba 11 00 00 00       	mov    $0x11,%edx
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   29dad:	89 c5                	mov    %eax,%ebp
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   29daf:	e8 39 19 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
        size.y += lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN) + lv_obj_get_style_pad_bottom(label, LV_LABEL_PART_MAIN);
   29db4:	66 03 6c 24 2a       	add    0x2a(%rsp),%bp
        lv_obj_set_size(label, size.x, size.y);
   29db9:	0f bf 74 24 28       	movswl 0x28(%rsp),%esi
   29dbe:	48 89 df             	mov    %rbx,%rdi
        size.y += lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN) + lv_obj_get_style_pad_bottom(label, LV_LABEL_PART_MAIN);
   29dc1:	01 e8                	add    %ebp,%eax
        lv_obj_set_size(label, size.x, size.y);
   29dc3:	0f bf d0             	movswl %ax,%edx
        size.y += lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN) + lv_obj_get_style_pad_bottom(label, LV_LABEL_PART_MAIN);
   29dc6:	66 89 44 24 2a       	mov    %ax,0x2a(%rsp)
        lv_obj_set_size(label, size.x, size.y);
   29dcb:	e8 ae 16 ff ff       	callq  1b47e <lv_obj_set_size>
   29dd0:	e9 c6 01 00 00       	jmpq   29f9b <lv_label_refr_text+0x301>
    else if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) {
   29dd5:	8d 50 fd             	lea    -0x3(%rax),%edx
   29dd8:	80 fa 01             	cmp    $0x1,%dl
   29ddb:	0f 86 ba 01 00 00    	jbe    29f9b <lv_label_refr_text+0x301>
    else if(ext->long_mode == LV_LABEL_LONG_DOT) {
   29de1:	3c 02                	cmp    $0x2,%al
   29de3:	0f 85 77 01 00 00    	jne    29f60 <lv_label_refr_text+0x2c6>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   29de9:	66 8b 44 24 36       	mov    0x36(%rsp),%ax
   29dee:	ff c0                	inc    %eax
   29df0:	66 2b 44 24 32       	sub    0x32(%rsp),%ax
        if(size.y <= lv_area_get_height(&txt_coords)) { /*No dots are required, the text is short enough*/
   29df5:	66 39 44 24 2a       	cmp    %ax,0x2a(%rsp)
   29dfa:	7e 11                	jle    29e0d <lv_label_refr_text+0x173>
        else if(_lv_txt_get_encoded_length(ext->text) <= LV_LABEL_DOT_NUM) {   /*Don't turn to dots all the characters*/
   29dfc:	48 8d 05 75 cc 20 00 	lea    0x20cc75(%rip),%rax        # 236a78 <_lv_txt_get_encoded_length>
   29e03:	49 8b 3e             	mov    (%r14),%rdi
   29e06:	ff 10                	callq  *(%rax)
   29e08:	83 f8 03             	cmp    $0x3,%eax
   29e0b:	77 0d                	ja     29e1a <lv_label_refr_text+0x180>
            ext->dot_end = LV_LABEL_DOT_END_INV;
   29e0d:	41 c7 46 10 ff ff 00 	movl   $0xffff,0x10(%r14)
   29e14:	00 
   29e15:	e9 81 01 00 00       	jmpq   29f9b <lv_label_refr_text+0x301>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   29e1a:	8b 44 24 34          	mov    0x34(%rsp),%eax
                  (lv_font_get_glyph_width(font, '.', '.') + letter_space) *
   29e1e:	ba 2e 00 00 00       	mov    $0x2e,%edx
   29e23:	be 2e 00 00 00       	mov    $0x2e,%esi
   29e28:	4c 89 ef             	mov    %r13,%rdi
   29e2b:	8d 68 01             	lea    0x1(%rax),%ebp
   29e2e:	2b 6c 24 30          	sub    0x30(%rsp),%ebp
   29e32:	e8 a9 d2 ff ff       	callq  270e0 <lv_font_get_glyph_width>
   29e37:	41 01 c4             	add    %eax,%r12d
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   29e3a:	66 8b 44 24 36       	mov    0x36(%rsp),%ax
                   (lv_font_get_line_height(font) + line_space); /*Round down to the last line*/
   29e3f:	41 0f bf 75 10       	movswl 0x10(%r13),%esi
            p.x = lv_area_get_width(&txt_coords) -
   29e44:	45 6b e4 fd          	imul   $0xfffffffd,%r12d,%r12d
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
   29e48:	48 89 df             	mov    %rbx,%rdi
   29e4b:	8d 48 01             	lea    0x1(%rax),%ecx
   29e4e:	66 2b 4c 24 32       	sub    0x32(%rsp),%cx
                   (lv_font_get_line_height(font) + line_space); /*Round down to the last line*/
   29e53:	41 01 f7             	add    %esi,%r15d
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
   29e56:	48 8d 74 24 2c       	lea    0x2c(%rsp),%rsi
            p.x = lv_area_get_width(&txt_coords) -
   29e5b:	44 01 e5             	add    %r12d,%ebp
   29e5e:	66 89 6c 24 2c       	mov    %bp,0x2c(%rsp)
            p.y -= p.y %
   29e63:	0f bf c1             	movswl %cx,%eax
   29e66:	99                   	cltd   
   29e67:	41 f7 ff             	idiv   %r15d
   29e6a:	29 d1                	sub    %edx,%ecx
            p.y -= line_space;                                               /*Trim the last line space*/
   29e6c:	2b 4c 24 08          	sub    0x8(%rsp),%ecx
   29e70:	66 89 4c 24 2e       	mov    %cx,0x2e(%rsp)
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
   29e75:	e8 cf fa ff ff       	callq  29949 <lv_label_get_letter_on>
            size_t txt_len = strlen(ext->text);
   29e7a:	49 8b 3e             	mov    (%r14),%rdi
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
   29e7d:	89 c5                	mov    %eax,%ebp
            size_t txt_len = strlen(ext->text);
   29e7f:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
   29e83:	31 c0                	xor    %eax,%eax
            uint32_t byte_id     = _lv_txt_encoded_get_byte_id(ext->text, letter_id);
   29e85:	89 ee                	mov    %ebp,%esi
            size_t txt_len = strlen(ext->text);
   29e87:	f2 ae                	repnz scas %es:(%rdi),%al
            uint32_t byte_id     = _lv_txt_encoded_get_byte_id(ext->text, letter_id);
   29e89:	48 8d 05 f8 cb 20 00 	lea    0x20cbf8(%rip),%rax        # 236a88 <_lv_txt_encoded_get_byte_id>
   29e90:	49 8b 3e             	mov    (%r14),%rdi
            size_t txt_len = strlen(ext->text);
   29e93:	48 f7 d1             	not    %rcx
   29e96:	4c 8d 61 ff          	lea    -0x1(%rcx),%r12
            uint32_t byte_id     = _lv_txt_encoded_get_byte_id(ext->text, letter_id);
   29e9a:	ff 10                	callq  *(%rax)
   29e9c:	89 44 24 24          	mov    %eax,0x24(%rsp)
            while(byte_id + LV_LABEL_DOT_NUM > txt_len) {
   29ea0:	44 8b 6c 24 24       	mov    0x24(%rsp),%r13d
   29ea5:	49 8b 3e             	mov    (%r14),%rdi
   29ea8:	41 8d 45 03          	lea    0x3(%r13),%eax
   29eac:	4c 01 ef             	add    %r13,%rdi
   29eaf:	4d 89 ef             	mov    %r13,%r15
   29eb2:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   29eb7:	4c 39 64 24 08       	cmp    %r12,0x8(%rsp)
   29ebc:	48 8d 05 dd cb 20 00 	lea    0x20cbdd(%rip),%rax        # 236aa0 <_lv_txt_encoded_size>
   29ec3:	48 8b 00             	mov    (%rax),%rax
   29ec6:	76 0d                	jbe    29ed5 <lv_label_refr_text+0x23b>
                byte_id -= _lv_txt_encoded_size(&ext->text[byte_id]);
   29ec8:	ff d0                	callq  *%rax
                letter_id--;
   29eca:	ff cd                	dec    %ebp
                byte_id -= _lv_txt_encoded_size(&ext->text[byte_id]);
   29ecc:	0f b6 c0             	movzbl %al,%eax
   29ecf:	29 44 24 24          	sub    %eax,0x24(%rsp)
   29ed3:	eb cb                	jmp    29ea0 <lv_label_refr_text+0x206>
                _lv_txt_encoded_next(ext->text, &byte_id);
   29ed5:	48 8d 44 24 24       	lea    0x24(%rsp),%rax
   29eda:	ba 04 00 00 00       	mov    $0x4,%edx
            uint8_t len          = 0;
   29edf:	45 31 e4             	xor    %r12d,%r12d
                _lv_txt_encoded_next(ext->text, &byte_id);
   29ee2:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
                len += _lv_txt_encoded_size(&ext->text[byte_id]);
   29ee7:	48 8d 05 b2 cb 20 00 	lea    0x20cbb2(%rip),%rax        # 236aa0 <_lv_txt_encoded_size>
   29eee:	8b 7c 24 24          	mov    0x24(%rsp),%edi
   29ef2:	49 03 3e             	add    (%r14),%rdi
   29ef5:	89 54 24 1c          	mov    %edx,0x1c(%rsp)
   29ef9:	ff 10                	callq  *(%rax)
   29efb:	41 01 c4             	add    %eax,%r12d
                _lv_txt_encoded_next(ext->text, &byte_id);
   29efe:	48 8d 05 93 cb 20 00 	lea    0x20cb93(%rip),%rax        # 236a98 <_lv_txt_encoded_next>
   29f05:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
   29f0a:	49 8b 3e             	mov    (%r14),%rdi
   29f0d:	ff 10                	callq  *(%rax)
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
   29f0f:	8b 54 24 1c          	mov    0x1c(%rsp),%edx
   29f13:	ff ca                	dec    %edx
   29f15:	75 d0                	jne    29ee7 <lv_label_refr_text+0x24d>
            if(lv_label_set_dot_tmp(label, &ext->text[byte_id_ori], len)) {
   29f17:	49 8b 36             	mov    (%r14),%rsi
   29f1a:	41 0f b6 d4          	movzbl %r12b,%edx
   29f1e:	48 89 df             	mov    %rbx,%rdi
   29f21:	4c 01 ee             	add    %r13,%rsi
   29f24:	e8 84 f8 ff ff       	callq  297ad <lv_label_set_dot_tmp>
   29f29:	84 c0                	test   %al,%al
   29f2b:	74 6e                	je     29f9b <lv_label_refr_text+0x301>
                    ext->text[byte_id_ori + i] = '.';
   29f2d:	49 8b 06             	mov    (%r14),%rax
                ext->text[byte_id_ori + LV_LABEL_DOT_NUM] = '\0';
   29f30:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
                ext->dot_end                              = letter_id + LV_LABEL_DOT_NUM;
   29f35:	83 c5 03             	add    $0x3,%ebp
                    ext->text[byte_id_ori + i] = '.';
   29f38:	42 c6 04 28 2e       	movb   $0x2e,(%rax,%r13,1)
   29f3d:	49 8b 16             	mov    (%r14),%rdx
   29f40:	41 8d 47 01          	lea    0x1(%r15),%eax
   29f44:	c6 04 02 2e          	movb   $0x2e,(%rdx,%rax,1)
   29f48:	49 8b 16             	mov    (%r14),%rdx
   29f4b:	41 8d 47 02          	lea    0x2(%r15),%eax
   29f4f:	c6 04 02 2e          	movb   $0x2e,(%rdx,%rax,1)
                ext->text[byte_id_ori + LV_LABEL_DOT_NUM] = '\0';
   29f53:	49 8b 06             	mov    (%r14),%rax
   29f56:	c6 04 08 00          	movb   $0x0,(%rax,%rcx,1)
                ext->dot_end                              = letter_id + LV_LABEL_DOT_NUM;
   29f5a:	41 89 6e 10          	mov    %ebp,0x10(%r14)
   29f5e:	eb 3b                	jmp    29f9b <lv_label_refr_text+0x301>
    else if(ext->long_mode == LV_LABEL_LONG_BREAK) {
   29f60:	fe c8                	dec    %al
   29f62:	75 37                	jne    29f9b <lv_label_refr_text+0x301>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   29f64:	ba 10 00 00 00       	mov    $0x10,%edx
   29f69:	31 f6                	xor    %esi,%esi
   29f6b:	48 89 df             	mov    %rbx,%rdi
   29f6e:	e8 7a 17 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   29f73:	31 f6                	xor    %esi,%esi
   29f75:	48 89 df             	mov    %rbx,%rdi
   29f78:	ba 11 00 00 00       	mov    $0x11,%edx
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   29f7d:	89 c5                	mov    %eax,%ebp
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   29f7f:	e8 69 17 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
        size.y += lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN) + lv_obj_get_style_pad_bottom(label, LV_LABEL_PART_MAIN);
   29f84:	66 03 6c 24 2a       	add    0x2a(%rsp),%bp
        lv_obj_set_height(label, size.y);
   29f89:	48 89 df             	mov    %rbx,%rdi
        size.y += lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN) + lv_obj_get_style_pad_bottom(label, LV_LABEL_PART_MAIN);
   29f8c:	01 e8                	add    %ebp,%eax
        lv_obj_set_height(label, size.y);
   29f8e:	0f bf f0             	movswl %ax,%esi
        size.y += lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN) + lv_obj_get_style_pad_bottom(label, LV_LABEL_PART_MAIN);
   29f91:	66 89 44 24 2a       	mov    %ax,0x2a(%rsp)
        lv_obj_set_height(label, size.y);
   29f96:	e8 0a 16 ff ff       	callq  1b5a5 <lv_obj_set_height>
    lv_obj_invalidate(label);
   29f9b:	48 89 df             	mov    %rbx,%rdi
   29f9e:	e8 0f 0d ff ff       	callq  1acb2 <lv_obj_invalidate>
}
   29fa3:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
   29fa8:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
   29faf:	00 00 
   29fb1:	74 05                	je     29fb8 <lv_label_refr_text+0x31e>
   29fb3:	e8 88 a6 fd ff       	callq  4640 <__stack_chk_fail@plt>
   29fb8:	48 83 c4 48          	add    $0x48,%rsp
   29fbc:	5b                   	pop    %rbx
   29fbd:	5d                   	pop    %rbp
   29fbe:	41 5c                	pop    %r12
   29fc0:	41 5d                	pop    %r13
   29fc2:	41 5e                	pop    %r14
   29fc4:	41 5f                	pop    %r15
   29fc6:	c3                   	retq   

0000000000029fc7 <lv_label_set_text>:
{
   29fc7:	41 54                	push   %r12
   29fc9:	55                   	push   %rbp
   29fca:	48 89 fd             	mov    %rdi,%rbp
   29fcd:	53                   	push   %rbx
   29fce:	49 89 f4             	mov    %rsi,%r12
    lv_obj_invalidate(label);
   29fd1:	e8 dc 0c ff ff       	callq  1acb2 <lv_obj_invalidate>
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   29fd6:	48 89 ef             	mov    %rbp,%rdi
   29fd9:	e8 21 23 ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    if(text == NULL) {
   29fde:	4d 85 e4             	test   %r12,%r12
   29fe1:	75 0c                	jne    29fef <lv_label_set_text+0x28>
}
   29fe3:	5b                   	pop    %rbx
        lv_label_refr_text(label);
   29fe4:	48 89 ef             	mov    %rbp,%rdi
}
   29fe7:	5d                   	pop    %rbp
   29fe8:	41 5c                	pop    %r12
        lv_label_refr_text(label);
   29fea:	e9 ab fc ff ff       	jmpq   29c9a <lv_label_refr_text>
    if(ext->text == text && ext->static_txt == 0) {
   29fef:	48 8b 10             	mov    (%rax),%rdx
   29ff2:	48 89 c3             	mov    %rax,%rbx
   29ff5:	4c 39 e2             	cmp    %r12,%rdx
   29ff8:	75 28                	jne    2a022 <lv_label_set_text+0x5b>
   29ffa:	8a 40 18             	mov    0x18(%rax),%al
   29ffd:	24 08                	and    $0x8,%al
   29fff:	75 26                	jne    2a027 <lv_label_set_text+0x60>
        ext->text = lv_mem_realloc(ext->text, strlen(ext->text) + 1);
   2a001:	48 89 d7             	mov    %rdx,%rdi
   2a004:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
   2a008:	f2 ae                	repnz scas %es:(%rdi),%al
   2a00a:	48 89 d7             	mov    %rdx,%rdi
   2a00d:	48 f7 d1             	not    %rcx
   2a010:	48 89 ce             	mov    %rcx,%rsi
   2a013:	e8 25 c1 ff ff       	callq  2613d <lv_mem_realloc>
        if(ext->text == NULL) return;
   2a018:	48 85 c0             	test   %rax,%rax
        ext->text = lv_mem_realloc(ext->text, strlen(ext->text) + 1);
   2a01b:	48 89 03             	mov    %rax,(%rbx)
        if(ext->text == NULL) return;
   2a01e:	75 c3                	jne    29fe3 <lv_label_set_text+0x1c>
   2a020:	eb 4c                	jmp    2a06e <lv_label_set_text+0xa7>
        if(ext->text != NULL && ext->static_txt == 0) {
   2a022:	48 85 d2             	test   %rdx,%rdx
   2a025:	74 15                	je     2a03c <lv_label_set_text+0x75>
   2a027:	f6 43 18 08          	testb  $0x8,0x18(%rbx)
   2a02b:	75 0f                	jne    2a03c <lv_label_set_text+0x75>
            lv_mem_free(ext->text);
   2a02d:	48 89 d7             	mov    %rdx,%rdi
   2a030:	e8 cf c0 ff ff       	callq  26104 <lv_mem_free>
            ext->text = NULL;
   2a035:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
        size_t len = strlen(text) + 1;
   2a03c:	31 c0                	xor    %eax,%eax
   2a03e:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
   2a042:	4c 89 e7             	mov    %r12,%rdi
   2a045:	f2 ae                	repnz scas %es:(%rdi),%al
   2a047:	48 f7 d1             	not    %rcx
   2a04a:	48 89 cf             	mov    %rcx,%rdi
        ext->text = lv_mem_alloc(len);
   2a04d:	e8 3f c0 ff ff       	callq  26091 <lv_mem_alloc>
        if(ext->text == NULL) return;
   2a052:	48 85 c0             	test   %rax,%rax
        ext->text = lv_mem_alloc(len);
   2a055:	48 89 03             	mov    %rax,(%rbx)
        if(ext->text == NULL) return;
   2a058:	74 14                	je     2a06e <lv_label_set_text+0xa7>
  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
   2a05a:	4c 89 e6             	mov    %r12,%rsi
   2a05d:	48 89 c7             	mov    %rax,%rdi
   2a060:	e8 6b a5 fd ff       	callq  45d0 <strcpy@plt>
        ext->static_txt = 0;
   2a065:	80 63 18 f7          	andb   $0xf7,0x18(%rbx)
   2a069:	e9 75 ff ff ff       	jmpq   29fe3 <lv_label_set_text+0x1c>
}
   2a06e:	5b                   	pop    %rbx
   2a06f:	5d                   	pop    %rbp
   2a070:	41 5c                	pop    %r12
   2a072:	c3                   	retq   

000000000002a073 <lv_label_set_text_static>:
{
   2a073:	41 54                	push   %r12
   2a075:	55                   	push   %rbp
   2a076:	49 89 f4             	mov    %rsi,%r12
   2a079:	53                   	push   %rbx
   2a07a:	48 89 fd             	mov    %rdi,%rbp
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   2a07d:	e8 7d 22 ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    if(ext->static_txt == 0 && ext->text != NULL) {
   2a082:	f6 40 18 08          	testb  $0x8,0x18(%rax)
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   2a086:	48 89 c3             	mov    %rax,%rbx
    if(ext->static_txt == 0 && ext->text != NULL) {
   2a089:	75 14                	jne    2a09f <lv_label_set_text_static+0x2c>
   2a08b:	48 8b 38             	mov    (%rax),%rdi
   2a08e:	48 85 ff             	test   %rdi,%rdi
   2a091:	74 0c                	je     2a09f <lv_label_set_text_static+0x2c>
        lv_mem_free(ext->text);
   2a093:	e8 6c c0 ff ff       	callq  26104 <lv_mem_free>
        ext->text = NULL;
   2a098:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
    if(text != NULL) {
   2a09f:	4d 85 e4             	test   %r12,%r12
   2a0a2:	74 07                	je     2a0ab <lv_label_set_text_static+0x38>
        ext->static_txt = 1;
   2a0a4:	80 4b 18 08          	orb    $0x8,0x18(%rbx)
        ext->text       = (char *)text;
   2a0a8:	4c 89 23             	mov    %r12,(%rbx)
}
   2a0ab:	5b                   	pop    %rbx
    lv_label_refr_text(label);
   2a0ac:	48 89 ef             	mov    %rbp,%rdi
}
   2a0af:	5d                   	pop    %rbp
   2a0b0:	41 5c                	pop    %r12
    lv_label_refr_text(label);
   2a0b2:	e9 e3 fb ff ff       	jmpq   29c9a <lv_label_refr_text>

000000000002a0b7 <lv_label_set_long_mode>:
{
   2a0b7:	41 54                	push   %r12
   2a0b9:	55                   	push   %rbp
   2a0ba:	41 89 f4             	mov    %esi,%r12d
   2a0bd:	53                   	push   %rbx
   2a0be:	48 89 fd             	mov    %rdi,%rbp
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   2a0c1:	e8 39 22 ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
   2a0c6:	8a 50 18             	mov    0x18(%rax),%dl
    if(long_mode == LV_LABEL_LONG_SROLL || long_mode == LV_LABEL_LONG_SROLL_CIRC || long_mode == LV_LABEL_LONG_CROP)
   2a0c9:	41 8d 4c 24 fd       	lea    -0x3(%r12),%ecx
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   2a0ce:	48 89 c3             	mov    %rax,%rbx
    ext->offset.x = 0;
   2a0d1:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%rax)
        ext->expand = 1;
   2a0d8:	88 d0                	mov    %dl,%al
   2a0da:	83 ca 80             	or     $0xffffff80,%edx
   2a0dd:	83 e0 7f             	and    $0x7f,%eax
   2a0e0:	80 f9 03             	cmp    $0x3,%cl
   2a0e3:	0f 43 d0             	cmovae %eax,%edx
   2a0e6:	88 53 18             	mov    %dl,0x18(%rbx)
    if(ext->long_mode == LV_LABEL_LONG_DOT && ext->dot_end != LV_LABEL_DOT_END_INV) {
   2a0e9:	83 e2 07             	and    $0x7,%edx
   2a0ec:	80 fa 02             	cmp    $0x2,%dl
   2a0ef:	75 11                	jne    2a102 <lv_label_set_long_mode+0x4b>
   2a0f1:	81 7b 10 ff ff 00 00 	cmpl   $0xffff,0x10(%rbx)
   2a0f8:	74 08                	je     2a102 <lv_label_set_long_mode+0x4b>
        lv_label_revert_dots(label);
   2a0fa:	48 89 ef             	mov    %rbp,%rdi
   2a0fd:	e8 26 f6 ff ff       	callq  29728 <lv_label_revert_dots>
    ext->long_mode = long_mode;
   2a102:	40 8a 73 18          	mov    0x18(%rbx),%sil
   2a106:	41 83 e4 07          	and    $0x7,%r12d
    lv_label_refr_text(label);
   2a10a:	48 89 ef             	mov    %rbp,%rdi
    ext->long_mode = long_mode;
   2a10d:	83 e6 f8             	and    $0xfffffff8,%esi
   2a110:	44 09 e6             	or     %r12d,%esi
   2a113:	40 88 73 18          	mov    %sil,0x18(%rbx)
}
   2a117:	5b                   	pop    %rbx
   2a118:	5d                   	pop    %rbp
   2a119:	41 5c                	pop    %r12
    lv_label_refr_text(label);
   2a11b:	e9 7a fb ff ff       	jmpq   29c9a <lv_label_refr_text>

000000000002a120 <lv_label_set_recolor>:
{
   2a120:	55                   	push   %rbp
   2a121:	53                   	push   %rbx
   2a122:	48 89 fd             	mov    %rdi,%rbp
   2a125:	89 f3                	mov    %esi,%ebx
   2a127:	48 83 ec 08          	sub    $0x8,%rsp
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   2a12b:	e8 cf 21 ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    if(ext->recolor == en) return;
   2a130:	8a 50 18             	mov    0x18(%rax),%dl
   2a133:	88 d1                	mov    %dl,%cl
   2a135:	c0 e9 06             	shr    $0x6,%cl
   2a138:	83 e1 01             	and    $0x1,%ecx
   2a13b:	38 d9                	cmp    %bl,%cl
   2a13d:	74 19                	je     2a158 <lv_label_set_recolor+0x38>
    ext->recolor = en == false ? 0 : 1;
   2a13f:	83 e3 01             	and    $0x1,%ebx
   2a142:	83 e2 bf             	and    $0xffffffbf,%edx
    lv_label_refr_text(label); /*Refresh the text because the potential color codes in text needs to
   2a145:	48 89 ef             	mov    %rbp,%rdi
    ext->recolor = en == false ? 0 : 1;
   2a148:	c1 e3 06             	shl    $0x6,%ebx
   2a14b:	09 da                	or     %ebx,%edx
   2a14d:	88 50 18             	mov    %dl,0x18(%rax)
}
   2a150:	5a                   	pop    %rdx
   2a151:	5b                   	pop    %rbx
   2a152:	5d                   	pop    %rbp
    lv_label_refr_text(label); /*Refresh the text because the potential color codes in text needs to
   2a153:	e9 42 fb ff ff       	jmpq   29c9a <lv_label_refr_text>
}
   2a158:	58                   	pop    %rax
   2a159:	5b                   	pop    %rbx
   2a15a:	5d                   	pop    %rbp
   2a15b:	c3                   	retq   

000000000002a15c <lv_label_create>:
{
   2a15c:	41 55                	push   %r13
   2a15e:	41 54                	push   %r12
   2a160:	49 89 f5             	mov    %rsi,%r13
   2a163:	55                   	push   %rbp
   2a164:	53                   	push   %rbx
   2a165:	48 83 ec 08          	sub    $0x8,%rsp
    lv_obj_t * new_label = lv_obj_create(par, copy);
   2a169:	e8 2a 0f ff ff       	callq  1b098 <lv_obj_create>
    if(new_label == NULL) return NULL;
   2a16e:	48 85 c0             	test   %rax,%rax
   2a171:	74 41                	je     2a1b4 <lv_label_create+0x58>
    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_label);
   2a173:	48 83 3d c5 de 22 00 	cmpq   $0x0,0x22dec5(%rip)        # 258040 <ancestor_signal>
   2a17a:	00 
   2a17b:	48 89 c3             	mov    %rax,%rbx
   2a17e:	75 0f                	jne    2a18f <lv_label_create+0x33>
   2a180:	48 89 c7             	mov    %rax,%rdi
   2a183:	e8 6d 21 ff ff       	callq  1c2f5 <lv_obj_get_signal_cb>
   2a188:	48 89 05 b1 de 22 00 	mov    %rax,0x22deb1(%rip)        # 258040 <ancestor_signal>
    lv_obj_allocate_ext_attr(new_label, sizeof(lv_label_ext_t));
   2a18f:	be 20 00 00 00       	mov    $0x20,%esi
   2a194:	48 89 df             	mov    %rbx,%rdi
   2a197:	e8 55 06 ff ff       	callq  1a7f1 <lv_obj_allocate_ext_attr>
    lv_label_ext_t * ext = lv_obj_get_ext_attr(new_label);
   2a19c:	48 89 df             	mov    %rbx,%rdi
   2a19f:	e8 5b 21 ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    if(ext == NULL) {
   2a1a4:	48 85 c0             	test   %rax,%rax
    lv_label_ext_t * ext = lv_obj_get_ext_attr(new_label);
   2a1a7:	48 89 c5             	mov    %rax,%rbp
    if(ext == NULL) {
   2a1aa:	75 0f                	jne    2a1bb <lv_label_create+0x5f>
        lv_obj_del(new_label);
   2a1ac:	48 89 df             	mov    %rbx,%rdi
   2a1af:	e8 5f 0b ff ff       	callq  1ad13 <lv_obj_del>
        return NULL;
   2a1b4:	31 db                	xor    %ebx,%ebx
   2a1b6:	e9 d5 01 00 00       	jmpq   2a390 <lv_label_create+0x234>
    ext->text       = NULL;
   2a1bb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    ext->align      = LV_LABEL_ALIGN_AUTO;
   2a1c2:	8a 40 18             	mov    0x18(%rax),%al
    lv_obj_set_design_cb(new_label, lv_label_design);
   2a1c5:	48 8d 35 db 01 00 00 	lea    0x1db(%rip),%rsi        # 2a3a7 <lv_label_design>
    ext->dot_tmp_alloc = 0;
   2a1cc:	80 65 19 fe          	andb   $0xfe,0x19(%rbp)
    lv_obj_set_design_cb(new_label, lv_label_design);
   2a1d0:	48 89 df             	mov    %rbx,%rdi
    ext->dot_end    = LV_LABEL_DOT_END_INV;
   2a1d3:	c7 45 10 ff ff 00 00 	movl   $0xffff,0x10(%rbp)
    ext->offset.x = 0;
   2a1da:	66 c7 45 14 00 00    	movw   $0x0,0x14(%rbp)
    ext->offset.y = 0;
   2a1e0:	66 c7 45 16 00 00    	movw   $0x0,0x16(%rbp)
    ext->align      = LV_LABEL_ALIGN_AUTO;
   2a1e6:	83 e0 80             	and    $0xffffff80,%eax
    ext->dot.tmp_ptr   = NULL;
   2a1e9:	48 c7 45 08 00 00 00 	movq   $0x0,0x8(%rbp)
   2a1f0:	00 
    ext->long_mode  = LV_LABEL_LONG_EXPAND;
   2a1f1:	83 c8 30             	or     $0x30,%eax
   2a1f4:	88 45 18             	mov    %al,0x18(%rbp)
    lv_obj_set_design_cb(new_label, lv_label_design);
   2a1f7:	e8 f0 05 ff ff       	callq  1a7ec <lv_obj_set_design_cb>
    lv_obj_set_signal_cb(new_label, lv_label_signal);
   2a1fc:	48 8d 35 9a 04 00 00 	lea    0x49a(%rip),%rsi        # 2a69d <lv_label_signal>
   2a203:	48 89 df             	mov    %rbx,%rdi
   2a206:	e8 c5 05 ff ff       	callq  1a7d0 <lv_obj_set_signal_cb>
    if(copy == NULL) {
   2a20b:	4d 85 ed             	test   %r13,%r13
   2a20e:	75 35                	jne    2a245 <lv_label_create+0xe9>
        lv_theme_apply(new_label, LV_THEME_LABEL);
   2a210:	48 89 df             	mov    %rbx,%rdi
   2a213:	be 06 00 00 00       	mov    $0x6,%esi
   2a218:	e8 4c d3 ff ff       	callq  27569 <lv_theme_apply>
        lv_obj_set_click(new_label, false);
   2a21d:	31 f6                	xor    %esi,%esi
   2a21f:	48 89 df             	mov    %rbx,%rdi
   2a222:	e8 6f 04 ff ff       	callq  1a696 <lv_obj_set_click>
        lv_label_set_long_mode(new_label, LV_LABEL_LONG_EXPAND);
   2a227:	31 f6                	xor    %esi,%esi
   2a229:	48 89 df             	mov    %rbx,%rdi
   2a22c:	e8 86 fe ff ff       	callq  2a0b7 <lv_label_set_long_mode>
        lv_label_set_text(new_label, "Text");
   2a231:	48 8d 35 e3 9c 00 00 	lea    0x9ce3(%rip),%rsi        # 33f1b <_lv_bpp1_opa_table+0x6c6>
   2a238:	48 89 df             	mov    %rbx,%rdi
   2a23b:	e8 87 fd ff ff       	callq  29fc7 <lv_label_set_text>
   2a240:	e9 25 01 00 00       	jmpq   2a36a <lv_label_create+0x20e>
        lv_label_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
   2a245:	4c 89 ef             	mov    %r13,%rdi
   2a248:	e8 b2 20 ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
        lv_label_set_long_mode(new_label, lv_label_get_long_mode(copy));
   2a24d:	4c 89 ef             	mov    %r13,%rdi
        lv_label_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
   2a250:	49 89 c4             	mov    %rax,%r12
        lv_label_set_long_mode(new_label, lv_label_get_long_mode(copy));
   2a253:	e8 b2 f6 ff ff       	callq  2990a <lv_label_get_long_mode>
   2a258:	48 89 df             	mov    %rbx,%rdi
   2a25b:	0f b6 f0             	movzbl %al,%esi
   2a25e:	e8 54 fe ff ff       	callq  2a0b7 <lv_label_set_long_mode>
        lv_label_set_recolor(new_label, lv_label_get_recolor(copy));
   2a263:	4c 89 ef             	mov    %r13,%rdi
   2a266:	e8 ca f6 ff ff       	callq  29935 <lv_label_get_recolor>
   2a26b:	48 89 df             	mov    %rbx,%rdi
   2a26e:	0f b6 f0             	movzbl %al,%esi
   2a271:	e8 aa fe ff ff       	callq  2a120 <lv_label_set_recolor>
        lv_label_set_align(new_label, lv_label_get_align(copy));
   2a276:	4c 89 ef             	mov    %r13,%rdi
   2a279:	e8 9d f6 ff ff       	callq  2991b <lv_label_get_align>
   2a27e:	48 89 df             	mov    %rbx,%rdi
   2a281:	0f b6 f0             	movzbl %al,%esi
   2a284:	e8 34 f6 ff ff       	callq  298bd <lv_label_set_align>
        if(copy_ext->static_txt == 0)
   2a289:	41 f6 44 24 18 08    	testb  $0x8,0x18(%r12)
            lv_label_set_text(new_label, lv_label_get_text(copy));
   2a28f:	4c 89 ef             	mov    %r13,%rdi
        if(copy_ext->static_txt == 0)
   2a292:	75 12                	jne    2a2a6 <lv_label_create+0x14a>
            lv_label_set_text(new_label, lv_label_get_text(copy));
   2a294:	e8 63 f6 ff ff       	callq  298fc <lv_label_get_text>
   2a299:	48 89 df             	mov    %rbx,%rdi
   2a29c:	48 89 c6             	mov    %rax,%rsi
   2a29f:	e8 23 fd ff ff       	callq  29fc7 <lv_label_set_text>
   2a2a4:	eb 10                	jmp    2a2b6 <lv_label_create+0x15a>
            lv_label_set_text_static(new_label, lv_label_get_text(copy));
   2a2a6:	e8 51 f6 ff ff       	callq  298fc <lv_label_get_text>
   2a2ab:	48 89 df             	mov    %rbx,%rdi
   2a2ae:	48 89 c6             	mov    %rax,%rsi
   2a2b1:	e8 bd fd ff ff       	callq  2a073 <lv_label_set_text_static>
        if(copy_ext->long_mode == LV_LABEL_LONG_DOT) {
   2a2b6:	41 8a 44 24 18       	mov    0x18(%r12),%al
   2a2bb:	83 e0 07             	and    $0x7,%eax
   2a2be:	3c 02                	cmp    $0x2,%al
   2a2c0:	75 39                	jne    2a2fb <lv_label_create+0x19f>
            ext->text = lv_mem_realloc(ext->text, _lv_mem_get_size(copy_ext->text));
   2a2c2:	49 8b 3c 24          	mov    (%r12),%rdi
   2a2c6:	e8 58 be ff ff       	callq  26123 <_lv_mem_get_size>
   2a2cb:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
   2a2cf:	89 c6                	mov    %eax,%esi
   2a2d1:	e8 67 be ff ff       	callq  2613d <lv_mem_realloc>
            if(ext->text == NULL) return NULL;
   2a2d6:	48 85 c0             	test   %rax,%rax
            ext->text = lv_mem_realloc(ext->text, _lv_mem_get_size(copy_ext->text));
   2a2d9:	48 89 45 00          	mov    %rax,0x0(%rbp)
            if(ext->text == NULL) return NULL;
   2a2dd:	0f 84 d1 fe ff ff    	je     2a1b4 <lv_label_create+0x58>
            _lv_memcpy(ext->text, copy_ext->text, _lv_mem_get_size(copy_ext->text));
   2a2e3:	49 8b 3c 24          	mov    (%r12),%rdi
   2a2e7:	e8 37 be ff ff       	callq  26123 <_lv_mem_get_size>
   2a2ec:	49 8b 34 24          	mov    (%r12),%rsi
   2a2f0:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
   2a2f4:	89 c2                	mov    %eax,%edx
   2a2f6:	e8 a9 f4 ff ff       	callq  297a4 <_lv_memcpy>
        if(copy_ext->dot_tmp_alloc && copy_ext->dot.tmp_ptr) {
   2a2fb:	41 f6 44 24 19 01    	testb  $0x1,0x19(%r12)
   2a301:	74 27                	je     2a32a <lv_label_create+0x1ce>
   2a303:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
   2a308:	48 85 ff             	test   %rdi,%rdi
   2a30b:	74 1d                	je     2a32a <lv_label_create+0x1ce>
            uint32_t len = (uint32_t)strlen(copy_ext->dot.tmp_ptr);
   2a30d:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
   2a311:	31 c0                	xor    %eax,%eax
            lv_label_set_dot_tmp(new_label, ext->dot.tmp_ptr, len);
   2a313:	48 8b 75 08          	mov    0x8(%rbp),%rsi
            uint32_t len = (uint32_t)strlen(copy_ext->dot.tmp_ptr);
   2a317:	f2 ae                	repnz scas %es:(%rdi),%al
            lv_label_set_dot_tmp(new_label, ext->dot.tmp_ptr, len);
   2a319:	48 89 df             	mov    %rbx,%rdi
            uint32_t len = (uint32_t)strlen(copy_ext->dot.tmp_ptr);
   2a31c:	48 f7 d1             	not    %rcx
   2a31f:	48 8d 51 ff          	lea    -0x1(%rcx),%rdx
            lv_label_set_dot_tmp(new_label, ext->dot.tmp_ptr, len);
   2a323:	e8 85 f4 ff ff       	callq  297ad <lv_label_set_dot_tmp>
        if(copy_ext->dot_tmp_alloc && copy_ext->dot.tmp_ptr) {
   2a328:	eb 13                	jmp    2a33d <lv_label_create+0x1e1>
            _lv_memcpy(ext->dot.tmp, copy_ext->dot.tmp, sizeof(ext->dot.tmp));
   2a32a:	49 8d 74 24 08       	lea    0x8(%r12),%rsi
   2a32f:	48 8d 7d 08          	lea    0x8(%rbp),%rdi
   2a333:	ba 04 00 00 00       	mov    $0x4,%edx
   2a338:	e8 67 f4 ff ff       	callq  297a4 <_lv_memcpy>
        ext->dot_tmp_alloc = copy_ext->dot_tmp_alloc;
   2a33d:	41 8a 54 24 19       	mov    0x19(%r12),%dl
   2a342:	8a 45 19             	mov    0x19(%rbp),%al
        lv_obj_refresh_style(new_label, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
   2a345:	be ff 00 00 00       	mov    $0xff,%esi
   2a34a:	48 89 df             	mov    %rbx,%rdi
        ext->dot_tmp_alloc = copy_ext->dot_tmp_alloc;
   2a34d:	83 e2 01             	and    $0x1,%edx
   2a350:	83 e0 fe             	and    $0xfffffffe,%eax
   2a353:	09 d0                	or     %edx,%eax
        lv_obj_refresh_style(new_label, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
   2a355:	ba ff 00 00 00       	mov    $0xff,%edx
        ext->dot_tmp_alloc = copy_ext->dot_tmp_alloc;
   2a35a:	88 45 19             	mov    %al,0x19(%rbp)
        ext->dot_end       = copy_ext->dot_end;
   2a35d:	41 8b 44 24 10       	mov    0x10(%r12),%eax
   2a362:	89 45 10             	mov    %eax,0x10(%rbp)
        lv_obj_refresh_style(new_label, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
   2a365:	e8 7a 1d ff ff       	callq  1c0e4 <lv_obj_refresh_style>
    LV_LOG_INFO("label created");
   2a36a:	4c 8d 05 af 9b 00 00 	lea    0x9baf(%rip),%r8        # 33f20 <_lv_bpp1_opa_table+0x6cb>
   2a371:	48 8d 0d e8 67 00 00 	lea    0x67e8(%rip),%rcx        # 30b60 <__func__.6328>
   2a378:	48 8d 35 62 9b 00 00 	lea    0x9b62(%rip),%rsi        # 33ee1 <_lv_bpp1_opa_table+0x68c>
   2a37f:	ba a7 00 00 00       	mov    $0xa7,%edx
   2a384:	bf 01 00 00 00       	mov    $0x1,%edi
   2a389:	31 c0                	xor    %eax,%eax
   2a38b:	e8 c6 bb ff ff       	callq  25f56 <_lv_log_add>
}
   2a390:	5a                   	pop    %rdx
   2a391:	48 89 d8             	mov    %rbx,%rax
   2a394:	5b                   	pop    %rbx
   2a395:	5d                   	pop    %rbp
   2a396:	41 5c                	pop    %r12
   2a398:	41 5d                	pop    %r13
   2a39a:	c3                   	retq   

000000000002a39b <lv_label_get_text_sel_start>:
}
   2a39b:	b8 ff ff 00 00       	mov    $0xffff,%eax
   2a3a0:	c3                   	retq   

000000000002a3a1 <lv_label_get_text_sel_end>:
   2a3a1:	b8 ff ff 00 00       	mov    $0xffff,%eax
   2a3a6:	c3                   	retq   

000000000002a3a7 <lv_label_design>:
{
   2a3a7:	41 57                	push   %r15
   2a3a9:	41 56                	push   %r14
   2a3ab:	41 55                	push   %r13
   2a3ad:	41 54                	push   %r12
   2a3af:	55                   	push   %rbp
   2a3b0:	53                   	push   %rbx
   2a3b1:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
   2a3b8:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   2a3bf:	00 00 
   2a3c1:	48 89 84 24 c8 00 00 	mov    %rax,0xc8(%rsp)
   2a3c8:	00 
   2a3c9:	31 c0                	xor    %eax,%eax
    if(mode == LV_DESIGN_COVER_CHK)
   2a3cb:	80 fa 02             	cmp    $0x2,%dl
        return LV_DESIGN_RES_NOT_COVER;
   2a3ce:	b0 02                	mov    $0x2,%al
    if(mode == LV_DESIGN_COVER_CHK)
   2a3d0:	0f 84 8c 02 00 00    	je     2a662 <lv_label_design+0x2bb>
    return LV_DESIGN_RES_OK;
   2a3d6:	31 c0                	xor    %eax,%eax
    else if(mode == LV_DESIGN_DRAW_MAIN) {
   2a3d8:	84 d2                	test   %dl,%dl
   2a3da:	0f 85 82 02 00 00    	jne    2a662 <lv_label_design+0x2bb>
   2a3e0:	49 89 ff             	mov    %rdi,%r15
   2a3e3:	48 89 f3             	mov    %rsi,%rbx
    _lv_memcpy_small(dest, src, sizeof(lv_area_t));
   2a3e6:	4c 8d 6c 24 08       	lea    0x8(%rsp),%r13
        lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   2a3eb:	e8 0f 1f ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   2a3f0:	31 f6                	xor    %esi,%esi
   2a3f2:	ba 04 00 00 00       	mov    $0x4,%edx
   2a3f7:	4c 89 ff             	mov    %r15,%rdi
   2a3fa:	48 89 c5             	mov    %rax,%rbp
        bool is_common = _lv_area_intersect(&txt_clip, clip_area, &txt_coords);
   2a3fd:	4c 8d 74 24 18       	lea    0x18(%rsp),%r14
   2a402:	e8 e6 12 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   2a407:	31 f6                	xor    %esi,%esi
   2a409:	ba 05 00 00 00       	mov    $0x5,%edx
   2a40e:	4c 89 ff             	mov    %r15,%rdi
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   2a411:	41 89 c4             	mov    %eax,%r12d
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   2a414:	e8 d4 12 ff ff       	callq  1b6ed <_lv_obj_get_style_int>
        lv_area_copy(&bg_coords, &label->coords);
   2a419:	49 8d 77 20          	lea    0x20(%r15),%rsi
   2a41d:	ba 08 00 00 00       	mov    $0x8,%edx
   2a422:	4c 89 ef             	mov    %r13,%rdi
   2a425:	41 89 c0             	mov    %eax,%r8d
   2a428:	e8 77 f3 ff ff       	callq  297a4 <_lv_memcpy>
        bg_coords.x1 -= w;
   2a42d:	66 44 29 64 24 08    	sub    %r12w,0x8(%rsp)
        bg_coords.x2 += w;
   2a433:	66 44 01 64 24 0c    	add    %r12w,0xc(%rsp)
        lv_draw_rect_dsc_init(&draw_rect_dsc);
   2a439:	4c 8d 64 24 48       	lea    0x48(%rsp),%r12
   2a43e:	4c 89 e7             	mov    %r12,%rdi
        bg_coords.y1 -= h;
   2a441:	66 44 29 44 24 0a    	sub    %r8w,0xa(%rsp)
        bg_coords.y2 += h;
   2a447:	66 44 01 44 24 0e    	add    %r8w,0xe(%rsp)
        lv_draw_rect_dsc_init(&draw_rect_dsc);
   2a44d:	e8 ef 8c ff ff       	callq  23141 <lv_draw_rect_dsc_init>
        lv_obj_init_draw_rect_dsc(label, LV_LABEL_PART_MAIN, &draw_rect_dsc);
   2a452:	4c 89 e2             	mov    %r12,%rdx
   2a455:	31 f6                	xor    %esi,%esi
   2a457:	4c 89 ff             	mov    %r15,%rdi
   2a45a:	e8 2a 1f ff ff       	callq  1c389 <lv_obj_init_draw_rect_dsc>
        lv_draw_rect(&bg_coords, clip_area, &draw_rect_dsc);
   2a45f:	4c 89 e2             	mov    %r12,%rdx
        get_txt_coords(label, &txt_coords);
   2a462:	4c 8d 64 24 10       	lea    0x10(%rsp),%r12
        lv_draw_rect(&bg_coords, clip_area, &draw_rect_dsc);
   2a467:	48 89 de             	mov    %rbx,%rsi
   2a46a:	4c 89 ef             	mov    %r13,%rdi
   2a46d:	e8 39 8d ff ff       	callq  231ab <lv_draw_rect>
        get_txt_coords(label, &txt_coords);
   2a472:	4c 89 e6             	mov    %r12,%rsi
   2a475:	4c 89 ff             	mov    %r15,%rdi
   2a478:	e8 cd f3 ff ff       	callq  2984a <get_txt_coords>
        bool is_common = _lv_area_intersect(&txt_clip, clip_area, &txt_coords);
   2a47d:	4c 89 e2             	mov    %r12,%rdx
   2a480:	48 89 de             	mov    %rbx,%rsi
   2a483:	4c 89 f7             	mov    %r14,%rdi
   2a486:	e8 91 b0 ff ff       	callq  2551c <_lv_area_intersect>
        if(!is_common) return LV_DESIGN_RES_OK;
   2a48b:	84 c0                	test   %al,%al
   2a48d:	75 07                	jne    2a496 <lv_label_design+0xef>
   2a48f:	31 c0                	xor    %eax,%eax
   2a491:	e9 cc 01 00 00       	jmpq   2a662 <lv_label_design+0x2bb>
        lv_label_align_t align = lv_label_get_align(label);
   2a496:	4c 89 ff             	mov    %r15,%rdi
   2a499:	e8 7d f4 ff ff       	callq  2991b <lv_label_get_align>
        if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
   2a49e:	8a 55 18             	mov    0x18(%rbp),%dl
   2a4a1:	88 d3                	mov    %dl,%bl
   2a4a3:	c0 eb 06             	shr    $0x6,%bl
   2a4a6:	83 e3 01             	and    $0x1,%ebx
        if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
   2a4a9:	84 d2                	test   %dl,%dl
   2a4ab:	79 03                	jns    2a4b0 <lv_label_design+0x109>
   2a4ad:	83 cb 02             	or     $0x2,%ebx
        if(ext->long_mode == LV_LABEL_LONG_EXPAND) flag |= LV_TXT_FLAG_FIT;
   2a4b0:	80 e2 07             	and    $0x7,%dl
   2a4b3:	75 03                	jne    2a4b8 <lv_label_design+0x111>
   2a4b5:	83 cb 10             	or     $0x10,%ebx
        if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
   2a4b8:	3c 01                	cmp    $0x1,%al
   2a4ba:	75 05                	jne    2a4c1 <lv_label_design+0x11a>
   2a4bc:	83 cb 04             	or     $0x4,%ebx
   2a4bf:	eb 07                	jmp    2a4c8 <lv_label_design+0x121>
        if(align == LV_LABEL_ALIGN_RIGHT) flag |= LV_TXT_FLAG_RIGHT;
   2a4c1:	3c 02                	cmp    $0x2,%al
   2a4c3:	75 03                	jne    2a4c8 <lv_label_design+0x121>
   2a4c5:	83 cb 08             	or     $0x8,%ebx
        lv_draw_label_dsc_init(&label_draw_dsc);
   2a4c8:	4c 8d 6c 24 20       	lea    0x20(%rsp),%r13
   2a4cd:	4c 89 ef             	mov    %r13,%rdi
   2a4d0:	e8 d4 61 ff ff       	callq  206a9 <lv_draw_label_dsc_init>
        label_draw_dsc.sel_start = lv_label_get_text_sel_start(label);
   2a4d5:	4c 89 ff             	mov    %r15,%rdi
   2a4d8:	e8 be fe ff ff       	callq  2a39b <lv_label_get_text_sel_start>
        label_draw_dsc.sel_end = lv_label_get_text_sel_end(label);
   2a4dd:	4c 89 ff             	mov    %r15,%rdi
        label_draw_dsc.sel_start = lv_label_get_text_sel_start(label);
   2a4e0:	89 44 24 38          	mov    %eax,0x38(%rsp)
        label_draw_dsc.sel_end = lv_label_get_text_sel_end(label);
   2a4e4:	e8 b8 fe ff ff       	callq  2a3a1 <lv_label_get_text_sel_end>
   2a4e9:	89 44 24 3c          	mov    %eax,0x3c(%rsp)
        label_draw_dsc.ofs_x = ext->offset.x;
   2a4ed:	8b 45 14             	mov    0x14(%rbp),%eax
        lv_obj_init_draw_label_dsc(label, LV_LABEL_PART_MAIN, &label_draw_dsc);
   2a4f0:	4c 89 ea             	mov    %r13,%rdx
   2a4f3:	31 f6                	xor    %esi,%esi
   2a4f5:	4c 89 ff             	mov    %r15,%rdi
        label_draw_dsc.ofs_x = ext->offset.x;
   2a4f8:	66 89 44 24 40       	mov    %ax,0x40(%rsp)
        label_draw_dsc.ofs_y = ext->offset.y;
   2a4fd:	66 8b 45 16          	mov    0x16(%rbp),%ax
        label_draw_dsc.flag = flag;
   2a501:	88 5c 24 45          	mov    %bl,0x45(%rsp)
        label_draw_dsc.ofs_y = ext->offset.y;
   2a505:	66 89 44 24 42       	mov    %ax,0x42(%rsp)
        lv_obj_init_draw_label_dsc(label, LV_LABEL_PART_MAIN, &label_draw_dsc);
   2a50a:	e8 a0 22 ff ff       	callq  1c7af <lv_obj_init_draw_label_dsc>
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
   2a50f:	8a 45 18             	mov    0x18(%rbp),%al
   2a512:	88 c2                	mov    %al,%dl
   2a514:	83 e2 07             	and    $0x7,%edx
   2a517:	83 ea 03             	sub    $0x3,%edx
   2a51a:	80 fa 01             	cmp    $0x1,%dl
   2a51d:	77 4e                	ja     2a56d <lv_label_design+0x1c6>
           (ext->align == LV_LABEL_ALIGN_CENTER || ext->align == LV_LABEL_ALIGN_RIGHT)) {
   2a51f:	83 e0 30             	and    $0x30,%eax
   2a522:	83 e8 10             	sub    $0x10,%eax
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
   2a525:	a8 e0                	test   $0xe0,%al
   2a527:	75 44                	jne    2a56d <lv_label_design+0x1c6>
            _lv_txt_get_size(&size, ext->text, label_draw_dsc.font, label_draw_dsc.letter_space, label_draw_dsc.line_space,
   2a529:	0f bf 4c 24 34       	movswl 0x34(%rsp),%ecx
   2a52e:	0f b6 c3             	movzbl %bl,%eax
   2a531:	48 8d 7c 24 04       	lea    0x4(%rsp),%rdi
   2a536:	48 83 ec 08          	sub    $0x8,%rsp
   2a53a:	48 8b 75 00          	mov    0x0(%rbp),%rsi
   2a53e:	41 b9 18 7c 00 00    	mov    $0x7c18,%r9d
   2a544:	50                   	push   %rax
   2a545:	44 0f bf 44 24 42    	movswl 0x42(%rsp),%r8d
   2a54b:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
   2a550:	e8 a5 c9 ff ff       	callq  26efa <_lv_txt_get_size>
   2a555:	59                   	pop    %rcx
   2a556:	5e                   	pop    %rsi
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   2a557:	8b 44 24 14          	mov    0x14(%rsp),%eax
   2a55b:	ff c0                	inc    %eax
   2a55d:	2b 44 24 10          	sub    0x10(%rsp),%eax
            if(size.x > lv_area_get_width(&txt_coords)) {
   2a561:	66 39 44 24 04       	cmp    %ax,0x4(%rsp)
   2a566:	7e 05                	jle    2a56d <lv_label_design+0x1c6>
                label_draw_dsc.flag &= ~LV_TXT_FLAG_CENTER;
   2a568:	80 64 24 45 f3       	andb   $0xf3,0x45(%rsp)
        lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, ext->text, hint);
   2a56d:	48 8b 4d 00          	mov    0x0(%rbp),%rcx
   2a571:	45 31 c0             	xor    %r8d,%r8d
   2a574:	4c 89 ea             	mov    %r13,%rdx
   2a577:	4c 89 f6             	mov    %r14,%rsi
   2a57a:	4c 89 e7             	mov    %r12,%rdi
   2a57d:	e8 65 61 ff ff       	callq  206e7 <lv_draw_label>
        if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) {
   2a582:	8a 45 18             	mov    0x18(%rbp),%al
   2a585:	83 e0 07             	and    $0x7,%eax
   2a588:	3c 04                	cmp    $0x4,%al
   2a58a:	0f 85 ff fe ff ff    	jne    2a48f <lv_label_design+0xe8>
            _lv_txt_get_size(&size, ext->text, label_draw_dsc.font, label_draw_dsc.letter_space, label_draw_dsc.line_space,
   2a590:	0f bf 4c 24 34       	movswl 0x34(%rsp),%ecx
   2a595:	48 8d 7c 24 04       	lea    0x4(%rsp),%rdi
   2a59a:	0f b6 db             	movzbl %bl,%ebx
   2a59d:	48 83 ec 08          	sub    $0x8,%rsp
   2a5a1:	48 8b 75 00          	mov    0x0(%rbp),%rsi
   2a5a5:	41 b9 18 7c 00 00    	mov    $0x7c18,%r9d
   2a5ab:	53                   	push   %rbx
   2a5ac:	44 0f bf 44 24 42    	movswl 0x42(%rsp),%r8d
   2a5b2:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
   2a5b7:	e8 3e c9 ff ff       	callq  26efa <_lv_txt_get_size>
   2a5bc:	58                   	pop    %rax
   2a5bd:	5a                   	pop    %rdx
   2a5be:	8b 4c 24 14          	mov    0x14(%rsp),%ecx
            if(size.x > lv_area_get_width(&txt_coords)) {
   2a5c2:	8b 44 24 04          	mov    0x4(%rsp),%eax
   2a5c6:	8d 51 01             	lea    0x1(%rcx),%edx
   2a5c9:	2b 54 24 10          	sub    0x10(%rsp),%edx
   2a5cd:	66 39 d0             	cmp    %dx,%ax
   2a5d0:	7e 41                	jle    2a613 <lv_label_design+0x26c>
                label_draw_dsc.ofs_x = ext->offset.x + size.x +
   2a5d2:	03 45 14             	add    0x14(%rbp),%eax
                                       lv_font_get_glyph_width(label_draw_dsc.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
   2a5d5:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
   2a5da:	ba 20 00 00 00       	mov    $0x20,%edx
   2a5df:	be 20 00 00 00       	mov    $0x20,%esi
                label_draw_dsc.ofs_x = ext->offset.x + size.x +
   2a5e4:	89 c3                	mov    %eax,%ebx
                                       lv_font_get_glyph_width(label_draw_dsc.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
   2a5e6:	e8 f5 ca ff ff       	callq  270e0 <lv_font_get_glyph_width>
                label_draw_dsc.ofs_x = ext->offset.x + size.x +
   2a5eb:	8d 04 40             	lea    (%rax,%rax,2),%eax
                lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, ext->text, hint);
   2a5ee:	48 8b 4d 00          	mov    0x0(%rbp),%rcx
   2a5f2:	45 31 c0             	xor    %r8d,%r8d
   2a5f5:	4c 89 ea             	mov    %r13,%rdx
   2a5f8:	4c 89 f6             	mov    %r14,%rsi
   2a5fb:	4c 89 e7             	mov    %r12,%rdi
                label_draw_dsc.ofs_x = ext->offset.x + size.x +
   2a5fe:	01 d8                	add    %ebx,%eax
   2a600:	66 89 44 24 40       	mov    %ax,0x40(%rsp)
                label_draw_dsc.ofs_y = ext->offset.y;
   2a605:	66 8b 45 16          	mov    0x16(%rbp),%ax
   2a609:	66 89 44 24 42       	mov    %ax,0x42(%rsp)
                lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, ext->text, hint);
   2a60e:	e8 d4 60 ff ff       	callq  206e7 <lv_draw_label>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   2a613:	66 8b 4c 24 16       	mov    0x16(%rsp),%cx
            if(size.y > lv_area_get_height(&txt_coords)) {
   2a618:	66 8b 44 24 06       	mov    0x6(%rsp),%ax
   2a61d:	8d 51 01             	lea    0x1(%rcx),%edx
   2a620:	66 2b 54 24 12       	sub    0x12(%rsp),%dx
   2a625:	66 39 d0             	cmp    %dx,%ax
   2a628:	0f 8e 61 fe ff ff    	jle    2a48f <lv_label_design+0xe8>
                label_draw_dsc.ofs_x = ext->offset.x;
   2a62e:	8b 55 14             	mov    0x14(%rbp),%edx
                lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, ext->text, hint);
   2a631:	48 8b 4d 00          	mov    0x0(%rbp),%rcx
   2a635:	45 31 c0             	xor    %r8d,%r8d
   2a638:	4c 89 f6             	mov    %r14,%rsi
   2a63b:	4c 89 e7             	mov    %r12,%rdi
                label_draw_dsc.ofs_x = ext->offset.x;
   2a63e:	66 89 54 24 40       	mov    %dx,0x40(%rsp)
                label_draw_dsc.ofs_y = ext->offset.y + size.y + lv_font_get_line_height(label_draw_dsc.font);
   2a643:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
   2a648:	66 03 42 10          	add    0x10(%rdx),%ax
                lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, ext->text, hint);
   2a64c:	4c 89 ea             	mov    %r13,%rdx
                label_draw_dsc.ofs_y = ext->offset.y + size.y + lv_font_get_line_height(label_draw_dsc.font);
   2a64f:	66 03 45 16          	add    0x16(%rbp),%ax
   2a653:	66 89 44 24 42       	mov    %ax,0x42(%rsp)
                lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, ext->text, hint);
   2a658:	e8 8a 60 ff ff       	callq  206e7 <lv_draw_label>
   2a65d:	e9 2d fe ff ff       	jmpq   2a48f <lv_label_design+0xe8>
}
   2a662:	48 8b 8c 24 c8 00 00 	mov    0xc8(%rsp),%rcx
   2a669:	00 
   2a66a:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   2a671:	00 00 
   2a673:	74 05                	je     2a67a <lv_label_design+0x2d3>
   2a675:	e8 c6 9f fd ff       	callq  4640 <__stack_chk_fail@plt>
   2a67a:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
   2a681:	5b                   	pop    %rbx
   2a682:	5d                   	pop    %rbp
   2a683:	41 5c                	pop    %r12
   2a685:	41 5d                	pop    %r13
   2a687:	41 5e                	pop    %r14
   2a689:	41 5f                	pop    %r15
   2a68b:	c3                   	retq   

000000000002a68c <lv_label_get_style>:
            style_dsc_p = &label->style_list;
   2a68c:	48 8d 47 48          	lea    0x48(%rdi),%rax
            style_dsc_p = NULL;
   2a690:	40 84 f6             	test   %sil,%sil
   2a693:	ba 00 00 00 00       	mov    $0x0,%edx
   2a698:	48 0f 45 c2          	cmovne %rdx,%rax
}
   2a69c:	c3                   	retq   

000000000002a69d <lv_label_signal>:
    if(sign == LV_SIGNAL_GET_STYLE) {
   2a69d:	40 80 fe 08          	cmp    $0x8,%sil
{
   2a6a1:	41 56                	push   %r14
   2a6a3:	41 55                	push   %r13
   2a6a5:	41 54                	push   %r12
   2a6a7:	55                   	push   %rbp
   2a6a8:	48 89 d5             	mov    %rdx,%rbp
   2a6ab:	53                   	push   %rbx
   2a6ac:	48 89 fb             	mov    %rdi,%rbx
    if(sign == LV_SIGNAL_GET_STYLE) {
   2a6af:	75 32                	jne    2a6e3 <lv_label_signal+0x46>
        info->result = lv_label_get_style(label, info->part);
   2a6b1:	0f b6 32             	movzbl (%rdx),%esi
   2a6b4:	e8 d3 ff ff ff       	callq  2a68c <lv_label_get_style>
        if(info->result != NULL) return LV_RES_OK;
   2a6b9:	48 85 c0             	test   %rax,%rax
        info->result = lv_label_get_style(label, info->part);
   2a6bc:	48 89 45 08          	mov    %rax,0x8(%rbp)
        if(info->result != NULL) return LV_RES_OK;
   2a6c0:	74 08                	je     2a6ca <lv_label_signal+0x2d>
   2a6c2:	41 b5 01             	mov    $0x1,%r13b
   2a6c5:	e9 d8 00 00 00       	jmpq   2a7a2 <lv_label_signal+0x105>
        else return ancestor_signal(label, sign, param);
   2a6ca:	48 89 ea             	mov    %rbp,%rdx
   2a6cd:	48 89 df             	mov    %rbx,%rdi
   2a6d0:	be 08 00 00 00       	mov    $0x8,%esi
}
   2a6d5:	5b                   	pop    %rbx
   2a6d6:	5d                   	pop    %rbp
   2a6d7:	41 5c                	pop    %r12
   2a6d9:	41 5d                	pop    %r13
   2a6db:	41 5e                	pop    %r14
        else return ancestor_signal(label, sign, param);
   2a6dd:	ff 25 5d d9 22 00    	jmpq   *0x22d95d(%rip)        # 258040 <ancestor_signal>
   2a6e3:	41 89 f4             	mov    %esi,%r12d
    res = ancestor_signal(label, sign, param);
   2a6e6:	40 0f b6 f6          	movzbl %sil,%esi
   2a6ea:	ff 15 50 d9 22 00    	callq  *0x22d950(%rip)        # 258040 <ancestor_signal>
    if(res != LV_RES_OK) return res;
   2a6f0:	3c 01                	cmp    $0x1,%al
    res = ancestor_signal(label, sign, param);
   2a6f2:	41 88 c5             	mov    %al,%r13b
    if(res != LV_RES_OK) return res;
   2a6f5:	0f 85 a7 00 00 00    	jne    2a7a2 <lv_label_signal+0x105>
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
   2a6fb:	41 80 fc 07          	cmp    $0x7,%r12b
   2a6ff:	75 17                	jne    2a718 <lv_label_signal+0x7b>
}
   2a701:	5b                   	pop    %rbx
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
   2a702:	48 89 ef             	mov    %rbp,%rdi
   2a705:	48 8d 35 22 98 00 00 	lea    0x9822(%rip),%rsi        # 33f2e <_lv_bpp1_opa_table+0x6d9>
}
   2a70c:	5d                   	pop    %rbp
   2a70d:	41 5c                	pop    %r12
   2a70f:	41 5d                	pop    %r13
   2a711:	41 5e                	pop    %r14
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
   2a713:	e9 50 1c ff ff       	jmpq   1c368 <lv_obj_handle_get_type_signal>
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   2a718:	48 89 df             	mov    %rbx,%rdi
   2a71b:	e8 df 1b ff ff       	callq  1c2ff <lv_obj_get_ext_attr>
    if(sign == LV_SIGNAL_CLEANUP) {
   2a720:	45 84 e4             	test   %r12b,%r12b
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   2a723:	49 89 c6             	mov    %rax,%r14
    if(sign == LV_SIGNAL_CLEANUP) {
   2a726:	75 1f                	jne    2a747 <lv_label_signal+0xaa>
        if(ext->static_txt == 0) {
   2a728:	f6 40 18 08          	testb  $0x8,0x18(%rax)
   2a72c:	75 0f                	jne    2a73d <lv_label_signal+0xa0>
            lv_mem_free(ext->text);
   2a72e:	48 8b 38             	mov    (%rax),%rdi
   2a731:	e8 ce b9 ff ff       	callq  26104 <lv_mem_free>
            ext->text = NULL;
   2a736:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
        lv_label_dot_tmp_free(label);
   2a73d:	48 89 df             	mov    %rbx,%rdi
   2a740:	e8 b8 ef ff ff       	callq  296fd <lv_label_dot_tmp_free>
   2a745:	eb 5b                	jmp    2a7a2 <lv_label_signal+0x105>
    else if(sign == LV_SIGNAL_STYLE_CHG) {
   2a747:	41 80 fc 04          	cmp    $0x4,%r12b
   2a74b:	75 12                	jne    2a75f <lv_label_signal+0xc2>
        lv_label_revert_dots(label);
   2a74d:	48 89 df             	mov    %rbx,%rdi
   2a750:	e8 d3 ef ff ff       	callq  29728 <lv_label_revert_dots>
        lv_label_refr_text(label);
   2a755:	48 89 df             	mov    %rbx,%rdi
   2a758:	e8 3d f5 ff ff       	callq  29c9a <lv_label_refr_text>
   2a75d:	eb 43                	jmp    2a7a2 <lv_label_signal+0x105>
    else if(sign == LV_SIGNAL_COORD_CHG) {
   2a75f:	41 80 fc 02          	cmp    $0x2,%r12b
   2a763:	0f 85 59 ff ff ff    	jne    2a6c2 <lv_label_signal+0x25>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   2a769:	66 8b 43 24          	mov    0x24(%rbx),%ax
   2a76d:	8d 50 01             	lea    0x1(%rax),%edx
   2a770:	66 8b 45 04          	mov    0x4(%rbp),%ax
   2a774:	66 2b 53 20          	sub    0x20(%rbx),%dx
   2a778:	ff c0                	inc    %eax
   2a77a:	66 2b 45 00          	sub    0x0(%rbp),%ax
        if(lv_area_get_width(&label->coords) != lv_area_get_width(param) ||
   2a77e:	66 39 c2             	cmp    %ax,%dx
   2a781:	75 ca                	jne    2a74d <lv_label_signal+0xb0>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   2a783:	66 8b 43 26          	mov    0x26(%rbx),%ax
   2a787:	8d 50 01             	lea    0x1(%rax),%edx
   2a78a:	66 8b 45 06          	mov    0x6(%rbp),%ax
   2a78e:	66 2b 53 22          	sub    0x22(%rbx),%dx
   2a792:	ff c0                	inc    %eax
   2a794:	66 2b 45 02          	sub    0x2(%rbp),%ax
   2a798:	66 39 c2             	cmp    %ax,%dx
   2a79b:	75 b0                	jne    2a74d <lv_label_signal+0xb0>
   2a79d:	e9 20 ff ff ff       	jmpq   2a6c2 <lv_label_signal+0x25>
}
   2a7a2:	5b                   	pop    %rbx
   2a7a3:	44 88 e8             	mov    %r13b,%al
   2a7a6:	5d                   	pop    %rbp
   2a7a7:	41 5c                	pop    %r12
   2a7a9:	41 5d                	pop    %r13
   2a7ab:	41 5e                	pop    %r14
   2a7ad:	c3                   	retq   

000000000002a7ae <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
   2a7ae:	41 55                	push   %r13
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   2a7b0:	4c 8d 2d 69 b2 20 00 	lea    0x20b269(%rip),%r13        # 235a20 <levels.4664>
{
   2a7b7:	41 54                	push   %r12
   2a7b9:	55                   	push   %rbp
   2a7ba:	53                   	push   %rbx
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   2a7bb:	48 63 c7             	movslq %edi,%rax
   2a7be:	ff c7                	inc    %edi
{
   2a7c0:	48 83 ec 08          	sub    $0x8,%rsp
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   2a7c4:	4d 8b 64 c5 00       	mov    0x0(%r13,%rax,8),%r12
   2a7c9:	48 63 ef             	movslq %edi,%rbp
   2a7cc:	4d 39 64 ed 00       	cmp    %r12,0x0(%r13,%rbp,8)
   2a7d1:	76 45                	jbe    2a818 <z_sys_init_run_level+0x6a>
		const struct device *dev = entry->dev;
   2a7d3:	49 8b 5c 24 08       	mov    0x8(%r12),%rbx

		if (dev != NULL) {
			z_object_init(dev);
		}

		if ((entry->init(dev) != 0) && (dev != NULL)) {
   2a7d8:	48 89 df             	mov    %rbx,%rdi
   2a7db:	41 ff 14 24          	callq  *(%r12)
   2a7df:	85 c0                	test   %eax,%eax
   2a7e1:	74 2f                	je     2a812 <z_sys_init_run_level+0x64>
   2a7e3:	48 85 db             	test   %rbx,%rbx
   2a7e6:	74 2a                	je     2a812 <z_sys_init_run_level+0x64>
			/* Initialization failed.
			 * Set the init status bit so device is not declared ready.
			 */
			sys_bitfield_set_bit(
				(mem_addr_t) __device_init_status_start,
				(dev - __device_start));
   2a7e8:	48 2b 1d b1 b7 20 00 	sub    0x20b7b1(%rip),%rbx        # 235fa0 <_GLOBAL_OFFSET_TABLE_+0x2c0>

static ALWAYS_INLINE void sys_set_bit(mem_addr_t addr, unsigned int bit)
{
	uint32_t temp = *(volatile uint32_t *)addr;

	*(volatile uint32_t *)addr = temp | (1 << bit);
   2a7ef:	ba 01 00 00 00       	mov    $0x1,%edx
   2a7f4:	48 89 d9             	mov    %rbx,%rcx
   2a7f7:	48 c1 f9 05          	sar    $0x5,%rcx
	void sys_bitfield_set_bit(mem_addr_t addr, unsigned int bit)
{
	/* Doing memory offsets in terms of 32-bit values to prevent
	 * alignment issues
	 */
	sys_set_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
   2a7fb:	89 c8                	mov    %ecx,%eax
	*(volatile uint32_t *)addr = temp | (1 << bit);
   2a7fd:	d3 e2                	shl    %cl,%edx
	sys_set_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
   2a7ff:	c1 e8 05             	shr    $0x5,%eax
   2a802:	c1 e0 02             	shl    $0x2,%eax
   2a805:	48 03 05 6c b7 20 00 	add    0x20b76c(%rip),%rax        # 235f78 <_GLOBAL_OFFSET_TABLE_+0x298>
	uint32_t temp = *(volatile uint32_t *)addr;
   2a80c:	8b 30                	mov    (%rax),%esi
	*(volatile uint32_t *)addr = temp | (1 << bit);
   2a80e:	09 f2                	or     %esi,%edx
   2a810:	89 10                	mov    %edx,(%rax)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   2a812:	49 83 c4 10          	add    $0x10,%r12
   2a816:	eb b4                	jmp    2a7cc <z_sys_init_run_level+0x1e>
		}
	}
}
   2a818:	58                   	pop    %rax
   2a819:	5b                   	pop    %rbx
   2a81a:	5d                   	pop    %rbp
   2a81b:	41 5c                	pop    %r12
   2a81d:	41 5d                	pop    %r13
   2a81f:	c3                   	retq   

000000000002a820 <z_device_ready>:

bool z_device_ready(const struct device *dev)
{
	/* Set bit indicates device failed initialization */
	return !(sys_bitfield_test_bit((mem_addr_t)__device_init_status_start,
					(dev - __device_start)));
   2a820:	48 2b 3d 79 b7 20 00 	sub    0x20b779(%rip),%rdi        # 235fa0 <_GLOBAL_OFFSET_TABLE_+0x2c0>
   2a827:	48 89 f9             	mov    %rdi,%rcx
   2a82a:	48 c1 f9 05          	sar    $0x5,%rcx
}

static ALWAYS_INLINE
	int sys_bitfield_test_bit(mem_addr_t addr, unsigned int bit)
{
	return sys_test_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
   2a82e:	89 c8                	mov    %ecx,%eax
   2a830:	c1 e8 05             	shr    $0x5,%eax
   2a833:	c1 e0 02             	shl    $0x2,%eax
   2a836:	48 03 05 3b b7 20 00 	add    0x20b73b(%rip),%rax        # 235f78 <_GLOBAL_OFFSET_TABLE_+0x298>
	uint32_t temp = *(volatile uint32_t *)addr;
   2a83d:	8b 10                	mov    (%rax),%edx
	return temp & (1 << bit);
   2a83f:	b8 01 00 00 00       	mov    $0x1,%eax
   2a844:	d3 e0                	shl    %cl,%eax
	return !(sys_bitfield_test_bit((mem_addr_t)__device_init_status_start,
   2a846:	85 d0                	test   %edx,%eax
   2a848:	0f 94 c0             	sete   %al
}
   2a84b:	c3                   	retq   

000000000002a84c <z_impl_device_get_binding>:
{
   2a84c:	41 54                	push   %r12
   2a84e:	55                   	push   %rbp
   2a84f:	48 89 fd             	mov    %rdi,%rbp
   2a852:	53                   	push   %rbx
	for (dev = __device_start; dev != __device_end; dev++) {
   2a853:	48 8d 1d 56 fc 20 00 	lea    0x20fc56(%rip),%rbx        # 23a4b0 <__log_backends_end>
   2a85a:	49 89 dc             	mov    %rbx,%r12
   2a85d:	48 3b 1d 64 b7 20 00 	cmp    0x20b764(%rip),%rbx        # 235fc8 <_GLOBAL_OFFSET_TABLE_+0x2e8>
   2a864:	74 17                	je     2a87d <z_impl_device_get_binding+0x31>
		if (z_device_ready(dev) && (dev->name == name)) {
   2a866:	48 89 df             	mov    %rbx,%rdi
   2a869:	e8 b2 ff ff ff       	callq  2a820 <z_device_ready>
   2a86e:	84 c0                	test   %al,%al
   2a870:	74 05                	je     2a877 <z_impl_device_get_binding+0x2b>
   2a872:	48 39 2b             	cmp    %rbp,(%rbx)
   2a875:	74 35                	je     2a8ac <z_impl_device_get_binding+0x60>
	for (dev = __device_start; dev != __device_end; dev++) {
   2a877:	48 83 c3 20          	add    $0x20,%rbx
   2a87b:	eb e0                	jmp    2a85d <z_impl_device_get_binding+0x11>
	for (dev = __device_start; dev != __device_end; dev++) {
   2a87d:	4c 89 e3             	mov    %r12,%rbx
   2a880:	48 3b 1d 41 b7 20 00 	cmp    0x20b741(%rip),%rbx        # 235fc8 <_GLOBAL_OFFSET_TABLE_+0x2e8>
   2a887:	74 21                	je     2a8aa <z_impl_device_get_binding+0x5e>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
   2a889:	48 89 df             	mov    %rbx,%rdi
   2a88c:	e8 8f ff ff ff       	callq  2a820 <z_device_ready>
   2a891:	84 c0                	test   %al,%al
   2a893:	74 0f                	je     2a8a4 <z_impl_device_get_binding+0x58>
   2a895:	48 8b 33             	mov    (%rbx),%rsi
   2a898:	48 89 ef             	mov    %rbp,%rdi
   2a89b:	e8 10 9e fd ff       	callq  46b0 <strcmp@plt>
   2a8a0:	85 c0                	test   %eax,%eax
   2a8a2:	74 08                	je     2a8ac <z_impl_device_get_binding+0x60>
	for (dev = __device_start; dev != __device_end; dev++) {
   2a8a4:	48 83 c3 20          	add    $0x20,%rbx
   2a8a8:	eb d6                	jmp    2a880 <z_impl_device_get_binding+0x34>
	return NULL;
   2a8aa:	31 db                	xor    %ebx,%ebx
}
   2a8ac:	48 89 d8             	mov    %rbx,%rax
   2a8af:	5b                   	pop    %rbx
   2a8b0:	5d                   	pop    %rbp
   2a8b1:	41 5c                	pop    %r12
   2a8b3:	c3                   	retq   

000000000002a8b4 <coredump>:
#else

void coredump(unsigned int reason, const z_arch_esf_t *esf,
	      struct k_thread *thread)
{
}
   2a8b4:	c3                   	retq   

000000000002a8b5 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
   2a8b5:	53                   	push   %rbx
   2a8b6:	89 fb                	mov    %edi,%ebx
	z_impl_log_panic();
   2a8b8:	31 c0                	xor    %eax,%eax
   2a8ba:	e8 a3 c8 fd ff       	callq  7162 <z_impl_log_panic>
   2a8bf:	48 8d 35 aa fb 20 00 	lea    0x20fbaa(%rip),%rsi        # 23a470 <log_const_os>
   2a8c6:	48 2b 35 83 b6 20 00 	sub    0x20b683(%rip),%rsi        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
   2a8cd:	48 8d 3d 63 96 00 00 	lea    0x9663(%rip),%rdi        # 33f37 <_lv_bpp1_opa_table+0x6e2>
   2a8d4:	48 c1 ee 04          	shr    $0x4,%rsi
   2a8d8:	c1 e6 06             	shl    $0x6,%esi
   2a8db:	83 ce 01             	or     $0x1,%esi
   2a8de:	e8 e1 c9 fd ff       	callq  72c4 <log_0>
	arch_system_halt(reason);
   2a8e3:	89 df                	mov    %ebx,%edi
   2a8e5:	e8 d1 fb fd ff       	callq  a4bb <arch_system_halt>

000000000002a8ea <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   2a8ea:	41 56                	push   %r14
   2a8ec:	41 55                	push   %r13
   2a8ee:	49 89 f5             	mov    %rsi,%r13
   2a8f1:	41 54                	push   %r12
   2a8f3:	55                   	push   %rbp
   2a8f4:	41 89 fc             	mov    %edi,%r12d
   2a8f7:	53                   	push   %rbx
	return posix_irq_lock();
   2a8f8:	e8 95 16 fe ff       	callq  bf92 <posix_irq_lock>
   2a8fd:	41 89 c6             	mov    %eax,%r14d
	return z_impl_k_current_get();
   2a900:	31 c0                	xor    %eax,%eax
   2a902:	e8 f9 15 00 00       	callq  2bf00 <z_impl_k_current_get>
   2a907:	48 8d 1d 62 fb 20 00 	lea    0x20fb62(%rip),%rbx        # 23a470 <log_const_os>
   2a90e:	48 2b 1d 3b b6 20 00 	sub    0x20b63b(%rip),%rbx        # 235f50 <_GLOBAL_OFFSET_TABLE_+0x270>
   2a915:	48 89 c5             	mov    %rax,%rbp
		return "Unknown error";
   2a918:	48 8d 15 71 96 00 00 	lea    0x9671(%rip),%rdx        # 33f90 <_lv_bpp1_opa_table+0x73b>
   2a91f:	44 89 e6             	mov    %r12d,%esi
   2a922:	48 c1 eb 04          	shr    $0x4,%rbx
	struct k_thread *thread = k_current_get();

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   2a926:	66 81 e3 ff 03       	and    $0x3ff,%bx
   2a92b:	41 89 d8             	mov    %ebx,%r8d
   2a92e:	41 c1 e0 06          	shl    $0x6,%r8d
   2a932:	41 83 c8 01          	or     $0x1,%r8d
	switch (reason) {
   2a936:	41 83 fc 04          	cmp    $0x4,%r12d
   2a93a:	77 3b                	ja     2a977 <z_fatal_error+0x8d>
   2a93c:	48 8d 15 f5 64 00 00 	lea    0x64f5(%rip),%rdx        # 30e38 <__func__.5785+0x1d0>
   2a943:	48 63 04 b2          	movslq (%rdx,%rsi,4),%rax
   2a947:	48 01 d0             	add    %rdx,%rax
   2a94a:	ff e0                	jmpq   *%rax
		return "Unhandled interrupt";
   2a94c:	48 8d 15 01 96 00 00 	lea    0x9601(%rip),%rdx        # 33f54 <_lv_bpp1_opa_table+0x6ff>
   2a953:	eb 22                	jmp    2a977 <z_fatal_error+0x8d>
		return "Stack overflow";
   2a955:	48 8d 15 0c 96 00 00 	lea    0x960c(%rip),%rdx        # 33f68 <_lv_bpp1_opa_table+0x713>
   2a95c:	eb 19                	jmp    2a977 <z_fatal_error+0x8d>
		return "Kernel oops";
   2a95e:	48 8d 15 12 96 00 00 	lea    0x9612(%rip),%rdx        # 33f77 <_lv_bpp1_opa_table+0x722>
   2a965:	eb 10                	jmp    2a977 <z_fatal_error+0x8d>
		return "Kernel panic";
   2a967:	48 8d 15 15 96 00 00 	lea    0x9615(%rip),%rdx        # 33f83 <_lv_bpp1_opa_table+0x72e>
   2a96e:	eb 07                	jmp    2a977 <z_fatal_error+0x8d>
		return "CPU exception";
   2a970:	48 8d 15 cf 95 00 00 	lea    0x95cf(%rip),%rdx        # 33f46 <_lv_bpp1_opa_table+0x6f1>
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   2a977:	48 8d 3d 28 96 00 00 	lea    0x9628(%rip),%rdi        # 33fa6 <_lv_bpp1_opa_table+0x751>
   2a97e:	31 c9                	xor    %ecx,%ecx
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
   2a980:	c1 e3 06             	shl    $0x6,%ebx
   2a983:	83 cb 01             	or     $0x1,%ebx
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   2a986:	e8 f9 c9 fd ff       	callq  7384 <log_3>
	const char *thread_name = thread ? k_thread_name_get(thread) : NULL;
   2a98b:	48 85 ed             	test   %rbp,%rbp
   2a98e:	74 12                	je     2a9a2 <z_fatal_error+0xb8>
   2a990:	48 89 ef             	mov    %rbp,%rdi
   2a993:	e8 9b 16 00 00       	callq  2c033 <k_thread_name_get>
	if (thread_name == NULL || thread_name[0] == '\0') {
   2a998:	48 85 c0             	test   %rax,%rax
   2a99b:	74 05                	je     2a9a2 <z_fatal_error+0xb8>
   2a99d:	80 38 00             	cmpb   $0x0,(%rax)
   2a9a0:	75 07                	jne    2a9a9 <z_fatal_error+0xbf>
		thread_name = "unknown";
   2a9a2:	48 8d 05 f5 95 00 00 	lea    0x95f5(%rip),%rax        # 33f9e <_lv_bpp1_opa_table+0x749>
	LOG_ERR("Current thread: %p (%s)", thread,
   2a9a9:	48 89 c7             	mov    %rax,%rdi
   2a9ac:	e8 5f c5 fd ff       	callq  6f10 <log_strdup>
   2a9b1:	48 8d 3d 16 96 00 00 	lea    0x9616(%rip),%rdi        # 33fce <_lv_bpp1_opa_table+0x779>
   2a9b8:	48 89 c2             	mov    %rax,%rdx
   2a9bb:	89 d9                	mov    %ebx,%ecx
   2a9bd:	48 89 ee             	mov    %rbp,%rsi
   2a9c0:	e8 6d c9 fd ff       	callq  7332 <log_2>
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);
   2a9c5:	48 89 ea             	mov    %rbp,%rdx
   2a9c8:	4c 89 ee             	mov    %r13,%rsi
   2a9cb:	44 89 e7             	mov    %r12d,%edi
   2a9ce:	e8 e1 fe ff ff       	callq  2a8b4 <coredump>

	k_sys_fatal_error_handler(reason, esf);
   2a9d3:	4c 89 ee             	mov    %r13,%rsi
   2a9d6:	44 89 e7             	mov    %r12d,%edi
   2a9d9:	e8 d7 fe ff ff       	callq  2a8b5 <k_sys_fatal_error_handler>
	posix_irq_unlock(key);
   2a9de:	44 89 f7             	mov    %r14d,%edi
   2a9e1:	e8 b6 15 fe ff       	callq  bf9c <posix_irq_unlock>
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	arch_irq_unlock(key);
	k_thread_abort(thread);
}
   2a9e6:	5b                   	pop    %rbx
	z_impl_k_thread_abort(thread);
   2a9e7:	48 89 ef             	mov    %rbp,%rdi
   2a9ea:	5d                   	pop    %rbp
   2a9eb:	41 5c                	pop    %r12
   2a9ed:	41 5d                	pop    %r13
   2a9ef:	41 5e                	pop    %r14
   2a9f1:	e9 e0 fe fd ff       	jmpq   a8d6 <z_impl_k_thread_abort>

000000000002a9f6 <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
   2a9f6:	48 83 ec 08          	sub    $0x8,%rsp
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
   2a9fa:	48 8d 05 f3 46 23 00 	lea    0x2346f3(%rip),%rax        # 25f0f4 <z_sys_post_kernel>

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   2aa01:	bf 02 00 00 00       	mov    $0x2,%edi
	z_sys_post_kernel = true;
   2aa06:	c6 00 01             	movb   $0x1,(%rax)
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   2aa09:	e8 a0 fd ff ff       	callq  2a7ae <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
   2aa0e:	e8 30 1a 00 00       	callq  2c443 <boot_banner>
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
   2aa13:	bf 03 00 00 00       	mov    $0x3,%edi
   2aa18:	e8 91 fd ff ff       	callq  2a7ae <z_sys_init_run_level>

	z_init_static_threads();
   2aa1d:	e8 44 17 00 00       	callq  2c166 <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
   2aa22:	e8 45 ad fd ff       	callq  576c <zephyr_app_main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   2aa27:	48 8d 05 72 d0 22 00 	lea    0x22d072(%rip),%rax        # 257aa0 <z_main_thread>
   2aa2e:	80 60 18 fe          	andb   $0xfe,0x18(%rax)

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   2aa32:	58                   	pop    %rax
   2aa33:	c3                   	retq   

000000000002aa34 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
   2aa34:	41 55                	push   %r13
   2aa36:	41 54                	push   %r12
   2aa38:	55                   	push   %rbp
   2aa39:	53                   	push   %rbx
   2aa3a:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
   2aa41:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   2aa48:	00 00 
   2aa4a:	48 89 84 24 98 00 00 	mov    %rax,0x98(%rsp)
   2aa51:	00 
   2aa52:	31 c0                	xor    %eax,%eax
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
   2aa54:	e8 2a c3 fd ff       	callq  6d83 <log_core_init>
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
   2aa59:	48 8d 1d e0 d0 22 00 	lea    0x22d0e0(%rip),%rbx        # 257b40 <_kernel>
   2aa60:	48 8d 44 24 08       	lea    0x8(%rsp),%rax
#endif
#if defined(CONFIG_MMU) && defined(CONFIG_USERSPACE)
	z_kernel_map_fixup();
#endif
	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   2aa65:	31 ff                	xor    %edi,%edi
	dummy_thread->base.user_options = K_ESSENTIAL;
   2aa67:	66 c7 44 24 20 01 01 	movw   $0x101,0x20(%rsp)
	_current_cpu->current = dummy_thread;
   2aa6e:	48 89 43 10          	mov    %rax,0x10(%rbx)
   2aa72:	e8 37 fd ff ff       	callq  2a7ae <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   2aa77:	bf 01 00 00 00       	mov    $0x1,%edi
   2aa7c:	e8 2d fd ff ff       	callq  2a7ae <z_sys_init_run_level>
	z_sched_init();
   2aa81:	e8 54 13 00 00       	callq  2bdda <z_sched_init>
	_kernel.ready_q.cache = &z_main_thread;
   2aa86:	48 8d 2d 13 d0 22 00 	lea    0x22d013(%rip),%rbp        # 257aa0 <z_main_thread>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   2aa8d:	48 8d 05 52 95 00 00 	lea    0x9552(%rip),%rax        # 33fe6 <_lv_bpp1_opa_table+0x791>
   2aa94:	48 8d 35 f5 e2 20 00 	lea    0x20e2f5(%rip),%rsi        # 238d90 <z_main_stack>
   2aa9b:	48 8d 0d 54 ff ff ff 	lea    -0xac(%rip),%rcx        # 2a9f6 <bg_thread_main>
   2aaa2:	45 31 c9             	xor    %r9d,%r9d
   2aaa5:	45 31 c0             	xor    %r8d,%r8d
   2aaa8:	ba 00 08 00 00       	mov    $0x800,%edx
	_kernel.ready_q.cache = &z_main_thread;
   2aaad:	48 89 6b 40          	mov    %rbp,0x40(%rbx)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   2aab1:	50                   	push   %rax
   2aab2:	48 89 ef             	mov    %rbp,%rdi
   2aab5:	6a 01                	pushq  $0x1
   2aab7:	6a 00                	pushq  $0x0
   2aab9:	6a 00                	pushq  $0x0
   2aabb:	e8 9a 15 00 00       	callq  2c05a <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   2aac0:	80 65 19 fb          	andb   $0xfb,0x19(%rbp)
   2aac4:	48 83 c4 20          	add    $0x20,%rsp
	z_ready_thread(&z_main_thread);
   2aac8:	48 89 ef             	mov    %rbp,%rdi
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   2aacb:	49 89 c5             	mov    %rax,%r13
	z_ready_thread(&z_main_thread);
   2aace:	e8 be 0c 00 00       	callq  2b791 <z_ready_thread>
	z_setup_new_thread(thread, stack,
   2aad3:	4c 8d 25 26 cf 22 00 	lea    0x22cf26(%rip),%r12        # 257a00 <z_idle_threads>
   2aada:	48 8d 0d fd 23 00 00 	lea    0x23fd(%rip),%rcx        # 2cede <idle>
   2aae1:	48 8d 35 a8 e1 20 00 	lea    0x20e1a8(%rip),%rsi        # 238c90 <z_idle_stacks>
   2aae8:	6a 00                	pushq  $0x0
   2aaea:	6a 01                	pushq  $0x1
   2aaec:	45 31 c9             	xor    %r9d,%r9d
   2aaef:	6a 0f                	pushq  $0xf
   2aaf1:	6a 00                	pushq  $0x0
   2aaf3:	49 89 d8             	mov    %rbx,%r8
   2aaf6:	ba 00 01 00 00       	mov    $0x100,%edx
   2aafb:	4c 89 e7             	mov    %r12,%rdi
   2aafe:	e8 57 15 00 00       	callq  2c05a <z_setup_new_thread>
		_kernel.cpus[i].irq_stack =
   2ab03:	48 8d 05 86 ea 20 00 	lea    0x20ea86(%rip),%rax        # 239590 <z_interrupt_stacks>
   2ab0a:	41 80 64 24 19 fb    	andb   $0xfb,0x19(%r12)
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   2ab10:	48 8d 15 df fe ff ff 	lea    -0x121(%rip),%rdx        # 2a9f6 <bg_thread_main>
   2ab17:	4c 89 ee             	mov    %r13,%rsi
   2ab1a:	48 89 ef             	mov    %rbp,%rdi
	z_setup_new_thread(thread, stack,
   2ab1d:	48 83 c4 20          	add    $0x20,%rsp
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   2ab21:	4c 89 63 18          	mov    %r12,0x18(%rbx)
		_kernel.cpus[i].id = i;
   2ab25:	c6 43 2c 00          	movb   $0x0,0x2c(%rbx)
		_kernel.cpus[i].irq_stack =
   2ab29:	48 05 00 08 00 00    	add    $0x800,%rax
   2ab2f:	48 89 43 08          	mov    %rax,0x8(%rbx)
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
   2ab33:	48 8d 43 30          	lea    0x30(%rbx),%rax
   2ab37:	48 89 43 30          	mov    %rax,0x30(%rbx)
	list->tail = (sys_dnode_t *)list;
   2ab3b:	48 89 43 38          	mov    %rax,0x38(%rbx)
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   2ab3f:	e8 79 fe fd ff       	callq  a9bd <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   2ab44:	48 8d 35 a0 94 00 00 	lea    0x94a0(%rip),%rsi        # 33feb <_lv_bpp1_opa_table+0x796>
   2ab4b:	48 8d 3d 00 66 00 00 	lea    0x6600(%rip),%rdi        # 31152 <__func__.5785+0x4ea>
   2ab52:	ba 27 01 00 00       	mov    $0x127,%edx
   2ab57:	31 c0                	xor    %eax,%eax
   2ab59:	e8 64 17 fe ff       	callq  c2c2 <posix_print_error_and_exit>

000000000002ab5e <k_heap_init>:
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   2ab5e:	48 8d 47 18          	lea    0x18(%rdi),%rax
	list->head = (sys_dnode_t *)list;
   2ab62:	48 89 47 18          	mov    %rax,0x18(%rdi)
	list->tail = (sys_dnode_t *)list;
   2ab66:	48 89 47 20          	mov    %rax,0x20(%rdi)
#include <init.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
   2ab6a:	e9 8b b4 fd ff       	jmpq   5ffa <sys_heap_init>

000000000002ab6f <statics_init>:
}

static int statics_init(const struct device *unused)
{
   2ab6f:	53                   	push   %rbx
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
   2ab70:	48 8d 1d a1 fa 20 00 	lea    0x20faa1(%rip),%rbx        # 23a618 <_k_mem_slab_list_end>
   2ab77:	48 3b 1d 2a b4 20 00 	cmp    0x20b42a(%rip),%rbx        # 235fa8 <_GLOBAL_OFFSET_TABLE_+0x2c8>
   2ab7e:	73 16                	jae    2ab96 <statics_init+0x27>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   2ab80:	48 8b 53 10          	mov    0x10(%rbx),%rdx
   2ab84:	48 8b 73 08          	mov    0x8(%rbx),%rsi
   2ab88:	48 89 df             	mov    %rbx,%rdi
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
   2ab8b:	48 83 c3 28          	add    $0x28,%rbx
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   2ab8f:	e8 ca ff ff ff       	callq  2ab5e <k_heap_init>
   2ab94:	eb e1                	jmp    2ab77 <statics_init+0x8>
	}
	return 0;
}
   2ab96:	31 c0                	xor    %eax,%eax
   2ab98:	5b                   	pop    %rbx
   2ab99:	c3                   	retq   

000000000002ab9a <k_heap_aligned_alloc>:

SYS_INIT(statics_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
   2ab9a:	41 57                	push   %r15
   2ab9c:	41 56                	push   %r14
   2ab9e:	41 55                	push   %r13
   2aba0:	41 54                	push   %r12
   2aba2:	55                   	push   %rbp
   2aba3:	53                   	push   %rbx
   2aba4:	48 89 fb             	mov    %rdi,%rbx
	int64_t now, end = z_timeout_end_calc(timeout);
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   2aba7:	4c 8d 6b 28          	lea    0x28(%rbx),%r13
	int64_t now, end = z_timeout_end_calc(timeout);
   2abab:	48 89 cf             	mov    %rcx,%rdi
		now = z_tick_get();
		if ((ret != NULL) || ((end - now) <= 0)) {
			break;
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   2abae:	4c 8d 7b 18          	lea    0x18(%rbx),%r15
{
   2abb2:	48 83 ec 18          	sub    $0x18,%rsp
   2abb6:	48 89 34 24          	mov    %rsi,(%rsp)
   2abba:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
	int64_t now, end = z_timeout_end_calc(timeout);
   2abbf:	e8 f4 1b 00 00       	callq  2c7b8 <z_timeout_end_calc>
   2abc4:	49 89 c6             	mov    %rax,%r14
	return posix_irq_lock();
   2abc7:	e8 c6 13 fe ff       	callq  bf92 <posix_irq_lock>
   2abcc:	41 89 c4             	mov    %eax,%r12d
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
   2abcf:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
   2abd4:	48 8b 34 24          	mov    (%rsp),%rsi
   2abd8:	48 89 df             	mov    %rbx,%rdi
   2abdb:	e8 00 b3 fd ff       	callq  5ee0 <sys_heap_aligned_alloc>
   2abe0:	48 89 c5             	mov    %rax,%rbp
		now = z_tick_get();
   2abe3:	e8 97 1b 00 00       	callq  2c77f <z_tick_get>
		if ((ret != NULL) || ((end - now) <= 0)) {
   2abe8:	48 85 ed             	test   %rbp,%rbp
   2abeb:	75 23                	jne    2ac10 <k_heap_aligned_alloc+0x76>
   2abed:	4c 89 f1             	mov    %r14,%rcx
   2abf0:	48 29 c1             	sub    %rax,%rcx
   2abf3:	48 85 c9             	test   %rcx,%rcx
   2abf6:	7e 18                	jle    2ac10 <k_heap_aligned_alloc+0x76>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   2abf8:	44 89 e6             	mov    %r12d,%esi
   2abfb:	4c 89 fa             	mov    %r15,%rdx
   2abfe:	4c 89 ef             	mov    %r13,%rdi
   2ac01:	e8 e1 0f 00 00       	callq  2bbe7 <z_pend_curr>
   2ac06:	e8 87 13 fe ff       	callq  bf92 <posix_irq_lock>
   2ac0b:	41 89 c4             	mov    %eax,%r12d
   2ac0e:	eb bf                	jmp    2abcf <k_heap_aligned_alloc+0x35>
	posix_irq_unlock(key);
   2ac10:	44 89 e7             	mov    %r12d,%edi
   2ac13:	e8 84 13 fe ff       	callq  bf9c <posix_irq_unlock>
		key = k_spin_lock(&h->lock);
	}

	k_spin_unlock(&h->lock, key);
	return ret;
}
   2ac18:	48 83 c4 18          	add    $0x18,%rsp
   2ac1c:	48 89 e8             	mov    %rbp,%rax
   2ac1f:	5b                   	pop    %rbx
   2ac20:	5d                   	pop    %rbp
   2ac21:	41 5c                	pop    %r12
   2ac23:	41 5d                	pop    %r13
   2ac25:	41 5e                	pop    %r14
   2ac27:	41 5f                	pop    %r15
   2ac29:	c3                   	retq   

000000000002ac2a <k_heap_free>:

void k_heap_free(struct k_heap *h, void *mem)
{
   2ac2a:	55                   	push   %rbp
   2ac2b:	53                   	push   %rbx
   2ac2c:	48 89 fb             	mov    %rdi,%rbx
   2ac2f:	48 83 ec 18          	sub    $0x18,%rsp
   2ac33:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	return posix_irq_lock();
   2ac38:	e8 55 13 fe ff       	callq  bf92 <posix_irq_lock>
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
   2ac3d:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   2ac42:	48 89 df             	mov    %rbx,%rdi
   2ac45:	89 c5                	mov    %eax,%ebp
   2ac47:	e8 ef b1 fd ff       	callq  5e3b <sys_heap_free>

	if (z_unpend_all(&h->wait_q) != 0) {
   2ac4c:	48 8d 7b 18          	lea    0x18(%rbx),%rdi
   2ac50:	e8 51 11 00 00       	callq  2bda6 <z_unpend_all>
   2ac55:	85 c0                	test   %eax,%eax
   2ac57:	74 11                	je     2ac6a <k_heap_free+0x40>
		z_reschedule(&h->lock, key);
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   2ac59:	48 83 c4 18          	add    $0x18,%rsp
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   2ac5d:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
		z_reschedule(&h->lock, key);
   2ac61:	89 ee                	mov    %ebp,%esi
}
   2ac63:	5b                   	pop    %rbx
   2ac64:	5d                   	pop    %rbp
		z_reschedule(&h->lock, key);
   2ac65:	e9 00 09 00 00       	jmpq   2b56a <z_reschedule>
}
   2ac6a:	48 83 c4 18          	add    $0x18,%rsp
	posix_irq_unlock(key);
   2ac6e:	89 ef                	mov    %ebp,%edi
   2ac70:	5b                   	pop    %rbx
   2ac71:	5d                   	pop    %rbp
   2ac72:	e9 25 13 fe ff       	jmpq   bf9c <posix_irq_unlock>

000000000002ac77 <init_mem_slab_module>:
static int init_mem_slab_module(const struct device *dev)
{
	int rc = 0;
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   2ac77:	48 8d 05 f2 f8 20 00 	lea    0x20f8f2(%rip),%rax        # 23a570 <_k_timer_list_end>
   2ac7e:	48 3b 05 db b2 20 00 	cmp    0x20b2db(%rip),%rax        # 235f60 <_GLOBAL_OFFSET_TABLE_+0x280>
   2ac85:	73 3c                	jae    2acc3 <init_mem_slab_module+0x4c>
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   2ac87:	48 8b 50 20          	mov    0x20(%rax),%rdx
   2ac8b:	48 8b 70 18          	mov    0x18(%rax),%rsi
   2ac8f:	48 89 d1             	mov    %rdx,%rcx
   2ac92:	48 09 f1             	or     %rsi,%rcx
   2ac95:	80 e1 07             	and    $0x7,%cl
   2ac98:	75 2c                	jne    2acc6 <init_mem_slab_module+0x4f>
	for (j = 0U; j < slab->num_blocks; j++) {
   2ac9a:	8b 78 10             	mov    0x10(%rax),%edi
	slab->free_list = NULL;
   2ac9d:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
   2aca4:	00 
	for (j = 0U; j < slab->num_blocks; j++) {
   2aca5:	31 c9                	xor    %ecx,%ecx
   2aca7:	39 f9                	cmp    %edi,%ecx
   2aca9:	74 12                	je     2acbd <init_mem_slab_module+0x46>
		*(char **)p = slab->free_list;
   2acab:	4c 8b 40 28          	mov    0x28(%rax),%r8
	for (j = 0U; j < slab->num_blocks; j++) {
   2acaf:	ff c1                	inc    %ecx
		*(char **)p = slab->free_list;
   2acb1:	4c 89 02             	mov    %r8,(%rdx)
		slab->free_list = p;
   2acb4:	48 89 50 28          	mov    %rdx,0x28(%rax)
		p += slab->block_size;
   2acb8:	48 01 f2             	add    %rsi,%rdx
   2acbb:	eb ea                	jmp    2aca7 <init_mem_slab_module+0x30>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   2acbd:	48 83 c0 38          	add    $0x38,%rax
   2acc1:	eb bb                	jmp    2ac7e <init_mem_slab_module+0x7>
		}
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}

out:
   2acc3:	31 c0                	xor    %eax,%eax
   2acc5:	c3                   	retq   
		return -EINVAL;
   2acc6:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	return rc;
}
   2accb:	c3                   	retq   

000000000002accc <k_mem_slab_init>:
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   2accc:	49 89 f0             	mov    %rsi,%r8
int k_mem_slab_init(struct k_mem_slab *slab, void *buffer,
		    size_t block_size, uint32_t num_blocks)
{
	int rc = 0;

	slab->num_blocks = num_blocks;
   2accf:	89 4f 10             	mov    %ecx,0x10(%rdi)
	slab->block_size = block_size;
   2acd2:	48 89 57 18          	mov    %rdx,0x18(%rdi)
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   2acd6:	49 09 d0             	or     %rdx,%r8
	slab->buffer = buffer;
   2acd9:	48 89 77 20          	mov    %rsi,0x20(%rdi)
	slab->num_used = 0U;
   2acdd:	c7 47 30 00 00 00 00 	movl   $0x0,0x30(%rdi)
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   2ace4:	41 80 e0 07          	and    $0x7,%r8b
		return -EINVAL;
   2ace8:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   2aced:	75 29                	jne    2ad18 <k_mem_slab_init+0x4c>
	slab->free_list = NULL;
   2acef:	48 c7 47 28 00 00 00 	movq   $0x0,0x28(%rdi)
   2acf6:	00 
	for (j = 0U; j < slab->num_blocks; j++) {
   2acf7:	31 c0                	xor    %eax,%eax
   2acf9:	39 c1                	cmp    %eax,%ecx
   2acfb:	74 12                	je     2ad0f <k_mem_slab_init+0x43>
		*(char **)p = slab->free_list;
   2acfd:	4c 8b 47 28          	mov    0x28(%rdi),%r8
	for (j = 0U; j < slab->num_blocks; j++) {
   2ad01:	ff c0                	inc    %eax
		*(char **)p = slab->free_list;
   2ad03:	4c 89 06             	mov    %r8,(%rsi)
		slab->free_list = p;
   2ad06:	48 89 77 28          	mov    %rsi,0x28(%rdi)
		p += slab->block_size;
   2ad0a:	48 01 d6             	add    %rdx,%rsi
   2ad0d:	eb ea                	jmp    2acf9 <k_mem_slab_init+0x2d>
	list->head = (sys_dnode_t *)list;
   2ad0f:	48 89 3f             	mov    %rdi,(%rdi)
	list->tail = (sys_dnode_t *)list;
   2ad12:	48 89 7f 08          	mov    %rdi,0x8(%rdi)
   2ad16:	31 c0                	xor    %eax,%eax

	z_object_init(slab);

out:
	return rc;
}
   2ad18:	c3                   	retq   

000000000002ad19 <k_mem_slab_alloc>:

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
   2ad19:	41 54                	push   %r12
   2ad1b:	55                   	push   %rbp
   2ad1c:	49 89 d4             	mov    %rdx,%r12
   2ad1f:	53                   	push   %rbx
   2ad20:	48 89 fb             	mov    %rdi,%rbx
   2ad23:	48 89 f5             	mov    %rsi,%rbp
	return posix_irq_lock();
   2ad26:	e8 67 12 fe ff       	callq  bf92 <posix_irq_lock>
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
   2ad2b:	48 8b 53 28          	mov    0x28(%rbx),%rdx
   2ad2f:	48 85 d2             	test   %rdx,%rdx
   2ad32:	74 16                	je     2ad4a <k_mem_slab_alloc+0x31>
		/* take a free block */
		*mem = slab->free_list;
   2ad34:	48 89 55 00          	mov    %rdx,0x0(%rbp)
		slab->free_list = *(char **)(slab->free_list);
   2ad38:	48 8b 53 28          	mov    0x28(%rbx),%rdx
   2ad3c:	48 8b 12             	mov    (%rdx),%rdx
		slab->num_used++;
   2ad3f:	ff 43 30             	incl   0x30(%rbx)
		slab->free_list = *(char **)(slab->free_list);
   2ad42:	48 89 53 28          	mov    %rdx,0x28(%rbx)

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
   2ad46:	31 db                	xor    %ebx,%ebx
   2ad48:	eb 43                	jmp    2ad8d <k_mem_slab_alloc+0x74>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2ad4a:	4d 85 e4             	test   %r12,%r12
   2ad4d:	75 0f                	jne    2ad5e <k_mem_slab_alloc+0x45>
		/* don't wait for a free block to become available */
		*mem = NULL;
   2ad4f:	48 c7 45 00 00 00 00 	movq   $0x0,0x0(%rbp)
   2ad56:	00 
		result = -ENOMEM;
   2ad57:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
   2ad5c:	eb 2f                	jmp    2ad8d <k_mem_slab_alloc+0x74>
	} else {
		/* wait for a free block or timeout */
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
   2ad5e:	48 8d 3d 90 43 23 00 	lea    0x234390(%rip),%rdi        # 25f0f5 <lock>
   2ad65:	48 89 da             	mov    %rbx,%rdx
   2ad68:	4c 89 e1             	mov    %r12,%rcx
   2ad6b:	89 c6                	mov    %eax,%esi
   2ad6d:	e8 75 0e 00 00       	callq  2bbe7 <z_pend_curr>
		if (result == 0) {
   2ad72:	85 c0                	test   %eax,%eax
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
   2ad74:	89 c3                	mov    %eax,%ebx
		if (result == 0) {
   2ad76:	75 1c                	jne    2ad94 <k_mem_slab_alloc+0x7b>
			*mem = _current->base.swap_data;
   2ad78:	48 8d 05 c1 cd 22 00 	lea    0x22cdc1(%rip),%rax        # 257b40 <_kernel>
   2ad7f:	48 8b 40 10          	mov    0x10(%rax),%rax
   2ad83:	48 8b 40 20          	mov    0x20(%rax),%rax
   2ad87:	48 89 45 00          	mov    %rax,0x0(%rbp)
   2ad8b:	eb 07                	jmp    2ad94 <k_mem_slab_alloc+0x7b>
	posix_irq_unlock(key);
   2ad8d:	89 c7                	mov    %eax,%edi
   2ad8f:	e8 08 12 fe ff       	callq  bf9c <posix_irq_unlock>
	}

	k_spin_unlock(&lock, key);

	return result;
}
   2ad94:	89 d8                	mov    %ebx,%eax
   2ad96:	5b                   	pop    %rbx
   2ad97:	5d                   	pop    %rbp
   2ad98:	41 5c                	pop    %r12
   2ad9a:	c3                   	retq   

000000000002ad9b <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   2ad9b:	41 54                	push   %r12
   2ad9d:	55                   	push   %rbp
   2ad9e:	48 89 f5             	mov    %rsi,%rbp
   2ada1:	53                   	push   %rbx
   2ada2:	48 89 fb             	mov    %rdi,%rbx
	return posix_irq_lock();
   2ada5:	e8 e8 11 fe ff       	callq  bf92 <posix_irq_lock>
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (slab->free_list == NULL) {
   2adaa:	48 83 7b 28 00       	cmpq   $0x0,0x28(%rbx)
   2adaf:	41 89 c4             	mov    %eax,%r12d
   2adb2:	75 37                	jne    2adeb <k_mem_slab_free+0x50>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   2adb4:	48 89 df             	mov    %rbx,%rdi
   2adb7:	e8 96 0f 00 00       	callq  2bd52 <z_unpend_first_thread>

		if (pending_thread != NULL) {
   2adbc:	48 85 c0             	test   %rax,%rax
   2adbf:	74 2a                	je     2adeb <k_mem_slab_free+0x50>
			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   2adc1:	48 8b 55 00          	mov    0x0(%rbp),%rdx
			z_ready_thread(pending_thread);
   2adc5:	48 89 c7             	mov    %rax,%rdi
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->callee_saved.retval = value;
   2adc8:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   2adcf:	48 89 50 20          	mov    %rdx,0x20(%rax)
   2add3:	e8 b9 09 00 00       	callq  2b791 <z_ready_thread>
	}
	**(char ***) mem = slab->free_list;
	slab->free_list = *(char **) mem;
	slab->num_used--;
	k_spin_unlock(&lock, key);
}
   2add8:	5b                   	pop    %rbx
			z_reschedule(&lock, key);
   2add9:	44 89 e6             	mov    %r12d,%esi
   2addc:	48 8d 3d 12 43 23 00 	lea    0x234312(%rip),%rdi        # 25f0f5 <lock>
}
   2ade3:	5d                   	pop    %rbp
   2ade4:	41 5c                	pop    %r12
			z_reschedule(&lock, key);
   2ade6:	e9 7f 07 00 00       	jmpq   2b56a <z_reschedule>
	**(char ***) mem = slab->free_list;
   2adeb:	48 8b 45 00          	mov    0x0(%rbp),%rax
   2adef:	48 8b 53 28          	mov    0x28(%rbx),%rdx
	posix_irq_unlock(key);
   2adf3:	44 89 e7             	mov    %r12d,%edi
   2adf6:	48 89 10             	mov    %rdx,(%rax)
	slab->free_list = *(char **) mem;
   2adf9:	48 8b 45 00          	mov    0x0(%rbp),%rax
	slab->num_used--;
   2adfd:	ff 4b 30             	decl   0x30(%rbx)
	slab->free_list = *(char **) mem;
   2ae00:	48 89 43 28          	mov    %rax,0x28(%rbx)
}
   2ae04:	5b                   	pop    %rbx
   2ae05:	5d                   	pop    %rbp
   2ae06:	41 5c                	pop    %r12
   2ae08:	e9 8f 11 fe ff       	jmpq   bf9c <posix_irq_unlock>

000000000002ae0d <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
   2ae0d:	41 56                	push   %r14
   2ae0f:	41 55                	push   %r13
   2ae11:	49 89 d6             	mov    %rdx,%r14
   2ae14:	41 54                	push   %r12
   2ae16:	55                   	push   %rbp

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
   2ae17:	4c 8d 67 10          	lea    0x10(%rdi),%r12
{
   2ae1b:	53                   	push   %rbx
   2ae1c:	48 89 fb             	mov    %rdi,%rbx
   2ae1f:	48 83 ec 10          	sub    $0x10,%rsp
   2ae23:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	return posix_irq_lock();
   2ae28:	e8 65 11 fe ff       	callq  bf92 <posix_irq_lock>
   2ae2d:	89 c5                	mov    %eax,%ebp

	if (msgq->used_msgs < msgq->max_msgs) {
   2ae2f:	8b 43 18             	mov    0x18(%rbx),%eax
   2ae32:	39 43 40             	cmp    %eax,0x40(%rbx)
   2ae35:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   2ae3a:	73 62                	jae    2ae9e <z_impl_k_msgq_put+0x91>
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   2ae3c:	48 89 df             	mov    %rbx,%rdi
   2ae3f:	e8 0e 0f 00 00       	callq  2bd52 <z_unpend_first_thread>
		if (pending_thread != NULL) {
   2ae44:	48 85 c0             	test   %rax,%rax
   2ae47:	48 8b 4b 10          	mov    0x10(%rbx),%rcx
   2ae4b:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   2ae50:	74 24                	je     2ae76 <z_impl_k_msgq_put+0x69>
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
   2ae52:	48 8b 78 20          	mov    0x20(%rax),%rdi
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
			return 0;
   2ae56:	45 31 ed             	xor    %r13d,%r13d
   2ae59:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
			z_ready_thread(pending_thread);
   2ae5b:	48 89 c7             	mov    %rax,%rdi
   2ae5e:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
   2ae65:	e8 27 09 00 00       	callq  2b791 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
   2ae6a:	89 ee                	mov    %ebp,%esi
   2ae6c:	4c 89 e7             	mov    %r12,%rdi
   2ae6f:	e8 f6 06 00 00       	callq  2b56a <z_reschedule>
			return 0;
   2ae74:	eb 65                	jmp    2aedb <z_impl_k_msgq_put+0xce>
   2ae76:	48 8b 7b 38          	mov    0x38(%rbx),%rdi
   2ae7a:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		} else {
			/* put message in queue */
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
   2ae7c:	48 8b 43 10          	mov    0x10(%rbx),%rax
   2ae80:	48 03 43 38          	add    0x38(%rbx),%rax
			if (msgq->write_ptr == msgq->buffer_end) {
   2ae84:	48 3b 43 28          	cmp    0x28(%rbx),%rax
			msgq->write_ptr += msgq->msg_size;
   2ae88:	48 89 43 38          	mov    %rax,0x38(%rbx)
			if (msgq->write_ptr == msgq->buffer_end) {
   2ae8c:	75 08                	jne    2ae96 <z_impl_k_msgq_put+0x89>
				msgq->write_ptr = msgq->buffer_start;
   2ae8e:	48 8b 43 20          	mov    0x20(%rbx),%rax
   2ae92:	48 89 43 38          	mov    %rax,0x38(%rbx)
			}
			msgq->used_msgs++;
   2ae96:	ff 43 40             	incl   0x40(%rbx)
		}
		result = 0;
   2ae99:	45 31 ed             	xor    %r13d,%r13d
   2ae9c:	eb 36                	jmp    2aed4 <z_impl_k_msgq_put+0xc7>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2ae9e:	4d 85 f6             	test   %r14,%r14
		/* don't wait for message space to become available */
		result = -ENOMSG;
   2aea1:	41 bd d6 ff ff ff    	mov    $0xffffffd6,%r13d
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2aea7:	74 2b                	je     2aed4 <z_impl_k_msgq_put+0xc7>
	} else {
		/* wait for put message success, failure, or timeout */
		_current->base.swap_data = (void *) data;
   2aea9:	48 8d 05 90 cc 22 00 	lea    0x22cc90(%rip),%rax        # 257b40 <_kernel>
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   2aeb0:	4c 89 f1             	mov    %r14,%rcx
   2aeb3:	48 89 da             	mov    %rbx,%rdx
   2aeb6:	4c 89 e7             	mov    %r12,%rdi
		_current->base.swap_data = (void *) data;
   2aeb9:	48 8b 40 10          	mov    0x10(%rax),%rax
   2aebd:	48 89 70 20          	mov    %rsi,0x20(%rax)
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   2aec1:	48 83 c4 10          	add    $0x10,%rsp
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   2aec5:	89 ee                	mov    %ebp,%esi
}
   2aec7:	5b                   	pop    %rbx
   2aec8:	5d                   	pop    %rbp
   2aec9:	41 5c                	pop    %r12
   2aecb:	41 5d                	pop    %r13
   2aecd:	41 5e                	pop    %r14
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   2aecf:	e9 13 0d 00 00       	jmpq   2bbe7 <z_pend_curr>
	posix_irq_unlock(key);
   2aed4:	89 ef                	mov    %ebp,%edi
   2aed6:	e8 c1 10 fe ff       	callq  bf9c <posix_irq_unlock>
}
   2aedb:	48 83 c4 10          	add    $0x10,%rsp
   2aedf:	44 89 e8             	mov    %r13d,%eax
   2aee2:	5b                   	pop    %rbx
   2aee3:	5d                   	pop    %rbp
   2aee4:	41 5c                	pop    %r12
   2aee6:	41 5d                	pop    %r13
   2aee8:	41 5e                	pop    %r14
   2aeea:	c3                   	retq   

000000000002aeeb <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
   2aeeb:	41 57                	push   %r15
   2aeed:	41 56                	push   %r14
   2aeef:	49 89 d7             	mov    %rdx,%r15
   2aef2:	41 55                	push   %r13
   2aef4:	41 54                	push   %r12
   2aef6:	49 89 f6             	mov    %rsi,%r14
   2aef9:	55                   	push   %rbp
   2aefa:	53                   	push   %rbx
   2aefb:	48 89 fb             	mov    %rdi,%rbx

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
   2aefe:	4c 8d 67 10          	lea    0x10(%rdi),%r12
{
   2af02:	48 83 ec 08          	sub    $0x8,%rsp
	return posix_irq_lock();
   2af06:	e8 87 10 fe ff       	callq  bf92 <posix_irq_lock>

	if (msgq->used_msgs > 0) {
   2af0b:	83 7b 40 00          	cmpl   $0x0,0x40(%rbx)
   2af0f:	89 c5                	mov    %eax,%ebp
   2af11:	0f 84 80 00 00 00    	je     2af97 <z_impl_k_msgq_get+0xac>
   2af17:	48 8b 73 30          	mov    0x30(%rbx),%rsi
   2af1b:	48 8b 4b 10          	mov    0x10(%rbx),%rcx
   2af1f:	4c 89 f7             	mov    %r14,%rdi
   2af22:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
		msgq->read_ptr += msgq->msg_size;
   2af24:	48 8b 43 10          	mov    0x10(%rbx),%rax
   2af28:	48 03 43 30          	add    0x30(%rbx),%rax
		if (msgq->read_ptr == msgq->buffer_end) {
   2af2c:	48 3b 43 28          	cmp    0x28(%rbx),%rax
		msgq->read_ptr += msgq->msg_size;
   2af30:	48 89 43 30          	mov    %rax,0x30(%rbx)
		if (msgq->read_ptr == msgq->buffer_end) {
   2af34:	75 08                	jne    2af3e <z_impl_k_msgq_get+0x53>
			msgq->read_ptr = msgq->buffer_start;
   2af36:	48 8b 43 20          	mov    0x20(%rbx),%rax
   2af3a:	48 89 43 30          	mov    %rax,0x30(%rbx)
		}
		msgq->used_msgs--;
   2af3e:	ff 4b 40             	decl   0x40(%rbx)

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   2af41:	48 89 df             	mov    %rbx,%rdi
   2af44:	e8 09 0e 00 00       	callq  2bd52 <z_unpend_first_thread>
		if (pending_thread != NULL) {
   2af49:	48 85 c0             	test   %rax,%rax
   2af4c:	74 7f                	je     2afcd <z_impl_k_msgq_get+0xe2>
   2af4e:	48 8b 70 20          	mov    0x20(%rax),%rsi
   2af52:	48 8b 7b 38          	mov    0x38(%rbx),%rdi
   2af56:	48 8b 4b 10          	mov    0x10(%rbx),%rcx
   2af5a:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
			/* add thread's message to queue */
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
   2af5c:	48 8b 53 10          	mov    0x10(%rbx),%rdx
   2af60:	48 03 53 38          	add    0x38(%rbx),%rdx
			if (msgq->write_ptr == msgq->buffer_end) {
   2af64:	48 3b 53 28          	cmp    0x28(%rbx),%rdx
			msgq->write_ptr += msgq->msg_size;
   2af68:	48 89 53 38          	mov    %rdx,0x38(%rbx)
			if (msgq->write_ptr == msgq->buffer_end) {
   2af6c:	75 08                	jne    2af76 <z_impl_k_msgq_get+0x8b>
				msgq->write_ptr = msgq->buffer_start;
   2af6e:	48 8b 53 20          	mov    0x20(%rbx),%rdx
   2af72:	48 89 53 38          	mov    %rdx,0x38(%rbx)
			}
			msgq->used_msgs++;
   2af76:	ff 43 40             	incl   0x40(%rbx)

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
   2af79:	48 89 c7             	mov    %rax,%rdi
   2af7c:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
			z_reschedule(&msgq->lock, key);
			return 0;
   2af83:	45 31 ed             	xor    %r13d,%r13d
			z_ready_thread(pending_thread);
   2af86:	e8 06 08 00 00       	callq  2b791 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
   2af8b:	89 ee                	mov    %ebp,%esi
   2af8d:	4c 89 e7             	mov    %r12,%rdi
   2af90:	e8 d5 05 00 00       	callq  2b56a <z_reschedule>
			return 0;
   2af95:	eb 40                	jmp    2afd7 <z_impl_k_msgq_get+0xec>
		}
		result = 0;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2af97:	4d 85 ff             	test   %r15,%r15
		/* don't wait for a message to become available */
		result = -ENOMSG;
   2af9a:	41 bd d6 ff ff ff    	mov    $0xffffffd6,%r13d
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2afa0:	74 2e                	je     2afd0 <z_impl_k_msgq_get+0xe5>
	} else {
		/* wait for get message success or timeout */
		_current->base.swap_data = data;
   2afa2:	48 8d 05 97 cb 22 00 	lea    0x22cb97(%rip),%rax        # 257b40 <_kernel>
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   2afa9:	4c 89 f9             	mov    %r15,%rcx
   2afac:	48 89 da             	mov    %rbx,%rdx
   2afaf:	89 ee                	mov    %ebp,%esi
   2afb1:	4c 89 e7             	mov    %r12,%rdi
		_current->base.swap_data = data;
   2afb4:	48 8b 40 10          	mov    0x10(%rax),%rax
   2afb8:	4c 89 70 20          	mov    %r14,0x20(%rax)
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   2afbc:	41 58                	pop    %r8
   2afbe:	5b                   	pop    %rbx
   2afbf:	5d                   	pop    %rbp
   2afc0:	41 5c                	pop    %r12
   2afc2:	41 5d                	pop    %r13
   2afc4:	41 5e                	pop    %r14
   2afc6:	41 5f                	pop    %r15
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   2afc8:	e9 1a 0c 00 00       	jmpq   2bbe7 <z_pend_curr>
		result = 0;
   2afcd:	45 31 ed             	xor    %r13d,%r13d
	posix_irq_unlock(key);
   2afd0:	89 ef                	mov    %ebp,%edi
   2afd2:	e8 c5 0f fe ff       	callq  bf9c <posix_irq_unlock>
}
   2afd7:	5a                   	pop    %rdx
   2afd8:	44 89 e8             	mov    %r13d,%eax
   2afdb:	5b                   	pop    %rbx
   2afdc:	5d                   	pop    %rbp
   2afdd:	41 5c                	pop    %r12
   2afdf:	41 5d                	pop    %r13
   2afe1:	41 5e                	pop    %r14
   2afe3:	41 5f                	pop    %r15
   2afe5:	c3                   	retq   

000000000002afe6 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   2afe6:	41 55                	push   %r13
   2afe8:	41 54                	push   %r12
   2afea:	49 89 f5             	mov    %rsi,%r13
   2afed:	55                   	push   %rbp
   2afee:	53                   	push   %rbx
   2afef:	48 89 fb             	mov    %rdi,%rbx
   2aff2:	48 83 ec 08          	sub    $0x8,%rsp
	return posix_irq_lock();
   2aff6:	e8 97 0f fe ff       	callq  bf92 <posix_irq_lock>
   2affb:	41 89 c4             	mov    %eax,%r12d
	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	sys_trace_mutex_lock(mutex);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   2affe:	8b 43 18             	mov    0x18(%rbx),%eax
   2b001:	48 8d 15 38 cb 22 00 	lea    0x22cb38(%rip),%rdx        # 257b40 <_kernel>
   2b008:	85 c0                	test   %eax,%eax
   2b00a:	74 12                	je     2b01e <z_impl_k_mutex_lock+0x38>
   2b00c:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
   2b010:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
   2b014:	48 39 cf             	cmp    %rcx,%rdi
   2b017:	75 2c                	jne    2b045 <z_impl_k_mutex_lock+0x5f>

		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
					_current->base.prio :
   2b019:	8b 4b 1c             	mov    0x1c(%rbx),%ecx
   2b01c:	eb 08                	jmp    2b026 <z_impl_k_mutex_lock+0x40>
   2b01e:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
   2b022:	0f be 49 1a          	movsbl 0x1a(%rcx),%ecx
					mutex->owner_orig_prio;

		mutex->lock_count++;
   2b026:	ff c0                	inc    %eax
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   2b028:	89 4b 1c             	mov    %ecx,0x1c(%rbx)
	posix_irq_unlock(key);
   2b02b:	44 89 e7             	mov    %r12d,%edi
		mutex->lock_count++;
   2b02e:	89 43 18             	mov    %eax,0x18(%rbx)
		mutex->owner = _current;
   2b031:	48 8b 42 10          	mov    0x10(%rdx),%rax
   2b035:	48 89 43 10          	mov    %rax,0x10(%rbx)
   2b039:	e8 5e 0f fe ff       	callq  bf9c <posix_irq_unlock>
			mutex->owner_orig_prio);

		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
   2b03e:	31 c0                	xor    %eax,%eax
   2b040:	e9 be 00 00 00       	jmpq   2b103 <z_impl_k_mutex_lock+0x11d>
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   2b045:	4d 85 ed             	test   %r13,%r13
   2b048:	75 12                	jne    2b05c <z_impl_k_mutex_lock+0x76>
   2b04a:	44 89 e7             	mov    %r12d,%edi
   2b04d:	e8 4a 0f fe ff       	callq  bf9c <posix_irq_unlock>
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
   2b052:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
   2b057:	e9 a7 00 00 00       	jmpq   2b103 <z_impl_k_mutex_lock+0x11d>
	}

	new_prio = new_prio_for_inheritance(_current->base.prio,
   2b05c:	0f be 47 1a          	movsbl 0x1a(%rdi),%eax
   2b060:	0f be 71 1a          	movsbl 0x1a(%rcx),%esi
   2b064:	ba 00 00 00 00       	mov    $0x0,%edx
   2b069:	39 c6                	cmp    %eax,%esi
   2b06b:	0f 4f f0             	cmovg  %eax,%esi
   2b06e:	85 f6                	test   %esi,%esi
   2b070:	0f 48 f2             	cmovs  %edx,%esi
	bool resched = false;
   2b073:	31 ed                	xor    %ebp,%ebp
					    mutex->owner->base.prio);

	LOG_DBG("adjusting prio up on mutex %p", mutex);

	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   2b075:	39 c6                	cmp    %eax,%esi
   2b077:	7d 08                	jge    2b081 <z_impl_k_mutex_lock+0x9b>
		return z_set_prio(mutex->owner, new_prio);
   2b079:	e8 ff 0b 00 00       	callq  2bc7d <z_set_prio>
   2b07e:	40 88 c5             	mov    %al,%bpl
		resched = adjust_owner_prio(mutex, new_prio);
	}

	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   2b081:	48 8d 3d 6d 40 23 00 	lea    0x23406d(%rip),%rdi        # 25f0f5 <lock>
   2b088:	4c 89 e9             	mov    %r13,%rcx
   2b08b:	48 89 da             	mov    %rbx,%rdx
   2b08e:	44 89 e6             	mov    %r12d,%esi
   2b091:	e8 51 0b 00 00       	callq  2bbe7 <z_pend_curr>
	LOG_DBG("on mutex %p got_mutex value: %d", mutex, got_mutex);

	LOG_DBG("%p got mutex %p (y/n): %c", _current, mutex,
		got_mutex ? 'y' : 'n');

	if (got_mutex == 0) {
   2b096:	85 c0                	test   %eax,%eax
   2b098:	74 69                	je     2b103 <z_impl_k_mutex_lock+0x11d>
	return posix_irq_lock();
   2b09a:	e8 f3 0e fe ff       	callq  bf92 <posix_irq_lock>
   2b09f:	41 89 c4             	mov    %eax,%r12d
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   2b0a2:	48 8b 03             	mov    (%rbx),%rax
	key = k_spin_lock(&lock);

	struct k_thread *waiter = z_waitq_head(&mutex->wait_q);

	new_prio = (waiter != NULL) ?
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   2b0a5:	48 39 d8             	cmp    %rbx,%rax
   2b0a8:	74 1c                	je     2b0c6 <z_impl_k_mutex_lock+0xe0>
   2b0aa:	48 85 c0             	test   %rax,%rax
   2b0ad:	74 17                	je     2b0c6 <z_impl_k_mutex_lock+0xe0>
   2b0af:	0f be 70 1a          	movsbl 0x1a(%rax),%esi
   2b0b3:	b8 00 00 00 00       	mov    $0x0,%eax
   2b0b8:	39 73 1c             	cmp    %esi,0x1c(%rbx)
   2b0bb:	0f 4e 73 1c          	cmovle 0x1c(%rbx),%esi
   2b0bf:	85 f6                	test   %esi,%esi
   2b0c1:	0f 48 f0             	cmovs  %eax,%esi
   2b0c4:	eb 03                	jmp    2b0c9 <z_impl_k_mutex_lock+0xe3>
   2b0c6:	8b 73 1c             	mov    0x1c(%rbx),%esi
		mutex->owner_orig_prio;

	LOG_DBG("adjusting prio down on mutex %p", mutex);

	resched = adjust_owner_prio(mutex, new_prio) || resched;
   2b0c9:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
	if (mutex->owner->base.prio != new_prio) {
   2b0cd:	0f be 47 1a          	movsbl 0x1a(%rdi),%eax
   2b0d1:	39 c6                	cmp    %eax,%esi
   2b0d3:	75 07                	jne    2b0dc <z_impl_k_mutex_lock+0xf6>

	if (resched) {
   2b0d5:	40 84 ed             	test   %bpl,%bpl
   2b0d8:	74 1c                	je     2b0f6 <z_impl_k_mutex_lock+0x110>
   2b0da:	eb 09                	jmp    2b0e5 <z_impl_k_mutex_lock+0xff>
		return z_set_prio(mutex->owner, new_prio);
   2b0dc:	e8 9c 0b 00 00       	callq  2bc7d <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   2b0e1:	84 c0                	test   %al,%al
   2b0e3:	74 f0                	je     2b0d5 <z_impl_k_mutex_lock+0xef>
		z_reschedule(&lock, key);
   2b0e5:	48 8d 3d 09 40 23 00 	lea    0x234009(%rip),%rdi        # 25f0f5 <lock>
   2b0ec:	44 89 e6             	mov    %r12d,%esi
   2b0ef:	e8 76 04 00 00       	callq  2b56a <z_reschedule>
   2b0f4:	eb 08                	jmp    2b0fe <z_impl_k_mutex_lock+0x118>
	posix_irq_unlock(key);
   2b0f6:	44 89 e7             	mov    %r12d,%edi
   2b0f9:	e8 9e 0e fe ff       	callq  bf9c <posix_irq_unlock>
	} else {
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
   2b0fe:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
   2b103:	5a                   	pop    %rdx
   2b104:	5b                   	pop    %rbx
   2b105:	5d                   	pop    %rbp
   2b106:	41 5c                	pop    %r12
   2b108:	41 5d                	pop    %r13
   2b10a:	c3                   	retq   

000000000002b10b <z_impl_k_mutex_unlock>:
{
	struct k_thread *new_owner;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	CHECKIF(mutex->owner == NULL) {
   2b10b:	48 8b 57 10          	mov    0x10(%rdi),%rdx
		return -EINVAL;
   2b10f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	CHECKIF(mutex->owner == NULL) {
   2b114:	48 85 d2             	test   %rdx,%rdx
   2b117:	0f 84 9a 00 00 00    	je     2b1b7 <z_impl_k_mutex_unlock+0xac>
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   2b11d:	48 8d 0d 1c ca 22 00 	lea    0x22ca1c(%rip),%rcx        # 257b40 <_kernel>
		return -EPERM;
   2b124:	83 c0 15             	add    $0x15,%eax
	CHECKIF(mutex->owner != _current) {
   2b127:	48 3b 51 10          	cmp    0x10(%rcx),%rdx
   2b12b:	0f 85 86 00 00 00    	jne    2b1b7 <z_impl_k_mutex_unlock+0xac>
{
   2b131:	55                   	push   %rbp
   2b132:	53                   	push   %rbx
   2b133:	48 89 fb             	mov    %rdi,%rbx
   2b136:	48 83 ec 08          	sub    $0x8,%rsp
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
   2b13a:	fe 4a 1b             	decb   0x1b(%rdx)

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count - 1U != 0U) {
   2b13d:	8b 47 18             	mov    0x18(%rdi),%eax
   2b140:	83 f8 01             	cmp    $0x1,%eax
   2b143:	74 07                	je     2b14c <z_impl_k_mutex_unlock+0x41>
		mutex->lock_count--;
   2b145:	ff c8                	dec    %eax
   2b147:	89 47 18             	mov    %eax,0x18(%rdi)
		goto k_mutex_unlock_return;
   2b14a:	eb 60                	jmp    2b1ac <z_impl_k_mutex_unlock+0xa1>
	return posix_irq_lock();
   2b14c:	e8 41 0e fe ff       	callq  bf92 <posix_irq_lock>
	}

	k_spinlock_key_t key = k_spin_lock(&lock);

	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   2b151:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
   2b155:	89 c5                	mov    %eax,%ebp
   2b157:	8b 73 1c             	mov    0x1c(%rbx),%esi
	if (mutex->owner->base.prio != new_prio) {
   2b15a:	0f be 47 1a          	movsbl 0x1a(%rdi),%eax
   2b15e:	39 c6                	cmp    %eax,%esi
   2b160:	74 05                	je     2b167 <z_impl_k_mutex_unlock+0x5c>
		return z_set_prio(mutex->owner, new_prio);
   2b162:	e8 16 0b 00 00       	callq  2bc7d <z_set_prio>

	/* Get the new owner, if any */
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   2b167:	48 89 df             	mov    %rbx,%rdi
   2b16a:	e8 e3 0b 00 00       	callq  2bd52 <z_unpend_first_thread>
	mutex->owner = new_owner;

	LOG_DBG("new owner of mutex %p: %p (prio: %d)",
		mutex, new_owner, new_owner ? new_owner->base.prio : -1000);

	if (new_owner != NULL) {
   2b16f:	48 85 c0             	test   %rax,%rax
	mutex->owner = new_owner;
   2b172:	48 89 43 10          	mov    %rax,0x10(%rbx)
	if (new_owner != NULL) {
   2b176:	74 26                	je     2b19e <z_impl_k_mutex_unlock+0x93>
		/*
		 * new owner is already of higher or equal prio than first
		 * waiter since the wait queue is priority-based: no need to
		 * ajust its priority
		 */
		mutex->owner_orig_prio = new_owner->base.prio;
   2b178:	0f be 50 1a          	movsbl 0x1a(%rax),%edx
		arch_thread_return_value_set(new_owner, 0);
		z_ready_thread(new_owner);
   2b17c:	48 89 c7             	mov    %rax,%rdi
		mutex->owner_orig_prio = new_owner->base.prio;
   2b17f:	89 53 1c             	mov    %edx,0x1c(%rbx)
   2b182:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
		z_ready_thread(new_owner);
   2b189:	e8 03 06 00 00       	callq  2b791 <z_ready_thread>
		z_reschedule(&lock, key);
   2b18e:	48 8d 3d 60 3f 23 00 	lea    0x233f60(%rip),%rdi        # 25f0f5 <lock>
   2b195:	89 ee                	mov    %ebp,%esi
   2b197:	e8 ce 03 00 00       	callq  2b56a <z_reschedule>
   2b19c:	eb 0e                	jmp    2b1ac <z_impl_k_mutex_unlock+0xa1>
	} else {
		mutex->lock_count = 0U;
   2b19e:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%rbx)
	posix_irq_unlock(key);
   2b1a5:	89 ef                	mov    %ebp,%edi
   2b1a7:	e8 f0 0d fe ff       	callq  bf9c <posix_irq_unlock>
		k_spin_unlock(&lock, key);
	}


k_mutex_unlock_return:
	k_sched_unlock();
   2b1ac:	e8 0f 05 00 00       	callq  2b6c0 <k_sched_unlock>
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);

	return 0;
}
   2b1b1:	5a                   	pop    %rdx
	return 0;
   2b1b2:	31 c0                	xor    %eax,%eax
}
   2b1b4:	5b                   	pop    %rbx
   2b1b5:	5d                   	pop    %rbp
   2b1b6:	c3                   	retq   
   2b1b7:	c3                   	retq   

000000000002b1b8 <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static int32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			    bool alloc, bool is_append)
{
   2b1b8:	41 57                	push   %r15
   2b1ba:	41 56                	push   %r14
   2b1bc:	41 89 cf             	mov    %ecx,%r15d
   2b1bf:	41 55                	push   %r13
   2b1c1:	41 54                	push   %r12
   2b1c3:	49 89 f5             	mov    %rsi,%r13
   2b1c6:	55                   	push   %rbp
   2b1c7:	53                   	push   %rbx
   2b1c8:	49 89 d6             	mov    %rdx,%r14
   2b1cb:	48 89 fb             	mov    %rdi,%rbx
	struct k_thread *first_pending_thread;
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   2b1ce:	48 8d 6f 10          	lea    0x10(%rdi),%rbp
{
   2b1d2:	48 83 ec 18          	sub    $0x18,%rsp
   2b1d6:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
	return posix_irq_lock();
   2b1db:	e8 b2 0d fe ff       	callq  bf92 <posix_irq_lock>

	if (is_append) {
   2b1e0:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
   2b1e5:	41 89 c4             	mov    %eax,%r12d
   2b1e8:	45 84 c0             	test   %r8b,%r8b
   2b1eb:	74 04                	je     2b1f1 <queue_insert+0x39>
		prev = sys_sflist_peek_tail(&queue->data_q);
   2b1ed:	4c 8b 6b 08          	mov    0x8(%rbx),%r13
	}
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
   2b1f1:	48 89 ef             	mov    %rbp,%rdi
   2b1f4:	e8 59 0b 00 00       	callq  2bd52 <z_unpend_first_thread>

	if (first_pending_thread != NULL) {
   2b1f9:	48 85 c0             	test   %rax,%rax
   2b1fc:	74 18                	je     2b216 <queue_insert+0x5e>
   2b1fe:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
   2b205:	4c 89 70 20          	mov    %r14,0x20(%rax)
	z_ready_thread(thread);
   2b209:	48 89 c7             	mov    %rax,%rdi
   2b20c:	e8 80 05 00 00       	callq  2b791 <z_ready_thread>
   2b211:	e9 af 00 00 00       	jmpq   2b2c5 <queue_insert+0x10d>
		z_reschedule(&queue->lock, key);
		return 0;
	}

	/* Only need to actually allocate if no threads are pending */
	if (alloc) {
   2b216:	45 84 ff             	test   %r15b,%r15b
   2b219:	74 30                	je     2b24b <queue_insert+0x93>
	return z_thread_aligned_alloc(0, size);
   2b21b:	31 ff                	xor    %edi,%edi
   2b21d:	be 10 00 00 00       	mov    $0x10,%esi
   2b222:	e8 6e 1c 00 00       	callq  2ce95 <z_thread_aligned_alloc>
		struct alloc_node *anode;

		anode = z_thread_malloc(sizeof(*anode));
		if (anode == NULL) {
   2b227:	48 85 c0             	test   %rax,%rax
   2b22a:	75 12                	jne    2b23e <queue_insert+0x86>
	posix_irq_unlock(key);
   2b22c:	44 89 e7             	mov    %r12d,%edi
   2b22f:	e8 68 0d fe ff       	callq  bf9c <posix_irq_unlock>
			k_spin_unlock(&queue->lock, key);
			return -ENOMEM;
   2b234:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
   2b239:	e9 94 00 00 00       	jmpq   2b2d2 <queue_insert+0x11a>
		}
		anode->data = data;
   2b23e:	4c 89 70 08          	mov    %r14,0x8(%rax)
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, uint8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
   2b242:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
   2b249:	eb 0a                	jmp    2b255 <queue_insert+0x9d>
   2b24b:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
   2b252:	4c 89 f0             	mov    %r14,%rax
   2b255:	48 8b 10             	mov    (%rax),%rdx
   2b258:	83 e2 03             	and    $0x3,%edx
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
   2b25b:	4d 85 ed             	test   %r13,%r13
   2b25e:	75 12                	jne    2b272 <queue_insert+0xba>
	parent->next_and_flags = cur_flags | (unative_t)child;
   2b260:	48 0b 13             	or     (%rbx),%rdx
Z_GENLIST_PREPEND(sflist, sfnode)
   2b263:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
	parent->next_and_flags = cur_flags | (unative_t)child;
   2b268:	48 89 10             	mov    %rdx,(%rax)
	list->head = node;
   2b26b:	48 89 03             	mov    %rax,(%rbx)
Z_GENLIST_PREPEND(sflist, sfnode)
   2b26e:	75 47                	jne    2b2b7 <queue_insert+0xff>
   2b270:	eb 2b                	jmp    2b29d <queue_insert+0xe5>
Z_GENLIST_INSERT(sflist, sfnode)
   2b272:	49 8b 4d 00          	mov    0x0(%r13),%rcx
   2b276:	48 83 e1 fc          	and    $0xfffffffffffffffc,%rcx
   2b27a:	75 27                	jne    2b2a3 <queue_insert+0xeb>
Z_GENLIST_APPEND(sflist, sfnode)
   2b27c:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
	parent->next_and_flags = cur_flags | (unative_t)child;
   2b280:	48 89 10             	mov    %rdx,(%rax)
Z_GENLIST_APPEND(sflist, sfnode)
   2b283:	48 85 c9             	test   %rcx,%rcx
   2b286:	75 09                	jne    2b291 <queue_insert+0xd9>
	list->tail = node;
   2b288:	48 89 43 08          	mov    %rax,0x8(%rbx)
	list->head = node;
   2b28c:	48 89 03             	mov    %rax,(%rbx)
   2b28f:	eb 26                	jmp    2b2b7 <queue_insert+0xff>
	parent->next_and_flags = cur_flags | (unative_t)child;
   2b291:	48 8b 11             	mov    (%rcx),%rdx
   2b294:	83 e2 03             	and    $0x3,%edx
   2b297:	48 09 c2             	or     %rax,%rdx
   2b29a:	48 89 11             	mov    %rdx,(%rcx)
	list->tail = node;
   2b29d:	48 89 43 08          	mov    %rax,0x8(%rbx)
   2b2a1:	eb 14                	jmp    2b2b7 <queue_insert+0xff>
	parent->next_and_flags = cur_flags | (unative_t)child;
   2b2a3:	48 09 ca             	or     %rcx,%rdx
   2b2a6:	48 89 10             	mov    %rdx,(%rax)
   2b2a9:	49 8b 55 00          	mov    0x0(%r13),%rdx
   2b2ad:	83 e2 03             	and    $0x3,%edx
   2b2b0:	48 09 d0             	or     %rdx,%rax
   2b2b3:	49 89 45 00          	mov    %rax,0x0(%r13)
	z_handle_obj_poll_events(&queue->poll_events, state);
   2b2b7:	48 8d 7b 20          	lea    0x20(%rbx),%rdi
   2b2bb:	be 04 00 00 00       	mov    $0x4,%esi
   2b2c0:	e8 d4 1a 00 00       	callq  2cd99 <z_handle_obj_poll_events>
		sys_sfnode_init(data, 0x0);
	}

	sys_sflist_insert(&queue->data_q, prev, data);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
	z_reschedule(&queue->lock, key);
   2b2c5:	44 89 e6             	mov    %r12d,%esi
   2b2c8:	48 89 ef             	mov    %rbp,%rdi
   2b2cb:	e8 9a 02 00 00       	callq  2b56a <z_reschedule>
	return 0;
   2b2d0:	31 c0                	xor    %eax,%eax
}
   2b2d2:	48 83 c4 18          	add    $0x18,%rsp
   2b2d6:	5b                   	pop    %rbx
   2b2d7:	5d                   	pop    %rbp
   2b2d8:	41 5c                	pop    %r12
   2b2da:	41 5d                	pop    %r13
   2b2dc:	41 5e                	pop    %r14
   2b2de:	41 5f                	pop    %r15
   2b2e0:	c3                   	retq   

000000000002b2e1 <z_queue_node_peek>:
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
   2b2e1:	48 85 ff             	test   %rdi,%rdi
   2b2e4:	74 19                	je     2b2ff <z_queue_node_peek+0x1e>
   2b2e6:	f6 07 03             	testb  $0x3,(%rdi)
   2b2e9:	74 14                	je     2b2ff <z_queue_node_peek+0x1e>
		if (needs_free) {
   2b2eb:	40 84 f6             	test   %sil,%sil
{
   2b2ee:	53                   	push   %rbx
		ret = anode->data;
   2b2ef:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
		if (needs_free) {
   2b2f3:	74 05                	je     2b2fa <z_queue_node_peek+0x19>
			k_free(anode);
   2b2f5:	e8 76 1b 00 00       	callq  2ce70 <k_free>
}
   2b2fa:	48 89 d8             	mov    %rbx,%rax
   2b2fd:	5b                   	pop    %rbx
   2b2fe:	c3                   	retq   
   2b2ff:	48 89 f8             	mov    %rdi,%rax
   2b302:	c3                   	retq   

000000000002b303 <z_impl_k_queue_init>:
   2b303:	48 8d 47 10          	lea    0x10(%rdi),%rax
	list->head = NULL;
   2b307:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
	list->tail = NULL;
   2b30e:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
   2b315:	00 
	list->head = (sys_dnode_t *)list;
   2b316:	48 89 47 10          	mov    %rax,0x10(%rdi)
	list->tail = (sys_dnode_t *)list;
   2b31a:	48 89 47 18          	mov    %rax,0x18(%rdi)
	sys_dlist_init(&queue->poll_events);
   2b31e:	48 8d 47 20          	lea    0x20(%rdi),%rax
	list->head = (sys_dnode_t *)list;
   2b322:	48 89 47 20          	mov    %rax,0x20(%rdi)
	list->tail = (sys_dnode_t *)list;
   2b326:	48 89 47 28          	mov    %rax,0x28(%rdi)
}
   2b32a:	c3                   	retq   

000000000002b32b <k_queue_append>:
{
	(void)queue_insert(queue, prev, data, false, false);
}

void k_queue_append(struct k_queue *queue, void *data)
{
   2b32b:	48 89 f2             	mov    %rsi,%rdx
	(void)queue_insert(queue, NULL, data, false, true);
   2b32e:	41 b8 01 00 00 00    	mov    $0x1,%r8d
   2b334:	31 c9                	xor    %ecx,%ecx
   2b336:	31 f6                	xor    %esi,%esi
   2b338:	e9 7b fe ff ff       	jmpq   2b1b8 <queue_insert>

000000000002b33d <k_queue_prepend>:
}

void k_queue_prepend(struct k_queue *queue, void *data)
{
   2b33d:	48 89 f2             	mov    %rsi,%rdx
	(void)queue_insert(queue, NULL, data, false, false);
   2b340:	45 31 c0             	xor    %r8d,%r8d
   2b343:	31 c9                	xor    %ecx,%ecx
   2b345:	31 f6                	xor    %esi,%esi
   2b347:	e9 6c fe ff ff       	jmpq   2b1b8 <queue_insert>

000000000002b34c <k_queue_append_list>:
#endif

int k_queue_append_list(struct k_queue *queue, void *head, void *tail)
{
	/* invalid head or tail of list */
	CHECKIF(head == NULL || tail == NULL) {
   2b34c:	48 85 f6             	test   %rsi,%rsi
   2b34f:	0f 84 99 00 00 00    	je     2b3ee <k_queue_append_list+0xa2>
   2b355:	48 85 d2             	test   %rdx,%rdx
{
   2b358:	41 56                	push   %r14
		return -EINVAL;
   2b35a:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
   2b35f:	41 55                	push   %r13
   2b361:	49 89 d6             	mov    %rdx,%r14
   2b364:	41 54                	push   %r12
   2b366:	55                   	push   %rbp
   2b367:	53                   	push   %rbx
	CHECKIF(head == NULL || tail == NULL) {
   2b368:	74 7b                	je     2b3e5 <k_queue_append_list+0x99>
   2b36a:	48 89 fd             	mov    %rdi,%rbp
   2b36d:	48 89 f3             	mov    %rsi,%rbx
	}

	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   2b370:	4c 8d 67 10          	lea    0x10(%rdi),%r12
	return posix_irq_lock();
   2b374:	e8 19 0c fe ff       	callq  bf92 <posix_irq_lock>
   2b379:	41 89 c5             	mov    %eax,%r13d
	}

	while ((head != NULL) && (thread != NULL)) {
		prepare_thread_to_run(thread, head);
		head = *(void **)head;
		thread = z_unpend_first_thread(&queue->wait_q);
   2b37c:	4c 89 e7             	mov    %r12,%rdi
   2b37f:	e8 ce 09 00 00       	callq  2bd52 <z_unpend_first_thread>
	while ((head != NULL) && (thread != NULL)) {
   2b384:	48 85 db             	test   %rbx,%rbx
   2b387:	74 1d                	je     2b3a6 <k_queue_append_list+0x5a>
   2b389:	48 85 c0             	test   %rax,%rax
   2b38c:	74 18                	je     2b3a6 <k_queue_append_list+0x5a>
	thread->base.swap_data = data;
   2b38e:	48 89 58 20          	mov    %rbx,0x20(%rax)
   2b392:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
	z_ready_thread(thread);
   2b399:	48 89 c7             	mov    %rax,%rdi
   2b39c:	e8 f0 03 00 00       	callq  2b791 <z_ready_thread>
		head = *(void **)head;
   2b3a1:	48 8b 1b             	mov    (%rbx),%rbx
   2b3a4:	eb d6                	jmp    2b37c <k_queue_append_list+0x30>
	}

	if (head != NULL) {
   2b3a6:	48 85 db             	test   %rbx,%rbx
   2b3a9:	74 1f                	je     2b3ca <k_queue_append_list+0x7e>
Z_GENLIST_APPEND_LIST(sflist, sfnode)
   2b3ab:	48 8b 45 08          	mov    0x8(%rbp),%rax
   2b3af:	48 85 c0             	test   %rax,%rax
   2b3b2:	75 06                	jne    2b3ba <k_queue_append_list+0x6e>
	list->head = node;
   2b3b4:	48 89 5d 00          	mov    %rbx,0x0(%rbp)
   2b3b8:	eb 0c                	jmp    2b3c6 <k_queue_append_list+0x7a>
	parent->next_and_flags = cur_flags | (unative_t)child;
   2b3ba:	48 8b 30             	mov    (%rax),%rsi
   2b3bd:	83 e6 03             	and    $0x3,%esi
   2b3c0:	48 09 f3             	or     %rsi,%rbx
   2b3c3:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
   2b3c6:	4c 89 75 08          	mov    %r14,0x8(%rbp)
	z_handle_obj_poll_events(&queue->poll_events, state);
   2b3ca:	48 8d 7d 20          	lea    0x20(%rbp),%rdi
   2b3ce:	be 04 00 00 00       	mov    $0x4,%esi
   2b3d3:	e8 c1 19 00 00       	callq  2cd99 <z_handle_obj_poll_events>
		sys_sflist_append_list(&queue->data_q, head, tail);
	}

	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
	z_reschedule(&queue->lock, key);
   2b3d8:	44 89 ee             	mov    %r13d,%esi
   2b3db:	4c 89 e7             	mov    %r12,%rdi
   2b3de:	e8 87 01 00 00       	callq  2b56a <z_reschedule>
	return 0;
   2b3e3:	31 c0                	xor    %eax,%eax
}
   2b3e5:	5b                   	pop    %rbx
   2b3e6:	5d                   	pop    %rbp
   2b3e7:	41 5c                	pop    %r12
   2b3e9:	41 5d                	pop    %r13
   2b3eb:	41 5e                	pop    %r14
   2b3ed:	c3                   	retq   
		return -EINVAL;
   2b3ee:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
   2b3f3:	c3                   	retq   

000000000002b3f4 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
   2b3f4:	41 54                	push   %r12
   2b3f6:	55                   	push   %rbp
   2b3f7:	49 89 f4             	mov    %rsi,%r12
   2b3fa:	53                   	push   %rbx
   2b3fb:	48 89 fb             	mov    %rdi,%rbx
   2b3fe:	e8 8f 0b fe ff       	callq  bf92 <posix_irq_lock>
Z_GENLIST_IS_EMPTY(sflist)
   2b403:	48 8b 3b             	mov    (%rbx),%rdi
   2b406:	89 c5                	mov    %eax,%ebp
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   2b408:	48 85 ff             	test   %rdi,%rdi
   2b40b:	74 2a                	je     2b437 <z_impl_k_queue_get+0x43>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   2b40d:	48 8b 07             	mov    (%rdi),%rax
   2b410:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   2b414:	48 3b 7b 08          	cmp    0x8(%rbx),%rdi
	list->head = node;
   2b418:	48 89 03             	mov    %rax,(%rbx)
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   2b41b:	75 04                	jne    2b421 <z_impl_k_queue_get+0x2d>
	list->tail = node;
   2b41d:	48 89 43 08          	mov    %rax,0x8(%rbx)
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   2b421:	be 01 00 00 00       	mov    $0x1,%esi
   2b426:	e8 b6 fe ff ff       	callq  2b2e1 <z_queue_node_peek>
	posix_irq_unlock(key);
   2b42b:	89 ef                	mov    %ebp,%edi
   2b42d:	48 89 c3             	mov    %rax,%rbx
   2b430:	e8 67 0b fe ff       	callq  bf9c <posix_irq_unlock>
		k_spin_unlock(&queue->lock, key);
		return data;
   2b435:	eb 36                	jmp    2b46d <z_impl_k_queue_get+0x79>
	}

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2b437:	4d 85 e4             	test   %r12,%r12
   2b43a:	75 0b                	jne    2b447 <z_impl_k_queue_get+0x53>
   2b43c:	89 c7                	mov    %eax,%edi
		k_spin_unlock(&queue->lock, key);
		return NULL;
   2b43e:	31 db                	xor    %ebx,%ebx
   2b440:	e8 57 0b fe ff       	callq  bf9c <posix_irq_unlock>
   2b445:	eb 26                	jmp    2b46d <z_impl_k_queue_get+0x79>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   2b447:	48 8d 7b 10          	lea    0x10(%rbx),%rdi
	}

	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
   2b44b:	4c 89 e1             	mov    %r12,%rcx
   2b44e:	89 c6                	mov    %eax,%esi

	return (ret != 0) ? NULL : _current->base.swap_data;
   2b450:	31 db                	xor    %ebx,%ebx
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
   2b452:	48 89 fa             	mov    %rdi,%rdx
   2b455:	e8 8d 07 00 00       	callq  2bbe7 <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
   2b45a:	85 c0                	test   %eax,%eax
   2b45c:	75 0f                	jne    2b46d <z_impl_k_queue_get+0x79>
   2b45e:	48 8d 05 db c6 22 00 	lea    0x22c6db(%rip),%rax        # 257b40 <_kernel>
   2b465:	48 8b 40 10          	mov    0x10(%rax),%rax
   2b469:	48 8b 58 20          	mov    0x20(%rax),%rbx
}
   2b46d:	48 89 d8             	mov    %rbx,%rax
   2b470:	5b                   	pop    %rbx
   2b471:	5d                   	pop    %rbp
   2b472:	41 5c                	pop    %r12
   2b474:	c3                   	retq   

000000000002b475 <z_is_t1_higher_prio_than_t2>:
#endif

bool z_is_t1_higher_prio_than_t2(struct k_thread *thread_1,
				 struct k_thread *thread_2)
{
	if (thread_1->base.prio < thread_2->base.prio) {
   2b475:	8a 46 1a             	mov    0x1a(%rsi),%al
   2b478:	38 47 1a             	cmp    %al,0x1a(%rdi)
   2b47b:	0f 9c c0             	setl   %al
		return (d2 - d1) >= 0;
	}
#endif

	return false;
}
   2b47e:	c3                   	retq   

000000000002b47f <z_reset_time_slice>:
{
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
   2b47f:	83 3d 3a 3c 23 00 00 	cmpl   $0x0,0x233c3a(%rip)        # 25f0c0 <slice_time>
   2b486:	74 23                	je     2b4ab <z_reset_time_slice+0x2c>
{
   2b488:	48 83 ec 08          	sub    $0x8,%rsp
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   2b48c:	e8 02 df fd ff       	callq  9393 <z_clock_elapsed>
   2b491:	8b 3d 29 3c 23 00    	mov    0x233c29(%rip),%edi        # 25f0c0 <slice_time>
   2b497:	48 8d 15 a2 c6 22 00 	lea    0x22c6a2(%rip),%rdx        # 257b40 <_kernel>
		z_set_timeout_expiry(slice_time, false);
   2b49e:	31 f6                	xor    %esi,%esi
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   2b4a0:	01 f8                	add    %edi,%eax
   2b4a2:	89 42 28             	mov    %eax,0x28(%rdx)
	}
}
   2b4a5:	58                   	pop    %rax
		z_set_timeout_expiry(slice_time, false);
   2b4a6:	e9 da 11 00 00       	jmpq   2c685 <z_set_timeout_expiry>
   2b4ab:	c3                   	retq   

000000000002b4ac <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
   2b4ac:	41 54                	push   %r12
   2b4ae:	55                   	push   %rbp
   2b4af:	41 89 f4             	mov    %esi,%r12d
   2b4b2:	53                   	push   %rbx
   2b4b3:	89 fb                	mov    %edi,%ebx
	return posix_irq_lock();
   2b4b5:	e8 d8 0a fe ff       	callq  bf92 <posix_irq_lock>
   2b4ba:	89 c5                	mov    %eax,%ebp
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
   2b4bc:	48 8d 05 7d c6 22 00 	lea    0x22c67d(%rip),%rax        # 257b40 <_kernel>
		if (result32 && (t < BIT64(32))) {
   2b4c3:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   2b4c8:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_ms_to_ticks_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
   2b4cf:	89 d8                	mov    %ebx,%eax
		t += off;
   2b4d1:	48 83 c0 09          	add    $0x9,%rax
		if (result32 && (t < BIT64(32))) {
   2b4d5:	48 39 d0             	cmp    %rdx,%rax
   2b4d8:	77 10                	ja     2b4ea <k_sched_time_slice_set+0x3e>
			return ((uint32_t)t) / (from_hz / to_hz);
   2b4da:	8d 43 09             	lea    0x9(%rbx),%eax
   2b4dd:	b9 0a 00 00 00       	mov    $0xa,%ecx
   2b4e2:	31 d2                	xor    %edx,%edx
   2b4e4:	f7 f1                	div    %ecx
   2b4e6:	89 c0                	mov    %eax,%eax
   2b4e8:	eb 0a                	jmp    2b4f4 <k_sched_time_slice_set+0x48>
			return t / (from_hz / to_hz);
   2b4ea:	b9 0a 00 00 00       	mov    $0xa,%ecx
   2b4ef:	31 d2                	xor    %edx,%edx
   2b4f1:	48 f7 f1             	div    %rcx
		slice_time = k_ms_to_ticks_ceil32(slice);
		slice_max_prio = prio;
   2b4f4:	44 89 25 c1 3b 23 00 	mov    %r12d,0x233bc1(%rip)        # 25f0bc <slice_max_prio>
		slice_time = k_ms_to_ticks_ceil32(slice);
   2b4fb:	89 05 bf 3b 23 00    	mov    %eax,0x233bbf(%rip)        # 25f0c0 <slice_time>
		z_reset_time_slice();
   2b501:	e8 79 ff ff ff       	callq  2b47f <z_reset_time_slice>
	}
}
   2b506:	5b                   	pop    %rbx
	posix_irq_unlock(key);
   2b507:	89 ef                	mov    %ebp,%edi
   2b509:	5d                   	pop    %rbp
   2b50a:	41 5c                	pop    %r12
   2b50c:	e9 8b 0a fe ff       	jmpq   bf9c <posix_irq_unlock>

000000000002b511 <z_find_first_thread_to_unpend>:
	pend(thread, wait_q, timeout);
}

ALWAYS_INLINE struct k_thread *z_find_first_thread_to_unpend(_wait_q_t *wait_q,
						     struct k_thread *from)
{
   2b511:	53                   	push   %rbx
   2b512:	48 83 ec 10          	sub    $0x10,%rsp
   2b516:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
   2b51b:	e8 72 0a fe ff       	callq  bf92 <posix_irq_lock>
	ARG_UNUSED(from);

	struct k_thread *ret = NULL;

	LOCKED(&sched_spinlock) {
		ret = _priq_wait_best(&wait_q->waitq);
   2b520:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   2b525:	89 c3                	mov    %eax,%ebx
   2b527:	e8 1a 01 00 00       	callq  2b646 <z_priq_dumb_best>
	posix_irq_unlock(key);
   2b52c:	89 df                	mov    %ebx,%edi
   2b52e:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
   2b533:	e8 64 0a fe ff       	callq  bf9c <posix_irq_unlock>
	}

	return ret;
}
   2b538:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
   2b53d:	48 83 c4 10          	add    $0x10,%rsp
   2b541:	5b                   	pop    %rbx
   2b542:	c3                   	retq   

000000000002b543 <z_unpend_thread_no_timeout>:
	z_mark_thread_as_not_pending(thread);
	thread->base.pended_on = NULL;
}

ALWAYS_INLINE void z_unpend_thread_no_timeout(struct k_thread *thread)
{
   2b543:	53                   	push   %rbx
   2b544:	48 83 ec 10          	sub    $0x10,%rsp
   2b548:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
   2b54d:	e8 40 0a fe ff       	callq  bf92 <posix_irq_lock>
	LOCKED(&sched_spinlock) {
		unpend_thread_no_timeout(thread);
   2b552:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   2b557:	89 c3                	mov    %eax,%ebx
   2b559:	e8 9f 00 00 00       	callq  2b5fd <unpend_thread_no_timeout>
	}
}
   2b55e:	48 83 c4 10          	add    $0x10,%rsp
	posix_irq_unlock(key);
   2b562:	89 df                	mov    %ebx,%edi
   2b564:	5b                   	pop    %rbx
   2b565:	e9 32 0a fe ff       	jmpq   bf9c <posix_irq_unlock>

000000000002b56a <z_reschedule>:
{
#ifdef CONFIG_SMP
	_current_cpu->swap_ok = 0;
#endif

	return arch_irq_unlocked(key) && !arch_is_in_isr();
   2b56a:	85 f6                	test   %esi,%esi
   2b56c:	75 1d                	jne    2b58b <z_reschedule+0x21>
}
#endif

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
   2b56e:	48 8d 05 cb c5 22 00 	lea    0x22c5cb(%rip),%rax        # 257b40 <_kernel>
   2b575:	83 38 00             	cmpl   $0x0,(%rax)
   2b578:	75 11                	jne    2b58b <z_reschedule+0x21>
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
	if (resched(key.key) && need_swap()) {
   2b57a:	48 8b 50 10          	mov    0x10(%rax),%rdx
   2b57e:	48 39 50 40          	cmp    %rdx,0x40(%rax)
   2b582:	74 07                	je     2b58b <z_reschedule+0x21>
	ret = arch_swap(key);
   2b584:	31 ff                	xor    %edi,%edi
   2b586:	e9 ec f3 fd ff       	jmpq   a977 <arch_swap>
   2b58b:	89 f7                	mov    %esi,%edi
   2b58d:	e9 0a 0a fe ff       	jmpq   bf9c <posix_irq_unlock>

000000000002b592 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   2b592:	85 ff                	test   %edi,%edi
   2b594:	75 11                	jne    2b5a7 <z_reschedule_irqlock+0x15>
   2b596:	48 8d 05 a3 c5 22 00 	lea    0x22c5a3(%rip),%rax        # 257b40 <_kernel>
   2b59d:	83 38 00             	cmpl   $0x0,(%rax)
   2b5a0:	75 05                	jne    2b5a7 <z_reschedule_irqlock+0x15>
   2b5a2:	e9 d0 f3 fd ff       	jmpq   a977 <arch_swap>
   2b5a7:	e9 f0 09 fe ff       	jmpq   bf9c <posix_irq_unlock>

000000000002b5ac <z_reschedule_unlocked>:
{
   2b5ac:	48 83 ec 08          	sub    $0x8,%rsp
	return posix_irq_lock();
   2b5b0:	e8 dd 09 fe ff       	callq  bf92 <posix_irq_lock>
	(void) z_reschedule_irqlock(arch_irq_lock());
   2b5b5:	89 c7                	mov    %eax,%edi
}
   2b5b7:	58                   	pop    %rax
	(void) z_reschedule_irqlock(arch_irq_lock());
   2b5b8:	e9 d5 ff ff ff       	jmpq   2b592 <z_reschedule_irqlock>

000000000002b5bd <k_sched_lock>:
		irq_unlock(key);
	}
}

void k_sched_lock(void)
{
   2b5bd:	48 83 ec 08          	sub    $0x8,%rsp
   2b5c1:	e8 cc 09 fe ff       	callq  bf92 <posix_irq_lock>
	--_current->base.sched_locked;
   2b5c6:	48 8d 15 73 c5 22 00 	lea    0x22c573(%rip),%rdx        # 257b40 <_kernel>
   2b5cd:	48 8b 52 10          	mov    0x10(%rdx),%rdx
   2b5d1:	fe 4a 1b             	decb   0x1b(%rdx)
	posix_irq_unlock(key);
   2b5d4:	89 c7                	mov    %eax,%edi
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
   2b5d6:	58                   	pop    %rax
   2b5d7:	e9 c0 09 fe ff       	jmpq   bf9c <posix_irq_unlock>

000000000002b5dc <z_priq_dumb_remove>:
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
   2b5dc:	48 8b 16             	mov    (%rsi),%rdx
   2b5df:	48 8b 46 08          	mov    0x8(%rsi),%rax
   2b5e3:	48 89 10             	mov    %rdx,(%rax)
	node->next->prev = node->prev;
   2b5e6:	48 8b 16             	mov    (%rsi),%rdx
   2b5e9:	48 89 42 08          	mov    %rax,0x8(%rdx)
	node->next = NULL;
   2b5ed:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
	node->prev = NULL;
   2b5f4:	48 c7 46 08 00 00 00 	movq   $0x0,0x8(%rsi)
   2b5fb:	00 
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
   2b5fc:	c3                   	retq   

000000000002b5fd <unpend_thread_no_timeout>:
{
   2b5fd:	53                   	push   %rbx
   2b5fe:	48 89 fb             	mov    %rdi,%rbx
	_priq_wait_remove(&pended_on(thread)->waitq, thread);
   2b601:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
   2b605:	48 89 de             	mov    %rbx,%rsi
   2b608:	e8 cf ff ff ff       	callq  2b5dc <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   2b60d:	80 63 19 fd          	andb   $0xfd,0x19(%rbx)
	thread->base.pended_on = NULL;
   2b611:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
   2b618:	00 
}
   2b619:	5b                   	pop    %rbx
   2b61a:	c3                   	retq   

000000000002b61b <z_unpend_thread>:
{
   2b61b:	55                   	push   %rbp
   2b61c:	53                   	push   %rbx
   2b61d:	48 89 fb             	mov    %rdi,%rbx
   2b620:	48 83 ec 08          	sub    $0x8,%rsp
	return posix_irq_lock();
   2b624:	e8 69 09 fe ff       	callq  bf92 <posix_irq_lock>
		unpend_thread_no_timeout(thread);
   2b629:	48 89 df             	mov    %rbx,%rdi
   2b62c:	89 c5                	mov    %eax,%ebp
   2b62e:	e8 ca ff ff ff       	callq  2b5fd <unpend_thread_no_timeout>
	posix_irq_unlock(key);
   2b633:	89 ef                	mov    %ebp,%edi
   2b635:	e8 62 09 fe ff       	callq  bf9c <posix_irq_unlock>
}
   2b63a:	58                   	pop    %rax
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   2b63b:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
   2b63f:	5b                   	pop    %rbx
   2b640:	5d                   	pop    %rbp
   2b641:	e9 e2 0f 00 00       	jmpq   2c628 <z_abort_timeout>

000000000002b646 <z_priq_dumb_best>:
	return list->head == list;
   2b646:	48 8b 07             	mov    (%rdi),%rax
struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
	struct k_thread *thread = NULL;
	sys_dnode_t *n = sys_dlist_peek_head(pq);

	if (n != NULL) {
   2b649:	48 85 c0             	test   %rax,%rax
   2b64c:	74 05                	je     2b653 <z_priq_dumb_best+0xd>
   2b64e:	48 39 c7             	cmp    %rax,%rdi
   2b651:	75 02                	jne    2b655 <z_priq_dumb_best+0xf>
	struct k_thread *thread = NULL;
   2b653:	31 c0                	xor    %eax,%eax
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
   2b655:	c3                   	retq   

000000000002b656 <update_cache>:
{
   2b656:	41 54                	push   %r12
   2b658:	55                   	push   %rbp
   2b659:	41 89 fc             	mov    %edi,%r12d
   2b65c:	53                   	push   %rbx
	if (_current_cpu->pending_abort != NULL) {
   2b65d:	48 8d 1d dc c4 22 00 	lea    0x22c4dc(%rip),%rbx        # 257b40 <_kernel>
   2b664:	48 83 7b 20 00       	cmpq   $0x0,0x20(%rbx)
   2b669:	75 22                	jne    2b68d <update_cache+0x37>
	thread = _priq_run_best(&_kernel.ready_q.runq);
   2b66b:	48 8d 7b 48          	lea    0x48(%rbx),%rdi
   2b66f:	e8 d2 ff ff ff       	callq  2b646 <z_priq_dumb_best>
	if (_current->base.thread_state & _THREAD_ABORTING) {
   2b674:	48 8b 53 10          	mov    0x10(%rbx),%rdx
	thread = _priq_run_best(&_kernel.ready_q.runq);
   2b678:	48 89 c5             	mov    %rax,%rbp
	if (_current->base.thread_state & _THREAD_ABORTING) {
   2b67b:	8a 42 19             	mov    0x19(%rdx),%al
   2b67e:	a8 20                	test   $0x20,%al
   2b680:	74 06                	je     2b688 <update_cache+0x32>
		_current->base.thread_state |= _THREAD_DEAD;
   2b682:	83 c8 08             	or     $0x8,%eax
   2b685:	88 42 19             	mov    %al,0x19(%rdx)
	return thread ? thread : _current_cpu->idle_thread;
   2b688:	48 85 ed             	test   %rbp,%rbp
   2b68b:	75 04                	jne    2b691 <update_cache+0x3b>
   2b68d:	48 8b 6b 18          	mov    0x18(%rbx),%rbp
	if (preempt_ok != 0) {
   2b691:	45 85 e4             	test   %r12d,%r12d
   2b694:	48 8b 43 10          	mov    0x10(%rbx),%rax
   2b698:	75 13                	jne    2b6ad <update_cache+0x57>
	if (z_is_thread_prevented_from_running(_current)) {
   2b69a:	f6 40 19 1f          	testb  $0x1f,0x19(%rax)
   2b69e:	75 0d                	jne    2b6ad <update_cache+0x57>
	if (is_preempt(_current) || is_metairq(thread)) {
   2b6a0:	66 83 78 1a 7f       	cmpw   $0x7f,0x1a(%rax)
   2b6a5:	76 06                	jbe    2b6ad <update_cache+0x57>
		_kernel.ready_q.cache = _current;
   2b6a7:	48 89 43 40          	mov    %rax,0x40(%rbx)
   2b6ab:	eb 0e                	jmp    2b6bb <update_cache+0x65>
		if (thread != _current) {
   2b6ad:	48 39 c5             	cmp    %rax,%rbp
   2b6b0:	74 05                	je     2b6b7 <update_cache+0x61>
			z_reset_time_slice();
   2b6b2:	e8 c8 fd ff ff       	callq  2b47f <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   2b6b7:	48 89 6b 40          	mov    %rbp,0x40(%rbx)
}
   2b6bb:	5b                   	pop    %rbx
   2b6bc:	5d                   	pop    %rbp
   2b6bd:	41 5c                	pop    %r12
   2b6bf:	c3                   	retq   

000000000002b6c0 <k_sched_unlock>:
{
   2b6c0:	53                   	push   %rbx
	return posix_irq_lock();
   2b6c1:	e8 cc 08 fe ff       	callq  bf92 <posix_irq_lock>
   2b6c6:	89 c3                	mov    %eax,%ebx
		++_current->base.sched_locked;
   2b6c8:	48 8d 05 71 c4 22 00 	lea    0x22c471(%rip),%rax        # 257b40 <_kernel>
		update_cache(0);
   2b6cf:	31 ff                	xor    %edi,%edi
		++_current->base.sched_locked;
   2b6d1:	48 8b 50 10          	mov    0x10(%rax),%rdx
   2b6d5:	fe 42 1b             	incb   0x1b(%rdx)
		update_cache(0);
   2b6d8:	e8 79 ff ff ff       	callq  2b656 <update_cache>
	posix_irq_unlock(key);
   2b6dd:	89 df                	mov    %ebx,%edi
   2b6df:	e8 b8 08 fe ff       	callq  bf9c <posix_irq_unlock>
}
   2b6e4:	5b                   	pop    %rbx
	z_reschedule_unlocked();
   2b6e5:	e9 c2 fe ff ff       	jmpq   2b5ac <z_reschedule_unlocked>

000000000002b6ea <ready_thread>:
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   2b6ea:	8a 47 19             	mov    0x19(%rdi),%al
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
   2b6ed:	84 c0                	test   %al,%al
   2b6ef:	0f 88 9b 00 00 00    	js     2b790 <ready_thread+0xa6>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   2b6f5:	a8 1f                	test   $0x1f,%al
   2b6f7:	0f 85 93 00 00 00    	jne    2b790 <ready_thread+0xa6>
   2b6fd:	48 83 7f 28 00       	cmpq   $0x0,0x28(%rdi)
   2b702:	0f 85 88 00 00 00    	jne    2b790 <ready_thread+0xa6>
{
   2b708:	41 54                	push   %r12
   2b70a:	4c 8d 25 2f c4 22 00 	lea    0x22c42f(%rip),%r12        # 257b40 <_kernel>
   2b711:	55                   	push   %rbp
   2b712:	53                   	push   %rbx
   2b713:	48 89 fb             	mov    %rdi,%rbx
   2b716:	49 8b 6c 24 48       	mov    0x48(%r12),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2b71b:	48 85 ed             	test   %rbp,%rbp
   2b71e:	74 0a                	je     2b72a <ready_thread+0x40>
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2b720:	49 8d 44 24 48       	lea    0x48(%r12),%rax
   2b725:	48 39 c5             	cmp    %rax,%rbp
   2b728:	75 20                	jne    2b74a <ready_thread+0x60>
	node->next = list;
   2b72a:	49 8d 44 24 48       	lea    0x48(%r12),%rax
   2b72f:	48 89 03             	mov    %rax,(%rbx)
	node->prev = list->tail;
   2b732:	49 8b 44 24 50       	mov    0x50(%r12),%rax
   2b737:	48 89 43 08          	mov    %rax,0x8(%rbx)
	list->tail->next = node;
   2b73b:	49 8b 44 24 50       	mov    0x50(%r12),%rax
   2b740:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
   2b743:	49 89 5c 24 50       	mov    %rbx,0x50(%r12)
   2b748:	eb 37                	jmp    2b781 <ready_thread+0x97>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
   2b74a:	48 89 ee             	mov    %rbp,%rsi
   2b74d:	48 89 df             	mov    %rbx,%rdi
   2b750:	e8 20 fd ff ff       	callq  2b475 <z_is_t1_higher_prio_than_t2>
   2b755:	84 c0                	test   %al,%al
   2b757:	74 18                	je     2b771 <ready_thread+0x87>
	node->prev = successor->prev;
   2b759:	48 8b 45 08          	mov    0x8(%rbp),%rax
	node->next = successor;
   2b75d:	48 89 2b             	mov    %rbp,(%rbx)
	node->prev = successor->prev;
   2b760:	48 89 43 08          	mov    %rax,0x8(%rbx)
	successor->prev->next = node;
   2b764:	48 8b 45 08          	mov    0x8(%rbp),%rax
   2b768:	48 89 18             	mov    %rbx,(%rax)
	successor->prev = node;
   2b76b:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
   2b76f:	eb 10                	jmp    2b781 <ready_thread+0x97>
	return (node == list->tail) ? NULL : node->next;
   2b771:	49 3b 6c 24 50       	cmp    0x50(%r12),%rbp
   2b776:	74 b2                	je     2b72a <ready_thread+0x40>
   2b778:	48 8b 6d 00          	mov    0x0(%rbp),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2b77c:	48 85 ed             	test   %rbp,%rbp
   2b77f:	eb a7                	jmp    2b728 <ready_thread+0x3e>
	thread->base.thread_state |= states;
   2b781:	80 4b 19 80          	orb    $0x80,0x19(%rbx)
		update_cache(0);
   2b785:	31 ff                	xor    %edi,%edi
}
   2b787:	5b                   	pop    %rbx
   2b788:	5d                   	pop    %rbp
   2b789:	41 5c                	pop    %r12
		update_cache(0);
   2b78b:	e9 c6 fe ff ff       	jmpq   2b656 <update_cache>
   2b790:	c3                   	retq   

000000000002b791 <z_ready_thread>:
{
   2b791:	53                   	push   %rbx
   2b792:	48 83 ec 10          	sub    $0x10,%rsp
   2b796:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
   2b79b:	e8 f2 07 fe ff       	callq  bf92 <posix_irq_lock>
		ready_thread(thread);
   2b7a0:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   2b7a5:	89 c3                	mov    %eax,%ebx
   2b7a7:	e8 3e ff ff ff       	callq  2b6ea <ready_thread>
}
   2b7ac:	48 83 c4 10          	add    $0x10,%rsp
	posix_irq_unlock(key);
   2b7b0:	89 df                	mov    %ebx,%edi
   2b7b2:	5b                   	pop    %rbx
   2b7b3:	e9 e4 07 fe ff       	jmpq   bf9c <posix_irq_unlock>

000000000002b7b8 <z_sched_start>:
{
   2b7b8:	53                   	push   %rbx
   2b7b9:	48 83 ec 10          	sub    $0x10,%rsp
   2b7bd:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
   2b7c2:	e8 cb 07 fe ff       	callq  bf92 <posix_irq_lock>
	if (z_has_thread_started(thread)) {
   2b7c7:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   2b7cc:	89 c3                	mov    %eax,%ebx
   2b7ce:	8a 57 19             	mov    0x19(%rdi),%dl
   2b7d1:	f6 c2 04             	test   $0x4,%dl
   2b7d4:	75 0c                	jne    2b7e2 <z_sched_start+0x2a>
}
   2b7d6:	48 83 c4 10          	add    $0x10,%rsp
	posix_irq_unlock(key);
   2b7da:	89 c7                	mov    %eax,%edi
   2b7dc:	5b                   	pop    %rbx
   2b7dd:	e9 ba 07 fe ff       	jmpq   bf9c <posix_irq_unlock>
	thread->base.thread_state &= ~_THREAD_PRESTART;
   2b7e2:	83 e2 fb             	and    $0xfffffffb,%edx
   2b7e5:	88 57 19             	mov    %dl,0x19(%rdi)
	ready_thread(thread);
   2b7e8:	e8 fd fe ff ff       	callq  2b6ea <ready_thread>
}
   2b7ed:	48 83 c4 10          	add    $0x10,%rsp
	z_reschedule(&sched_spinlock, key);
   2b7f1:	89 de                	mov    %ebx,%esi
   2b7f3:	48 8d 3d fb 38 23 00 	lea    0x2338fb(%rip),%rdi        # 25f0f5 <lock>
}
   2b7fa:	5b                   	pop    %rbx
	z_reschedule(&sched_spinlock, key);
   2b7fb:	e9 6a fd ff ff       	jmpq   2b56a <z_reschedule>

000000000002b800 <z_thread_timeout>:
{
   2b800:	41 54                	push   %r12
   2b802:	55                   	push   %rbp
   2b803:	53                   	push   %rbx
   2b804:	48 89 fb             	mov    %rdi,%rbx
		struct k_thread *thread = CONTAINER_OF(timeout,
   2b807:	48 8d 6b d8          	lea    -0x28(%rbx),%rbp
	return posix_irq_lock();
   2b80b:	e8 82 07 fe ff       	callq  bf92 <posix_irq_lock>
		if (thread->base.pended_on != NULL) {
   2b810:	48 83 7b e8 00       	cmpq   $0x0,-0x18(%rbx)
   2b815:	41 89 c4             	mov    %eax,%r12d
   2b818:	74 08                	je     2b822 <z_thread_timeout+0x22>
			unpend_thread_no_timeout(thread);
   2b81a:	48 89 ef             	mov    %rbp,%rdi
   2b81d:	e8 db fd ff ff       	callq  2b5fd <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   2b822:	80 63 f1 eb          	andb   $0xeb,-0xf(%rbx)
		ready_thread(thread);
   2b826:	48 89 ef             	mov    %rbp,%rdi
   2b829:	e8 bc fe ff ff       	callq  2b6ea <ready_thread>
}
   2b82e:	5b                   	pop    %rbx
	posix_irq_unlock(key);
   2b82f:	44 89 e7             	mov    %r12d,%edi
   2b832:	5d                   	pop    %rbp
   2b833:	41 5c                	pop    %r12
   2b835:	e9 62 07 fe ff       	jmpq   bf9c <posix_irq_unlock>

000000000002b83a <move_thread_to_end_of_prio_q>:
{
   2b83a:	41 54                	push   %r12
   2b83c:	55                   	push   %rbp
   2b83d:	53                   	push   %rbx
	if (z_is_thread_queued(thread)) {
   2b83e:	80 7f 19 00          	cmpb   $0x0,0x19(%rdi)
{
   2b842:	48 89 fb             	mov    %rdi,%rbx
   2b845:	4c 8d 25 f4 c2 22 00 	lea    0x22c2f4(%rip),%r12        # 257b40 <_kernel>
	if (z_is_thread_queued(thread)) {
   2b84c:	79 0d                	jns    2b85b <move_thread_to_end_of_prio_q+0x21>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
   2b84e:	48 89 fe             	mov    %rdi,%rsi
   2b851:	49 8d 7c 24 48       	lea    0x48(%r12),%rdi
   2b856:	e8 81 fd ff ff       	callq  2b5dc <z_priq_dumb_remove>
	return list->head == list;
   2b85b:	49 8b 6c 24 48       	mov    0x48(%r12),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2b860:	48 85 ed             	test   %rbp,%rbp
   2b863:	74 0a                	je     2b86f <move_thread_to_end_of_prio_q+0x35>
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2b865:	49 8d 44 24 48       	lea    0x48(%r12),%rax
   2b86a:	48 39 c5             	cmp    %rax,%rbp
   2b86d:	75 20                	jne    2b88f <move_thread_to_end_of_prio_q+0x55>
	node->next = list;
   2b86f:	49 8d 44 24 48       	lea    0x48(%r12),%rax
   2b874:	48 89 03             	mov    %rax,(%rbx)
	node->prev = list->tail;
   2b877:	49 8b 44 24 50       	mov    0x50(%r12),%rax
   2b87c:	48 89 43 08          	mov    %rax,0x8(%rbx)
	list->tail->next = node;
   2b880:	49 8b 44 24 50       	mov    0x50(%r12),%rax
   2b885:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
   2b888:	49 89 5c 24 50       	mov    %rbx,0x50(%r12)
   2b88d:	eb 37                	jmp    2b8c6 <move_thread_to_end_of_prio_q+0x8c>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
   2b88f:	48 89 ee             	mov    %rbp,%rsi
   2b892:	48 89 df             	mov    %rbx,%rdi
   2b895:	e8 db fb ff ff       	callq  2b475 <z_is_t1_higher_prio_than_t2>
   2b89a:	84 c0                	test   %al,%al
   2b89c:	74 18                	je     2b8b6 <move_thread_to_end_of_prio_q+0x7c>
	node->prev = successor->prev;
   2b89e:	48 8b 45 08          	mov    0x8(%rbp),%rax
	node->next = successor;
   2b8a2:	48 89 2b             	mov    %rbp,(%rbx)
	node->prev = successor->prev;
   2b8a5:	48 89 43 08          	mov    %rax,0x8(%rbx)
	successor->prev->next = node;
   2b8a9:	48 8b 45 08          	mov    0x8(%rbp),%rax
   2b8ad:	48 89 18             	mov    %rbx,(%rax)
	successor->prev = node;
   2b8b0:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
   2b8b4:	eb 10                	jmp    2b8c6 <move_thread_to_end_of_prio_q+0x8c>
	return (node == list->tail) ? NULL : node->next;
   2b8b6:	49 39 6c 24 50       	cmp    %rbp,0x50(%r12)
   2b8bb:	74 b2                	je     2b86f <move_thread_to_end_of_prio_q+0x35>
   2b8bd:	48 8b 6d 00          	mov    0x0(%rbp),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2b8c1:	48 85 ed             	test   %rbp,%rbp
   2b8c4:	eb a7                	jmp    2b86d <move_thread_to_end_of_prio_q+0x33>
	thread->base.thread_state |= states;
   2b8c6:	80 4b 19 80          	orb    $0x80,0x19(%rbx)
	update_cache(thread == _current);
   2b8ca:	31 ff                	xor    %edi,%edi
   2b8cc:	49 39 5c 24 10       	cmp    %rbx,0x10(%r12)
}
   2b8d1:	5b                   	pop    %rbx
   2b8d2:	5d                   	pop    %rbp
   2b8d3:	41 5c                	pop    %r12
	update_cache(thread == _current);
   2b8d5:	40 0f 94 c7          	sete   %dil
   2b8d9:	e9 78 fd ff ff       	jmpq   2b656 <update_cache>

000000000002b8de <z_time_slice>:
{
   2b8de:	55                   	push   %rbp
   2b8df:	53                   	push   %rbx
   2b8e0:	89 fb                	mov    %edi,%ebx
   2b8e2:	48 83 ec 08          	sub    $0x8,%rsp
	return posix_irq_lock();
   2b8e6:	e8 a7 06 fe ff       	callq  bf92 <posix_irq_lock>
	if (slice_time && sliceable(_current)) {
   2b8eb:	83 3d ce 37 23 00 00 	cmpl   $0x0,0x2337ce(%rip)        # 25f0c0 <slice_time>
   2b8f2:	89 c5                	mov    %eax,%ebp
   2b8f4:	48 8d 0d 45 c2 22 00 	lea    0x22c245(%rip),%rcx        # 257b40 <_kernel>
   2b8fb:	74 40                	je     2b93d <z_time_slice+0x5f>
   2b8fd:	48 8b 79 10          	mov    0x10(%rcx),%rdi
		&& !z_is_idle_thread_object(thread);
   2b901:	66 83 7f 1a 7f       	cmpw   $0x7f,0x1a(%rdi)
   2b906:	77 35                	ja     2b93d <z_time_slice+0x5f>
		&& !z_is_thread_prevented_from_running(thread)
   2b908:	f6 47 19 1f          	testb  $0x1f,0x19(%rdi)
   2b90c:	75 2f                	jne    2b93d <z_time_slice+0x5f>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   2b90e:	0f be 47 1a          	movsbl 0x1a(%rdi),%eax
		&& !z_is_idle_thread_object(thread);
   2b912:	39 05 a4 37 23 00    	cmp    %eax,0x2337a4(%rip)        # 25f0bc <slice_max_prio>
   2b918:	7f 23                	jg     2b93d <z_time_slice+0x5f>
   2b91a:	48 3b 3d af a6 20 00 	cmp    0x20a6af(%rip),%rdi        # 235fd0 <_GLOBAL_OFFSET_TABLE_+0x2f0>
   2b921:	74 1a                	je     2b93d <z_time_slice+0x5f>
		if (ticks >= _current_cpu->slice_ticks) {
   2b923:	8b 71 28             	mov    0x28(%rcx),%esi
   2b926:	39 de                	cmp    %ebx,%esi
   2b928:	7f 0c                	jg     2b936 <z_time_slice+0x58>
			move_thread_to_end_of_prio_q(_current);
   2b92a:	e8 0b ff ff ff       	callq  2b83a <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
   2b92f:	e8 4b fb ff ff       	callq  2b47f <z_reset_time_slice>
   2b934:	eb 0e                	jmp    2b944 <z_time_slice+0x66>
			_current_cpu->slice_ticks -= ticks;
   2b936:	29 de                	sub    %ebx,%esi
   2b938:	89 71 28             	mov    %esi,0x28(%rcx)
   2b93b:	eb 07                	jmp    2b944 <z_time_slice+0x66>
		_current_cpu->slice_ticks = 0;
   2b93d:	c7 41 28 00 00 00 00 	movl   $0x0,0x28(%rcx)
}
   2b944:	58                   	pop    %rax
	posix_irq_unlock(key);
   2b945:	89 ef                	mov    %ebp,%edi
   2b947:	5b                   	pop    %rbx
   2b948:	5d                   	pop    %rbp
   2b949:	e9 4e 06 fe ff       	jmpq   bf9c <posix_irq_unlock>

000000000002b94e <z_impl_k_thread_suspend>:
{
   2b94e:	41 54                	push   %r12
   2b950:	55                   	push   %rbp
   2b951:	53                   	push   %rbx
   2b952:	48 89 fb             	mov    %rdi,%rbx
   2b955:	48 83 c7 28          	add    $0x28,%rdi
   2b959:	e8 ca 0c 00 00       	callq  2c628 <z_abort_timeout>
	return posix_irq_lock();
   2b95e:	e8 2f 06 fe ff       	callq  bf92 <posix_irq_lock>
		if (z_is_thread_queued(thread)) {
   2b963:	80 7b 19 00          	cmpb   $0x0,0x19(%rbx)
   2b967:	41 89 c4             	mov    %eax,%r12d
   2b96a:	48 8d 2d cf c1 22 00 	lea    0x22c1cf(%rip),%rbp        # 257b40 <_kernel>
   2b971:	79 10                	jns    2b983 <z_impl_k_thread_suspend+0x35>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   2b973:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
   2b977:	48 89 de             	mov    %rbx,%rsi
   2b97a:	e8 5d fc ff ff       	callq  2b5dc <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   2b97f:	80 63 19 7f          	andb   $0x7f,0x19(%rbx)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   2b983:	80 4b 19 10          	orb    $0x10,0x19(%rbx)
		update_cache(thread == _current);
   2b987:	31 ff                	xor    %edi,%edi
   2b989:	48 39 5d 10          	cmp    %rbx,0x10(%rbp)
   2b98d:	40 0f 94 c7          	sete   %dil
   2b991:	e8 c0 fc ff ff       	callq  2b656 <update_cache>
	posix_irq_unlock(key);
   2b996:	44 89 e7             	mov    %r12d,%edi
   2b999:	e8 fe 05 fe ff       	callq  bf9c <posix_irq_unlock>
	if (thread == _current) {
   2b99e:	48 39 5d 10          	cmp    %rbx,0x10(%rbp)
   2b9a2:	75 09                	jne    2b9ad <z_impl_k_thread_suspend+0x5f>
}
   2b9a4:	5b                   	pop    %rbx
   2b9a5:	5d                   	pop    %rbp
   2b9a6:	41 5c                	pop    %r12
		z_reschedule_unlocked();
   2b9a8:	e9 ff fb ff ff       	jmpq   2b5ac <z_reschedule_unlocked>
}
   2b9ad:	5b                   	pop    %rbx
   2b9ae:	5d                   	pop    %rbp
   2b9af:	41 5c                	pop    %r12
   2b9b1:	c3                   	retq   

000000000002b9b2 <z_thread_single_abort>:
{
   2b9b2:	41 55                	push   %r13
   2b9b4:	41 54                	push   %r12
   2b9b6:	55                   	push   %rbp
   2b9b7:	53                   	push   %rbx
   2b9b8:	48 89 fb             	mov    %rdi,%rbx
   2b9bb:	48 83 ec 08          	sub    $0x8,%rsp
	return posix_irq_lock();
   2b9bf:	e8 ce 05 fe ff       	callq  bf92 <posix_irq_lock>
	if ((thread->base.thread_state &
   2b9c4:	8a 53 19             	mov    0x19(%rbx),%dl
   2b9c7:	89 c7                	mov    %eax,%edi
   2b9c9:	f6 c2 28             	test   $0x28,%dl
   2b9cc:	74 0c                	je     2b9da <z_thread_single_abort+0x28>
}
   2b9ce:	59                   	pop    %rcx
   2b9cf:	5b                   	pop    %rbx
   2b9d0:	5d                   	pop    %rbp
   2b9d1:	41 5c                	pop    %r12
   2b9d3:	41 5d                	pop    %r13
	posix_irq_unlock(key);
   2b9d5:	e9 c2 05 fe ff       	jmpq   bf9c <posix_irq_unlock>
	thread->base.thread_state |= _THREAD_ABORTING;
   2b9da:	83 ca 20             	or     $0x20,%edx
   2b9dd:	88 53 19             	mov    %dl,0x19(%rbx)
   2b9e0:	e8 b7 05 fe ff       	callq  bf9c <posix_irq_unlock>
   2b9e5:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
   2b9e9:	e8 3a 0c 00 00       	callq  2c628 <z_abort_timeout>
	return posix_irq_lock();
   2b9ee:	e8 9f 05 fe ff       	callq  bf92 <posix_irq_lock>
   2b9f3:	41 89 c4             	mov    %eax,%r12d
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   2b9f6:	8a 43 19             	mov    0x19(%rbx),%al
   2b9f9:	a8 1f                	test   $0x1f,%al
   2b9fb:	75 33                	jne    2ba30 <z_thread_single_abort+0x7e>
		if (z_is_thread_ready(thread)) {
   2b9fd:	48 83 7b 28 00       	cmpq   $0x0,0x28(%rbx)
   2ba02:	75 2c                	jne    2ba30 <z_thread_single_abort+0x7e>
			if (z_is_thread_queued(thread)) {
   2ba04:	84 c0                	test   %al,%al
   2ba06:	48 8d 2d 33 c1 22 00 	lea    0x22c133(%rip),%rbp        # 257b40 <_kernel>
   2ba0d:	79 10                	jns    2ba1f <z_thread_single_abort+0x6d>
				_priq_run_remove(&_kernel.ready_q.runq,
   2ba0f:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
   2ba13:	48 89 de             	mov    %rbx,%rsi
   2ba16:	e8 c1 fb ff ff       	callq  2b5dc <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   2ba1b:	80 63 19 7f          	andb   $0x7f,0x19(%rbx)
			update_cache(thread == _current);
   2ba1f:	31 ff                	xor    %edi,%edi
   2ba21:	48 39 5d 10          	cmp    %rbx,0x10(%rbp)
   2ba25:	40 0f 94 c7          	sete   %dil
   2ba29:	e8 28 fc ff ff       	callq  2b656 <update_cache>
   2ba2e:	eb 1c                	jmp    2ba4c <z_thread_single_abort+0x9a>
			if (z_is_thread_pending(thread)) {
   2ba30:	a8 02                	test   $0x2,%al
   2ba32:	74 18                	je     2ba4c <z_thread_single_abort+0x9a>
				_priq_wait_remove(&pended_on(thread)->waitq,
   2ba34:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
   2ba38:	48 89 de             	mov    %rbx,%rsi
   2ba3b:	e8 9c fb ff ff       	callq  2b5dc <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   2ba40:	80 63 19 fd          	andb   $0xfd,0x19(%rbx)
				thread->base.pended_on = NULL;
   2ba44:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
   2ba4b:	00 
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   2ba4c:	4c 8d 6b 48          	lea    0x48(%rbx),%r13
	return list->head == list;
   2ba50:	48 8b 6b 48          	mov    0x48(%rbx),%rbp
		while ((waiter = z_waitq_head(&thread->base.join_waiters)) !=
   2ba54:	48 85 ed             	test   %rbp,%rbp
   2ba57:	74 37                	je     2ba90 <z_thread_single_abort+0xde>
   2ba59:	4c 39 ed             	cmp    %r13,%rbp
   2ba5c:	74 32                	je     2ba90 <z_thread_single_abort+0xde>
   2ba5e:	48 8d 7d 28          	lea    0x28(%rbp),%rdi
   2ba62:	e8 c1 0b 00 00       	callq  2c628 <z_abort_timeout>
			_priq_wait_remove(&pended_on(waiter)->waitq, waiter);
   2ba67:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
   2ba6b:	48 89 ee             	mov    %rbp,%rsi
   2ba6e:	e8 69 fb ff ff       	callq  2b5dc <z_priq_dumb_remove>
   2ba73:	80 65 19 fd          	andb   $0xfd,0x19(%rbp)
			waiter->base.pended_on = NULL;
   2ba77:	48 c7 45 10 00 00 00 	movq   $0x0,0x10(%rbp)
   2ba7e:	00 
			ready_thread(waiter);
   2ba7f:	48 89 ef             	mov    %rbp,%rdi
	thread->callee_saved.retval = value;
   2ba82:	c7 45 5c 00 00 00 00 	movl   $0x0,0x5c(%rbp)
   2ba89:	e8 5c fc ff ff       	callq  2b6ea <ready_thread>
   2ba8e:	eb c0                	jmp    2ba50 <z_thread_single_abort+0x9e>
		if (z_is_idle_thread_object(_current)) {
   2ba90:	48 8d 05 a9 c0 22 00 	lea    0x22c0a9(%rip),%rax        # 257b40 <_kernel>
   2ba97:	48 8d 0d 62 bf 22 00 	lea    0x22bf62(%rip),%rcx        # 257a00 <z_idle_threads>
   2ba9e:	48 39 48 10          	cmp    %rcx,0x10(%rax)
   2baa2:	75 0a                	jne    2baae <z_thread_single_abort+0xfc>
			update_cache(1);
   2baa4:	bf 01 00 00 00       	mov    $0x1,%edi
   2baa9:	e8 a8 fb ff ff       	callq  2b656 <update_cache>
		thread->base.thread_state |= _THREAD_DEAD;
   2baae:	80 4b 19 08          	orb    $0x8,0x19(%rbx)
		fn_abort = thread->fn_abort;
   2bab2:	48 8b 6b 70          	mov    0x70(%rbx),%rbp
	posix_irq_unlock(key);
   2bab6:	44 89 e7             	mov    %r12d,%edi
   2bab9:	e8 de 04 fe ff       	callq  bf9c <posix_irq_unlock>
	if (fn_abort != NULL) {
   2babe:	48 85 ed             	test   %rbp,%rbp
   2bac1:	74 0f                	je     2bad2 <z_thread_single_abort+0x120>
}
   2bac3:	5a                   	pop    %rdx
		fn_abort(thread);
   2bac4:	48 89 df             	mov    %rbx,%rdi
   2bac7:	48 89 e8             	mov    %rbp,%rax
}
   2baca:	5b                   	pop    %rbx
   2bacb:	5d                   	pop    %rbp
   2bacc:	41 5c                	pop    %r12
   2bace:	41 5d                	pop    %r13
		fn_abort(thread);
   2bad0:	ff e0                	jmpq   *%rax
}
   2bad2:	58                   	pop    %rax
   2bad3:	5b                   	pop    %rbx
   2bad4:	5d                   	pop    %rbp
   2bad5:	41 5c                	pop    %r12
   2bad7:	41 5d                	pop    %r13
   2bad9:	c3                   	retq   

000000000002bada <unready_thread>:
{
   2bada:	55                   	push   %rbp
   2badb:	53                   	push   %rbx
   2badc:	48 89 fb             	mov    %rdi,%rbx
   2badf:	48 83 ec 08          	sub    $0x8,%rsp
	if (z_is_thread_queued(thread)) {
   2bae3:	80 7f 19 00          	cmpb   $0x0,0x19(%rdi)
   2bae7:	48 8d 2d 52 c0 22 00 	lea    0x22c052(%rip),%rbp        # 257b40 <_kernel>
   2baee:	79 10                	jns    2bb00 <unready_thread+0x26>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
   2baf0:	48 89 fe             	mov    %rdi,%rsi
   2baf3:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
   2baf7:	e8 e0 fa ff ff       	callq  2b5dc <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   2bafc:	80 63 19 7f          	andb   $0x7f,0x19(%rbx)
	update_cache(thread == _current);
   2bb00:	31 ff                	xor    %edi,%edi
   2bb02:	48 39 5d 10          	cmp    %rbx,0x10(%rbp)
}
   2bb06:	58                   	pop    %rax
   2bb07:	5b                   	pop    %rbx
   2bb08:	5d                   	pop    %rbp
	update_cache(thread == _current);
   2bb09:	40 0f 94 c7          	sete   %dil
   2bb0d:	e9 44 fb ff ff       	jmpq   2b656 <update_cache>

000000000002bb12 <add_to_waitq_locked>:
{
   2bb12:	41 54                	push   %r12
   2bb14:	55                   	push   %rbp
   2bb15:	49 89 f4             	mov    %rsi,%r12
   2bb18:	53                   	push   %rbx
   2bb19:	48 89 fb             	mov    %rdi,%rbx
	unready_thread(thread);
   2bb1c:	e8 b9 ff ff ff       	callq  2bada <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   2bb21:	80 4b 19 02          	orb    $0x2,0x19(%rbx)
	if (wait_q != NULL) {
   2bb25:	4d 85 e4             	test   %r12,%r12
   2bb28:	74 64                	je     2bb8e <add_to_waitq_locked+0x7c>
   2bb2a:	49 8b 2c 24          	mov    (%r12),%rbp
		thread->base.pended_on = wait_q;
   2bb2e:	4c 89 63 10          	mov    %r12,0x10(%rbx)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2bb32:	48 85 ed             	test   %rbp,%rbp
   2bb35:	74 05                	je     2bb3c <add_to_waitq_locked+0x2a>
   2bb37:	49 39 ec             	cmp    %rbp,%r12
   2bb3a:	75 1b                	jne    2bb57 <add_to_waitq_locked+0x45>
	node->prev = list->tail;
   2bb3c:	49 8b 44 24 08       	mov    0x8(%r12),%rax
	node->next = list;
   2bb41:	4c 89 23             	mov    %r12,(%rbx)
	node->prev = list->tail;
   2bb44:	48 89 43 08          	mov    %rax,0x8(%rbx)
	list->tail->next = node;
   2bb48:	49 8b 44 24 08       	mov    0x8(%r12),%rax
   2bb4d:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
   2bb50:	49 89 5c 24 08       	mov    %rbx,0x8(%r12)
   2bb55:	eb 37                	jmp    2bb8e <add_to_waitq_locked+0x7c>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
   2bb57:	48 89 ee             	mov    %rbp,%rsi
   2bb5a:	48 89 df             	mov    %rbx,%rdi
   2bb5d:	e8 13 f9 ff ff       	callq  2b475 <z_is_t1_higher_prio_than_t2>
   2bb62:	84 c0                	test   %al,%al
   2bb64:	74 18                	je     2bb7e <add_to_waitq_locked+0x6c>
	node->prev = successor->prev;
   2bb66:	48 8b 45 08          	mov    0x8(%rbp),%rax
	node->next = successor;
   2bb6a:	48 89 2b             	mov    %rbp,(%rbx)
	node->prev = successor->prev;
   2bb6d:	48 89 43 08          	mov    %rax,0x8(%rbx)
	successor->prev->next = node;
   2bb71:	48 8b 45 08          	mov    0x8(%rbp),%rax
   2bb75:	48 89 18             	mov    %rbx,(%rax)
	successor->prev = node;
   2bb78:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
   2bb7c:	eb 10                	jmp    2bb8e <add_to_waitq_locked+0x7c>
	return (node == list->tail) ? NULL : node->next;
   2bb7e:	49 39 6c 24 08       	cmp    %rbp,0x8(%r12)
   2bb83:	74 b7                	je     2bb3c <add_to_waitq_locked+0x2a>
   2bb85:	48 8b 6d 00          	mov    0x0(%rbp),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2bb89:	48 85 ed             	test   %rbp,%rbp
   2bb8c:	eb ac                	jmp    2bb3a <add_to_waitq_locked+0x28>
}
   2bb8e:	5b                   	pop    %rbx
   2bb8f:	5d                   	pop    %rbp
   2bb90:	41 5c                	pop    %r12
   2bb92:	c3                   	retq   

000000000002bb93 <pend>:
{
   2bb93:	55                   	push   %rbp
   2bb94:	53                   	push   %rbx
   2bb95:	48 89 fb             	mov    %rdi,%rbx
   2bb98:	48 83 ec 18          	sub    $0x18,%rsp
   2bb9c:	48 89 14 24          	mov    %rdx,(%rsp)
   2bba0:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	return posix_irq_lock();
   2bba5:	e8 e8 03 fe ff       	callq  bf92 <posix_irq_lock>
		add_to_waitq_locked(thread, wait_q);
   2bbaa:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
   2bbaf:	89 c5                	mov    %eax,%ebp
   2bbb1:	48 89 df             	mov    %rbx,%rdi
   2bbb4:	e8 59 ff ff ff       	callq  2bb12 <add_to_waitq_locked>
	posix_irq_unlock(key);
   2bbb9:	89 ef                	mov    %ebp,%edi
   2bbbb:	e8 dc 03 fe ff       	callq  bf9c <posix_irq_unlock>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   2bbc0:	48 8b 14 24          	mov    (%rsp),%rdx
   2bbc4:	48 83 fa ff          	cmp    $0xffffffffffffffff,%rdx
   2bbc8:	74 16                	je     2bbe0 <pend+0x4d>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   2bbca:	48 8d 35 2f fc ff ff 	lea    -0x3d1(%rip),%rsi        # 2b800 <z_thread_timeout>
}
   2bbd1:	48 83 c4 18          	add    $0x18,%rsp
   2bbd5:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
   2bbd9:	5b                   	pop    %rbx
   2bbda:	5d                   	pop    %rbp
   2bbdb:	e9 27 09 00 00       	jmpq   2c507 <z_add_timeout>
   2bbe0:	48 83 c4 18          	add    $0x18,%rsp
   2bbe4:	5b                   	pop    %rbx
   2bbe5:	5d                   	pop    %rbp
   2bbe6:	c3                   	retq   

000000000002bbe7 <z_pend_curr>:
	pend(_current, wait_q, timeout);
   2bbe7:	48 8d 05 52 bf 22 00 	lea    0x22bf52(%rip),%rax        # 257b40 <_kernel>
{
   2bbee:	53                   	push   %rbx
   2bbef:	89 f3                	mov    %esi,%ebx
   2bbf1:	48 89 d6             	mov    %rdx,%rsi
   2bbf4:	48 89 ca             	mov    %rcx,%rdx
	pend(_current, wait_q, timeout);
   2bbf7:	48 8b 78 10          	mov    0x10(%rax),%rdi
   2bbfb:	e8 93 ff ff ff       	callq  2bb93 <pend>
   2bc00:	89 df                	mov    %ebx,%edi
}
   2bc02:	5b                   	pop    %rbx
   2bc03:	e9 6f ed fd ff       	jmpq   a977 <arch_swap>

000000000002bc08 <z_tick_sleep.part.25>:
	z_impl_k_yield();
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
   2bc08:	41 55                	push   %r13
   2bc0a:	41 54                	push   %r12
   2bc0c:	49 89 fc             	mov    %rdi,%r12
   2bc0f:	55                   	push   %rbp
   2bc10:	53                   	push   %rbx
   2bc11:	48 83 ec 08          	sub    $0x8,%rsp
		return 0;
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);

	expected_wakeup_ticks = ticks + z_tick_get_32();
   2bc15:	e8 8e 0b 00 00       	callq  2c7a8 <z_tick_get_32>
   2bc1a:	42 8d 1c 20          	lea    (%rax,%r12,1),%ebx
	return posix_irq_lock();
   2bc1e:	e8 6f 03 fe ff       	callq  bf92 <posix_irq_lock>
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
#endif
	unready_thread(_current);
   2bc23:	48 8d 2d 16 bf 22 00 	lea    0x22bf16(%rip),%rbp        # 257b40 <_kernel>
   2bc2a:	41 89 c5             	mov    %eax,%r13d
   2bc2d:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
   2bc31:	e8 a4 fe ff ff       	callq  2bada <unready_thread>
   2bc36:	48 8b 45 10          	mov    0x10(%rbp),%rax
   2bc3a:	48 8d 35 bf fb ff ff 	lea    -0x441(%rip),%rsi        # 2b800 <z_thread_timeout>
   2bc41:	4c 89 e2             	mov    %r12,%rdx
   2bc44:	48 8d 78 28          	lea    0x28(%rax),%rdi
   2bc48:	e8 ba 08 00 00       	callq  2c507 <z_add_timeout>
	z_add_thread_timeout(_current, timeout);
	z_mark_thread_as_suspended(_current);
   2bc4d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
   2bc51:	44 89 ef             	mov    %r13d,%edi
	thread->base.thread_state |= _THREAD_SUSPENDED;
   2bc54:	80 4a 19 10          	orb    $0x10,0x19(%rdx)
   2bc58:	e8 1a ed fd ff       	callq  a977 <arch_swap>

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - z_tick_get_32();
   2bc5d:	e8 46 0b 00 00       	callq  2c7a8 <z_tick_get_32>
   2bc62:	89 da                	mov    %ebx,%edx
   2bc64:	89 c0                	mov    %eax,%eax
   2bc66:	48 29 c2             	sub    %rax,%rdx
   2bc69:	48 89 d0             	mov    %rdx,%rax
   2bc6c:	ba 00 00 00 00       	mov    $0x0,%edx
   2bc71:	48 0f 48 c2          	cmovs  %rdx,%rax
		return ticks;
	}
#endif

	return 0;
}
   2bc75:	5a                   	pop    %rdx
   2bc76:	5b                   	pop    %rbx
   2bc77:	5d                   	pop    %rbp
   2bc78:	41 5c                	pop    %r12
   2bc7a:	41 5d                	pop    %r13
   2bc7c:	c3                   	retq   

000000000002bc7d <z_set_prio>:
{
   2bc7d:	41 55                	push   %r13
   2bc7f:	41 54                	push   %r12
   2bc81:	55                   	push   %rbp
   2bc82:	53                   	push   %rbx
   2bc83:	48 89 fb             	mov    %rdi,%rbx
   2bc86:	89 f5                	mov    %esi,%ebp
   2bc88:	48 83 ec 08          	sub    $0x8,%rsp
   2bc8c:	e8 01 03 fe ff       	callq  bf92 <posix_irq_lock>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   2bc91:	f6 43 19 1f          	testb  $0x1f,0x19(%rbx)
   2bc95:	41 89 c5             	mov    %eax,%r13d
   2bc98:	0f 85 9c 00 00 00    	jne    2bd3a <z_set_prio+0xbd>
		if (need_sched) {
   2bc9e:	48 83 7b 28 00       	cmpq   $0x0,0x28(%rbx)
   2bca3:	0f 85 91 00 00 00    	jne    2bd3a <z_set_prio+0xbd>
				_priq_run_remove(&_kernel.ready_q.runq, thread);
   2bca9:	4c 8d 25 90 be 22 00 	lea    0x22be90(%rip),%r12        # 257b40 <_kernel>
   2bcb0:	48 89 de             	mov    %rbx,%rsi
   2bcb3:	49 8d 7c 24 48       	lea    0x48(%r12),%rdi
   2bcb8:	e8 1f f9 ff ff       	callq  2b5dc <z_priq_dumb_remove>
				thread->base.prio = prio;
   2bcbd:	40 88 6b 1a          	mov    %bpl,0x1a(%rbx)
	return list->head == list;
   2bcc1:	49 8b 6c 24 48       	mov    0x48(%r12),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2bcc6:	48 85 ed             	test   %rbp,%rbp
   2bcc9:	74 0a                	je     2bcd5 <z_set_prio+0x58>
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2bccb:	49 8d 44 24 48       	lea    0x48(%r12),%rax
   2bcd0:	48 39 c5             	cmp    %rax,%rbp
   2bcd3:	75 20                	jne    2bcf5 <z_set_prio+0x78>
	node->next = list;
   2bcd5:	49 8d 44 24 48       	lea    0x48(%r12),%rax
   2bcda:	48 89 03             	mov    %rax,(%rbx)
	node->prev = list->tail;
   2bcdd:	49 8b 44 24 50       	mov    0x50(%r12),%rax
   2bce2:	48 89 43 08          	mov    %rax,0x8(%rbx)
	list->tail->next = node;
   2bce6:	49 8b 44 24 50       	mov    0x50(%r12),%rax
   2bceb:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
   2bcee:	49 89 5c 24 50       	mov    %rbx,0x50(%r12)
   2bcf3:	eb 37                	jmp    2bd2c <z_set_prio+0xaf>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
   2bcf5:	48 89 ee             	mov    %rbp,%rsi
   2bcf8:	48 89 df             	mov    %rbx,%rdi
   2bcfb:	e8 75 f7 ff ff       	callq  2b475 <z_is_t1_higher_prio_than_t2>
   2bd00:	84 c0                	test   %al,%al
   2bd02:	74 18                	je     2bd1c <z_set_prio+0x9f>
	node->prev = successor->prev;
   2bd04:	48 8b 45 08          	mov    0x8(%rbp),%rax
	node->next = successor;
   2bd08:	48 89 2b             	mov    %rbp,(%rbx)
	node->prev = successor->prev;
   2bd0b:	48 89 43 08          	mov    %rax,0x8(%rbx)
	successor->prev->next = node;
   2bd0f:	48 8b 45 08          	mov    0x8(%rbp),%rax
   2bd13:	48 89 18             	mov    %rbx,(%rax)
	successor->prev = node;
   2bd16:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
   2bd1a:	eb 10                	jmp    2bd2c <z_set_prio+0xaf>
	return (node == list->tail) ? NULL : node->next;
   2bd1c:	49 3b 6c 24 50       	cmp    0x50(%r12),%rbp
   2bd21:	74 b2                	je     2bcd5 <z_set_prio+0x58>
   2bd23:	48 8b 6d 00          	mov    0x0(%rbp),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2bd27:	48 85 ed             	test   %rbp,%rbp
   2bd2a:	eb a7                	jmp    2bcd3 <z_set_prio+0x56>
			update_cache(1);
   2bd2c:	bf 01 00 00 00       	mov    $0x1,%edi
   2bd31:	b3 01                	mov    $0x1,%bl
   2bd33:	e8 1e f9 ff ff       	callq  2b656 <update_cache>
   2bd38:	eb 06                	jmp    2bd40 <z_set_prio+0xc3>
			thread->base.prio = prio;
   2bd3a:	40 88 6b 1a          	mov    %bpl,0x1a(%rbx)
   2bd3e:	31 db                	xor    %ebx,%ebx
	posix_irq_unlock(key);
   2bd40:	44 89 ef             	mov    %r13d,%edi
   2bd43:	e8 54 02 fe ff       	callq  bf9c <posix_irq_unlock>
}
   2bd48:	5a                   	pop    %rdx
   2bd49:	88 d8                	mov    %bl,%al
   2bd4b:	5b                   	pop    %rbx
   2bd4c:	5d                   	pop    %rbp
   2bd4d:	41 5c                	pop    %r12
   2bd4f:	41 5d                	pop    %r13
   2bd51:	c3                   	retq   

000000000002bd52 <z_unpend_first_thread>:
{
   2bd52:	55                   	push   %rbp
   2bd53:	53                   	push   %rbx
   2bd54:	48 83 ec 18          	sub    $0x18,%rsp
   2bd58:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
   2bd5d:	e8 30 02 fe ff       	callq  bf92 <posix_irq_lock>
		ret = _priq_wait_best(&wait_q->waitq);
   2bd62:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   2bd67:	89 c5                	mov    %eax,%ebp
   2bd69:	e8 d8 f8 ff ff       	callq  2b646 <z_priq_dumb_best>
	posix_irq_unlock(key);
   2bd6e:	89 ef                	mov    %ebp,%edi
   2bd70:	48 89 c3             	mov    %rax,%rbx
   2bd73:	e8 24 02 fe ff       	callq  bf9c <posix_irq_unlock>

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
   2bd78:	48 85 db             	test   %rbx,%rbx
   2bd7b:	74 1f                	je     2bd9c <z_unpend_first_thread+0x4a>
	return posix_irq_lock();
   2bd7d:	e8 10 02 fe ff       	callq  bf92 <posix_irq_lock>
		unpend_thread_no_timeout(thread);
   2bd82:	48 89 df             	mov    %rbx,%rdi
   2bd85:	89 c5                	mov    %eax,%ebp
   2bd87:	e8 71 f8 ff ff       	callq  2b5fd <unpend_thread_no_timeout>
	posix_irq_unlock(key);
   2bd8c:	89 ef                	mov    %ebp,%edi
   2bd8e:	e8 09 02 fe ff       	callq  bf9c <posix_irq_unlock>
	return z_abort_timeout(&thread->base.timeout);
   2bd93:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
   2bd97:	e8 8c 08 00 00       	callq  2c628 <z_abort_timeout>
}
   2bd9c:	48 83 c4 18          	add    $0x18,%rsp
   2bda0:	48 89 d8             	mov    %rbx,%rax
   2bda3:	5b                   	pop    %rbx
   2bda4:	5d                   	pop    %rbp
   2bda5:	c3                   	retq   

000000000002bda6 <z_unpend_all>:
{
   2bda6:	55                   	push   %rbp
   2bda7:	53                   	push   %rbx
   2bda8:	48 89 fd             	mov    %rdi,%rbp
	int need_sched = 0;
   2bdab:	31 c0                	xor    %eax,%eax
{
   2bdad:	48 83 ec 08          	sub    $0x8,%rsp
	return list->head == list;
   2bdb1:	48 8b 5d 00          	mov    0x0(%rbp),%rbx
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   2bdb5:	48 85 db             	test   %rbx,%rbx
   2bdb8:	74 1c                	je     2bdd6 <z_unpend_all+0x30>
   2bdba:	48 39 dd             	cmp    %rbx,%rbp
   2bdbd:	74 17                	je     2bdd6 <z_unpend_all+0x30>
		z_unpend_thread(thread);
   2bdbf:	48 89 df             	mov    %rbx,%rdi
   2bdc2:	e8 54 f8 ff ff       	callq  2b61b <z_unpend_thread>
		z_ready_thread(thread);
   2bdc7:	48 89 df             	mov    %rbx,%rdi
   2bdca:	e8 c2 f9 ff ff       	callq  2b791 <z_ready_thread>
		need_sched = 1;
   2bdcf:	b8 01 00 00 00       	mov    $0x1,%eax
   2bdd4:	eb db                	jmp    2bdb1 <z_unpend_all+0xb>
}
   2bdd6:	5a                   	pop    %rdx
   2bdd7:	5b                   	pop    %rbx
   2bdd8:	5d                   	pop    %rbp
   2bdd9:	c3                   	retq   

000000000002bdda <z_sched_init>:
	list->head = (sys_dnode_t *)list;
   2bdda:	48 8d 05 5f bd 22 00 	lea    0x22bd5f(%rip),%rax        # 257b40 <_kernel>
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   2bde1:	31 f6                	xor    %esi,%esi
   2bde3:	31 ff                	xor    %edi,%edi
   2bde5:	48 8d 50 48          	lea    0x48(%rax),%rdx
   2bde9:	48 89 50 48          	mov    %rdx,0x48(%rax)
	list->tail = (sys_dnode_t *)list;
   2bded:	48 89 50 50          	mov    %rdx,0x50(%rax)
   2bdf1:	e9 b6 f6 ff ff       	jmpq   2b4ac <k_sched_time_slice_set>

000000000002bdf6 <z_impl_k_yield>:
{
   2bdf6:	41 55                	push   %r13
   2bdf8:	41 54                	push   %r12
   2bdfa:	55                   	push   %rbp
   2bdfb:	53                   	push   %rbx
   2bdfc:	48 83 ec 08          	sub    $0x8,%rsp
	if (!z_is_idle_thread_object(_current)) {
   2be00:	48 8d 1d 39 bd 22 00 	lea    0x22bd39(%rip),%rbx        # 257b40 <_kernel>
   2be07:	48 8d 05 f2 bb 22 00 	lea    0x22bbf2(%rip),%rax        # 257a00 <z_idle_threads>
   2be0e:	48 39 43 10          	cmp    %rax,0x10(%rbx)
   2be12:	0f 84 9b 00 00 00    	je     2beb3 <z_impl_k_yield+0xbd>
	return posix_irq_lock();
   2be18:	e8 75 01 fe ff       	callq  bf92 <posix_irq_lock>
				_priq_run_remove(&_kernel.ready_q.runq,
   2be1d:	48 8b 73 10          	mov    0x10(%rbx),%rsi
   2be21:	48 8d 7b 48          	lea    0x48(%rbx),%rdi
   2be25:	41 89 c5             	mov    %eax,%r13d
   2be28:	e8 af f7 ff ff       	callq  2b5dc <z_priq_dumb_remove>
	return list->head == list;
   2be2d:	48 8b 6b 48          	mov    0x48(%rbx),%rbp
			_priq_run_add(&_kernel.ready_q.runq, _current);
   2be31:	4c 8b 63 10          	mov    0x10(%rbx),%r12
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2be35:	48 85 ed             	test   %rbp,%rbp
   2be38:	74 09                	je     2be43 <z_impl_k_yield+0x4d>
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2be3a:	48 8d 43 48          	lea    0x48(%rbx),%rax
   2be3e:	48 39 c5             	cmp    %rax,%rbp
   2be41:	75 1e                	jne    2be61 <z_impl_k_yield+0x6b>
	node->next = list;
   2be43:	48 8d 43 48          	lea    0x48(%rbx),%rax
   2be47:	49 89 04 24          	mov    %rax,(%r12)
	node->prev = list->tail;
   2be4b:	48 8b 43 50          	mov    0x50(%rbx),%rax
   2be4f:	49 89 44 24 08       	mov    %rax,0x8(%r12)
	list->tail->next = node;
   2be54:	48 8b 43 50          	mov    0x50(%rbx),%rax
   2be58:	4c 89 20             	mov    %r12,(%rax)
	list->tail = node;
   2be5b:	4c 89 63 50          	mov    %r12,0x50(%rbx)
   2be5f:	eb 38                	jmp    2be99 <z_impl_k_yield+0xa3>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
   2be61:	48 89 ee             	mov    %rbp,%rsi
   2be64:	4c 89 e7             	mov    %r12,%rdi
   2be67:	e8 09 f6 ff ff       	callq  2b475 <z_is_t1_higher_prio_than_t2>
   2be6c:	84 c0                	test   %al,%al
   2be6e:	74 1a                	je     2be8a <z_impl_k_yield+0x94>
	node->prev = successor->prev;
   2be70:	48 8b 45 08          	mov    0x8(%rbp),%rax
	node->next = successor;
   2be74:	49 89 2c 24          	mov    %rbp,(%r12)
	node->prev = successor->prev;
   2be78:	49 89 44 24 08       	mov    %rax,0x8(%r12)
	successor->prev->next = node;
   2be7d:	48 8b 45 08          	mov    0x8(%rbp),%rax
   2be81:	4c 89 20             	mov    %r12,(%rax)
	successor->prev = node;
   2be84:	4c 89 65 08          	mov    %r12,0x8(%rbp)
   2be88:	eb 0f                	jmp    2be99 <z_impl_k_yield+0xa3>
	return (node == list->tail) ? NULL : node->next;
   2be8a:	48 39 6b 50          	cmp    %rbp,0x50(%rbx)
   2be8e:	74 b3                	je     2be43 <z_impl_k_yield+0x4d>
   2be90:	48 8b 6d 00          	mov    0x0(%rbp),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2be94:	48 85 ed             	test   %rbp,%rbp
   2be97:	eb a8                	jmp    2be41 <z_impl_k_yield+0x4b>
			z_mark_thread_as_queued(_current);
   2be99:	48 8b 43 10          	mov    0x10(%rbx),%rax
			update_cache(1);
   2be9d:	bf 01 00 00 00       	mov    $0x1,%edi
	thread->base.thread_state |= states;
   2bea2:	80 48 19 80          	orb    $0x80,0x19(%rax)
   2bea6:	e8 ab f7 ff ff       	callq  2b656 <update_cache>
	posix_irq_unlock(key);
   2beab:	44 89 ef             	mov    %r13d,%edi
   2beae:	e8 e9 00 fe ff       	callq  bf9c <posix_irq_unlock>
	return posix_irq_lock();
   2beb3:	e8 da 00 fe ff       	callq  bf92 <posix_irq_lock>
   2beb8:	89 c7                	mov    %eax,%edi
}
   2beba:	58                   	pop    %rax
   2bebb:	5b                   	pop    %rbx
   2bebc:	5d                   	pop    %rbp
   2bebd:	41 5c                	pop    %r12
   2bebf:	41 5d                	pop    %r13
   2bec1:	e9 b1 ea fd ff       	jmpq   a977 <arch_swap>

000000000002bec6 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
   2bec6:	53                   	push   %rbx
   2bec7:	48 89 fb             	mov    %rdi,%rbx

	__ASSERT(!arch_is_in_isr(), "");
	sys_trace_void(SYS_TRACE_ID_SLEEP);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   2beca:	48 ff c7             	inc    %rdi
   2becd:	75 14                	jne    2bee3 <z_impl_k_sleep+0x1d>
		k_thread_suspend(_current);
   2becf:	48 8d 05 6a bc 22 00 	lea    0x22bc6a(%rip),%rax        # 257b40 <_kernel>
   2bed6:	48 8b 78 10          	mov    0x10(%rax),%rdi
	z_impl_k_thread_suspend(thread);
   2beda:	e8 6f fa ff ff       	callq  2b94e <z_impl_k_thread_suspend>
		return (int32_t) K_TICKS_FOREVER;
   2bedf:	89 d8                	mov    %ebx,%eax
   2bee1:	eb 1b                	jmp    2befe <z_impl_k_sleep+0x38>
	if (ticks == 0) {
   2bee3:	48 85 db             	test   %rbx,%rbx
   2bee6:	75 0b                	jne    2bef3 <z_impl_k_sleep+0x2d>
	z_impl_k_yield();
   2bee8:	31 c0                	xor    %eax,%eax
   2beea:	e8 07 ff ff ff       	callq  2bdf6 <z_impl_k_yield>
		return 0;
   2beef:	31 c0                	xor    %eax,%eax
   2bef1:	eb 08                	jmp    2befb <z_impl_k_sleep+0x35>
   2bef3:	48 89 df             	mov    %rbx,%rdi
   2bef6:	e8 0d fd ff ff       	callq  2bc08 <z_tick_sleep.part.25>

	ticks = timeout.ticks;

	ticks = z_tick_sleep(ticks);
	sys_trace_end_call(SYS_TRACE_ID_SLEEP);
	return k_ticks_to_ms_floor64(ticks);
   2befb:	6b c0 0a             	imul   $0xa,%eax,%eax
}
   2befe:	5b                   	pop    %rbx
   2beff:	c3                   	retq   

000000000002bf00 <z_impl_k_current_get>:
	 * local interrupts when reading it.
	 */
	unsigned int k = arch_irq_lock();
#endif

	k_tid_t ret = _current_cpu->current;
   2bf00:	48 8d 05 39 bc 22 00 	lea    0x22bc39(%rip),%rax        # 257b40 <_kernel>

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
   2bf07:	48 8b 40 10          	mov    0x10(%rax),%rax
}
   2bf0b:	c3                   	retq   

000000000002bf0c <z_impl_k_sem_init>:
		      unsigned int limit)
{
	/*
	 * Limit cannot be zero and count cannot be greater than limit
	 */
	CHECKIF(limit == 0U || initial_count > limit) {
   2bf0c:	85 d2                	test   %edx,%edx
   2bf0e:	74 20                	je     2bf30 <z_impl_k_sem_init+0x24>
   2bf10:	39 f2                	cmp    %esi,%edx
   2bf12:	72 1c                	jb     2bf30 <z_impl_k_sem_init+0x24>
	sem->count = initial_count;
	sem->limit = limit;
	sys_trace_semaphore_init(sem);
	z_waitq_init(&sem->wait_q);
#if defined(CONFIG_POLL)
	sys_dlist_init(&sem->poll_events);
   2bf14:	48 8d 47 18          	lea    0x18(%rdi),%rax
	sem->count = initial_count;
   2bf18:	89 77 10             	mov    %esi,0x10(%rdi)
	sem->limit = limit;
   2bf1b:	89 57 14             	mov    %edx,0x14(%rdi)
	list->head = (sys_dnode_t *)list;
   2bf1e:	48 89 3f             	mov    %rdi,(%rdi)
	list->tail = (sys_dnode_t *)list;
   2bf21:	48 89 7f 08          	mov    %rdi,0x8(%rdi)
	list->head = (sys_dnode_t *)list;
   2bf25:	48 89 47 18          	mov    %rax,0x18(%rdi)
	list->tail = (sys_dnode_t *)list;
   2bf29:	48 89 47 20          	mov    %rax,0x20(%rdi)
	SYS_TRACING_OBJ_INIT(k_sem, sem);

	z_object_init(sem);
	sys_trace_end_call(SYS_TRACE_ID_SEMA_INIT);

	return 0;
   2bf2d:	31 c0                	xor    %eax,%eax
   2bf2f:	c3                   	retq   
		return -EINVAL;
   2bf30:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
   2bf35:	c3                   	retq   

000000000002bf36 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   2bf36:	55                   	push   %rbp
   2bf37:	53                   	push   %rbx
   2bf38:	48 89 fb             	mov    %rdi,%rbx
   2bf3b:	48 83 ec 08          	sub    $0x8,%rsp
   2bf3f:	e8 4e 00 fe ff       	callq  bf92 <posix_irq_lock>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	sys_trace_semaphore_give(sem);
	thread = z_unpend_first_thread(&sem->wait_q);
   2bf44:	48 89 df             	mov    %rbx,%rdi
   2bf47:	89 c5                	mov    %eax,%ebp
   2bf49:	e8 04 fe ff ff       	callq  2bd52 <z_unpend_first_thread>

	if (thread != NULL) {
   2bf4e:	48 85 c0             	test   %rax,%rax
   2bf51:	74 11                	je     2bf64 <z_impl_k_sem_give+0x2e>
   2bf53:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   2bf5a:	48 89 c7             	mov    %rax,%rdi
   2bf5d:	e8 2f f8 ff ff       	callq  2b791 <z_ready_thread>
   2bf62:	eb 1e                	jmp    2bf82 <z_impl_k_sem_give+0x4c>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   2bf64:	8b 53 10             	mov    0x10(%rbx),%edx
   2bf67:	31 c0                	xor    %eax,%eax
   2bf69:	39 53 14             	cmp    %edx,0x14(%rbx)
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   2bf6c:	48 8d 7b 18          	lea    0x18(%rbx),%rdi
   2bf70:	be 02 00 00 00       	mov    $0x2,%esi
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   2bf75:	0f 95 c0             	setne  %al
   2bf78:	01 d0                	add    %edx,%eax
   2bf7a:	89 43 10             	mov    %eax,0x10(%rbx)
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   2bf7d:	e8 17 0e 00 00       	callq  2cd99 <z_handle_obj_poll_events>
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
}
   2bf82:	58                   	pop    %rax
	z_reschedule(&lock, key);
   2bf83:	89 ee                	mov    %ebp,%esi
   2bf85:	48 8d 3d 69 31 23 00 	lea    0x233169(%rip),%rdi        # 25f0f5 <lock>
}
   2bf8c:	5b                   	pop    %rbx
   2bf8d:	5d                   	pop    %rbp
	z_reschedule(&lock, key);
   2bf8e:	e9 d7 f5 ff ff       	jmpq   2b56a <z_reschedule>

000000000002bf93 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   2bf93:	55                   	push   %rbp
   2bf94:	53                   	push   %rbx
   2bf95:	48 89 fb             	mov    %rdi,%rbx
   2bf98:	48 89 f5             	mov    %rsi,%rbp
   2bf9b:	48 83 ec 08          	sub    $0x8,%rsp
   2bf9f:	e8 ee ff fd ff       	callq  bf92 <posix_irq_lock>
		  K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");

	k_spinlock_key_t key = k_spin_lock(&lock);
	sys_trace_semaphore_take(sem);

	if (likely(sem->count > 0U)) {
   2bfa4:	44 8b 43 10          	mov    0x10(%rbx),%r8d
   2bfa8:	89 c7                	mov    %eax,%edi
   2bfaa:	45 85 c0             	test   %r8d,%r8d
   2bfad:	74 10                	je     2bfbf <z_impl_k_sem_take+0x2c>
		sem->count--;
   2bfaf:	41 ff c8             	dec    %r8d
   2bfb2:	44 89 43 10          	mov    %r8d,0x10(%rbx)
	posix_irq_unlock(key);
   2bfb6:	e8 e1 ff fd ff       	callq  bf9c <posix_irq_unlock>
		k_spin_unlock(&lock, key);
		ret = 0;
   2bfbb:	31 c0                	xor    %eax,%eax
		goto out;
   2bfbd:	eb 29                	jmp    2bfe8 <z_impl_k_sem_take+0x55>
	}

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2bfbf:	48 85 ed             	test   %rbp,%rbp
   2bfc2:	75 0c                	jne    2bfd0 <z_impl_k_sem_take+0x3d>
   2bfc4:	e8 d3 ff fd ff       	callq  bf9c <posix_irq_unlock>
		k_spin_unlock(&lock, key);
		ret = -EBUSY;
   2bfc9:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
		goto out;
   2bfce:	eb 18                	jmp    2bfe8 <z_impl_k_sem_take+0x55>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);

out:
	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
	return ret;
}
   2bfd0:	41 58                	pop    %r8
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   2bfd2:	48 89 e9             	mov    %rbp,%rcx
   2bfd5:	48 89 da             	mov    %rbx,%rdx
   2bfd8:	48 8d 3d 16 31 23 00 	lea    0x233116(%rip),%rdi        # 25f0f5 <lock>
}
   2bfdf:	5b                   	pop    %rbx
   2bfe0:	5d                   	pop    %rbp
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   2bfe1:	89 c6                	mov    %eax,%esi
   2bfe3:	e9 ff fb ff ff       	jmpq   2bbe7 <z_pend_curr>
}
   2bfe8:	5a                   	pop    %rdx
   2bfe9:	5b                   	pop    %rbx
   2bfea:	5d                   	pop    %rbp
   2bfeb:	c3                   	retq   

000000000002bfec <k_sys_work_q_init>:
K_KERNEL_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
   2bfec:	53                   	push   %rbx
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
   2bfed:	48 8d 1d ac bb 22 00 	lea    0x22bbac(%rip),%rbx        # 257ba0 <k_sys_work_q>
   2bff4:	83 c9 ff             	or     $0xffffffff,%ecx
   2bff7:	48 8d 35 92 dd 20 00 	lea    0x20dd92(%rip),%rsi        # 239d90 <sys_work_q_stack>
   2bffe:	ba 00 04 00 00       	mov    $0x400,%edx
   2c003:	48 89 df             	mov    %rbx,%rdi
   2c006:	e8 0f 03 00 00       	callq  2c31a <k_work_q_start>
	return z_impl_k_thread_name_set(thread_id, value);
   2c00b:	48 8d 35 fc 7f 00 00 	lea    0x7ffc(%rip),%rsi        # 3400e <_lv_bpp1_opa_table+0x7b9>
   2c012:	48 8d 7b 30          	lea    0x30(%rbx),%rdi
   2c016:	e8 12 00 00 00       	callq  2c02d <z_impl_k_thread_name_set>
		       K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
   2c01b:	31 c0                	xor    %eax,%eax
   2c01d:	5b                   	pop    %rbx
   2c01e:	c3                   	retq   

000000000002c01f <k_is_in_isr>:
	return _kernel.cpus[0].nested != 0U;
   2c01f:	48 8d 05 1a bb 22 00 	lea    0x22bb1a(%rip),%rax        # 257b40 <_kernel>
   2c026:	83 38 00             	cmpl   $0x0,(%rax)
   2c029:	0f 95 c0             	setne  %al
}

bool k_is_in_isr(void)
{
	return arch_is_in_isr();
}
   2c02c:	c3                   	retq   

000000000002c02d <z_impl_k_thread_name_set>:
#else
	ARG_UNUSED(thread);
	ARG_UNUSED(value);
	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
   2c02d:	b8 da ff ff ff       	mov    $0xffffffda,%eax
   2c032:	c3                   	retq   

000000000002c033 <k_thread_name_get>:
	return (const char *)thread->name;
#else
	ARG_UNUSED(thread);
	return NULL;
#endif /* CONFIG_THREAD_NAME */
}
   2c033:	31 c0                	xor    %eax,%eax
   2c035:	c3                   	retq   

000000000002c036 <z_impl_k_thread_start>:
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
	z_sched_start(thread);
   2c036:	e9 7d f7 ff ff       	jmpq   2b7b8 <z_sched_start>

000000000002c03b <z_init_thread_base>:
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (uint8_t)options;
   2c03b:	88 4f 18             	mov    %cl,0x18(%rdi)
	thread_base->thread_state = (uint8_t)initial_state;
   2c03e:	88 57 19             	mov    %dl,0x19(%rdi)

	thread_base->prio = priority;
   2c041:	40 88 77 1a          	mov    %sil,0x1a(%rdi)

	thread_base->sched_locked = 0U;
   2c045:	c6 47 1b 00          	movb   $0x0,0x1b(%rdi)
	node->next = NULL;
   2c049:	48 c7 47 28 00 00 00 	movq   $0x0,0x28(%rdi)
   2c050:	00 
	node->prev = NULL;
   2c051:	48 c7 47 30 00 00 00 	movq   $0x0,0x30(%rdi)
   2c058:	00 
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
   2c059:	c3                   	retq   

000000000002c05a <z_setup_new_thread>:
{
   2c05a:	41 55                	push   %r13
   2c05c:	41 54                	push   %r12
	sys_dlist_init(&w->waitq);
   2c05e:	48 8d 47 48          	lea    0x48(%rdi),%rax
   2c062:	55                   	push   %rbp
   2c063:	53                   	push   %rbx
   2c064:	49 89 f5             	mov    %rsi,%r13
   2c067:	49 89 cc             	mov    %rcx,%r12
   2c06a:	48 89 d5             	mov    %rdx,%rbp
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
   2c06d:	ba 04 00 00 00       	mov    $0x4,%edx
{
   2c072:	48 83 ec 18          	sub    $0x18,%rsp
	list->head = (sys_dnode_t *)list;
   2c076:	48 89 47 48          	mov    %rax,0x48(%rdi)
	list->tail = (sys_dnode_t *)list;
   2c07a:	48 89 47 50          	mov    %rax,0x50(%rdi)
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
   2c07e:	8b 4c 24 50          	mov    0x50(%rsp),%ecx
   2c082:	8b 74 24 48          	mov    0x48(%rsp),%esi
{
   2c086:	48 89 fb             	mov    %rdi,%rbx
   2c089:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
   2c08e:	4c 89 0c 24          	mov    %r9,(%rsp)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   2c092:	48 83 c5 07          	add    $0x7,%rbp
   2c096:	48 83 e5 f8          	and    $0xfffffffffffffff8,%rbp
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
   2c09a:	e8 9c ff ff ff       	callq  2c03b <z_init_thread_base>
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   2c09f:	48 83 ec 08          	sub    $0x8,%rsp
	stack_ptr = (char *)stack + stack_obj_size;
   2c0a3:	4c 01 ed             	add    %r13,%rbp
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   2c0a6:	4c 89 e1             	mov    %r12,%rcx
   2c0a9:	ff 74 24 48          	pushq  0x48(%rsp)
   2c0ad:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9
   2c0b2:	48 89 ea             	mov    %rbp,%rdx
   2c0b5:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
   2c0ba:	4c 89 ee             	mov    %r13,%rsi
   2c0bd:	48 89 df             	mov    %rbx,%rdi
   2c0c0:	e8 13 e9 fd ff       	callq  a9d8 <arch_new_thread>
   2c0c5:	58                   	pop    %rax
	if (!_current) {
   2c0c6:	48 8d 05 73 ba 22 00 	lea    0x22ba73(%rip),%rax        # 257b40 <_kernel>
	new_thread->init_data = NULL;
   2c0cd:	48 c7 43 68 00 00 00 	movq   $0x0,0x68(%rbx)
   2c0d4:	00 
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   2c0d5:	5a                   	pop    %rdx
	new_thread->fn_abort = NULL;
   2c0d6:	48 c7 43 70 00 00 00 	movq   $0x0,0x70(%rbx)
   2c0dd:	00 
	if (!_current) {
   2c0de:	48 8b 40 10          	mov    0x10(%rax),%rax
   2c0e2:	48 85 c0             	test   %rax,%rax
   2c0e5:	75 0d                	jne    2c0f4 <z_setup_new_thread+0x9a>
		new_thread->resource_pool = NULL;
   2c0e7:	48 c7 83 80 00 00 00 	movq   $0x0,0x80(%rbx)
   2c0ee:	00 00 00 00 
		return stack_ptr;
   2c0f2:	eb 0e                	jmp    2c102 <z_setup_new_thread+0xa8>
	new_thread->resource_pool = _current->resource_pool;
   2c0f4:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
   2c0fb:	48 89 83 80 00 00 00 	mov    %rax,0x80(%rbx)
}
   2c102:	48 83 c4 18          	add    $0x18,%rsp
   2c106:	48 89 e8             	mov    %rbp,%rax
   2c109:	5b                   	pop    %rbx
   2c10a:	5d                   	pop    %rbp
   2c10b:	41 5c                	pop    %r12
   2c10d:	41 5d                	pop    %r13
   2c10f:	c3                   	retq   

000000000002c110 <z_impl_k_thread_create>:
{
   2c110:	55                   	push   %rbp
   2c111:	53                   	push   %rbx
   2c112:	48 89 fb             	mov    %rdi,%rbx
   2c115:	48 83 ec 08          	sub    $0x8,%rsp
   2c119:	48 8b 6c 24 38       	mov    0x38(%rsp),%rbp
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   2c11e:	6a 00                	pushq  $0x0
   2c120:	8b 44 24 38          	mov    0x38(%rsp),%eax
   2c124:	50                   	push   %rax
   2c125:	8b 44 24 38          	mov    0x38(%rsp),%eax
   2c129:	50                   	push   %rax
   2c12a:	ff 74 24 38          	pushq  0x38(%rsp)
   2c12e:	e8 27 ff ff ff       	callq  2c05a <z_setup_new_thread>
   2c133:	48 83 c4 20          	add    $0x20,%rsp
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   2c137:	48 83 fd ff          	cmp    $0xffffffffffffffff,%rbp
   2c13b:	74 22                	je     2c15f <z_impl_k_thread_create+0x4f>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   2c13d:	48 85 ed             	test   %rbp,%rbp
   2c140:	75 0a                	jne    2c14c <z_impl_k_thread_create+0x3c>
	z_impl_k_thread_start(thread);
   2c142:	48 89 df             	mov    %rbx,%rdi
   2c145:	e8 ec fe ff ff       	callq  2c036 <z_impl_k_thread_start>
   2c14a:	eb 13                	jmp    2c15f <z_impl_k_thread_create+0x4f>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   2c14c:	48 8d 35 ad f6 ff ff 	lea    -0x953(%rip),%rsi        # 2b800 <z_thread_timeout>
   2c153:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
   2c157:	48 89 ea             	mov    %rbp,%rdx
   2c15a:	e8 a8 03 00 00       	callq  2c507 <z_add_timeout>
}
   2c15f:	48 89 d8             	mov    %rbx,%rax
   2c162:	5a                   	pop    %rdx
   2c163:	5b                   	pop    %rbx
   2c164:	5d                   	pop    %rbp
   2c165:	c3                   	retq   

000000000002c166 <z_init_static_threads>:
{
   2c166:	55                   	push   %rbp
   2c167:	53                   	push   %rbx
   2c168:	48 83 ec 08          	sub    $0x8,%rsp
	_FOREACH_STATIC_THREAD(thread_data) {
   2c16c:	48 8d 1d a1 e3 20 00 	lea    0x20e3a1(%rip),%rbx        # 23a514 <__device_init_status_end>
   2c173:	48 89 dd             	mov    %rbx,%rbp
   2c176:	48 3b 1d eb 9d 20 00 	cmp    0x209deb(%rip),%rbx        # 235f68 <_GLOBAL_OFFSET_TABLE_+0x288>
   2c17d:	73 3a                	jae    2c1b9 <z_init_static_threads+0x53>
		z_setup_new_thread(
   2c17f:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
   2c183:	8b 53 10             	mov    0x10(%rbx),%edx
   2c186:	48 8b 73 08          	mov    0x8(%rbx),%rsi
   2c18a:	ff 73 50             	pushq  0x50(%rbx)
   2c18d:	8b 43 3c             	mov    0x3c(%rbx),%eax
   2c190:	50                   	push   %rax
   2c191:	8b 43 38             	mov    0x38(%rbx),%eax
   2c194:	50                   	push   %rax
   2c195:	ff 73 30             	pushq  0x30(%rbx)
   2c198:	4c 8b 4b 28          	mov    0x28(%rbx),%r9
   2c19c:	4c 8b 43 20          	mov    0x20(%rbx),%r8
   2c1a0:	48 8b 3b             	mov    (%rbx),%rdi
   2c1a3:	e8 b2 fe ff ff       	callq  2c05a <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   2c1a8:	48 8b 03             	mov    (%rbx),%rax
		z_setup_new_thread(
   2c1ab:	48 83 c4 20          	add    $0x20,%rsp
		thread_data->init_thread->init_data = thread_data;
   2c1af:	48 89 58 68          	mov    %rbx,0x68(%rax)
	_FOREACH_STATIC_THREAD(thread_data) {
   2c1b3:	48 83 c3 58          	add    $0x58,%rbx
   2c1b7:	eb bd                	jmp    2c176 <z_init_static_threads+0x10>
					    K_MSEC(thread_data->init_delay));
   2c1b9:	31 db                	xor    %ebx,%ebx
	k_sched_lock();
   2c1bb:	e8 fd f3 ff ff       	callq  2b5bd <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   2c1c0:	48 3b 2d a1 9d 20 00 	cmp    0x209da1(%rip),%rbp        # 235f68 <_GLOBAL_OFFSET_TABLE_+0x288>
   2c1c7:	73 46                	jae    2c20f <z_init_static_threads+0xa9>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   2c1c9:	48 63 45 40          	movslq 0x40(%rbp),%rax
   2c1cd:	83 f8 ff             	cmp    $0xffffffff,%eax
   2c1d0:	74 37                	je     2c209 <z_init_static_threads+0xa3>
					    K_MSEC(thread_data->init_delay));
   2c1d2:	85 c0                	test   %eax,%eax
   2c1d4:	b9 0a 00 00 00       	mov    $0xa,%ecx
			schedule_new_thread(thread_data->init_thread,
   2c1d9:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
					    K_MSEC(thread_data->init_delay));
   2c1dd:	48 0f 48 c3          	cmovs  %rbx,%rax
   2c1e1:	31 d2                	xor    %edx,%edx
		t += off;
   2c1e3:	48 83 c0 09          	add    $0x9,%rax
			return t / (from_hz / to_hz);
   2c1e7:	48 f7 f1             	div    %rcx
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   2c1ea:	48 85 c0             	test   %rax,%rax
   2c1ed:	75 07                	jne    2c1f6 <z_init_static_threads+0x90>
   2c1ef:	e8 42 fe ff ff       	callq  2c036 <z_impl_k_thread_start>
   2c1f4:	eb 13                	jmp    2c209 <z_init_static_threads+0xa3>
   2c1f6:	48 8d 35 03 f6 ff ff 	lea    -0x9fd(%rip),%rsi        # 2b800 <z_thread_timeout>
   2c1fd:	48 83 c7 28          	add    $0x28,%rdi
   2c201:	48 89 c2             	mov    %rax,%rdx
   2c204:	e8 fe 02 00 00       	callq  2c507 <z_add_timeout>
	_FOREACH_STATIC_THREAD(thread_data) {
   2c209:	48 83 c5 58          	add    $0x58,%rbp
   2c20d:	eb b1                	jmp    2c1c0 <z_init_static_threads+0x5a>
}
   2c20f:	58                   	pop    %rax
   2c210:	5b                   	pop    %rbx
   2c211:	5d                   	pop    %rbp
	k_sched_unlock();
   2c212:	e9 a9 f4 ff ff       	jmpq   2b6c0 <k_sched_unlock>

000000000002c217 <z_self_abort>:
#include <syscall_handler.h>
#include <logging/log.h>
LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

FUNC_NORETURN void z_self_abort(void)
{
   2c217:	53                   	push   %rbx
	return posix_irq_lock();
   2c218:	e8 75 fd fd ff       	callq  bf92 <posix_irq_lock>
	 * while we set this up
	 */
	key = arch_irq_lock();
	cpu = _current_cpu;
	__ASSERT(cpu->pending_abort == NULL, "already have a thread to abort");
	cpu->pending_abort = _current;
   2c21d:	48 8d 15 1c b9 22 00 	lea    0x22b91c(%rip),%rdx        # 257b40 <_kernel>
   2c224:	89 c3                	mov    %eax,%ebx
   2c226:	48 8b 7a 10          	mov    0x10(%rdx),%rdi
   2c22a:	48 89 7a 20          	mov    %rdi,0x20(%rdx)
	z_impl_k_thread_suspend(thread);
   2c22e:	e8 1b f7 ff ff       	callq  2b94e <z_impl_k_thread_suspend>
   2c233:	89 df                	mov    %ebx,%edi
   2c235:	e8 3d e7 fd ff       	callq  a977 <arch_swap>
		_current, cpu->idle_thread);

	k_thread_suspend(_current);
	z_swap_irqlock(key);
	__ASSERT(false, "should never get here");
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   2c23a:	48 8d 35 d6 7d 00 00 	lea    0x7dd6(%rip),%rsi        # 34017 <_lv_bpp1_opa_table+0x7c2>
   2c241:	48 8d 3d 0a 4f 00 00 	lea    0x4f0a(%rip),%rdi        # 31152 <__func__.5785+0x4ea>
   2c248:	ba 31 00 00 00       	mov    $0x31,%edx
   2c24d:	31 c0                	xor    %eax,%eax
   2c24f:	e8 6e 00 fe ff       	callq  c2c2 <posix_print_error_and_exit>

000000000002c254 <k_work_submit_to_queue>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2c254:	8b 46 10             	mov    0x10(%rsi),%eax
   2c257:	89 c1                	mov    %eax,%ecx
   2c259:	89 c2                	mov    %eax,%edx
   2c25b:	83 c9 01             	or     $0x1,%ecx
   2c25e:	f0 0f b1 4e 10       	lock cmpxchg %ecx,0x10(%rsi)
   2c263:	75 f2                	jne    2c257 <k_work_submit_to_queue+0x3>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   2c265:	80 e2 01             	and    $0x1,%dl
   2c268:	75 05                	jne    2c26f <k_work_submit_to_queue+0x1b>
		k_queue_append(&work_q->queue, work);
   2c26a:	e9 bc f0 ff ff       	jmpq   2b32b <k_queue_append>
}
   2c26f:	c3                   	retq   

000000000002c270 <work_timeout>:
{
	struct k_delayed_work *w = CONTAINER_OF(t, struct k_delayed_work,
						   timeout);

	/* submit work to workqueue */
	k_work_submit_to_queue(w->work_q, &w->work);
   2c270:	48 8d 77 e8          	lea    -0x18(%rdi),%rsi
   2c274:	48 8b 7f 20          	mov    0x20(%rdi),%rdi
   2c278:	e9 d7 ff ff ff       	jmpq   2c254 <k_work_submit_to_queue>

000000000002c27d <work_cancel>:
}

static int work_cancel(struct k_delayed_work *work)
{
   2c27d:	55                   	push   %rbp
   2c27e:	53                   	push   %rbx
	return atomic_test_bit(work->flags, K_WORK_STATE_PENDING);
   2c27f:	48 8d 6f 10          	lea    0x10(%rdi),%rbp
   2c283:	48 89 fb             	mov    %rdi,%rbx
   2c286:	48 83 ec 08          	sub    $0x8,%rsp
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2c28a:	8b 47 10             	mov    0x10(%rdi),%eax
	if (k_work_pending(&work->work)) {
   2c28d:	a8 01                	test   $0x1,%al
   2c28f:	74 62                	je     2c2f3 <work_cancel+0x76>
		/* Remove from the queue if already submitted */
		if (!k_queue_remove(&work->work_q->queue, &work->work)) {
   2c291:	48 8b 57 38          	mov    0x38(%rdi),%rdx
 * @return true if node was removed
 */
static inline bool sys_sflist_find_and_remove(sys_sflist_t *list,
					      sys_sfnode_t *node);

Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   2c295:	31 c9                	xor    %ecx,%ecx
   2c297:	48 8b 02             	mov    (%rdx),%rax
   2c29a:	48 85 c0             	test   %rax,%rax
   2c29d:	74 4d                	je     2c2ec <work_cancel+0x6f>
   2c29f:	48 39 c3             	cmp    %rax,%rbx
   2c2a2:	75 39                	jne    2c2dd <work_cancel+0x60>
   2c2a4:	48 8b 33             	mov    (%rbx),%rsi
   2c2a7:	48 8b 7a 08          	mov    0x8(%rdx),%rdi
   2c2ab:	48 83 e6 fc          	and    $0xfffffffffffffffc,%rsi
Z_GENLIST_REMOVE(sflist, sfnode)
   2c2af:	48 85 c9             	test   %rcx,%rcx
   2c2b2:	75 0e                	jne    2c2c2 <work_cancel+0x45>
   2c2b4:	48 39 fb             	cmp    %rdi,%rbx
	list->head = node;
   2c2b7:	48 89 32             	mov    %rsi,(%rdx)
Z_GENLIST_REMOVE(sflist, sfnode)
   2c2ba:	75 1b                	jne    2c2d7 <work_cancel+0x5a>
	list->tail = node;
   2c2bc:	48 89 72 08          	mov    %rsi,0x8(%rdx)
   2c2c0:	eb 15                	jmp    2c2d7 <work_cancel+0x5a>
	parent->next_and_flags = cur_flags | (unative_t)child;
   2c2c2:	48 8b 01             	mov    (%rcx),%rax
   2c2c5:	83 e0 03             	and    $0x3,%eax
   2c2c8:	48 09 f0             	or     %rsi,%rax
Z_GENLIST_REMOVE(sflist, sfnode)
   2c2cb:	48 39 fb             	cmp    %rdi,%rbx
	parent->next_and_flags = cur_flags | (unative_t)child;
   2c2ce:	48 89 01             	mov    %rax,(%rcx)
Z_GENLIST_REMOVE(sflist, sfnode)
   2c2d1:	75 04                	jne    2c2d7 <work_cancel+0x5a>
	list->tail = node;
   2c2d3:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
	parent->next_and_flags = cur_flags | (unative_t)child;
   2c2d7:	48 83 23 03          	andq   $0x3,(%rbx)
   2c2db:	eb 28                	jmp    2c305 <work_cancel+0x88>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   2c2dd:	48 8b 30             	mov    (%rax),%rsi
Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   2c2e0:	48 89 c1             	mov    %rax,%rcx
   2c2e3:	48 89 f0             	mov    %rsi,%rax
   2c2e6:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
   2c2ea:	eb ae                	jmp    2c29a <work_cancel+0x1d>
			return -EINVAL;
   2c2ec:	ba ea ff ff ff       	mov    $0xffffffea,%edx
   2c2f1:	eb 21                	jmp    2c314 <work_cancel+0x97>
		}
	} else {
		int err = z_abort_timeout(&work->timeout);
   2c2f3:	48 8d 7f 18          	lea    0x18(%rdi),%rdi
   2c2f7:	e8 2c 03 00 00       	callq  2c628 <z_abort_timeout>

		if (err) {
   2c2fc:	85 c0                	test   %eax,%eax
			return -EALREADY;
   2c2fe:	ba 8e ff ff ff       	mov    $0xffffff8e,%edx
		if (err) {
   2c303:	75 0f                	jne    2c314 <work_cancel+0x97>
		}
	}

	/* Detach from workqueue */
	work->work_q = NULL;
   2c305:	48 c7 43 38 00 00 00 	movq   $0x0,0x38(%rbx)
   2c30c:	00 
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2c30d:	f0 83 65 00 fe       	lock andl $0xfffffffe,0x0(%rbp)

	atomic_clear_bit(work->work.flags, K_WORK_STATE_PENDING);

	return 0;
   2c312:	31 d2                	xor    %edx,%edx
}
   2c314:	89 d0                	mov    %edx,%eax
   2c316:	5a                   	pop    %rdx
   2c317:	5b                   	pop    %rbx
   2c318:	5d                   	pop    %rbp
   2c319:	c3                   	retq   

000000000002c31a <k_work_q_start>:
{
   2c31a:	55                   	push   %rbp
   2c31b:	53                   	push   %rbx
   2c31c:	89 cd                	mov    %ecx,%ebp
   2c31e:	48 83 ec 28          	sub    $0x28,%rsp
   2c322:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
   2c327:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
	z_impl_k_queue_init(queue);
   2c32c:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
   2c331:	e8 cd ef ff ff       	callq  2b303 <z_impl_k_queue_init>
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
   2c336:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
   2c33b:	49 8d 58 30          	lea    0x30(%r8),%rbx
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   2c33f:	48 8d 0d 4d 98 fd ff 	lea    -0x267b3(%rip),%rcx        # 5b93 <z_work_q_main>
   2c346:	6a 00                	pushq  $0x0
   2c348:	45 31 c9             	xor    %r9d,%r9d
   2c34b:	6a 00                	pushq  $0x0
   2c34d:	55                   	push   %rbp
   2c34e:	48 89 df             	mov    %rbx,%rdi
   2c351:	6a 00                	pushq  $0x0
   2c353:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
   2c358:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
   2c35d:	e8 ae fd ff ff       	callq  2c110 <z_impl_k_thread_create>
}
   2c362:	48 83 c4 48          	add    $0x48,%rsp
	return z_impl_k_thread_name_set(thread_id, value);
   2c366:	48 89 df             	mov    %rbx,%rdi
   2c369:	48 8d 35 cf 7c 00 00 	lea    0x7ccf(%rip),%rsi        # 3403f <_lv_bpp1_opa_table+0x7ea>
   2c370:	5b                   	pop    %rbx
   2c371:	5d                   	pop    %rbp
   2c372:	e9 b6 fc ff ff       	jmpq   2c02d <z_impl_k_thread_name_set>

000000000002c377 <k_delayed_work_submit_to_queue>:

int k_delayed_work_submit_to_queue(struct k_work_q *work_q,
				   struct k_delayed_work *work,
				   k_timeout_t delay)
{
   2c377:	41 56                	push   %r14
   2c379:	41 55                	push   %r13
   2c37b:	49 89 d6             	mov    %rdx,%r14
   2c37e:	41 54                	push   %r12
   2c380:	55                   	push   %rbp
   2c381:	49 89 fc             	mov    %rdi,%r12
   2c384:	53                   	push   %rbx
   2c385:	48 89 f3             	mov    %rsi,%rbx
   2c388:	e8 05 fc fd ff       	callq  bf92 <posix_irq_lock>
   2c38d:	41 89 c5             	mov    %eax,%r13d
	k_spinlock_key_t key = k_spin_lock(&lock);
	int err = 0;

	/* Work cannot be active in multiple queues */
	if (work->work_q != NULL && work->work_q != work_q) {
   2c390:	48 8b 43 38          	mov    0x38(%rbx),%rax
   2c394:	48 85 c0             	test   %rax,%rax
   2c397:	74 0c                	je     2c3a5 <k_delayed_work_submit_to_queue+0x2e>
   2c399:	4c 39 e0             	cmp    %r12,%rax
		err = -EADDRINUSE;
   2c39c:	bd 9e ff ff ff       	mov    $0xffffff9e,%ebp
	if (work->work_q != NULL && work->work_q != work_q) {
   2c3a1:	75 51                	jne    2c3f4 <k_delayed_work_submit_to_queue+0x7d>
   2c3a3:	eb 09                	jmp    2c3ae <k_delayed_work_submit_to_queue+0x37>
		goto done;
	}

	/* Cancel if work has been submitted */
	if (work->work_q == work_q) {
   2c3a5:	4d 85 e4             	test   %r12,%r12
   2c3a8:	74 04                	je     2c3ae <k_delayed_work_submit_to_queue+0x37>
	int err = 0;
   2c3aa:	31 ed                	xor    %ebp,%ebp
   2c3ac:	eb 13                	jmp    2c3c1 <k_delayed_work_submit_to_queue+0x4a>
		err = work_cancel(work);
   2c3ae:	48 89 df             	mov    %rbx,%rdi
   2c3b1:	e8 c7 fe ff ff       	callq  2c27d <work_cancel>
		/* -EALREADY may indicate the work has already completed so
		 * this is likely a recurring work.  It may also indicate that
		 * the work handler is still executing.  But it's neither
		 * delayed nor pending, so it can be rescheduled.
		 */
		if (err == -EALREADY) {
   2c3b6:	83 f8 8e             	cmp    $0xffffff8e,%eax
		err = work_cancel(work);
   2c3b9:	89 c5                	mov    %eax,%ebp
		if (err == -EALREADY) {
   2c3bb:	74 ed                	je     2c3aa <k_delayed_work_submit_to_queue+0x33>
			err = 0;
		} else if (err < 0) {
   2c3bd:	85 c0                	test   %eax,%eax
   2c3bf:	78 33                	js     2c3f4 <k_delayed_work_submit_to_queue+0x7d>
	work->work_q = work_q;

	/* Submit work directly if no delay.  Note that this is a
	 * blocking operation, so release the lock first.
	 */
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   2c3c1:	4d 85 f6             	test   %r14,%r14
	work->work_q = work_q;
   2c3c4:	4c 89 63 38          	mov    %r12,0x38(%rbx)
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   2c3c8:	75 17                	jne    2c3e1 <k_delayed_work_submit_to_queue+0x6a>
	posix_irq_unlock(key);
   2c3ca:	44 89 ef             	mov    %r13d,%edi
		k_spin_unlock(&lock, key);
		k_work_submit_to_queue(work_q, &work->work);
		return 0;
   2c3cd:	31 ed                	xor    %ebp,%ebp
   2c3cf:	e8 c8 fb fd ff       	callq  bf9c <posix_irq_unlock>
		k_work_submit_to_queue(work_q, &work->work);
   2c3d4:	48 89 de             	mov    %rbx,%rsi
   2c3d7:	4c 89 e7             	mov    %r12,%rdi
   2c3da:	e8 75 fe ff ff       	callq  2c254 <k_work_submit_to_queue>
		return 0;
   2c3df:	eb 1b                	jmp    2c3fc <k_delayed_work_submit_to_queue+0x85>
	}

	/* Add timeout */
	z_add_timeout(&work->timeout, work_timeout, delay);
   2c3e1:	48 8d 7b 18          	lea    0x18(%rbx),%rdi
   2c3e5:	48 8d 35 84 fe ff ff 	lea    -0x17c(%rip),%rsi        # 2c270 <work_timeout>
   2c3ec:	4c 89 f2             	mov    %r14,%rdx
   2c3ef:	e8 13 01 00 00       	callq  2c507 <z_add_timeout>
   2c3f4:	44 89 ef             	mov    %r13d,%edi
   2c3f7:	e8 a0 fb fd ff       	callq  bf9c <posix_irq_unlock>

done:
	k_spin_unlock(&lock, key);
	return err;
}
   2c3fc:	5b                   	pop    %rbx
   2c3fd:	89 e8                	mov    %ebp,%eax
   2c3ff:	5d                   	pop    %rbp
   2c400:	41 5c                	pop    %r12
   2c402:	41 5d                	pop    %r13
   2c404:	41 5e                	pop    %r14
   2c406:	c3                   	retq   

000000000002c407 <k_delayed_work_cancel>:

int k_delayed_work_cancel(struct k_delayed_work *work)
{
   2c407:	53                   	push   %rbx
   2c408:	48 83 ec 10          	sub    $0x10,%rsp
   2c40c:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
   2c411:	e8 7c fb fd ff       	callq  bf92 <posix_irq_lock>
	k_spinlock_key_t key = k_spin_lock(&lock);
	int ret = -EINVAL;

	if (work->work_q != NULL) {
   2c416:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   2c41b:	89 c3                	mov    %eax,%ebx
   2c41d:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   2c422:	48 83 7f 38 00       	cmpq   $0x0,0x38(%rdi)
   2c427:	74 05                	je     2c42e <k_delayed_work_cancel+0x27>
		ret = work_cancel(work);
   2c429:	e8 4f fe ff ff       	callq  2c27d <work_cancel>
	posix_irq_unlock(key);
   2c42e:	89 df                	mov    %ebx,%edi
   2c430:	89 44 24 08          	mov    %eax,0x8(%rsp)
   2c434:	e8 63 fb fd ff       	callq  bf9c <posix_irq_unlock>
	}

	k_spin_unlock(&lock, key);
	return ret;
}
   2c439:	8b 44 24 08          	mov    0x8(%rsp),%eax
   2c43d:	48 83 c4 10          	add    $0x10,%rsp
   2c441:	5b                   	pop    %rbx
   2c442:	c3                   	retq   

000000000002c443 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
   2c443:	48 8d 15 37 5c 00 00 	lea    0x5c37(%rip),%rdx        # 32081 <__func__.5785+0x1419>
   2c44a:	48 8d 35 f8 7b 00 00 	lea    0x7bf8(%rip),%rsi        # 34049 <_lv_bpp1_opa_table+0x7f4>
   2c451:	48 8d 3d 0d 7c 00 00 	lea    0x7c0d(%rip),%rdi        # 34065 <_lv_bpp1_opa_table+0x810>
   2c458:	31 c0                	xor    %eax,%eax
   2c45a:	e9 31 95 fd ff       	jmpq   5990 <printk>

000000000002c45f <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0U;
   2c45f:	83 3d 5e 2c 23 00 00 	cmpl   $0x0,0x232c5e(%rip)        # 25f0c4 <announce_remaining>
   2c466:	75 05                	jne    2c46d <elapsed+0xe>
   2c468:	e9 26 cf fd ff       	jmpq   9393 <z_clock_elapsed>
}
   2c46d:	31 c0                	xor    %eax,%eax
   2c46f:	c3                   	retq   

000000000002c470 <next_timeout>:

static int32_t next_timeout(void)
{
   2c470:	53                   	push   %rbx
	return list->head == list;
   2c471:	48 8b 1d b8 a5 20 00 	mov    0x20a5b8(%rip),%rbx        # 236a30 <timeout_list>
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2c478:	48 8d 05 b1 a5 20 00 	lea    0x20a5b1(%rip),%rax        # 236a30 <timeout_list>
   2c47f:	48 39 c3             	cmp    %rax,%rbx
   2c482:	75 02                	jne    2c486 <next_timeout+0x16>
   2c484:	31 db                	xor    %ebx,%ebx
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
   2c486:	e8 d4 ff ff ff       	callq  2c45f <elapsed>
	int32_t ret = to == NULL ? MAX_WAIT
   2c48b:	48 85 db             	test   %rbx,%rbx
   2c48e:	ba ff ff ff 7f       	mov    $0x7fffffff,%edx
   2c493:	74 20                	je     2c4b5 <next_timeout+0x45>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
   2c495:	48 63 d0             	movslq %eax,%rdx
   2c498:	48 8b 43 18          	mov    0x18(%rbx),%rax
   2c49c:	48 29 d0             	sub    %rdx,%rax
	int32_t ret = to == NULL ? MAX_WAIT
   2c49f:	31 d2                	xor    %edx,%edx
   2c4a1:	48 85 c0             	test   %rax,%rax
   2c4a4:	7e 0f                	jle    2c4b5 <next_timeout+0x45>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
   2c4a6:	48 3d ff ff ff 7f    	cmp    $0x7fffffff,%rax
	int32_t ret = to == NULL ? MAX_WAIT
   2c4ac:	ba ff ff ff 7f       	mov    $0x7fffffff,%edx
   2c4b1:	48 0f 4e d0          	cmovle %rax,%rdx

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   2c4b5:	48 8d 05 84 b6 22 00 	lea    0x22b684(%rip),%rax        # 257b40 <_kernel>
   2c4bc:	8b 40 28             	mov    0x28(%rax),%eax
   2c4bf:	85 c0                	test   %eax,%eax
   2c4c1:	74 04                	je     2c4c7 <next_timeout+0x57>
   2c4c3:	39 d0                	cmp    %edx,%eax
   2c4c5:	7c 02                	jl     2c4c9 <next_timeout+0x59>
   2c4c7:	89 d0                	mov    %edx,%eax
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   2c4c9:	5b                   	pop    %rbx
   2c4ca:	c3                   	retq   

000000000002c4cb <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   2c4cb:	48 85 ff             	test   %rdi,%rdi
   2c4ce:	48 8b 07             	mov    (%rdi),%rax
   2c4d1:	74 16                	je     2c4e9 <remove_timeout+0x1e>
	return (node == list->tail) ? NULL : node->next;
   2c4d3:	48 3b 3d 5e a5 20 00 	cmp    0x20a55e(%rip),%rdi        # 236a38 <timeout_list+0x8>
   2c4da:	74 0d                	je     2c4e9 <remove_timeout+0x1e>
	if (next(t) != NULL) {
   2c4dc:	48 85 c0             	test   %rax,%rax
   2c4df:	74 08                	je     2c4e9 <remove_timeout+0x1e>
		next(t)->dticks += t->dticks;
   2c4e1:	48 8b 57 18          	mov    0x18(%rdi),%rdx
   2c4e5:	48 01 50 18          	add    %rdx,0x18(%rax)
	node->prev->next = node->next;
   2c4e9:	48 8b 57 08          	mov    0x8(%rdi),%rdx
   2c4ed:	48 89 02             	mov    %rax,(%rdx)
	node->next->prev = node->prev;
   2c4f0:	48 8b 07             	mov    (%rdi),%rax
   2c4f3:	48 89 50 08          	mov    %rdx,0x8(%rax)
	node->next = NULL;
   2c4f7:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
	node->prev = NULL;
   2c4fe:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
   2c505:	00 
}
   2c506:	c3                   	retq   

000000000002c507 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   2c507:	48 83 fa ff          	cmp    $0xffffffffffffffff,%rdx
   2c50b:	0f 84 16 01 00 00    	je     2c627 <z_add_timeout+0x120>
{
   2c511:	41 55                	push   %r13
   2c513:	41 54                	push   %r12
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	k_ticks_t ticks = timeout.ticks + 1;

	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
   2c515:	49 c7 c4 fe ff ff ff 	mov    $0xfffffffffffffffe,%r12
{
   2c51c:	55                   	push   %rbp
	k_ticks_t ticks = timeout.ticks + 1;
   2c51d:	48 8d 6a 01          	lea    0x1(%rdx),%rbp
{
   2c521:	53                   	push   %rbx
   2c522:	49 89 f5             	mov    %rsi,%r13
   2c525:	48 89 fb             	mov    %rdi,%rbx
   2c528:	48 83 ec 08          	sub    $0x8,%rsp
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
   2c52c:	49 39 ec             	cmp    %rbp,%r12
   2c52f:	78 17                	js     2c548 <z_add_timeout+0x41>
		ticks = Z_TICK_ABS(ticks) - (curr_tick + elapsed());
   2c531:	e8 29 ff ff ff       	callq  2c45f <elapsed>
   2c536:	4c 2b 25 0b bb 22 00 	sub    0x22bb0b(%rip),%r12        # 258048 <curr_tick>
   2c53d:	48 98                	cltq   
   2c53f:	49 29 ec             	sub    %rbp,%r12
   2c542:	4c 89 e5             	mov    %r12,%rbp
   2c545:	48 29 c5             	sub    %rax,%rbp
	}

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   2c548:	4c 89 6b 10          	mov    %r13,0x10(%rbx)
	return posix_irq_lock();
   2c54c:	e8 41 fa fd ff       	callq  bf92 <posix_irq_lock>
   2c551:	41 89 c4             	mov    %eax,%r12d
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
   2c554:	e8 06 ff ff ff       	callq  2c45f <elapsed>
	ticks = MAX(1, ticks);
   2c559:	48 85 ed             	test   %rbp,%rbp
   2c55c:	ba 01 00 00 00       	mov    $0x1,%edx
		to->dticks = ticks + elapsed();
   2c561:	48 98                	cltq   
	ticks = MAX(1, ticks);
   2c563:	48 0f 4e ea          	cmovle %rdx,%rbp
	return list->head == list;
   2c567:	48 8d 15 c2 a4 20 00 	lea    0x20a4c2(%rip),%rdx        # 236a30 <timeout_list>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   2c56e:	48 8b 3d c3 a4 20 00 	mov    0x20a4c3(%rip),%rdi        # 236a38 <timeout_list+0x8>
		to->dticks = ticks + elapsed();
   2c575:	48 01 c5             	add    %rax,%rbp
	return list->head == list;
   2c578:	48 8b 05 b1 a4 20 00 	mov    0x20a4b1(%rip),%rax        # 236a30 <timeout_list>
   2c57f:	48 89 6b 18          	mov    %rbp,0x18(%rbx)
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2c583:	48 39 d0             	cmp    %rdx,%rax
   2c586:	74 42                	je     2c5ca <z_add_timeout+0xc3>
		for (t = first(); t != NULL; t = next(t)) {
   2c588:	48 85 c0             	test   %rax,%rax
   2c58b:	74 3d                	je     2c5ca <z_add_timeout+0xc3>
			if (t->dticks > to->dticks) {
   2c58d:	48 8b 70 18          	mov    0x18(%rax),%rsi
   2c591:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
   2c595:	48 39 ce             	cmp    %rcx,%rsi
   2c598:	7e 1f                	jle    2c5b9 <z_add_timeout+0xb2>
				t->dticks -= to->dticks;
   2c59a:	48 29 ce             	sub    %rcx,%rsi
	node->prev = successor->prev;
   2c59d:	48 8b 48 08          	mov    0x8(%rax),%rcx
   2c5a1:	48 89 70 18          	mov    %rsi,0x18(%rax)
	node->next = successor;
   2c5a5:	48 89 03             	mov    %rax,(%rbx)
	node->prev = successor->prev;
   2c5a8:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
	successor->prev->next = node;
   2c5ac:	48 8b 48 08          	mov    0x8(%rax),%rcx
   2c5b0:	48 89 19             	mov    %rbx,(%rcx)
	successor->prev = node;
   2c5b3:	48 89 58 08          	mov    %rbx,0x8(%rax)
   2c5b7:	eb 30                	jmp    2c5e9 <z_add_timeout+0xe2>
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
   2c5b9:	48 29 f1             	sub    %rsi,%rcx
	return (node == list->tail) ? NULL : node->next;
   2c5bc:	48 39 c7             	cmp    %rax,%rdi
   2c5bf:	48 89 4b 18          	mov    %rcx,0x18(%rbx)
   2c5c3:	74 05                	je     2c5ca <z_add_timeout+0xc3>
   2c5c5:	48 8b 00             	mov    (%rax),%rax
   2c5c8:	eb be                	jmp    2c588 <z_add_timeout+0x81>
	node->prev = list->tail;
   2c5ca:	48 8b 05 67 a4 20 00 	mov    0x20a467(%rip),%rax        # 236a38 <timeout_list+0x8>
	node->next = list;
   2c5d1:	48 89 13             	mov    %rdx,(%rbx)
	node->prev = list->tail;
   2c5d4:	48 89 43 08          	mov    %rax,0x8(%rbx)
	list->tail->next = node;
   2c5d8:	48 8b 05 59 a4 20 00 	mov    0x20a459(%rip),%rax        # 236a38 <timeout_list+0x8>
   2c5df:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
   2c5e2:	48 89 1d 4f a4 20 00 	mov    %rbx,0x20a44f(%rip)        # 236a38 <timeout_list+0x8>
	return list->head == list;
   2c5e9:	48 8b 05 40 a4 20 00 	mov    0x20a440(%rip),%rax        # 236a30 <timeout_list>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   2c5f0:	48 39 d0             	cmp    %rdx,%rax
   2c5f3:	74 23                	je     2c618 <z_add_timeout+0x111>
   2c5f5:	48 39 c3             	cmp    %rax,%rbx
   2c5f8:	75 1e                	jne    2c618 <z_add_timeout+0x111>
			 * last announcement, and slice_ticks is based
			 * on that. It means the that time remaining for
			 * the next announcement can be lesser than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
   2c5fa:	e8 71 fe ff ff       	callq  2c470 <next_timeout>

			if (next_time == 0 ||
   2c5ff:	85 c0                	test   %eax,%eax
   2c601:	74 0c                	je     2c60f <z_add_timeout+0x108>
			    _current_cpu->slice_ticks != next_time) {
   2c603:	48 8d 15 36 b5 22 00 	lea    0x22b536(%rip),%rdx        # 257b40 <_kernel>
			if (next_time == 0 ||
   2c60a:	39 42 28             	cmp    %eax,0x28(%rdx)
   2c60d:	74 09                	je     2c618 <z_add_timeout+0x111>
				z_clock_set_timeout(next_time, false);
   2c60f:	31 f6                	xor    %esi,%esi
   2c611:	89 c7                	mov    %eax,%edi
   2c613:	e8 5a cd fd ff       	callq  9372 <z_clock_set_timeout>
#else
			z_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
   2c618:	58                   	pop    %rax
	posix_irq_unlock(key);
   2c619:	44 89 e7             	mov    %r12d,%edi
   2c61c:	5b                   	pop    %rbx
   2c61d:	5d                   	pop    %rbp
   2c61e:	41 5c                	pop    %r12
   2c620:	41 5d                	pop    %r13
   2c622:	e9 75 f9 fd ff       	jmpq   bf9c <posix_irq_unlock>
   2c627:	c3                   	retq   

000000000002c628 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
   2c628:	53                   	push   %rbx
   2c629:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
   2c62e:	48 83 ec 10          	sub    $0x10,%rsp
   2c632:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
   2c637:	e8 56 f9 fd ff       	callq  bf92 <posix_irq_lock>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
   2c63c:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
   2c641:	89 c1                	mov    %eax,%ecx
   2c643:	48 83 3f 00          	cmpq   $0x0,(%rdi)
   2c647:	74 07                	je     2c650 <z_abort_timeout+0x28>
			remove_timeout(to);
			ret = 0;
   2c649:	31 db                	xor    %ebx,%ebx
			remove_timeout(to);
   2c64b:	e8 7b fe ff ff       	callq  2c4cb <remove_timeout>
	posix_irq_unlock(key);
   2c650:	89 cf                	mov    %ecx,%edi
   2c652:	e8 45 f9 fd ff       	callq  bf9c <posix_irq_unlock>
		}
	}

	return ret;
}
   2c657:	48 83 c4 10          	add    $0x10,%rsp
   2c65b:	89 d8                	mov    %ebx,%eax
   2c65d:	5b                   	pop    %rbx
   2c65e:	c3                   	retq   

000000000002c65f <z_get_next_timeout_expiry>:

	return ticks;
}

int32_t z_get_next_timeout_expiry(void)
{
   2c65f:	53                   	push   %rbx
   2c660:	48 83 ec 10          	sub    $0x10,%rsp
	return posix_irq_lock();
   2c664:	e8 29 f9 fd ff       	callq  bf92 <posix_irq_lock>
   2c669:	89 c3                	mov    %eax,%ebx
	int32_t ret = (int32_t) K_TICKS_FOREVER;

	LOCKED(&timeout_lock) {
		ret = next_timeout();
   2c66b:	e8 00 fe ff ff       	callq  2c470 <next_timeout>
	posix_irq_unlock(key);
   2c670:	89 df                	mov    %ebx,%edi
   2c672:	89 44 24 0c          	mov    %eax,0xc(%rsp)
   2c676:	e8 21 f9 fd ff       	callq  bf9c <posix_irq_unlock>
	}
	return ret;
}
   2c67b:	8b 44 24 0c          	mov    0xc(%rsp),%eax
   2c67f:	48 83 c4 10          	add    $0x10,%rsp
   2c683:	5b                   	pop    %rbx
   2c684:	c3                   	retq   

000000000002c685 <z_set_timeout_expiry>:

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
   2c685:	55                   	push   %rbp
   2c686:	53                   	push   %rbx
   2c687:	89 f3                	mov    %esi,%ebx
   2c689:	48 83 ec 18          	sub    $0x18,%rsp
   2c68d:	89 7c 24 0c          	mov    %edi,0xc(%rsp)
	return posix_irq_lock();
   2c691:	e8 fc f8 fd ff       	callq  bf92 <posix_irq_lock>
   2c696:	89 c5                	mov    %eax,%ebp
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
   2c698:	e8 d3 fd ff ff       	callq  2c470 <next_timeout>
		bool sooner = (next_to == K_TICKS_FOREVER)
			      || (ticks <= next_to);
   2c69d:	8b 7c 24 0c          	mov    0xc(%rsp),%edi
		bool sooner = (next_to == K_TICKS_FOREVER)
   2c6a1:	83 f8 ff             	cmp    $0xffffffff,%eax
   2c6a4:	0f 94 c1             	sete   %cl
			      || (ticks <= next_to);
   2c6a7:	39 f8                	cmp    %edi,%eax
   2c6a9:	0f 9d c2             	setge  %dl
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   2c6ac:	08 d1                	or     %dl,%cl
   2c6ae:	74 0c                	je     2c6bc <z_set_timeout_expiry+0x37>
   2c6b0:	ff c8                	dec    %eax
   2c6b2:	7e 08                	jle    2c6bc <z_set_timeout_expiry+0x37>
			z_clock_set_timeout(ticks, is_idle);
   2c6b4:	0f b6 f3             	movzbl %bl,%esi
   2c6b7:	e8 b6 cc fd ff       	callq  9372 <z_clock_set_timeout>
		}
	}
}
   2c6bc:	48 83 c4 18          	add    $0x18,%rsp
	posix_irq_unlock(key);
   2c6c0:	89 ef                	mov    %ebp,%edi
   2c6c2:	5b                   	pop    %rbx
   2c6c3:	5d                   	pop    %rbp
   2c6c4:	e9 d3 f8 fd ff       	jmpq   bf9c <posix_irq_unlock>

000000000002c6c9 <z_clock_announce>:

void z_clock_announce(int32_t ticks)
{
   2c6c9:	41 54                	push   %r12
   2c6cb:	55                   	push   %rbp
   2c6cc:	4c 8d 25 5d a3 20 00 	lea    0x20a35d(%rip),%r12        # 236a30 <timeout_list>
   2c6d3:	53                   	push   %rbx
   2c6d4:	89 fb                	mov    %edi,%ebx
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   2c6d6:	e8 03 f2 ff ff       	callq  2b8de <z_time_slice>
	return posix_irq_lock();
   2c6db:	e8 b2 f8 fd ff       	callq  bf92 <posix_irq_lock>
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   2c6e0:	89 1d de 29 23 00    	mov    %ebx,0x2329de(%rip)        # 25f0c4 <announce_remaining>
   2c6e6:	89 c5                	mov    %eax,%ebp
   2c6e8:	49 8b 1c 24          	mov    (%r12),%rbx
   2c6ec:	48 63 15 d1 29 23 00 	movslq 0x2329d1(%rip),%rdx        # 25f0c4 <announce_remaining>
   2c6f3:	48 8b 35 4e b9 22 00 	mov    0x22b94e(%rip),%rsi        # 258048 <curr_tick>

	while (first() != NULL && first()->dticks <= announce_remaining) {
   2c6fa:	48 85 db             	test   %rbx,%rbx
   2c6fd:	48 89 d1             	mov    %rdx,%rcx
   2c700:	74 50                	je     2c752 <z_clock_announce+0x89>
   2c702:	4c 39 e3             	cmp    %r12,%rbx
   2c705:	74 4b                	je     2c752 <z_clock_announce+0x89>
   2c707:	48 8b 43 18          	mov    0x18(%rbx),%rax
   2c70b:	48 39 d0             	cmp    %rdx,%rax
   2c70e:	7f 3b                	jg     2c74b <z_clock_announce+0x82>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
   2c710:	48 63 d0             	movslq %eax,%rdx
		announce_remaining -= dt;
   2c713:	29 c1                	sub    %eax,%ecx
		t->dticks = 0;
		remove_timeout(t);
   2c715:	48 89 df             	mov    %rbx,%rdi
		curr_tick += dt;
   2c718:	48 01 f2             	add    %rsi,%rdx
		t->dticks = 0;
   2c71b:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
   2c722:	00 
		announce_remaining -= dt;
   2c723:	89 0d 9b 29 23 00    	mov    %ecx,0x23299b(%rip)        # 25f0c4 <announce_remaining>
		curr_tick += dt;
   2c729:	48 89 15 18 b9 22 00 	mov    %rdx,0x22b918(%rip)        # 258048 <curr_tick>
		remove_timeout(t);
   2c730:	e8 96 fd ff ff       	callq  2c4cb <remove_timeout>
	posix_irq_unlock(key);
   2c735:	89 ef                	mov    %ebp,%edi
   2c737:	e8 60 f8 fd ff       	callq  bf9c <posix_irq_unlock>

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
   2c73c:	48 89 df             	mov    %rbx,%rdi
   2c73f:	ff 53 10             	callq  *0x10(%rbx)
	return posix_irq_lock();
   2c742:	e8 4b f8 fd ff       	callq  bf92 <posix_irq_lock>
   2c747:	89 c5                	mov    %eax,%ebp
   2c749:	eb 9d                	jmp    2c6e8 <z_clock_announce+0x1f>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   2c74b:	48 29 d0             	sub    %rdx,%rax
   2c74e:	48 89 43 18          	mov    %rax,0x18(%rbx)
	}

	curr_tick += announce_remaining;
   2c752:	48 01 f2             	add    %rsi,%rdx
	announce_remaining = 0;
   2c755:	c7 05 65 29 23 00 00 	movl   $0x0,0x232965(%rip)        # 25f0c4 <announce_remaining>
   2c75c:	00 00 00 
	curr_tick += announce_remaining;
   2c75f:	48 89 15 e2 b8 22 00 	mov    %rdx,0x22b8e2(%rip)        # 258048 <curr_tick>

	z_clock_set_timeout(next_timeout(), false);
   2c766:	e8 05 fd ff ff       	callq  2c470 <next_timeout>
   2c76b:	31 f6                	xor    %esi,%esi
   2c76d:	89 c7                	mov    %eax,%edi
   2c76f:	e8 fe cb fd ff       	callq  9372 <z_clock_set_timeout>

	k_spin_unlock(&timeout_lock, key);
}
   2c774:	5b                   	pop    %rbx
	posix_irq_unlock(key);
   2c775:	89 ef                	mov    %ebp,%edi
   2c777:	5d                   	pop    %rbp
   2c778:	41 5c                	pop    %r12
   2c77a:	e9 1d f8 fd ff       	jmpq   bf9c <posix_irq_unlock>

000000000002c77f <z_tick_get>:

int64_t z_tick_get(void)
{
   2c77f:	55                   	push   %rbp
   2c780:	53                   	push   %rbx
   2c781:	48 83 ec 08          	sub    $0x8,%rsp
	return posix_irq_lock();
   2c785:	e8 08 f8 fd ff       	callq  bf92 <posix_irq_lock>
   2c78a:	89 c5                	mov    %eax,%ebp
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
   2c78c:	e8 02 cc fd ff       	callq  9393 <z_clock_elapsed>
   2c791:	89 c3                	mov    %eax,%ebx
   2c793:	48 03 1d ae b8 22 00 	add    0x22b8ae(%rip),%rbx        # 258048 <curr_tick>
	posix_irq_unlock(key);
   2c79a:	89 ef                	mov    %ebp,%edi
   2c79c:	e8 fb f7 fd ff       	callq  bf9c <posix_irq_unlock>
	}
	return t;
}
   2c7a1:	5a                   	pop    %rdx
   2c7a2:	48 89 d8             	mov    %rbx,%rax
   2c7a5:	5b                   	pop    %rbx
   2c7a6:	5d                   	pop    %rbp
   2c7a7:	c3                   	retq   

000000000002c7a8 <z_tick_get_32>:

uint32_t z_tick_get_32(void)
{
   2c7a8:	48 83 ec 08          	sub    $0x8,%rsp
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)z_tick_get();
   2c7ac:	e8 ce ff ff ff       	callq  2c77f <z_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
   2c7b1:	5a                   	pop    %rdx
   2c7b2:	c3                   	retq   

000000000002c7b3 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return z_tick_get();
   2c7b3:	e9 c7 ff ff ff       	jmpq   2c77f <z_tick_get>

000000000002c7b8 <z_timeout_end_calc>:
 */
uint64_t z_timeout_end_calc(k_timeout_t timeout)
{
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   2c7b8:	48 83 ff ff          	cmp    $0xffffffffffffffff,%rdi
   2c7bc:	74 30                	je     2c7ee <z_timeout_end_calc+0x36>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2c7be:	48 85 ff             	test   %rdi,%rdi
   2c7c1:	75 05                	jne    2c7c8 <z_timeout_end_calc+0x10>
		return z_tick_get();
   2c7c3:	e9 b7 ff ff ff       	jmpq   2c77f <z_tick_get>
	}

	dt = timeout.ticks;

	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   2c7c8:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
   2c7cf:	48 29 f8             	sub    %rdi,%rax
   2c7d2:	79 1e                	jns    2c7f2 <z_timeout_end_calc+0x3a>
{
   2c7d4:	53                   	push   %rbx
   2c7d5:	48 89 fb             	mov    %rdi,%rbx
		return Z_TICK_ABS(dt);
	}
	return z_tick_get() + MAX(1, dt);
   2c7d8:	e8 a2 ff ff ff       	callq  2c77f <z_tick_get>
   2c7dd:	48 85 db             	test   %rbx,%rbx
   2c7e0:	bf 01 00 00 00       	mov    $0x1,%edi
   2c7e5:	48 0f 4f fb          	cmovg  %rbx,%rdi
   2c7e9:	48 01 f8             	add    %rdi,%rax
}
   2c7ec:	5b                   	pop    %rbx
   2c7ed:	c3                   	retq   
		return UINT64_MAX;
   2c7ee:	48 89 f8             	mov    %rdi,%rax
   2c7f1:	c3                   	retq   
}
   2c7f2:	c3                   	retq   

000000000002c7f3 <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
   2c7f3:	55                   	push   %rbp
   2c7f4:	53                   	push   %rbx
   2c7f5:	48 89 fb             	mov    %rdi,%rbx
   2c7f8:	48 83 ec 08          	sub    $0x8,%rsp

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   2c7fc:	48 8b 57 40          	mov    0x40(%rdi),%rdx
   2c800:	48 8d 42 01          	lea    0x1(%rdx),%rax
   2c804:	48 83 f8 01          	cmp    $0x1,%rax
   2c808:	76 0c                	jbe    2c816 <z_timer_expiration_handler+0x23>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   2c80a:	48 8d 35 e2 ff ff ff 	lea    -0x1e(%rip),%rsi        # 2c7f3 <z_timer_expiration_handler>
   2c811:	e8 f1 fc ff ff       	callq  2c507 <z_add_timeout>

	/* update timer's status */
	timer->status += 1U;

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   2c816:	48 8b 43 30          	mov    0x30(%rbx),%rax
	timer->status += 1U;
   2c81a:	ff 43 48             	incl   0x48(%rbx)
	if (timer->expiry_fn != NULL) {
   2c81d:	48 85 c0             	test   %rax,%rax
   2c820:	74 05                	je     2c827 <z_timer_expiration_handler+0x34>
		timer->expiry_fn(timer);
   2c822:	48 89 df             	mov    %rbx,%rdi
   2c825:	ff d0                	callq  *%rax
   2c827:	48 8b 6b 20          	mov    0x20(%rbx),%rbp
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   2c82b:	48 85 ed             	test   %rbp,%rbp
   2c82e:	74 20                	je     2c850 <z_timer_expiration_handler+0x5d>
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   2c830:	48 83 c3 20          	add    $0x20,%rbx
   2c834:	48 39 dd             	cmp    %rbx,%rbp
   2c837:	74 17                	je     2c850 <z_timer_expiration_handler+0x5d>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
   2c839:	48 89 ef             	mov    %rbp,%rdi
   2c83c:	e8 02 ed ff ff       	callq  2b543 <z_unpend_thread_no_timeout>

	z_ready_thread(thread);
   2c841:	48 89 ef             	mov    %rbp,%rdi
   2c844:	e8 48 ef ff ff       	callq  2b791 <z_ready_thread>
	thread->callee_saved.retval = value;
   2c849:	c7 45 5c 00 00 00 00 	movl   $0x0,0x5c(%rbp)

	arch_thread_return_value_set(thread, 0);
}
   2c850:	58                   	pop    %rax
   2c851:	5b                   	pop    %rbx
   2c852:	5d                   	pop    %rbp
   2c853:	c3                   	retq   

000000000002c854 <k_timer_init>:
	sys_dlist_init(&w->waitq);
   2c854:	48 8d 47 20          	lea    0x20(%rdi),%rax

void k_timer_init(struct k_timer *timer,
			 k_timer_expiry_t expiry_fn,
			 k_timer_stop_t stop_fn)
{
	timer->expiry_fn = expiry_fn;
   2c858:	48 89 77 30          	mov    %rsi,0x30(%rdi)
	timer->stop_fn = stop_fn;
   2c85c:	48 89 57 38          	mov    %rdx,0x38(%rdi)
	timer->status = 0U;
   2c860:	c7 47 48 00 00 00 00 	movl   $0x0,0x48(%rdi)
	node->next = NULL;
   2c867:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
	list->head = (sys_dnode_t *)list;
   2c86e:	48 89 47 20          	mov    %rax,0x20(%rdi)
	list->tail = (sys_dnode_t *)list;
   2c872:	48 89 47 28          	mov    %rax,0x28(%rdi)
	node->prev = NULL;
   2c876:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
   2c87d:	00 

	z_waitq_init(&timer->wait_q);
	z_init_timeout(&timer->timeout);
	SYS_TRACING_OBJ_INIT(k_timer, timer);

	timer->user_data = NULL;
   2c87e:	48 c7 47 50 00 00 00 	movq   $0x0,0x50(%rdi)
   2c885:	00 

	z_object_init(timer);
}
   2c886:	c3                   	retq   

000000000002c887 <z_impl_k_timer_start>:


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   2c887:	48 83 fe ff          	cmp    $0xffffffffffffffff,%rsi
   2c88b:	74 6e                	je     2c8fb <z_impl_k_timer_start+0x74>
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (period.ticks != 0 && Z_TICK_ABS(period.ticks) < 0) {
   2c88d:	48 85 d2             	test   %rdx,%rdx
{
   2c890:	41 54                	push   %r12
   2c892:	49 89 f4             	mov    %rsi,%r12
   2c895:	55                   	push   %rbp
   2c896:	53                   	push   %rbx
   2c897:	48 89 d3             	mov    %rdx,%rbx
	if (period.ticks != 0 && Z_TICK_ABS(period.ticks) < 0) {
   2c89a:	74 1b                	je     2c8b7 <z_impl_k_timer_start+0x30>
   2c89c:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
   2c8a3:	48 39 d0             	cmp    %rdx,%rax
   2c8a6:	79 0f                	jns    2c8b7 <z_impl_k_timer_start+0x30>
		period.ticks = MAX(period.ticks - 1, 1);
   2c8a8:	48 ff cb             	dec    %rbx
   2c8ab:	b8 01 00 00 00       	mov    $0x1,%eax
   2c8b0:	48 85 db             	test   %rbx,%rbx
   2c8b3:	48 0f 4e d8          	cmovle %rax,%rbx
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
   2c8b7:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
   2c8be:	48 39 f0             	cmp    %rsi,%rax
   2c8c1:	79 0f                	jns    2c8d2 <z_impl_k_timer_start+0x4b>
		duration.ticks = MAX(duration.ticks - 1, 0);
   2c8c3:	48 ff ce             	dec    %rsi
   2c8c6:	b8 00 00 00 00       	mov    $0x0,%eax
   2c8cb:	49 89 f4             	mov    %rsi,%r12
   2c8ce:	4c 0f 48 e0          	cmovs  %rax,%r12
   2c8d2:	48 89 fd             	mov    %rdi,%rbp
	}

	(void)z_abort_timeout(&timer->timeout);
   2c8d5:	e8 4e fd ff ff       	callq  2c628 <z_abort_timeout>
	timer->period = period;
   2c8da:	48 89 5d 40          	mov    %rbx,0x40(%rbp)
	timer->status = 0U;
   2c8de:	c7 45 48 00 00 00 00 	movl   $0x0,0x48(%rbp)

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   2c8e5:	4c 89 e2             	mov    %r12,%rdx
		     duration);
}
   2c8e8:	5b                   	pop    %rbx
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   2c8e9:	48 89 ef             	mov    %rbp,%rdi
   2c8ec:	48 8d 35 00 ff ff ff 	lea    -0x100(%rip),%rsi        # 2c7f3 <z_timer_expiration_handler>
}
   2c8f3:	5d                   	pop    %rbp
   2c8f4:	41 5c                	pop    %r12
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   2c8f6:	e9 0c fc ff ff       	jmpq   2c507 <z_add_timeout>
   2c8fb:	c3                   	retq   

000000000002c8fc <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   2c8fc:	53                   	push   %rbx
   2c8fd:	48 89 fb             	mov    %rdi,%rbx
	int inactive = z_abort_timeout(&timer->timeout) != 0;
   2c900:	e8 23 fd ff ff       	callq  2c628 <z_abort_timeout>

	if (inactive) {
   2c905:	85 c0                	test   %eax,%eax
   2c907:	75 3e                	jne    2c947 <z_impl_k_timer_stop+0x4b>
		return;
	}

	if (timer->stop_fn != NULL) {
   2c909:	48 8b 43 38          	mov    0x38(%rbx),%rax
   2c90d:	48 85 c0             	test   %rax,%rax
   2c910:	74 05                	je     2c917 <z_impl_k_timer_stop+0x1b>
		timer->stop_fn(timer);
   2c912:	48 89 df             	mov    %rbx,%rdi
   2c915:	ff d0                	callq  *%rax
	}

	struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
   2c917:	48 8d 7b 20          	lea    0x20(%rbx),%rdi
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
   2c91b:	31 f6                	xor    %esi,%esi
   2c91d:	e8 ef eb ff ff       	callq  2b511 <z_find_first_thread_to_unpend>
	if (thread != NULL) {
   2c922:	48 85 c0             	test   %rax,%rax
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
   2c925:	48 89 c3             	mov    %rax,%rbx
	if (thread != NULL) {
   2c928:	74 1d                	je     2c947 <z_impl_k_timer_stop+0x4b>
		z_unpend_thread_no_timeout(thread);
   2c92a:	48 89 c7             	mov    %rax,%rdi
   2c92d:	e8 11 ec ff ff       	callq  2b543 <z_unpend_thread_no_timeout>

	if (pending_thread != NULL) {
		z_ready_thread(pending_thread);
   2c932:	48 89 df             	mov    %rbx,%rdi
   2c935:	e8 57 ee ff ff       	callq  2b791 <z_ready_thread>
	return posix_irq_lock();
   2c93a:	e8 53 f6 fd ff       	callq  bf92 <posix_irq_lock>
		z_reschedule_unlocked();
	}
}
   2c93f:	5b                   	pop    %rbx
	(void) z_reschedule_irqlock(arch_irq_lock());
   2c940:	89 c7                	mov    %eax,%edi
   2c942:	e9 4b ec ff ff       	jmpq   2b592 <z_reschedule_irqlock>
   2c947:	5b                   	pop    %rbx
   2c948:	c3                   	retq   

000000000002c949 <clear_event_registrations>:

/* must be called with interrupts locked */
static inline void clear_event_registrations(struct k_poll_event *events,
					      int num_events,
					      k_spinlock_key_t key)
{
   2c949:	41 54                	push   %r12
   2c94b:	41 bc 01 00 00 00    	mov    $0x1,%r12d
   2c951:	55                   	push   %rbp
   2c952:	48 89 fd             	mov    %rdi,%rbp
   2c955:	53                   	push   %rbx
   2c956:	89 d7                	mov    %edx,%edi
   2c958:	89 f3                	mov    %esi,%ebx
	while (num_events--) {
   2c95a:	ff cb                	dec    %ebx
   2c95c:	83 fb ff             	cmp    $0xffffffff,%ebx
   2c95f:	74 5b                	je     2c9bc <clear_event_registrations+0x73>
		clear_event_registration(&events[num_events]);
   2c961:	4c 63 c3             	movslq %ebx,%r8
   2c964:	4d 6b c0 28          	imul   $0x28,%r8,%r8
   2c968:	49 01 e8             	add    %rbp,%r8
	switch (event->type) {
   2c96b:	41 8a 48 19          	mov    0x19(%r8),%cl
	event->poller = NULL;
   2c96f:	49 c7 40 10 00 00 00 	movq   $0x0,0x10(%r8)
   2c976:	00 
	switch (event->type) {
   2c977:	83 e1 0f             	and    $0xf,%ecx
   2c97a:	80 f9 04             	cmp    $0x4,%cl
   2c97d:	77 2f                	ja     2c9ae <clear_event_registrations+0x65>
   2c97f:	4c 89 e0             	mov    %r12,%rax
   2c982:	48 d3 e0             	shl    %cl,%rax
   2c985:	a8 16                	test   $0x16,%al
   2c987:	74 25                	je     2c9ae <clear_event_registrations+0x65>
	if (remove && sys_dnode_is_linked(&event->_node)) {
   2c989:	49 8b 10             	mov    (%r8),%rdx
   2c98c:	48 85 d2             	test   %rdx,%rdx
   2c98f:	74 1d                	je     2c9ae <clear_event_registrations+0x65>
	node->prev->next = node->next;
   2c991:	49 8b 40 08          	mov    0x8(%r8),%rax
   2c995:	48 89 10             	mov    %rdx,(%rax)
	node->next->prev = node->prev;
   2c998:	49 8b 10             	mov    (%r8),%rdx
   2c99b:	48 89 42 08          	mov    %rax,0x8(%rdx)
	node->next = NULL;
   2c99f:	49 c7 00 00 00 00 00 	movq   $0x0,(%r8)
	node->prev = NULL;
   2c9a6:	49 c7 40 08 00 00 00 	movq   $0x0,0x8(%r8)
   2c9ad:	00 
	posix_irq_unlock(key);
   2c9ae:	e8 e9 f5 fd ff       	callq  bf9c <posix_irq_unlock>
	return posix_irq_lock();
   2c9b3:	e8 da f5 fd ff       	callq  bf92 <posix_irq_lock>
   2c9b8:	89 c7                	mov    %eax,%edi
   2c9ba:	eb 9e                	jmp    2c95a <clear_event_registrations+0x11>
		k_spin_unlock(&lock, key);
		key = k_spin_lock(&lock);
	}
}
   2c9bc:	5b                   	pop    %rbx
   2c9bd:	5d                   	pop    %rbp
   2c9be:	41 5c                	pop    %r12
   2c9c0:	c3                   	retq   

000000000002c9c1 <k_work_submit_to_queue>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2c9c1:	8b 46 10             	mov    0x10(%rsi),%eax
   2c9c4:	89 c1                	mov    %eax,%ecx
   2c9c6:	89 c2                	mov    %eax,%edx
   2c9c8:	83 c9 01             	or     $0x1,%ecx
   2c9cb:	f0 0f b1 4e 10       	lock cmpxchg %ecx,0x10(%rsi)
   2c9d0:	75 f2                	jne    2c9c4 <k_work_submit_to_queue+0x3>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   2c9d2:	80 e2 01             	and    $0x1,%dl
   2c9d5:	75 05                	jne    2c9dc <k_work_submit_to_queue+0x1b>
		k_queue_append(&work_q->queue, work);
   2c9d7:	e9 4f e9 ff ff       	jmpq   2b32b <k_queue_append>
}
   2c9dc:	c3                   	retq   

000000000002c9dd <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, uint32_t state)
{
   2c9dd:	41 56                	push   %r14
   2c9df:	41 55                	push   %r13
   2c9e1:	41 54                	push   %r12
   2c9e3:	55                   	push   %rbp
   2c9e4:	41 89 f4             	mov    %esi,%r12d
   2c9e7:	53                   	push   %rbx
	struct z_poller *poller = event->poller;
   2c9e8:	48 8b 5f 10          	mov    0x10(%rdi),%rbx
{
   2c9ec:	48 89 fd             	mov    %rdi,%rbp
	int retcode = 0;

	if (poller) {
   2c9ef:	48 85 db             	test   %rbx,%rbx
   2c9f2:	0f 84 8b 00 00 00    	je     2ca83 <signal_poll_event+0xa6>
		if (poller->mode == MODE_POLL) {
   2c9f8:	8a 43 01             	mov    0x1(%rbx),%al
   2c9fb:	3c 01                	cmp    $0x1,%al
   2c9fd:	75 50                	jne    2ca4f <signal_poll_event+0x72>
	if (!z_is_thread_pending(thread)) {
   2c9ff:	f6 43 a1 02          	testb  $0x2,-0x5f(%rbx)
   2ca03:	74 7b                	je     2ca80 <signal_poll_event+0xa3>
	if (z_is_thread_timeout_expired(thread)) {
   2ca05:	48 83 7b c8 fe       	cmpq   $0xfffffffffffffffe,-0x38(%rbx)
   2ca0a:	75 0d                	jne    2ca19 <signal_poll_event+0x3c>
			retcode = signal_poller(event, state);
		} else if (poller->mode == MODE_TRIGGERED) {
			retcode = signal_triggered_work(event, state);
		}

		poller->is_polling = false;
   2ca0c:	c6 03 00             	movb   $0x0,(%rbx)
		return -EAGAIN;
   2ca0f:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
   2ca14:	e9 8f 00 00 00       	jmpq   2caa8 <signal_poll_event+0xcb>
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   2ca19:	4c 8d 6b 88          	lea    -0x78(%rbx),%r13
	z_unpend_thread(thread);
   2ca1d:	4c 89 ef             	mov    %r13,%rdi
   2ca20:	e8 f6 eb ff ff       	callq  2b61b <z_unpend_thread>
	arch_thread_return_value_set(thread,
   2ca25:	31 c0                	xor    %eax,%eax
   2ca27:	41 83 fc 08          	cmp    $0x8,%r12d
   2ca2b:	0f 95 c0             	setne  %al
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   2ca2e:	f6 43 a1 1f          	testb  $0x1f,-0x5f(%rbx)
   2ca32:	8d 04 85 fc ff ff ff 	lea    -0x4(,%rax,4),%eax
   2ca39:	89 43 e4             	mov    %eax,-0x1c(%rbx)
   2ca3c:	75 42                	jne    2ca80 <signal_poll_event+0xa3>
	if (!z_is_thread_ready(thread)) {
   2ca3e:	48 83 7b b0 00       	cmpq   $0x0,-0x50(%rbx)
   2ca43:	75 3b                	jne    2ca80 <signal_poll_event+0xa3>
	z_ready_thread(thread);
   2ca45:	4c 89 ef             	mov    %r13,%rdi
   2ca48:	e8 44 ed ff ff       	callq  2b791 <z_ready_thread>
   2ca4d:	eb 31                	jmp    2ca80 <signal_poll_event+0xa3>
		} else if (poller->mode == MODE_TRIGGERED) {
   2ca4f:	3c 02                	cmp    $0x2,%al
   2ca51:	75 2d                	jne    2ca80 <signal_poll_event+0xa3>
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
   2ca53:	80 3b 00             	cmpb   $0x0,(%rbx)
   2ca56:	74 2b                	je     2ca83 <signal_poll_event+0xa6>
   2ca58:	4c 8b 6b f8          	mov    -0x8(%rbx),%r13
   2ca5c:	4d 85 ed             	test   %r13,%r13
   2ca5f:	74 1f                	je     2ca80 <signal_poll_event+0xa3>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
   2ca61:	48 8d 7b 20          	lea    0x20(%rbx),%rdi
   2ca65:	4c 8d 73 e0          	lea    -0x20(%rbx),%r14
   2ca69:	e8 ba fb ff ff       	callq  2c628 <z_abort_timeout>
		twork->poll_result = 0;
   2ca6e:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%rbx)
		k_work_submit_to_queue(work_q, &twork->work);
   2ca75:	4c 89 f6             	mov    %r14,%rsi
   2ca78:	4c 89 ef             	mov    %r13,%rdi
   2ca7b:	e8 41 ff ff ff       	callq  2c9c1 <k_work_submit_to_queue>
		poller->is_polling = false;
   2ca80:	c6 03 00             	movb   $0x0,(%rbx)
	event->state |= state;
   2ca83:	8b 45 18             	mov    0x18(%rbp),%eax
	event->poller = NULL;
   2ca86:	48 c7 45 10 00 00 00 	movq   $0x0,0x10(%rbp)
   2ca8d:	00 
	event->state |= state;
   2ca8e:	89 c6                	mov    %eax,%esi
   2ca90:	25 ff 0f fe ff       	and    $0xfffe0fff,%eax
   2ca95:	c1 ee 0c             	shr    $0xc,%esi
   2ca98:	44 09 e6             	or     %r12d,%esi
   2ca9b:	83 e6 1f             	and    $0x1f,%esi
   2ca9e:	c1 e6 0c             	shl    $0xc,%esi
   2caa1:	09 c6                	or     %eax,%esi
	return retcode;
   2caa3:	31 c0                	xor    %eax,%eax
	event->state |= state;
   2caa5:	89 75 18             	mov    %esi,0x18(%rbp)
}
   2caa8:	5b                   	pop    %rbx
   2caa9:	5d                   	pop    %rbp
   2caaa:	41 5c                	pop    %r12
   2caac:	41 5d                	pop    %r13
   2caae:	41 5e                	pop    %r14
   2cab0:	c3                   	retq   

000000000002cab1 <add_event>:
{
   2cab1:	41 55                	push   %r13
   2cab3:	41 54                	push   %r12
   2cab5:	55                   	push   %rbp
   2cab6:	53                   	push   %rbx
   2cab7:	48 89 f5             	mov    %rsi,%rbp
   2caba:	48 89 fb             	mov    %rdi,%rbx
   2cabd:	48 83 ec 08          	sub    $0x8,%rsp
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   2cac1:	48 3b 3f             	cmp    (%rdi),%rdi
   2cac4:	48 8b 47 08          	mov    0x8(%rdi),%rax
   2cac8:	74 39                	je     2cb03 <add_event+0x52>
	if ((pending == NULL) ||
   2caca:	48 85 c0             	test   %rax,%rax
   2cacd:	74 34                	je     2cb03 <add_event+0x52>
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   2cacf:	45 31 ed             	xor    %r13d,%r13d
   2cad2:	48 85 d2             	test   %rdx,%rdx
   2cad5:	74 04                	je     2cadb <add_event+0x2a>
   2cad7:	4c 8d 6a 88          	lea    -0x78(%rdx),%r13
	    z_is_t1_higher_prio_than_t2(poller_thread(pending->poller),
   2cadb:	48 8b 40 10          	mov    0x10(%rax),%rax
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   2cadf:	31 ff                	xor    %edi,%edi
   2cae1:	48 85 c0             	test   %rax,%rax
   2cae4:	74 04                	je     2caea <add_event+0x39>
   2cae6:	48 8d 78 88          	lea    -0x78(%rax),%rdi
	    z_is_t1_higher_prio_than_t2(poller_thread(pending->poller),
   2caea:	4c 89 ee             	mov    %r13,%rsi
   2caed:	e8 83 e9 ff ff       	callq  2b475 <z_is_t1_higher_prio_than_t2>
	if ((pending == NULL) ||
   2caf2:	84 c0                	test   %al,%al
   2caf4:	75 0d                	jne    2cb03 <add_event+0x52>
	return list->head == list;
   2caf6:	4c 8b 23             	mov    (%rbx),%r12
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   2caf9:	4d 85 e4             	test   %r12,%r12
   2cafc:	74 05                	je     2cb03 <add_event+0x52>
   2cafe:	4c 39 e3             	cmp    %r12,%rbx
   2cb01:	75 19                	jne    2cb1c <add_event+0x6b>
	node->prev = list->tail;
   2cb03:	48 8b 43 08          	mov    0x8(%rbx),%rax
	node->next = list;
   2cb07:	48 89 5d 00          	mov    %rbx,0x0(%rbp)
	node->prev = list->tail;
   2cb0b:	48 89 45 08          	mov    %rax,0x8(%rbp)
	list->tail->next = node;
   2cb0f:	48 8b 43 08          	mov    0x8(%rbx),%rax
   2cb13:	48 89 28             	mov    %rbp,(%rax)
	list->tail = node;
   2cb16:	48 89 6b 08          	mov    %rbp,0x8(%rbx)
   2cb1a:	eb 47                	jmp    2cb63 <add_event+0xb2>
		if (z_is_t1_higher_prio_than_t2(poller_thread(poller),
   2cb1c:	49 8b 44 24 10       	mov    0x10(%r12),%rax
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   2cb21:	31 f6                	xor    %esi,%esi
   2cb23:	48 85 c0             	test   %rax,%rax
   2cb26:	74 04                	je     2cb2c <add_event+0x7b>
   2cb28:	48 8d 70 88          	lea    -0x78(%rax),%rsi
		if (z_is_t1_higher_prio_than_t2(poller_thread(poller),
   2cb2c:	4c 89 ef             	mov    %r13,%rdi
   2cb2f:	e8 41 e9 ff ff       	callq  2b475 <z_is_t1_higher_prio_than_t2>
   2cb34:	84 c0                	test   %al,%al
   2cb36:	74 1c                	je     2cb54 <add_event+0xa3>
	node->prev = successor->prev;
   2cb38:	49 8b 44 24 08       	mov    0x8(%r12),%rax
	node->next = successor;
   2cb3d:	4c 89 65 00          	mov    %r12,0x0(%rbp)
	node->prev = successor->prev;
   2cb41:	48 89 45 08          	mov    %rax,0x8(%rbp)
	successor->prev->next = node;
   2cb45:	49 8b 44 24 08       	mov    0x8(%r12),%rax
   2cb4a:	48 89 28             	mov    %rbp,(%rax)
	successor->prev = node;
   2cb4d:	49 89 6c 24 08       	mov    %rbp,0x8(%r12)
   2cb52:	eb 0f                	jmp    2cb63 <add_event+0xb2>
	return (node == list->tail) ? NULL : node->next;
   2cb54:	4c 39 63 08          	cmp    %r12,0x8(%rbx)
   2cb58:	74 a9                	je     2cb03 <add_event+0x52>
   2cb5a:	4d 8b 24 24          	mov    (%r12),%r12
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   2cb5e:	4d 85 e4             	test   %r12,%r12
   2cb61:	eb 9e                	jmp    2cb01 <add_event+0x50>
}
   2cb63:	58                   	pop    %rax
   2cb64:	5b                   	pop    %rbx
   2cb65:	5d                   	pop    %rbp
   2cb66:	41 5c                	pop    %r12
   2cb68:	41 5d                	pop    %r13
   2cb6a:	c3                   	retq   

000000000002cb6b <register_events>:
{
   2cb6b:	41 57                	push   %r15
   2cb6d:	41 56                	push   %r14
   2cb6f:	49 89 fe             	mov    %rdi,%r14
   2cb72:	41 55                	push   %r13
   2cb74:	41 54                	push   %r12
   2cb76:	41 88 cd             	mov    %cl,%r13b
   2cb79:	55                   	push   %rbp
   2cb7a:	53                   	push   %rbx
	for (int ii = 0; ii < num_events; ii++) {
   2cb7b:	45 31 e4             	xor    %r12d,%r12d
{
   2cb7e:	48 89 d3             	mov    %rdx,%rbx
	int events_registered = 0;
   2cb81:	31 ed                	xor    %ebp,%ebp
{
   2cb83:	48 83 ec 18          	sub    $0x18,%rsp
   2cb87:	89 74 24 0c          	mov    %esi,0xc(%rsp)
	for (int ii = 0; ii < num_events; ii++) {
   2cb8b:	44 3b 64 24 0c       	cmp    0xc(%rsp),%r12d
   2cb90:	0f 8d d2 00 00 00    	jge    2cc68 <register_events+0xfd>
   2cb96:	e8 f7 f3 fd ff       	callq  bf92 <posix_irq_lock>
   2cb9b:	41 89 c7             	mov    %eax,%r15d
	switch (event->type) {
   2cb9e:	41 8a 46 19          	mov    0x19(%r14),%al
   2cba2:	83 e0 0f             	and    $0xf,%eax
   2cba5:	3c 02                	cmp    $0x2,%al
   2cba7:	74 0a                	je     2cbb3 <register_events+0x48>
   2cba9:	3c 04                	cmp    $0x4,%al
   2cbab:	74 17                	je     2cbc4 <register_events+0x59>
   2cbad:	fe c8                	dec    %al
   2cbaf:	75 5d                	jne    2cc0e <register_events+0xa3>
   2cbb1:	eb 22                	jmp    2cbd5 <register_events+0x6a>
		if (k_sem_count_get(event->sem) > 0U) {
   2cbb3:	49 8b 46 20          	mov    0x20(%r14),%rax
   2cbb7:	83 78 10 00          	cmpl   $0x0,0x10(%rax)
   2cbbb:	74 51                	je     2cc0e <register_events+0xa3>
			*state = K_POLL_STATE_SEM_AVAILABLE;
   2cbbd:	be 02 00 00 00       	mov    $0x2,%esi
   2cbc2:	eb 20                	jmp    2cbe4 <register_events+0x79>
		if (!k_queue_is_empty(event->queue)) {
   2cbc4:	49 8b 46 20          	mov    0x20(%r14),%rax
   2cbc8:	48 83 38 00          	cmpq   $0x0,(%rax)
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
   2cbcc:	be 04 00 00 00       	mov    $0x4,%esi
		if (!k_queue_is_empty(event->queue)) {
   2cbd1:	75 11                	jne    2cbe4 <register_events+0x79>
   2cbd3:	eb 39                	jmp    2cc0e <register_events+0xa3>
		if (event->signal->signaled != 0U) {
   2cbd5:	49 8b 46 20          	mov    0x20(%r14),%rax
			*state = K_POLL_STATE_SIGNALED;
   2cbd9:	be 01 00 00 00       	mov    $0x1,%esi
		if (event->signal->signaled != 0U) {
   2cbde:	83 78 10 00          	cmpl   $0x0,0x10(%rax)
   2cbe2:	74 2a                	je     2cc0e <register_events+0xa3>
	event->state |= state;
   2cbe4:	41 8b 56 18          	mov    0x18(%r14),%edx
	event->poller = NULL;
   2cbe8:	49 c7 46 10 00 00 00 	movq   $0x0,0x10(%r14)
   2cbef:	00 
	event->state |= state;
   2cbf0:	89 d0                	mov    %edx,%eax
   2cbf2:	81 e2 ff 0f fe ff    	and    $0xfffe0fff,%edx
   2cbf8:	c1 e8 0c             	shr    $0xc,%eax
   2cbfb:	83 e0 1f             	and    $0x1f,%eax
   2cbfe:	09 f0                	or     %esi,%eax
   2cc00:	c1 e0 0c             	shl    $0xc,%eax
   2cc03:	09 d0                	or     %edx,%eax
   2cc05:	41 89 46 18          	mov    %eax,0x18(%r14)
			poller->is_polling = false;
   2cc09:	c6 03 00             	movb   $0x0,(%rbx)
   2cc0c:	eb 46                	jmp    2cc54 <register_events+0xe9>
		} else if (!just_check && poller->is_polling) {
   2cc0e:	45 84 ed             	test   %r13b,%r13b
   2cc11:	75 41                	jne    2cc54 <register_events+0xe9>
   2cc13:	80 3b 00             	cmpb   $0x0,(%rbx)
   2cc16:	74 3c                	je     2cc54 <register_events+0xe9>
	switch (event->type) {
   2cc18:	41 8a 46 19          	mov    0x19(%r14),%al
   2cc1c:	83 e0 0f             	and    $0xf,%eax
   2cc1f:	3c 02                	cmp    $0x2,%al
   2cc21:	74 0e                	je     2cc31 <register_events+0xc6>
   2cc23:	3c 04                	cmp    $0x4,%al
   2cc25:	74 14                	je     2cc3b <register_events+0xd0>
   2cc27:	fe c8                	dec    %al
   2cc29:	75 23                	jne    2cc4e <register_events+0xe3>
		add_event(&event->signal->poll_events, event, poller);
   2cc2b:	49 8b 7e 20          	mov    0x20(%r14),%rdi
   2cc2f:	eb 12                	jmp    2cc43 <register_events+0xd8>
		add_event(&event->sem->poll_events, event, poller);
   2cc31:	49 8b 46 20          	mov    0x20(%r14),%rax
   2cc35:	48 8d 78 18          	lea    0x18(%rax),%rdi
   2cc39:	eb 08                	jmp    2cc43 <register_events+0xd8>
		add_event(&event->queue->poll_events, event, poller);
   2cc3b:	49 8b 46 20          	mov    0x20(%r14),%rax
   2cc3f:	48 8d 78 20          	lea    0x20(%rax),%rdi
		add_event(&event->signal->poll_events, event, poller);
   2cc43:	48 89 da             	mov    %rbx,%rdx
   2cc46:	4c 89 f6             	mov    %r14,%rsi
   2cc49:	e8 63 fe ff ff       	callq  2cab1 <add_event>
	event->poller = poller;
   2cc4e:	49 89 5e 10          	mov    %rbx,0x10(%r14)
			events_registered += 1;
   2cc52:	ff c5                	inc    %ebp
	posix_irq_unlock(key);
   2cc54:	44 89 ff             	mov    %r15d,%edi
	for (int ii = 0; ii < num_events; ii++) {
   2cc57:	41 ff c4             	inc    %r12d
   2cc5a:	49 83 c6 28          	add    $0x28,%r14
   2cc5e:	e8 39 f3 fd ff       	callq  bf9c <posix_irq_unlock>
   2cc63:	e9 23 ff ff ff       	jmpq   2cb8b <register_events+0x20>
}
   2cc68:	48 83 c4 18          	add    $0x18,%rsp
   2cc6c:	89 e8                	mov    %ebp,%eax
   2cc6e:	5b                   	pop    %rbx
   2cc6f:	5d                   	pop    %rbp
   2cc70:	41 5c                	pop    %r12
   2cc72:	41 5d                	pop    %r13
   2cc74:	41 5e                	pop    %r14
   2cc76:	41 5f                	pop    %r15
   2cc78:	c3                   	retq   

000000000002cc79 <k_poll_event_init>:
	event->type = type;
   2cc79:	40 88 f0             	mov    %sil,%al
   2cc7c:	40 8a 77 19          	mov    0x19(%rdi),%sil
	event->mode = mode;
   2cc80:	83 e2 01             	and    $0x1,%edx
	event->type = type;
   2cc83:	83 e0 0f             	and    $0xf,%eax
	event->poller = NULL;
   2cc86:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
   2cc8d:	00 
	event->obj = obj;
   2cc8e:	48 89 4f 20          	mov    %rcx,0x20(%rdi)
	event->type = type;
   2cc92:	83 e6 f0             	and    $0xfffffff0,%esi
   2cc95:	09 c6                	or     %eax,%esi
	event->mode = mode;
   2cc97:	8d 04 12             	lea    (%rdx,%rdx,1),%eax
	event->type = type;
   2cc9a:	40 88 77 19          	mov    %sil,0x19(%rdi)
	event->state = K_POLL_STATE_NOT_READY;
   2cc9e:	81 67 18 ff 0f fe ff 	andl   $0xfffe0fff,0x18(%rdi)
	event->mode = mode;
   2cca5:	8a 57 1a             	mov    0x1a(%rdi),%dl
   2cca8:	83 e2 fd             	and    $0xfffffffd,%edx
   2ccab:	09 c2                	or     %eax,%edx
   2ccad:	88 57 1a             	mov    %dl,0x1a(%rdi)
	event->unused = 0U;
   2ccb0:	66 83 67 1a 03       	andw   $0x3,0x1a(%rdi)
}
   2ccb5:	c3                   	retq   

000000000002ccb6 <z_impl_k_poll>:
{
   2ccb6:	41 56                	push   %r14
   2ccb8:	41 55                	push   %r13
	events_registered = register_events(events, num_events, poller,
   2ccba:	31 c9                	xor    %ecx,%ecx
{
   2ccbc:	41 54                	push   %r12
   2ccbe:	55                   	push   %rbp
   2ccbf:	49 89 d6             	mov    %rdx,%r14
   2ccc2:	53                   	push   %rbx
   2ccc3:	49 89 fc             	mov    %rdi,%r12
   2ccc6:	48 83 ec 20          	sub    $0x20,%rsp
   2ccca:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   2ccd1:	00 00 
   2ccd3:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
   2ccd8:	31 c0                	xor    %eax,%eax
	struct z_poller *poller = &_current->poller;
   2ccda:	48 8d 05 5f ae 22 00 	lea    0x22ae5f(%rip),%rax        # 257b40 <_kernel>
	events_registered = register_events(events, num_events, poller,
   2cce1:	48 85 d2             	test   %rdx,%rdx
   2cce4:	0f 94 c1             	sete   %cl
	struct z_poller *poller = &_current->poller;
   2cce7:	48 8b 58 10          	mov    0x10(%rax),%rbx
   2cceb:	48 8d 53 78          	lea    0x78(%rbx),%rdx
	poller->is_polling = true;
   2ccef:	c6 43 78 01          	movb   $0x1,0x78(%rbx)
	poller->mode = MODE_POLL;
   2ccf3:	c6 43 79 01          	movb   $0x1,0x79(%rbx)
	events_registered = register_events(events, num_events, poller,
   2ccf7:	e8 6f fe ff ff       	callq  2cb6b <register_events>
   2ccfc:	41 89 c5             	mov    %eax,%r13d
	return posix_irq_lock();
   2ccff:	e8 8e f2 fd ff       	callq  bf92 <posix_irq_lock>
	if (!poller->is_polling) {
   2cd04:	80 7b 78 00          	cmpb   $0x0,0x78(%rbx)
   2cd08:	89 c5                	mov    %eax,%ebp
   2cd0a:	75 18                	jne    2cd24 <z_impl_k_poll+0x6e>
		clear_event_registrations(events, events_registered, key);
   2cd0c:	89 c2                	mov    %eax,%edx
   2cd0e:	44 89 ee             	mov    %r13d,%esi
   2cd11:	4c 89 e7             	mov    %r12,%rdi
   2cd14:	e8 30 fc ff ff       	callq  2c949 <clear_event_registrations>
	posix_irq_unlock(key);
   2cd19:	89 ef                	mov    %ebp,%edi
		return 0;
   2cd1b:	31 db                	xor    %ebx,%ebx
   2cd1d:	e8 7a f2 fd ff       	callq  bf9c <posix_irq_unlock>
   2cd22:	eb 51                	jmp    2cd75 <z_impl_k_poll+0xbf>
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2cd24:	4d 85 f6             	test   %r14,%r14
	poller->is_polling = false;
   2cd27:	c6 43 78 00          	movb   $0x0,0x78(%rbx)
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2cd2b:	75 0e                	jne    2cd3b <z_impl_k_poll+0x85>
   2cd2d:	89 c7                	mov    %eax,%edi
		return -EAGAIN;
   2cd2f:	bb f5 ff ff ff       	mov    $0xfffffff5,%ebx
   2cd34:	e8 63 f2 fd ff       	callq  bf9c <posix_irq_unlock>
   2cd39:	eb 3a                	jmp    2cd75 <z_impl_k_poll+0xbf>
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   2cd3b:	48 8d 3d b3 23 23 00 	lea    0x2323b3(%rip),%rdi        # 25f0f5 <lock>
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   2cd42:	48 89 e2             	mov    %rsp,%rdx
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   2cd45:	4c 89 f1             	mov    %r14,%rcx
   2cd48:	89 c6                	mov    %eax,%esi
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   2cd4a:	48 89 14 24          	mov    %rdx,(%rsp)
   2cd4e:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   2cd53:	e8 8f ee ff ff       	callq  2bbe7 <z_pend_curr>
   2cd58:	89 c3                	mov    %eax,%ebx
	return posix_irq_lock();
   2cd5a:	e8 33 f2 fd ff       	callq  bf92 <posix_irq_lock>
	clear_event_registrations(events, events_registered, key);
   2cd5f:	4c 89 e7             	mov    %r12,%rdi
   2cd62:	89 c5                	mov    %eax,%ebp
   2cd64:	89 c2                	mov    %eax,%edx
   2cd66:	44 89 ee             	mov    %r13d,%esi
   2cd69:	e8 db fb ff ff       	callq  2c949 <clear_event_registrations>
	posix_irq_unlock(key);
   2cd6e:	89 ef                	mov    %ebp,%edi
   2cd70:	e8 27 f2 fd ff       	callq  bf9c <posix_irq_unlock>
}
   2cd75:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
   2cd7a:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
   2cd81:	00 00 
   2cd83:	89 d8                	mov    %ebx,%eax
   2cd85:	74 05                	je     2cd8c <z_impl_k_poll+0xd6>
   2cd87:	e8 b4 78 fd ff       	callq  4640 <__stack_chk_fail@plt>
   2cd8c:	48 83 c4 20          	add    $0x20,%rsp
   2cd90:	5b                   	pop    %rbx
   2cd91:	5d                   	pop    %rbp
   2cd92:	41 5c                	pop    %r12
   2cd94:	41 5d                	pop    %r13
   2cd96:	41 5e                	pop    %r14
   2cd98:	c3                   	retq   

000000000002cd99 <z_handle_obj_poll_events>:
	return list->head == list;
   2cd99:	48 8b 07             	mov    (%rdi),%rax

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   2cd9c:	48 39 c7             	cmp    %rax,%rdi
   2cd9f:	74 28                	je     2cdc9 <z_handle_obj_poll_events+0x30>
	node->prev->next = node->next;
   2cda1:	48 8b 08             	mov    (%rax),%rcx
   2cda4:	48 8b 50 08          	mov    0x8(%rax),%rdx
		(void) signal_poll_event(poll_event, state);
   2cda8:	48 89 c7             	mov    %rax,%rdi
   2cdab:	48 89 0a             	mov    %rcx,(%rdx)
	node->next->prev = node->prev;
   2cdae:	48 8b 08             	mov    (%rax),%rcx
   2cdb1:	48 89 51 08          	mov    %rdx,0x8(%rcx)
	node->next = NULL;
   2cdb5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	node->prev = NULL;
   2cdbc:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
   2cdc3:	00 
   2cdc4:	e9 14 fc ff ff       	jmpq   2c9dd <signal_poll_event>
}
   2cdc9:	c3                   	retq   

000000000002cdca <z_impl_k_poll_signal_raise>:
{
   2cdca:	41 54                	push   %r12
   2cdcc:	55                   	push   %rbp
   2cdcd:	41 89 f4             	mov    %esi,%r12d
   2cdd0:	53                   	push   %rbx
   2cdd1:	48 89 fb             	mov    %rdi,%rbx
   2cdd4:	48 83 ec 10          	sub    $0x10,%rsp
	return posix_irq_lock();
   2cdd8:	e8 b5 f1 fd ff       	callq  bf92 <posix_irq_lock>
	return list->head == list;
   2cddd:	48 8b 3b             	mov    (%rbx),%rdi
   2cde0:	89 c5                	mov    %eax,%ebp
	signal->result = result;
   2cde2:	44 89 63 14          	mov    %r12d,0x14(%rbx)
	signal->signaled = 1U;
   2cde6:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%rbx)
	if (!sys_dlist_is_empty(list)) {
   2cded:	48 39 fb             	cmp    %rdi,%rbx
   2cdf0:	75 0b                	jne    2cdfd <z_impl_k_poll_signal_raise+0x33>
	posix_irq_unlock(key);
   2cdf2:	89 c7                	mov    %eax,%edi
   2cdf4:	e8 a3 f1 fd ff       	callq  bf9c <posix_irq_unlock>
		return 0;
   2cdf9:	31 c0                	xor    %eax,%eax
   2cdfb:	eb 40                	jmp    2ce3d <z_impl_k_poll_signal_raise+0x73>
	node->prev->next = node->next;
   2cdfd:	48 8b 57 08          	mov    0x8(%rdi),%rdx
   2ce01:	48 8b 0f             	mov    (%rdi),%rcx
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   2ce04:	be 01 00 00 00       	mov    $0x1,%esi
   2ce09:	48 89 0a             	mov    %rcx,(%rdx)
	node->next->prev = node->prev;
   2ce0c:	48 8b 0f             	mov    (%rdi),%rcx
   2ce0f:	48 89 51 08          	mov    %rdx,0x8(%rcx)
	node->next = NULL;
   2ce13:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
	node->prev = NULL;
   2ce1a:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
   2ce21:	00 
   2ce22:	e8 b6 fb ff ff       	callq  2c9dd <signal_poll_event>
	z_reschedule(&lock, key);
   2ce27:	48 8d 3d c7 22 23 00 	lea    0x2322c7(%rip),%rdi        # 25f0f5 <lock>
   2ce2e:	89 ee                	mov    %ebp,%esi
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   2ce30:	89 44 24 0c          	mov    %eax,0xc(%rsp)
	z_reschedule(&lock, key);
   2ce34:	e8 31 e7 ff ff       	callq  2b56a <z_reschedule>
   2ce39:	8b 44 24 0c          	mov    0xc(%rsp),%eax
}
   2ce3d:	48 83 c4 10          	add    $0x10,%rsp
   2ce41:	5b                   	pop    %rbx
   2ce42:	5d                   	pop    %rbp
   2ce43:	41 5c                	pop    %r12
   2ce45:	c3                   	retq   

000000000002ce46 <z_heap_aligned_alloc>:
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
   2ce46:	48 83 c2 08          	add    $0x8,%rdx
   2ce4a:	72 21                	jb     2ce6d <z_heap_aligned_alloc+0x27>
#include <string.h>
#include <sys/math_extras.h>
#include <sys/util.h>

static void *z_heap_aligned_alloc(struct k_heap *heap, size_t align, size_t size)
{
   2ce4c:	53                   	push   %rbx
	 * boundary without wasting any memory.
	 */
	if (size_add_overflow(size, sizeof(heap_ref), &size)) {
		return NULL;
	}
	__align = align | sizeof(heap_ref);
   2ce4d:	48 83 ce 08          	or     $0x8,%rsi

	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
   2ce51:	31 c9                	xor    %ecx,%ecx
   2ce53:	48 89 fb             	mov    %rdi,%rbx
   2ce56:	e8 3f dd ff ff       	callq  2ab9a <k_heap_aligned_alloc>
	if (mem == NULL) {
   2ce5b:	48 85 c0             	test   %rax,%rax
   2ce5e:	75 04                	jne    2ce64 <z_heap_aligned_alloc+0x1e>
		return NULL;
   2ce60:	31 c0                	xor    %eax,%eax
   2ce62:	eb 07                	jmp    2ce6b <z_heap_aligned_alloc+0x25>
		return NULL;
	}

	heap_ref = mem;
	*heap_ref = heap;
   2ce64:	48 89 18             	mov    %rbx,(%rax)
	mem = ++heap_ref;
   2ce67:	48 83 c0 08          	add    $0x8,%rax
	__ASSERT(align == 0 || ((uintptr_t)mem & (align - 1)) == 0,
		 "misaligned memory at %p (align = %zu)", mem, align);

	return mem;
}
   2ce6b:	5b                   	pop    %rbx
   2ce6c:	c3                   	retq   
		return NULL;
   2ce6d:	31 c0                	xor    %eax,%eax
}
   2ce6f:	c3                   	retq   

000000000002ce70 <k_free>:

void k_free(void *ptr)
{
	struct k_heap **heap_ref;

	if (ptr != NULL) {
   2ce70:	48 85 ff             	test   %rdi,%rdi
   2ce73:	74 0d                	je     2ce82 <k_free+0x12>
		heap_ref = ptr;
		ptr = --heap_ref;
   2ce75:	48 8d 77 f8          	lea    -0x8(%rdi),%rsi
		k_heap_free(*heap_ref, ptr);
   2ce79:	48 8b 7f f8          	mov    -0x8(%rdi),%rdi
   2ce7d:	e9 a8 dd ff ff       	jmpq   2ac2a <k_heap_free>
	}
}
   2ce82:	c3                   	retq   

000000000002ce83 <k_aligned_alloc>:

K_HEAP_DEFINE(_system_heap, CONFIG_HEAP_MEM_POOL_SIZE);
#define _SYSTEM_HEAP (&_system_heap)

void *k_aligned_alloc(size_t align, size_t size)
{
   2ce83:	48 89 f2             	mov    %rsi,%rdx
		"align must be a multiple of sizeof(void *)");

	__ASSERT((align & (align - 1)) == 0,
		"align must be a power of 2");

	return z_heap_aligned_alloc(_SYSTEM_HEAP, align, size);
   2ce86:	48 89 fe             	mov    %rdi,%rsi
   2ce89:	48 8d 3d 88 d7 20 00 	lea    0x20d788(%rip),%rdi        # 23a618 <_k_mem_slab_list_end>
   2ce90:	e9 b1 ff ff ff       	jmpq   2ce46 <z_heap_aligned_alloc>

000000000002ce95 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
   2ce95:	55                   	push   %rbp
   2ce96:	53                   	push   %rbx
   2ce97:	48 89 f5             	mov    %rsi,%rbp
   2ce9a:	48 89 fb             	mov    %rdi,%rbx
   2ce9d:	48 83 ec 08          	sub    $0x8,%rsp
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
   2cea1:	e8 79 f1 ff ff       	callq  2c01f <k_is_in_isr>
   2cea6:	84 c0                	test   %al,%al
   2cea8:	75 19                	jne    2cec3 <z_thread_aligned_alloc+0x2e>
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
   2ceaa:	48 8d 05 8f ac 22 00 	lea    0x22ac8f(%rip),%rax        # 257b40 <_kernel>
   2ceb1:	48 8b 40 10          	mov    0x10(%rax),%rax
   2ceb5:	48 8b b8 80 00 00 00 	mov    0x80(%rax),%rdi
	}

	if (heap) {
   2cebc:	48 85 ff             	test   %rdi,%rdi
   2cebf:	75 09                	jne    2ceca <z_thread_aligned_alloc+0x35>
   2cec1:	eb 15                	jmp    2ced8 <z_thread_aligned_alloc+0x43>
		heap = _SYSTEM_HEAP;
   2cec3:	48 8d 3d 4e d7 20 00 	lea    0x20d74e(%rip),%rdi        # 23a618 <_k_mem_slab_list_end>
	} else {
		ret = NULL;
	}

	return ret;
}
   2ceca:	59                   	pop    %rcx
		ret = z_heap_aligned_alloc(heap, align, size);
   2cecb:	48 89 ea             	mov    %rbp,%rdx
   2cece:	48 89 de             	mov    %rbx,%rsi
}
   2ced1:	5b                   	pop    %rbx
   2ced2:	5d                   	pop    %rbp
		ret = z_heap_aligned_alloc(heap, align, size);
   2ced3:	e9 6e ff ff ff       	jmpq   2ce46 <z_heap_aligned_alloc>
}
   2ced8:	5a                   	pop    %rdx
   2ced9:	31 c0                	xor    %eax,%eax
   2cedb:	5b                   	pop    %rbx
   2cedc:	5d                   	pop    %rbp
   2cedd:	c3                   	retq   

000000000002cede <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *p1, void *unused2, void *unused3)
{
   2cede:	55                   	push   %rbp
   2cedf:	53                   	push   %rbx
   2cee0:	48 89 fb             	mov    %rdi,%rbx
   2cee3:	48 83 ec 08          	sub    $0x8,%rsp
	return posix_irq_lock();
   2cee7:	e8 a6 f0 fd ff       	callq  bf92 <posix_irq_lock>
	while (true) {
		/* Lock interrupts to atomically check if to_abort is non-NULL,
		 * and if so clear it
		 */
		int key = arch_irq_lock();
		struct k_thread *to_abort = cpu->pending_abort;
   2ceec:	48 8b 6b 20          	mov    0x20(%rbx),%rbp

		if (to_abort) {
   2cef0:	48 85 ed             	test   %rbp,%rbp
   2cef3:	74 25                	je     2cf1a <idle+0x3c>
	posix_irq_unlock(key);
   2cef5:	89 c7                	mov    %eax,%edi
			cpu->pending_abort = NULL;
   2cef7:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
   2cefe:	00 
   2ceff:	e8 98 f0 fd ff       	callq  bf9c <posix_irq_unlock>
			 * is continued below.
			 */
			LOG_DBG("idle %p aborting thread %p",
				_current, to_abort);

			z_thread_single_abort(to_abort);
   2cf04:	48 89 ef             	mov    %rbp,%rdi
   2cf07:	e8 a6 ea ff ff       	callq  2b9b2 <z_thread_single_abort>
	return posix_irq_lock();
   2cf0c:	e8 81 f0 fd ff       	callq  bf92 <posix_irq_lock>
	(void) z_reschedule_irqlock(arch_irq_lock());
   2cf11:	89 c7                	mov    %eax,%edi
   2cf13:	e8 7a e6 ff ff       	callq  2b592 <z_reschedule_irqlock>
			 * in order to abort the thread, and we now need to
			 * figure out what to do next, it's not necessarily
			 * the case that there are no other runnable threads.
			 */
			z_reschedule_unlocked();
			continue;
   2cf18:	eb cd                	jmp    2cee7 <idle+0x9>
		k_busy_wait(100);
		k_yield();
#else

#ifdef CONFIG_SYS_CLOCK_EXISTS
		int32_t ticks = z_get_next_timeout_expiry();
   2cf1a:	e8 40 f7 ff ff       	callq  2c65f <z_get_next_timeout_expiry>
		 * that the system should not enter a tickless idle for
		 * periods less than that.  This seems... silly, given that it
		 * saves no power and does not improve latency.  But it's an
		 * API we need to honor...
		 */
		z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   2cf1f:	83 f8 02             	cmp    $0x2,%eax
   2cf22:	7f 05                	jg     2cf29 <idle+0x4b>
   2cf24:	b8 01 00 00 00       	mov    $0x1,%eax
   2cf29:	be 01 00 00 00       	mov    $0x1,%esi
   2cf2e:	89 c7                	mov    %eax,%edi
   2cf30:	e8 50 f7 ff ff       	callq  2c685 <z_set_timeout_expiry>
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
   2cf35:	e8 72 d5 fd ff       	callq  a4ac <arch_cpu_idle>
   2cf3a:	eb ab                	jmp    2cee7 <idle+0x9>

000000000002cf3c <_OffsetAbsSyms>:

#if defined(CONFIG_FPU_SHARING)
GEN_OFFSET_SYM(_thread_arch_t, excNestCount);
#endif

GEN_ABS_SYM_END
   2cf3c:	c3                   	retq   

Disassembly of section .fini:

000000000002cf40 <_fini>:
   2cf40:	48 83 ec 08          	sub    $0x8,%rsp
   2cf44:	48 83 c4 08          	add    $0x8,%rsp
   2cf48:	c3                   	retq   
